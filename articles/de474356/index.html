<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎛️ 👨🏾‍⚖️ 🎎 ThingJS v1.0-alpha 🧚🏽 🚁 👥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten zwei Jahren habe ich meine eigene IoT- Plattform entwickelt und heute bin ich bereit, ihre Alpha-Version zu zeigen. 


 Zusammen mit ei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ThingJS v1.0-alpha</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474356/"><p><img src="https://habrastorage.org/webt/hd/vu/kq/hdvukqu1cfju8ygby3otuzmptmu.png"></p><br><p> In den letzten zwei Jahren habe ich meine eigene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IoT-</a> Plattform entwickelt und heute bin ich bereit, ihre Alpha-Version zu zeigen. </p><br><p>  Zusammen mit einem Partner erstellen und unterstützen wir IoT-Geräte.  Wir haben im Rahmen dieser Aktivität mehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">als einen Rechenschuppen</a> abgebaut.  ThingJS wurde nicht so sehr aus Begierde als vielmehr aus dem Bedürfnis heraus geboren, uns das Leben zu erleichtern, sondern gleichzeitig, hoffe ich, für Sie. </p><br><p>  Der Artikel wird für Menschen interessant sein, die dem Thema IoT nahe stehen und in diesem Bereich bereits etwas unternommen haben.  Ein wichtiger Punkt wird sein, dass die Plattform (plötzlich) JavaScript-Entwickler interessieren sollte, wie  Diese Sprache wird als Grundlage für die Plattform gewählt.  Natürlich haben C / C ++ - Entwickler auch etwas zu lesen. </p><br><p>  Zuerst werde ich darüber sprechen, auf welche Hauptprobleme wir bei der Entwicklung von IoT-Geräten gestoßen sind, dann werde ich beschreiben, wie die Plattform damit umgeht, und am Ende ist alles langweilig: das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> , der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">technische Teil,</a> und Sie können alles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">live</a> berühren. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IoT-Probleme</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurzhandproblem</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Problem des Turms von Babel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stockholm-Syndrom-Problem</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lösungen für Probleme</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gemeinschaft, Sucht, Modisch, Jugend.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Versprechen und Abstraktionen.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Virtuelle IoT-Geräte</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Technische Informationen</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ThingJS-Anwendungsstruktur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Technologie-Stack</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen der Entwicklungsumgebung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützte Geräte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleich mit Wettbewerbern</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnellstart</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich muss nur zuschauen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich möchte es versuchen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blink App</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Montage von der Quelle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungszusammensetzung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">manifest.json</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Komponentenblock</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Skripte blockieren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Block "erfordert"</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">blink.js</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blink.vue</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">scripts / blink.js</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstellenimplementierung</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklungsumgebung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungsentwicklung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Firmware-Entwicklung</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was weiter?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenzen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FAQ</a> </li></ul></div></div><br><h1 id="problemy-iot--anchorproblemsanchor">  IoT-Probleme: <a name="problems"></a></h1><br><h2 id="--problema-korotkih-ruk-anchorshort-handsanchor">  - Das Problem der kurzen Arme <a name="short-hands"></a></h2><br><p>  IoT basiert auf einem Ökosystem.  Die Entwicklung des Konzepts und der technischen Architektur ist wirklich viel Arbeit.  Darüber hinaus müssen Sie noch eine Reihe von Firmware für heterogene Geräte entwickeln.  Transport für den Datenaustausch zwischen Geräten nach verschiedenen physikalischen und logischen Prinzipien erfinden und implementieren.  Erweitern Sie die Cloud-Ressourcen.  Benutzeroberflächen ausarbeiten.  Usw.  usw. </p><br><p>  Selbst wenn ein einzelner Spezialist über die erforderlichen Fähigkeiten verfügt, hat er einfach nicht genug Zeit (Hände), um eine solche Idee umzusetzen.  Während er es schneiden wird, wird sie obsolet. </p><br><h2 id="--problema-vavilonskoy-bashni-anchortoweranchor">  - Das Problem des Turms von Babel <a name="tower"></a></h2><br><p>  Die Entwicklung eines vollwertigen IoT-Ökosystems erfordert einen sehr breiten technologischen Stapel.  Ein Full Stack im IoT zu sein ist unkompliziert ... schwierig.  Brauche überall Erfahrung.  Nicht alle können sich eines so breiten Wissens- und sogar Erfahrungsspektrums rühmen.  Und hier geht es nicht um geistige Fähigkeiten.  Dies ist eine offensichtliche Schlussfolgerung aus dem Kurzhandproblem. </p><br><p>  Um ein wirklich wohlhabendes Ökosystem zu schaffen, müssen viele ziemlich enge Spezialisten arbeiten, die jedoch über fundierte Kenntnisse auf ihrem Gebiet verfügen.  Diese Spezialisten sprechen verschiedene Sprachen, verwenden unterschiedliche Muster und verstehen elementare Begriffe häufig auf unterschiedliche Weise.  Und da IoT auf Geräten mit begrenzten Ressourcen basiert, ist eine effektive Kommunikation entscheidend für die Verwirklichung der beabsichtigten Ziele. </p><br><h2 id="--problema-stokgolmskogo-sindroma-anchorsindromanchor">  - Das Problem des Stockholm-Syndroms <a name="sindrom"></a></h2><br><p>  Heute gibt es Anbieter, die ihre Ökosysteme entwickeln.  Dies sind Google, Microsoft, Yandex, Megaphone, MTS usw.  Einige von ihnen ermöglichen es Ihnen, Ihre eigenen Dinge zu ihren Bedingungen in ihre Ökosysteme zu integrieren.  Dies deckt weitgehend die oben beschriebenen Probleme ab.  Aber es schafft eine neue - Sucht.  Und Anbieter möchten die Bedingungen für die Integration ändern.  Und noch mehr, es gibt keine Frage der Selbstverwirklichung in diesem Paradigma. </p><br><h1 id="resheniya-problem-anchorsolutionsanchor">  Lösungen für Probleme: <a name="solutions"></a></h1><br><h2 id="--soobschestvo-zavisimosti-modno-molodezhno-anchorcommunityanchor">  - Gemeinschaft, Sucht, Mode, Jugend <a name="community"></a></h2><br><p>  Die oben beschriebenen Probleme blockieren tatsächlich den Zugang von Einzelpersonen zur IoT-Entwicklung.  Die Entwicklung der Plattform wurde mit dem Bewusstsein dieser Probleme gestartet.  Der Grundstein für die Entwicklung der Plattform durch die Community wurde gelegt. </p><br><p>  Um diese Idee zu verwirklichen, verfügt die Plattform natürlich über eine offene Codebasis und ein Abhängigkeitsparadigma auf allen Ebenen. </p><br><p>  Wenn Sie nicht wissen, was Sucht ist, ist es Zeit, sie kennenzulernen.  Wenn Sie jedoch versuchen, dies sehr einfach zu erklären, hängt das Modul, das Sie entwickeln, möglicherweise von einem anderen Modul ab, das Ihr Freund schreibt.  Und Sie werden über eine vordefinierte Schnittstelle auf das Modul zugreifen. </p><br><p>  Gleichzeitig können viele Menschen unabhängig voneinander ihre eigenen Plattformkomponenten entwickeln und vorhandene, die von jemandem entwickelt wurden, wiederverwenden.  Dies löst das Problem der kurzen Hände grundlegend. </p><br><p><img src="https://habrastorage.org/webt/zt/xk/ok/ztxkokx7yqcgzwymgrq3o-ueah4.png"></p><br><p>  Auch das Problem des „Turms von Babel“ wird gelöst.  Abhängigkeiten werden so erstellt, dass die verschiedenen Ebenen der Plattform, die in verschiedenen Sprachen entwickelt wurden, einen vorgegebenen Mechanismus zum Erstellen von Abhängigkeiten untereinander haben. </p><br><p>  Ein C-Entwickler kann beispielsweise eine vorgefertigte Front-End-Komponente nutzen, indem er ihm die erforderliche Schnittstelle zur Verfügung stellt.  Im Gegenteil, der Front-End-Entwickler kann eine in C geschriebene vorgefertigte Komponente verwenden  Jeder wird das tun, was er am besten weiß. </p><br><h2 id="--bolshe-obeschaniy-i-abstrakciy-anchorpromisesanchor">  - Mehr Versprechen und Abstraktionen <a name="promises"></a></h2><br><p>  Das Kommunikationsprotokoll zwischen Geräten ist nicht definiert.  Stattdessen gibt es eine Abstraktion - einen Datenbus.  Das Gerät kann ein Ereignis an den Bus senden oder den Bus abhören.  Es ist nicht klar, wer im Voraus in den Bus schreibt und wer empfängt.  Und wenn auch.  Asynchroner Datenaustausch und Lieferung werden nicht garantiert.  Im Allgemeinen - Hölle.  Keine Panik.  So konzipiert. </p><br><p>  Die Sache ist, dass das Ökosystem eine Gruppe von separaten, autarken Geräten ist.  Einige Geräte sind möglicherweise zu keinem Zeitpunkt verfügbar.  Aus verschiedenen Gründen.  Es ist nicht das beste Szenario, die Aktivität anderer Geräte zu stoppen, wenn ein Teil nicht verfügbar ist.  Es ist notwendig, das zu legalisieren, was nicht verhindert werden kann. </p><br><p>  Die Plattform implementiert das Paradigma von Versprechungen zur Bereitstellung von Veranstaltungen.  Das erste Gerät schließt sich dem Versprechen des zweiten an, ihm Informationen zu geben.  Es gibt jedoch keine Garantien.  Der Abonnent muss entscheiden, was zu tun ist, wenn ihm Daten nicht rechtzeitig zur Verfügung gestellt werden. </p><br><p>  Das Problem der synchronen Kommunikation wird gelöst, indem Ereignisse über den Bus mit Verbindungen zu synchronen Kanälen übertragen werden.  Das Synchronkanalprotokoll wird durch die Art des Ereignisses selbst bestimmt.  Sie können beispielsweise ein Ereignis mit dem Typ "do-render-video-stream" senden und IP-WEB-Kameras als Nutzdaten senden.  Somit weiß der Empfänger, dass Sie den Videostream von der angegebenen Adresse abspielen müssen. </p><br><p><img src="https://habrastorage.org/webt/3s/th/vn/3sthvnlojthoq_gh9uqirnbqedg.png"></p><br><p>  Aber wie funktioniert der Bus physisch?  Die Umsetzung des Busses liegt bei der Gemeinde.  Der Reifen dehnt sich mit dem Transport aus, den Ihr Projekt benötigt.  Beispielsweise wird ein Ereignis über http empfangen und über UART weitergeleitet.  Für alle Elemente des Ökosystems wird sich äußerlich nichts ändern. </p><br><h1 id="--virtualnye-iot-ustroystva-anchorvirtualanchor">  - Virtuelle IoT-Geräte <a name="virtual"></a></h1><br><p>  Für ThingJS ist eine Sache nicht nur eine physische Sache, sondern auch eine spezielle Anwendung - eine virtuelle Sache.  Darüber hinaus kann eine physische Sache mehrere virtuelle Dinge (Anwendungen) enthalten, die die Ressourcen einer physischen Sache nutzen. </p><br><p>  Mit diesem Ansatz können Sie die Interaktion zwischen dem bedingten Backend (Controller / Server / Cloud usw.) und dem Frontend (Browser, Anwendung usw.) sowie b2b und sogar f2f vereinheitlichen.  Erstellen Sie eine Matrix, keine Hierarchie von Interaktionen. </p><br><p><img src="https://habrastorage.org/webt/-l/vg/bd/-lvgbdkme-d81bzhaqpqjwhcnly.png"></p><br><p>  Ein einfaches Beispiel wäre eine WEB-Kamera, die an sich eine virtuelle Sache hat - eine Benutzeroberfläche.  Wenn der Benutzer zur Adresse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://192.168.4.1 wechselt</a> , wird die WEB-Seite geöffnet, auf der das virtuelle Objekt zu "leben" beginnt.  Die Kamera (physische Sache) und die Seite (virtuelle Sache) werden automatisch zu einem Ökosystem, in dem ein einheitlicher Datenbus verfügbar ist.  Dadurch kommuniziert das virtuelle Ding mit dem physischen.  In diesem Fall: Das physische Objekt teilt dem virtuellen Objekt über den Bus die Adresse des Videostreams, seinen Status usw. mit, und das virtuelle Objekt zeigt dem Benutzer das Video und gibt dem physischen Objekt die erforderlichen Befehle. </p><br><p>  Die logische Fortsetzung ist die Fähigkeit, virtuelle Dinge in den Clouds zu hosten und in ein gemeinsames Ökosystem einzubeziehen.  Auf diese Weise können Sie virtuelle Geräte mit riesigen Ressourcen erstellen, die Probleme lösen, die beispielsweise für KI verfügbar sind. </p><br><p>  Sie können solche Geräte selbst erstellen oder bereits erstellte verwenden.  Das Stockholm-Syndrom ist besiegt.  Sie bestimmen selbst, wovon Ihr Projekt abhängt und wie Sie es entwickeln werden. </p><br><h1 id="tehnicheskaya-informaciya-anchortech-infoanchor">  Technische Informationen <a name="tech-info"></a></h1><br><h2 id="struktura-prilozheniya-thingjs-anchorapp-structanchor">  ThingJS-Anwendungsstruktur <a name="app-struct"></a></h2><br><p><img src="https://habrastorage.org/webt/sz/-w/ul/sz-wuldlbfp7z2kcc1vgrqov_ta.png"></p><br><h2 id="stek-tehnologiy-anchortech-stackanchor">  Technologie-Stack <a name="tech-stack"></a></h2><br><p>  Die ausgewählte Hardwareplattform ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ESP32-</a> Controller.  Die Plattform wurde als hardwareunabhängig konzipiert.  Leider war keine Zeit für die Partitionierung auf anderen Geräten. </p><br><p>  Für die Entwicklung der Firmware werden die empfohlenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Espressif-Tools verwendet</a> .  Die Firmware wurde in C entwickelt. Der cmake-Sammler.  Das Projekt verwendet das Komponentenkonzept, das ebenfalls von Espressif gefördert wird. </p><br><p>  Zusätzlich zu esp-idf wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mongoose WEB Server</a> sowie ein modifizierter JavaScript-Interpreter Mongoose <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mJS verwendet</a> . </p><br><p>  Für die Anwendungsentwicklung wird JavaScript mit dem VUE 2-Framework verwendet. Erstellen Sie Anwendungen mit Webpack.  Der Paketmanager ist npm.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VUE CLI wurde</a> als Basis für die Entwicklungsumgebung verwendet. </p><br><p>  Um die Anwendungsvisualisierung zu standardisieren und die Kreativität der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benutzeroberfläche zu</a> lindern, ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vuetifyjs-</a> Paket in der Plattform enthalten. </p><br><h2 id="vozmozhnosti-sredy-razrabotki-anchordev-skilsanchor">  Funktionen der Entwicklungsumgebung <a name="dev-skils"></a></h2><br><p>  Für JavaScript-Entwickler (virtuelle Dinge): </p><br><ul><li>  Empfohlene IDE - WEBStorm; </li><li>  Alle Gewinne, die VUE CLI und IDE bringen; </li><li>  Systeminternes Debuggen von Anwendungen (mJS-Debugger auf dem Controller); </li><li>  MJS implementiert den Debugger-Befehl, mit dem Sie den Debugger an einer beliebigen Stelle aufrufen können. </li><li>  Hot Upload aktualisierter Dateien auf den Controller während der Entwicklung (JavaScript-Entwickler können ohne diese Funktion bereits nicht leben); </li><li>  Die Laufzeitentwicklung wird mit einem echten Controller gepaart.  Sie programmieren und sehen genau dort das Ergebnis auf der Hardware. </li><li>  Konfigurierte ESLint zum Verständnis von Plattformobjekten. </li></ul><br><p>  Für C-Entwickler (physische Dinge): </p><br><ul><li>  Empfohlene IDE - CLion; </li><li>  Alle Gewinne esp-idf und IDE; </li><li>  Die Plattform ist im Rahmen des esp-idf-Konzepts in Komponenten unterteilt. </li><li>  Einfache Integration in die native Komponentenplattform. </li></ul><br><h2 id="podderzhivaemye-ustroystva-anchorhw-supportedanchor">  Unterstützte Geräte <a name="hw-supported"></a></h2><br><p>  Derzeit wird nur ESP32 unterstützt.  Der Chip ist aufgrund seiner Verfügbarkeit mit erstaunlichen technischen Eigenschaften beliebt.  Auf dieser Grundlage wurden viele vorgefertigte IoT-Geräte erstellt, die unter ThingJS verwendet werden können. </p><br><h2 id="sravnenie-s-konkurentami-anchorvs-otheranchor">  Vergleich mit Mitbewerbern <a name="vs-other"></a></h2><br><p>  Ich schlage vor, nicht so weit zu rennen.  Ich wage es nicht, kommerzielle Plattformen als Konkurrenten zu bezeichnen.  Und Open Source erscheint und verschwindet, ohne eine merkliche Spur zu hinterlassen.  Daher habe ich keinen Vergleich gemacht.  Wenn jedoch jemand einen Wunsch hat, bin ich bereit, das Ergebnis seiner Arbeit hier zu veröffentlichen. </p><br><h1 id="bystryy-start-anchorget-startedanchor">  Schnellstart <a name="get-started"></a></h1><br><h2 id="mne-tolko-posmotret-anchorvideoanchor">  Ich muss nur zuschauen <a name="video"></a></h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dhPIAL2N0MQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="hochu-poprobovat-anchortouch-itanchor">  Ich möchte es versuchen <a name="touch-it"></a></h2><br><p>  Um die Plattform auf echter Hardware zu testen, benötigen Sie jedes auf ESP32 basierende Gerät mit Flash 4 MB und die Fähigkeit, es über USB zu flashen.  Die ESP32-Kernplatine v2 ist jedoch am besten geeignet. </p><br><p><img src="https://habrastorage.org/webt/ik/qw/jy/ikqwjyhkejf5t5kwdmbn20lq1ko.png"></p><br><p>  Sie können solche Dinge problemlos bei Aliexpress oder Ebay kaufen.  Darüber hinaus gibt es in Russland sogar Repräsentanzen.  Ich persönlich kaufe in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">St. Petersburg</a> . </p><br><p>  Um den Betrieb der Testanwendung „Blink“ zu testen, müssen Sie eine LED anschließen.  Einige Versionen der Karten verfügen über eine vorinstallierte LED, die an GPIO2 angeschlossen ist.  Wenn Sie ein solches Board haben, können Sie nichts tun.  Das Blinken sollte ohne unnötige Bewegungen funktionieren.  Wenn Sie nur eine Diode (Netzteil) haben, müssen Sie die Anzeigediode selbst anschließen.  Das ist nichts kompliziertes. </p><br><p>  Sie benötigen eine Anzeige-LED und einen Widerstand von 1 bis 5K. </p><br><p><img src="https://habrastorage.org/webt/ey/vg/e7/eyvge7dfugct2jtk2u2rq8wkpqs.png"></p><br><p>  Sie müssen nur noch das Benutzerpaket auf dem Gerät bereitstellen.  Sie können es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier nehmen</a> .  Dort finden Sie Anweisungen zur Bereitstellung. </p><br><h2 id="blink-prilozhenie-anchorblinkanchor">  Blink App <a name="blink"></a></h2><br><h3 id="sborka-iz-ishodnikov-anchorblink-bouldanchor">  Montage von der Quelle <a name="blink-bould"></a></h3><br><p>  Blink ist ein einfaches Ökosystem, das aus einem virtuellen Gerät, das die Benutzeroberfläche implementiert, und einem physischen Gerät besteht.  Ein virtuelles Gerät startet von einem physischen Gerät, wenn Sie über einen Browser darauf zugreifen. </p><br><p>  Das Skript ist einfach.  Bei der Installation der Anwendung auf einem physischen Gerät beginnt die LED (zuvor angeschlossen) mit einer Frequenz von 1 Hz zu blinken.  Der Benutzer kann das Blinken der Diode über die Schnittstelle ein- oder ausschalten.  Sie können das Video im Abschnitt "Ich kann nur sehen" ansehen. </p><br><p>  Quellen befinden sich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> src / applications / blink.  Um Blink zu sammeln und damit zu spielen, benötigen Sie nur dieses Repository.  Stellen Sie sicher, dass Sie git, npm und nodejs bereits installiert haben. </p><br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch alpha https://github.com/rpiontik/ThingJS-front <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ThingJS-front npm install npm run build</code> </pre> <br><p>  Wenn alles reibungslos verlief, erhalten Sie Folgendes: </p><br><p><img src="https://habrastorage.org/webt/7b/a-/n8/7ba-n8_6y8hng41irp6jttozxks.png"></p><br><p>  Herzlichen Glückwunsch!  Sie haben Ihre erste ThingJS-App erstellt.  Sie finden es im Ordner dist / apps / blink und versuchen sofort, es auf dem Gerät zu installieren, basierend auf dem Video aus dem Abschnitt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Ich schaue nur"</a> . </p><br><h3 id="sostav-prilozheniya-anchorblink-containsanchor">  Anwendungszusammensetzung <a name="blink-contains"></a></h3><br><div class="scrollable-table"><table><tbody><tr><th>  Datei </th><th>  Beschreibung </th></tr><tr><td>  scripts / blink.js </td><td>  Das Skript, das auf dem Controller installiert ist </td></tr><tr><td>  blink.js </td><td>  Einhängepunkt der Anwendungskomponente </td></tr><tr><td>  Blink.vue </td><td>  VUE-Komponente, die die Benutzeroberfläche implementiert </td></tr><tr><td>  favicon.svg </td><td>  Anwendungssymbol </td></tr><tr><td>  langs.js </td><td>  Application Language Pack </td></tr><tr><td>  manifest.json </td><td>  Anwendungsmanifest </td></tr></tbody></table></div><br><p>  Sie können sich mit allen Details der Anwendung selbst vertraut machen.  Ich werde mich auf mehrere Dateien konzentrieren. </p><br><h3 id="manifestjson-anchorblink-manifestanchor">  manifest.json <a name="blink-manifest"></a></h3><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Blink"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"vendor"</span></span> : <span class="hljs-string"><span class="hljs-string">"rpiontik"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"subversion"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"patch"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"en"</span></span>: <span class="hljs-string"><span class="hljs-string">"Blink Example"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"components"</span></span>: {...}, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: {...}, <span class="hljs-attr"><span class="hljs-attr">"requires"</span></span> : {...} }</code> </pre> <br><p>  Wie der Name der Datei angibt, ist dies das Anwendungsmanifest.  Es enthält allgemeine Metadaten, deren Zweck leicht zu erraten ist.  Zusätzlich gibt es drei wichtige Blöcke.  Schauen wir sie uns genauer an: </p><br><h4 id="blok-components-anchorblink-manifest-componentsanchor">  Komponentenblock <a name="blink-manifest-components"></a></h4><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"components"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"blink-app"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"blink.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"intent_filter"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"thingjs.intent.action.MAIN"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"category"</span></span>: <span class="hljs-string"><span class="hljs-string">"thingjs.intent.category.LAUNCH"</span></span> } ] } }</code> </pre> <br><p>  Der Block beschreibt die gesamte Komponentenbasis der Anwendung.  Das Feld „source“ zeigt auf den Mount-Punkt der Komponente (siehe blink.js) und ist der Assembly-Einstiegspunkt für das Webpack ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eintrag</a> ).  Somit wird jede Komponente in einem separaten Bundle ausgegeben.  Dieses Bundle wird nach Bedarf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geladen</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lazy Load</a> ). </p><br><p>  Eine wichtige Struktur ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">intent_filter</a> .  Wenn Sie zufällig für Android programmieren, werden Sie etwas finden, das Ihnen vertraut ist.  Und machen Sie keinen Fehler.  Das System generiert Schnittstellen- und Serviceereignisse, die die Komponente abonniert.  Wenn ein Ereignis eintritt, das die Filterbedingungen erfüllt, wird die Komponente geladen und die Steuerung an den Einhängepunkt übertragen. </p><br><p>  In diesem Fall abonniert die Komponente "Blink-App" das Startereignis der Hauptschnittstellenkomponente der Anwendung.  Wenn der Launcher die Anwendung startet, wird diese Komponente eingeführt. </p><br><p>  Wenn Sie das Manifest durch Ändern der Zeile ändern </p><br><p> <code>thingjs.intent.category.LAUNCH &gt;&gt; thingjs.intent.category.PREFERENCE</code> </p> <br><p>  Nach der Montage und Installation stellt sich heraus, dass die Anwendung auf dem Desktop nicht mehr geöffnet ist.  Im Abschnitt "Einstellungen" wurde jedoch eine neue "Kachel" angezeigt.  Gleichzeitig hat sich funktional nichts geändert. </p><br><p>  Daher haben wir dem Launcher mitgeteilt, dass diese Komponente ein Schnittstellenelement zum Anpassen unserer Anwendung ist.  Und diese Komponente begann in den Einstellungen zu erscheinen. </p><br><h4 id="blok-scripts-anchorblink-manifest-scriptsanchor">  Skripte blockieren <a name="blink-manifest-scripts"></a></h4><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"entry"</span></span>: <span class="hljs-string"><span class="hljs-string">"blink"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"subscriptions"</span></span> : [<span class="hljs-string"><span class="hljs-string">"$-script-restart"</span></span>, <span class="hljs-string"><span class="hljs-string">"blink"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"modules"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"blink"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"hot_reload"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"scripts/blink.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"optimize"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } }</code> </pre> <br><p>  Dieser Block ähnelt in seiner Funktion dem Block "Komponenten", beschreibt jedoch die Basis der Anwendungskomponenten auf der Controllerseite. </p><br><p>  Es zeigt deutlich den Einstiegspunkt an.  Im Feld "Eintrag".  Unabhängig davon werde ich darauf achten, dass das Skript bei der Installation der Anwendung nicht sofort gestartet wird.  Es wird nur gestartet, wenn eines der Ereignisse eintritt, für die das Skript abonniert ist. </p><br><p>  Das Feld "Abonnements" ist für Abonnements verantwortlich.  Jetzt zeigt es zwei Ereignisse an: </p><br><ul><li>  <strong>$ -script-restart</strong> - tritt auf, wenn das System <strong>gestartet</strong> oder neu <strong>gestartet wird</strong> ; </li><li>  <strong>Blink</strong> ist ein benutzerdefiniertes Ereignis, das für das Blink-Ökosystem relevant ist. </li></ul><br><p>  Im Block „Module“ folgt eine Beschreibung der Zusammensetzung von Skripten.  Ich werde zwei Felder beachten: </p><br><ul><li>  <strong>hot_reload</strong> - Wenn dieses Feld auf true gesetzt ist, wird eine Datei beim <strong>Ändern</strong> im Entwicklungsmodus automatisch auf den Controller heruntergeladen (Hot Reload). </li><li>  <strong>Optimieren</strong> - Wenn dies der Fall ist, wird das Skript beim Erstellen des Projekts optimiert und aggregiert. </li></ul><br><h4 id="blok-requires-anchorblink-manifest-requiresanchor">  Der Block "erfordert" <a name="blink-manifest-requires"></a></h4><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"requires"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"interfaces"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"blink"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"bit_port"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default"</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span> : <span class="hljs-string"><span class="hljs-string">"LED "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"en"</span></span> : <span class="hljs-string"><span class="hljs-string">"LED indicator"</span></span> } } } }</code> </pre> <br><p>  Sie haben wahrscheinlich bereits bemerkt, dass Sie bei der Installation der Anwendung den Pin auswählen müssen, an dem die LED blinkt.  Standardmäßig ist es jedoch bereits als GPIO2 ausgewählt.  Dieser Block ist für diese Einstellungen verantwortlich. </p><br><p>  In diesem Block werden Abhängigkeiten angezeigt.  In diesem Fall muss die Anwendung eine Schnittstelle mit dem Typ "bit_port" bereitstellen, damit sie funktioniert.  Diese Schnittstelle ist eine erforderliche Anforderung (erforderlich = wahr) und standardmäßig ist GPIO2 angegeben (Standard = 2).  Es wird mit dem Namen "blink" in das Skript projiziert. </p><br><p>  Bei der Installation der Anwendung wird das Profil des Geräts berücksichtigt, auf dem die Skripte bereitgestellt werden.  Dieses Profil listet die verfügbaren Schnittstellen und die verfügbaren Hardwareressourcen für sie auf (insbesondere Pins und ihre Kombinationen).  Überprüft die Kompatibilität von Anforderungen und Ausrüstung.  Wenn das Gerät die Anforderungen der Anwendung erfüllen kann, wird dem Benutzer ein Ressourcenzuweisungsschema angezeigt, bei dem Primärressourcen automatisch zugewiesen werden, wobei Empfehlungen aus dem Manifest berücksichtigt werden.  Das heißt  aus dem gleichen "Standard" -Feld. </p><br><p>  Somit können mehrere Anwendungen auf einem Gerät installiert werden, die Hardwareressourcen untereinander gemeinsam nutzen können. </p><br><h3 id="blinkjs-anchorblink-blink-jsanchor">  blink.js <a name="blink-blink-js"></a></h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Blink.vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Langs <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./langs'</span></span>; $includeLang(Langs); $exportComponent(<span class="hljs-string"><span class="hljs-string">'blink-app'</span></span>, App);</code> </pre> <br><p>  Die Datei ist der Einhängepunkt der im Manifest angekündigten Komponente (siehe manifest.js / components). Sie registriert die VUE-Komponente 'blink-app' über die Abstraktionsmethode $ exportComponent und registriert auch das Sprachpaket. </p><br><p>  Sie fragen sich vielleicht - warum solche Schwierigkeiten?  Warum registrieren Sie nicht sofort die VUE-Komponente, die Sie in der Quelle angegeben haben?  Tatsache ist, dass das Manifest öffentliche Komponenten beschreibt.  Diese Komponenten können von Anwendungen von Drittanbietern angefordert werden (Laufzeitabhängigkeiten).  Der Einhängepunkt kann wiederum verwandte Komponenten (für den internen Gebrauch) sowie Dienste registrieren.  Bereiten Sie also die Komponentenumgebung vor. </p><br><h3 id="blinkvue-anchorblink-blink-vueanchor">  Blink.vue <a name="blink-blink-vue"></a></h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Blink'</span></span>, <span class="hljs-attr"><span class="hljs-attr">watch</span></span>: { blink_state (state) { <span class="hljs-comment"><span class="hljs-comment">// Send event to script this.$bus.$emit($consts.EVENTS.UBUS_MESSAGE, 'blink', state); } }, data () { return { blink_state: true }; } };</span></span></code> </pre> <br><p>  Der Code spricht für sich.  Wenn die Eigenschaft "blink_state" geändert wird, wird eine Nachricht mit dem aktuellen Wert an den Bus ($ bus) gesendet.  Dies ist alles, was Sie tun müssen, damit das Skript auf der Controllerseite den gewünschten Befehl erhält. </p><br><h3 id="scriptsblinkjs-anchorblink-script-blink-jsanchor">  scripts / blink.js <a name="blink-script-blink-js"></a></h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> active = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Set port direction $res.blink.direction($res.blink.DIR_MODE_DEF_OUTPUT); // Run background process setInterval(function () { if (active) { // $res - is container with required resources $res.blink.set(state); // Do invert state = !state; } }, 1000); // Event listener // $bus - system bus interface $bus.on(function (event, content, data) { if (event === 'blink') { active = !!JSON.parse(content); } }, null);</span></span></code> </pre> <br><p>  Im Allgemeinen ist der Code der klassischen Verwendung eines Timers in JavaScript sehr ähnlich.  Nur dass es nicht in diesem Dialekt von JavaScript ist.  Es ist in der Plattform implementiert.  Treffen Sie diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mJS</a> .  Weitere Informationen finden Sie auf der offiziellen Seite des Projekts. </p><br><p>  Für die Bedürfnisse der Plattform wird der Dialekt finalisiert.  Es wurden Timer sowie ein nützlicher Befehl wie "Debugger" eingeführt.  Nun, der Debugger selbst.  Mehr dazu separat im Abschnitt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Entwicklungsumgebung"</a> . </p><br><p>  Achten Sie auf die globalen Objekte der Plattform.  Sie werden mit dem Zeichen "$" benannt. </p><br><ul><li>  <strong>$ res</strong> - enthält Ressourcen, die dem Skript zugewiesen sind. </li><li>  <strong>$ bus</strong> - Busschnittstelle. </li></ul><br><p>  Weil  Die Anwendung forderte eine Schnittstelle mit dem Typ "bit_port" (siehe profile.json / require) und dem Namen "blink" an. Sie wurde als $ res.blink angegeben.  Die Schnittstelle implementiert nur drei Funktionen: </p><br><ul><li>  <strong>set (Wert)</strong> - Stellen Sie den GPIO-Pegel ein </li><li>  <strong>get ()</strong> - Liefert den aktuellen GPIO-Level </li><li>  <strong>Richtung (Wert)</strong> - GPIO-Modus einstellen </li></ul><br><p>  Für die Richtungsfunktion werden verfügbare Konstanten über dieselbe Schnittstelle $ res.blink beschrieben .: DIR_MODE_DISABLE;  DIR_MODE_DEF_INPUT;  DIR_MODE_DEF_OUTPUT;  DIR_MODE_INPUT_OUTPUT_OD;  DIR_MODE_INPUT_OUTPUT. </p><br><p>  Das Abonnieren von Busereignissen erfolgt über die Methode $ bus.on.  In diesem Fall werden alle Ereignisse, die das Skript abonniert hat, an den Handler gesendet.  Der Handler akzeptiert drei Parameter: </p><br><ul><li>  <strong>Ereignis</strong> - <strong>Ereigniskennung</strong> .  In diesem Fall sind nur zwei möglich: "$ -script-restart" und "blink".  Davon wird nur einer verarbeitet - blink.  Das Abonnieren des zweiten Skripts ist nur erforderlich, damit das Skript sofort beim Systemstart gestartet wird. </li><li>  <strong>Inhalt</strong> - Daten können mit dem Ereignis kommen.  Ihre Größe ist basierend auf der Länge der Ereigniskennung auf 126 Byte begrenzt. </li><li>  <strong>Daten</strong> - Daten, die beim Abonnieren des Ereignisses als zweiter Parameter übertragen werden.  Und in diesem Fall sind sie null. </li></ul><br><p>  Schnittstellen sind erweiterbar.  Im Folgenden finden Sie eine Beschreibung zum Erstellen Ihrer eigenen Benutzeroberfläche. </p><br><h2 id="realizaciya-interfeysa-anchorintefacesanchor">  Schnittstellenimplementierung <a name="intefaces"></a></h2><br><p>  Mit ThingJS können Sie verfügbare Hardware- und Serviceressourcen über spezielle Schnittstellen erweitern.  Sie können unabhängig voneinander eine Schnittstelle erstellen, die komplexe, genaue, geladene usw. implementiert.  funktional. </p><br><p>  Beispielsweise können Sie eine Integrationsschnittstelle mit Ihrem Cloud-Service implementieren.  Oder ein asynchroner Hintergrundprozess, mit dem das Skript Nachrichten austauschen kann.  Nun, oder implementieren Sie Display-Unterstützung.  Es wird ebenso einfach herzustellen und zu verwenden sein.  Sowohl du als auch andere.  Richtig, dafür müssen Sie C kennen. </p><br><p>  Betrachten Sie die Implementierung der bit_port-Schnittstelle, die im Blink-Beispiel verwendet wird.  Zum Starten müssen Sie das Alpha-Release-Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ThingJS-template</a> bereitstellen.  Die Bereitstellungsdokumentation befindet sich im Projekt selbst. </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch alpha https://github.com/rpiontik/ThingJS-template</code> </pre> <br><p>  Das Projekt umfasst Komponenten: </p><br><ul><li>  <strong>ThingJS-Boards</strong> - enthält Gerätekonfigurationen.  Bisher nur ESP32_CORE_BOARD V2 und kompatibel; </li><li>  <strong>ThingJS-extern</strong> - Bibliotheken von Drittanbieterprojekten, die ThingJS verwendet; </li><li>  <strong>ThingJS-Core</strong> - Plattformkern; </li><li>  <strong>ThingJS-front</strong> - Anwendungsentwicklungsumgebung; </li><li>  <strong>ThingJS-stdi</strong> - Standardschnittstellen. </li></ul><br><p>  Wir interessieren uns für das ThingJS-stdi-Projekt.  Seine Struktur ist wie folgt: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Datei </th><th>  Beschreibung </th></tr><tr><td>  Implementierung / tgsi_bit_port.c </td><td>  Implementierung der Bit_port-Schnittstelle </td></tr><tr><td>  Implementierung / tgsi_bit_port.h </td><td>  Bit_pro-Schnittstellenheaderdatei </td></tr><tr><td>  CMakeLists.txt </td><td>  cmake Build-Skript </td></tr><tr><td>  README.md </td><td></td></tr><tr><td>  sdti_utils.h </td><td>  Helfer </td></tr><tr><td>  thingjs_stdi.c </td><td>  Schnittstellenmontagepunkt </td></tr><tr><td>  thingjs_stdi.h </td><td>  Mount Point-Header-Datei </td></tr></tbody></table></div><br><p>  Tatsächlich interessiert uns nur eine Datei - Implementierung / tgsi_bit_port.c.  Es enthält alles, was einer gesonderten Erklärung bedarf. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thingjsBitPortRegister</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> thingjs_bit_port_cases[] = DEF_CASES( DEF_CASE(GPIO0), DEF_CASE(GPIO2), DEF_CASE(GPIO3), DEF_CASE(GPIO4), DEF_CASE(GPIO5), DEF_CASE(GPIO12), DEF_CASE(GPIO13), DEF_CASE(GPIO14), DEF_CASE(GPIO15), DEF_CASE(GPIO16), DEF_CASE(GPIO17), DEF_CASE(GPIO18), DEF_CASE(GPIO19), DEF_CASE(GPIO21), DEF_CASE(GPIO22), DEF_CASE(GPIO23), DEF_CASE(GPIO25), DEF_CASE(GPIO26), DEF_CASE(GPIO27), DEF_CASE(GPIO32), DEF_CASE(GPIO33) ); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">st_thingjs_interface_manifest</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> = {</span></span> .type = <span class="hljs-string"><span class="hljs-string">"bit_port"</span></span>, .constructor = thingjsBitPortConstructor, .cases = thingjs_bit_port_cases }; thingjsRegisterInterface(&amp;interface); }</code> </pre> <br><p>  Die Funktion thingjsBitPortRegister registriert eine Komponente im ThingJS-Kern.  Dazu ruft es die Funktion thingjsRegisterInterface auf, an die es eine Struktur mit einer Schnittstellenbeschreibung übergibt. </p><br><ul><li>  <strong>Typ</strong> - Schnittstellenkennung.  Er ist der Typ, der in der Datei manifest.json der Anwendung angegeben ist. </li><li>  <strong>Konstruktor</strong> - Link zum Schnittstellenkonstruktor.  Die Funktion wird jedes Mal aufgerufen, wenn Sie eine neue Instanz der Schnittstelle erstellen müssen. </li><li>  <strong>case</strong> ist ein Array, das mögliche Hardwareressourcen beschreibt, die die Schnittstelle für ihre Arbeit verwenden kann.  In diesem Fall handelt es sich um einzelne GPIOs.  Ihre Kombinationen oder Abhängigkeiten können jedoch separat beschrieben werden. </li></ul><br><p>  Der Schnittstellenkonstruktor stellt die Schnittstelle in der mJS-Maschine bereit. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mjs_val_t</span></span> thingjsBitPortConstructor(struct mjs *mjs, cJSON *params) { <span class="hljs-comment"><span class="hljs-comment">//Validate preset params //The params must have pin number if (!cJSON_IsNumber(params)) return MJS_UNDEFINED; //Get pin number gpio_num_t gpio = params-&gt;valueint; //Create mjs object mjs_val_t interface = mjs_mk_object(mjs); /* Configure the IOMUX register for pad BLINK_GPIO (some pads are muxed to GPIO on reset already, but some default to other functions and need to be switched to GPIO. Consult the Technical Reference for a list of pads and their default functions.) */ gpio_pad_select_gpio(gpio); //Add protected property to interface mjs_set(mjs, interface, "gpio", ~0, mjs_mk_number(mjs, gpio)); //Set protected flag mjs_set_protected(mjs, interface, "gpio", ~0, true); //Bind functions mjs_set(mjs, interface, "set", ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) thingjsBitPortSet)); mjs_set(mjs, interface, "get", ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) thingjsBitPortGet)); mjs_set(mjs, interface, "direction", ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) thingjsBitPortDirection)); //Consts mjs_set(mjs, interface, "DIR_MODE_DISABLE", ~0, mjs_mk_number(mjs, GPIO_MODE_DISABLE)); mjs_set(mjs, interface, "DIR_MODE_DEF_INPUT", ~0, mjs_mk_number(mjs, GPIO_MODE_DEF_INPUT)); mjs_set(mjs, interface, "DIR_MODE_DEF_OUTPUT", ~0, mjs_mk_number(mjs, GPIO_MODE_DEF_OUTPUT)); mjs_set(mjs, interface, "DIR_MODE_INPUT_OUTPUT_OD", ~0, mjs_mk_number(mjs, GPIO_MODE_INPUT_OUTPUT_OD)); mjs_set(mjs, interface, "DIR_MODE_INPUT_OUTPUT", ~0, mjs_mk_number(mjs, GPIO_MODE_INPUT_OUTPUT)); //Return mJS interface object return interface; }</span></span></code> </pre> <br><p>  Wie Parameter übergeben werden: </p><br><ul><li>  <strong>mjs</strong> - globaler Ausführungskontext; </li><li>  <strong>params</strong> - Parameter für die Schnittstelleninitialisierung.  In diesem Fall ist dies die GPIO-Nummer. </li></ul><br><p>  Ein mJS-Schnittstellenobjekt wird erstellt, in dem die Methoden und Eigenschaften der Schnittstelle bereitgestellt werden: </p><br><ul><li>  <strong>gpio</strong> - schreibgeschützte Eigenschaft, in der die Anzahl der verwendeten GPIO gespeichert ist; </li><li>  <strong>set</strong> - Methode zum Einstellen des Signalpegels; </li><li>  <strong>get</strong> - eine Methode zum Erhalten des aktuellen Signalpegels; </li><li>  <strong>Richtung</strong> - Einstellen des GPIO-Modus; </li></ul><br><p>  Außerdem werden Konstanten bereitgestellt, mit denen Skripte arbeiten können (DIR_MODE_DISABLE, DIR_MODE_DEF_INPUT usw.). </p><br><p>  Nach dem Erstellen der Schnittstelle wird sie im globalen $ res-Objekt unter einer bestimmten Kennung (im Blink-Beispiel ist es "blink") bereitgestellt.  Ein Anwendungsbeispiel finden Sie im Abschnitt Blink ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">scripts / blink.js</a> ). </p><br><p>  Sie können Schnittstellen in separate Komponenten oder Pakete formatieren.  Auf diese Weise können Sie die Firmware als Lego zusammenstellen. </p><br><h1 id="sreda-razrabotki-anchordevanchor">  Entwicklungsumgebung <a name="dev"></a></h1><br><h2 id="razrabotka-prilozheniy-anchordev-appanchor">  Anwendungsentwicklung <a name="dev-app"></a></h2><br><p>  Die Anwendungsentwicklungsumgebung basiert auf der VUE CLI, die an die Anforderungen der ThingJS-Plattform angepasst wurde.  Dies ist eine harte Gabel, inkl.  Es lohnt sich, auf neue Funktionen von VUE CLI zu warten, wenn sie das Leben direkt erheblich erleichtern. </p><br><p>  Um die Umgebung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereitzustellen</a> , müssen Sie das Alpha-Release-Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ThingJS-front</a> klonen.  Stellen Sie sicher, dass Sie git, npm und nodejs bereits installiert haben. </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch alpha https://github.com/rpiontik/ThingJS-front <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ThingJS-front npm install</code> </pre> <br><p>  Bei der Entwicklung empfehle ich die Verwendung des IDE WEBStorm. </p><br><p>  Die Zusammensetzung und Struktur des Projekts erbt von VUE CLI.  Ich werde signifikante Unterschiede reflektieren: </p><br><ol><li>  Überarbeitete Build-Skripte im Build-Ordner. </li><li>  Eine Umgebungsvariable "HW_DEVICE_URL" wurde der dev-Umgebungskonfiguration (config / dev.env.js) hinzugefügt.  Es ist erforderlich, einen Link zu dem physischen Gerät anzugeben, mit dem Sie arbeiten werden. </li><li>  Der Systemordner src / applications wurde angezeigt.  Es enthält Anwendungen, die automatisch erstellt werden.  Insbesondere enthält es zwei Anwendungen: ante (Launcher) und blink (Anwendung). </li><li>  Alles über dem Ordner src / applications wird als Plattformmodul und Ressourcen betrachtet.  Natürlich können Sie Änderungen daran vornehmen, aber in diesem Fall werden sie erst nach dem Flashen im Controller angezeigt.  T.ch.  Wenn Sie sich keine konkreten Ziele setzen, ist es besser, diese nicht zu berühren. </li></ol><br><p>  Zum Testen können Sie den Dev-Server sofort starten.  Obwohl Sie ohne die physische Hardware nicht vollständig entwickeln können, beeinträchtigt dies die Entwicklung der Schnittstelle nicht.  Und so startet der Entwickler-Server: </p><br><pre> <code class="bash hljs">npm run dev</code> </pre> <br><p>  Das Ergebnis sollte ungefähr so ​​aussehen: </p><br><p><img src="https://habrastorage.org/webt/c2/ku/if/c2kuifxxfz1ppogv-_50rp7wtuo.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wenn</a> Sie den Browser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">öffnen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://0.0.0.0:8080</a> in die Adressleiste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingeben</a> , wird die Plattform im Entwicklungsmodus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angezeigt</a> : </p><br><p><img src="https://habrastorage.org/webt/no/cv/ax/nocvaxx5-kdjtvy0x7i5_jfvcbg.png"></p><br><p>  Der Schnittstellenentwicklungsprozess selbst unterscheidet sich nicht wesentlich von der klassischen Front-End-Entwicklung auf VUE.  Abgesehen davon, dass es globale Plattformobjekte gibt, die Sie beachten müssen: </p><br><ul><li>  <strong>$ const</strong> - enthält Plattformkonstanten sowie Sprachpakete; </li><li>  <strong>$ bus</strong> - Datenbus; </li><li>  <strong>$ store</strong> - globaler Speicher (VUEX). <br>  Anhand der Beispiele können Sie verstehen, wie Sie sie verwenden. </li></ul><br><p>  Mehrsprachigkeit wird auf einfachste Weise implementiert - durch den Filter „lang“.  Geben Sie eine Sprachkonstante an, die je nach Sprache der Benutzeroberfläche in Text interpretiert wird. </p><br><pre> <code class="xml hljs">v-bind:label="'BLINK_SATE' | lang"</code> </pre> <br><p>  Um die Funktionen der Entwicklungsumgebung vollständig bewerten zu können, benötigen Sie einen vorbereiteten (zusammengefügten) Controller.  Sie können die Firmware selbst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aus dem Projekt zusammenstellen</a> oder die vorgefertigte Firmware und das Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier aus verwenden</a> . </p><br><p>  Nachdem Sie den Controller geflasht und eine Verbindung zum Netzwerk hergestellt haben, müssen Sie sicherstellen, dass der Controller von Ihrem Computer aus über IP erreichbar ist.  Geben Sie dazu im Browser <a href="">http: // [</a> Controller- <a href="">IP</a> ] ein.  Die WEB-Schnittstelle sollte sich öffnen. </p><br><p>  Jetzt müssen Sie die Adresse des Controllers in der Datei config / dev.env.js angeben </p><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> merge = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'webpack-merge'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prodEnv = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./prod.env'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = merge(prodEnv, { <span class="hljs-attr"><span class="hljs-attr">NODE_ENV</span></span>: <span class="hljs-string"><span class="hljs-string">'"development"'</span></span>, <span class="hljs-attr"><span class="hljs-attr">HW_DEVICE_URL</span></span>: <span class="hljs-string"><span class="hljs-string">'"http://[IP ]"'</span></span> <span class="hljs-comment"><span class="hljs-comment">//HW_DEVICE_URL: '"http://192.168.8.105"', //HW_DEVICE_URL: '"http://192.168.4.1"', })</span></span></code> </pre> <br><p>  Wenn der Entwicklungsserver gestartet wurde, stoppen Sie ihn und starten Sie ihn neu.  Starten Sie in Zukunft den Entwicklungsserver nach dem Ändern der Build-Dateien, der Konfiguration und des Anwendungsmanifests immer neu. </p><br><p>  Obwohl bei der Arbeit in einer Entwicklungsumgebung alle Anwendungen angezeigt werden, die sich im installierten Ordner src / application befinden, funktionieren nur diejenigen, die tatsächlich auf dem Controller installiert sind.  Dies ist keine Funktion, sondern ein Alpha-Fehler.  In Zukunft erfolgt die Synchronisation von Hardware und Entwicklungsumgebung automatisch.  Im Moment müssen Sie die Anwendung jedoch manuell auf dem Controller installieren, damit die Umgebung sie „einbindet“ und mit dem synchronisiert, was sich in dev befindet. </p><br><p>  Wir montieren die Anwendung im Prod-Modus: </p><br><pre> <code class="bash hljs">npm run prod</code> </pre> <br><p>  Installieren Sie die gesammelten Anwendungen direkt auf dem Controller.  <u><strong>Nicht über den Entwickler-Server</strong></u> . </p><br><p>  Jetzt können Sie mit der Entwicklung beginnen.  Alle Änderungen, die Sie an Ihren Dateien vornehmen, beginnen automatisch mit der Neuerstellung von Anwendungen und das Bild auf dem Bildschirm ändert sich (Hot-Reload).  Die gleiche Regel gilt für Controller-Skripte.  Beispielsweise können Sie den Debugger-Befehl zum Blink-Anwendungsskript hinzufügen und das Ergebnis anzeigen. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Event listener // $bus - system bus interface $bus.on(function (event, content, data) { if (event === 'blink') { debugger; active = !!JSON.parse(content); } }, null);</span></span></code> </pre> <br><p>  Wenn sich nun der Status des Kontrollkästchens der Blink-Anwendung ändert, gibt die Entwicklungsumgebung die folgende Meldung aus: </p><br><p><img src="https://habrastorage.org/webt/bj/lw/qg/bjlwqgwrzgutdhi0vr2oed_cuee.png"></p><br><p>  Durch Klicken auf den Link "Debugger starten" gelangen Sie zum Debugger.  Die Zeile, in der der Stopp aufgetreten ist, wird angezeigt. </p><br><p><img src="https://habrastorage.org/webt/m7/8u/3e/m78u3etl9hleirs072xjgpye_rw.png"></p><br><p>  Der Debugging-Prozess selbst unterscheidet sich nicht wesentlich von anderen Debuggern. </p><br><p><img src="https://habrastorage.org/webt/0m/i_/nt/0mi_nt0gx_-e-7nnvrrtdhxb9kg.png"></p><br><p>  Der Debugger ist in vier Abschnitte unterteilt.  Im zentralen Code selbst.  Links installierte Anwendungen auf dem Controller.  Ihre Struktur und Zusammensetzung.  Richtig, Inspektor.  Das Protokoll wird unten angezeigt.  Unten links sehen Sie den aktuellen Status der Kommunikation mit der Steuerung. </p><br><p>  Die Debugging-Umgebung befindet sich in einer intensiven Entwicklung.  Es müssen noch viele weitere Überwachungs- und Debugging-Tools erstellt werden.  Ich entschuldige mich im Voraus für mögliche Fehler. </p><br><h2 id="razrabotka-proshivki-anchordev-firmwareanchor">  Firmware-Entwicklung <a name="dev-firmware"></a></h2><br><p>  Die Firmware-Entwicklung basiert auf dem von Espressif vorgeschlagenen Konzept.  Ich kann die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">native Dokumentation</a> in dieser Hinsicht nicht übertreffen. </p><br><p>  Für einen schnellen Start wurde ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> vorbereitet.  Es enthält Bereitstellungsinformationen.  Ein Anwendungsbeispiel finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Implementieren einer Schnittstelle“</a> . </p><br><p>  Die Montage ist sehr einfach und in buchstäblich 1-2 Stunden werden Sie die Firmware bereits ohne Probleme montieren. </p><br><h1 id="chto-dalshe-anchorwhat-afteranchor">  Was weiter? <a name="what-after"></a></h1><br><p>  Wenn die Plattform für die Community von Interesse ist, ist Folgendes geplant: </p><br><ul><li>  Entwicklung einer Debugging-Umgebung; </li><li>  Standardisierung der Benennung von Schnittstellen, Ereignissen, Komponenten; </li><li>  Detaillierte Dokumentation auf der Plattform; </li><li>  Cloud-Hosting für virtuelle Dinge; </li><li>  Laufzeit-Repositorys </li><li>  Partitionierung auf verschiedene fertige Geräte. </li></ul><br><p>  Außerdem suche ich Leute, die die Plattform mit mir entwickeln möchten.  Es ist bereits sehr umfangreich und ehrgeizig.  Ich gehe von einer gleichberechtigten Zusammenarbeit aus, deren Ziel es sein wird, die Plattform nach einem vollwertigen OpenSource-Prinzip zu entwickeln. </p><br><p>        pull-     . </p><br><h1 id="ssylki-anchorrefsanchor">  Referenzen <a name="refs"></a></h1><br><p>   ThingJS: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Site</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Gruppe</a> </li></ul><br><p>   ThingJS: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a> </li></ul><br><p>  : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ESP32</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">esp-idf</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mongoose WEB Server</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mJS</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vue 2</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vuetifyjs</a> </li></ul><br><h1 id="faq-anchorfaqanchor">  FAQ <a name="faq"></a></h1><br><p>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474356/">https://habr.com/ru/post/de474356/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474342/index.html">Beschleunigen von Szenen in einem Video mithilfe einer Tabellenansicht</a></li>
<li><a href="../de474344/index.html">Das Internet der Dinge in der Industrie: Wie funktionieren intelligente Pflanzen?</a></li>
<li><a href="../de474346/index.html">Docker-Entwicklung unter Windows Subsystem for Linux (WSL)</a></li>
<li><a href="../de474352/index.html">Zerstörung von Feinden durch einen Sprung, wie in "Mario" Unity 2D</a></li>
<li><a href="../de474354/index.html">Smart Home in Containern (ioBroker + Zigbee in Docker)</a></li>
<li><a href="../de474358/index.html">Holen Sie sich am Wochenende genug Schlaf: Wie weißes Rauschen Erwachsenen hilft, sich zu entspannen und die Schlafqualität von Kindern zu überwachen</a></li>
<li><a href="../de474360/index.html">Verbessern Sie Ihr CSS mit diesen 5 Prinzipien.</a></li>
<li><a href="../de474364/index.html">Elektronikentwicklung. Eine subjektive Überprüfung der nützlichsten integrierten Sensoren</a></li>
<li><a href="../de474366/index.html">Digitale Veranstaltungen in Moskau vom 4. bis 10. November</a></li>
<li><a href="../de474368/index.html">Synopsis zum maschinellen Lernen. Wahrscheinlichkeitstheorie. Bayes-Formel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>