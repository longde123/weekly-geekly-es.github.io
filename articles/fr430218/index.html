<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêì üë©üèª‚Äçüéì üë©üèΩ‚Äçü§ù‚Äçüë®üèæ Optimisation √©nerg√©tique STM32: un guide pratique üë®‚Äçüè≠ ‚è≥ ü•à</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Il existe de nombreux articles sur le r√©seau concernant le fonctionnement des microcontr√¥leurs STM32 dans les appareils √©conerg√©tiqu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimisation √©nerg√©tique STM32: un guide pratique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430218/"> Bonjour, Habr! <br><br>  Il existe de nombreux articles sur le r√©seau concernant le fonctionnement des microcontr√¥leurs STM32 dans les appareils √©conerg√©tiques - g√©n√©ralement des appareils aliment√©s par batterie - mais il y en a malheureusement peu qui ne comprennent pas ce sujet en dehors de la liste des modes d'√©conomie d'√©nergie et des commandes SPL / HAL qui les incluent (cependant, la m√™me affirmation s'applique) √† la grande majorit√© des articles sur l'utilisation de STM32). <br><br>  Pendant ce temps, en raison du d√©veloppement rapide des maisons intelligentes et de toutes sortes d'IoT, le sujet devient de plus en plus pertinent - dans de tels syst√®mes, de nombreux composants sont aliment√©s par batterie et des ann√©es de fonctionnement continu sont attendues de leur part. <br><br>  Nous comblerons cette lacune par l'exemple du STM32L1 - un contr√¥leur tr√®s populaire, assez √©conomique et en m√™me temps ayant des probl√®mes sp√©cifiques √† cette s√©rie.  Presque tout ce qui pr√©c√®de s'appliquera √©galement aux STM32L0 et STM32L4, et en termes de probl√®mes et d'approches communs, aux autres contr√¥leurs bas√©s sur des c≈ìurs Cortex-M. <br><br><img src="https://habrastorage.org/webt/-r/az/lt/-razltjud_qdbwtc74aaopi69la.jpeg"><br><br>  Le r√©sultat pratique devrait ressembler √† la photo ci-dessus (et oui, nous parlerons √©galement de l'applicabilit√© des multim√®tres et autres instruments de mesure √† des t√¢ches similaires). <br><a name="habracut"></a><br><h3>  Modes d'√©conomie d'√©nergie dans STM32L1 </h3><br>  Les principes de base de l'√©conomie de batterie sont les principaux modes d'√©conomie d'√©nergie du processeur.  Chaque fabricant et chaque s√©rie de contr√¥leurs ont leurs propres (un ensemble sp√©cifique est une extension du fournisseur des modes de base Cortex-M standard avec diverses nuances concernant la p√©riph√©rie, les tensions d'alimentation, etc.). <br><br>  Plus pr√©cis√©ment, le STM32L1, qui appartient √† la s√©rie √©conomique des contr√¥leurs, et √† cet √©gard, entre autres, a re√ßu un ensemble √©tendu de param√®tres d'alimentation, nous avons les √©l√©ments suivants: <br><br><ul><li>  <b>Ex√©cuter</b> - mode normal.  Tout compris, tous les p√©riph√©riques disponibles, fr√©quence jusqu'√† 32 MHz. </li><li>  <b>Low Power Run (LP Run)</b> - un mode sp√©cial avec une fr√©quence de fonctionnement de 131 kHz et une consommation maximale, <i>compte tenu de toute la p√©riph√©rie</i> , 200 ŒºA.  En mode LP Run, le r√©gulateur de puissance du processeur passe dans un mode √©conomique sp√©cial, qui √©conomise jusqu'√† cinquante microamp√®res par rapport au fonctionnement √† la m√™me fr√©quence en mode Run. </li><li>  <b>Sommeil</b> - suspension du noyau, mais avec conservation de toutes les fr√©quences d'horloge.  Les p√©riph√©riques du processeur peuvent continuer √† fonctionner si le noyau n'en a pas besoin, mais il peut √™tre automatiquement d√©sactiv√©. </li><li>  <b>Veille √† faible puissance (LP Sleep)</b> - une combinaison de veille avec la transition du stabilisateur en mode √©conomie.  La fr√©quence d'horloge n'est pas sup√©rieure √† 131 kHz, la consommation totale n'est pas sup√©rieure √† 200 ŒºA. </li><li>  <b>Stop</b> - un arr√™t complet de toutes les fr√©quences d'horloge, √† l'exception du g√©n√©rateur ¬´d'horloge¬ª 32768 Hz, externe ou interne.  Dans le cas de STM32L1, seule l'horloge en temps r√©el continue de fonctionner dans ce mode, tout le reste s'arr√™te compl√®tement;  dans les processeurs plus r√©cents, certains p√©riph√©riques peuvent √™tre cadenc√©s √† basse fr√©quence.  <i>Presque</i> toutes les branches du processeur conservent leur √©tat.  Le contenu de la RAM est enregistr√©, les interruptions externes continuent de fonctionner. </li><li>  <b>Veille</b> - un arr√™t complet du c≈ìur du processeur, de la RAM et de tous les p√©riph√©riques, √† l'exception des horloges en temps r√©el.  La RAM n'est pas sauvegard√©e (c.-√†-d. Du point de vue du logiciel, laisser en veille √©quivaut presque √† d√©former l'alimentation - recommencer depuis le d√©but), RTC continue de cocher.  Les interruptions externes ne fonctionnent pas, √† l'exception de trois segments WKUPx sp√©ciaux, dont la commutation de 0 √† 1 r√©veille le processeur. </li></ul><br>  L'entr√©e dans chacun des modes est assez simple - vous devez d√©finir les drapeaux dans trois √† cinq registres, apr√®s quoi (pour les modes de veille) appeler l'instruction WFI ou WFE, il s'agit de l'instruction Cortex-M standard, signifie ¬´Attendre une interruption¬ª et ¬´Attendre un √©v√©nement¬ª .  Selon les drapeaux (ils sont d√©crits dans le Manuel de r√©f√©rence du processeur, pour STM32L1 c'est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RM0038</a> ), le processeur lui-m√™me passera dans ce mode sur cette commande. <br><br>  De plus, il serait bon d'interdire les interruptions (cela n'affectera pas la capacit√© des √©v√©nements externes et internes √† sortir le processeur du sommeil) et d'attendre que les donn√©es soient enregistr√©es des registres dans la m√©moire si cela se produit soudainement, en utilisant la commande DSB. <br><br>  Par exemple, voici √† quoi ressemble le passage en mode Stop: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  PDDS    Stop  Standby,    */</span></span> PWR-&gt;CR &amp;= ~(PWR_CR_PDDS); <span class="hljs-comment"><span class="hljs-comment">/*  Wakeup   ,      */</span></span> PWR-&gt;CR |= PWR_CR_CWUF; <span class="hljs-comment"><span class="hljs-comment">/*    low-power ,    Stop -    */</span></span> PWR-&gt;CR |= PWR_CR_LPSDSR; <span class="hljs-comment"><span class="hljs-comment">/*    Vref   */</span></span> PWR-&gt;CR |= PWR_CR_ULP; <span class="hljs-comment"><span class="hljs-comment">/*     Cortex-M,  Stop,  Standby -   Deep Sleep */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      Deep Sleep */</span></span> SCB-&gt;SCR |= (SCB_SCR_SLEEPDEEP_Msk); <span class="hljs-comment"><span class="hljs-comment">/*  ;       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> state = irq_disable(); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> __DSB(); <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> __WFI(); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> init_clk(); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> irq_restore(state);</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WFI</a> est une instruction de blocage, le processeur entrera en veille profonde et ne le quittera pas avant qu'une sorte d'interruption ne se produise.  Oui, je le r√©p√®te, malgr√© le fait que nous ayons explicitement d√©sactiv√© les interruptions, le processeur y r√©pondra et se r√©veillera - mais il ne commencera le traitement qu'apr√®s que nous les ayons r√©activ√©.  Et cela a un sens profond. <br><br>  Dans le code ci-dessus, apr√®s WFI, une r√©initialisation des fr√©quences de fonctionnement ne se produit pas seulement - le fait est que L1 quitte <i>toujours</i> le sommeil profond √† une fr√©quence de 4,2 MHz et avec un g√©n√©rateur MSI interne comme source de cette fr√©quence.  Dans de nombreuses situations, vous ne voulez √©videmment pas que le gestionnaire d'interruption qui r√©veille le processeur commence √† fonctionner √† cette fr√©quence - par exemple, car les fr√©quences de tous les temporisateurs, UART et autres bus s'envoleront;  par cons√©quent, nous restaurons d'abord les fr√©quences de fonctionnement (ou, si nous voulons rester sur MSI, recalculons les bus n√©cessaires sous 4,2 MHz), puis nous plongons dans les interruptions. <br><br>  En pratique, les deux modes les plus couramment utilis√©s sont Run et Stop.  Le fait est que LP Run est douloureusement lent et n'a aucun sens si le processeur doit effectuer des calculs et ne pas simplement attendre des √©v√©nements externes, et Sleep et LP Sleep ne sont pas trop √©conomiques (consommation jusqu'√† 2 mA) et sont n√©cessaires si vous en avez besoin √©conomiser au moins un peu, mais en m√™me temps laisser les p√©riph√©riques de travail et / ou fournir la r√©action la plus rapide possible du processeur aux √©v√©nements.  De telles exigences existent, mais dans l'ensemble pas tr√®s souvent. <br><br>  Le mode veille n'est g√©n√©ralement pas utilis√©, car apr√®s qu'il est impossible de continuer √† partir de l'endroit o√π vous vous √©tiez arr√™t√© en raison de la mise √† z√©ro de la RAM, il existe √©galement des probl√®mes avec les p√©riph√©riques externes, dont nous discuterons ci-dessous, qui n√©cessitent des solutions mat√©rielles.  Cependant, si l'appareil a √©t√© con√ßu dans cet esprit, la veille peut √™tre utilis√©e comme un mode ¬´off¬ª, par exemple, pendant le stockage √† long terme de cet appareil. <br><br>  En fait, sur la pr√©sentation de cela, la plupart des manuels se d√©tachent g√©n√©ralement triomphalement. <br><br>  Le probl√®me est que, en les suivant, vous obtiendrez une triste consommation de 100 √† 200 ŒºA de consommation r√©elle au lieu des 1,4 ŒºA promis en Stop avec les heures de travail - m√™me sur le d√©bogage de r√©f√©rence Nucleo, qui n'a pas de puces, capteurs, etc. externes. √† laquelle il pourrait √™tre attribu√©. <br><br>  Et non, votre processeur fonctionne, il n'y a rien dans les errata et vous avez tout fait correctement. <br><br>  Mais pas jusqu'au bout. <br><br><h3>  Syndrome des jambes sans repos </h3><br>  Le premier probl√®me STM32L1, dont <i>certains</i> articles mentionnent, mais ne se souviennent souvent que sur les forums, lorsque le troisi√®me jour de discussion, d'o√π viennent les 100-200 ŒºA, quelqu'un se souvient de l'existence de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AN3430</a> et atteint la page 19 de celui-ci - ce √©tat des jambes par d√©faut. <br><br>  Je note que m√™me STMicro lui-m√™me fait r√©f√©rence au probl√®me √† travers les manches, et dans la plupart des documents o√π l'optimisation de la consommation d'√©nergie est envisag√©e, il est limit√© √† une ou deux phrases avec le conseil de tirer les jambes inutilis√©es au sol ou de passer en mode d'entr√©e analogique, sans expliquer les raisons. <br><br>  Ce qui est triste, c'est que par d√©faut, toutes les jambes sont configur√©es comme entr√©es num√©riques (0x00 dans le registre GPIOx_MODER).  Un d√©clencheur Schmitt est toujours sur l'entr√©e num√©rique, ce qui am√©liore l'immunit√© au bruit de cette entr√©e, et il est compl√®tement ind√©pendant - c'est un √©l√©ment logique simple, un tampon avec hyst√©r√©sis qui ne n√©cessite pas d'horloge externe. <br><br>  Dans notre cas, cela signifie que nous avons √©teint l'horloge en mode Stop, et les d√©clencheurs Schmitt ont continu√© √† fonctionner comme si de rien n'√©tait - en fonction du niveau du signal d'entr√©e, ils commutent leurs sorties sur 0 et 1. <br><br>  Dans le m√™me temps, une partie des jambes du processeur dans un circuit typique est suspendue dans l'air - c'est-√†-dire qu'il n'y a aucun signal intelligible sur elles.  Il serait faux de penser que l'absence d'un signal clair signifie que sur ces jambes 0 ne l'est pas, sur ces jambes en raison de leur imp√©dance d'entr√©e √©lev√©e, il y a un bruit al√©atoire d'une valeur ind√©termin√©e, provenant des micros et du courant circulant des pistes voisines vers la premi√®re cha√Æne de t√©l√©vision, si le pied est assez long pour servir d'antenne (cependant, les t√©l√©viseurs analogiques en Russie seront bient√¥t √©teints, ce qui devrait entra√Æner une certaine r√©duction de la consommation d'√©nergie des microcontr√¥leurs mal configur√©s). <br><br>  Conform√©ment √† ces fluctuations, la jambe bascule de fa√ßon al√©atoire entre 0 et 1. La logique CMOS consomme du courant lors de la commutation.  C'est-√†-dire qu'une <i>jambe de processeur suspendue en l'air, configur√©e en mode d'entr√©e num√©rique, consomme un courant perceptible en soi</i> . <br><br>  La solution est simple: lorsque vous d√©marrez le programme, vous devez configurer toutes les branches √† l'√©tat de l'entr√©e analogique;  STM32 l'a formellement pour toutes les jambes sans exception, qu'elles soient connect√©es ou non √† l'ADC, et ne diff√®re de l'entr√©e num√©rique qu'en l'absence d'un d√©clencheur Schmitt √† l'entr√©e. <br><br><img src="https://habrastorage.org/webt/nm/k2/py/nmk2py-r1zqa2rgltekzx69bmy8.png"><br><br>  Pour ce faire, il suffit d'√©crire la valeur 0xFF ... FF dans tous les registres GPIOx_MODER, il est plus facile de le faire, comme mentionn√© ci-dessus, d√®s le d√©but, puis au cours du jeu, vous reconfigurerez les jambes individuelles selon les besoins de cet appareil. <br><br>  Ici, cependant, un probl√®me de second ordre se pose - c'est bien si votre micrologiciel fonctionne sur un contr√¥leur sp√©cifique, et donc vous savez toujours ce que <i>x</i> est dans GPIOx.  Pire encore si le firmware est universel - le STM32 peut avoir <i>jusqu'√†</i> 8 ports, mais il peut √™tre plus petit;  lorsque vous essayez d'√©crire sur un port qui n'existe pas dans ce mod√®le de contr√¥leur, vous obtiendrez Hard Fault, c'est-√†-dire  crash du noyau. <br><br>  Cependant, m√™me ce cas peut √™tre contourn√© - Cortex-M vous permet de v√©rifier la validit√© des adresses, d'ailleurs, dans le cas de M3 et M4, le contr√¥le est g√©n√©ralement trivial, et sur M0 il n√©cessite un peu de magie, mais il est r√©alisable (les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©tails peuvent √™tre lus ici</a> , nous ne fan pas cet article ) <br><br>  Autrement dit, le processeur a d√©marr√©, r√©gl√© les fr√©quences - et a imm√©diatement parcouru tous les ports GPIO disponibles, en les √©crivant sur ceux MODER (le code ci-dessous est √©crit pour RIOT OS, mais en g√©n√©ral, il est clair sans commentaire et peut √™tre transf√©r√© en trois minutes toute autre plateforme). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(CPU_FAM_STM32L1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* switch all GPIOs to AIN mode to minimize power consumption */</span></span></span><span class="hljs-meta"> GPIO_TypeDef *port; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable GPIO clock */</span></span></span><span class="hljs-meta"> uint32_t ahb_gpio_clocks = RCC-&gt;AHBENR &amp; 0xFF; periph_clk_en(AHB, 0xFF); for (uint8_t i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 8; i++) { port = (GPIO_TypeDef *)(GPIOA_BASE + i*(GPIOB_BASE - GPIOA_BASE)); if (cpu_check_address((char *)port)) { port-&gt;MODER = 0xffffffff; } else { break; } } /* restore GPIO clock */ uint32_t tmpreg = RCC-&gt;AHBENR; tmpreg &amp;= ~((uint32_t)0xFF); tmpreg |= ahb_gpio_clocks; periph_clk_en(AHB, tmpreg); #endif</span></span></span></span></code> </pre><br>  Je note que cela ne s'applique qu'√† la s√©rie L1, dans L0 et L4, l'exp√©rience a √©t√© prise en compte et, par d√©faut, ils configurent tous les ports comme entr√©es analogiques au d√©marrage. <br><br>  Apr√®s avoir soigneusement effectu√© toutes ces proc√©dures, vous remplissez le firmware dans l'appareil fini ... et obtenez 150 uA en mode Stop sur le processeur et toutes les puces externes d√©sactiv√©es, malgr√© le fait que vos estimations soient les plus pessimistes, provenant des fiches techniques pour tout ce que vous avez soud√© sur la carte ne donne pas plus de 10 ŒºA. <br><br>  De plus, vous essayez de mettre le processeur en veille plut√¥t qu'en arr√™t, c'est-√†-dire  il suffit de l'√©teindre presque compl√®tement - et au lieu de baisser, la consommation d'√©nergie triple, s'approchant de pr√®s d'un demi-milliamp√®re! <br><br>  Pas besoin de paniquer.  Comme vous l'avez peut-√™tre devin√©, vous avez tout fait correctement.  Mais pas jusqu'au bout. <br><br><h3>  Syndrome des jambes sans repos - 2 </h3><br>  Le probl√®me suivant comporte deux parties. <br><br>  La premi√®re est assez √©vidente: si votre appareil ne se compose pas d'un seul microcontr√¥leur, il est important de ne pas oublier que les puces externes ont √©galement des signaux d'entr√©e sur lesquels les d√©clencheurs Schmitt se bloquent et qui, de plus, peuvent r√©veiller la logique interne de la puce.  Par exemple, une puce qui est retir√©e et retir√©e de son sommeil par l'√©quipe UART essaiera de lui lire des donn√©es avec n'importe quel mouvement sur ce bus. <br><br>  Par cons√©quent, si toutes ces jambes sont suspendues en l'air, nous n'obtiendrons rien de bon. <br><br>  Dans quelles conditions finissent-ils dans l'air? <br><br>  Premi√®rement, lorsque le contr√¥leur passe en mode veille, tous les GPIO sont transf√©r√©s √† l'√©tat High-Z, avec une r√©sistance √©lev√©e - c'est-√†-dire que les puces externes qui leur sont connect√©es sont en l'air.  Il est impossible de r√©soudre ce probl√®me par programme dans STM32L1 (dans d'autres s√©ries et d'autres contr√¥leurs, cela se produit de diff√©rentes mani√®res), par cons√©quent, la seule issue est dans un syst√®me qui utilise le mode veille, les entr√©es des puces externes doivent √™tre tir√©es √† la terre ou aliment√©es par des r√©sistances externes. <br><br>  Un niveau sp√©cifique est choisi pour que la ligne soit inactive du point de vue de la puce: <br><br><ul><li>  1 pour UART TX </li><li>  0 pour SPI MOSI </li><li>  0 pour SPI CLK en mode SPI 0 ou 1 </li><li>  1 pour SPI CLK avec SPI Mode 2 ou 3 </li><li>  1 pour SPI CS </li></ul><br>  Deuxi√®mement, sur STM32 <i>lors de l'utilisation du mode Stop</i> (sic!) <i>, L'</i> √©tat des GPIO connect√©s aux blocs mat√©riels internes des interfaces peut √™tre ... diff√©rent.  C'est-√†-dire que la m√™me interface SPI, lorsqu'elle est configur√©e, dans Stop se r√©v√®le soudainement √™tre soit une entr√©e num√©rique, soit, en g√©n√©ral, High-Z - avec les cons√©quences correspondantes pour les puces externes qui s'y accrochent.  Bien que la documentation indique que les jambes sont en bon √©tat, vous ne pouvez a priori vous y fier que si vous utilisez vos jambes en tant que GPIO ordinaires. <br><br>  Vous ne pouvez pas le comprendre et le pardonner, mais vous pouvez vous en souvenir et le r√©parer: pour les interfaces qui se comportent de cette fa√ßon, vous devez ajouter la commutation forc√©e au GPIO normal avec des niveaux correspondant aux niveaux inactifs de cette interface dans la fonction de soin du sommeil.  Apr√®s s'√™tre endormi, les interfaces peuvent √™tre restaur√©es. <br><br>  Par exemple, le m√™me SPI avant de s'endormir (pour plus de simplicit√©, je reprends le code du RIOT OS, il est clair que le m√™me est facile √† impl√©menter sur les registres): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* specifically set GPIOs used for external SPI devices */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MOSI = 0, SCK = 0, MISO = AIN for SPI Mode 0 &amp; 1 (CPOL = 0) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MOSI = 0, SCK = 1, MISO = AIN for SPI Mode 2 &amp; 3 (CPOL = 1) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SPI_NUMOF; i++) { <span class="hljs-comment"><span class="hljs-comment">/* check if SPI is in use */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_periph_clk(spi_config[i].apbbus, spi_config[i].rccmask) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* SPI CLK polarity */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spi_config[i].dev-&gt;CR1 &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>)) { gpio_init(spi_config[i].sclk_pin, GPIO_IN_PU); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gpio_init(spi_config[i].sclk_pin, GPIO_IN_PD); } gpio_init(spi_config[i].mosi_pin, GPIO_IN_PD); gpio_init(spi_config[i].miso_pin, GPIO_AIN); } }</code> </pre><br>  Veuillez noter que les sorties ici ne sont pas configur√©es en tant que GPIO_OUT avec un niveau de 0 ou 1, mais en tant qu'entr√©es avec un pull-up √† 0 ou 1 - ce n'est pas un point fondamental, mais offre une s√©curit√© suppl√©mentaire si vous faites une erreur et essayez de jouer au pull-push avec une sorte de une puce externe tirant cette jambe dans l'autre sens.  Avec GPIO_OUT, vous pouvez organiser un court-circuit, avec GPIO_IN avec un pull-up - jamais. <br><br>  De plus, le signal SPI CS n'est pas affect√© - dans ce cas, il est g√©n√©r√© par programme, c'est-√†-dire par un GPIO normal, et il conserve son √©tat dans un r√™ve en toute confiance. <br><br>  Pour restaurer l'√©tat de la jambe en sortant du sommeil, il suffit d'√©crire les valeurs des registres qui seront modifi√©s (MODER, PUPDR, OTYPER, OSPEEDR - voir la situation dans un cas particulier) √† l'entr√©e, en variables, et de les reculer dans les registres en sortant du sommeil des variables . <br><br>  Et maintenant ... ta daaam!  Image de titre.  Un et demi microamp√®res. <br><br>  Mais il est trop t√¥t pour c√©l√©brer.  Sur ce point, nous avons termin√© l'optimisation <i>statique</i> de la consommation d'√©nergie, et devant nous est <i>dynamique</i> . <br><br><h3>  Achilles vs Turtle </h3><br>  Quel est le meilleur - manger plus et courir plus vite ou manger moins, mais courir plus lentement?  Dans le cas des microcontr√¥leurs, la r√©ponse √† cette question est deux fois non triviale. <br><br>  Premi√®rement, les fr√©quences de fonctionnement peuvent √™tre modifi√©es dans une tr√®s large plage - de 65 kHz (LP Run) √† 32 MHz en mode normal.  Comme toute puce CMOS, STM32 a deux composants en termes de consommation d'√©nergie: statique et dynamique;  le second d√©pend de la fr√©quence, le premier est constant.  En cons√©quence, la consommation d'√©nergie ne diminuera pas aussi rapidement que la fr√©quence de fonctionnement et la productivit√©, et selon la t√¢che, la fr√©quence optimale du point de vue de l'efficacit√© √©nerg√©tique peut se r√©v√©ler diff√©rente - o√π vous devez attendre un √©v√©nement, mais pour une raison quelconque vous ne pouvez pas vous endormir, il y aura les basses fr√©quences sont efficaces, o√π vous avez juste besoin de battre des nombres - √©lev√©s.  Dans les t√¢ches "moyennes √† l'h√¥pital" typiques, il n'est g√©n√©ralement pas logique de descendre en dessous de 2-4 MHz. <br><br>  Deuxi√®mement, et c'est un moment moins trivial, le taux de sortie du sommeil d√©pend de la fr√©quence de travail et de la fa√ßon dont il est re√ßu. <br><br>  Le pire des cas est de sortir du sommeil √† une fr√©quence de 32 MHz √† partir d'un quartz externe (laissez-moi vous rappeler que le STM32L1 se r√©veille sur un oscillateur interne √† 4 MHz), car il se compose de trois √©tapes: <br><br><ul><li>  en fait, le processeur se r√©veille du sommeil </li><li>  stabilisation de la g√©n√©ration de quartz (1-24 MHz) </li><li>  Stabilisation de g√©n√©ration PLL (32 MHz) </li></ul><br>  En fait, sortir le processeur du sommeil est le plus petit probl√®me, √† une fr√©quence de 4,2 MHz, cela prend environ 10 Œºs.  Mais la stabilisation du quartz peut prendre jusqu'√† 1 ms (bien que g√©n√©ralement pour les r√©sonateurs √† grande vitesse, elle soit encore plus rapide, de l'ordre de plusieurs centaines de microsecondes), l'acc√®s au mode PLL est encore de 160 Œºs. <br><br>  Ces retards peuvent ne pas √™tre importants du point de vue de la consommation d'√©nergie pour un syst√®me qui se r√©veille rarement (pas plus d'une fois par seconde), mais o√π la p√©riode entre les r√©veils est de quelques dizaines de millisecondes et moins, et les r√©veils eux-m√™mes sont courts, les frais g√©n√©raux commencent √† faire un ajout d√©j√† mesurable m√™me sachant que lors du r√©veil le processeur consomme un courant relativement faible. <br><br>  Que peut-on faire avec √ßa?  En g√©n√©ral, la r√©ponse est √©vidente: essayez d'√©viter d'utiliser du quartz externe.  Par exemple, un programme dans lequel il existe de rares sous-t√¢ches lourdes qui n√©cessitent une synchronisation pr√©cise (par exemple, des plus triviales - √©change de donn√©es UART), et des sous-t√¢ches simples fr√©quentes, peut d√©cider par lui-m√™me √† chaque r√©veil s'il est n√©cessaire d'aller √† quartz externe, ou il sera plus facile (et plus rapide!) d'effectuer la t√¢che en cours sur le g√©n√©rateur MSI, sur lequel le processeur s'est d√©j√† r√©veill√© sans passer beaucoup de temps √† initialiser les fr√©quences. <br><br>  Dans ce cas, cependant, il peut √™tre n√©cessaire d'ajuster les fr√©quences d'horloge de la p√©riph√©rie, ainsi que d'ajuster les modes d'acc√®s √† la m√©moire flash (le nombre de cycles de retard), la tension du c≈ìur du processeur (dans STM32L1, il est s√©lectionn√© parmi trois valeurs possibles), etc.  Cependant, en ce qui concerne les modes de fonctionnement du noyau et de la m√©moire, il est souvent possible de les affiner en choisissant ceux recommand√©s pour la fr√©quence maximale utilis√©e, car un fonctionnement non optimal du c≈ìur √† des fr√©quences plus basses n'entra√Ænera pas de changement significatif dans les performances pratiques et la consommation d'√©nergie en raison du faible volume de t√¢ches √† ces fr√©quences effectu√©. <br><br>  Bien que toutes ces mesures s'appliquent d√©j√† au r√©glage fin des modes (et, par exemple, la plupart des syst√®mes d'exploitation et des biblioth√®ques ne savent m√™me rien de proche de la bo√Æte), dans certains cas, elles peuvent entra√Æner une diminution de la consommation moyenne √† l'√©chelle des unit√©s de pourcentage, et parfois m√™me plus.  Imaginez, par exemple, un compteur d'eau qui interroge les contacts d'un interrupteur √† lames toutes les 50 ms, tandis que le lev√© r√©el prend plusieurs dizaines de microsecondes - voulez-vous ajouter ~ 500 Œºs √† ce moment pour r√©veiller le contr√¥leur? .. <br><br><h3>  Insoutenablement longue seconde </h3><br>  Un autre probl√®me qui n'est pas directement li√© √† la conservation de l'√©nergie, mais qui se pose in√©vitablement en rapport avec celui-ci - comment compter les intervalles de temps inf√©rieurs √† 1 seconde? <br><br>  Le fait est que sur STM32L1 il n'y a qu'une seule minuterie qui fonctionne en mode Stop - c'est RTC, l'unit√© de temps standard pour laquelle est 1 seconde.  Dans le m√™me temps, dans les programmes, il y a constamment des intervalles de temps d'unit√©s, de dizaines et de centaines de millisecondes, pour prendre au moins le m√™me compteur d'eau. <br><br>  Comment √™tre  Fonctionne sur des processeurs avec des temporisateurs LPTIM, cadenc√©s √† 32768 Hz?  Une bonne option, en fait, mais pas toujours n√©cessaire.  C'est possible sans cela. <br><br>  Pas sur tous les STM32L1, mais √† partir de Cat.  2 (il s'agit des processeurs STM32L151CB-A, STM32L151CC et plus r√©cents), le bloc RTC a √©t√© compl√©t√© par un nouveau registre - SSR, Registre des sous-secondes.  Plus pr√©cis√©ment, il n'√©tait pas tant compl√©t√© qu'il le rendait visible √† l'utilisateur, plus les alarmes de sous-seconde ALRMASSR et ALRMBSSR ont √©t√© ajout√©es. <br><br>  Ce registre ne contient aucune unit√© de temps compr√©hensible, il a √©t√© fouett√© √† partir d'un compteur technique interne.  Dans STM32L1, une horloge √† 32768 Hz passe √† travers deux compteurs diviseurs, asynchrones et synchrones, qui au total la divisent normalement par 32768 pour obtenir une tique de 1 seconde pour l'horloge.  Ainsi, SSR est juste la valeur actuelle du deuxi√®me compteur. <br><br>  Bien que le SSR ne compte pas en millisecondes, mais dans ses unit√©s, la dimension de ces unit√©s peut √™tre modifi√©e en modifiant le rapport des diviseurs du compteur synchrone et asynchrone, tout en conservant leur coefficient total √©gal √† 32768 pour obtenir la norme 1 seconde √† l'entr√©e RTC.  Connaissant ces coefficients, nous pouvons calculer le prix d'une division de SSR en millisecondes, et √† partir de l√†, nous pouvons proc√©der √† la programmation d'alarmes de sous-seconde. <br><br>  Il convient de noter qu'un pr√©-compteur asynchrone est plus √©conomique qu'un SSR synchrone, et donc le mettre √† 1, et d√©j√† diviser la fr√©quence d'entr√©e en SSR par 32768, apr√®s avoir re√ßu un compte de seulement 30 Œºs, est √©nerg√©tiquement d√©savantageux.  Pour nous-m√™mes, nous avons d√©termin√© la valeur optimale pour le diviseur pr√©liminaire 7, pour synchrone - 4095 ((7 + 1) * (4095 + 1) = 32768).  Avec une nouvelle diminution du diviseur pr√©liminaire, la consommation d'√©nergie du RTC commence √† augmenter de fa√ßon mesurable - d'une fraction de microamp√®re, mais puisque nous la comparons √† la ¬´r√©f√©rence¬ª 1,4 ŒºA en mode Stop, m√™me les fractions comptent.  Par d√©faut, pour STM32L1, ces valeurs sont 127 et 255, c'est-√†-dire  le prix de r√©f√©rence est d'environ 4 ms, ce qui est un peu approximatif. <br><br>  Si vous souhaitez approfondir le code, nous avons <a href="">finalis√©</a> en temps voulu <a href="">le pilote RTC standard</a> de RIOT OS pour prendre en charge RTC_SSR et les intervalles en millisecondes.  Depuis lors, nous l'utilisons litt√©ralement √† chaque √©tape (et puisque nous travaillons dans le syst√®me d'exploitation, un service se bloque √©galement au-dessus de lui, ce qui vous permet de suspendre presque n'importe quel nombre de t√¢ches avec des p√©riodes arbitraires sur une minuterie mat√©rielle avec un coup de poignet). <br><br>  La m√™me approche est transf√©r√©e aux contr√¥leurs STM32L0 et STM32L4, dont tous les mod√®les ont le registre RTC_SSR;  cela √©limine le besoin de temporisateurs LPTIM et unifie le code pour diff√©rentes plates-formes. <br><br><h3>  Comment comprendre qu'un multim√®tre est couch√© </h3><br>  Bien s√ªr, apr√®s toutes les optimisations, la question l√©gitime se pose: qu'avons-nous r√©alis√© en fait?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sans en conna√Ætre la r√©ponse, on pourrait se limiter compl√®tement √† un WFE avec des drapeaux correctement configur√©s, s'endormir et obtenir vos 200-500 ŒºA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fa√ßon la plus traditionnelle de mesurer le courant est, bien s√ªr, un multim√®tre. Comprendre qu'il est allong√© sur une charge comme un microcontr√¥leur avec sa consommation dynamique est tr√®s simple - s'il est allum√©, il est allong√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela ne signifie cependant pas que le multim√®tre est inutile √† cet √©gard. Il vous suffit de pouvoir l'appliquer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Premi√®rement, un multim√®tre est une chose tr√®s lente, un temps typique pour un compte est une deuxi√®me √©chelle, un temps typique pour changer l'√©tat d'un microcontr√¥leur est une √©chelle de microsecondes. Dans un syst√®me qui modifie sa consommation √† ce rythme, le multim√®tre affichera simplement des valeurs al√©atoires.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, l'une des variables non al√©atoires qui nous int√©resse est la consommation du microcontr√¥leur en mode veille; s'il d√©passe de mani√®re significative la valeur que nous avons estim√©e sur les fiches techniques, alors quelque chose ne va clairement pas. Il s'agit de la consommation d'un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syst√®me statique</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est-√†-dire qu'il peut √™tre mesur√© avec un multim√®tre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√©thode la plus banale montr√©e dans la photo de titre est un multim√®tre en mode micro-amp√®rem√®tre, qui est maintenant dans la plupart des mod√®les de milieu de gamme, et a une bonne pr√©cision et une excellente r√©solution. L'UT120C a une r√©solution de 0,1 ŒºA avec une pr√©cision certifi√©e de ¬± 1% ¬± 3 d√©charges, ce qui nous suffit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'y a qu'un seul probl√®me avec ce mode - les multim√®tres qu'il contient ont une grande r√©sistance en s√©rie, une √©chelle de centaines d'ohms, donc en mode normal, un microcontr√¥leur avec un tel multim√®tre dans le circuit de puissance ne d√©marre tout simplement pas. Heureusement, les positions de "mA" et "uA" dans presque tous les instruments de la balance sont proches, les prises de mesure sur les deux gammes sont les m√™mes, vous pouvez donc d√©marrer en toute s√©curit√© le contr√¥leur √† la limite de "mA", et quand il se met en veille, cliquez sur "uA" "- cela se produit assez rapidement pour que le contr√¥leur n'ait pas le temps de perdre le courant et de red√©marrer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veuillez noter que si le contr√¥leur conna√Æt des pics d'activit√©, cette m√©thode n'est pas applicable. Par exemple, la minuterie du chien de garde est r√©initialis√©e toutes les 15 secondes dans le micrologiciel de l'appareil - √† ces moments, le multim√®tre parvient √† afficher quelque chose dans la r√©gion de 27 ŒºA, ce qui, bien s√ªr, n'a rien √† voir avec la m√©t√©o sur Mars. Si quelque chose de court arbitrairement se produit sur votre syst√®me plus d'une fois toutes les 5 √† 10 secondes, le multim√®tre se trouvera simplement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre fa√ßon de mesurer l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©lectricit√© statique</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Je souligne directement ce mot) la consommation par un multim√®tre est une mesure de la chute sur un shunt externe. Si vous souhaitez mesurer des courants ultra-petits √† l'√©chelle de quelques dizaines de microamp√®res, vous devez mettre un shunt de grande taille (par exemple, 1 kOhm) et parall√®le √† celui-ci - une diode Schottky en connexion directe. Si le shunt chute de plus de 0,3 V, la diode s'ouvrira et limitera la chute de tension, et jusqu'√† 0,3 V, vous pouvez mesurer la chute en toute s√©curit√© avec un multim√®tre de l'ordre du millivolt, 1 mV = 1 ŒºA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√©las, il ne fonctionnera pas pour mesurer la chute sur un shunt √† basse imp√©dance avec un multim√®tre typique - des appareils de classe moyenne, m√™me s'ils montrent quelque chose en dessous de 100 ŒºV, la pr√©cision dans cette gamme est regrettable. Si vous avez un bon appareil de bureau pouvant afficher 1 uV, vous n'avez plus besoin de mes conseils.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, la statique est bonne, mais qu'en est-il de la dynamique? </font><font style="vertical-align: inherit;">Comment √©valuer le m√™me effet de fr√©quences diff√©rentes sur la consommation √©lectrique moyenne? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, tout est compliqu√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âcrivons les exigences de base:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plage de courant d'au moins 1 ŒºA - 100 mA (10 ^ 5) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> p√©riode de mesure ne d√©passant pas 10 Œºs </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chute de tension non sup√©rieure √† 100 mV </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dur√©e de mesure - illimit√©e </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous traduisons simplement cela directement en chiffres, nous obtiendrons un ADC relativement rapide et pas moins de 18 bits avec une polarisation d'entr√©e inf√©rieure √† 30 ŒºV, un frontal analogique capable de mesurer des tensions √† partir de 1 ŒºV et une interface rapide avec l'ordinateur qui nous permettra de transf√©rer tout cela et √©conomisez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et tout cela pour une seule utilisation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous voyez, oui, pourquoi de telles choses ne se trouvent pas √† chaque coin de dix dollars? Keysight N6705C dans la premi√®re approximation r√©pond √† nos exigences, seulement il en co√ªte 7960 $.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä partir de solutions budg√©taires, par exemple, SiLabs int√®gre la mesure du courant dans ses d√©bogages - les caract√©ristiques de leur syst√®me de surveillance √©nerg√©tique avanc√©e (AEM) d√©pendent du mod√®le de d√©bogage sp√©cifique, et ils ont le plus gros probl√®me avec la vitesse de mesure. Dans les anciens ¬´kits de d√©marrage¬ª, le STK3300 / 3400 n'est que de 100 Hz, sur les plus r√©cents d√©bogue le STK3700 / 3800 (facilement reconnaissable par le textolite noir) - 6,25 kHz, et dans les mod√®les plus anciens de la s√©rie DK d√©bogue, il peut atteindre jusqu'√† 10 kHz, mais cela co√ªte aussi ils sont d√©j√† 300 $ +. Pour les t√¢ches s√©rieuses, SiLabs recommande officiellement le Keysight susmentionn√©.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En principe, un tel appareil peut √™tre con√ßu par vous-m√™me - tout d'abord, vous avez besoin de tr√®s bons amplis op√©rationnels avec une polarisation d'entr√©e minimale, comme l'OPA2335. Ces amplificateurs op√©rationnels sont plac√©s sur le m√™me shunt de 2-3 pi√®ces avec diff√©rents facteurs d'amplification, tous sont enroul√©s sur diff√©rentes entr√©es ADC (avec cette approche, il est tout √† fait possible d'utiliser le microcontr√¥leur int√©gr√©), puis chaque acquisition de donn√©es d√©termine par programme lequel des amplificateurs op√©rationnels dans ce le moment n'est pas surcharg√©, les lectures de celui-ci sont compt√©es.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le probl√®me de la vitesse de transfert des donn√©es vers un ordinateur est r√©solu assez simplement - car pour des raisons pratiques, nous nous int√©ressons principalement √† la consommation moyenne du syst√®me dans la vie r√©elle, des lectures en microsecondes peuvent √™tre collect√©es dans le microcontr√¥leur embarqu√© du compteur et la moyenne arithm√©tique pour une √©chelle raisonnable en millisecondes peut √™tre envoy√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, comme le montre la pratique, il est tr√®s utile d'avoir un compteur-enregistreur, bien que simple et pas trop pr√©cis, mais toujours √† port√©e de main - afin de ne pas avoir de surprises avec une sorte de changement de firmware cass√© par des √©conomies d'√©nergie.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, nous en avons int√©gr√© un dans notre adaptateur USB standard UMDK-RF, qui est constamment utilis√© lors du d√©bogage du micrologiciel - il dispose d√©j√† d'un programmeur SWD avec prise en charge du protocole DAPLink, d'un pont USB-UART et d'une logique de gestion de l'alimentation, respectivement, il a obtenu un compteur de consommation presque gratuit. Le compteur lui-m√™me est un shunt de 1 Ohm et un amplificateur INA213 (gain 50 fois, d√©calage z√©ro typique 5 ŒºV): l' </font></font><br><br><img src="https://habrastorage.org/webt/me/l_/dr/mel_drvu6rqzwr1bebtbtayfiiw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amplificateur est connect√© directement √† l'entr√©e de l'ADC du microcontr√¥leur (STM32F042F6P6), l'ADC traite avec une p√©riode de 10 Œºs par une minuterie mat√©rielle, et via USB les donn√©es moyennes sont sorties pour un intervalle de 100 ms. En cons√©quence, en changeant quelque chose dans la logique du firmware, vous pouvez simplement aller fumer ou boire un caf√©, en laissant l'appareil sur la table et en revenant, regardez un calendrier comme celui-ci:</font></font><br><br><img src="https://habrastorage.org/webt/qp/e2/h1/qpe2h1zrmci58iozay_rmag-lsm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La pr√©cision d'un tel appareil "gratuit" n'est bien s√ªr pas √©lev√©e - avec un ADC 12 bits et un amplificateur, le quantum minimum est de 16 ŒºA, mais il est extr√™mement utile pour une √©valuation rapide et r√©guli√®re du comportement des appareils d√©bogu√©s du point de vue de la consommation d'√©nergie. En fin de compte, si vous faites quelque chose de mal dans le firmware ou l'appareil, avec une garantie tr√®s √©lev√©e, vous pourrez sortir des unit√©s de microamp√®res au moins des centaines, et cela sera clairement visible. </font></font><br><br><img src="https://habrastorage.org/webt/np/kb/ko/npkbkoxcwb3xsmoyshtkjtc3-jq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre avantage int√©ressant est que, puisque les donn√©es sont envoy√©es au port COM virtuel sous forme de texte (valeurs en microamp√®res), vous pouvez positionner la fen√™tre du terminal √† c√¥t√© de la fen√™tre affichant la console de l'appareil et regarder la consommation d'√©nergie simultan√©ment avec les messages de d√©bogage.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je m'en vante pour une raison, mais pour offrir √† tous ceux qui veulent utiliser ce programmeur de d√©bogueur minimal (et tr√®s bon march√©!) Dans leurs propres projets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pouvez</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dessiner le diagramme </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">ici</font></a><font style="vertical-align: inherit;"> ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source dans DipTrace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), faire glisser le firmware </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (brunch umdk-rf, lorsque la construction de la cible est UMDK-RF, bas√©e sur le projet </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dap42</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Le diagramme est dessin√© en d√©sordre, mais j'esp√®re que les points principaux sont clairs, le firmware est √©crit en C en utilisant libopencm3 et est assembl√© avec le bras-aucun-eabi-gcc habituel. En tant que fonctions suppl√©mentaires, le micrologiciel dispose d'une gestion de l'alimentation, captant les signaux de surcharge des touches de commande et entrant le contr√¥leur qui lui est connect√© dans son chargeur de d√©marrage natif en appuyant longuement sur un bouton.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NB: si vous voulez que le bouton de d√©marrage am√®ne le propre contr√¥leur du programmeur dans son chargeur de d√©marrage de mani√®re r√©guli√®re, il doit avoir la polarit√© de la connexion modifi√©e, les octets d'option d'√©dition du contr√¥leur au premier d√©marrage et l'entr√©e du programme dans le chargeur de d√©marrage supprim√©, et la polarit√© d'interruption pour le r√©gulier fonctions de ce bouton. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez voir comment la mesure actuelle est effectu√©e sur une paire d'amplificateurs op√©rationnels avec diff√©rents facteurs de gain (par exemple, pour am√©liorer le d√©bogueur d√©crit ci-dessus pour vos t√¢ches), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (p. 9), une alternative plus traditionnelle - avec un amplificateur op√©rationnel et un ADC 24 bits co√ªteux - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TI l'a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (EnergyTrace √† la page 5).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Veuillez noter que lors du d√©bogage avec un UART ou JTAG / SWD connect√©, un petit courant peut √©galement fuir √† travers leurs jambes, ce qui ne se produira pas pendant le fonctionnement r√©el de l'appareil. </font><font style="vertical-align: inherit;">Ainsi, sur UMDK-RF, environ 15 ŒºA fuient dans le SWD (et donc, dans la photo d'en-t√™te, les mesures avec un multim√®tre sont effectu√©es sur l'ancienne version de la carte, sans SWD), et sur le STM32 Nucleo, il y avait des cas de flux parasite √† travers le SWD d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">environ 200 ŒºA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Les cartes de d√©bogage utilis√©es pour la mesure doivent √™tre v√©rifi√©es pour ces fonctionnalit√©s - soit en d√©connectant leurs lignes d'interface, s'il y a une telle possibilit√©, soit en comparant les r√©sultats avec la consommation de l'appareil mesur√©e sans l'installer pour le d√©bogage, par exemple, avec un multim√®tre en mode statique.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au lieu d'une conclusion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> J'esp√®re que vous avez d√©j√† compris l'erreur que vous avez commise en choisissant la programmation des microcontr√¥leurs comme sp√©cialit√© principale. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430218/">https://habr.com/ru/post/fr430218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430206/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 18: Navigation priv√©e sur Internet, partie 2</a></li>
<li><a href="../fr430208/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 18: ¬´Navigation Internet priv√©e¬ª, partie 3</a></li>
<li><a href="../fr430210/index.html">Testez ma patience par la Check Point Security Academy</a></li>
<li><a href="../fr430212/index.html">OpenSceneGraph: principes de base de la g√©om√©trie de sc√®ne</a></li>
<li><a href="../fr430216/index.html">Si je comprends bien, je mange beaucoup de bonbons, ou le classement des marchandises par ch√®que dans l'application</a></li>
<li><a href="../fr430220/index.html">Comment transformer un hub USB ¬´centenaire¬ª en un smart managed et √©conomiser 300 $</a></li>
<li><a href="../fr430222/index.html">Ing√©nieur senior en recherche de travail. Comment j'ai v√©cu 20 entretiens avec les RH et ce que j'en pense</a></li>
<li><a href="../fr430224/index.html">Trouble schizotypique: un regard int√©rieur</a></li>
<li><a href="../fr430226/index.html">De la var b √† l'interview</a></li>
<li><a href="../fr430228/index.html">Marques en forme de X comme m√©thode d'identification radar utilisant l'analyse de donn√©es ouvertes de deux satellites scientifiques SENTINEL-1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>