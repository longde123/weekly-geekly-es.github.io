<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘°ğŸ¿ ğŸ›¸ ğŸ‘¨â€âš•ï¸ Mencoba instans operator yang ditingkatkan di Jawa 14 ğŸ¤¹ğŸ¾ ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ’ªğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tidak jauh dari itu, Java versi ke 14 yang baru , yang berarti inilah saatnya untuk melihat fitur sintaks baru apa yang akan terkandung dalam versi Ja...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mencoba instans operator yang ditingkatkan di Jawa 14</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477654/"> Tidak jauh dari itu, Java <a href="http://openjdk.java.net/projects/jdk/14/">versi ke 14 yang baru</a> , yang berarti inilah saatnya untuk melihat fitur sintaks baru apa yang akan terkandung dalam versi Java ini.  Salah satu kemungkinan sintaksis ini adalah <a href="https://openjdk.java.net/jeps/305">pencocokan pola dari tipe</a> yang akan diimplementasikan menggunakan <code>instanceof</code> operator yang ditingkatkan (diperluas). <br><br>  Hari ini saya ingin bermain-main dengan operator baru ini dan mempertimbangkan fitur kerjanya lebih detail.  Karena pencocokan pola berdasarkan tipe belum memasuki repositori JDK utama, saya harus mengunduh repositori <a href="https://openjdk.java.net/projects/amber/">dari proyek Amber</a> , yang sedang mengembangkan konstruksi sintaksis Java baru, dan <a href="https://builds.shipilev.net/workspaces/">mengkompilasi JDK</a> dari repositori ini. <br><a name="habracut"></a><br>  Jadi, hal pertama yang akan kita lakukan adalah memeriksa versi Java untuk memastikan bahwa kita benar-benar menggunakan JDK 14: <br><br><pre> <code class="bash hljs">&gt; java -version openjdk version <span class="hljs-string"><span class="hljs-string">"14-internal"</span></span> 2020-03-17 OpenJDK Runtime Environment (build 14-internal+0-adhoc.osboxes.amber-amber) OpenJDK 64-Bit Server VM (build 14-internal+0-adhoc.osboxes.amber-amber, mixed mode, sharing)</code> </pre> <br>  Benar juga. <br><br>  Sekarang kita akan menulis sepotong kode kecil dengan operator <code>instanceof</code> "lama" dan menjalankannya: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A().f(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String) { String str = (String) obj; System.out.println(str.toLowerCase()); } } }</code> </pre> <br><pre> <code class="bash hljs">&gt; java A.java hello, world!</code> </pre> <br>  Itu bekerja.  Ini adalah pemeriksaan tipe standar diikuti oleh pemain.  Kami menulis konstruksi yang sama setiap hari, apa pun versi Java yang kami gunakan, setidaknya 1,0, setidaknya 13. <br>  Tapi sekarang kita memiliki Java 14 di tangan kita, dan mari kita menulis ulang kode menggunakan <code>instanceof</code> operator yang ditingkatkan (saya akan menghilangkan baris kode berulang di masa depan): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">&gt; java --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-preview --<span class="hljs-built_in"><span class="hljs-built_in">source</span></span> 14 A.java hello, world!</code> </pre> <br>  Bagus  Kode ini lebih bersih, lebih pendek, lebih aman dan lebih mudah dibaca.  Ada tiga pengulangan kata String, satu menjadi.  Perhatikan bahwa kami tidak lupa untuk menentukan argumen <code>--enable-preview --source 14</code> , as  Operator baru adalah <a href="https://openjdk.java.net/jeps/12">fitur pratinjau</a> .  Selain itu, pembaca yang penuh perhatian mungkin memperhatikan bahwa kami menjalankan file sumber A.java secara langsung, tanpa kompilasi.  Fitur ini <a href="https://openjdk.java.net/jeps/330">muncul</a> di Java 11. <br><br>  Mari kita coba menulis sesuatu yang lebih canggih dan menambahkan kondisi kedua yang menggunakan variabel yang baru saja dinyatakan: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str &amp;&amp; str.length() &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { System.out.println(str.toLowerCase()); }</code> </pre> <br>  Ini mengkompilasi dan bekerja.  Tetapi bagaimana jika Anda menukar kondisi? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.length() &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:7: error: cannot find symbol <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.length() &gt; 5 &amp;&amp; obj instanceof String str) { ^</code> </pre> <br>  Kesalahan kompilasi.  Yang diharapkan: variabel <code>str</code> belum dideklarasikan, yang berarti tidak dapat digunakan. <br><br>  Ngomong-ngomong, bagaimana dengan mutabilitas?  Apakah variabelnya final atau tidak?  Kami mencoba: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { str = <span class="hljs-string"><span class="hljs-string">"World, hello!"</span></span>; System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:8: error: pattern binding str may not be assigned str = <span class="hljs-string"><span class="hljs-string">"World, hello!"</span></span>; ^</code> </pre> <br>  Ya, variabel terakhir.  Ini berarti bahwa kata "variabel" tidak sepenuhnya benar di sini.  Dan kompiler menggunakan istilah khusus "pola mengikat".  Oleh karena itu, saya mengusulkan mulai sekarang untuk mengatakan bukan "variabel", tetapi "pola mengikat" (sayangnya, kata "mengikat" tidak diterjemahkan dengan sangat baik ke dalam bahasa Rusia). <br><br>  Dengan mutabilitas dan terminologi beres.  Mari kita bereksperimen lebih jauh.  Bagaimana jika kita berhasil "memecahkan" kompiler? <br><br>  Bagaimana jika Anda memberi nama variabel dan pola yang mengikat dengan nama yang sama? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String obj) { System.out.println(obj.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:7: error: variable obj is already defined <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method f(Object) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj instanceof String obj) { ^</code> </pre> <br>  Masuk akal.  Tumpang tindih variabel dari lingkup luar tidak berfungsi.  Ini setara dengan seolah-olah kita baru saja memutus objek variabel <code>obj</code> kedua kalinya dalam cakupan yang sama. <br><br>  Dan jika demikian: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str &amp;&amp; obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:7: error: illegal attempt to redefine an existing match binding <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj instanceof String str &amp;&amp; obj instanceof String str) { ^</code> </pre> <br>  Kompiler sekuat beton. <br><br>  Apa lagi yang bisa Anda coba?  Mari kita bermain-main dengan cakupan.  Jika penjilidan didefinisikan di cabang <code>if</code> , apakah itu akan didefinisikan di cabang <code>else</code> jika kondisinya terbalik? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str)) { System.out.println(<span class="hljs-string"><span class="hljs-string">"not a string"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.out.println(str.toLowerCase()); }</code> </pre> <br>  Itu berhasil.  Kompiler tidak hanya dapat diandalkan, tetapi juga cerdas. <br><br>  Dan jika demikian? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { System.out.println(str.toLowerCase()); }</code> </pre> <br>  Berhasil lagi.  Compiler dengan benar memahami bahwa kondisi bermuara pada <code>obj instanceof String str</code> sederhana dari <code>obj instanceof String str</code> . <br><br>  Apakah benar-benar tidak mungkin untuk "memecahkan" kompiler? <br><br>  Mungkin begitu? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str || <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:8: error: cannot find symbol System.out.println(str.toLowerCase()); ^</code> </pre><br>  Ya!  Ini sudah terlihat seperti bug.  Bagaimanapun, ketiga kondisi ini benar-benar setara: <br><br><ul><li> <code>obj instanceof String str</code> </li> <li> <code>obj instanceof String str &amp;&amp; true</code> </li> <li> <code>obj instanceof String str || false</code> </li> </ul><br>  Di lain pihak, aturan pelingkupan aliran agak <a href="http://cr.openjdk.java.net/~briangoetz/amber/pattern-semantics.html">tidak trivial</a> , dan mungkin kasus seperti itu seharusnya tidak berhasil.  Tetapi jika Anda melihat murni dari sudut pandang manusia, maka saya pikir ini adalah bug. <br><br>  Tapi ayolah, mari kita coba yang lain.  Apakah ini akan berhasil: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(); } System.out.println(str.toLowerCase());</code> </pre> <br>  Disusun.  Ini bagus, karena kode ini setara dengan yang berikut: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.out.println(str.toLowerCase()); }</code> </pre> <br>  Dan karena kedua opsi tersebut setara, programmer berharap mereka bekerja dengan cara yang sama. <br><br>  Bagaimana dengan bidang yang tumpang tindih? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String str; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.out.println(str.toLowerCase()); } } }</code> </pre> <br>  Kompiler tidak bersumpah.  Ini logis, karena variabel lokal selalu bisa tumpang tindih bidang.  Rupanya, mereka juga memutuskan untuk tidak membuat pengecualian untuk binding pola.  Di sisi lain, kode semacam itu agak rapuh.  Satu gerakan ceroboh, dan Anda mungkin tidak memperhatikan bagaimana <code>if</code> cabang Anda rusak: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str || isOK()) { System.out.println(str.toLowerCase()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.out.println(str.toLowerCase()); } }</code> </pre> <br>  Kedua cabang sekarang menggunakan bidang <code>str</code> , yang mungkin tidak diharapkan oleh programmer yang lalai.  Untuk mendeteksi kesalahan seperti sedini mungkin, gunakan inspeksi di IDE dan penyorotan sintaksis yang berbeda untuk bidang dan variabel.  Saya juga merekomendasikan agar Anda selalu menggunakan kualifikasi <code>this</code> untuk bidang.  Ini akan menambah lebih banyak keandalan. <br><br>  Apa lagi yang menarik?  Seperti contoh "lama", yang baru tidak pernah cocok dengan <code>null</code> .  Ini berarti bahwa Anda selalu dapat mengandalkan fakta bahwa pengikat pola tidak pernah dapat menjadi <code>null</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); <span class="hljs-comment"><span class="hljs-comment">//    NullPointerException }</span></span></code> </pre> <br>  Omong-omong, menggunakan properti ini, Anda dapat mempersingkat rantai seperti: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { B b = a.getB(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { C c = b.getC(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { System.out.println(c.getSize()); } } }</code> </pre> <br>  Jika Anda menggunakan <code>instanceof</code> , maka kode di atas dapat ditulis ulang seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; a.getB() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> B b &amp;&amp; b.getC() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> C c) { System.out.println(c.getSize()); }</code> </pre> <br>  Tulis di komentar apa pendapat Anda tentang gaya ini.  Apakah Anda menggunakan idiom ini? <br><br>  Bagaimana dengan obat generik? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A().f(List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List&lt;Integer&gt; list) { System.out.println(list.size()); } } }</code> </pre> <br><pre> <code class="bash hljs">&gt; java --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-preview --<span class="hljs-built_in"><span class="hljs-built_in">source</span></span> 14 A.java Note: A.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> details. 3</code> </pre> <br>  Sangat menarik.  Jika <code>instanceof</code> "lama" hanya mendukung <code>instanceof List</code> atau <code>instanceof List&lt;?&gt;</code> , Maka yang baru berfungsi dengan tipe tertentu.  Kami sedang menunggu orang pertama jatuh ke dalam perangkap seperti itu: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List&lt;Integer&gt; list) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Int list of size "</span></span> + list.size()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List&lt;String&gt; list) { System.out.println(<span class="hljs-string"><span class="hljs-string">"String list of size "</span></span> + list.size()); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Mengapa ini tidak berhasil?</b> <div class="spoiler_text">  Jawab: kurangnya generik terverifikasi di Jawa. </div></div><br>  IMHO, ini masalah yang cukup serius.  Di sisi lain, saya tidak tahu cara memperbaikinya.  Sepertinya Anda harus mengandalkan inspeksi di IDE lagi. <br><br><h2>  Kesimpulan </h2><br>  Secara umum, tipe pencocokan pola yang baru berfungsi sangat keren.  Operator <code>instanceof</code> ditingkatkan memungkinkan Anda untuk melakukan tidak hanya pengujian jenis, tetapi juga mendeklarasikan pengikat siap pakai dari jenis ini, menghilangkan kebutuhan untuk casting manual.  Ini berarti bahwa akan ada lebih sedikit noise dalam kode, dan akan jauh lebih mudah bagi pembaca untuk membedakan logika yang bermanfaat.  Misalnya, sebagian besar <code>equals()</code> implementasi dapat ditulis dalam satu baris: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; â€¦ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.hash(x, y); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Point p &amp;&amp; px == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x &amp;&amp; py == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Kode di atas dapat ditulis lebih pendek.</b>  <b class="spoiler_title">Bagaimana?</b> <div class="spoiler_text">  Menggunakan <a href="https://openjdk.java.net/jeps/359">entri</a> yang juga akan dimasukkan dalam Java 14. Kami akan membicarakannya lain kali. </div></div><br>  Di sisi lain, beberapa poin kontroversial menimbulkan pertanyaan kecil: <br><br><ul><li>  Aturan cakupan tidak sepenuhnya transparan (contoh dengan <code>instanceof || false</code> ). </li><li>  Bidang yang tumpang tindih. </li><li>  <code>instanceof</code> dan generik. </li></ul><br>  Namun, ini adalah nitpicking lebih kecil daripada klaim serius.  Semua dalam semua, manfaat besar dari operator <code>instanceof</code> baru pasti layak ditambahkan bahasa.  Dan jika masih meninggalkan status pratinjau dan menjadi sintaks yang stabil, maka akan menjadi motivasi yang bagus untuk akhirnya meninggalkan Java 8 ke versi Java yang baru. <br><br>  NB Saya memiliki <a href="https://t.me/miniJUG">saluran di Telegram di</a> mana saya menulis tentang berita Jawa.  Saya mendorong Anda untuk berlangganan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477654/">https://habr.com/ru/post/id477654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477642/index.html">Visi mesin (radio) melihat melalui dinding</a></li>
<li><a href="../id477644/index.html">Mengembalikan UNIX v0 ke PDP-7: Detail Backroom</a></li>
<li><a href="../id477646/index.html">Matematikawan memotong bentuk untuk mencari bagian persamaan</a></li>
<li><a href="../id477648/index.html">MVCC dalam PostgreSQL-3. Versi baris</a></li>
<li><a href="../id477650/index.html">Enkripsi lalu lintas TLS menurut algoritma GOST-2012 dengan Stunnel</a></li>
<li><a href="../id477656/index.html">Jadi tetap saja, mengapa Anda perlu membuatnya?</a></li>
<li><a href="../id477658/index.html">Active Restore: dapatkah pemulihan bencana lebih cepat? Jauh lebih cepat?</a></li>
<li><a href="../id477662/index.html">Akses ke Redd Ban di Jembatan FTDI</a></li>
<li><a href="../id477668/index.html">29 November, 6 malam - devleads-mitap</a></li>
<li><a href="../id477670/index.html">Apa yang memberi otomatisasi pengujian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>