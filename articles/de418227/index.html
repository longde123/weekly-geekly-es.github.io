<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✝️ 🐫 👩‍👩‍👧‍👦 MIT-Kurs "Computer Systems Security". Vorlesung 7: Die Native Client Sandbox, Teil 3 👩🏽‍💻 🤹🏼 🤜🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 7: Die Native Client Sandbox, Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418227/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die Vorträge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gefährden, und Sicherheitstechniken, die auf jüngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen gehören Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: „Einführung: Bedrohungsmodelle“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: „Kontrolle von Hackerangriffen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 3: „Pufferüberläufe: Exploits und Schutz“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 4: „Trennung von Privilegien“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 5: „Woher kommen Sicherheitssysteme?“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> <br>  Vorlesung 6: „Chancen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 7: „Native Client Sandbox“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  In Regel <b>C4</b> gibt es eine Einschränkung.  Sie können nicht über das Ende eines Programms "springen".  Das Letzte, zu dem Sie springen können, ist die letzte Anweisung.  Diese Regel garantiert also, dass bei der Ausführung des Programms in der Prozess-Engine keine Diskrepanz auftritt. <br><br>  Regel <b>C5</b> besagt, dass es keine Anweisungen geben darf, die größer als 32 Byte sind.  Wir haben eine bestimmte Version dieser Regel in Betracht gezogen, als wir über die Vielzahl der Befehlsgrößen bis 32 Byte gesprochen haben. Andernfalls können Sie in die Mitte des Befehls springen und ein Problem mit dem Systemaufruf verursachen, der sich dort "verstecken" kann. <br><br>  Regel <b>C6</b> besagt, dass alle verfügbaren Anweisungen von Anfang an zerlegt werden können.  Dies stellt somit sicher, dass wir jede Anweisung sehen und alle Anweisungen überprüfen können, die ausgeführt werden, wenn das Programm ausgeführt wird. <br><br>  Regel <b>C7</b> besagt, dass alle direkten Sprünge korrekt sind.  Sie springen beispielsweise direkt zu dem Teil der Anweisung, in dem das Ziel angegeben ist, und obwohl es kein Vielfaches von 32 ist, ist es immer noch die richtige Anweisung, auf die die Demontage von links nach rechts angewendet wird. <br><br><img src="https://habrastorage.org/webt/1-/3i/vl/1-3ivlo26n7llpnkbkvzgzm-tci.jpeg"><br><br>  <b>Teilnehmerin:</b> Was ist der Unterschied zwischen <b>C5</b> und <b>C3</b> ? <br><br>  <b>Professor:</b> Ich denke, <b>C5</b> sagt, dass ein Multibyte-Befehl die Grenzen benachbarter Adressen nicht überschreiten kann.  Angenommen, ich habe einen Befehlsstrom und es gibt eine Adresse 32 und eine Adresse 64. Ein Befehl kann also das Grenzmultiplikator von 32 Bytes nicht überschreiten, dh er darf nicht mit einer Adresse kleiner als 64 beginnen und mit einer Adresse größer als 64 enden. <br><br><img src="https://habrastorage.org/webt/di/oc/l5/diocl5ztxk3kmc1ol0mmm_badik.jpeg"><br><br>  Dies ist, was Regel <b>C5</b> sagt.  Denn andernfalls können Sie nach einem Sprung der Multiplizität 32 in die Mitte eines anderen Befehls gelangen, bei dem nicht bekannt ist, was passiert. <br><br>  Und Regel <b>C3</b> ist ein Analogon zu diesem Verbot auf der Seite des Sprunges.  Es besagt, dass bei jedem Sprung die Länge Ihres Sprungs ein Vielfaches von 32 sein muss. <br><br>  <b>C5</b> behauptet auch, dass alles im Adressbereich, das ein Vielfaches von 32 ist, eine sichere Anweisung ist. <br><br>  Nachdem ich die Liste dieser Regeln gelesen hatte, hatte ich ein gemischtes Gefühl, da ich nicht beurteilen konnte, ob diese Regeln ausreichend sind, dh die Liste ist minimal oder vollständig. <br>  Denken wir also über die Hausaufgaben nach, die Sie erledigen müssen.  Ich denke, dass tatsächlich ein Fehler im Betrieb des <b>nativen Clients</b> vorliegt, wenn einige komplizierte Anweisungen in der Sandbox ausgeführt werden.  Ich glaube, dass sie nicht die richtige Längencodierung hatten, was zu etwas Schlechtem führen könnte, aber ich kann mich nicht genau erinnern, was der Fehler war. <br><br>  Angenommen, ein Sandbox-Validator erhält fälschlicherweise die Länge einer Anweisung.  Was kann in diesem Fall passieren?  Wie würden Sie diesen Slip verwenden? <br><br>  <b>Zielgruppe:</b> Sie können beispielsweise den Systemaufruf oder die return-Anweisung <b>ret</b> ausblenden. <br><br>  <b>Professor:</b> Ja.  Angenommen, es gibt eine ausgefallene Version der <b>AND-</b> Anweisung, die Sie aufgeschrieben haben.  Es ist möglich, dass der Validator sich geirrt hat und angenommen hat, dass seine Länge 6 Bytes mit der tatsächlichen Länge von 5 Bytes beträgt. <br><br><img src="https://habrastorage.org/webt/2z/ak/mg/2zakmgsficxcsi5tqkqnb-r_tj4.jpeg"><br><br>  Was wird passieren?  Der Validator betrachtet die Länge dieses Befehls als 6 Bytes und hat einen anderen gültigen Befehl dahinter.  Der Prozessor verwendet jedoch beim Starten des Codes die tatsächliche Länge des Befehls, d. H. 5 Bytes.  Infolgedessen haben wir am Ende der <b>AND-</b> Anweisung ein freies Byte, in das wir einen Systemaufruf einfügen und zu unserem Vorteil verwenden können.  Und wenn wir hier ein <b>CD-</b> Byte einlegen, ist dies wie der Beginn einer anderen Anweisung.  Als nächstes werden wir etwas in die nächste 6-Byte-Spanne einfügen, und es wird wie eine Anweisung aussehen, die mit dem <b>CD-</b> Byte beginnt, obwohl es tatsächlich Teil der <b>AND-</b> Anweisung ist.  Danach können wir einen Systemaufruf tätigen und aus der Sandbox "entkommen". <br><br>  Daher muss der <b>Native Client-</b> Validator seine Aktionen mit den Aktionen der <b>CPU</b> synchronisieren, dh genau erraten, wie der Prozessor jeden Befehl interpretiert.  Und dies sollte auf jeder Ebene der Sandbox sein, was ziemlich schwierig zu implementieren ist. <br><br>  In der Tat gibt es andere interessante Fehler im <b>Native Client</b> .  Eine davon ist die falsche Bereinigung der Prozessorumgebung beim Sprung in die <b>Trusted Service Runtime</b> .  Ich denke, wir werden gleich darüber sprechen.  Die <b>Trusted Service Runtime</b> funktioniert jedoch grundsätzlich mit denselben <b>CPU-</b> Registern, mit denen nicht vertrauenswürdige Module ausgeführt werden können.  Wenn der Prozessor vergisst, etwas zu löschen oder neu zu starten, kann die Laufzeit dadurch beeinträchtigt werden, dass das unzuverlässige Modul als vertrauenswürdige Anwendung betrachtet wird und etwas getan wird, das nicht hätte getan werden sollen oder das nicht die Absicht der Entwickler war. <br><br>  Wo sind wir jetzt?  Im Moment verstehen wir, wie man alle Anweisungen zerlegt und wie man die Ausführung verbotener Anweisungen verhindert.  Nun wollen wir sehen, wie wir Speicher und Links für Code und Daten im <b>Native Client-</b> Modul speichern. <br><br>  Aus Leistungsgründen beginnen die <b>Native Client-</b> Mitarbeiter, Hardware-Unterstützung zu verwenden, um sicherzustellen, dass das Speichern von Speicher und Links nicht wirklich viel Aufwand verursacht.  Bevor ich jedoch über die von ihnen verwendete Hardwareunterstützung nachdenke, möchte ich Vorschläge hören. Wie könnte ich dasselbe ohne die Hardwareunterstützung tun?  Können wir nur Zugriff auf alle Speicherprozesse innerhalb der zuvor von der Maschine festgelegten Grenzen gewähren? <br><br>  <b>Zielgruppe:</b> Sie können Anweisungen instrumentieren, um alle hohen Bits zu löschen. <br><br><img src="https://habrastorage.org/webt/h1/b7/yg/h1b7ygdlwrvvs7y7ywxitmabec8.jpeg"><br><br>  <b>Professor:</b> Ja, das ist richtig.  Tatsächlich sehen wir, dass wir diese <b>UND-</b> Anweisung hier haben, und jedes Mal, wenn wir zum Beispiel irgendwohin springen, werden die niedrigen Bits gelöscht.  Wenn wir jedoch den gesamten möglichen Code behalten möchten, der innerhalb der niedrigen 256 MB ausgeführt wird, können wir einfach das erste Attribut <b>f</b> durch <b>0</b> ersetzen und <b>$ 0x0fffffe0</b> anstelle von <b>$ 0xffffffe0 erhalten</b> .  Dies löscht die unteren Bits und legt eine Obergrenze von 256 MB fest. <br><br>  Dies macht also genau das, was Sie anbieten, und stellt sicher, dass Sie sich bei jedem Sprung innerhalb von 256 MB befinden.  Und die Tatsache, dass wir die Demontage durchführen, ermöglicht es auch zu überprüfen, ob alle direkten Sprünge in Reichweite sind. <br><br>  Der Grund, warum sie dies für ihren Code nicht tun, ist, dass Sie auf der <b>x86-</b> Plattform <b>AND</b> sehr effektiv codieren können, wobei alle oberen Bits 1 sind. Dies führt zur Existenz eines 3-Byte-Befehls für <b>AND</b> und eines 2-Byte-Befehls für den Sprung.  Somit haben wir einen zusätzlichen Aufwand von 3 Bytes.  Wenn Sie jedoch ein High-Bit ohne Einheit benötigen, wie diese <b>0</b> anstelle von <b>f</b> , haben Sie plötzlich einen 5-Byte-Befehl.  Daher denke ich, dass sie sich in diesem Fall Sorgen um den Overhead machen. <br><br>  <b>Zielgruppe:</b> Gibt es ein Problem mit der Existenz einiger Anweisungen, die die Version erhöhen, die Sie erhalten möchten?  Das heißt, Sie können sagen, dass Ihre Anweisung eine konstante Tendenz oder so etwas haben kann? <br><br>  <b>Professor:</b> Ich denke schon.  Sie werden wahrscheinlich Anweisungen verbieten, die zu einer komplexen Adressformel springen, und nur Anweisungen unterstützen, die direkt zu diesem Wert springen, und dieser Wert erhält immer <b>AND</b> . <br><br>  <b>Zielgruppe:</b> Für den Zugriff auf den Speicher ist mehr erforderlich als ... <br><br>  <b>Professor:</b> Ja, weil es nur Code ist.  Und für den Zugriff auf Speicher auf der <b>x86-</b> Plattform gibt es viele seltsame Möglichkeiten, auf einen bestimmten Speicherort zuzugreifen.  Normalerweise müssen Sie zuerst den Speicherort berechnen, dann ein zusätzliches <b>UND</b> hinzufügen und erst dann darauf zugreifen.  Ich denke, dies ist der wahre Grund für ihre Besorgnis über den Leistungsabfall aufgrund der Verwendung dieses Toolkits. <br><br>  Auf der <b>x86-</b> Plattform oder zumindest auf der im Artikel beschriebenen 32-Bit-Plattform verwenden sie Hardwareunterstützung, anstatt die Code- und Adressdaten einzuschränken, die auf nicht vertrauenswürdige Module verweisen. <br><br>  Lassen Sie uns sehen, wie es aussieht, bevor wir herausfinden, wie das <b>NaCl-</b> Modul in einer Sandbox verwendet wird.  Diese Hardware wird als Segmentierung bezeichnet.  Es entstand noch bevor die <b>x86-</b> Plattform eine Auslagerungsdatei bekam.  Auf der <b>x86-</b> Plattform ist während des Vorgangs eine unterstützte Hardwaretabelle vorhanden.  Wir nennen es die Tabelle der Segmentdeskriptoren.  Es handelt sich um eine Reihe von Segmenten, die von 0 bis zum Ende einer Tabelle beliebiger Größe nummeriert sind.  Dies ist so etwas wie ein Dateideskriptor unter <b>Unix</b> , außer dass jeder Eintrag aus zwei Werten besteht: der <b>Basisbasis</b> und der Länge. <br><br>  Diese Tabelle sagt uns, dass wir ein Paar von Segmenten haben, und jedes Mal, wenn wir uns auf ein bestimmtes Segment beziehen, bedeutet dies in gewissem Sinne, dass es sich um ein Stück Speicher handelt, das an der Basisadresse der <b>Basis</b> beginnt und sich über die Länge <b>erstreckt</b> . <br><br><img src="https://habrastorage.org/webt/bc/5z/ly/bc5zlyp2hzg0aa6nn9nfsbbzwoe.jpeg"><br><br>  Dies hilft uns, die Speichergrenzen auf der <b>x86-</b> Plattform <b>beizubehalten</b> , da jeder Befehl, der auf den Speicher zugreift, auf ein bestimmtes Segment in dieser Tabelle verweist. <br><br>  Wenn wir beispielsweise <b>mov (% eax) (% ebx)</b> ausführen <b>, dh</b> den Speicherwert von einem im <b>EAX-</b> Register gespeicherten Zeiger auf einen anderen im <b>EBX-</b> Register gespeicherten Zeiger verschieben, weiß das Programm, wie die Start- und Endadressen lauten im Hinblick auf und speichert den Wert in der zweiten Adresse. <br><br>  Tatsächlich gibt es auf der <b>x86-</b> Plattform, wenn wir über Speicher sprechen, eine implizite Sache, die als Segmentdeskriptor bezeichnet wird, ähnlich einem Dateideskriptor in <b>Unix</b> .  Dies ist nur ein Index in der Deskriptortabelle. Sofern nicht anders angegeben, enthält jeder Operationscode ein Standardsegment. <br><br>  Wenn Sie <b>mov (% eax)</b> ausführen, bezieht sich dies daher auf <b>% ds</b> oder auf das Datensegmentregister, das ein spezielles Register in Ihrem Prozessor ist.  Wenn ich mich richtig erinnere, ist es eine 16-Bit-Ganzzahl, die auf diese Deskriptortabelle verweist. <br><br>  Das Gleiche gilt für <b>(% ebx)</b> - es bezieht sich auf denselben <b>% ds-</b> Segmentselektor.  Tatsächlich haben wir in <b>x86</b> eine Gruppe von 6 Code-Selektoren: <b>CS, DS, ES, FS, GS</b> und <b>SS</b> .  Der <b>CS-Anrufwähler wird</b> implizit zum Empfangen von Anweisungen verwendet.  Wenn Ihr Anweisungszeiger also auf etwas zeigt, bezieht er sich auf denjenigen, der den <b>CS-</b> Segment-Selektor ausgewählt hat. <br><br><img src="https://habrastorage.org/webt/li/vq/nz/livqnzyn6jk6muyb93siboedkik.jpeg"><br><br>  Die meisten Datenreferenzen verwenden implizit <b>DS</b> oder <b>ES</b> , <b>FS</b> und <b>GS</b> weisen auf einige besondere Dinge hin, und <b>SS wird</b> immer für Stapeloperationen verwendet.  Und wenn Sie <b>Push &amp; Pop</b> ausführen, stammen diese implizit aus dieser Segmentauswahl.  Dies ist eine ziemlich archaische Mechanik, die sich jedoch in diesem speziellen Fall als äußerst nützlich herausstellt. <br><br>  Wenn Sie beispielsweise im Selektor <b>% ds: addr</b> Zugriff auf eine Adresse erhalten, <b>leitet</b> die Hardware diese mit der Tabelle <b>adrr + T [% ds] .base</b> an die Operation <b>weiter</b> .  Dies bedeutet, dass die Adresslänge des Moduls aus derselben Tabelle stammt.  Jedes Mal, wenn Sie auf den Speicher zugreifen, verfügt er über eine Datenbank mit Segmentselektoren in Form von Deskriptortabelleneinträgen. Die von Ihnen angegebene Adresse wird mit der Länge des entsprechenden Segments abgeglichen. <br><br>  <b>Zielgruppe:</b> Warum wird es beispielsweise nicht zum Schutz des Puffers verwendet? <br><br>  <b>Professor:</b> Ja, das ist eine gute Frage!  Könnten wir dies zum Schutz vor Pufferüberläufen verwenden?  Zum Beispiel können Sie für jeden Puffer, den wir haben, die Pufferbasis hier und dort die Puffergröße einfügen. <br><br>  <b>Teilnehmerin:</b> Was ist, wenn Sie es nicht in eine Tabelle legen müssen, bevor Sie es schreiben möchten?  Sie müssen nicht ständig da sein. <br><br>  <b>Professor:</b> Ja.  Daher denke ich, dass der Grund dafür, dass dieser Ansatz nicht oft zum Schutz vor Pufferüberläufen verwendet wird, darin besteht, dass die Anzahl der Datensätze in dieser Tabelle 2 in der 16. Potenz nicht überschreiten kann, da Deskriptoren 16 Bit lang sind, aber tatsächlich Tatsächlich werden ein paar weitere Bits für andere Dinge verwendet.  Tatsächlich können Sie in dieser Tabelle nur 2 in der 13. Potenz der Datensätze platzieren.  Wenn Sie in Ihrem Code ein Datenarray haben, das größer als 2 <sup>13 ist</sup> , kann es daher zu einem Überlauf dieser Tabelle kommen. <br><br>  Darüber hinaus wäre es für den Compiler seltsam, diese Tabelle direkt zu verwalten, da sie normalerweise mithilfe von Systemaufrufen bearbeitet wird.  Sie können nicht direkt in diese Tabelle schreiben. Zuerst müssen Sie einen Systemaufruf an das Betriebssystem senden. Danach legt das Betriebssystem den Datensatz in dieser Tabelle ab.  Daher denke ich, dass die meisten Compiler einfach nicht mit einem so komplexen Speicherpuffer-Managementsystem umgehen wollen. <br><br><img src="https://habrastorage.org/webt/rp/sa/hb/rpsahbydh4eumva5z7st5cfuc2a.jpeg"><br><br>  Übrigens verwendet <b>Multex</b> diesen Ansatz: Es verfügt über 2 <sup>18</sup> Datensätze für verschiedene Segmente und 2 <sup>18</sup> Datensätze für mögliche Offsets.  Und jedes gemeinsame Bibliotheksfragment oder Speicherfragment sind separate Segmente.  Sie werden alle auf Reichweite geprüft und können daher nicht auf variabler Ebene verwendet werden. <br><br>  <b>Zielgruppe:</b> Vermutlich verlangsamt die ständige Notwendigkeit, den Kernel zu verwenden, den Prozess. <br><br>  <b>Professor:</b> Ja, das ist richtig.  Wir haben also Overhead aufgrund der Tatsache, dass wir, wenn plötzlich ein neuer Puffer auf dem Stapel erstellt wird, einen Systemaufruf ausführen müssen, um ihn hinzuzufügen. <br><br>  Wie viele dieser Elemente verwenden tatsächlich den Segmentierungsmechanismus?  Sie können sich vorstellen, wie es funktioniert.  Ich denke, standardmäßig haben alle diese Segmente in <b>x86</b> eine Basis gleich 0 und die Länge liegt zwischen 2 und 32. Auf diese Weise können Sie auf den gesamten gewünschten Speicherbereich zugreifen.  Daher codieren sie für <b>NaCl</b> die Basis 0 und setzen die Länge auf 256 Megabyte.  Dann zeigen sie auf alle Register von 6 Segmentselektoren in diesem Datensatz für den 256-MB-Bereich.  Wenn das Gerät auf den Speicher zugreift, ändert es ihn mit einem Offset von 256 MB.  Die Möglichkeit, das Modul zu ändern, ist daher auf 256 MB beschränkt. <br><br>  Ich denke, Sie verstehen jetzt, wie diese Hardware unterstützt wird und wie sie funktioniert, sodass Sie möglicherweise diese Segmentselektoren verwenden. <br>  Was kann also schief gehen, wenn wir diesen Plan nur umsetzen?  Können wir in einem nicht vertrauenswürdigen Modul aus der Segmentauswahl herausspringen?  Ich denke, eine Sache, mit der man vorsichtig sein muss, ist, dass diese Register wie reguläre Register sind und man Werte in sie hinein und aus ihnen heraus verschieben kann.  Daher müssen Sie sicherstellen, dass das nicht vertrauenswürdige Modul diese Segmentauswahlregister nicht verzerrt.  Denn irgendwo in der Deskriptortabelle befindet sich möglicherweise ein Datensatz, der auch der Quellensegmentdeskriptor für einen Prozess ist, der eine Basis von 0 und eine Länge von bis zu 2 <sup>32 hat</sup> . <br><br><img src="https://habrastorage.org/webt/vg/k-/sv/vgk-svh5b3xlsnke_meuehgaira.jpeg"><br><br>  Wenn also ein unzuverlässiges Modul <b>CS</b> , <b>DS</b> oder <b>ES</b> oder einen dieser Selektoren so ändern konnte, dass sie auf dieses ursprüngliche Betriebssystem verweisen, das Ihren gesamten Adressraum abdeckt, können Sie eine Speicherverknüpfung zu diesem Segment herstellen und " aus dem Sandkasten springen. <br><br>  Daher musste der <b>native Client</b> dieser verbotenen Liste einige weitere Anweisungen hinzufügen.  Ich denke, dass sie alle Anweisungen wie <b>mov% ds, es</b> und so weiter verbieten.  Daher können Sie in der Sandbox nicht das Segment ändern, auf das sich einige Dinge beziehen, die sich darauf beziehen.  Auf der <b>x86-</b> Plattform <b>sind</b> Anweisungen zum Ändern der Segmentdeskriptortabelle privilegiert, aber das Ändern der <b>ds, es</b> selbst usw.  Der Tisch ist völlig unprivilegiert. <br><br>  <b>Zielgruppe:</b> Können Sie die Tabelle so initialisieren, dass in allen nicht verwendeten Slots die Länge Null platziert wird? <br><br>  <b>Professor:</b> Ja.  Sie können die Tabellenlänge für etwas festlegen, bei dem keine nicht verwendeten Slots vorhanden sind.  Es stellt sich heraus, dass Sie diesen zusätzlichen Steckplatz mit 0 und 2 <sup>32</sup> wirklich benötigen, da die <b>vertrauenswürdige Laufzeitumgebung</b> in diesem Segment beginnen und Zugriff auf den gesamten Speicherbereich erhalten sollte.  Dieser Eintrag ist also erforderlich, damit die vertrauenswürdige <b>Laufzeitumgebung</b> funktioniert. <br><br>  Zielgruppe: Was wird benötigt, um die Länge der Ausgabe der Tabelle zu ändern? <br>  Professor: Sie müssen Root-Rechte haben.  <b>Linux hat</b> tatsächlich ein System namens <b>modify_ldt ()</b> für die lokale Deskriptortabelle, mit dem jeder Prozess seine eigene Tabelle ändern kann, <b>dh</b> es gibt tatsächlich eine Tabelle für jeden Prozess.  Auf der <b>x86-</b> Plattform ist dies jedoch komplizierter. Es gibt sowohl eine globale als auch eine lokale Tabelle.  Eine lokale Tabelle für einen bestimmten Prozess kann geändert werden. <br><br>  Versuchen wir nun herauszufinden, wie wir vom <b>Native Client-</b> Ausführungsprozess springen oder springen oder aus der Sandbox springen.  Was bedeutet es, aus uns herauszuspringen? <br><br><img src="https://habrastorage.org/webt/8t/lb/yj/8tlbyjy5erf0s-x7stz29ca1qae.jpeg"><br><br>  Wir müssen also diesen vertrauenswürdigen Code ausführen, und dieser vertrauenswürdige Code "lebt" irgendwo über der Grenze von 256 MB.  Um dorthin zu gelangen, müssen wir alle vom <b>Native Client</b> installierten Schutzfunktionen rückgängig machen.  Grundsätzlich kommt es darauf an, diese sechs Selektoren zu ändern.  Ich denke, dass unser Validator nicht die gleichen Regeln für Dinge anwenden wird, die sich oberhalb der 256-MB-Grenze befinden, daher ist dies recht einfach. <br><br>  Aber dann müssen wir irgendwie in die <b>vertrauenswürdige Laufzeit-Laufzeit</b> springen und die Segment-Selektoren auf die richtigen Werte für dieses riesige Segment neu installieren, wobei der Adressraum des gesamten Prozesses abgedeckt wird - dieser Bereich liegt zwischen 0 und 2 <sup>32</sup> .  Sie nannten solche Mechanismen, die in den <b>Native Client-</b> <b>Trampolinen</b> und <b>Trittbrettern vorhanden sind</b> .  Sie leben in einem niedrigen 64k-Modul.  Das Coolste ist, dass diese „Trampoline“ und „Sprünge“ Codeteile sind, die in den unteren 64 KB des Prozessraums liegen.  Dies bedeutet, dass dieses unzuverlässige Modul dorthin springen kann, da es sich um eine gültige Codeadresse handelt, die innerhalb der Grenzen von 32 Bit und innerhalb von 256 MB liegt.  Sie können also auf dieses Trampolin springen. <br><br>    <b>Native Client</b>    «» - .  ,  <b>Native Client</b>       «»,   trampoline      <b>trusted runtime</b> .         ,    <b>DS, CS</b>   ,       . <br><br>  ,        ,   -  <b>malo</b>   ,    «»,  «»  32-  . <br><br> ,     4096 + 32        ,     .   , ,   <b>mov %ds, 7</b> ,       <b>ds</b> ,   7         0  2 <sup>32</sup> .    <b>CS</b>       <b>trusted service runtime</b> ,     256 . <br><br><img src="https://habrastorage.org/webt/cr/fx/xj/crfxxjwdpg1tcflmflesmj_8obq.jpeg"><br><br>  ,     ,     ,         <b>trusted service runtime</b> ,    .            ,   .      DS ,   ,      ,     ,    -       . <br><br> ,        ? ,          «»? ,    ? <br><br> <b>:</b>    64. <br><br> <b>:</b> , ,          .         malo,       64,     32 .        ,       ,  ,     . <br><br>   ,        32-  ,       .  , ,        32 ,     32-    ,    .       «»    <b>trusted runtime</b>   32  . <br><br><img src="https://habrastorage.org/webt/hq/zy/tj/hqzytj99szvgxayslg6aqmwlmrk.jpeg"><br><br>      .     ,     ,     <b>DS, CS</b>   .    ,       256-  ,    <b>trusted runtime</b> ,      .                 . <br><br>         «»,      <b>trusted runtime</b>   256     <b>Native Client</b> . «»   <b>DS</b> , ,  <b>mov %ds, 7</b> ,        ,  <b>trusted runtime</b>    .     .     ,        «»,       - . <br><br>      <b>halt</b>    32-   «».        «»,   .      <b>trusted service runtime</b>      ,   1    . <br><br><img src="https://habrastorage.org/webt/50/am/cy/50amcyeulmago9zmrdvmjrsipvg.jpeg"><br><br>       <b>trusted service runtime</b> ,     ,        . <br><br> <b>:</b>   «»    ? <br><br> <b>:</b> «»     0  256   .        64-     ,    ,       «»,    - -.     <b>Native Client</b>       . <br><br> <b>:</b>          ? <br><br> <b>:</b> ,         ?  ,      «»?   ? <br><br> <b>:</b>    ,   ? <br><br> <b>:</b>  ,            -  <b>%eax</b> ,  <b>trusted runtime</b> : «,      »!      <b>EAX</b> ,    <b>mov</b> ,  «»      <b>EAX</b> ,        <b>trusted runtime</b> .   ,       «»? <br><br> <b>:</b> ,        ,         .   … <br><br> <b>:</b> ,   ,       —  ,       ,            0  2 <sup>32</sup> .   .         «»,                256 . <br><br>  ,      «»,          .  , «»    ,    .    ,   «»   . <br><br> <b>:</b>    «»   256 ? <br><br> <b>:</b>  ,      .    ,       <b>CS</b>         -  .     «»,       <b>halt</b> ,   mov,    <b>CS</b> ,        ,       256 . <br><br>  ,         ,    «».  ,       <b>DS</b> ,  ,  <b>CS</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und irgendwo springen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie es versuchen würden, könnten Sie wahrscheinlich eine Folge von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anweisungen entwickeln </font><font style="vertical-align: inherit;">, die dies außerhalb der Grenzen des Adressraums des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Native Client-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moduls tun könnten </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sehen uns also nächste Woche und sprechen über Web-Sicherheit.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I0Psvvky-44" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Vollversion des Kurses finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank für Ihren Aufenthalt bei uns.</font></font> Gefällt dir unser Artikel?  Möchten Sie weitere interessante Materialien sehen?  Unterstützen Sie uns, indem Sie eine Bestellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgeben</a> oder sie Ihren Freunden empfehlen. <b>Habr-Benutzer erhalten 30% Rabatt auf ein einzigartiges Analogon von Einstiegsservern, das wir für Sie erfunden haben:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ganze Wahrheit über VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s $ 20 oder wie teilt man den Server?</a>  (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfügbar). <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s bis Dezember kostenlos,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn Sie für einen Zeitraum von sechs Monaten bezahlen, können Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bestellen </font><font style="vertical-align: inherit;">.</font></font><br><br>  <b>Dell R730xd 2 mal günstiger?</b>  Nur wir haben <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 GB DDR4 6 x 480 GB SSD 1 Gbit / s 100 TV von 249 US-Dollar</a> in den Niederlanden und den USA!</b>  Lesen Sie mehr über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Aufbau eines Infrastrukturgebäudes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse mit Dell R730xd E5-2650 v4 Servern für 9.000 Euro für einen Cent?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418227/">https://habr.com/ru/post/de418227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418217/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 6: „Chancen“, Teil 1</a></li>
<li><a href="../de418219/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 6: Chancen, Teil 2</a></li>
<li><a href="../de418221/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 6: „Chancen“, Teil 3</a></li>
<li><a href="../de418223/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 7: Die Native Client Sandbox, Teil 1</a></li>
<li><a href="../de418225/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 7: Native Client Sandbox Teil 2</a></li>
<li><a href="../de418229/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 8: Netzwerksicherheitsmodell, Teil 1</a></li>
<li><a href="../de418233/index.html">BMW Mnemonik zum Finden von Grenzwerten</a></li>
<li><a href="../de418235/index.html">Orchestrierte Saga oder Erstellen von Geschäftstransaktionen in Diensten mit der Datenbank nach Dienstmuster</a></li>
<li><a href="../de418237/index.html">Entwicklung mandantenfähiger Anwendungen auf der SAP Cloud Platform in Neo, Teil 2: Autorisierung und Authentifizierung</a></li>
<li><a href="../de418239/index.html">48 Megapixel für Smartphone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>