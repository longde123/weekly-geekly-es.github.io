<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóíÔ∏è üë®‚Äçüíº üöñ Desarrollo de operadores de Kubernetes con Operator Framework üóûÔ∏è üëçüèø üëµüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como se menciona en el art√≠culo de Radar Technology , Lamoda se est√° moviendo activamente hacia la arquitectura de microservicios. La mayor√≠a de nuest...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de operadores de Kubernetes con Operator Framework</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lamoda/blog/446648/"><p><img src="https://habrastorage.org/getpro/habr/post_images/352/5c8/f16/3525c8f16510afa2b61b0ff9b8434a02.png" alt="Imagen"></p><br><p>  Como se menciona en el art√≠culo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Radar Technology</a> , Lamoda se est√° moviendo activamente hacia la arquitectura de microservicios.  La mayor√≠a de nuestros servicios se empaquetan con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Helm</a> y se implementan en Kubernetes.  Este enfoque satisface plenamente nuestras necesidades en el 99% de los casos.  El 1% permanece cuando la funcionalidad est√°ndar de Kubernetes no es suficiente, por ejemplo, cuando necesita configurar una copia de seguridad o actualizar un servicio para un evento espec√≠fico.  Para resolver este problema, utilizamos el patr√≥n del operador.  En esta serie de art√≠culos, yo, Grigory Mikhalkin, desarrollador del equipo de I + D de Lamoda, hablar√© sobre las lecciones que aprend√≠ de mi experiencia en el desarrollo de operadores de K8 utilizando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Marco del operador</a> . </p><a name="habracut"></a><br><h2 id="chto-takoe-operator">  ¬øQu√© es un operador? </h2><br><p>  Una forma de ampliar la funcionalidad de Kubernetes es crear sus propios controladores.  Las principales abstracciones en Kubernetes son objetos y controladores.  Los objetos describen el estado deseado del cl√∫ster.  Por ejemplo, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pod</a> describe qu√© contenedores deben iniciarse y los par√°metros de inicio, y el objeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ReplicaSet</a> indica cu√°ntas r√©plicas debe ejecutar un Pod determinado.  Los controladores controlan el estado del cl√∫ster en funci√≥n de la descripci√≥n de los objetos; en el caso descrito anteriormente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ReplicationController</a> admitir√° la cantidad de r√©plicas de Pod especificadas en ReplicaSet.  Con la ayuda de nuevos controladores, puede implementar l√≥gica adicional, como enviar notificaciones de eventos, recuperarse de una falla o administrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recursos de terceros</a> . </p><br><p>  Un operador es una aplicaci√≥n kubernetes que incluye uno o m√°s controladores que sirven a un recurso de terceros.  El concepto fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">inventado por el equipo CoreOS</a> en 2016, y recientemente, la popularidad de los operadores ha estado creciendo r√°pidamente.  Puede intentar encontrar el operador deseado en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lista en kubedex</a> (m√°s de 100 operadores disponibles p√∫blicamente se enumeran aqu√≠), as√≠ como en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OperatorHub</a> .  Existen 3 herramientas populares para el desarrollo de operadores: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubebuilder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Operator SDK</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Metacontroller</a> .  En Lamoda utilizamos el SDK del operador, por lo que hablaremos m√°s adelante. </p><br><h2 id="operator-sdk">  SDK de operador </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f7e/56d/194/f7e56d1948a2f5291ef189e7a03df9be.png" alt="Imagen"></p><br><p>  El SDK del operador es parte del marco del operador, que incluye dos partes m√°s importantes: Operator Lifecycle Manager y Operator Metering. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El SDK del operador</a> es un contenedor para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el tiempo de ejecuci√≥n del controlador</a> , una biblioteca popular para el desarrollo de controladores (que, a su vez, es un contenedor para el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cliente-go</a> ), un generador de c√≥digo + marco para escribir pruebas E2E. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Operator Lifecycle Manager</a> : un marco para administrar operadores existentes;  resuelve situaciones cuando el operador ingresa al modo zombie o se implementa una nueva versi√≥n. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Medici√≥n del operador</a> : como su nombre lo indica, recopila datos sobre el trabajo del operador y tambi√©n puede generar informes basados ‚Äã‚Äãen ellos. </li></ul><br><h2 id="sozdanie-novogo-proekta">  Crea un nuevo proyecto </h2><br><p>  Un ejemplo es un operador que monitorea un archivo con configuraciones en el repositorio y, cuando se actualiza, reinicia la implementaci√≥n del servicio con nuevas configuraciones.  El c√≥digo de muestra completo est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4c0/e84/ebc/4c0e84ebcba8cad49b2bea8506f79d32.png" alt="Imagen"></p><br><p>  Cree un proyecto con un nuevo operador: </p><br><pre><code class="plaintext hljs">operator-sdk new config-monitor</code> </pre> <br><p>  El generador de c√≥digo crear√° c√≥digo para el operador que trabaja en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">espacio de nombres</a> asignado.  Este enfoque es preferible a dar acceso a todo el cl√∫ster, ya que en caso de errores, los problemas se aislar√°n dentro del mismo espacio de nombres.  El operador de <code>cluster-wide</code> se puede generar agregando <code>--cluster-scoped</code> .  Los siguientes directorios se ubicar√°n dentro del proyecto creado: </p><br><ul><li>  cmd: contiene el <code>main package</code> , en el que <code>Manager</code> inicializa y se inicia; </li><li>  desplegar: contiene declaraciones del operador, CRD y los objetos necesarios para configurar el operador RBAC; </li><li>  pkg: aqu√≠ estar√° nuestro c√≥digo principal para nuevos objetos y controladores. </li></ul><br><p>  Solo hay un archivo <a href=""><code>cmd/manager/main.go</code></a> en <a href=""><code>cmd/manager/main.go</code></a> . </p><br><div class="spoiler">  <b class="spoiler_title">Fragmento de c√≥digo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// Become the leader before proceeding err = leader.Become(ctx, "config-monitor-lock") if err != nil { log.Error(err, "") os.Exit(1) } // Create a new Cmd to provide shared dependencies and start components mgr, err := manager.New(cfg, manager.Options{ Namespace: namespace, MetricsBindAddress: fmt.Sprintf("%s:%d", metricsHost, metricsPort), }) ... // Setup Scheme for all resources if err := apis.AddToScheme(mgr.GetScheme()); err != nil { log.Error(err, "") os.Exit(1) } // Setup all Controllers if err := controller.AddToManager(mgr); err != nil { log.Error(err, "") os.Exit(1) } ... // Start the Cmd if err := mgr.Start(signals.SetupSignalHandler()); err != nil { log.Error(err, "Manager exited non-zero") os.Exit(1) }</code> </pre> </div></div><br><p>  En la primera l√≠nea: <code>err = leader.Become(ctx, "config-monitor-lock")</code> : se selecciona un l√≠der.  En la mayor√≠a de los escenarios, solo se necesita una instancia activa de una declaraci√≥n en el espacio de nombres / cl√∫ster.  De forma predeterminada, el SDK del operador utiliza la estrategia <a href="">L√≠der para toda la vida</a> : la primera instancia lanzada del operador seguir√° siendo el l√≠der hasta que se elimine del cl√∫ster. </p><br><p>  Despu√©s de que esta instancia de operador ha sido nombrada l√≠der, se inicializa un nuevo <code>Manager</code> : <code>mgr, err := manager.New(...)</code> .  Sus responsabilidades incluyen: </p><br><ul><li>  <code>err := apis.AddToScheme(mgr.GetScheme())</code> - registro de nuevos esquemas de recursos; </li><li>  <code>err := controller.AddToManager(mgr)</code> - registro de controladores; </li><li>  <code>err := mgr.Start(signals.SetupSignalHandler())</code> - <code>err := mgr.Start(signals.SetupSignalHandler())</code> y controla los controladores. </li></ul><br><p>  Por el momento, no tenemos nuevos recursos ni controladores para el registro.  Puede agregar un nuevo recurso con el comando: </p><br><pre> <code class="plaintext hljs">operator-sdk add api --api-version=services.example.com/v1alpha1 --kind=MonitoredService</code> </pre> <br><p>  Este comando agregar√° la definici√≥n del esquema de recursos <code>MonitoredService</code> al directorio <code>pkg/apis</code> , as√≠ como yaml con la definici√≥n <code>CRD</code> en <code>deploy/crds</code> .  De todos los archivos generados, debe cambiar manualmente solo la definici√≥n de esquema en <a href=""><code>monitoredservice_types.go</code></a> .  El tipo <code>MonitoredServiceSpec</code> define el estado deseado del recurso: lo que el usuario especifica en yaml con la definici√≥n del recurso.  En el contexto de nuestro operador, el campo <code>Size</code> determina el n√∫mero deseado de r√©plicas, <code>ConfigRepo</code> indica de d√≥nde se pueden extraer las configuraciones actuales.  <code>MonitoredServiceStatus</code> determina el estado observado del recurso, por ejemplo, almacena los nombres de Pods que pertenecen a este recurso y los Pods de <code>spec</code> actuales. </p><br><p>  Despu√©s de editar el esquema, debe ejecutar el comando: </p><br><pre> <code class="plaintext hljs">operator-sdk generate k8s</code> </pre> <br><p>  Actualizar√° la definici√≥n de <code>CRD</code> en <code>deploy/crds</code> . </p><br><p>  Ahora creemos la parte principal de nuestro operador, el controlador: </p><br><pre> <code class="plaintext hljs">operator-sdk add controller --api-version=services.example.com/v1alpha1 --kind=Monitor</code> </pre> <br><p>  El archivo <a href=""><code>monitor_controller.go</code></a> aparecer√° en el <a href=""><code>monitor_controller.go</code></a> <code>pkg/controller</code> , en el que agregaremos la l√≥gica que necesitamos. </p><br><h2 id="razrabotka-kontrollera">  Desarrollo de controlador </h2><br><p>  El controlador es la principal unidad de trabajo del operador.  En nuestro caso, hay dos controladores: </p><br><ul><li>  El controlador del monitor supervisa los cambios de configuraci√≥n del servicio </li><li>  El controlador de actualizaci√≥n actualiza el servicio y lo mantiene en el estado deseado. </li></ul><br><p>  En esencia, el controlador es un bucle de control, monitorea la cola con los eventos a los que est√° suscrito y los procesa: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/220/2e6/a09/2202e6a0931df3e5b87c4442dd839615.png" alt="Imagen"></p><br><p>  El administrador crea y registra un nuevo controlador en el m√©todo <code>add</code> : </p><br><pre> <code class="plaintext hljs">c, err := controller.New("monitor-controller", mgr, controller.Options{Reconciler: r})</code> </pre> <br><p>  Usando el m√©todo <code>Watch</code> , lo suscribimos a eventos relacionados con la creaci√≥n de un nuevo recurso o la actualizaci√≥n de <code>Spec</code> de un recurso <code>MonitoredService</code> existente: </p><br><pre> <code class="plaintext hljs">err = c.Watch(&amp;source.Kind{Type: &amp;servicesv1alpha1.MonitoredService{}}, &amp;handler.EnqueueRequestForObject{}, common.CreateOrUpdateSpecPredicate)</code> </pre> <br><p>  El tipo de evento se puede configurar utilizando los par√°metros <code>src</code> y <code>predicates</code> .  <code>src</code> acepta objetos de tipo <code>Source</code> . </p><br><ul><li>  <code>Informer</code> : sondea peri√≥dicamente el <code>apiserver</code> busca de eventos que coincidan con el filtro; si existe dicho evento, lo coloca en la cola del controlador.  En <code>controller-runtime</code> este es un contenedor sobre <code>SharedIndexInformer</code> desde <code>client-go</code> . </li><li>  <code>Kind</code> tambi√©n es un contenedor sobre <code>SharedIndexInformer</code> , pero, a diferencia de <code>Informer</code> , crea de forma independiente una instancia de informador basada en los par√°metros pasados ‚Äã‚Äã(esquema del recurso monitoreado). </li><li>  <code>Channel</code> : acepta el <code>chan event.GenericEvent</code> como par√°metro, los eventos que lo atraviesan se colocan en la cola del controlador. </li></ul><br><p>  <code>redicates</code> espera objetos que satisfacen la interfaz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Predicate</code></a> .  De hecho, este es un filtro adicional para eventos, por ejemplo, al filtrar <code>UpdateEvent</code> puede ver exactamente qu√© cambios se realizaron en la <code>spec</code> recurso. </p><br><p>  Cuando llega un evento, un <code>EventHandler</code> acepta, el segundo argumento del m√©todo <code>Watch</code> , que envuelve el evento en el formato de solicitud que espera el <code>Reconciler</code> : </p><br><ul><li>  <code>EnqueueRequestForObject</code> : crea una solicitud con el nombre y el espacio de nombres del objeto que caus√≥ el evento; </li><li>  <code>EnqueueRequestForOwner</code> : crea una solicitud con los datos del padre del objeto.  Esto es necesario, por ejemplo, si el <code>Pod</code> controlado por recursos <code>Pod</code> sido eliminado y necesita comenzar su reemplazo; </li><li>  <code>EnqueueRequestsFromMapFunc</code> : toma como par√°metro la funci√≥n de <code>map</code> que recibe un evento (envuelto en <code>MapObject</code> ) y devuelve una lista de solicitudes.  <a href="">Un ejemplo cuando</a> se <a href="">necesita este controlador</a> : hay un temporizador, para cada tic del cual necesita extraer nuevas configuraciones para todos los servicios disponibles. </li></ul><br><p>  Las solicitudes se colocan en la cola del controlador, y uno de los trabajadores (de forma predeterminada, el controlador tiene una) extrae el evento de la cola y lo pasa a <code>Reconciler</code> . </p><br><p>  <strong>Reconciler</strong> implementa solo un m√©todo: <code>Reconcile</code> , que contiene la l√≥gica b√°sica del procesamiento de eventos: </p><br><div class="spoiler">  <b class="spoiler_title">m√©todo de conciliaci√≥n</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">func (r *ReconcileMonitor) Reconcile(request reconcile.Request) (reconcile.Result, error) { reqLogger := log.WithValues("Request.Namespace", request.Namespace, "Request.Name", request.Name) reqLogger.Info("Checking updates in repo for MonitoredService") // fetch the Monitor instance instance := &amp;servicesv1alpha1.MonitoredService{} err := r.client.Get(context.Background(), request.NamespacedName, instance) if err != nil { if errors.IsNotFound(err) { // Request object not found, could have been deleted after reconcile request. // Owned objects are automatically garbage collected. For additional cleanup logic use finalizers. // Return and don't requeue return reconcile.Result{}, nil } // Error reading the object - requeue the request. return reconcile.Result{}, err } // check if service's config was updated // if it was, send event to upgrade controller if podSpec, ok := r.isServiceConfigUpdated(instance); ok { // Update instance Spec instance.Status.PodSpec = *podSpec instance.Status.ConfigChanged = true err = r.client.Status().Update(context.Background(), instance) if err != nil { reqLogger.Error(err, "Failed to update service status", "Service.Namespace", instance.Namespace, "Service.Name", instance.Name) return reconcile.Result{}, err } r.eventsChan &lt;- event.GenericEvent{Meta: &amp;servicesv1alpha1.MonitoredService{}, Object: instance} } return reconcile.Result{}, nil }</code> </pre> </div></div><br><p>  El m√©todo acepta un objeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Request</code></a> con el campo <code>NamespacedName</code> , por el cual el recurso se puede extraer de la memoria cach√©: <code>r.client.Get(context.TODO(), request.NamespacedName, instance)</code> .  En el ejemplo, se realiza una solicitud al archivo con la configuraci√≥n del servicio referenciada por el campo <code>ConfigRepo</code> en la <code>spec</code> recurso.  Si la configuraci√≥n se actualiza, se <code>GenericEvent</code> un nuevo evento del tipo <code>GenericEvent</code> y se env√≠a al canal que escucha el controlador de <code>Upgrade</code> . </p><br><p>  Despu√©s de procesar la solicitud, <code>Reconcile</code> devuelve un objeto de tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Result</code></a> y <code>error</code> .  Si el campo <code>Result</code> es <code>Requeue: true</code> o <code>error != nil</code> , el controlador devolver√° la solicitud a la cola utilizando el m√©todo <code>queue.AddRateLimited</code> .  La solicitud se devolver√° a la cola con un retraso, que est√° determinado por <code>RateLimiter</code> .  De forma predeterminada, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>ItemExponentialFailureRateLimiter</code></a> utiliza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>ItemExponentialFailureRateLimiter</code></a> , que aumenta el tiempo de retraso exponencialmente con un aumento en el n√∫mero de "devoluciones" de la solicitud.  Si el campo <code>Requeue</code> no <code>Requeue</code> configurado y no se produjo ning√∫n error durante el procesamiento de la solicitud, el controlador llamar√° al m√©todo <code>Queue.Forget</code> , que eliminar√° la solicitud <code>RateLimiter</code> cach√© de <code>RateLimiter</code> (restableciendo as√≠ el n√∫mero de devoluciones).  Al final del procesamiento de la solicitud, el controlador lo elimina de la cola utilizando el m√©todo <code>Queue.Done</code> . </p><br><h2 id="zapusk-operatora">  Lanzamiento del operador </h2><br><p>  Los componentes del operador se describieron anteriormente, y quedaba una pregunta: c√≥mo iniciarlo.  Primero debe asegurarse de que est√©n instalados todos los recursos necesarios (para pruebas locales, recomiendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">configurar minikube</a> ): </p><br><pre> <code class="plaintext hljs"># Setup Service Account kubectl create -f deploy/service_account.yaml # Setup RBAC kubectl create -f deploy/role.yaml kubectl create -f deploy/role_binding.yaml # Setup the CRD kubectl create -f deploy/crds/services_v1alpha1_monitoredservice_crd.yaml # Setup custom resource kubectl create -f deploy/crds/services_v1alpha1_monitoredservice_cr.yaml</code> </pre> <br><p>  Una vez que se han cumplido los requisitos previos, hay dos formas f√°ciles de ejecutar la declaraci√≥n para la prueba.  Lo m√°s f√°cil es iniciarlo fuera del cl√∫ster con el comando: </p><br><pre> <code class="plaintext hljs">operator-sdk up local --namespace=default</code> </pre> <br><p>  La segunda forma es implementar el operador en el cl√∫ster.  Primero necesita construir una imagen Docker con el operador: </p><br><pre> <code class="plaintext hljs">operator-sdk build config-monitor-operator:latest</code> </pre> <br><p>  En el archivo <code>deploy/operator.yaml</code> , reemplace <code>REPLACE_IMAGE</code> con <code>config-monitor-operator:latest</code> : </p><br><pre> <code class="plaintext hljs">sed -i "" 's|REPLACE_IMAGE|config-monitor-operator:latest|g' deploy/operator.yaml</code> </pre> <br><p>  Crear implementaci√≥n con declaraci√≥n: </p><br><pre> <code class="plaintext hljs">kubectl create -f deploy/operator.yaml</code> </pre> <br><p>  Ahora en la lista de <code>Pod</code> en el cl√∫ster deber√≠a aparecer <code>Pod</code> con un servicio de prueba, y en el segundo caso, otro con un operador. </p><br><h2 id="vmesto-zaklyucheniya-ili-best-practices">  En lugar de una conclusi√≥n o mejores pr√°cticas </h2><br><p>  Los problemas clave del desarrollo del operador en este momento son la escasa documentaci√≥n de las herramientas y la falta de mejores pr√°cticas establecidas.  Cuando un nuevo desarrollador comienza a desarrollar un operador, pr√°cticamente no tiene d√≥nde mirar ejemplos de implementaci√≥n de un requisito particular, por lo que los errores son inevitables.  A continuaci√≥n hay algunas lecciones que aprendimos de nuestros errores: </p><br><ul><li>  Si hay dos aplicaciones relacionadas, debe evitar el deseo de combinarlas con un solo operador.  De lo contrario, se viola el principio de los servicios de acoplamiento flexible. </li><li>  Debe recordar la separaci√≥n de preocupaciones: no debe intentar implementar toda la l√≥gica en un controlador.  Por ejemplo, vale la pena difundir las funciones de monitoreo de configuraciones y crear / actualizar un recurso. </li><li>  El bloqueo de llamadas debe evitarse en el m√©todo <code>Reconcile</code> .  Por ejemplo, puede extraer configuraciones de una fuente externa, pero si la operaci√≥n es m√°s larga, cree una rutina para esto y env√≠e la solicitud nuevamente a la cola, indicando en la respuesta <code>Requeue: true</code> . </li></ul><br><p>  En los comentarios, ser√≠a interesante conocer su experiencia en el desarrollo de operadores.  Y en la siguiente parte hablaremos sobre las pruebas del operador. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446648/">https://habr.com/ru/post/446648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446634/index.html">SDN Digest - Seis emuladores de c√≥digo abierto</a></li>
<li><a href="../446638/index.html">Cisco HyperFlex vs. competidores: pruebas de rendimiento</a></li>
<li><a href="../446640/index.html">20 proyectos, 20 idiomas, fecha l√≠mite ayer. Parte 2</a></li>
<li><a href="../446642/index.html">Lista de verificaci√≥n para crear y publicar aplicaciones web</a></li>
<li><a href="../446644/index.html">C√≥mo ejecutar SMM en 2019: 17 diagramas de Neil Patel</a></li>
<li><a href="../446654/index.html">C√≥mo guardamos la revisi√≥n del c√≥digo</a></li>
<li><a href="../446656/index.html">Codificaci√≥n de voz de 1600 bits / s con codificador de voz neural LPCNet</a></li>
<li><a href="../446658/index.html">Entrevista con Andrei Stankevich sobre programaci√≥n deportiva.</a></li>
<li><a href="../446660/index.html">IA, estudiante y gran premio: c√≥mo hacer aprendizaje autom√°tico en octavo grado</a></li>
<li><a href="../446662/index.html">Transacciones y mecanismos para su control.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>