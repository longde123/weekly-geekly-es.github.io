<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‰ ğŸ§‘ğŸ¼â€ğŸ¤â€ğŸ§‘ğŸ¼ ğŸ‘¶ğŸ¾ Layanan, layanan microser dan pemrograman berorientasi batch ğŸ‘¸ğŸ¾ ğŸ§‘ğŸ½â€ğŸ¤â€ğŸ§‘ğŸ» ğŸ¬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak pemrogram telah mendengar bahwa kadang-kadang kode harus dialokasikan ke perpustakaan yang terpisah untuk digunakan kembali lebih lanjut. Namun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Layanan, layanan microser dan pemrograman berorientasi batch</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466455/">  Banyak pemrogram telah mendengar bahwa kadang-kadang kode harus dialokasikan ke perpustakaan yang terpisah untuk digunakan kembali lebih lanjut.  Namun, pertanyaan tentang kode seperti apa yang harus dipilih sebagai entitas terpisah membingungkan banyak pengembang.  Saat membaca artikel / percakapan tentang topik ini, masalah generalisasi prematur biasanya teringat kembali. <br><br>  Pemrogram berpengalaman biasanya memiliki aturan sendiri, yang mengikuti mereka memahami apakah kode harus dibedakan sebagai dapat digunakan kembali.  Misalnya, jika kode seperti itu (atau sangat mirip) digunakan di tiga tempat atau lebih.  Meskipun demikian, setiap orang yang pernah saya ajak bicara tentang hal ini setuju bahwa kode yang dapat digunakan kembali harus ada, penciptaannya adalah berkah, dan layak untuk menghabiskan waktu Anda. <br><br>  Saya ingin mengangkat topik penggunaan kembali kode dalam konteks menciptakan arsitektur berorientasi layanan dan layanan mikro. <br><a name="habracut"></a><br><h3>  Apa kode yang dapat digunakan kembali? </h3><br>  Kode yang dapat digunakan kembali adalah kode yang diisolasi dalam entitas terpisah, yang disebut berbeda dalam bahasa yang berbeda - perpustakaan, paket, ketergantungan, dll.  Biasanya, kode tersebut disimpan dalam repositori terpisah, dan ada dokumentasi untuk menghubungkan dan menggunakan kode ini (README.md).  Selain itu, kode dapat dicakup oleh tes, mungkin ada instruksi untuk melakukan perubahan (CONTRIBUTING.md), dan CI dapat dikonfigurasi.  Berbagai lencana yang dilampirkan pada deskripsi hanya meningkatkan representasi visual dari kematangan entitas yang diberikan, dan jumlah bintang yang diberikan akan menunjukkan popularitas solusi ini.  Anda tidak perlu pergi jauh untuk contoh - cukup buka halaman github dari salah satu kerangka kerja populer dalam bahasa favorit Anda, misalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vue.js.</a>  Secara umum, metode desain perpustakaan berkualitas tinggi adalah gerobak dan troli kecil. <br><br><h3>  Layanan dan layanan microser </h3><br>  Dalam artikel ini, layanan adalah entitas lengkap yang melakukan serangkaian tugas khusus dalam domain tanggung jawabnya dan menyediakan antarmuka untuk interaksi.  Layanan atau layanan mikro dalam artikel ini dari sudut pandang arsitektur dapat berupa konsep yang identik, pertanyaannya hanya dalam skala.  Suatu layanan dapat terdiri dari serangkaian layanan microser yang mengimplementasikan sektor logika bisnis mereka, atau menjadi layanan microser yang membanggakan. <br><br>  Arsitektur berorientasi layanan mengasumsikan bahwa setiap layanan minimal terhubung dengan yang lain.  Namun demikian, interaksi antar-layanan tidak dikecualikan, tetapi hanya diasumsikan bahwa itu harus diminimalkan.  Untuk menerima permintaan, suatu layanan biasanya mengimplementasikan beberapa API standar.  Itu bisa apa saja - SISA, SABUN, JSONRPC atau GraphQL bermodel baru. <br><br>  Secara konvensional, layanan dapat dibagi menjadi infrastruktur dan bahan makanan.  Layanan produk adalah mereka yang menerapkan logika produk klien.  Misalnya, mereka bekerja dengan aplikasi untuk koneksinya, atau mengatur dukungan untuk produk ini sepanjang seluruh siklus hidup klien.  Layanan infrastruktur lebih banyak tentang fungsi dasar suatu perusahaan (atau proyek), misalnya, layanan yang berisi informasi pelanggan, atau layanan yang menyimpan informasi tentang pesanan tertentu.  Selain itu, layanan infrastruktur mencakup layanan yang mengimplementasikan fungsi bantu, misalnya, layanan informasi pelanggan (mengirim pesan push atau SMS) atau layanan untuk berinteraksi dengan dadata. <br><br><h3>  Sedikit fantasi </h3><br>  Misalkan ada toko online hipotetis yang dibangun di atas arsitektur berorientasi layanan.  Para pengembang keajaiban teknik ini dapat menyetujui di antara mereka sendiri dan sampai pada kesimpulan bahwa semua layanan mereka akan berfungsi sebagai API, misalnya, menggunakan protokol jsonrpc.  Namun, karena toko online itu besar, tidak berdiri diam dan aktif berkembang, ada beberapa kelompok pengembangan di sana, biarlah lebih dari dua - dua yang desain, satu disertai dengan apa yang sudah ditulis.  Juga, untuk meningkatkan efek, semua tim menulis di tumpukan yang sama. <br><br>  <i>Arsitektur toko online hipotetis:</i> <br><br><img src="https://habrastorage.org/webt/8t/di/2r/8tdi2rdhusrs66kvbyrwkcoauag.png"><br><br>  Hanya layanan API yang menonjol di Internet yang menyediakan akses ke semua sistem front-end - antarmuka web toko online, serta aplikasi seluler. <br><br>  Layanan informasi pelanggan menyimpan informasi tentang pelanggan, tahu bagaimana memulainya, memberikan otorisasi, mengeluarkan informasi yang diperlukan tentang mereka. <br><br>  Layanan informasi produk menyimpan informasi tentang produk, saldo dan ketersediaannya untuk pemesanan, juga menyediakan metode untuk memperoleh informasi yang diperlukan dengan mudah. <br><br>  Layanan pesanan beroperasi dengan pesanan.  Berikut adalah logika pembentukan pesanan, konfirmasinya, pilihan jenis pembayaran dan alamat pengiriman, dll. <br><br>  Layanan informasi pelanggan dapat mengirim PUSH / SMS / pesan email.  Jenis komunikasi, misalnya, tergantung pada pengaturan klien tertentu, dan klien juga dapat mengatur waktu yang diinginkan untuk menerima pemberitahuan. <br><br>  Layanan ini bersifat prasarana kondisional, karena tanpa mereka toko online tidak dapat berfungsi seperti itu. <br><br>  Layanan promosi dan penawaran serta distribusi intisari seharusnya dikembangkan dalam waktu dekat oleh tim proyek.  Layanan ini adalah kelontong bersyarat. <br><br>  Jelas, dalam hal apa pun, layanan produk baru apa pun tidak akan dapat eksis tanpa interaksi dengan layanan infrastruktur - kemungkinan besar harus menerima informasi tentang pelanggan atau perlu mengirim pemberitahuan. <br><br>  Dalam contoh yang dijelaskan di atas, detail implementasi setiap layanan sengaja disembunyikan.  Jadi, misalnya, layanan informasi pelanggan mungkin memiliki mekanisme eksekusi kode tertunda, seperti antrian eksekusi, dan layanan informasi produk dapat memiliki panel admin sendiri untuk manajemen barang yang nyaman, dan api untuk sistem front-end mungkin memiliki beberapa replika.  Selain itu, arsitektur yang digambarkan mungkin tidak optimal, hanya diambil dari kepala. <br><br>  Dalam konteks arsitektur yang diusulkan, segera menjadi jelas bahwa perpustakaan siap pakai sangat penting untuk pengembangan produk yang cepat.  Jadi, penting untuk memiliki implementasi yang siap pakai dari server jsonrpc, serta klien untuk itu, karena ini adalah protokol utama untuk mengatur interaksi antar layanan.  Juga dalam contoh ini, masalah mendokumentasikan API meningkat sepenuhnya.  Jelas, untuk pembentukan dokumentasi, tim juga harus memiliki alat yang sudah jadi.  Jika kita berasumsi bahwa masih ada alat yang siap pakai untuk menghasilkan skema smd untuk server jsonrpc, maka kecepatan pengembangan layanan baru dapat meningkat lebih jauh.  Akibatnya, di dalam perusahaan, idealnya, harus ada satu set perpustakaan siap pakai yang digunakan semua tim untuk melakukan tugas-tugas khas.  Pustaka-pustaka ini dapat berupa milik atau open-source, yang utama adalah mereka melakukan tugasnya dengan baik.  Jelas, tim yang ada di tumpukan umum dan menulis layanan menggunakan perpustakaan siap pakai akan lebih efektif daripada tim yang terus-menerus siklus.  Kehadiran satu kerangka kerja dan satu database perpustakaan yang digunakan di semua tim proyek, saya sebut ekosistem tunggal. <br><br><h3>  Dan bagaimana dengan perusahaan besar? </h3><br>  Di perusahaan besar, ada jauh lebih banyak layanan infrastruktur, serta protokol interaksi yang digunakan.  Jumlah perpustakaan yang sudah jadi bisa mencapai puluhan atau bahkan ratusan.  Menyoroti dalam kode yang dapat digunakan kembali di sini bahkan lebih relevan. <br><br>  Kebetulan saya memiliki pengalaman di sebuah perusahaan yang mempekerjakan sekitar 200 pengembang yang menulis dalam berbagai bahasa - java, c #, php, python, go, js, dll. Anehnya, ekosistem umum, dalam konteks tumpukan tunggal, jauh dari semua tim pengembangan miliki dan gunakan.  Tampaknya hal yang jelas - untuk mempersiapkan kode yang dapat digunakan kembali, memformatnya dengan benar dan menggunakannya - masih jauh dari jelas.  Tentu saja, tim pengembangan menyelesaikan masalah mereka.  Seseorang menggunakan templat layanan - satu set kode yang membentuk inti dari setiap layanan baru, dari mana segala sesuatu yang tidak perlu dibuang dan yang diperlukan ditambahkan. <br><br>  Tim pengembang lain menggunakan sepeda motor mereka sendiri, menyalin dan menempelkannya dari proyek ke proyek, dan tidak peduli mendokumentasikan dan mengujinya.  Secara umum, ada banyak perpecahan dalam alat dan pendekatan yang digunakan dalam tumpukan yang sama di satu perusahaan.  Apalagi secara geografis terletak di satu kota. <br><br><h3>  Manfaat ekosistem tunggal </h3><br>  Membentuk ekosistem tunggal dapat mengatasi banyak kesulitan, dan memiliki potensi besar untuk meningkatkan produktivitas bagi perusahaan besar.  Faktanya, praktik ini diambil dari komunitas Open Source - solusi terbaik di bidangnya bertahan dan paling populer.  Sekarang cukup untuk membuka manajer dependensi dan hanya akan terkejut dengan banyaknya solusi yang diusulkan.  Tetapi pendekatan semacam itu dapat diterapkan di dalam perusahaan.  Keuntungan dari pendekatan ini ketika menerapkan layanan baru adalah sebagai berikut: <br><br><ul><li>  Stabilitas tinggi - penggunaan perpustakaan yang dicoba dan didokumentasikan dengan baik meningkatkan stabilitas layanan secara keseluruhan; </li><li>  Rotasi kolega yang mudah antar tim - jika semua tim berada di dalam ekosistem tunggal, maka ketika berpindah dari satu tim ke tim lainnya, pengembang tidak perlu menghabiskan banyak waktu untuk mengetahui alat yang digunakan, karena ia sudah mengenal mereka; </li><li>  Konsentrasi pada logika bisnis - memang, pengembangan layanan baru bermuara pada kebutuhan untuk memperketat ketergantungan yang diperlukan yang menyelesaikan semua tugas infrastruktur dan hanya menulis logika bisnis; </li><li>  Akselerasi pengembangan - tidak perlu berputar, semuanya sudah siap, kecuali untuk logika bisnis; </li><li>  Penyederhanaan pengujian - hanya logika bisnis yang perlu diuji, karena perpustakaan telah diuji; </li></ul><br><h3>  Terbang di salep </h3><br>  Jelas bahwa untuk mencapai pendekatan ini, beberapa praktik harus diikuti, yaitu, mengembangkan perpustakaan menggunakan versi semantik, mengurus dokumentasi dan tes, dan telah dikonfigurasi.  Ini adalah semacam indikator kedewasaan tidak hanya dari tim pengembangan, tetapi juga pengembang di perusahaan secara keseluruhan. <br><br><h3>  PS </h3><br>  Dan pendekatan berorientasi paket hanya karena kode yang dapat digunakan kembali pada stack saya disebut paket.  Ya, itu terdengar lucu.  Baru-baru ini, saya berdialog dengan salah satu kolega saya yang mendorong saya untuk menulis artikel ini: <br><blockquote>  - Rekan: Anda berubah menjadi kasir dalam lima <br>  - saya: artinya?) <br>  - Rekan: segera Anda akan bertanya "apakah Anda memerlukan paket?" <br>  - I: tolong buka pikiran.  saya tidak mengerti <br>  - Rekan kerja: yah, untuk kesekian kalinya Anda memiliki paket yang sudah jadi untuk menyelesaikan masalah saya <br></blockquote><br>  Masalahnya adalah bahwa di komunitas pengembang kami di dalam perusahaan ada sekitar 20 buah paket siap pakai, dan penciptaan layanan baru diterjemahkan menjadi menarik ketergantungan yang diperlukan, serta menulis logika bisnis.  Biaya mengikat dalam hal penulisan kode hampir dibatalkan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466455/">https://habr.com/ru/post/id466455/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466445/index.html">Serangan antara trust di antara domain</a></li>
<li><a href="../id466447/index.html">Untuk apa kita membangun CDN?</a></li>
<li><a href="../id466449/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 44. Pengantar OSPF</a></li>
<li><a href="../id466451/index.html">Baca_Anda tidak bisa_menghapus</a></li>
<li><a href="../id466453/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 45. Mengkonfigurasi OSPF</a></li>
<li><a href="../id466457/index.html">Pertanian dan panel surya - strategi win-win untuk insinyur listrik dan petani</a></li>
<li><a href="../id466459/index.html">Tes Integrasi Paralel Postgresql di Aplikasi GO</a></li>
<li><a href="../id466461/index.html">Zabbix Summit 2019: apa yang diharapkan tahun ini</a></li>
<li><a href="../id466463/index.html">Bagaimana kami membuat aplikasi perbaikan prototipe berhenti</a></li>
<li><a href="../id466465/index.html">Summ3r 0f h4ck 2019: hasil penelitian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>