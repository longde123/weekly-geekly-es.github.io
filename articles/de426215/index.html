<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™ üë®‚Äç‚ù§Ô∏è‚Äçüë® üåà Fragen zur Lebensfreigabe ü§∂üèª üçà üçï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jeder Entwickler stellte Fragen zum Aktivit√§tslebenszyklus: Was ist ein Bindedienst, wie wird der Status der Benutzeroberfl√§che gespeichert, wenn der ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fragen zur Lebensfreigabe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/426215/"><img src="https://habrastorage.org/webt/iq/rl/ci/iqrlcirhwliuqufp0rlca6brqfk.jpeg"><br><br><p>  Jeder Entwickler stellte Fragen zum Aktivit√§tslebenszyklus: Was ist ein Bindedienst, wie wird der Status der Benutzeroberfl√§che gespeichert, wenn der Bildschirm gedreht wird, und wie unterscheidet sich Fragment von Aktivit√§t? <br>  Wir bei FunCorp haben eine Liste mit Fragen zu √§hnlichen Themen zusammengestellt, jedoch mit bestimmten Nuancen.  Ich m√∂chte einige davon mit Ihnen teilen. </p><a name="habracut"></a><br><p>  <strong>1.</strong> Jeder wei√ü, dass die Lebenszyklus-Anrufkette folgenderma√üen aussieht, wenn Sie die zweite Aktivit√§t √ºber der ersten √∂ffnen und den Bildschirm drehen: </p><br><div class="spoiler">  <b class="spoiler_title">Er√∂ffnungsaktivit√§t</b> <div class="spoiler_text"><p>  <em>FirstActivity: onPause</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onResume</em> <em><br></em>  <em>FirstActivity: onSaveInstanceState</em> <em><br></em>  <em>FirstActivity: onStop</em> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Drehen Sie sich</b> <div class="spoiler_text"><p>  <em>SecondActivity: onPause</em> <em><br></em>  <em>SecondActivity: onSaveInstanceState</em> <em><br></em>  <em>SecondActivity: onStop</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onRestoreInstanceState</em> <em><br></em>  <em>SecondActivity: onResume</em> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Kehre zur√ºck</b> <div class="spoiler_text"><p>  <em>SecondActivity: onPause</em> <em><br></em>  <em>FirstActivity: onCreate</em> <em><br></em>  <em>FirstActivity: onStart</em> <em><br></em>  <em>FirstActivity: onRestoreInstanceState</em> <em><br></em>  <em>SecondActivity: onStop</em> </p></div></div><br><p>  Und was passiert, wenn die zweite Aktivit√§t transparent ist? </p><br><p>  <strong>L√∂sung</strong> </p><br><p>  Bei transparenter Top-Aktivit√§t ist logisch alles etwas anders.  Gerade weil es transparent ist, m√ºssen nach der Rotation der Inhalt und die Aktivit√§t, die sich direkt darunter befindet, wiederhergestellt werden.  Daher unterscheidet sich die Reihenfolge der Anrufe geringf√ºgig: </p><br><div class="spoiler">  <b class="spoiler_title">Erkennungsaktivit√§t</b> <div class="spoiler_text"><p>  <em>FirstActivity: onPause</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onResume</em> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Drehen Sie sich</b> <div class="spoiler_text"><p>  <em>SecondActivity: onPause</em> <em><br></em>  <em>SecondActivity: onSaveInstanceState</em> <em><br></em>  <em>SecondActivity: onStop</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onRestoreInstanceState</em> <em><br></em>  <em>SecondActivity: onResume</em> <em><br></em>  <em>FirstActivity: onSaveInstanceState</em> <em><br></em>  <em>FirstActivity: onStop</em> <em><br></em>  <em>FirstActivity: onCreate</em> <em><br></em>  <em>FirstActivity: onStart</em> <em><br></em>  <em>FirstActivity: onRestoreInstanceState</em> <em><br></em>  <em>FirstActivity: onResume</em> <em><br></em>  <em>FirstActivity: onPause</em> </p></div></div><br><p>  <strong>2.</strong> Keine Anwendung kann auf das dynamische Hinzuf√ºgen einer Ansicht verzichten, aber manchmal m√ºssen Sie dieselbe Ansicht zwischen verschiedenen Bildschirmen verschieben.  Kann dasselbe Objekt gleichzeitig zu zwei verschiedenen Aktivit√§ten hinzugef√ºgt werden?  Was passiert, wenn ich es mit dem Anwendungskontext erstelle und es gleichzeitig verschiedenen Aktivit√§ten hinzuf√ºgen m√∂chte? </p><br><p>  <strong>Warum wird das ben√∂tigt?</strong> <br>  Es gibt "nicht sehr angenehme" Bibliotheken, die wichtige Gesch√§ftslogik in benutzerdefinierten Ansichten enthalten, und das Neuerstellen dieser Ansichten in jeder neuen Aktivit√§t ist eine schlechte Entscheidung, da  Ich m√∂chte einen Datensatz haben. </p><br><p><img src="https://habrastorage.org/webt/zs/-e/zk/zs-ezkaoyfadfd-xmrh-fhbm0pa.jpeg" width="200" height="350"><img src="https://habrastorage.org/webt/_r/yz/ie/_ryzienmkhodnc2lqx8mqiouj44.jpeg" width="200" height="350"><img src="https://habrastorage.org/webt/lz/y1/6g/lzy16g4ls7spgu9jqs8dqbpiaaa.jpeg" width="200" height="350"></p><br><p>  <strong>L√∂sung</strong> </p><br><p>  Nichts verhindert das Erstellen einer Ansicht mit dem Anwendungskontext.  Es werden einfach Standardstile angewendet, die sich nicht auf eine Aktivit√§t beziehen.  Sie k√∂nnen diese Ansicht auch problemlos zwischen verschiedenen Aktivit√§ten verschieben, m√ºssen jedoch sicherstellen, dass sie nur einem √ºbergeordneten Element hinzugef√ºgt wird </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addViewInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, LayoutParams params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> preventRequestLayout)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child.getParent() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"The specified child already has a parent. "</span></span> + <span class="hljs-string"><span class="hljs-string">"You must call removeView() on the child's parent first."</span></span>); } ... }</code> </pre> <br><p>  Sie k√∂nnen beispielsweise ActivityLifecycleCallbacks abonnieren, onStop (removeView) aus der aktuellen Aktivit√§t l√∂schen und onStart zum n√§chsten √ñffnen (addView) hinzuf√ºgen. </p><br><p>  <strong>3. Das</strong> Fragment kann durch Hinzuf√ºgen und Ersetzen hinzugef√ºgt werden.  Und was ist der Unterschied zwischen diesen beiden Optionen in Bezug auf die Reihenfolge des Aufrufs von Lebenszyklusmethoden?  Was sind die Vorteile von jedem von ihnen? </p><br><p>  <strong>L√∂sung</strong> </p><br><p>  Selbst wenn Sie ein Fragment durch Ersetzen hinzuf√ºgen, bedeutet dies nicht, dass es vollst√§ndig ersetzt wird.  Dies bedeutet, dass an dieser Stelle im Container die Ansicht ersetzt wird. Daher wird onDestroyView f√ºr das aktuelle Fragment aufgerufen und onCreateView wird bei der R√ºckkehr erneut aufgerufen. </p><br><br><p>  Dies √§ndert ziemlich genau die Spielregeln.  Sie m√ºssen alle Controller und Klassen, die der Benutzeroberfl√§che zugeordnet sind, in onDestroyView trennen.  Es ist notwendig, den Empfang der f√ºr das Fragment erforderlichen Daten und das Ausf√ºllen der Ansicht (Listen usw.) klar zu trennen, da das Ausf√ºllen und Unterbrechen der Ansicht viel h√§ufiger erfolgt als das Empfangen von Daten (Lesen einiger Daten aus der Datenbank). </p><br><p>  Es gibt auch Nuancen bei der Statuswiederherstellung: Beispielsweise kommt onSaveInstanceState manchmal nach onDestroyView.  Dar√ºber hinaus sollte ber√ºcksichtigt werden, dass wenn null in onViewStateRestored eingeht, dies bedeutet, dass Sie nichts wiederherstellen m√ºssen, aber nicht auf den Standardstatus zur√ºckgesetzt werden m√ºssen. </p><br><p>  Wenn wir √ºber die Bequemlichkeit zwischen Hinzuf√ºgen und Ersetzen sprechen, ist das Ersetzen im Speicher wirtschaftlicher, wenn Sie √ºber eine tiefe Navigation verf√ºgen (wir haben eine Benutzer-Navigationstiefe f√ºr einen der Produkt-KPIs).  Es ist auch viel bequemer, die Symbolleiste durch Ersetzen zu ersetzen, da Sie sie in onCreateView erneut fixieren k√∂nnen.  Von den Vorteilen von add: weniger Probleme mit dem Lebenszyklus, wenn Sie zur√ºckkehren, erstelle ich die Ansicht nicht neu und muss nichts neu f√ºllen. </p><br><p>  <strong>4.</strong> Manchmal m√ºssen Sie immer noch direkt mit Diensten und sogar mit Bindungsdiensten arbeiten.  Die Aktivit√§t interagiert mit einem dieser Dienste (nur eine Aktivit√§t).  Es stellt eine Verbindung zum Dienst her und √ºbertr√§gt Daten an diesen.  Wenn Sie den Bildschirm drehen, wird unsere Aktivit√§t zerst√∂rt und wir sind verpflichtet, von diesem Dienst abzuprallen.  Wenn jedoch keine Verbindung besteht, wird der Dienst zerst√∂rt und nach dem Abbinden wird bind an einen v√∂llig anderen Dienst gesendet.  Wie stellen Sie sicher, dass der Dienst beim Einschalten weiterhin aktiv ist? </p><br><p>  <strong>L√∂sung</strong> </p><br><p>  Wenn Sie eine sch√∂ne L√∂sung kennen, schreiben Sie in die Kommentare.  Es f√§llt nur etwas √Ñhnliches ein: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy(); ThreadsUtils.postOnUiThread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ unbindService(mConnection); } }); }</code> </pre> <br><p>  <strong>5.</strong> K√ºrzlich haben wir die Navigation in unserer Anwendung f√ºr einzelne Aktivit√§ten (unter Verwendung einer der verf√ºgbaren Bibliotheken) √ºberarbeitet.  Fr√ºher war jeder Anwendungsbildschirm eine separate Aktivit√§t, jetzt arbeitet die Navigation an Fragmenten.  Das Problem der R√ºckkehr zur Aktivit√§t in der Mitte des Stapels wurde durch Absichtsflags gel√∂st.  Wie kann ich zu dem Fragment in der Mitte des Stapels zur√ºckkehren? </p><br><p>  <strong>L√∂sung</strong> </p><br><p>  Ja, FragmentManager bietet keine sofort einsatzbereiten L√∂sungen.  Cicerone macht etwas √Ñhnliches in sich selbst: </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BackTo command)</span></span></span><span class="hljs-function"> </span></span>{ String key = command.getScreenKey(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { backToRoot(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = localStackCopy.indexOf(key); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = localStackCopy.size(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; size - index; i++) { localStackCopy.pop(); } fragmentManager.popBackStack(key, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { backToUnexisting(command.getScreenKey()); } } }</code> </pre> <br><p>  <strong>6.</strong> Au√üerdem haben wir k√ºrzlich eine so ineffiziente und komplexe Komponente wie ViewPager beseitigt, da die Logik der Interaktion sehr kompliziert ist und das Verhalten von Fragmenten in bestimmten F√§llen nicht vorhersehbar ist.  In einigen Fragmenten haben wir innere Fragmente verwendet.  Was passiert, wenn Fragmente in RecycleView-Elementen verwendet werden? </p><br><p>  <strong>L√∂sung</strong> </p><br><p>  Im Allgemeinen wird nichts falsch sein.  Das Fragment wird problemlos hinzugef√ºgt und angezeigt.  Das einzige, mit dem wir konfrontiert sind, sind Inkonsistenzen mit dem Lebenszyklus.  Die Implementierung auf dem ViewPager verwaltet den Lebenszyklus der Fragmente √ºber setUserVisibleHint, und die RecycleView erledigt alles auf der Stirn, ohne √ºber die tats√§chliche Sichtbarkeit und Verf√ºgbarkeit der Fragmente nachzudenken. </p><br><p>  <strong>7. Aus</strong> dem gleichen Grund, aus dem wir von ViewPager gewechselt sind, ist das Problem der Wiederherstellung des Status aufgetreten.  Bei Fragmenten wurde dies vom Framework implementiert: An den richtigen Stellen haben wir einfach onSaveInstanceState neu definiert und alle notwendigen Daten im Bundle gespeichert.  Wenn Sie den ViewPager neu erstellen, wurden alle Fragmente vom FragmentManager wiederhergestellt und haben ihren Status zur√ºckgegeben.  Was tun mit RecycleView und seinem ViewHolder? </p><br><p>  <strong>L√∂sung</strong> </p><br><p>  ‚ÄûMan muss jedes Mal alles in die Datenbank schreiben und daraus lesen‚Äú, sagen Sie.  Oder die Logik zum Speichern des Status sollte au√üerhalb liegen und die Liste ist nur eine Anzeige.  In einer idealen Welt ist es.  In unserem Fall ist jedes Element der Liste ein komplexer Bildschirm mit einer eigenen Logik.  Daher musste ich mein Fahrrad im Stil ‚ÄûLasst uns die gleiche Logik wie im ViewPager und im Fragment ausf√ºhren‚Äú erfinden: </p><br><div class="spoiler">  <b class="spoiler_title">Adapter</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecycleViewGalleryAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecyclerView</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Adapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GalleryItemViewHolder</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GalleryAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String RV_STATE_KEY = <span class="hljs-string"><span class="hljs-string">"RV_STATE"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Bundle mSavedState; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GalleryItemViewHolder holder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holder.isAttached()) { holder.detach(); } holder.attach(createArgs(position, getItemViewType(position))); restoreItemState(holder); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ Bundle adapterState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bundle(); saveItemsState(adapterState); bundle.putBundle(RV_STATE_KEY, adapterState); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bundle == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } mSavedState = bundle.getBundle(RV_STATE_KEY); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreItemState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GalleryItemViewHolder holder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mSavedState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { holder.restoreState(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } String stateKey = String.valueOf(holder.getGalleryItemId()); Bundle state = mSavedState.getBundle(stateKey); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { holder.restoreState(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); mSavedState = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } holder.restoreState(state); mSavedState.remove(stateKey); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveItemsState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle outState)</span></span></span><span class="hljs-function"> </span></span>{ GalleryItemHolder holder = getCurrentGalleryViewItem(); saveItemState(outState, (GalleryItemViewHolder) holder); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveItemState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle, GalleryItemViewHolder holder)</span></span></span><span class="hljs-function"> </span></span>{ Bundle itemState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bundle(); holder.saveState(itemState); bundle.putBundle(String.valueOf(holder.getGalleryItemId()), itemState); } }</code> </pre> </div></div><br><p>  Bei Fragment.onSaveInstanceState lesen wir den Status der ben√∂tigten Inhaber und f√ºgen sie in das Bundle ein.  Beim erneuten Erstellen der Halter erhalten wir das gespeicherte Bundle und auf dem onBindViewHolder √ºbergeben wir die gefundenen Zust√§nde innerhalb der Halter: </p><br><p>  <strong>8.</strong> Womit bedroht uns das? </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity); ViewGroup root = findViewById(R.id.default_id); ViewGroup view1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinearLayout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); view1.setId(R.id.default_id); root.addView(view1); ViewGroup view2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameLayout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); view2.setId(R.id.default_id); view1.addView(view2); ViewGroup view3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RelativeLayout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); view3.setId(R.id.default_id); view2.addView(view3); }</code> </pre> <br><p>  <strong>L√∂sung</strong> </p><br><p>  In der Tat ist daran nichts auszusetzen.  In derselben RecycleView werden Listen von Elementen mit derselben ID gespeichert.  Es gibt jedoch noch eine kleine Nuance: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &lt;T extends View&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findViewTraversal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@IdRes </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == mID) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> View[] where = mChildren; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = mChildrenCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { View v = where[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { v = v.findViewById(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) v; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br><p>  Es sollte vorsichtig sein, wenn wir Elemente mit derselben ID in der Hierarchie haben, weil  Es ist immer das erste gefundene Element, das immer zur√ºckgegeben wird, und auf verschiedenen Ebenen des Aufrufs findViewById k√∂nnen es verschiedene Objekte sein. </p><br><p>  <strong>9.</strong> Sie fallen von TooLargeTransaction ab, wenn Sie den Bildschirm drehen (ja, hier ist unser ViewPager immer noch indirekt schuld).  Wie finde ich den T√§ter? </p><br><p>  <strong>L√∂sung</strong> </p><br><p>  Es ist ganz einfach: H√§ngen Sie ActivityLifecycleCallbacks an die Anwendung, fangen Sie alle onActivitySaveInstanceState ab und analysieren Sie alles, was im Bundle enthalten ist.  Dort k√∂nnen Sie den Status aller Ansichten und Fragmente innerhalb dieser Aktivit√§t abrufen. </p><br><p>  Unten sehen Sie ein Beispiel, wie wir den Zustand von Fragmenten aus dem Bundle erhalten: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Tries to find saved [FragmentState] in bundle using 'android:support:fragments' key. */</span></span> fun Bundle.getFragmentsStateList(): List&lt;FragmentBundle&gt;? { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { val fragmentManagerState: FragmentManagerState? = getParcelable(<span class="hljs-string"><span class="hljs-string">"android:support:fragments"</span></span>) val active = fragmentManagerState?.mActive ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> emptyList() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> active.filter { it.mSavedFragmentState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }.map { fragmentState -&gt; FragmentBundle(fragmentState.mClassName, fragmentState.mSavedFragmentState) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (throwable: Throwable) { Assert.fail(throwable) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ application.registerActivityLifecycleCallbacks(object : SimpleActivityLifecycleCallback() { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivitySaveInstanceState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: Activity, outState: Bundle?)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onActivitySaveInstanceState(activity, outState) outState?.let { ThreadsUtils.runOnMainThread { trackActivitySaveState(activity, outState) } } } }) } <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackActivitySaveState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: Activity, outState: Bundle)</span></span></span><span class="hljs-function"> </span></span>{ val sizeInBytes = outState.getSizeInBytes() val fragmentsInfos = outState.getFragmentsStateList() ?.map { mapFragmentsSaveInstanceSaveInfo(it) } ... }</code> </pre> <br><p>  Als n√§chstes berechnen wir einfach die Gr√∂√üe des Bundles und protokollieren es: </p><br><pre> <code class="java hljs"> fun Bundle.getSizeInBytes(): Int { val parcel = Parcel.obtain() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parcel.writeValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) parcel.dataSize() } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { parcel.recycle() } }</code> </pre><br><p>  <strong>10.</strong> Angenommen, wir haben eine Aktivit√§t und eine Reihe von Abh√§ngigkeiten davon.  Unter bestimmten Bedingungen m√ºssen wir eine Reihe dieser Abh√§ngigkeiten neu erstellen (z. B. durch Klicken auf ein bestimmtes Experiment mit einer anderen Benutzeroberfl√§che).  Wie setzen wir das um? </p><br><p>  <strong>L√∂sung</strong> </p><br><p>  Nat√ºrlich k√∂nnen Sie mit Flaggen basteln und es durch den Start der Absicht zu einer Art ‚ÄûKr√ºcke‚Äú machen.  Tats√§chlich ist jedoch alles sehr einfach - Aktivit√§t hat eine Wiederherstellungsmethode. </p><br><p>  H√∂chstwahrscheinlich wird das meiste dieses Wissens f√ºr Sie nicht n√ºtzlich sein, da Sie nicht aus einem guten Leben zu jedem von ihnen kommen.  Einige von ihnen zeigen jedoch gut, wie eine Person argumentieren und L√∂sungen vorschlagen kann.  Wir verwenden √§hnliche Fragen in Interviews.  Wenn Sie interessante Aufgaben haben, die Sie in den Interviews l√∂sen sollten, oder wenn Sie sie selbst festlegen, schreiben Sie sie in die Kommentare - es wird interessant sein, dar√ºber zu diskutieren! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426215/">https://habr.com/ru/post/de426215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426205/index.html">Mit der Ver√∂ffentlichung von Chrome werden 70.000 Websites, die durch Symantec-Zertifikate gesch√ºtzt sind, nicht mehr vertrauensw√ºrdig</a></li>
<li><a href="../de426207/index.html">Es wird bald kalt: Lernen Sie Pekatherm kennen und w√§hlen Sie beheizte Handschuhe</a></li>
<li><a href="../de426209/index.html">PeerTube 1.0: Video-Hosting ohne Rechenzentrum und Kapitalkosten</a></li>
<li><a href="../de426211/index.html">Gehen Sie gegen Javascript. Wie schreibe ich IoT-Projekte?</a></li>
<li><a href="../de426213/index.html">Eine Gruppe von Tankstellenmitarbeitern wurde festgenommen, die mithilfe von Software und Elektronik 5% korrigierten und organisierten, indem sie an der Tankstelle nicht tanken</a></li>
<li><a href="../de426217/index.html">Wie ist die Sicherheit Ihres Windows-Betriebssystems organisiert?</a></li>
<li><a href="../de426223/index.html">Android-Entwicklung und L√∂sung von Entwicklungsproblemen</a></li>
<li><a href="../de426227/index.html">Wie man Kaggle "bewirtschaftet"</a></li>
<li><a href="../de426229/index.html">Verhaltenskodex: Warum Linux-Kernel-Entwickler drohten, ihren Code zu entfernen - Den Konflikt verstehen</a></li>
<li><a href="../de426231/index.html">Gro√übritannien will das Internet regulieren - welche Auswirkungen neue Gesetze haben werden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>