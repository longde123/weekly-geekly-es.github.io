<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèæ üëµüèø ü§∂üèæ Not One Spring Boot: Tinjauan Alternatif üëèüèø üë®üèº üàÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat ini tidak ada kekurangan kerangka kerja untuk membuat layanan microser di Jawa dan Kotlin. Artikel ini membahas hal-hal berikut: 
 Judul  Versi  ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Not One Spring Boot: Tinjauan Alternatif</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/456376/"><img src="https://habrastorage.org/webt/al/mw/1g/almw1ghoqrvuf2nbw_awcwqvqe4.png"><br><br>  Saat ini tidak ada kekurangan kerangka kerja untuk membuat layanan microser di Jawa dan Kotlin.  Artikel ini membahas hal-hal berikut: <br><div class="scrollable-table"><table><tbody><tr><th>  Judul </th><th>  Versi </th><th>  Tahun rilis pertama </th><th>  Pengembang </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Helidon se</a> </td><td>  1.1.1 </td><td>  2019 </td><td>  Oracle </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ktor</a> </td><td>  1.2.1 </td><td>  2018 </td><td>  Otak Jet </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Micronaut</a> </td><td>  1.1.3 </td><td>  2018 </td><td>  Komputasi objek </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Boot musim semi</a> </td><td>  2.1.5 </td><td>  2014 </td><td>  Sangat penting </td></tr></tbody></table></div><a name="habracut"></a><br>  Berdasarkan mereka, empat layanan telah dibuat yang dapat berinteraksi satu sama lain melalui API HTTP menggunakan pola Penemuan Layanan yang diimplementasikan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konsul</a> .  Dengan demikian, mereka membentuk arsitektur layanan mikro yang heterogen (pada tingkat kerangka kerja) (selanjutnya disebut sebagai ISA): <br><br><img src="https://habrastorage.org/webt/tv/mv/kp/tvmvkpurtljgpl3yhxhtpmse4_g.png"><br><br>  Tetapkan serangkaian persyaratan untuk setiap layanan: <br><br><ul><li>  tumpukan teknologi: <br><ul><li>  JDK 12; </li><li>  Kotlin </li><li>  Gradle (Kotlin DSL); </li><li>  JUnit 5. </li></ul><br></li><li>  fungsionalitas (HTTP API): <br><ul><li><code>GET /application-info{?request-to=some-service-name}</code> <br>  Mengembalikan beberapa informasi dasar tentang layanan mikro (nama, kerangka kerja, tahun rilis kerangka kerja);  ketika menentukan nama salah satu dari empat layanan microser di parameter <code>request-to</code> ke HTTP API-nya, permintaan serupa dijalankan yang mengembalikan informasi dasar; </li><li> <code>GET /application-info/logo</code> <br>  Mengembalikan gambar. </li></ul><br></li><li>  implementasi: <br><ul><li>  pengaturan menggunakan file konfigurasi; </li><li>  Menggunakan injeksi ketergantungan </li><li>  tes yang memverifikasi fungsionalitas API HTTP. </li></ul><br></li><li>  ISA: <br><ul><li>  menggunakan pola Penemuan Layanan (mendaftar dengan Konsul, mengakses API HTTP dari layanan Microsoft lainnya dengan namanya menggunakan penyeimbangan beban klien); </li><li>  formasi artefak uber-jar. </li></ul><br></li></ul><br>  Selanjutnya, kami mempertimbangkan implementasi layanan mikro pada masing-masing kerangka kerja dan membandingkan parameter aplikasi yang diterima. <br><br><h1>  Layanan Helidon </h1><br>  Kerangka pengembangan dibuat di Oracle untuk penggunaan internal, kemudian menjadi open-source.  Ada dua model pengembangan berdasarkan kerangka kerja ini: Edisi Standar (SE) dan MicroProfile (MP).  Dalam kedua kasus, layanan ini akan menjadi program Java SE biasa.  Pelajari lebih lanjut tentang perbedaan pada halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br><br>  Singkatnya, Helidon MP adalah salah satu implementasi Eclipse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MicroProfile</a> , yang memungkinkan untuk menggunakan banyak API, keduanya sebelumnya dikenal oleh pengembang Java EE (misalnya, JAX-RS, CDI), dan yang lebih baru (Pemeriksaan Kesehatan, Metrik, Toleransi Kesalahan) dll.)  Dalam varian Helidon SE, pengembang dipandu oleh prinsip "No magic", yang dinyatakan, khususnya, dalam sedikit atau tidak ada penjelasan yang diperlukan untuk membuat aplikasi. <br><br>  Helidon SE dipilih untuk pengembangan layanan mikro.  Antara lain, tidak memiliki alat untuk mengimplementasikan Dependency Injection, sehingga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Koin</a> digunakan untuk mengimplementasikan dependensi.  Berikut ini adalah kelas yang berisi metode utama.  Untuk mengimplementasikan Injeksi Ketergantungan, kelas mewarisi dari <i>KoinComponent</i> .  Koin dimulai terlebih dahulu, kemudian dependensi yang diperlukan diinisialisasi dan metode <code>startServer()</code> dipanggil, di mana objek dari tipe <i>WebServer</i> dibuat, di mana konfigurasi aplikasi dan pengaturan perutean sebelumnya ditransfer  setelah mulai aplikasi terdaftar di Konsul: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> HelidonServiceApplication : KoinComponent { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startTime = System.currentTimeMillis() startKoin { modules(koinModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> consulClient: Consul <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoProperties: ApplicationInfoProperties <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serviceName = applicationInfoProperties.name startServer(applicationInfoService, consulClient, serviceName, startTime) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( applicationInfoService: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ApplicationInfoService</span></span></span></span><span class="hljs-function"><span class="hljs-params">, consulClient: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Consul</span></span></span></span><span class="hljs-function"><span class="hljs-params">, serviceName: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, startTime: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>: WebServer { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serverConfig = ServerConfiguration.create(Config.create().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"webserver"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> server: WebServer = WebServer .builder(createRouting(applicationInfoService)) .config(serverConfig) .build() server.start().thenAccept { ws -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> durationInMillis = System.currentTimeMillis() - startTime log.info(<span class="hljs-string"><span class="hljs-string">"Startup completed in </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$durationInMillis</span></span></span><span class="hljs-string"> ms. Service running at: http://localhost:"</span></span> + ws.port()) <span class="hljs-comment"><span class="hljs-comment">// register in Consul consulClient.agentClient().register(createConsulRegistration(serviceName, ws.port())) } return server }</span></span></code> </pre> <br>  Routing dikonfigurasi sebagai berikut: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRouting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(applicationInfoService: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ApplicationInfoService</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = Routing.builder() .register(JacksonSupport.create()) .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"/application-info"</span></span>, Handler { req, res -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> requestTo: String? = req.queryParams() .first(<span class="hljs-string"><span class="hljs-string">"request-to"</span></span>) .orElse(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) res .status(Http.ResponseStatus.create(<span class="hljs-number"><span class="hljs-number">200</span></span>)) .send(applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo)) }) .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"/application-info/logo"</span></span>, Handler { req, res -&gt; res.headers().contentType(MediaType.create(<span class="hljs-string"><span class="hljs-string">"image"</span></span>, <span class="hljs-string"><span class="hljs-string">"png"</span></span>)) res .status(Http.ResponseStatus.create(<span class="hljs-number"><span class="hljs-number">200</span></span>)) .send(applicationInfoService.getLogo()) }) .error(Exception::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span></span>{ req, res, ex -&gt; log.error(<span class="hljs-string"><span class="hljs-string">"Exception:"</span></span>, ex) res.status(Http.Status.INTERNAL_SERVER_ERROR_500).send() } .build()</code> </pre> <br>  Aplikasi menggunakan konfigurasi dalam format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>HOCON</u></a> : <br><br><pre> <code class="json hljs">webserver { port: <span class="hljs-number"><span class="hljs-number">8081</span></span> } application-info { name: <span class="hljs-string"><span class="hljs-string">"helidon-service"</span></span> framework { name: <span class="hljs-string"><span class="hljs-string">"Helidon SE"</span></span> release-year: <span class="hljs-number"><span class="hljs-number">2019</span></span> } }</code> </pre> <br>  Dimungkinkan juga untuk menggunakan file dalam format JSON, YAML dan properti untuk konfigurasi (lebih detail di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ). <br><br><h1>  Layanan Ktor </h1><br>  Kerangka ini ditulis dalam Kotlin.  Proyek baru dapat dibuat dengan beberapa cara: menggunakan sistem build, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">start.ktor.io</a> atau plug-in untuk IntelliJ IDEA (selengkapnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ). <br><br>  Seperti Helidon SE, Ktor tidak memiliki DI di luar kotak, jadi dependensi diimplementasikan menggunakan Koin sebelum memulai server: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> koinModule = module { single { ApplicationInfoService(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()) } single { ApplicationInfoProperties() } single { ServiceClient(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()) } single { Consul.builder().withUrl(<span class="hljs-string"><span class="hljs-string">"http://localhost:8500"</span></span>).build() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { startKoin { modules(koinModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> server = embeddedServer(Netty, commandLineEnvironment(args)) server.start(wait = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre> <br>  Modul yang diperlukan oleh aplikasi ditentukan dalam file konfigurasi (dimungkinkan untuk hanya menggunakan format HOCON; lebih lanjut tentang mengkonfigurasi server Ktor di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ), yang isinya disajikan di bawah ini: <br><br><pre> <code class="kotlin hljs">ktor { deployment { host = localhost port = <span class="hljs-number"><span class="hljs-number">8082</span></span> watch = [io.heterogeneousmicroservices.ktorservice] } application { modules = [io.heterogeneousmicroservices.ktorservice.module.KtorServiceApplicationModuleKt.module] } } application-info { name: <span class="hljs-string"><span class="hljs-string">"ktor-service"</span></span> framework { name: <span class="hljs-string"><span class="hljs-string">"Ktor"</span></span> release-year: <span class="hljs-number"><span class="hljs-number">2018</span></span> }</code> </pre> <br>  Ktor dan Koin menggunakan istilah "modul", yang memiliki arti berbeda.  Di Koin, modul adalah analog dari konteks aplikasi dalam Kerangka Kerja Musim Semi.  Modul Ktor adalah fungsi yang ditentukan pengguna yang menerima objek bertipe <i>Aplikasi</i> dan dapat mengkonfigurasi pipa, mengatur fitur, mendaftarkan rute, memproses <br>  permintaan, dll .: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Application.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">module</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isTest()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> consulClient: Consul <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() registerInConsul(applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>).name, consulClient) } install(DefaultHeaders) install(Compression) install(CallLogging) install(ContentNegotiation) { jackson {} } routing { route(<span class="hljs-string"><span class="hljs-string">"application-info"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> requestTo: String? = call.parameters[<span class="hljs-string"><span class="hljs-string">"request-to"</span></span>] call.respond(applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo)) } static { resource(<span class="hljs-string"><span class="hljs-string">"/logo"</span></span>, <span class="hljs-string"><span class="hljs-string">"logo.png"</span></span>) } } } }</code> </pre> <br>  Dalam cuplikan kode ini, perutean permintaan dikonfigurasikan, khususnya, <code>logo.png</code> sumber daya statis. <br><br>  Layanan Ktor dapat berisi fitur.  Fitur adalah fungsi yang tertanam dalam jalur permintaan-respons ( <i>DefaultHeaders, Compression,</i> dan lainnya dalam contoh kode di atas).  Dimungkinkan untuk mengimplementasikan fitur Anda sendiri, misalnya, kode di bawah ini menerapkan pola Penemuan Layanan dalam kombinasi dengan penyeimbangan beban klien berdasarkan pada algoritma Round-robin: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConsulFeature</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> consulClient: Consul) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consulClient: Consul } <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Feature : HttpClientFeature&lt;Config, ConsulFeature&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serviceInstanceIndex: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> key = AttributeKey&lt;ConsulFeature&gt;(<span class="hljs-string"><span class="hljs-string">"ConsulFeature"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Config</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = ConsulFeature(Config().apply(block).consulClient) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">install</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(feature: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ConsulFeature</span></span></span></span><span class="hljs-function"><span class="hljs-params">, scope: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">HttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { scope.requestPipeline.intercept(HttpRequestPipeline.Render) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serviceName = context.url.host <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serviceInstances = feature.consulClient.healthClient().getHealthyServiceInstances(serviceName).response <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectedInstance = serviceInstances[serviceInstanceIndex] context.url.apply { host = selectedInstance.service.address port = selectedInstance.service.port } serviceInstanceIndex = (serviceInstanceIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) % serviceInstances.size } } } }</code> </pre> <br>  Logika utama ada di metode <code>install</code> : selama fase permintaan <i>Render</i> (yang berjalan sebelum fase <i>Kirim</i> ), nama layanan yang dipanggil pertama kali ditentukan, kemudian daftar instance layanan ini diminta dari <code>consulClient</code> , setelah itu instance ditentukan menggunakan algoritma Round-robin.  Dengan demikian, panggilan berikut menjadi mungkin: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getApplicationInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(serviceName: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ApplicationInfo = runBlocking { httpClient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;ApplicationInfo&gt;(<span class="hljs-string"><span class="hljs-string">"http://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$serviceName</span></span></span><span class="hljs-string">/application-info"</span></span>) }</code> </pre> <br><br><h1>  Layanan micronaut </h1><br>  Micronaut dikembangkan oleh pembuat kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grails</a> dan terinspirasi oleh pengalaman membangun layanan menggunakan Spring, Spring Boot, dan Grails.  Kerangka kerja ini adalah polyglot yang mendukung Java, Kotlin dan Groovy;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mungkin</a> akan ada dukungan untuk Scala.  Ketergantungan injeksi dilakukan pada tahap kompilasi, yang mengarah pada konsumsi memori yang lebih sedikit dan startup aplikasi yang lebih cepat dibandingkan dengan Spring Boot. <br><br>  Kelas utama memiliki bentuk berikut: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> MicronautServiceApplication { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { Micronaut.build() .packages(<span class="hljs-string"><span class="hljs-string">"io.heterogeneousmicroservices.micronautservice"</span></span>) .mainClass(MicronautServiceApplication.javaClass) .start() } }</code> </pre> <br>  Beberapa komponen aplikasi berbasis Micronaut mirip dengan rekan-rekan mereka di aplikasi Boot Musim Semi, misalnya, kode pengontrol adalah sebagai berikut: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Controller( value = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/application-info"</span></span></span><span class="hljs-meta">, consumes = [MediaType.APPLICATION_JSON], produces = [MediaType.APPLICATION_JSON] )</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationInfoController</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService ) { <span class="hljs-meta"><span class="hljs-meta">@Get</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(requestTo: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: ApplicationInfo = applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo) <span class="hljs-meta"><span class="hljs-meta">@Get(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/logo"</span></span></span><span class="hljs-meta">, produces = [MediaType.IMAGE_PNG])</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLogo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ByteArray = applicationInfoService.getLogo() }</code> </pre> <br>  Dukungan Kotlin di Micronaut didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin</a> kompiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kapt</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">info</a> lebih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lanjut di</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ).  Script assembly dikonfigurasikan sebagai berikut: <br><br><pre> <code class="kotlin hljs">plugins { ... kotlin(<span class="hljs-string"><span class="hljs-string">"kapt"</span></span>) ... } dependencies { kapt(<span class="hljs-string"><span class="hljs-string">"io.micronaut:micronaut-inject-java"</span></span>) ... kaptTest(<span class="hljs-string"><span class="hljs-string">"io.micronaut:micronaut-inject-java"</span></span>) ... }</code> </pre> <br>  Berikut ini adalah isi dari file konfigurasi: <br><br><pre> <code class="json hljs">micronaut: application: name: micronaut-service server: port: <span class="hljs-number"><span class="hljs-number">8083</span></span> consul: client: registration: enabled: <span class="hljs-literal"><span class="hljs-literal">true</span></span> application-info: name: ${micronaut.application.name} framework: name: Micronaut release-year: <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre> <br>  Konfigurasi microservice juga dimungkinkan dengan JSON, properti, dan format file Groovy (lebih detail di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ). <br><br><h1>  Layanan booting musim semi </h1><br>  Kerangka kerja ini dibuat untuk menyederhanakan pengembangan aplikasi menggunakan ekosistem Spring Framework.  Ini dicapai melalui mekanisme konfigurasi otomatis saat menghubungkan perpustakaan.  Berikut ini adalah kode pengontrol: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping(path = [</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"application-info"</span></span></span><span class="hljs-meta">], produces = [MediaType.APPLICATION_JSON_UTF8_VALUE])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationInfoController</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService ) { <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestParam(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"request-to"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> requestTo: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: ApplicationInfo = applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo) <span class="hljs-meta"><span class="hljs-meta">@GetMapping(path = [</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/logo"</span></span></span><span class="hljs-meta">], produces = [MediaType.IMAGE_PNG_VALUE])</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLogo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ByteArray = applicationInfoService.getLogo() }</code> </pre> <br>  Layanan microsoft dikonfigurasikan dengan file YAML: <br><br><pre> <code class="json hljs">spring: application: name: spring-boot-service server: port: <span class="hljs-number"><span class="hljs-number">8084</span></span> application-info: name: ${spring.application.name} framework: name: Spring Boot release-year: <span class="hljs-number"><span class="hljs-number">2014</span></span></code> </pre> <br>  Dimungkinkan juga untuk menggunakan file format properti untuk konfigurasi (lebih detail di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ). <br><br><h1>  Luncurkan </h1><br>  Proyek ini bekerja pada JDK 12, meskipun kemungkinan pada versi 11 juga, Anda hanya perlu mengubah parameter <code>jvmTarget</code> dalam skrip perakitan <code>jvmTarget</code> : <br><br><pre> <code class="kotlin hljs">withType&lt;KotlinCompile&gt; { kotlinOptions { jvmTarget = <span class="hljs-string"><span class="hljs-string">"12"</span></span> ... } }</code> </pre> <br>  Sebelum memulai layanan microser, Anda harus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menginstal</a> Konsul dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mulai</a> agen - misalnya, seperti ini: <code>consul agent -dev</code> . <br><br>  Memulai layanan microsoft dimungkinkan dari: <br><br><ul><li>  IDE <br>  Pengguna IntelliJ IDEA dapat melihat sesuatu seperti berikut: <br><img src="https://habrastorage.org/webt/n3/u_/hy/n3u_hy7_z5ut65ryaetvsw2znci.png"><br></li><li>  konsol <br>  Untuk melakukan ini, buka folder proyek dan jalankan secara berurutan: <br><br><pre> <code class="plaintext hljs">java -jar helidon-service/build/libs/helidon-service-all.jar java -jar ktor-service/build/libs/ktor-service-all.jar java -jar micronaut-service/build/libs/micronaut-service-all.jar java -jar spring-boot-service/build/libs/spring-boot-service.jar</code> </pre> <br></li></ul><br>  Setelah memulai semua layanan microser di <code>http://localhost:8500/ui/dc1/services</code> Anda akan melihat: <br><br><img src="https://habrastorage.org/webt/qi/lm/bv/qilmbv1op4a6xgy6b31tnsfjpmm.png"><br><br><h1>  Pengujian API </h1><br>  Hasil pengujian API layanan Helidon diberikan sebagai contoh: <br><br><ol><li> <code>GET http://localhost:8081/application-info</code> <br> <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"helidon-service"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"framework"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Helidon SE"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"releaseYear"</span></span>: <span class="hljs-number"><span class="hljs-number">2019</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"requestedService"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> </li><li> <code>GET http://localhost:8081/application-info?request-to=ktor-service</code> <br> <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"helidon-service"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"framework"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Helidon SE"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"releaseYear"</span></span>: <span class="hljs-number"><span class="hljs-number">2019</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"requestedService"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"ktor-service"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"framework"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ktor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"releaseYear"</span></span>: <span class="hljs-number"><span class="hljs-number">2018</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"requestedService"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> } }</code> </pre> </li><li> <code>GET http://localhost:8081/application-info/logo</code> <br> <br>  Mengembalikan gambar. </li></ol><br>  Anda dapat menguji API microservice sewenang-wenang menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Postman</a> ( <a href="">kumpulan</a> permintaan), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.jetbrains.com/help/idea/">klien HTTP</a> IntelliJ IDEA ( <a href="https://github.com/rkudryashov/heterogeneous-microservices/blob/master/_misc/api_testing/idea_http_client/http-request.">kumpulan</a> permintaan), browser, atau alat lain.  Jika Anda menggunakan dua klien pertama, Anda perlu menentukan port dari microservice yang disebut di variabel yang sesuai (di Postman itu ada di <i>menu koleksi -&gt; Edit -&gt; Variabel</i> , dan di HTTP Client itu berada di variabel lingkungan yang ditentukan dalam file <a href="https://github.com/rkudryashov/heterogeneous-microservices/blob/master/_misc/api_testing/idea_http_client/">ini</a> ), dan ketika menguji metode 2) API juga perlu menentukan nama layanan mikro "di bawah tenda" yang diminta.  Jawabannya akan serupa dengan yang diberikan di atas. <br><br><h1>  Perbandingan Pengaturan Aplikasi </h1><br><br><h3>  Ukuran artefak </h3><br>  Untuk menjaga kesederhanaan konfigurasi dan menjalankan aplikasi dalam skrip assembly, tidak ada dependensi transitif yang dikecualikan, sehingga ukuran layanan uber-JAR pada Spring Boot secara signifikan melebihi ukuran analog pada kerangka kerja lain (karena ketika menggunakan permulaan, tidak hanya dependensi yang diperlukan yang diimpor; jika diinginkan, ukuran dapat dikurangi secara signifikan): <br><div class="scrollable-table"><table><tbody><tr><th>  Layanan microser </th><th>  Ukuran Artefak, MB </th></tr><tr><td>  Layanan Helidon </td><td align="right">  16.6 </td></tr><tr><td>  Layanan Ktor </td><td align="right">  20.9 </td></tr><tr><td>  Layanan micronaut </td><td align="right">  16.5 </td></tr><tr><td>  Layanan booting musim semi </td><td align="right">  42.7 </td></tr></tbody></table></div><br><br><h3>  Waktu peluncuran </h3><br>  Waktu peluncuran setiap aplikasi tidak konsisten dan jatuh ke dalam beberapa "jendela";  tabel di bawah ini menunjukkan waktu peluncuran artefak tanpa menentukan parameter tambahan: <br><div class="scrollable-table"><table><tbody><tr><th>  Layanan microser </th><th>  Mulai waktu, detik </th></tr><tr><td>  Layanan Helidon </td><td align="right">  2.2 </td></tr><tr><td>  Layanan Ktor </td><td align="right">  1.4 </td></tr><tr><td>  Layanan micronaut </td><td align="right">  4.0 </td></tr><tr><td>  Layanan booting musim semi </td><td align="right">  10.2 </td></tr></tbody></table></div><br>  Perlu dicatat bahwa jika Anda "membersihkan" aplikasi Spring Boot dari dependensi yang tidak perlu dan memperhatikan untuk mengkonfigurasi aplikasi untuk memulai (misalnya, hanya memindai paket yang diperlukan dan menggunakan inisialisasi bin malas), Anda dapat secara signifikan mengurangi waktu startup. <br><br><h3>  Uji beban </h3><br>  Untuk pengujian, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gatling</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip</a> Scala digunakan.  Generator beban dan layanan yang diuji dijalankan pada mesin yang sama (Windows 10, prosesor quad-core 3,2 GHz, 24 GB RAM, SSD).  Port layanan ini ditunjukkan dalam skrip Scala. <br><br>  Untuk setiap layanan mikro ditentukan: <br><br><ul><li>  jumlah minimum heap-memory ( <code>-Xmx</code> ) yang diperlukan untuk menjalankan layanan microser (menanggapi permintaan) yang berfungsi </li><li>  memori tumpukan minimum yang diperlukan untuk lulus uji beban 50 pengguna * 1000 permintaan </li><li>  memori tumpukan minimum yang diperlukan untuk lulus uji beban 500 pengguna * 1000 permintaan </li></ul><br>  Lulus tes beban berarti bahwa layanan mikro merespons semua permintaan kapan saja. <br><div class="scrollable-table"><table><tbody><tr><th rowspan="2">  Layanan microser </th><th colspan="3">  Jumlah minimum memori tumpukan, MB </th></tr><tr><th>  Untuk memulai layanan </th><th>  Untuk memuat 50 * 1000 </th><th>  Untuk memuat 500 * 1000 </th></tr><tr><td>  Layanan Helidon </td><td align="right">  9 </td><td align="right">  9 </td><td align="right">  11 </td></tr><tr><td>  Layanan Ktor </td><td align="right">  11 </td><td align="right">  11 </td><td align="right">  13 </td></tr><tr><td>  Layanan micronaut </td><td align="right">  13 </td><td align="right">  13 </td><td align="right">  17 </td></tr><tr><td>  Layanan booting musim semi </td><td align="right">  22 </td><td align="right">  23 </td><td align="right">  25 </td></tr></tbody></table></div><br>  Perlu dicatat bahwa semua layanan microser menggunakan server HTTP Netty. <br><br><h1>  Kesimpulan </h1><br>  Tugas - pembuatan layanan sederhana dengan HTTP API dan kemampuan untuk berfungsi di ISA - dapat diselesaikan pada semua kerangka kerja yang dimaksud.  Sudah waktunya untuk mengambil stok dan mempertimbangkan pro dan kontra mereka. <br><br>  <i><b>Helidon</b></i> <br><br>  <font color="#808080">Edisi standar</font> <br><ul><li>  plus <br><ul><li>  pengaturan aplikasi <br>  Dalam semua hal menunjukkan hasil yang baik; </li><li>  "Tidak ada sihir" <br>  Kerangka kerja membenarkan prinsip yang dinyatakan oleh pengembang: hanya butuh satu anotasi untuk membuat aplikasi ( <code>@JvmStatic</code> - untuk interope Java-Kotlin). </li></ul></li><li>  kontra <br><ul><li>  pekerjaan mikro <br>  Beberapa komponen yang diperlukan untuk pengembangan industri tidak tersedia, misalnya, injeksi ketergantungan dan implementasi Service Discovery. </li></ul></li></ul><br>  <font color="#808080">Mikroprofil</font> <br>  Microservice tidak diterapkan pada kerangka kerja ini, jadi saya hanya akan mencatat beberapa poin yang saya tahu: <br><br><ul><li>  plus <br><ul><li>  Implementasi Eclipse MicroProfile <br>  Intinya, MicroProfile adalah Java EE yang dioptimalkan untuk ISA.  Jadi, pertama, Anda mendapatkan akses ke seluruh variasi Java EE API, termasuk yang dirancang khusus untuk ISA, dan kedua, Anda dapat mengubah implementasi MicroProfile ke yang lain (Open Liberty, WildFly Swarm, dll.) . </li></ul></li><li>  selain itu <br><ul><li>  pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MicroProfile Starter</a> Anda dapat membuat proyek dari awal dengan parameter yang diperlukan dengan analogi dengan alat serupa untuk kerangka kerja lainnya (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring Initializr</a> ).  Pada saat publikasi artikel, Helidon mengimplementasikan MicroProfile 1.2, sedangkan versi spesifikasi terbaru adalah 3.0. </li></ul></li></ul><br><br>  <i><b>Ktor</b></i> <br><br><ul><li>  plus <br><ul><li>  ringan <br>  Memungkinkan Anda untuk menghubungkan hanya fungsi-fungsi yang secara langsung diperlukan untuk menyelesaikan tugas; </li><li>  pengaturan aplikasi <br>  Hasil bagus dalam segala hal. </li></ul></li><li>  kontra <br><ul><li>  ‚ÄúDiasah‚Äù di bawah Kotlin, yaitu mungkin, tetapi tidak perlu, untuk dikembangkan di Jawa; </li><li>  microframework (lihat item serupa untuk Helidon SE). </li></ul></li><li>  selain itu <br>  Di satu sisi, konsep pengembangan kerangka kerja tidak termasuk dalam dua model pengembangan Java yang paling populer (Spring-like (Spring Boot / Micronaut) dan Java EE / MicroProfile), yang dapat mengarah pada: <br><br><ul><li>  masalah dengan menemukan spesialis; </li><li>  waktu yang lebih lama untuk menyelesaikan tugas dibandingkan dengan Boot Musim Semi karena kebutuhan untuk secara eksplisit mengkonfigurasi fungsionalitas yang diperlukan. </li></ul><br>  Di sisi lain, ketidaksamaan dengan Musim Semi ‚Äúklasik‚Äù dan Java EE memungkinkan Anda untuk melihat proses pengembangan dari sudut yang berbeda, mungkin lebih sadar. </li></ul><br><br>  <i><b>Micronaut</b></i> <br><br><ul><li>  plus <br><ul><li>  Aot <br>  Seperti yang disebutkan sebelumnya, AOT memungkinkan Anda untuk mengurangi waktu mulai dan memori yang dikonsumsi oleh aplikasi dibandingkan dengan rekannya pada Spring Boot; </li><li>  Model pengembangan semi-suka <br>  Programmer dengan pengalaman berkembang di Spring tidak akan membutuhkan banyak waktu untuk menguasai kerangka ini; </li><li>  pengaturan aplikasi <br>  Hasil yang baik dalam semua hal; </li><li>  polyglot <br>  Dukungan warga negara kelas satu untuk Jawa, Kotlin, Groovy;  mungkin akan ada dukungan untuk Scala.  Menurut pendapat saya, ini dapat secara positif mempengaruhi pertumbuhan masyarakat.  Ngomong-ngomong, pada Juni 2019 Groovy di peringkat popularitas bahasa pemrograman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TIOBE</a> mengambil tempat ke-14, lepas landas dari tahun ke-60 sebelumnya, dengan demikian berada di posisi kedua terhormat di antara bahasa JVM; </li><li>  Proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Micronaut untuk Spring juga</a> memungkinkan Anda untuk mengubah runtime dari aplikasi Boot Spring yang ada ke Micronaut (dengan batasan). </li></ul></li></ul><br><br>  <i><b>Boot musim semi</b></i> <br><br><ul><li>  plus <br><ul><li>  kematangan platform dan ekosistem <br>  Kerangka kerja "setiap hari".  Untuk sebagian besar tugas sehari-hari, sudah ada solusi dalam paradigma pemrograman Spring, yaitu, dengan cara yang akrab bagi banyak programmer.  Pengembangan disederhanakan oleh konsep permulaan dan konfigurasi otomatis; </li><li>  kehadiran sejumlah besar spesialis di pasar tenaga kerja, serta basis pengetahuan yang signifikan (termasuk dokumentasi dan jawaban untuk Stack Overflow); </li><li>  perspektif <br>  Saya pikir banyak orang akan setuju bahwa dalam waktu dekat, Spring akan tetap menjadi kerangka pengembangan terkemuka. </li></ul></li><li>  kontra <br><ul><li>  pengaturan aplikasi <br>  Aplikasi pada kerangka kerja ini bukan di antara para pemimpin, namun beberapa parameter, seperti disebutkan sebelumnya, dapat dioptimalkan secara mandiri.  Perlu juga mengingat kembali keberadaan proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring Fu</a> , yang sedang dalam pengembangan aktif, yang penggunaannya memungkinkan untuk mengurangi parameter-parameter ini. </li></ul></li></ul><br>  Anda juga dapat menyoroti masalah umum yang terkait dengan kerangka kerja baru yang hilang dari Spring Boot: <br><br><ul><li>  ekosistem yang kurang berkembang; </li><li>  sejumlah kecil spesialis dengan pengalaman dengan teknologi ini; </li><li>  waktu yang lebih lama untuk menyelesaikan tugas; </li><li>  prospek yang tidak jelas. </li></ul><br>  Kerangka kerja yang dipertimbangkan termasuk dalam kategori bobot yang berbeda: Helidon SE dan Ktor adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mikroframe</a> , Spring Boot adalah kerangka kerja tumpukan penuh, Micronaut lebih mungkin juga tumpukan penuh;  kategori lain adalah MicroProfile (mis. Helidon MP).  Dalam mikroframe, fungsionalitas terbatas, yang dapat memperlambat pelaksanaan tugas;  Untuk mengklarifikasi kemungkinan penerapan fungsi ini atau itu berdasarkan kerangka pengembangan apa pun, saya sarankan Anda membiasakan diri dengan dokumentasinya. <br><br>  Saya tidak berani menilai apakah kerangka kerja ini atau itu akan "menembak" dalam waktu dekat, oleh karena itu, menurut pendapat saya, lebih baik untuk terus memantau perkembangan acara menggunakan kerangka kerja pengembangan yang ada untuk menyelesaikan tugas kerja. <br><br>  Pada saat yang sama, seperti yang ditunjukkan dalam artikel, kerangka kerja baru mengungguli Spring Boot oleh parameter yang dipertimbangkan dari aplikasi yang diterima.  Jika salah satu dari parameter ini sangat penting untuk salah satu layanan microser Anda, maka Anda mungkin perlu memperhatikan kerangka kerja yang menunjukkan hasil terbaik pada mereka.  Namun, jangan lupa bahwa Boot Musim Semi, pertama, terus membaik, dan kedua, ia memiliki ekosistem yang sangat besar dan sejumlah besar programmer Java yang akrab dengannya.  Ada kerangka kerja lain yang tidak tercakup dalam artikel ini: Javalin, Quarkus, dll. <br><br>  Anda dapat melihat kode proyek di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Terima kasih atas perhatian anda! <br><br>  PS: Terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">artglorin</a> untuk membantu dengan artikel ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456376/">https://habr.com/ru/post/id456376/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456362/index.html">Perancang Tingkat 6: bagaimana kita memotivasi dan mengembangkan perancang</a></li>
<li><a href="../id456366/index.html">Bagaimana Saya Merancang Kotak HATI LED</a></li>
<li><a href="../id456368/index.html">Melakukan transaksi publik dan pribadi di JPMorgan Quorum blockchain menggunakan Web3</a></li>
<li><a href="../id456370/index.html">Menerapkan QoS di Qsan Storage</a></li>
<li><a href="../id456372/index.html">SimbirSoft mengundang para profesional TI ke Intensive Summer 2019</a></li>
<li><a href="../id456380/index.html">Open Day dari Fakultas Pemrograman Netologi</a></li>
<li><a href="../id456382/index.html">Kolaborasi dan otomatisasi di frontend. Apa yang kami pelajari dari 13 sekolah</a></li>
<li><a href="../id456384/index.html">Grafik PVS-Studio dari Pengembangan Kemampuan Diagnostik</a></li>
<li><a href="../id456386/index.html">Buka perpustakaan untuk visualisasi konten audio</a></li>
<li><a href="../id456388/index.html">Bagan pengembangan diagnostik dalam PVS-Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>