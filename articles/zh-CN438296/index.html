<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦋 👩🏻‍🤝‍👨🏾 ➿ OpenSceneGraph：插件系统 💔 🤘🏿 👳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 
 在先前的课程中，曾经有人说过OSG支持通过其自身的插件系统加载各种资源，例如光栅图像，各种格式的3D模型或字体。 OSG插件是一个单独的组件，可扩展引擎的功能，并在OSG中具有标准化的接口。 该插件实现为动态共享库（Windows上为dll，在Linux等上为dll）。 插件库的名称与特定...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph：插件系统</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438296/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="图片"><br><h1> 引言 </h1><br> 在先前的课程中，曾经有人说过OSG支持通过其自身的插件系统加载各种资源，例如光栅图像，各种格式的3D模型或字体。  OSG插件是一个单独的组件，可扩展引擎的功能，并在OSG中具有标准化的接口。 该插件实现为动态共享库（Windows上为dll，在Linux等上为dll）。 插件库的名称与特定约定相对应 <br><br><pre><code class="plaintext hljs">osgdb_&lt; &gt;.dll</code> </pre> <br> 也就是说，插件名称始终包含osgdb_前缀。 文件扩展名告诉引擎应使用哪个插件来下载具有该扩展名的文件。 例如，当我们用代码编写函数时 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span>);</code> </pre><br> 引擎会看到osg扩展名并加载名为osgdb_osg.dll的插件（如果是Linux，则为osgdb_osg.so）。 插件代码通过返回指向描述cessna模型的节点的指针来完成所有肮脏的工作。 同样，尝试加载PNG图片 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg:Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.png"</span></span>);</code> </pre><br> 将导致osgdb_png.dll插件加载，该插件实现了一种算法，该算法可从PNG图像读取数据并将此数据放置在osg :: Image类型的对象中。 <br><a name="habracut"></a><br> 使用外部资源进行的所有操作均由osgDB库的功能实现，通过该功能，我们始终将示例与示例之间的程序链接在一起。 该库依赖于OSG插件系统。 迄今为止，OSG软件包包括许多可与大多数图像格式，3D模型和实践中使用的字体一起使用的插件。 插件既可以读取特定格式的数据（导入），又可以在大多数情况下将数据写入所需格式的文件（导出）。 尤其是osgconv实用程序，使您可以将数据从一种格式转换为另一种格式，例如插件系统。 <br><br><pre> <code class="plaintext hljs">$ osgconv cessna.osg cessna.3ds</code> </pre><br> 它可以轻松自然地将cessna osg模型转换为3DS格式，然后可以将其导入3D编辑器，例如，导入Blender（顺便说一句，它有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">扩展功能，可直接</a>为Blender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用osg</a> ） <br><br><img src="https://habrastorage.org/webt/vy/dm/qm/vydmqm2a3evtdqxu2vtf_kknmrw.png"><br><br> 这里有一份标准的OSG插件的正式列表，其中描述了它们的用途，但是它很长，我懒得把它带到这里。 在bin / ospPlugins-xyz文件夹中查看该库的安装路径更加容易，其中x，y，z是OSG版本号。 从插件文件的名称可以很容易地了解其处理的格式。 <br><br> 如果OSG由MinGW编译器编译，则将附加前缀mingw_添加到插件的标准名称，即该名称将如下所示 <br><br><pre> <code class="plaintext hljs">mingw_osgdb_&lt; &gt;.dll</code> </pre><br> 在DEBUG配置中编译的插件版本在名称末尾附加了后缀d，即格式为 <br><br><pre> <code class="plaintext hljs">osgdb_&lt; &gt;d.dll</code> </pre><br> 或 <br><br><pre> <code class="plaintext hljs">mingw_osgdb_&lt; &gt;d.dll</code> </pre><br> 组装MinGW时。 <br><br><h1>  1.插件伪加载器 </h1><br> 一些OSG插件执行所谓的伪加载器的功能-这意味着它们不与特定的文件扩展名绑定，但是通过在文件名的末尾添加后缀，您可以指定应使用哪个插件来下载此文件。 <br><br><pre> <code class="plaintext hljs">$ osgviewer worldmap.shp.ogr</code> </pre><br> 在这种情况下，磁盘上文件的真实名称是worldmap.shp-此文件以ESRI shapefile格式存储世界地图。 后缀.ogr告诉osgDB库使用osgdb_ogr插件来加载该文件。 否则，将使用osgdb_shp插件。 <br><br> 另一个很好的例子是osgdb_ffmpeg插件。  FFmpeg库支持100多种不同的编解码器。 要读取其中的任何一个，我们只需在媒体文件名称后添加后缀.ffmpeg。 <br><br> 除此之外，一些伪加载器还允许我们在后缀中传递许多影响加载对象状态的参数，我们在动画示例中已经遇到了这一点。 <br><br><pre> <code class="cpp hljs">node = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg.0,0,90.rot"</span></span>);</code> </pre><br>  0.90行向osgdb_osg插件指示了加载模型的初始方向的参数。 一些伪加载器需要完全特定的参数才能工作。 <br><br><h1>  2.用于开发第三方插件的API </h1><br> 在阅读完所有内容后，如果您有想法为OSG编写自己的插件可能并不困难，这将使您能够导入非标准格式的3D模型或图像，这是完全合乎逻辑的。 这是一个真实的想法！ 插件机制仅用于扩展引擎的功能，而无需更改OSG本身。 为了理解编写插件的基本原理，让我们尝试实现一个简单的示例。 <br><br> 该插件的开发是为了扩展OSG提供的虚拟读取/写入接口。 此功能由osgDB :: ReaderWriter虚拟类提供。 此类提供了许多由插件开发人员重新定义的虚拟方法。 <br><table><thead><tr><th> 方法 </th><th> 内容描述 </th></tr></thead><tbody><tr><td>  supportExtensions（） </td><td> 它接受两个字符串参数：文件扩展名和描述。 该方法总是在子类的构造函数中调用。 </td></tr><tr><td>  acceptsExtension（） </td><td> 如果插件支持作为参数传递的扩展名，则返回true </td></tr><tr><td>  fileExists（） </td><td> 允许您确定磁盘上是否存在给定文件（路径作为参数传递）（如果成功，则返回true） </td></tr><tr><td>  readNode（） </td><td> 接受文件名和选项作为osgDB :: Option对象。 从文件读取数据的功能由开发人员实现 </td></tr><tr><td>  writeNode（） </td><td> 接受节点名称，所需的文件名和选项。 将数据写入磁盘的功能由开发人员实现 </td></tr><tr><td>  readImage（） </td><td> 读取磁盘位图数据 </td></tr><tr><td>  writeImage（） </td><td> 将位图写入磁盘 </td></tr></tbody></table><br>  readNode（）方法的实现可以通过以下代码描述 <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         bool recognizableExtension = ...; bool fileExists = ...; if (!recognizableExtension) return ReadResult::FILE_NOT_HANDLED; if (!fileExists) return ReadResult::FILE_NOT_FOUND; //          osg::Node *root = ...; //       -     . //    -      bool errorInParsing = ...; if (errorInParsing) return ReadResult::ERROR_IN_READING_FILE; return root; }</span></span></code> </pre><br> 令人惊讶的是，该方法返回的类型不是osgDB :: ReaderWriter :: ReadResult，而是指向场景图节点的指针。 此类型是读取结果对象，可以用作节点容器，图像，状态枚举器（例如FILE_NOT_FOUND），另一个特殊对象，甚至可以用作错误消息字符串。 它具有许多用于实现所描述功能的隐式构造函数。 <br><br> 另一个有用的类是osgDB :: Options。 它可以允许您使用setOptionString（）和getOptionString（）方法设置或获取加载选项的字符串。 也可以将此字符串作为参数传递给此类的构造方法。 <br><br> 开发人员可以通过设置加载对象时传递的参数字符串中的设置来控制插件的行为，例如，通过这种方式 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    osg::Node* node1 = osgDB::readNodeFile("cow.osg"); //     string osg::Node* node2 = osgDB::readNodeFile("cow.osg", new osgDB::Options(string));</span></span></code> </pre><br><h1>  3. OSG插件中的数据流处理 </h1><br> 基类osgDB :: ReaderWriter包括一组处理标准C ++库提供的输入/输出流的数据的方法。 这些读/写方法与上面讨论的方法之间的唯一区别是，它们接受文件std :: istream和输入流或std :: ostream和输出流而不是文件名。 使用文件I / O流总是比使用文件名更好。 要执行文件读取操作，我们可以使用以下界面设计： <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... osgDB::<span class="hljs-function"><span class="hljs-function">ifstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file.c_str(), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ios::binary)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stream) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReadResult::ERROR_IN_READING_FILE; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readNode(stream, options); } ... osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         osg::Node *root = ...; return root; }</span></span></code> </pre><br> 实现插件后，我们只需指定文件路径，即可使用标准函数osgDB :: readNodeFile（）和osgDB :: readImageFile（）加载模型和图像。  OSG将找到并下载我们编写的插件。 <br><br><h1>  4.我们编写自己的插件 </h1><br><br> 因此，没有人会打扰我们想出我们自己的格式来将数据存储在三维几何中，而我们会想出它 <br><br>  <strong>吡酰胺</strong> <br><br><pre> <code class="plaintext hljs">vertex: 1.0 1.0 0.0 vertex: 1.0 -1.0 0.0 vertex: -1.0 -1.0 0.0 vertex: -1.0 1.0 0.0 vertex: 0.0 0.0 2.0 face: 0 1 2 3 face: 0 3 4 face: 1 0 4 face: 2 1 4 face: 3 2 4</code> </pre><br> 在文件的开头，是带有其坐标的顶点列表。 顶点索引从零开始顺序排列。 顶点列表之后是​​面列表。 每个面由形成顶点的一系列顶点索引定义。 显然没有什么复杂的。 任务是从磁盘读取此文件并在其基础上形成三维几何。 <br><br><h1>  5.插件项目设置：构建脚本功能 </h1><br> 如果在构建应用程序之前，现在必须编写一个动态库，而不仅仅是编写一个库，而是编写一个满足某些要求的OSG插件。 我们将通过如下所示的项目构建脚本开始满足这些要求 <br><br>  <strong>plugin.pro</strong> <br><br><pre> <code class="cmake hljs">TEMPLATE = lib CONFIG += plugin CONFIG += no_plugin_name_prefix <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = osgdb_pmd win32-g++: <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,mingw_,) win32 { OSG_LIB_DIRECTORY = $$(OSG_BIN_PATH) OSG_INCLUDE_DIRECTORY = $$(OSG_INCLUDE_PATH) DESTDIR = $$(OSG_PLUGINS_PATH) CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,d) LIBS += -L$$OSG_LIB_DIRECTORY -losgd LIBS += -L$$OSG_LIB_DIRECTORY -losgViewerd LIBS += -L$$OSG_LIB_DIRECTORY -losgDBd LIBS += -L$$OSG_LIB_DIRECTORY -lOpenThreadsd LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LIBS += -L$$OSG_LIB_DIRECTORY -losg LIBS += -L$$OSG_LIB_DIRECTORY -losgViewer LIBS += -L$$OSG_LIB_DIRECTORY -losgDB LIBS += -L$$OSG_LIB_DIRECTORY -lOpenThreads LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil } INCLUDEPATH += $$OSG_INCLUDE_DIRECTORY } unix { DESTDIR = /usr/lib/osgPlugins-<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,d) LIBS += -losgd LIBS += -losgViewerd LIBS += -losgDBd LIBS += -lOpenThreadsd LIBS += -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LIBS += -losg LIBS += -losgViewer LIBS += -losgDB LIBS += -lOpenThreads LIBS += -losgUtil } } INCLUDEPATH += ./<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> HEADERS += $$files(./<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>/*.h) SOURCES += $$files(./src/*.cpp)</code> </pre><br> 我们将更详细地分析各个细微差别 <br><br><pre> <code class="cmake hljs">TEMPLATE = lib</code> </pre><br> 意味着我们将建立图书馆。 为了防止在* nix系统中解决了库版本冲突的问题的情况下生成符号链接，我们向构建系统指示该库将是一个插件，即它将“动态”加载到内存中。 <br><br><pre> <code class="cmake hljs">CONFIG += plugin</code> </pre><br> 接下来，我们排除lib前缀的生成，该lib前缀在使用gcc系列编译器时添加，并且在加载库时在运行时环境中考虑 <br><br><pre> <code class="cmake hljs">CONFIG += no_plugin_name_prefix</code> </pre><br> 设置库文件的名称 <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = osgdb_pmd</code> </pre><br> 其中，pmd是我们发明的3D模型格式的文件扩展名。 此外，我们必须指出，在MinGW组装的情况下，必须在名称中添加前缀mingw_ <br><br><pre> <code class="cmake hljs">win32-g++: <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,mingw_,)</code> </pre><br> 指定库构建路径：对于Windows <br><br><pre> <code class="cmake hljs">DESTDIR = $$(OSG_PLUGINS_PATH)</code> </pre><br> 对于Linux <br><br><pre> <code class="cmake hljs">DESTDIR = /usr/lib/osgPlugins-<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br> 对于Linux，使用这样的路径指示（无疑是拐杖，但我还没有找到其他解决方案），我们授予普通用户使用OSG插件写入指定文件夹的权利。 <br><br><pre> <code class="plaintext hljs"># chmod 666 /usr/lib/osgPlugins-3.7.0</code> </pre><br> 所有其他构建设置与之前的示例应用程序组装中使用的设置类似。 <br><br><h1>  6.插件项目设置：调试模式功能 </h1><br> 由于该项目是一个动态库，因此必须有一个程序在其执行过程中加载该库。 它可以是使用OSG的任何应用程序，在该应用程序中将调用该函数 <br><br><pre> <code class="cpp hljs">node = osdDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"piramide.pmd"</span></span>);</code> </pre><br> 在这种情况下，我们的插件将加载。 为了不自己编写此类程序，我们将使用现成的解决方案-标准osgviewer查看器，该解决方案包含在引擎的交付包装中。 如果在控制台中执行 <br><br><pre> <code class="plaintext hljs">$ osgviewer piramide.pmd</code> </pre><br> 然后它将触发插件。 在项目启动设置中，将osgviewerd的路径指定为工作目录，指定piramide.pmd文件所在的目录，并在osgviewer命令行选项中指定相同的文件 <br><br><img src="https://habrastorage.org/webt/v8/9y/xa/v89yxafvygysowtw7aeihf9mgcs.png"><br><br> 现在，我们可以运行插件并直接从QtCreator IDE对其进行调试。 <br><br><h1>  6.我们实现插件框架 </h1><br> 这个示例在某种程度上概括了我们从先前的课程中已经获得的有关OSG的知识。 编写插件时，我们必须 <br><br><ol><li> 选择数据结构以存储从模型文件读取的模型几何信息 <br></li><li> 读取并解析（解析）模型数据文件 <br></li><li> 根据从文件中读取的数据正确配置osg :: Drawable几何对象 <br></li><li> 为加载的模型构建场景子图 <br></li></ol><br> 因此，按照传统，我将提供插件的完整源代码 <br><br><div class="spoiler">  <b class="spoiler_title">osgdb_pmd插件</b> <div class="spoiler_text">  <strong>主文件</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgDB/FileNameUtils&gt; #include &lt;osgDB/FileUtils&gt; #include &lt;osgDB/Registry&gt; #include &lt;osgUtil/SmoothingVisitor&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct face_t { std::vector&lt;unsigned int&gt; indices; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct pmd_mesh_t { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices; osg::ref_ptr&lt;osg::Vec3Array&gt; normals; std::vector&lt;face_t&gt; faces; pmd_mesh_t() : vertices(new osg::Vec3Array) , normals(new osg::Vec3Array) { } osg::Vec3 calcFaceNormal(const face_t &amp;face) const { osg::Vec3 v0 = (*vertices)[face.indices[0]]; osg::Vec3 v1 = (*vertices)[face.indices[1]]; osg::Vec3 v2 = (*vertices)[face.indices[2]]; osg::Vec3 n = (v1 - v0) ^ (v2 - v0); return n * (1 / n.length()); } }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class ReaderWriterPMD : public osgDB::ReaderWriter { public: ReaderWriterPMD(); virtual ReadResult readNode(const std::string &amp;filename, const osgDB::Options *options) const; virtual ReadResult readNode(std::istream &amp;stream, const osgDB::Options *options) const; private: pmd_mesh_t parsePMD(std::istream &amp;stream) const; std::vector&lt;std::string&gt; parseLine(const std::string &amp;line) const; }; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ ReaderWriterPMD::ReaderWriterPMD() { supportsExtension("pmd", "PMD model file"); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( const std::string &amp;filename, const osgDB::Options *options) const { std::string ext = osgDB::getLowerCaseFileExtension(filename); if (!acceptsExtension(ext)) return ReadResult::FILE_NOT_HANDLED; std::string fileName = osgDB::findDataFile(filename, options); if (fileName.empty()) return ReadResult::FILE_NOT_FOUND; std::ifstream stream(fileName.c_str(), std::ios::in); if (!stream) return ReadResult::ERROR_IN_READING_FILE; return readNode(stream, options); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( std::istream &amp;stream, const osgDB::Options *options) const { (void) options; pmd_mesh_t mesh = parsePMD(stream); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(mesh.vertices.get()); for (size_t i = 0; i &lt; mesh.faces.size(); ++i) { osg::ref_ptr&lt;osg::DrawElementsUInt&gt; polygon = new osg::DrawElementsUInt(osg::PrimitiveSet::POLYGON, 0); for (size_t j = 0; j &lt; mesh.faces[i].indices.size(); ++j) polygon-&gt;push_back(mesh.faces[i].indices[j]); geom-&gt;addPrimitiveSet(polygon.get()); } geom-&gt;setNormalArray(mesh.normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(geom.get()); return geode.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ pmd_mesh_t ReaderWriterPMD::parsePMD(std::istream &amp;stream) const { pmd_mesh_t mesh; while (!stream.eof()) { std::string line; std::getline(stream, line); std::vector&lt;std::string&gt; tokens = parseLine(line); if (tokens[0] == "vertex") { osg::Vec3 point; std::istringstream iss(tokens[1]); iss &gt;&gt; point.x() &gt;&gt; point.y() &gt;&gt; point.z(); mesh.vertices-&gt;push_back(point); } if (tokens[0] == "face") { unsigned int idx = 0; std::istringstream iss(tokens[1]); face_t face; while (!iss.eof()) { iss &gt;&gt; idx; face.indices.push_back(idx); } mesh.faces.push_back(face); mesh.normals-&gt;push_back(mesh.calcFaceNormal(face)); } } return mesh; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ std::string delete_symbol(const std::string &amp;str, char symbol) { std::string tmp = str; tmp.erase(std::remove(tmp.begin(), tmp.end(), symbol), tmp.end()); return tmp; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ std::vector&lt;std::string&gt; ReaderWriterPMD::parseLine(const std::string &amp;line) const { std::vector&lt;std::string&gt; tokens; std::string tmp = delete_symbol(line, '\r'); size_t pos = 0; std::string token; while ( (pos = tmp.find(':')) != std::string::npos ) { token = tmp.substr(0, pos); tmp.erase(0, pos + 1); if (!token.empty()) tokens.push_back(token); } tokens.push_back(tmp); return tokens; } REGISTER_OSGPLUGIN( pmd, ReaderWriterPMD )</span></span></span></span></code> </pre><br></div></div><br> 首先，让我们照顾一下用于存储几何数据的结构。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">face_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; indices; };</code> </pre><br>  -描述由属于该面的顶点的索引列表定义的面。 整个模型将通过这种结构进行描述 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pmd_mesh_t</span></span></span><span class="hljs-class"> {</span></span> osg::ref_ptr&lt;osg::Vec3Array&gt; vertices; osg::ref_ptr&lt;osg::Vec3Array&gt; normals; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">face_t</span></span>&gt; faces; <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span>() : vertices(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) , normals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) { } osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcFaceNormal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">face_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;face)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ osg::Vec3 v0 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">0</span></span>]]; osg::Vec3 v1 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">1</span></span>]]; osg::Vec3 v2 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">2</span></span>]]; osg::Vec3 n = (v1 - v0) ^ (v2 - v0); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * (<span class="hljs-number"><span class="hljs-number">1</span></span> / n.length()); } };</code> </pre><br> 该结构由用于存储数据的成员变量组成：顶点-用于存储几何对象的顶点数组； 法线-对象表面法线的数组； 面孔-对象的面孔列表。 结构构造函数立即初始化智能指针 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span>() : vertices(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) , normals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) { }</code> </pre><br> 另外，该结构包含一个方法，该方法允许您计算作为calcFaceNormal（）的法线向量的参数，该参数采用描述面部的结构。 我们不会详细介绍此方法的实现，稍后将对其进行分析。 <br><br> 因此，我们决定了要在其中存储几何数据的结构。 现在让我们编写插件的框架，即，我们实现osgDB :: ReaderWriter继承者类 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReaderWriterPMD</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgDB::ReaderWriter { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ReaderWriterPMD(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> parsePMD(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; parseLine(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;line) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; };</code> </pre><br> 正如在开发插件的API的描述中所建议的那样，在此类中，我们重新定义了从文件读取数据并将其转换为场景的子图的方法。  readNode（）方法有两个重载-一个重载文件名作为输入，另一个重载标准输入流。 类构造函数定义插件支持的文件扩展名 <br><br><pre> <code class="cpp hljs">ReaderWriterPMD::ReaderWriterPMD() { supportsExtension(<span class="hljs-string"><span class="hljs-string">"pmd"</span></span>, <span class="hljs-string"><span class="hljs-string">"PMD model file"</span></span>); }</code> </pre><br>  readNode（）方法的第一个重载分析文件名和文件路径的正确性，将标准输入流与文件相关联，并调用第二个重载，完成主要工作 <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;filename, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgDB::Options *options) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       std::string ext = osgDB::getLowerCaseFileExtension(filename); // ,      if (!acceptsExtension(ext)) return ReadResult::FILE_NOT_HANDLED; // ,       std::string fileName = osgDB::findDataFile(filename, options); if (fileName.empty()) return ReadResult::FILE_NOT_FOUND; //      std::ifstream stream(fileName.c_str(), std::ios::in); if (!stream) return ReadResult::ERROR_IN_READING_FILE; //      readNode() return readNode(stream, options); }</span></span></code> </pre><br> 在第二个重载中，我们为OSG实现了对象生成算法 <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgDB::Options *options) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) options; <span class="hljs-comment"><span class="hljs-comment">//   *.pmd       pmd_mesh_t mesh = parsePMD(stream); //    osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; //    geom-&gt;setVertexArray(mesh.vertices.get()); //    for (size_t i = 0; i &lt; mesh.faces.size(); ++i) { //    GL_POLYGON      (  - 0) osg::ref_ptr&lt;osg::DrawElementsUInt&gt; polygon = new osg::DrawElementsUInt(osg::PrimitiveSet::POLYGON, 0); //       for (size_t j = 0; j &lt; mesh.faces[i].indices.size(); ++j) polygon-&gt;push_back(mesh.faces[i].indices[j]); //     geom-&gt;addPrimitiveSet(polygon.get()); } //    geom-&gt;setNormalArray(mesh.normals.get()); //  OpenGL,       geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); //             osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(geom.get()); //     return geode.release(); }</span></span></code> </pre><br> 在main.cpp文件的末尾，调用REGISTER_OSGPLUGIN（）宏。 <br><br><pre> <code class="cpp hljs">REGISTER_OSGPLUGIN( pmd, ReaderWriterPMD )</code> </pre><br> 该宏生成附加代码，该代码允许OSG以osgDB库的形式构造类型为ReaderWriterPMD的对象，并调用其方法以加载类型为pmd的文件。 这样，插件框架就准备好了，事情仍然不大了-实现加载和解析pmd文件。 <br><br><h1>  7. Parsim 3D模型文件 </h1><br> 现在，该插件的所有功能都取决于parsePMD（）方法的实现 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> ReaderWriterPMD::parsePMD(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> mesh; <span class="hljs-comment"><span class="hljs-comment">//    while (!stream.eof()) { //      std::string line; std::getline(stream, line); //     -     std::vector&lt;std::string&gt; tokens = parseLine(line); //    -  if (tokens[0] == "vertex") { //       osg::Vec3 point; std::istringstream iss(tokens[1]); iss &gt;&gt; point.x() &gt;&gt; point.y() &gt;&gt; point.z(); //      mesh.vertices-&gt;push_back(point); } //    -  if (tokens[0] == "face") { //         unsigned int idx = 0; std::istringstream iss(tokens[1]); face_t face; while (!iss.eof()) { iss &gt;&gt; idx; face.indices.push_back(idx); } //      mesh.faces.push_back(face); //     mesh.normals-&gt;push_back(mesh.calcFaceNormal(face)); } } return mesh; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ParseLine（）方法解析Pmd文件的行 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; ReaderWriterPMD::parseLine(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;line) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; tokens; <span class="hljs-comment"><span class="hljs-comment">//   ,        ( Windows) std::string tmp = delete_symbol(line, '\r'); size_t pos = 0; std::string token; //      ,     : //      while ( (pos = tmp.find(':')) != std::string::npos ) { //     (vertex  face   ) token = tmp.substr(0, pos); //         tmp.erase(0, pos + 1); if (!token.empty()) tokens.push_back(token); } //        tokens.push_back(tmp); return tokens; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此方法会将字符串“ vertex：1.0 -1.0 0.0”转换为“ vertex”和“ 1.0 -1.0 0.0”两行的列表。</font><font style="vertical-align: inherit;">在第一行中，我们确定数据类型-顶点或面，从第二行中，我们提取顶点坐标上的数据。</font><font style="vertical-align: inherit;">为了确保此方法的运行，我们需要辅助函数delete_symbol（），该函数从字符串中删除给定的字符，并返回不包含该字符的字符串</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete_symbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> tmp = str; tmp.erase(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove(tmp.begin(), tmp.end(), symbol), tmp.end()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 也就是说，现在我们已经实现了插件的所有功能并可以对其进行测试。 </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.测试插件 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们编译插件并运行调试（F5）。</font><font style="vertical-align: inherit;">将启动标准osgviewerd查看器的调试版本，该版本将分析传递给它的piramide.pmd文件，加载我们的插件并调用其readNode（）方法。</font><font style="vertical-align: inherit;">如果我们做对了所有事情，那么我们将得到这样的结果：</font></font><br><br><img src="https://habrastorage.org/webt/s3/5g/-y/s35g-ykmmlet5z8jisj7efkz7je.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，我们发明的3D模型文件中的顶点和面列表隐藏了四角锥。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我们要自己计算法线？</font><font style="vertical-align: inherit;">在其中一课中，我们提供了以下自动计算平滑法线的方法</font></font><br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们在示例中应用此函数，而不是分配自己的法线 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//geom-&gt;setNormalArray(mesh.normals.get()); //geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); osgUtil::SmoothingVisitor::smooth(*geom);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以得到以下结果：</font></font><br><br><img src="https://habrastorage.org/webt/eb/gd/kt/ebgdktxsplxyqatprxunnwd8r2o.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">法线会影响照明模型的计算，并且可以看到在这种情况下，平滑的法线会导致金字塔照明计算的错误结果。</font><font style="vertical-align: inherit;">出于这个原因，我们将我们的自行车应用于法线计算。</font><font style="vertical-align: inherit;">但我认为，解释这一细微差别超出了本课程的范围。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN438296/">https://habr.com/ru/post/zh-CN438296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN438286/index.html">在JavaScript中使用时区</a></li>
<li><a href="../zh-CN438288/index.html">无所畏惧的保护。 Rust的内存安全性</a></li>
<li><a href="../zh-CN438290/index.html">GGJ-2019的事后分析：如何获得成功，但仍能使游戏成为现实</a></li>
<li><a href="../zh-CN438292/index.html">使用HomePod，Raspberry Pi和Node.js的公寓自动化</a></li>
<li><a href="../zh-CN438294/index.html">在PUBG比赛中查找抽搐彩带</a></li>
<li><a href="../zh-CN438298/index.html">为什么要教开发是否更有利可图。 与GeekBrains的对话</a></li>
<li><a href="../zh-CN438302/index.html">数字进化的惊人创造力</a></li>
<li><a href="../zh-CN438304/index.html">分包？ 酷你命中</a></li>
<li><a href="../zh-CN438306/index.html">辐射：平日放射化学实验室</a></li>
<li><a href="../zh-CN438310/index.html">Instagram使用机器学习删除假粉丝</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>