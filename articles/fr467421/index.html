<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë©üèª üë©‚Äçüéì üõµ Cr√©er des pointeurs intelligents expressifs pour la m√©moire distante en C ++ üë®üèø‚Äçü§ù‚Äçüë®üèª ü¶Ñ üçó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Aujourd'hui, nous publions la traduction d'une √©tude int√©ressante sur l'utilisation de la m√©moire et des pointeurs en C ++. Le mat√©r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©er des pointeurs intelligents expressifs pour la m√©moire distante en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/467421/">  Bonjour, Habr! <br><br>  Aujourd'hui, nous publions la traduction d'une √©tude int√©ressante sur l'utilisation de la m√©moire et des pointeurs en C ++.  Le mat√©riel est un peu acad√©mique, mais il int√©ressera √©videmment les lecteurs des livres de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Galowitz</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Williams</a> . <br><br>  Suivez l'annonce! <br><a name="habracut"></a><br>  A l'√©cole doctorale, je suis engag√© dans la construction de structures de donn√©es distribu√©es.  Par cons√©quent, l'abstraction repr√©sentant le pointeur distant est extr√™mement importante dans mon travail pour cr√©er du code propre et bien rang√©.  Dans cet article, je vais expliquer pourquoi des pointeurs intelligents sont n√©cessaires, expliquer comment j'ai √©crit des objets de pointeur distant en C ++ pour ma biblioth√®que, m'assurer qu'ils fonctionnent exactement comme des pointeurs C ++ normaux;  cela se fait en utilisant des objets de liaison distante.  De plus, j'expliquerai dans quels cas cette abstraction √©choue pour la simple raison que mon propre pointeur (jusqu'√† pr√©sent) ne fait pas face aux t√¢ches que les pointeurs ordinaires peuvent faire.  J'esp√®re que cet article int√©ressera les lecteurs impliqu√©s dans le d√©veloppement d'abstractions de haut niveau. <br><br><h3>  API de bas niveau </h3><br>  Lorsque vous travaillez avec des ordinateurs distribu√©s ou avec du mat√©riel r√©seau, vous avez souvent un acc√®s en lecture et en √©criture √† un morceau de m√©moire via l'API C. Un exemple de ce type est l'API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MPI</a> pour la communication unidirectionnelle.  Cette API utilise des fonctions qui ouvrent un acc√®s direct pour lire et √©crire √† partir de la m√©moire d'autres n≈ìuds situ√©s dans un cluster distribu√©.  Voici √† quoi cela ressemble de mani√®re l√©g√®rement simplifi√©e. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target_node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target_node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>;</code> </pre> <br>  Au <i>d√©calage</i> indiqu√© dans le segment de m√©moire partag√©e du n≈ìud cible, <code>remote_read</code> un certain nombre d'octets et <code>remote_write</code> √©crit un certain nombre d'octets. <br><br>  Ces API sont excellentes car elles nous donnent acc√®s √† des primitives importantes qui nous sont utiles pour impl√©menter des programmes s'ex√©cutant sur un cluster d'ordinateurs.  Ils sont √©galement tr√®s bons car ils fonctionnent tr√®s rapidement et refl√®tent avec pr√©cision les capacit√©s offertes au niveau mat√©riel: acc√®s direct √† la m√©moire √† distance (RDMA).  Les r√©seaux de superordinateurs modernes, tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cray Aries</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mellanox EDR</a> , nous permettent de calculer que le retard de lecture / √©criture ne d√©passera pas 1-2 Œºs.  Cet indicateur peut √™tre atteint du fait que la carte r√©seau (NIC) peut lire et √©crire directement sur la RAM, sans attendre que le CPU distant se r√©veille et r√©ponde √† votre demande de r√©seau. <br><br>  Cependant, ces API ne sont pas si bonnes en termes de programmation d'application.  M√™me dans le cas de ces API simples comme d√©crit ci-dessus, l'effacement accidentel des donn√©es ne co√ªte rien, car il n'y a pas de nom distinct pour chaque objet sp√©cifique stock√© en m√©moire, seulement un grand tampon contigu.  De plus, l'interface n'est pas typ√©e, c'est-√†-dire que vous √™tes priv√© d'une autre aide tangible: lorsque le compilateur jure, si vous √©crivez la valeur du mauvais type au mauvais endroit.  Votre code se r√©v√©lera simplement faux et les erreurs seront de la nature la plus myst√©rieuse et la plus catastrophique.  La situation est encore plus compliqu√©e car en r√©alit√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ces API</a> sont un peu plus compliqu√©es, et lorsque vous travaillez avec elles, il est tout √† fait possible de r√©organiser par erreur deux ou plusieurs param√®tres. <br><br><h3>  Pointeurs supprim√©s </h3><br>  Les pointeurs sont un niveau d'abstraction important et n√©cessaire lors de la cr√©ation d'outils de programmation de haut niveau.  L'utilisation directe de pointeurs est parfois difficile, et vous pouvez faire beaucoup de bugs, mais les pointeurs sont les blocs de construction fondamentaux du code.  Les structures de donn√©es et m√™me les liens C ++ utilisent souvent des pointeurs sous le capot. <br><br>  Si nous supposons que nous aurons une API similaire √† celles d√©crites ci-dessus, un emplacement unique en m√©moire sera indiqu√© par deux ¬´coordonn√©es¬ª: (1) le <i>rang</i> ou l'ID de processus et (2) le d√©calage apport√© √† la partie partag√©e de la m√©moire distante occup√©e par le processus avec ce rang .  Vous ne pouvez pas vous arr√™ter l√† et faire une structure √† part enti√®re. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rank_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset_; };</code> </pre> <br>  √Ä ce stade, il est d√©j√† possible de concevoir une API pour lire et √©crire sur des pointeurs distants, et cette API sera plus s√©curis√©e que celle que nous utilisions √† l'origine. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remote_ptr&lt;T&gt; src)</span></span></span><span class="hljs-function"> </span></span>{ T rv; remote_read(&amp;rv, src.rank_, src.offset_, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;T&gt; dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; src)</span></span></span><span class="hljs-function"> </span></span>{ remote_write(&amp;src, dst.rank_, dst.offset_, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); }</code> </pre> <br>  Les transferts de blocs sont tr√®s similaires, et ici je les omet par souci de concision.  Maintenant, pour lire et √©crire des valeurs, vous pouvez √©crire le code suivant: <br><br><pre> <code class="cpp hljs"> remote_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ptr = ...; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rval = rget(ptr); rval++; rput(ptr, rval);</code> </pre> <br>  C'est d√©j√† mieux que l'API d'origine, car ici nous travaillons avec des objets typ√©s.  D√©sormais, il n'est pas si facile d'√©crire ou de lire une valeur de mauvais type ou d'√©crire uniquement une partie d'un objet. <br><br><h3>  Arithm√©tique des pointeurs </h3><br>  L'arithm√©tique des pointeurs est la technique la plus importante qui permet √† un programmeur de g√©rer des collections de valeurs en m√©moire;  si nous √©crivons un programme pour le travail distribu√© en m√©moire, nous allons vraisemblablement fonctionner avec de grandes collections de valeurs. <br>  Que signifie augmenter ou diminuer un pointeur supprim√© d'une fa√ßon?  L'option la plus simple consiste √† consid√©rer l'arithm√©tique des pointeurs supprim√©s comme l'arithm√©tique des pointeurs ordinaires: p + 1 pointe simplement vers la taille suivante de la m√©moire align√©e <code>sizeof(T)</code> apr√®s p dans le segment partag√© du rang d'origine. <br><br>  Bien que ce ne soit pas la seule d√©finition possible de l'arithm√©tique des pointeurs distants, elle a r√©cemment √©t√© la plus activement adopt√©e, et les pointeurs distants utilis√©s de cette mani√®re sont contenus dans des biblioth√®ques telles que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UPC ++</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DASH</a> et BCL.  Cependant, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">langage Unified Parallel C</a> (UPC), qui a laiss√© un riche h√©ritage dans la communaut√© des sp√©cialistes du calcul haute performance (HPC), contient une d√©finition plus √©labor√©e de l'arithm√©tique des pointeurs [1]. <br><br>  L'impl√©mentation de l'arithm√©tique du pointeur de cette mani√®re est simple et ne n√©cessite que la modification du d√©calage du pointeur. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ptr&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> diff) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> new_offset = offset_ + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)*diff; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ptr&lt;T&gt;{rank_, new_offset}; }</code> </pre> <br>  Dans ce cas, nous avons la possibilit√© d'acc√©der √† des tableaux de donn√©es en m√©moire distribu√©e.  Ainsi, nous pourrions r√©aliser que chaque processus du programme SPMD effectuerait une op√©ration d'√©criture ou de lecture sur sa variable dans le tableau vers lequel le pointeur distant est dirig√© [2]. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; len) { rput(ptr + my_rank(), my_rank()); } }</code> </pre> <br>  Il est √©galement facile d'impl√©menter d'autres op√©rateurs, prenant en charge l'ensemble complet des op√©rations arithm√©tiques effectu√©es dans l'arithm√©tique de pointeur ordinaire. <br><br><h3>  S√©lectionnez nullptr </h3><br>  Pour les pointeurs r√©guliers, la valeur <code>nullptr</code> est <code>NULL</code> , ce qui signifie g√©n√©ralement r√©duire <code>#define</code> √† 0x0, car il est peu probable que cette section en m√©moire soit utilis√©e.  Dans notre sch√©ma avec des pointeurs distants, nous pouvons soit choisir une valeur de pointeur sp√©cifique comme <code>nullptr</code> , rendant ainsi cet emplacement en m√©moire inutilis√©, soit inclure un membre bool√©en sp√©cial qui indiquera si le pointeur est nul.  Bien que l'utilisation d'un certain emplacement dans la m√©moire ne soit pas la meilleure solution, nous tiendrons √©galement compte du fait que lors de l'ajout d'une seule valeur bool√©enne, la taille du pointeur distant doublera du point de vue de la plupart des compilateurs et passera de 128 √† 256 bits pour maintenir l'alignement.  Ceci est particuli√®rement ind√©sirable.  Dans ma biblioth√®que, j'ai choisi <code>{0, 0}</code> , c'est-√†-dire un d√©calage de 0 avec un rang de 0, comme valeur <code>nullptr</code> . <br><br>  Il peut √™tre possible de choisir d'autres options pour <code>nullptr</code> qui fonctionneront tout aussi bien.  De plus, dans certains environnements de programmation, tels que UPC, des pointeurs √©troits sont impl√©ment√©s qui tiennent sur 64 bits chacun.  Ainsi, ils peuvent √™tre utilis√©s dans des op√©rations de comparaison atomique avec √©change.  Lorsque vous travaillez avec un pointeur √©troit, vous devez faire des compromis: soit l'identificateur de d√©calage, soit l'identificateur de rang doit tenir sur 32 bits ou moins, ce qui limite l'√©volutivit√©. <br><br><h3>  Liens supprim√©s </h3><br>  Dans des langages comme Python, l'instruction bracket sert de sucre syntaxique pour appeler les <code>__getitem__</code> <code>__setitem__</code> et <code>__getitem__</code> , selon que vous lisez ou √©crivez l'objet.  En C ++, l' <code>operator[]</code> ne distingue pas √† laquelle des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cat√©gories de valeurs</a> un objet appartient et si la valeur retourn√©e tombera imm√©diatement en lecture ou en √©criture.  Pour r√©soudre ce probl√®me, les structures de donn√©es C ++ renvoient des liens pointant vers la m√©moire contenue dans le conteneur, qui peut √™tre √©crite ou lue.  L'impl√©mentation de l' <code>operator[]</code> pour <code>std::vector</code> pourrait ressembler √† ceci. <br><br><pre> <code class="cpp hljs"> T&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_[idx]; }</code> </pre><br>  Le fait le plus significatif ici est que nous renvoyons une entit√© de type <code>T&amp;</code> , qui est un lien C ++ brut par lequel vous pouvez √©crire, et non une entit√© de type <code>T</code> , qui repr√©sente simplement la valeur des donn√©es source. <br><br>  Dans notre cas, nous ne pouvons pas renvoyer un lien C ++ brut, car nous faisons r√©f√©rence √† la m√©moire situ√©e sur un autre n≈ìud et non repr√©sent√©e dans notre espace d'adressage virtuel.  Certes, nous pouvons cr√©er nos propres objets de r√©f√©rence personnalis√©s. <br>  Un lien est un objet qui sert de wrapper autour d'un pointeur, et il remplit deux fonctions importantes: il peut √™tre converti en une valeur de type <code>T</code> , et vous pouvez √©galement l'affecter √† une valeur de type <code>T</code>  Ainsi, dans le cas d'une r√©f√©rence distante, nous avons juste besoin d'impl√©menter un op√©rateur de conversion implicite qui lit la valeur, et √©galement de cr√©er un op√©rateur d'affectation qui √©crit dans la valeur. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote_ref</span></span></span><span class="hljs-class"> {</span></span> remote_ptr&lt;T&gt; ptr_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rget(ptr_); } remote_ref&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) { rput(ptr_, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } };</code> </pre><br>  Ainsi, nous pouvons enrichir notre pointeur distant de nouvelles fonctionnalit√©s puissantes, en pr√©sence desquelles il peut √™tre d√©r√©f√©renc√© exactement comme des pointeurs ordinaires. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ref&lt;T&gt;{*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ref&lt;T&gt;{*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + idx}; }</code> </pre> <br>  Alors maintenant, nous avons restaur√© l'image enti√®re montrant comment vous pouvez utiliser des pointeurs distants comme d'habitude.  Nous pouvons r√©√©crire le programme simple ci-dessus. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; len) { ptr[my_rank()] = my_rank(); } }</code> </pre> <br>  Bien s√ªr, notre nouvelle API de pointeur nous permet d'√©crire des programmes plus complexes, par exemple, une fonction pour effectuer une r√©duction parall√®le bas√©e sur un arbre [3].  Les impl√©mentations utilisant notre classe de pointeur distant sont plus s√ªres et plus propres que celles g√©n√©ralement obtenues √† l'aide de l'API C d√©crite ci-dessus. <br><br><h3>  Co√ªts r√©sultant de l'ex√©cution (ou de leur absence!) </h3><br>  Cependant, combien cela nous co√ªterait-il d'utiliser une telle abstraction de haut niveau?  Chaque fois que nous acc√©dons √† la m√©moire, nous appelons la m√©thode de d√©r√©f√©rencement, renvoyons l'objet interm√©diaire qui enveloppe le pointeur, puis nous appelons l'op√©rateur de conversion ou l'op√©rateur d'affectation qui affecte l'objet interm√©diaire.  Combien cela nous co√ªtera-t-il √† l'ex√©cution? <br><br>  Il s'av√®re que si vous d√©signez soigneusement le pointeur et les classes de r√©f√©rence, il n'y aura pas de surcharge pour cette abstraction au moment de l'ex√©cution - les compilateurs C ++ modernes g√®rent ces objets interm√©diaires et les appels de m√©thode par incorporation agressive.  Pour √©valuer ce qu'une telle abstraction nous co√ªtera, nous pouvons compiler un exemple de programme simple et v√©rifier comment l'assemblage se d√©roulera pour voir quels objets et m√©thodes existeront au moment de l'ex√©cution.  Dans l'exemple d√©crit ici avec la r√©duction bas√©e sur l'arborescence compil√©e avec des classes de pointeurs et de r√©f√©rences distants, les compilateurs modernes r√©duisent la r√©duction bas√©e sur l'arborescence √† plusieurs <code>remote_read</code> et <code>remote_write</code> [4].  Aucune m√©thode de classe n'est appel√©e, aucun objet de r√©f√©rence n'existe au moment de l'ex√©cution. <br><br><h3>  Interaction avec les biblioth√®ques de structure de donn√©es </h3><br>  Les programmeurs C ++ exp√©riment√©s se souviennent que la biblioth√®que de mod√®les C ++ standard indique: Les conteneurs STL doivent prendre en charge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les allocateurs C ++ personnalis√©s</a> .  Les allocateurs vous permettent d'allouer de la m√©moire, puis cette m√©moire peut √™tre r√©f√©renc√©e √† l'aide des types de pointeurs que nous avons cr√©√©s.  Cela signifie-t-il que vous pouvez simplement cr√©er un ¬´allocateur distant¬ª et le connecter pour stocker des donn√©es dans la m√©moire distante √† l'aide de conteneurs STL? <br><br>  Malheureusement non.  Vraisemblablement, pour des raisons de performances, la norme C ++ ne n√©cessite plus la prise en charge des types de r√©f√©rence personnalis√©s, et dans la plupart des impl√©mentations de la biblioth√®que standard C ++, elles ne sont vraiment pas prises en charge.  Ainsi, par exemple, si vous utilisez libstdc ++ de GCC, vous pouvez recourir √† des pointeurs personnalis√©s, mais seuls les liens C ++ normaux sont disponibles, ce qui ne vous permet pas d'utiliser des conteneurs STL dans la m√©moire distante.  Certaines biblioth√®ques de mod√®les C ++ de haut niveau, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Agency</a> , qui utilisent des types de pointeurs et des types de r√©f√©rence personnalis√©s, contiennent leurs propres impl√©mentations de certaines structures de donn√©es de STL qui vous permettent vraiment de travailler avec des types de r√©f√©rence distants.  Dans ce cas, le programmeur obtient plus de libert√© dans une approche cr√©ative pour cr√©er des types d'allocateurs, de pointeurs et de liens, et, en outre, obtient une collection de structures de donn√©es qui peuvent automatiquement √™tre utilis√©es avec elles. <br><br><h3>  Contexte large </h3><br>  Dans cet article, nous avons abord√© un certain nombre de probl√®mes plus vastes et non encore r√©solus. <br><br><ul><li>  <b>Allocation de m√©moire</b> .  Maintenant que nous pouvons r√©f√©rencer des objets dans la m√©moire distante, comment r√©server ou allouer une telle m√©moire distante? </li><li>  <b>Prise en charge des objets</b> .  Qu'en est-il du stockage en m√©moire distante de tels objets de types plus compliqu√©s qu'int?  Un support soign√© pour les types complexes est-il possible?  Les types simples peuvent-ils √™tre pris en charge en m√™me temps sans gaspiller les ressources sur la s√©rialisation? </li><li>  <b>Conception de structures de donn√©es distribu√©es</b> .  Maintenant que vous disposez de ces abstractions, quelles structures de donn√©es et applications pouvez-vous cr√©er avec elles?  Quelles abstractions devraient √™tre utilis√©es pour la distribution des donn√©es? </li></ul><br><h3>  Remarques </h3><br>  [1] Dans UPC, les pointeurs ont une phase qui d√©termine quel rang le pointeur sera dirig√© apr√®s avoir augment√© d'une unit√©.  En raison des phases, les tableaux distribu√©s peuvent √™tre encapsul√©s dans des pointeurs et les mod√®les de distribution peuvent √™tre tr√®s diff√©rents.  Ces fonctionnalit√©s sont tr√®s puissantes, mais elles peuvent sembler magiques √† un utilisateur novice.  Bien que certains as UPC pr√©f√®rent cette approche, une approche orient√©e objet plus raisonnable consiste √† √©crire d'abord une classe de pointeur distant simple, puis √† s'assurer que les donn√©es sont allou√©es en fonction de structures de donn√©es sp√©cialement con√ßues √† cet effet. <br><br>  [2] La plupart des applications dans HPC sont √©crites dans le style de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SPMD</a> , ce nom signifie "un programme, des donn√©es diff√©rentes".  L'API SPMD offre une fonction ou variable <code>my_rank()</code> qui indique au processus ex√©cutant le programme un rang ou un ID unique, sur la base duquel il peut ensuite se d√©river du programme principal. <br><br>  [3] Voici une simple r√©duction d'arbre √©crite dans le style SPMD en utilisant la classe de pointeur distant.  Le code est adapt√© sur la base d'un programme √©crit √† l'origine par mon coll√®gue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Andrew Belt</a> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;T&gt; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> k = len; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k = (k + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; k &amp;&amp; my_rank() + k &lt; len) { a[my_rank()] += a[my_rank() + k]; } len = k; barrier(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre><br>  [4] Le r√©sultat compil√© du code ci-dessus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut √™tre trouv√© ici</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467421/">https://habr.com/ru/post/fr467421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467407/index.html">Nous travaillons avec le cobot Dobot M1</a></li>
<li><a href="../fr467409/index.html">Pour faire des affaires dans la Silicon Valley, vous devez vous comporter</a></li>
<li><a href="../fr467413/index.html">Framework de microservice PHP - `Hello world` de Swoft</a></li>
<li><a href="../fr467415/index.html">March√© des changes moderne</a></li>
<li><a href="../fr467419/index.html">Sortie finale de Jakarta EE 8</a></li>
<li><a href="../fr467423/index.html">Xamarin.Forms - utilisation pratique des polices d'ic√¥nes dans l'application</a></li>
<li><a href="../fr467425/index.html">Approche d'apprentissage intensif STEM</a></li>
<li><a href="../fr467427/index.html">BudgetTracker - un autre outil open-source pour la comptabilit√© des finances personnelles</a></li>
<li><a href="../fr467429/index.html">Habrastatistique: explorer les sections les plus et les moins visit√©es du site</a></li>
<li><a href="../fr467435/index.html">Nous envoyons les rapports de l'agent Veeam Linux par courrier ou par t√©l√©gramme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>