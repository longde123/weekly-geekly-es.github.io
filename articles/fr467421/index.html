<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👩🏻 👩‍🎓 🛵 Créer des pointeurs intelligents expressifs pour la mémoire distante en C ++ 👨🏿‍🤝‍👨🏻 🦄 🍗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Aujourd'hui, nous publions la traduction d'une étude intéressante sur l'utilisation de la mémoire et des pointeurs en C ++. Le matér...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Créer des pointeurs intelligents expressifs pour la mémoire distante en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/467421/">  Bonjour, Habr! <br><br>  Aujourd'hui, nous publions la traduction d'une étude intéressante sur l'utilisation de la mémoire et des pointeurs en C ++.  Le matériel est un peu académique, mais il intéressera évidemment les lecteurs des livres de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Galowitz</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Williams</a> . <br><br>  Suivez l'annonce! <br><a name="habracut"></a><br>  A l'école doctorale, je suis engagé dans la construction de structures de données distribuées.  Par conséquent, l'abstraction représentant le pointeur distant est extrêmement importante dans mon travail pour créer du code propre et bien rangé.  Dans cet article, je vais expliquer pourquoi des pointeurs intelligents sont nécessaires, expliquer comment j'ai écrit des objets de pointeur distant en C ++ pour ma bibliothèque, m'assurer qu'ils fonctionnent exactement comme des pointeurs C ++ normaux;  cela se fait en utilisant des objets de liaison distante.  De plus, j'expliquerai dans quels cas cette abstraction échoue pour la simple raison que mon propre pointeur (jusqu'à présent) ne fait pas face aux tâches que les pointeurs ordinaires peuvent faire.  J'espère que cet article intéressera les lecteurs impliqués dans le développement d'abstractions de haut niveau. <br><br><h3>  API de bas niveau </h3><br>  Lorsque vous travaillez avec des ordinateurs distribués ou avec du matériel réseau, vous avez souvent un accès en lecture et en écriture à un morceau de mémoire via l'API C. Un exemple de ce type est l'API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MPI</a> pour la communication unidirectionnelle.  Cette API utilise des fonctions qui ouvrent un accès direct pour lire et écrire à partir de la mémoire d'autres nœuds situés dans un cluster distribué.  Voici à quoi cela ressemble de manière légèrement simplifiée. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target_node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target_node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>;</code> </pre> <br>  Au <i>décalage</i> indiqué dans le segment de mémoire partagée du nœud cible, <code>remote_read</code> un certain nombre d'octets et <code>remote_write</code> écrit un certain nombre d'octets. <br><br>  Ces API sont excellentes car elles nous donnent accès à des primitives importantes qui nous sont utiles pour implémenter des programmes s'exécutant sur un cluster d'ordinateurs.  Ils sont également très bons car ils fonctionnent très rapidement et reflètent avec précision les capacités offertes au niveau matériel: accès direct à la mémoire à distance (RDMA).  Les réseaux de superordinateurs modernes, tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cray Aries</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mellanox EDR</a> , nous permettent de calculer que le retard de lecture / écriture ne dépassera pas 1-2 μs.  Cet indicateur peut être atteint du fait que la carte réseau (NIC) peut lire et écrire directement sur la RAM, sans attendre que le CPU distant se réveille et réponde à votre demande de réseau. <br><br>  Cependant, ces API ne sont pas si bonnes en termes de programmation d'application.  Même dans le cas de ces API simples comme décrit ci-dessus, l'effacement accidentel des données ne coûte rien, car il n'y a pas de nom distinct pour chaque objet spécifique stocké en mémoire, seulement un grand tampon contigu.  De plus, l'interface n'est pas typée, c'est-à-dire que vous êtes privé d'une autre aide tangible: lorsque le compilateur jure, si vous écrivez la valeur du mauvais type au mauvais endroit.  Votre code se révélera simplement faux et les erreurs seront de la nature la plus mystérieuse et la plus catastrophique.  La situation est encore plus compliquée car en réalité <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ces API</a> sont un peu plus compliquées, et lorsque vous travaillez avec elles, il est tout à fait possible de réorganiser par erreur deux ou plusieurs paramètres. <br><br><h3>  Pointeurs supprimés </h3><br>  Les pointeurs sont un niveau d'abstraction important et nécessaire lors de la création d'outils de programmation de haut niveau.  L'utilisation directe de pointeurs est parfois difficile, et vous pouvez faire beaucoup de bugs, mais les pointeurs sont les blocs de construction fondamentaux du code.  Les structures de données et même les liens C ++ utilisent souvent des pointeurs sous le capot. <br><br>  Si nous supposons que nous aurons une API similaire à celles décrites ci-dessus, un emplacement unique en mémoire sera indiqué par deux «coordonnées»: (1) le <i>rang</i> ou l'ID de processus et (2) le décalage apporté à la partie partagée de la mémoire distante occupée par le processus avec ce rang .  Vous ne pouvez pas vous arrêter là et faire une structure à part entière. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rank_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset_; };</code> </pre> <br>  À ce stade, il est déjà possible de concevoir une API pour lire et écrire sur des pointeurs distants, et cette API sera plus sécurisée que celle que nous utilisions à l'origine. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remote_ptr&lt;T&gt; src)</span></span></span><span class="hljs-function"> </span></span>{ T rv; remote_read(&amp;rv, src.rank_, src.offset_, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;T&gt; dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; src)</span></span></span><span class="hljs-function"> </span></span>{ remote_write(&amp;src, dst.rank_, dst.offset_, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); }</code> </pre> <br>  Les transferts de blocs sont très similaires, et ici je les omet par souci de concision.  Maintenant, pour lire et écrire des valeurs, vous pouvez écrire le code suivant: <br><br><pre> <code class="cpp hljs"> remote_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ptr = ...; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rval = rget(ptr); rval++; rput(ptr, rval);</code> </pre> <br>  C'est déjà mieux que l'API d'origine, car ici nous travaillons avec des objets typés.  Désormais, il n'est pas si facile d'écrire ou de lire une valeur de mauvais type ou d'écrire uniquement une partie d'un objet. <br><br><h3>  Arithmétique des pointeurs </h3><br>  L'arithmétique des pointeurs est la technique la plus importante qui permet à un programmeur de gérer des collections de valeurs en mémoire;  si nous écrivons un programme pour le travail distribué en mémoire, nous allons vraisemblablement fonctionner avec de grandes collections de valeurs. <br>  Que signifie augmenter ou diminuer un pointeur supprimé d'une façon?  L'option la plus simple consiste à considérer l'arithmétique des pointeurs supprimés comme l'arithmétique des pointeurs ordinaires: p + 1 pointe simplement vers la taille suivante de la mémoire alignée <code>sizeof(T)</code> après p dans le segment partagé du rang d'origine. <br><br>  Bien que ce ne soit pas la seule définition possible de l'arithmétique des pointeurs distants, elle a récemment été la plus activement adoptée, et les pointeurs distants utilisés de cette manière sont contenus dans des bibliothèques telles que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UPC ++</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DASH</a> et BCL.  Cependant, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">langage Unified Parallel C</a> (UPC), qui a laissé un riche héritage dans la communauté des spécialistes du calcul haute performance (HPC), contient une définition plus élaborée de l'arithmétique des pointeurs [1]. <br><br>  L'implémentation de l'arithmétique du pointeur de cette manière est simple et ne nécessite que la modification du décalage du pointeur. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ptr&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> diff) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> new_offset = offset_ + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)*diff; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ptr&lt;T&gt;{rank_, new_offset}; }</code> </pre> <br>  Dans ce cas, nous avons la possibilité d'accéder à des tableaux de données en mémoire distribuée.  Ainsi, nous pourrions réaliser que chaque processus du programme SPMD effectuerait une opération d'écriture ou de lecture sur sa variable dans le tableau vers lequel le pointeur distant est dirigé [2]. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; len) { rput(ptr + my_rank(), my_rank()); } }</code> </pre> <br>  Il est également facile d'implémenter d'autres opérateurs, prenant en charge l'ensemble complet des opérations arithmétiques effectuées dans l'arithmétique de pointeur ordinaire. <br><br><h3>  Sélectionnez nullptr </h3><br>  Pour les pointeurs réguliers, la valeur <code>nullptr</code> est <code>NULL</code> , ce qui signifie généralement réduire <code>#define</code> à 0x0, car il est peu probable que cette section en mémoire soit utilisée.  Dans notre schéma avec des pointeurs distants, nous pouvons soit choisir une valeur de pointeur spécifique comme <code>nullptr</code> , rendant ainsi cet emplacement en mémoire inutilisé, soit inclure un membre booléen spécial qui indiquera si le pointeur est nul.  Bien que l'utilisation d'un certain emplacement dans la mémoire ne soit pas la meilleure solution, nous tiendrons également compte du fait que lors de l'ajout d'une seule valeur booléenne, la taille du pointeur distant doublera du point de vue de la plupart des compilateurs et passera de 128 à 256 bits pour maintenir l'alignement.  Ceci est particulièrement indésirable.  Dans ma bibliothèque, j'ai choisi <code>{0, 0}</code> , c'est-à-dire un décalage de 0 avec un rang de 0, comme valeur <code>nullptr</code> . <br><br>  Il peut être possible de choisir d'autres options pour <code>nullptr</code> qui fonctionneront tout aussi bien.  De plus, dans certains environnements de programmation, tels que UPC, des pointeurs étroits sont implémentés qui tiennent sur 64 bits chacun.  Ainsi, ils peuvent être utilisés dans des opérations de comparaison atomique avec échange.  Lorsque vous travaillez avec un pointeur étroit, vous devez faire des compromis: soit l'identificateur de décalage, soit l'identificateur de rang doit tenir sur 32 bits ou moins, ce qui limite l'évolutivité. <br><br><h3>  Liens supprimés </h3><br>  Dans des langages comme Python, l'instruction bracket sert de sucre syntaxique pour appeler les <code>__getitem__</code> <code>__setitem__</code> et <code>__getitem__</code> , selon que vous lisez ou écrivez l'objet.  En C ++, l' <code>operator[]</code> ne distingue pas à laquelle des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">catégories de valeurs</a> un objet appartient et si la valeur retournée tombera immédiatement en lecture ou en écriture.  Pour résoudre ce problème, les structures de données C ++ renvoient des liens pointant vers la mémoire contenue dans le conteneur, qui peut être écrite ou lue.  L'implémentation de l' <code>operator[]</code> pour <code>std::vector</code> pourrait ressembler à ceci. <br><br><pre> <code class="cpp hljs"> T&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_[idx]; }</code> </pre><br>  Le fait le plus significatif ici est que nous renvoyons une entité de type <code>T&amp;</code> , qui est un lien C ++ brut par lequel vous pouvez écrire, et non une entité de type <code>T</code> , qui représente simplement la valeur des données source. <br><br>  Dans notre cas, nous ne pouvons pas renvoyer un lien C ++ brut, car nous faisons référence à la mémoire située sur un autre nœud et non représentée dans notre espace d'adressage virtuel.  Certes, nous pouvons créer nos propres objets de référence personnalisés. <br>  Un lien est un objet qui sert de wrapper autour d'un pointeur, et il remplit deux fonctions importantes: il peut être converti en une valeur de type <code>T</code> , et vous pouvez également l'affecter à une valeur de type <code>T</code>  Ainsi, dans le cas d'une référence distante, nous avons juste besoin d'implémenter un opérateur de conversion implicite qui lit la valeur, et également de créer un opérateur d'affectation qui écrit dans la valeur. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote_ref</span></span></span><span class="hljs-class"> {</span></span> remote_ptr&lt;T&gt; ptr_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rget(ptr_); } remote_ref&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) { rput(ptr_, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } };</code> </pre><br>  Ainsi, nous pouvons enrichir notre pointeur distant de nouvelles fonctionnalités puissantes, en présence desquelles il peut être déréférencé exactement comme des pointeurs ordinaires. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ref&lt;T&gt;{*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ref&lt;T&gt;{*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + idx}; }</code> </pre> <br>  Alors maintenant, nous avons restauré l'image entière montrant comment vous pouvez utiliser des pointeurs distants comme d'habitude.  Nous pouvons réécrire le programme simple ci-dessus. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; len) { ptr[my_rank()] = my_rank(); } }</code> </pre> <br>  Bien sûr, notre nouvelle API de pointeur nous permet d'écrire des programmes plus complexes, par exemple, une fonction pour effectuer une réduction parallèle basée sur un arbre [3].  Les implémentations utilisant notre classe de pointeur distant sont plus sûres et plus propres que celles généralement obtenues à l'aide de l'API C décrite ci-dessus. <br><br><h3>  Coûts résultant de l'exécution (ou de leur absence!) </h3><br>  Cependant, combien cela nous coûterait-il d'utiliser une telle abstraction de haut niveau?  Chaque fois que nous accédons à la mémoire, nous appelons la méthode de déréférencement, renvoyons l'objet intermédiaire qui enveloppe le pointeur, puis nous appelons l'opérateur de conversion ou l'opérateur d'affectation qui affecte l'objet intermédiaire.  Combien cela nous coûtera-t-il à l'exécution? <br><br>  Il s'avère que si vous désignez soigneusement le pointeur et les classes de référence, il n'y aura pas de surcharge pour cette abstraction au moment de l'exécution - les compilateurs C ++ modernes gèrent ces objets intermédiaires et les appels de méthode par incorporation agressive.  Pour évaluer ce qu'une telle abstraction nous coûtera, nous pouvons compiler un exemple de programme simple et vérifier comment l'assemblage se déroulera pour voir quels objets et méthodes existeront au moment de l'exécution.  Dans l'exemple décrit ici avec la réduction basée sur l'arborescence compilée avec des classes de pointeurs et de références distants, les compilateurs modernes réduisent la réduction basée sur l'arborescence à plusieurs <code>remote_read</code> et <code>remote_write</code> [4].  Aucune méthode de classe n'est appelée, aucun objet de référence n'existe au moment de l'exécution. <br><br><h3>  Interaction avec les bibliothèques de structure de données </h3><br>  Les programmeurs C ++ expérimentés se souviennent que la bibliothèque de modèles C ++ standard indique: Les conteneurs STL doivent prendre en charge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les allocateurs C ++ personnalisés</a> .  Les allocateurs vous permettent d'allouer de la mémoire, puis cette mémoire peut être référencée à l'aide des types de pointeurs que nous avons créés.  Cela signifie-t-il que vous pouvez simplement créer un «allocateur distant» et le connecter pour stocker des données dans la mémoire distante à l'aide de conteneurs STL? <br><br>  Malheureusement non.  Vraisemblablement, pour des raisons de performances, la norme C ++ ne nécessite plus la prise en charge des types de référence personnalisés, et dans la plupart des implémentations de la bibliothèque standard C ++, elles ne sont vraiment pas prises en charge.  Ainsi, par exemple, si vous utilisez libstdc ++ de GCC, vous pouvez recourir à des pointeurs personnalisés, mais seuls les liens C ++ normaux sont disponibles, ce qui ne vous permet pas d'utiliser des conteneurs STL dans la mémoire distante.  Certaines bibliothèques de modèles C ++ de haut niveau, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Agency</a> , qui utilisent des types de pointeurs et des types de référence personnalisés, contiennent leurs propres implémentations de certaines structures de données de STL qui vous permettent vraiment de travailler avec des types de référence distants.  Dans ce cas, le programmeur obtient plus de liberté dans une approche créative pour créer des types d'allocateurs, de pointeurs et de liens, et, en outre, obtient une collection de structures de données qui peuvent automatiquement être utilisées avec elles. <br><br><h3>  Contexte large </h3><br>  Dans cet article, nous avons abordé un certain nombre de problèmes plus vastes et non encore résolus. <br><br><ul><li>  <b>Allocation de mémoire</b> .  Maintenant que nous pouvons référencer des objets dans la mémoire distante, comment réserver ou allouer une telle mémoire distante? </li><li>  <b>Prise en charge des objets</b> .  Qu'en est-il du stockage en mémoire distante de tels objets de types plus compliqués qu'int?  Un support soigné pour les types complexes est-il possible?  Les types simples peuvent-ils être pris en charge en même temps sans gaspiller les ressources sur la sérialisation? </li><li>  <b>Conception de structures de données distribuées</b> .  Maintenant que vous disposez de ces abstractions, quelles structures de données et applications pouvez-vous créer avec elles?  Quelles abstractions devraient être utilisées pour la distribution des données? </li></ul><br><h3>  Remarques </h3><br>  [1] Dans UPC, les pointeurs ont une phase qui détermine quel rang le pointeur sera dirigé après avoir augmenté d'une unité.  En raison des phases, les tableaux distribués peuvent être encapsulés dans des pointeurs et les modèles de distribution peuvent être très différents.  Ces fonctionnalités sont très puissantes, mais elles peuvent sembler magiques à un utilisateur novice.  Bien que certains as UPC préfèrent cette approche, une approche orientée objet plus raisonnable consiste à écrire d'abord une classe de pointeur distant simple, puis à s'assurer que les données sont allouées en fonction de structures de données spécialement conçues à cet effet. <br><br>  [2] La plupart des applications dans HPC sont écrites dans le style de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SPMD</a> , ce nom signifie "un programme, des données différentes".  L'API SPMD offre une fonction ou variable <code>my_rank()</code> qui indique au processus exécutant le programme un rang ou un ID unique, sur la base duquel il peut ensuite se dériver du programme principal. <br><br>  [3] Voici une simple réduction d'arbre écrite dans le style SPMD en utilisant la classe de pointeur distant.  Le code est adapté sur la base d'un programme écrit à l'origine par mon collègue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Andrew Belt</a> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;T&gt; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> k = len; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k = (k + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; k &amp;&amp; my_rank() + k &lt; len) { a[my_rank()] += a[my_rank() + k]; } len = k; barrier(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre><br>  [4] Le résultat compilé du code ci-dessus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut être trouvé ici</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467421/">https://habr.com/ru/post/fr467421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467407/index.html">Nous travaillons avec le cobot Dobot M1</a></li>
<li><a href="../fr467409/index.html">Pour faire des affaires dans la Silicon Valley, vous devez vous comporter</a></li>
<li><a href="../fr467413/index.html">Framework de microservice PHP - `Hello world` de Swoft</a></li>
<li><a href="../fr467415/index.html">Marché des changes moderne</a></li>
<li><a href="../fr467419/index.html">Sortie finale de Jakarta EE 8</a></li>
<li><a href="../fr467423/index.html">Xamarin.Forms - utilisation pratique des polices d'icônes dans l'application</a></li>
<li><a href="../fr467425/index.html">Approche d'apprentissage intensif STEM</a></li>
<li><a href="../fr467427/index.html">BudgetTracker - un autre outil open-source pour la comptabilité des finances personnelles</a></li>
<li><a href="../fr467429/index.html">Habrastatistique: explorer les sections les plus et les moins visitées du site</a></li>
<li><a href="../fr467435/index.html">Nous envoyons les rapports de l'agent Veeam Linux par courrier ou par télégramme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>