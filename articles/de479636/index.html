<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òéÔ∏è üë®‚ÄçüöÄ üç≥ Eigener Navigationsstack. Besser als ROS? üë©‚Äç‚ù§Ô∏è‚Äçüë® üíí ‚úä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite Artikel des setUP-Teams √ºber unsere Erfahrungen bei der Erstellung autonomer Roboter f√ºr Eurobot Open-Wettbewerbe und deren Verwen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eigener Navigationsstack. Besser als ROS?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479636/">  Dies ist der zweite Artikel des setUP-Teams √ºber unsere Erfahrungen bei der Erstellung autonomer Roboter f√ºr Eurobot Open-Wettbewerbe und deren Verwendung von ROS. <br><br>  <a href="https://habr.com/ru/post/478836/">Der erste Artikel befasst sich mit der Mechanik und der allgemeinen Architektur von Robotern.</a> <br><br>  Roboter bewegen sich auf einem flachen Feld und die meisten Hindernisse sind im Voraus bekannt. Schleichende Gegner k√∂nnen jedoch versuchen, unsere Ressourcen zu stehlen (und wir m√∂chten manchmal ein paar Dutzend zus√§tzliche Punkte essen), w√§hrend wir so schnell wie m√∂glich zum gew√ºnschten Punkt fahren und die Hindernisse nicht ber√ºhren m√∂chten.  Von einer externen Kamera auf dem Feld erhalten wir Daten √ºber die Position des Feindes und wissen, wo er sich jetzt befindet.  Es reicht jedoch nicht aus, seine Position zu kennen - Sie m√ºssen in der Lage sein, diese Informationen zu verwenden. <br><br>  Heute werden wir versuchen, von Punkt A nach Punkt B zu fahren, ohne den Schwanz einer Katze entlanggefahren zu sein, die auf dem Feld eingeschlafen ist.  Insbesondere werden wir erkl√§ren, wie wir eine Route erstellen, die Geschwindigkeit des Roboters steuern und wie alles auf unserem Computer gestartet wird. <br><br><img src="https://habrastorage.org/webt/om/x0/a6/omx0a6wfefbht9c1pialld-9vqy.png"><br><a name="habracut"></a><br><h3>  Ich versuche mit ein bisschen Blut auszukommen </h3><br>  Wenn Sie dieses Problem l√∂sen, k√∂nnen Sie vorgefertigtes Material verwenden, das von Fachleuten geschrieben wurde. Dann wird das n√§chste ‚ÄûFahrrad‚Äú nicht mehr erfunden.  Wir verwendeten eine Allradplattform, und obwohl versucht wurde, einen vorgefertigten lokalen Hobel von ROS zu verwenden, war dies aus mehreren Gr√ºnden nicht vielversprechend.  Unten sehen Sie, wie viel Material der Designer eines Standard-Segelflugzeugs ben√∂tigt: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @class TrajectoryPlanner * @brief Computes control velocities for a robot given a costmap, a plan, and the robot's position in the world. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlanner</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlannerTest</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//Need this for gtest to work public: /** * @brief Constructs a trajectory controller * @param world_model The WorldModel the trajectory controller uses to check for collisions * @param costmap A reference to the Costmap the controller should use * @param footprint_spec A polygon representing the footprint of the robot. (Must be convex) * @param inscribed_radius The radius of the inscribed circle of the robot * @param circumscribed_radius The radius of the circumscribed circle of the robot * @param acc_lim_x The acceleration limit of the robot in the x direction * @param acc_lim_y The acceleration limit of the robot in the y direction * @param acc_lim_theta The acceleration limit of the robot in the theta direction * @param sim_time The number of seconds to "roll-out" each trajectory * @param sim_granularity The distance between simulation points should be small enough that the robot doesn't hit things * @param vx_samples The number of trajectories to sample in the x dimension * @param vtheta_samples The number of trajectories to sample in the theta dimension * @param pdist_scale A scaling factor for how close the robot should stay to the path * @param gdist_scale A scaling factor for how aggresively the robot should pursue a local goal * @param occdist_scale A scaling factor for how much the robot should prefer to stay away from obstacles * @param heading_lookahead How far the robot should look ahead of itself when differentiating between different rotational velocities * @param oscillation_reset_dist The distance the robot must travel before it can explore rotational velocities that were unsuccessful in the past * @param escape_reset_dist The distance the robot must travel before it can exit escape mode * @param escape_reset_theta The distance the robot must rotate before it can exit escape mode * @param holonomic_robot Set this to true if the robot being controlled can take y velocities and false otherwise * @param max_vel_x The maximum x velocity the controller will explore * @param min_vel_x The minimum x velocity the controller will explore * @param max_vel_th The maximum rotational velocity the controller will explore * @param min_vel_th The minimum rotational velocity the controller will explore * @param min_in_place_vel_th The absolute value of the minimum in-place rotational velocity the controller will explore * @param backup_vel The velocity to use while backing up * @param dwa Set this to true to use the Dynamic Window Approach, false to use acceleration limits * @param heading_scoring Set this to true to score trajectories based on the robot's heading after 1 timestep * @param heading_scoring_timestep How far to look ahead in time when we score heading based trajectories * @param meter_scoring adapt parameters to costmap resolution * @param simple_attractor Set this to true to allow simple attraction to a goal point instead of intelligent cost propagation * @param y_vels A vector of the y velocities the controller will explore * @param angular_sim_granularity The distance between simulation points for angular velocity should be small enough that the robot doesn't hit things */ TrajectoryPlanner(WorldModel&amp; world_model, const costmap_2d::Costmap2D&amp; costmap, std::vector&lt;geometry_msgs::Point&gt; footprint_spec, double acc_lim_x = 1.0, double acc_lim_y = 1.0, double acc_lim_theta = 1.0, double sim_time = 1.0, double sim_granularity = 0.025, int vx_samples = 20, int vtheta_samples = 20, double pdist_scale = 0.6, double gdist_scale = 0.8, double occdist_scale = 0.2, double heading_lookahead = 0.325, double oscillation_reset_dist = 0.05, double escape_reset_dist = 0.10, double escape_reset_theta = M_PI_2, bool holonomic_robot = true, double max_vel_x = 0.5, double min_vel_x = 0.1, double max_vel_th = 1.0, double min_vel_th = -1.0, double min_in_place_vel_th = 0.4, double backup_vel = -0.1, bool dwa = false, bool heading_scoring = false, double heading_scoring_timestep = 0.1, bool meter_scoring = true, bool simple_attractor = false, std::vector&lt;double&gt; y_vels = std::vector&lt;double&gt;(0), double stop_time_buffer = 0.2, double sim_period = 0.1, double angular_sim_granularity = 0.025);</span></span></code> </pre> <br>  <i>Dies ist ein Beispiel f√ºr die Initialisierung von Parametern zur Regelung der Geschwindigkeit und der gesamten Flugbahn.</i> <br><br>  Wichtige Parameter f√ºr eine vollst√§ndige Berechnung: <br><br><ol><li>  Parameter world_model. </li><li>  Kostenkartenparameter: Ein Link zu einer Karte, die Hindernisse enth√§lt, sowie deren "virtuelle Erweiterung" unter Ber√ºcksichtigung der m√∂glichen Kollision. </li></ol><br>  Von den Vorteilen des Standardstacks k√∂nnen Sie die Verf√ºgbarkeit der Dokumentation und die F√§higkeit hervorheben, Informationen in den Foren zu finden.  <a href="https://github.com/ros-planning/navigation" rel="nofollow">Sie k√∂nnen mehr auf der offiziellen Website mit Dokumentation lesen</a> <br><br>  Es ist wichtig zu erw√§hnen, dass ROS-Pakete f√ºr zweir√§drige Plattformen geschrieben wurden und unter Omni optimiert wurden, indem der verf√ºgbare Drehwinkel beim Bewegen auf 360 Grad erh√∂ht wurde, was sicherlich eine Kr√ºcke ist. <br><br>  Nach der Analyse des Projekts stellten wir fest, dass das Lernen und Erg√§nzen schwierig sein w√ºrde und dass es viele schwere Chips gibt, die wir nicht ben√∂tigen.  Es scheint, lassen Sie sie sein, aber wir verwendeten Odroid xu4 (der Prozessor, von dem noch auf Samsung s5 war), und die Leistungsergebnisse waren deprimierend, und der Raum f√ºr etwas leistungsf√§higeres (und die Himbeere 4 und der Jetson Nano-Prozessor rauchen nerv√∂s beiseite im Vergleich zu mit ihm) nein.  Ich musste den Standardstapel aufgeben und versuchen, den globalen Planer, den lokalen Planer und den Flugbahnregler selbst zu erstellen <br><br><img src="https://habrastorage.org/webt/ij/qe/es/ijqeesrak1vuhjqfr1ij6exr4_a.jpeg"><br><br><h3>  Globaler Planer, lokaler Planer, Flugbahnregler und alles in allem </h3><br>  Globale und lokale Segelflugzeuge werden ben√∂tigt, um eine Wegbeschreibung zum Ziel zu erhalten.  Warum ist eine Trennung notwendig?  Warum kannst du nicht einfach <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A * nehmen</a> und damit fahren?  In der Regel kann der globale Planer beim Erstellen einer Route die gesamte Karte in seiner Arbeit verwenden, sodass der Algorithmus so schnell wie m√∂glich sein sollte, m√∂glicherweise sogar mit einigen Vereinfachungen.  Um diese Vereinfachungen auszugleichen, verwenden sie auch den lokalen Planer, der auf der Grundlage des Ergebnisses des globalen Planers (oder nur eines begrenzten Bereichs um den Roboter) versucht, alle Nuancen zu ber√ºcksichtigen. <br><br>  Nachdem wir die Route erstellt haben, wissen wir, wohin der Roboter gehen soll, aber wie kann er dar√ºber informiert werden?  Dazu gibt es einen Flugbahnregler.  Er berechnet, mit welcher Geschwindigkeit und in welche Richtung sich der Roboter gerade bewegen soll, um nicht von der Flugbahn abzuweichen.  In vielerlei Hinsicht ist dieses Paket daf√ºr verantwortlich, wie schnell und sch√∂n der Roboter f√§hrt. <br><br>  Neben diesen drei Entit√§ten gibt es einen vierten - einen Kartenserver, mit dem Sie den Zustand der Welt bequem verarbeiten k√∂nnen.  Es legt fest, wie wir die Karte beschreiben, welche M√∂glichkeiten wir beim Arbeiten mit der Karte haben und in vielerlei Hinsicht die Geschwindigkeit der Segelflugzeuge bestimmen. <br><br>  Bevor Sie mit der Beschreibung des Navigationsstapels fortfahren, sollten Sie die Gr√ºnde erl√§utern, warum cost_map als Kartenserver ausgew√§hlt wurde.  Im Allgemeinen haben wir verschiedene Optionen f√ºr den Map-Handler <a href="http://wiki.ros.org/grid_map" rel="nofollow">ausprobiert</a> : <a href="https://github.com/IntelRealSense/realsense-ros/tree/occupancy-mapping" rel="nofollow">Occupancy_grid</a> , <a href="http://wiki.ros.org/grid_map" rel="nofollow">Grid_map</a> , <a href="https://github.com/stonier/cost_map" rel="nofollow">Cost_map</a> . <br><br>  Gr√ºnde: <br><br><ol><li>  Bequem mit der Karte interagieren. </li><li>  Es gibt verschiedene Iteratoren, die wir in verschiedenen Formen ben√∂tigen (kreisf√∂rmig, linear, rechteckig usw.). </li><li>  Sie k√∂nnen mehrere Kartenebenen mit unterschiedlichen Parametern speichern. </li><li>  Gutes Speichermanagement. </li><li>  Und vor allem Geschwindigkeit.  Grid Map funktioniert mit doppeltem Typ und ist daher um ein Vielfaches langsamer als die Kartenserver, die int8 f√ºr die Arbeit verwenden. </li></ol><br>  Trotz der Tatsache, dass das Belegungsraster auch mit int8 funktioniert, kann es sich nicht der gleichen Benutzerfreundlichkeit r√ºhmen, so dass ich es aufgeben musste. <br><br>  Aus der Karte m√ºssen wir wissen, wo sich die freien, gef√§hrlichen und unwiderstehlichen Zonen befinden.  F√ºr jedes Objekt, das sich auf dem Feld befindet, k√∂nnen wir das Aufblasfeld anpassen - ein Wert, der abh√§ngig vom Abstand zum Objekt die Durchl√§ssigkeit der Zelle kennzeichnet.  Inflation ist der Schwanz der Katze, man merkt es leicht nicht, aber dann werden Sie es sehr lange bereuen.  Wir kartieren feindliche Roboter und f√ºgen eine Gefahrenzone hinzu, die nur der lokale Planer ber√ºcksichtigt.  Der globale Planer ignoriert alle Punkte, wenn sie kein Hindernis sind. <br><br><h4>  Globaler Planer </h4><br>  Das erste, was sie in der Navigation geschrieben haben, ist der globale Planer.  Es basiert auf dem Theta * -Algorithmus.  Kurz gesagt, dies ist ein modifiziertes <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a> , bei dem der Schwerpunkt auf dem Finden des Elternknotens liegt, der direkt erreicht werden kann, d.h.  Es gibt keine Hindernisse f√ºr sie.  Auf diese Weise k√∂nnen wir bequeme und glatte Pfade erstellen, die im lokalen Planer verwendet werden. <br><br><img src="https://habrastorage.org/webt/it/qs/e4/itqse4uuumbbzu8rxws07gapbn8.png"><br>  <i>Vergleich von A * und Theta *</i> <br><br>  F√ºr den globalen Planer haben wir eine Datei mit Parametern (params / path_planner.yaml), die Kartenthemen und Themen mit dem Standort aller Roboter beschreibt (f√ºr alle vier Roboter auf dem Feld, wobei "null" das Thema mit Daten zum aktuellen Roboter ist). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># small robot debug param list robot_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"small"</span></span></span><span class="hljs-meta"> ########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: 0.45 cost_map_server/little_robot_size: 0.45 cost_map_server/cube_size: 0.11 cost_map_server/inscribed_radius: 0.3 cost_map_server/inflation_radius: 0.3 cost_map_server/inflation_exponential_rate: 0.6 cost_map_server/big_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/big_robot"</span></span></span><span class="hljs-meta"> cost_map_server/big_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot1"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"null"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot2"</span></span></span><span class="hljs-meta"> cost_map_server/collision: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"collision"</span></span></span><span class="hljs-meta"> cost_map_server/image_resource_name: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span></span><span class="hljs-meta"> cost_map_server/min_diff_points: 0.01 ########################### ### path_planner params ### ########################### global_planner/path_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/path_force_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"obstacle_inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/frame_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"map"</span></span></span><span class="hljs-meta"> global_planner/current_position: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"real_corr"</span></span></span><span class="hljs-meta"> global_planner/path_filter_epsilon: 0</span></span></code> </pre> <br>  Es zeigt auch an: <br><br><ol><li>  einen der Algorithmen, die Sie w√§hlen k√∂nnen, um eine Route zu erstellen, </li><li>  Namen von Layern, auf denen wir die Route selbst bauen werden, </li><li>  Ein Thema √ºber unsere Position, an der gefilterte Daten ausgegeben werden (in unserem Fall ist es eine Kombination aus Positionsdaten von der Kamera und der Kilometerz√§hler). </li></ol><br>  Der Pfadsuchalgorithmus selbst - Theta Star - ist in einer separaten Datei (src / global_planner.cpp) hervorgehoben, damit Sie bequem neue Algorithmen hinzuf√ºgen k√∂nnen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cost_so_far[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>]; PriorityPoint neighbors[<span class="hljs-number"><span class="hljs-number">8</span></span>]; PriorityPoint current; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> come_from[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePath_ThetaStar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;cost_map::Index&gt; &amp;path, PriorityPoint start, PriorityPoint goal, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> layer, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> grid_cost, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> only_cost)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::priority_queue&lt;PriorityPoint, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;PriorityPoint&gt;, myCompare&gt; openSet; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_x = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_y = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::fill_n(*cost_so_far, max_x * max_y, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max()); cost_so_far[start.x][start.y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = start.x; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = start.y; openSet.push(start); grid_cost=<span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!openSet.empty()) { current = openSet.top(); openSet.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == goal) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } current.GetNeighbors(neighbors); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> current_cost = cost_so_far[current.x][current.y]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent_carent[<span class="hljs-number"><span class="hljs-number">2</span></span>] ={come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>], come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbors[i].OnMap(max_x, max_y)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> onLine = lineOfSight(parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>], parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>], neighbors[i].x, neighbors[i].y, cost_map, layer, grid_cost + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onLine) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = cost_so_far[parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]][parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]] + HeuristicEvclid(parent_carent, neighbors[i], grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority = HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> neighbor_price = cost_map.at(layer, cost_map::Index({neighbors[i].x, neighbors[i].y})) + neighbors[i].priority; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = current_cost + neighbor_price; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority =HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = current.x; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = current.y; } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (only_cost) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cost_so_far[current.x][current.y]; } path.clear(); PriorityPoint temp_point; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != start) { path.push_back({current.x, current.y}); temp_point.x = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>]; temp_point.y = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]; current = temp_point; } path.push_back({current.x, current.y}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Ein Algorithmus zum Entfernen zus√§tzlicher Punkte im RamerDouglasPeucker-Pfad ist ebenfalls einer separaten Datei zugeordnet. <br>  Punkte werden vom Pfad entfernt, wenn der Abstand zu der Linie, die zwei benachbarte Punkte verbindet, nicht mehr gegeben ist. <br><br><img src="https://habrastorage.org/webt/en/_9/dw/en_9dw6khdarxbyf7gvrhpqg7b4.jpeg"><br><br><h4>  Lokaler Planer </h4><br>  Er arbeitet f√ºr uns auf der Basis von Gef√§lle in einem potenziellen Feld.  Als Eingabe der Pfad aus dem globalen Planer.  Dies ist jedoch nicht alles, wozu er in der Lage ist.  In local_planner gibt es interne Services zur Auswahl des Pfadkonstruktionsmodus.  Insgesamt gibt es zwei Betriebsmodi: den Modus zum Verschieben von Punkten entlang des Verlaufs mithilfe mehrerer Kartenpassagen sowie den Modus zum Verschieben, bei dem das Inkrement sofort in zwei Koordinaten berechnet und der Punkt an den Rand der sicheren Zone verschoben wird.  Wenn der Punkt in mehrere solcher Zonen f√§llt, verschieben wir uns zu den Stellen, an denen er sich kreuzt, weil er dort am sichersten ist. <br><br>  Die Funktionsweise ist wie folgt: Wenn der Pfad der vorherigen Iteration kein Hindernis enth√§lt, brechen wir den Pfad alle 2 cm und verschieben ihn dann entlang des Gef√§lles. Andernfalls verwenden wir die zweite lokale Planungsbetriebsart. <br><br>  Die zweite Option ist recht leicht und belastet den Prozessor wie der globale Planer nicht sehr.  Wir haben verschiedene Versionen dieses Algorithmus und verschiedene Manipulationen mit der Karte verwendet.  Wir haben zum Beispiel versucht, ein Diagramm zu schreiben, in dem die Eckpunkte alle 10 cm gefunden und um maximal 4 cm verschoben werden. Anschlie√üend wurde der Dijkstra-Algorithmus f√ºr das erhaltene Diagramm verwendet, um den kleinsten Abstand zu ermitteln.  Der Endpunkt verwendet in diesem Fall den n√§chstgelegenen Versatzpunkt.  Ein solcher Algorithmus war jedoch besser f√ºr globale Planer geeignet, und wir entschieden uns, diese Implementierung aufzugeben. <br><br>  Wir haben auch versucht, die Pfadbildung von Grund auf mit der Gradientenabstiegsmethode durchzuf√ºhren.  Diese Methode war die erste, f√ºr die wir uns entschieden haben zu schreiben.  Es stellte sich heraus, dass es nicht speichereffizient (es belegte mehr als 400 MB reinen RAM, da es bei jedem Durchlauf eine Kostenkarte verwendete) und langsam war.  Die Frequenzregelung wurde aufgrund einer schlechten Optimierung deaktiviert und die Geschwindigkeit betrug weniger als 30 Mal pro Sekunde, was uns nicht zusagte. <br><br>  Aus diesem Grund haben wir uns entschlossen, den Gradientenabstieg in einem potenziellen Feld zu verwenden, das auf dem Pfad des globalen Planers basiert.  Es stellte sich heraus, dass es sich um einen leichten und relativ einfachen Algorithmus handelt, der hinsichtlich Pfadqualit√§t, Arbeitszeit und RAM-Verbrauch in der Gr√∂√üenordnung von 100-150 MB vollkommen zu uns passt. Dies ist ein Vielfaches weniger als in den ersten Entwicklungsiterationen. <br><br><img src="https://habrastorage.org/webt/sg/oq/mo/sgoqmogivjs8elhylt74oqjqrdw.png"><br>  <i>Ein Beispiel f√ºr einen durch einen lokalen Planer versetzten Pfad</i> <br><br>  Im Gegensatz zu global_planner sind die Parameter in local_planner extrem klein, was auf die Einfachheit zur√ºckzuf√ºhren ist, da alle wichtigen Aufgaben bei global_planner liegen: <br><br><pre> <code class="cpp hljs">grid_map_server/big_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/big_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> local_planner/radius : <span class="hljs-number"><span class="hljs-number">0.15</span></span> global_planner/frame_id : <span class="hljs-string"><span class="hljs-string">"map"</span></span></code> </pre> <br>  In diesem Fall konfigurieren wir: <br><br><ul><li>  Radien der Sicherheitszonen f√ºr jeden Roboter. </li><li>  Maximaler Pfadversatz durch lokalen Planer. </li><li>  Der Name der Kartenebene, mit der wir arbeiten. </li></ul><br>  In einer eigenen Klasse wurden alle wichtigen Funktionen vergeben.  In diesem Fall handelt es sich um eine rekursive Aufteilung des Pfades, die Erstellung eines Segelflugzeugs sowie virtueller Konstruktoren und Destruktoren. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Planner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Planner(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> inflation_radius_, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> frame_id_) { inflation_radius = inflation_radius_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">200</span></span>; j++) our_map[i][j] = <span class="hljs-number"><span class="hljs-number">3000.0</span></span>; } OurPath-&gt;poses.resize(<span class="hljs-number"><span class="hljs-number">50</span></span>); geometry_msgs::Pose pose; pose.position.x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; pose.position.y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>; i++) { OurPath-&gt;poses[i].pose = pose; } frame_id = frame_id_; } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Planner() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; ros::Publisher move_pub; ros::Publisher BigEnemyPub; ros::Publisher LittleEnemyPub; ros::Publisher local_path_publisher; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-comment"><span class="hljs-comment">// virtual double Calculate_Path_Len(); nav_msgs::Path* recursive_path(nav_msgs::Path *path, std::pair&lt;double, double&gt; start, std::pair&lt;double, double&gt; end, double epsilon, int &amp;index) { if (CalcDistance(start, end) &lt; (epsilon) || path-&gt;poses.size() &gt; 200) return path; double start_x = (start.first + end.first) / 2.0; double start_y = (start.second + end.second) / 2.0; index = find_out(path, start); geometry_msgs::PoseStamped pose; pose.pose.position.x = start_x; pose.pose.position.y = start_y; path-&gt;poses.insert(path-&gt;poses.begin() + index, pose); recursive_path(path, start, std::pair&lt;double, double&gt;{start_x, start_y}, epsilon, index); recursive_path(path, std::pair&lt;double, double&gt;{start_x, start_y}, end, epsilon, index); } int find_out(nav_msgs::Path *path, pair_double point) { int index = 0; for (int i = 0; i &lt; path-&gt;poses.size(); i++) if (path-&gt;poses[i].pose.position.x == point.first &amp;&amp; path-&gt;poses[i].pose.position.y == point.second) return ++i; return index; } void add_in_path(nav_msgs::Path* Path, geometry_msgs::PoseStamped pose, int&amp; Index) { Path-&gt;poses[Index % max_size] = pose; Index++; } double inflation_radius; double our_map[300][200]; int max_size = 49; std::string frame_id; nav_msgs::Path *path = new nav_msgs::Path; nav_msgs::Path *OurPath = new nav_msgs::Path; };</span></span></code> </pre> <br>  Die LocalPlanning-Klasse wurde von ihr geerbt, in der sich der gesamte Kern des Segelflugzeugs befindet, dh Punkte an den Rand der sicheren Zone verschoben werden und entschieden wird, was mit dem Pfad speziell zu tun ist. <br><br>  Alle anderen Funktionen werden in einer separaten Datei fichi.hpp hervorgehoben und der Gradientenabstieg in potential_field.hpp.  Unten finden Sie eine Momentaufnahme aus dieser Datei, in der die Funktionen zum Erstellen eines potenziellen Felds auf der cost_map-Karte aufgef√ºhrt sind: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcAttractivePotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(grid_map::Index index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">0</span></span>] - goalx, <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">1</span></span>] - goaly, <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcPotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> starty, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp;our_map)[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">300</span></span></span></span><span class="hljs-function"><span class="hljs-params">][</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">200</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Use some magic for normalisation of Field double max_distance = (CalcAttractivePotential(grid_map::Index(startx, starty), goalx, goaly) + 15); if (max_distance == 0.0) { max_distance = 0.01; } for (cost_map::CircleIterator iterator(cost_map, grid_map::Position(startx / 100.0, starty / 100.0), max_distance / 100.); !iterator.isPastEnd(); ++iterator) { try { grid_map::Index index(*iterator); double uf; uf = cost_map.at("obstacle_inflation_layer", *iterator); // if we on free podouble - field is more less then if it not free podouble if ( uf &gt;= 10) { uf = 3000.0; // CP - is const variable } else uf += CalcAttractivePotential(index, goalx, goaly)/max_distance * 256; our_map[299-index(0)][199-index(1)] = uf; } catch(std::exception&amp; e) { ROS_INFO("Exception! %s", e.what() ); } } }</span></span></code> </pre> <br><h4>  Flugbahnregler </h4><br>  Last but not least ist der Flugbahnregler.  Er ist daf√ºr verantwortlich, den lokalen Planerpfad in einen Pfad umzuwandeln und gibt die Geschwindigkeit f√ºr den aktuellen Schritt an. <br><br>  Die erste Version, die wir beim Eurobot-Finale 2018 verwendet haben, ist eine Mischung aus Beschleunigungs- und Brems-PID-Regler, bei der der Vektor relativ zum Abstand zum Endpunkt auf den n√§chsten Wegspunkt normiert wird. <br><br>  Kurz gesagt, der PID-Regler ist die Summe der drei Systemzust√§nde, mit deren Hilfe manchmal auftretende System- und Zufallsfehler behoben werden k√∂nnen. <br><br>  Diese Funktionen wurden empirisch ausgew√§hlt und h√§ngen vom Abstand zum Endpunkt im Pfad ab (er kann quadratisch, kubisch oder invers sein, aber dann haben wir uns f√ºr das Quadrat entschieden).  Dies funktionierte, aber das einzige, was uns nicht zusagte, war, dass der Roboter bei Geschwindigkeiten √ºber 0,7 Metern pro Sekunde nicht rechtzeitig bremsen konnte.  Daher haben wir uns zu gegebener Zeit entschlossen, den gesamten Algorithmus neu zu erstellen. <br><br>  Die erste Iteration auf dem Weg zur neuen Flugbahn war das Ersetzen des Vektors, zu dem wir wollten.  Nun war es die Summe der Vektoren f√ºr die n√§chsten drei mit unterschiedlichen Koeffizienten.  Die zweite Iteration schrieb Minimum Jerk.  Kurz gesagt, dies ist eine Konstruktion eines Polynoms 5. Grades, wobei die x- und y-Koordinaten von der Ankunftszeit zu jedem Punkt abh√§ngen. <br><br><img src="https://habrastorage.org/webt/ho/mw/hd/homwhdagbnkgdlrigettcc6yook.png"><br>  <i>Die Abbildung zeigt eine grafische Darstellung einer der Koordinaten √ºber der Zeit sowie der Geschwindigkeit entlang dieser Koordinate</i> <br><br>  Diese Art der Flugbahnregelung hat sich f√ºr uns bew√§hrt, da bei der Auswahl verschiedener Koeffizienten weniger Manipulationen erforderlich sind, da alle Koeffizienten die Werte im Polynom sind, die auf der Grundlage von Ankunftszeit, aktueller Geschwindigkeit und Beschleunigung, Ausgangsgeschwindigkeit und Beschleunigung berechnet wurden. <br><br>  Das Ergebnis der Umschreibung der Flugbahn war, dass es uns gelungen ist, die Durchschnittsgeschwindigkeit des Roboters zu verdoppeln. <br><br>  Wie in den beiden vorherigen F√§llen sind alle Hauptfunktionen zur einfachen Interaktion in einer separaten Datei hervorgehoben.  Dieses Mal ist die PlannerTrajectory-Klasse f√ºr die Erstellung einer Trajektorie basierend auf MinimumJerk verantwortlich <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> velocity; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> acceleration; State(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v_, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a_) : velocity(v_), acceleration(a_) {} State() { velocity = <span class="hljs-number"><span class="hljs-number">0</span></span>; acceleration = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlannerTrajectory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: nav_msgs::Path global_path; cost_map::CostMap *costmap_ptr; geometry_msgs::PoseStamped Goal_pred; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_x; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_y; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> average_velocity = <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Defualt or get from param // double max_velocity = 100; double coef_x[6]; double coef_y[6]; int frequency = 30; // Defualt or get from param // int index; public: PlannerTrajectory(cost_map::CostMap *costmap_, const int &amp;frequency_, const double &amp;max_velocity_, const double &amp;average_velocity_) { average_velocity = average_velocity;; max_velocity = max_velocity_; costmap_ptr = costmap_; frequency = frequency_; Goal_pred.pose.position.x = 0.0; Goal_pred.pose.position.y = 0.0; }</span></span></code> </pre> <br>  <i>Das Foto zeigt alle deklarierten Variablen, die wir verwenden.</i> <br><br>  Alles andere ist in einer anderen Datei hervorgehoben (include / trajectory_regulator.h): Punkte von Themen erhalten, entscheiden, ob zum n√§chsten Punkt gegangen werden soll (wenn es sich in einem Hindernis befindet, werden wir nicht gehen) und vieles mehr. <br><br><h3>  Migration zu ROS Melodic </h3><br>  Bis letztes Jahr haben wir die lte-Version von ROS-ROS Kinetic verwendet.  Er passte uns im Allgemeinen, aber seine Unterst√ºtzung l√§uft im n√§chsten Jahr aus und viele der Pakete, die wir brauchen, wurden exklusiv f√ºr ROS Melodic herausgebracht.  Und dann stellte sich heraus, dass der von uns verwendete costmap_server nicht unter Melodic steht. <br><br>  Bei der Verarbeitung der Daten von den Karten ist ein Problem aufgetreten. <br><br>  Wir haben die Grid-Karte gew√§hlt, da der Stapel √§hnlich ist, sich der Anfang der Karte jedoch an einer anderen Stelle befindet und die Werte der Karte selbst von 0 bis 1 variieren. Dies ist ein gro√ües Problem im gesamten Navigationsstapel geworden.  Wenn der globale Planer fr√ºher 50-mal pro Sekunde gestartet wurde (es gab Frequenzbeschr√§nkungen, und daher wurde der Prozessor auch in der H√§lfte eines Threads nicht zu h√§ufig verwendet), ebnete er jetzt alle zwei Sekunden den Weg und hielt ihn f√ºr schlecht: Er lud einen Kern vollst√§ndig.  In 2 Sekunden konnte der Roboter die gesamte Karte √ºberqueren.  Dies passte nicht zu uns und Versuche, diesen Prozess zu parallelisieren, scheiterten, weil dann keine Leistung mehr f√ºr andere Projekte √ºbrig war (unter Ber√ºcksichtigung der Kosten f√ºr die Parallelisierung). <br><br>  Wir haben uns entschlossen, den Stack erneut zu √§ndern und die Grid Map zugunsten des Occupancy Grids aufzugeben.  Es ist ein neues Problem aufgetreten - die Unf√§higkeit, mehrere Versionen von Karten gleichzeitig zu speichern (z. B. eine vollst√§ndige Karte mit allen Hindernissen und eine statische Karte mit nur dynamischen Hindernissen).  Ich m√ºsste die H√§lfte des Codes √§ndern, was nicht besonders zuverl√§ssig war.  Daher haben wir uns entschlossen, nach alternativen L√∂sungen f√ºr dieses Problem zu suchen. <br><br><h4>  Cost Map Server </h4><br>  Nach langer Suche fanden wir die Fork Maps costmap_serverr: <a href="" rel="nofollow">https://github.com/lelongg/cost_map.git</a> - sehr n√ºtzlich f√ºr unser Fork System. <br><br><img src="https://habrastorage.org/webt/27/rb/oh/27rbohj3kefxprwtjqrg4mwtqjc.png"><br><br>  Und anstatt nur die Gitterkarte zu warten, schaffen wir es jetzt, den wahrscheinlichen Ort des Feindes basierend auf der Vorhersage des Kalman-Filters f√ºr die Lieferung zu berechnen. <br><br><img src="https://habrastorage.org/webt/ni/pm/nz/nipmnzvhcrqdje1cu8glf9quude.png"><br><br>  Eines der wichtigsten Dinge f√ºr einen Kartenserver ist eine Kartendatei, die zum erstmaligen Erstellen aller Layer verwendet wird, die anschlie√üend nur aktualisiert werden.  Es ist ein bin√§res PNG-Bild, in dem Schwarz ein Hindernis und Wei√ü eine freie Zone ist. <br><br><img src="https://habrastorage.org/webt/2b/l5/rg/2bl5rgpuecb7he51heslqpvcazm.png"><br><br>  Es gibt auch eine Einstellungsdatei f√ºr die Konfiguration von cost_map_server.  Es enth√§lt Themen mit Feindpunkten, eine Inflationszone und die Gr√∂√üe des Quadrats, mit denen Sie auch die Gefahrenzone des Feindes auf die Karte setzen k√∂nnen. <br><br><pre> <code class="cpp hljs">########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/little_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/cube_size: <span class="hljs-number"><span class="hljs-number">0.11</span></span> cost_map_server/inscribed_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_exponential_rate: <span class="hljs-number"><span class="hljs-number">0.6</span></span> cost_map_server/big_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot1"</span></span> cost_map_server/big_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot2"</span></span> cost_map_server/small_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot3"</span></span> cost_map_server/small_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot4"</span></span> cost_map_server/collision: <span class="hljs-string"><span class="hljs-string">"collision"</span></span> cost_map_server/image_resource_name: <span class="hljs-string"><span class="hljs-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span> cost_map_server/min_diff_points: <span class="hljs-number"><span class="hljs-number">0.01</span></span></code> </pre> <br>  Alle Ebenen werden nur ver√∂ffentlicht, wenn jemand sie abonniert hat: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublishChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ nav_msgs::OccupancyGrid msg; cost_map_msgs::CostMap cost_map_msg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle_inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"obstacle_layer"</span></span>, msg); obstacle_inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"inflation_layer"</span></span>, msg); inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cost_map_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toMessage(costmap, cost_map_msg); cost_map_publisher.publish(cost_map_msg); } }</code> </pre> <br><h3>  F√ºhren Sie auf Ihrem Computer </h3><br>  Um den gesamten Stapel zu starten, m√ºssen Sie: <br><br><ul><li>  Setzen Sie ROS </li><li>  roslaunch cost_map_server cost_map_server_alone.launch - um die Karte zu starten </li><li>  roslaunch global_planner global_planner.launch - Global Planer mit Parametern starten </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosparam load $ (find local_planner) /param/param.yaml </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun local_planner local_planning </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun trajectory_regulator trajectory_regulator </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun global_planner mover </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rosrun Rviz </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºge inflation_layer hinzu </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Senden Sie nun eine Nachricht an das Topic / gp / goal und wir senden den Roboter an den gew√ºnschten Punkt </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem Sie alle Elemente gestartet haben, steht Ihnen eine Simulation zur Verf√ºgung, mit der Sie unseren Stapel auf Ihrem Computer starten k√∂nnen. </font></font><a href="https://github.com/lelongg/cost_map" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notwendige Gabel</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iRY5WHgAFns" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     ,     ,       .          ,   ‚Äî .          ,   eurobot,    . <br><br>     ,  , ‚Ä¶ <br><br>  : t.me/SetUpSber <br> <a href="https://github.com/ristle/EUrobotNavigation" rel="nofollow">    </a> <br><br><img src="https://habrastorage.org/webt/98/gl/4m/98gl4mdibk20qgavmhzkbdppu4w.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479636/">https://habr.com/ru/post/de479636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479620/index.html">Umgekehrte Logik</a></li>
<li><a href="../de479622/index.html">So funktioniert der Prototyp anonymer Transaktionen in der Waves-Blockchain</a></li>
<li><a href="../de479624/index.html">Postgres-Profi-Gendar Oleg Bartunov informiert Faride Roslovets √ºber PostgreSQL und das Gesch√§ft in Russland</a></li>
<li><a href="../de479626/index.html">Resonator mit einer Wendung, die Physiker nicht kennen</a></li>
<li><a href="../de479630/index.html">K√§mpfe um Aufmerksamkeit</a></li>
<li><a href="../de479642/index.html">Wie dumme Entscheidungen beim Entwerfen eines Flugzeugs aus dem Zweiten Weltkrieg zur Schaffung des Macintosh f√ºhrten</a></li>
<li><a href="../de479644/index.html">Einfache Worte zu Programmatic</a></li>
<li><a href="../de479646/index.html">Schlechte Ratschl√§ge oder Gr√ºnde, um nach der Mittelstufe weiter Englisch zu lernen</a></li>
<li><a href="../de479650/index.html">Top 12 der interessantesten dynamischen IT-Infografiken</a></li>
<li><a href="../de479654/index.html">Django Vue Generator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>