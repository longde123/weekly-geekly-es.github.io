<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏻 📱 👷 JavaScript指南第4部分：功能 🐎 🤚 🏰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，我们将发布JavaScript手册翻译的第四部分，该手册专门介绍函数。 

 → 第1部分：第一个程序，语言功能，标准 
 → 第2部分：代码样式和程序结构 
 → 第3部分：变量，数据类型，表达式，对象 
 → 第4部分：功能 
 → 第5部分：数组和循环 
 → 第6部分：异常，分号，通配...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript指南第4部分：功能</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/430382/"> 今天，我们将发布JavaScript手册翻译的第四部分，该手册专门介绍函数。 <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分：第一个程序，语言功能，标准</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分：代码样式和程序结构</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分：变量，数据类型，表达式，对象</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4部分：功能</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5部分：数组和循环</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6部分：异常，分号，通配符文字</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7部分：严格模式，此关键字，事件，模块，数学计算</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8部分：ES6功能概述</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9部分：ES7，ES8和ES9标准概述</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><br><h2>  <font color="#3AC1EF">JavaScript函数</font> </h2><br> 让我们讨论一下JavaScript中的函数，对其进行一般性的回顾，并考虑有关它们的细节，这些知识将使您有效地使用它们。 <br><a name="habracut"></a><br> 函数是一个独立的代码块，一旦声明，就可以根据需要多次调用。 一个函数可以（尽管不是必需的）接受参数。 函数返回单个值。 <br><br>  JavaScript中的函数是对象，或者更确切地说，它们是<code>Function</code>类型的对象。 它们与普通对象的主要区别在于，它们可以调用函数，从而赋予它们所拥有的卓越功能。 <br><br> 另外，JavaScript中的函数称为“一流函数”，因为它们可以分配给变量，可以作为参数传递给其他函数，也可以从其他函数返回。 <br><br> 首先，我们考虑使用功能的特征以及对应于ES6标准之前的语言中仍然存在的语法结构。 <br><br> 这就是函数声明的样子。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br> 如今，这些功能被称为“正常”功能，与ES6中出现的“箭头”功能有所区别。 <br><br> 您可以将函数分配给变量或常量。 这种构造称为函数表达式。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br> 您可能会注意到，在上面的示例中，该函数被分配给一个常量，但是它本身没有名称。 这种功能称为匿名。 可以为类似的功能分配名称。 在这种情况下，我们谈论的是命名函数表达式（named function expression）。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br> 使用此类表达式可提高调试的便利性（在执行堆栈跟踪的错误消息中，该函数的名称可见）。 在函数表达式中也可能需要函数的名称，以便函数可以调用自身，这对于实现递归算法是必不可少的。 <br><br> 在ES6标准中，出现了箭头函数，这些箭头函数特别方便以所谓的“内联函数”的形式使用-作为传递给其他函数（回调）的参数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br> 箭头函数除了用于声明它们的结构之外，还比使用普通函数更为紧凑，但它们在某些重要功能上与它们不同，我们将在下面进行讨论。 <br><br><h2>  <font color="#3AC1EF">功能参数</font> </h2><br> 参数是在函数声明阶段设置的变量，将包含传递给它的值（这些值称为自变量）。  JavaScript中的函数可能没有参数，也可能有一个或多个参数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } const doSomethingElse = foo =&gt; { // - } const doSomethingElseAgain = (foo, bar) =&gt; { // - }</span></span></code> </pre> <br> 这是箭头功能的一些示例。 <br><br> 从ES6标准开始，函数可以具有所谓的“默认参数”。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br> 如果表示未设置某些参数的值，则它们代表由函数的参数设置的标准值。 例如，可以通过将其接收的所有两个参数传递给该函数以及通过其他方法来调用上述函数。 <br><br><pre> <code class="javascript hljs">doSomething(<span class="hljs-number"><span class="hljs-number">3</span></span>) doSomething()</code> </pre> <br> 在ES8中，可以在函数的最后一个参数之后加上逗号（这称为尾随逗号）。 使用此功能，可以在程序开发过程中使用版本控制系统时增加编辑代码的便利性。 关于此的详细信息可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 <br><br> 传递给函数的参数可以表示为数组。 为了解析这些参数，可以使用看起来像三个点的运算符（这就是所谓的“扩展运算符”或“扩展运算符”）。 这是它的外观。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } const args = [2, 'ho!'] doSomething(...args)</span></span></code> </pre> <br> 如果函数需要采用许多参数，则记住其顺序的顺序可能会很困难。 在这种情况下，将使用具有参数和解构ES6对象机会的对象。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - console.log(foo) // 2 console.log(bar) // 'ho!' } const args = { foo: 2, bar: 'ho!' } doSomething(args)</span></span></code> </pre> <br> 该技术允许以对象属性的形式描述参数并将函数传递给对象，从而无需使用其他构造即可使函数按其名称访问参数。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关此技术的更多信息。 <br><br><h2>  <font color="#3AC1EF">从函数返回的值</font> </h2><br> 所有函数均返回特定值。 如果未明确指定return命令，则该函数将返回<code>undefined</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } console.log(doSomething())</span></span></code> </pre> <br> 函数执行在它包含的所有代码执行完之后，或者在代码中遇到<code>return</code>关键字之后结束。 当在函数中遇到此关键字时，其操作将完成，控制权将转移到调用该函数的位置。 <br><br> 如果在<code>return</code>关键字之后指定了某个值，则此值将作为此函数的结果返回到函数调用的位置。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = doSomething() <span class="hljs-comment"><span class="hljs-comment">// result === 'test'</span></span></code> </pre> <br> 一个函数只能返回一个值。 为了能够返回多个值，您可以使用对象常量或作为数组将它们作为对象返回，并且在调用函数时，请使用破坏性赋值构造。 参数名称已保存。 同时，如果需要使用从函数返回的对象或数组，即对象或数组的形式，则可以进行无损分配。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'Roger'</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [ name, age ] = doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, age) <span class="hljs-comment"><span class="hljs-comment">//Roger 6</span></span></code> </pre> <br> 构造<code>const [ name, age ] = doSomething()</code>可以如下读取：“声明<code>name</code>和<code>age</code>常量，并为其指定函数将返回的数组元素的值。” <br> 这是使用对象的相同外观。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Roger'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, age } = doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, age) <span class="hljs-comment"><span class="hljs-comment">//Roger 6</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">嵌套函数</font> </h2><br> 可以在其他函数内部声明函数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingElse = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {} doSomethingElse() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } doSomething()</code> </pre> <br> 嵌套函数的范围受其外部函数的限制；不能从外部调用它。 <br><br><h2>  <font color="#3AC1EF">对象方法</font> </h2><br> 当函数用作对象的属性时，此类函数称为对象方法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Started`</span></span>) } } car.start()</code> </pre> <br><h2>  <font color="#3AC1EF">这个关键词</font> </h2><br> 如果比较箭头和用作对象方法的普通函数，我们会发现它们的重要区别，这就是关键字<code>this</code>的含义。 考虑一个例子。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Started </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.brand}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.model}</span></span></span><span class="hljs-string">`</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Stopped </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.brand}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.model}</span></span></span><span class="hljs-string">`</span></span>) } } car.start() <span class="hljs-comment"><span class="hljs-comment">//Started Ford Fiesta car.stop() //Stopped undefined undefined</span></span></code> </pre> <br> 如您所见，调用<code>start()</code>方法会得到预期的结果，但是<code>stop()</code>方法显然不能正常工作。 <br><br> 这是由于以下事实：this关键字在箭头功能和普通功能中使用时的行为有所不同。 即，箭头函数中的<code>this</code>包含指向包含该函数的上下文的链接。 在这种情况下，当涉及到浏览器时，该上下文就是<code>window</code>对象。 <br><br> 这是在浏览器控制台中执行此类代码的方式。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">arrFn</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } } test.fn() test.arrFn()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b3/7c4/c29/4b37c4c299f7f21c40c77c372d34974f.png"></div><br>  <i><font color="#999999">常规和箭头功能中的此关键字功能</font></i> <br><br> 如您所见，在常规函数中调用它意味着调用对象，而在箭头函数中此指向<code>window</code> 。 <br><br> 所有这些都意味着arrow函数不适合对象和构造方法的角色（如果尝试将arrow函数用作构造函数，则会<code>TypeError</code> ）。 <br><br><h2>  <font color="#3AC1EF">立即调用函数表达式</font> </h2><br> 立即调用函数表达式（IIFE）是在声明后立即自动调用的函数。 <br><br><pre> <code class="javascript hljs">;(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'executed'</span></span>) })()</code> </pre> <br>  IIFE之前的分号是可选的，但是使用它可以确保避免与分号的自动放置相关的错误。 <br><br> 在上面的示例中， <code>executed</code>的单词将进入控制台，此后IIFE将退出。 与其他功能一样，IIFE可以返回其工作结果。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'IIFE'</span></span> })() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(something)</code> </pre> <br> 执行完此简单示例后，控制台将获得<code>IIFE</code>行，该行在执行立即调用的函数表达式后变成了<code>something</code> 。 这种设计似乎没有特别的好处。 但是，如果在IIFE中执行了一些仅需执行一次的复杂计算，那么之后就不需要了相应的机制-IIFE的用途显而易见。 即，使用这种方法，在执行IIFE之后，程序中将仅提供函数返回的结果。 此外，我们可能还记得函数可以返回其他函数和对象。 我们正在谈论闭包，我们将在下面讨论它们。 <br><br><h2>  <font color="#3AC1EF">功能升级</font> </h2><br> 在执行JavaScript代码之前，必须对其进行重新组织。 我们已经讨论了使用<code>var</code>关键字声明的变量的提升机制。 类似的机制也可用于功能。 即，我们正在谈论这样一个事实，即在执行代码之前处理代码的过程中将函数声明移到其作用域的上部。 结果，例如，事实证明您可以在声明函数之前调用它。 <br><br><pre> <code class="javascript hljs">doSomething() <span class="hljs-comment"><span class="hljs-comment">//did something function doSomething() { console.log('did something') }</span></span></code> </pre> <br> 如果移动函数调用使其在声明后进行，则不会发生任何变化。 <br><br> 如果在类似情况下使用函数表达式，则类似代码将引发错误。 <br><br><pre> <code class="javascript hljs">doSomething() <span class="hljs-comment"><span class="hljs-comment">//TypeError var doSomething = function () { console.log('did something') }</span></span></code> </pre> <br> 在这种情况下，事实证明，尽管<code>doSomething</code>变量的声明上升到作用域的顶部，但这不适用于赋值操作。 <br> 如果在类似情况下使用<code>let</code>或<code>const</code>关键字代替<code>var</code> ，则此代码也将不起作用，但是，系统将显示不同的错误消息（ <code>ReferenceError</code>而不是<code>TypeError</code> ），因为使用<code>let</code>和<code>const</code>时不会引发变量和常量声明。 <br><br><h2>  <font color="#3AC1EF">箭头功能</font> </h2><br> 现在，我们将更多地讨论已经遇到的箭头功能。 它们可以被视为ES6标准最重要的创新之一，它们不仅在外观上而且在行为上均与普通功能不同。 如今，它们的使用极为广泛。 也许没有一个现代项目可以在绝大多数情况下不使用它们。 可以说，它们的外观永远改变了JS代码的外观及其工作特性。 <br><br> 从纯粹的外部角度来看，声明箭头函数的语法比普通函数的语法更紧凑。 这是一个常规函数的声明。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br> 这是箭头功能的公告，通常，如果您不考虑箭头功能的特性，则与前一个功能类似。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br> 如果箭头函数的主体仅包含一个命令，该函数的结果将返回，则可以将其写成大括号且没有<code>return</code>关键字。 例如，这样的函数返回传递给它的参数的总和。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//3</span></span></code> </pre> <br> 如您所见，箭头函数的参数（与普通函数一样）在括号中描述。 而且，如果这样的函数仅使用一个参数，则可以在不带括号的情况下指定它。 例如，这是一个函数，该函数返回将传递给它的数字除以2的结果。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">8</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//4</span></span></code> </pre> <br> 结果，事实证明，在需要小的功能的情况下，使用箭头功能非常方便。 <br><br><h3>  <font color="#3AC1EF">▍隐式返回函数结果</font> </h3><br> 我们已经谈到了箭头功能的这一功能，但它非常重要，因此应进行更详细的讨论。 我们正在谈论一个事实，即单行箭头函数支持其工作结果的隐式返回。 我们已经看到了从单行箭头函数返回原始值的示例。 如果这样的函数应该返回一个对象怎么办？ 在这种情况下，对象文字的花括号可能会使系统感到困惑，因此在函数的主体中使用了括号。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'test'</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = myFunction() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.value) <span class="hljs-comment"><span class="hljs-comment">//test</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">this关键字this和箭头功能</font> </h3><br> 上面，当我们查看<code>this</code>的功能时，我们比较了常规函数和箭头函数。 本节旨在提请您注意它们之间差异的重要性。  <code>this</code>本身可能会导致某些困难，因为它取决于代码执行的上下文以及是否启用严格模式。 <br><br> 如我们所见，当在由常规函数表示的对象的方法中使用<code>this</code>时， <code>this</code>指向该方法所属的对象。 在这种情况下，我们讨论将关键字<code>this</code>绑定到表示函数上下文的值。 特别是，如果将函数称为对象方法，则this关键字将绑定到该对象。 <br><br> 对于箭头函数，事实证明未在其中执行<code>this</code>绑定；它们从其作用域中使用<code>this</code> 。 因此，不建议将它们用作对象方法。 <br><br> 将函数用作DOM元素的事件处理程序时，会发生相同的问题。 例如，HTML元素<code>button</code>用于描述按钮。 用户单击按钮时将<code>click</code>事件。 为了在代码中响应此事件，您必须首先获得指向相应元素的链接，然后为它分配一个<code>click</code>事件处理函数作为函数。 作为此类处理程序，您可以同时使用常规函数和箭头函数。 但是，如果在事件处理程序中需要访问被调用的元素（即<code>this</code> ），则arrow函数在这里将不起作用，因为其中可用的<code>this</code>值指向<code>window</code>对象。 为了在实践中进行测试，请创建一个HTML页面，其代码如下所示，然后单击按钮。 <br><br><pre> <code class="javascript hljs">&lt;!DOCTYPE html&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"fn"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Function</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"arrowFn"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Arrow function</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="javascript"><span class="xml"><span class="javascript">     </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">const</span></span></span></span><span class="xml"><span class="javascript"> f = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.getElementById(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">"fn"</span></span></span></span><span class="xml"><span class="javascript">)     f.addEventListener(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'click'</span></span></span></span><span class="xml"><span class="javascript">, </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></span><span class="xml"><span class="javascript"><span class="hljs-function"> (</span></span></span><span class="hljs-params"></span><span class="xml"><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span></span><span class="xml"><span class="javascript">{         alert(</span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span><span class="xml"><span class="javascript"> === f)     })     </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">const</span></span></span></span><span class="xml"><span class="javascript"> af = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.getElementById(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">"arrowFn"</span></span></span></span><span class="xml"><span class="javascript">)     af.addEventListener(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'click'</span></span></span></span><span class="xml"><span class="javascript">, () =&gt; {         alert(</span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span><span class="xml"><span class="javascript"> === </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">window</span></span></span></span><span class="xml"><span class="javascript">)     })   </span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br> 在这种情况下，当您单击这些按钮时，将出现包含<code>true</code>窗口。 但是，在具有标识符<code>fn</code>的按钮的<code>click</code>事件处理程序中，将检查此按钮与按钮的相等性，在具有标识符<code>arrowFn</code>的按钮中，将检查该标识符与<code>window</code>对象的相等性。 <br><br> 结果，如果需要在HTML元素的事件处理程序中调用<code>this</code>函数，则箭头函数将不适用于此类处理程序的设计。 <br><br><h2>  <font color="#3AC1EF">短路</font> </h2><br> 闭包是JavaScript中的重要概念。 实际上，如果您编写了JS函数，那么您还使用了闭包。 在某些设计模式中使用闭包-如果您需要组织对某些数据或功能的访问的严格控制。 <br><br> 调用函数时，它可以访问其外部范围内的所有内容。 但是无法访问函数内部声明的内容。 也就是说，如果在一个函数中声明了一个变量（或另一个函数），则在执行该函数期间或完成其工作之后，外部代码将无法访问它们。 但是，如果从该函数返回了另一个函数，则此新函数将有权访问原始函数中声明的所有内容。 在这种情况下，所有这些都将在闭包的外部代码中隐藏。 <br><br> 考虑一个例子。 这是一个采用狗名的函数，然后将其显示在控制台中。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> ;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say))() } bark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Roger barked!</span></span></code> </pre> <br> 该函数返回的值对我们不感兴趣，该文本使用IIFE在控制台中显示，在这种情况下，该文本没有特殊作用，但是，这将帮助我们查看此函数及其变体之间的联系，而不是调用显示该函数的函数。文本到控制台，我们将从重写的函数<code>bark()</code>返回此函数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prepareBark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) bark() <span class="hljs-comment"><span class="hljs-comment">// Roger barked!</span></span></code> </pre> <br> 在两种情况下，代码的结果是相同的。 但是在第二种情况下，被调用时转移到原始函数的内容（狗的名字， <code>Roger</code> ）存储在闭包中，之后由原始函数返回的另一个函数使用。 <br><br> 让我们进行另一个实验-使用原始功能为不同的狗创建两个新的。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prepareBark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rogerBark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sydBark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Syd`</span></span>) rogerBark() sydBark()</code> </pre> <br> 此代码将输出以下内容。 <br><br><pre> <code class="javascript hljs">Roger barked! Syd barked!</code> </pre> <br> 事实证明， <code>say</code>常量的值与从<code>prepareBark()</code>函数返回的函数有关。 <br><br> 请注意， <code>say</code> ，当您再次调用<code>prepareBark()</code>时，它将获得一个新值，而<code>say</code>第一次<code>prepareBark()</code>时记录的值不会改变。 关键是每次调用此函数都会创建一个新的闭包。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 今天，我们讨论了普通和箭头函数，它们的声明和使用功能， <code>this</code>关键字在不同情况下的行为以及闭包。 下次我们讨论数组和循环。 <br><br>  <b>亲爱的读者们！</b> 您如何看待JavaScript中的箭头功能？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430382/">https://habr.com/ru/post/zh-CN430382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430372/index.html">氢气车。 是时候跟汽油说再见了吗？</a></li>
<li><a href="../zh-CN430374/index.html">数据工程及其他：毁录会议录像带和幻灯片</a></li>
<li><a href="../zh-CN430376/index.html">JavaScript指南第6部分：异常，分号，模板文字</a></li>
<li><a href="../zh-CN430378/index.html">J2CL-迟到总比不到好</a></li>
<li><a href="../zh-CN430380/index.html">JavaScript指南第5部分：数组和循环</a></li>
<li><a href="../zh-CN430384/index.html">根据噪声特征创建地图</a></li>
<li><a href="../zh-CN430386/index.html">印度将建设固态存储电站</a></li>
<li><a href="../zh-CN430388/index.html">网络峰会非会议</a></li>
<li><a href="../zh-CN430392/index.html">如何使用PieceofScript“ bike”开发和测试API</a></li>
<li><a href="../zh-CN430394/index.html">使用RxJava在Android中实现即时搜索</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>