<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍💻 👨‍✈️ ✋🏿 Analisando mercados de criptomoedas com Python 🤞🏻 🎅🏾 ⚠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como os mercados de Bitcoin se comportam? Quais são as razões do aumento e queda repentinos dos preços das criptomoedas? Existe uma conexão estreita e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisando mercados de criptomoedas com Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wirex/blog/406363/">  <i>Como os mercados de Bitcoin se comportam?</i>  <i>Quais são as razões do aumento e queda repentinos dos preços das criptomoedas?</i>  <i>Existe uma conexão estreita e inseparável entre os mercados de altcoin ou eles são praticamente independentes um do outro?</i>  <i>Como podemos prever o que acontecerá no futuro?</i> <br><br><img src="https://habrastorage.org/web/74a/6d8/70f/74a6d870fa77478e950c47b297fe13c8.jpg" alt="imagem"><br><br><h3>  Abordagem analítica da informação para o raciocínio de criptomoeda </h3><br>  Artigos dedicados a criptomoedas como Bitcoin e Ethereum abundam em raciocínio e teorias.  Centenas de especialistas autoproclamados defendem tendências que eles acreditam que aparecerão em breve.  O que muitas dessas análises carecem com certeza é uma base sólida na forma de dados e estatísticas que podem suportar certas declarações. <br><br>  O objetivo deste artigo é fornecer uma introdução simples à análise de criptomoedas usando Python.  Nele, examinaremos passo a passo um script Python simples para receber, analisar e visualizar dados em várias criptomoedas.  No decorrer do trabalho, descobriremos uma tendência interessante no comportamento dos mercados voláteis e descobriremos quais mudanças ocorreram neles. <br><a name="habracut"></a><br> <a href=""><img src="https://habrastorage.org/web/8f9/37a/f50/8f937af50b104ff585b4571e1ae923a1.png" alt="imagem"></a> <br><br>  Este post não será dedicado a explicar o que são criptomoedas (se você precisar de uma explicação dessas, eu recomendaria essa excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">revisão</a> ).  Não haverá discussão sobre quais moedas específicas aumentarão ou diminuirão de valor.  Em vez disso, o guia se concentrará em obter acesso a dados brutos e brutos e em encontrar o histórico oculto sob camadas de números. <br><br><h3>  Etapa 1. Equipamos nosso laboratório </h3><br>  Este guia é destinado a uma ampla gama de entusiastas, engenheiros e profissionais de processamento de dados, independentemente do seu nível de profissionalismo.  Com base nas habilidades, você precisará apenas de um conhecimento básico do Python e das habilidades mínimas de linha de comando necessárias para configurar o projeto. <br><br>  A versão completa do trabalho realizado e todos os seus resultados estão disponíveis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h4>  1.1 Instalar o Anaconda </h4><br>  A maneira mais fácil de instalar dependências do zero para este projeto é usar o Anaconda, um ecossistema python e gerenciador de dependências que contém todos os pacotes necessários para trabalhar com dados e analisá-los. <br><br>  Para instalar o Anaconda, eu recomendaria usar as instruções oficiais disponíveis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  <i>Se você é um usuário avançado e o Anaconda não gosta, não é necessário instalá-lo.</i>  <i>Nesse caso, acho que você não precisa de ajuda para instalar as dependências necessárias e pode ir diretamente para o segundo estágio.</i> <br><br><h4>  1.2 Configurando o ambiente do projeto no Anaconda </h4> <br>  Assim que o Anaconda estiver instalado, queremos criar um novo ambiente para organizar o trabalho com dependências. <br><br>  Digite o comando <code>conda create --name cryptocurrency-analysis python=3</code> para criar um novo ambiente Anaconda para o nosso projeto. <br><br>  Em seguida, insira a <code>source activate cryptocurrency-analysis</code> e (no Linux / macOS) ou <code>activate cryptocurrency-analysis</code> (no Windows) para ativar o ambiente. <br><br>  E, finalmente, o <code>conda install numpy pandas nb_conda jupyter plotly quandl</code> instalará as dependências necessárias no ambiente.  Esse processo pode levar alguns minutos. <br><br>  <i>Por que usamos o ambiente?</i>  <i>Se você planeja trabalhar simultaneamente com muitos projetos Python no seu computador, é útil colocar as dependências (bibliotecas e pacotes de software) separadamente para evitar conflitos.</i>  <i>Dentro de cada projeto, o Anaconda cria um diretório especial para dependências no ambiente, que permite separá-las das dependências de outros projetos e organizar o trabalho com elas.</i> <br><br><h4>  1.3 Iniciando o notebook interativo Jupyter Notebook </h4><br>  Depois que o ambiente e as dependências estiverem instalados, digite <code>jupyter notebook</code> no console para iniciar o kernel do iPython e abra o link <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http: // localhost: 8888 /</a> no navegador.  Crie um novo notebook Python, verificando se ele usa o kernel <code>Python [conda env:cryptocurrency-analysis]</code> . <br><br><img src="https://habrastorage.org/web/6ff/35b/ada/6ff35badacfd44c58a1c4e3f55a3dd9f.png" alt="imagem"><br><br><h4>  1.4 Importando dependências para a parte superior do notebook </h4><br>  Assim que você vir um log Jupyter limpo, primeiro precisará importar as dependências necessárias. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> quandl <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime</code> </pre> <br>  Além disso, você deve importar o Plotly e ativar o modo offline para ele. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> plotly.offline <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> plotly.graph_objs <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> go <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> plotly.figure_factory <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ff py.init_notebook_mode(connected=True)</code> </pre> <br><h3>  Etapa 2. Obtendo dados de preços do Bitcoin </h3><br>  Agora que todas as configurações estão completas, estamos prontos para começar a receber informações para análise.  Primeiro de tudo, precisamos solicitar dados de preços do Bitcoin usando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API</a> gratuita do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bitcoin API Quandl</a> . <br><br><h4>  2.1 Definir uma função auxiliar do Quandl </h4><br>  Para ajudar na aquisição de dados, definiremos uma função que baixa e armazena em cache os conjuntos de dados do Quandl. <br><br><pre> <code class="javascript hljs">def get_quandl_data(quandl_id): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Download and cache Quandl dataseries'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> cache_path = <span class="hljs-string"><span class="hljs-string">'{}.pkl'</span></span>.format(quandl_id).replace(<span class="hljs-string"><span class="hljs-string">'/'</span></span>,<span class="hljs-string"><span class="hljs-string">'-'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: f = open(cache_path, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) df = pickle.load(f) print(<span class="hljs-string"><span class="hljs-string">'Loaded {} from cache'</span></span>.format(quandl_id)) except (OSError, IOError) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'Downloading {} from Quandl'</span></span>.format(quandl_id)) df = quandl.get(quandl_id, returns=<span class="hljs-string"><span class="hljs-string">"pandas"</span></span>) df.to_pickle(cache_path) print(<span class="hljs-string"><span class="hljs-string">'Cached {} at {}'</span></span>.format(quandl_id, cache_path)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df</code> </pre> <br>  Para converter os dados baixados e salvá-los em um arquivo, usaremos <code>pickle</code> .  Isso impedirá que os mesmos dados sejam baixados novamente sempre que executarmos o script.  A função retornará dados como um quadro de dados do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pandas</a> .  Se você não estiver familiarizado com os quadros de dados, poderá apresentá-los na forma de planilhas muito poderosas. <br><br><h4>  2.2 Tomamos dados de preços da bolsa Kraken </h4><br>  Para começar, vamos extrair os dados históricos sobre a taxa de câmbio do Bitcoin da bolsa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kraken</a> . <br><br><pre> <code class="javascript hljs"># Pull Kraken BTC price exchange data btc_usd_price_kraken = get_quandl_data(<span class="hljs-string"><span class="hljs-string">'BCHARTS/KRAKENUSD'</span></span>)</code> </pre> <br>  Podemos verificar as 5 primeiras linhas do quadro de dados usando o método <code>head()</code> . <br><br><pre> <code class="javascript hljs">btc_usd_price_kraken.head()</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/4c5/ee0/33f/4c5ee033ffe44eba96c137f6a3f3a828.PNG" alt="imagem"></a> <br><br>  Em seguida, vamos gerar um gráfico simples para verificação visual rápida da correção dos dados. <br><br><pre> <code class="javascript hljs"># Chart the BTC pricing data btc_trace = go.Scatter(x=btc_usd_price_kraken.index, y=btc_usd_price_kraken[<span class="hljs-string"><span class="hljs-string">'Weighted Price'</span></span>]) py.iplot([btc_trace])</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/934/c62/911/934c6291184b430bac5a2cd2fcfc01af.png" alt="imagem"></a> <br><br>  Para visualização, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Plotly é</a> usado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Essa é uma abordagem menos tradicional em comparação com as bibliotecas de visualização em python mais autoritativas, como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Matplotlib</a> , mas, na minha opinião, o Plotly é uma excelente opção, pois permite criar gráficos totalmente interativos usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">D3.js.</a>  Como resultado, você pode obter bons diagramas visuais na saída sem nenhuma configuração.  Além disso, o Plotly é fácil de aprender e seus resultados são facilmente inseridos em páginas da web. <br><br>  <i>Obviamente, você deve sempre lembrar a necessidade de comparar as visualizações resultantes com gráficos de preços de criptomoedas disponíveis ao público (por exemplo, no Coinbase) para uma verificação básica da confiabilidade dos dados baixados.</i> <br><br><h4>  2.3 Solicitar dados de preços de outras trocas BTC </h4><br>  Você deve ter notado discrepâncias neste conjunto: o gráfico diminui em vários lugares para zero, especialmente no final de 2014 e no início de 2016. Essas quedas são encontradas no conjunto de dados Kraken e, obviamente, não queremos que elas sejam refletidas em nossa análise final de preços. <br><br>  A natureza das trocas de bitcoin é tal que os preços são determinados pela oferta e pela demanda e, portanto, nenhuma das trocas existentes pode alegar que suas cotações refletem o único preço verdadeiro e de referência do Bitcoin.  Para levar em conta essa desvantagem, bem como para eliminar o subsidência de preços no gráfico, provavelmente devido a erros técnicos ou de conjunto de dados, coletaremos adicionalmente dados de três outras grandes trocas de bitcoins para calcular o índice de preços agregado para bitcoin. <br><br>  Para começar, vamos baixar os dados de cada troca em um dicionário de quadros de dados. <br><br><pre> <code class="javascript hljs"># Pull pricing data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> more BTC exchanges exchanges = [<span class="hljs-string"><span class="hljs-string">'COINBASE'</span></span>,<span class="hljs-string"><span class="hljs-string">'BITSTAMP'</span></span>,<span class="hljs-string"><span class="hljs-string">'ITBIT'</span></span>] exchange_data = {} exchange_data[<span class="hljs-string"><span class="hljs-string">'KRAKEN'</span></span>] = btc_usd_price_kraken <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> exchange <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> exchanges: exchange_code = <span class="hljs-string"><span class="hljs-string">'BCHARTS/{}USD'</span></span>.format(exchange) btc_exchange_df = get_quandl_data(exchange_code) exchange_data[exchange] = btc_exchange_df</code> </pre> <br><h4>  2.4 Combinando todos os dados de preços em um quadro de dados </h4><br>  A seguir, definiremos uma função simples que combina as colunas semelhantes de cada quadro de dados em um novo quadro combinado. <br><br><pre> <code class="javascript hljs">def merge_dfs_on_column(dataframes, labels, col): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Merge a single column of each dataframe into a new combined dataframe'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> series_dict = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(dataframes)): series_dict[labels[index]] = dataframes[index][col] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pd.DataFrame(series_dict)</code> </pre> <br>  Agora, vamos combinar todos os quadros de dados com base na coluna Preço Ponderado. <br><br><pre> <code class="javascript hljs"># Merge the BTC price dataseries<span class="hljs-string"><span class="hljs-string">' into a single dataframe btc_usd_datasets = merge_dfs_on_column(list(exchange_data.values()), list(exchange_data.keys()), '</span></span>Weighted Price<span class="hljs-string"><span class="hljs-string">')</span></span></code> </pre> <br>  Por fim, observe as últimas cinco linhas usando o método <code>tail()</code> para garantir que o resultado do nosso trabalho pareça normal. <br><br><pre> <code class="javascript hljs">btc_usd_datasets.tail()</code> </pre> <br><img src="https://habrastorage.org/web/dff/f3c/661/dfff3c661b494648bfc0d2675d260f40.png" alt="imagem"><br><br>  Os preços parecem os esperados: eles estão dentro de limites semelhantes, mas há pequenas diferenças com base na relação oferta / demanda em cada troca individual. <br><br><h4>  2.5 Visualizar conjuntos de dados de preços </h4><br>  O próximo passo lógico é visualizar a comparação dos conjuntos de dados resultantes.  Para isso, definimos uma função auxiliar que fornece a capacidade de gerar um gráfico com base em um quadro de dados usando um comando de linha única. <br><br><pre> <code class="javascript hljs">def df_scatter(df, title, seperate_y_axis=False, y_axis_label=<span class="hljs-string"><span class="hljs-string">''</span></span>, scale=<span class="hljs-string"><span class="hljs-string">'linear'</span></span>, initial_hide=False): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Generate a scatter plot of the entire dataframe'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> label_arr = list(df) series_arr = list(map(lambda col: df[col], label_arr)) layout = go.Layout( title=title, legend=dict(orientation=<span class="hljs-string"><span class="hljs-string">"h"</span></span>), xaxis=dict(type=<span class="hljs-string"><span class="hljs-string">'date'</span></span>), yaxis=dict( title=y_axis_label, showticklabels= not seperate_y_axis, type=scale ) ) y_axis_config = dict( overlaying=<span class="hljs-string"><span class="hljs-string">'y'</span></span>, showticklabels=False, type=scale ) visibility = <span class="hljs-string"><span class="hljs-string">'visible'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> initial_hide: visibility = <span class="hljs-string"><span class="hljs-string">'legendonly'</span></span> # Form Trace For Each Series trace_arr = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index, series <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(series_arr): trace = go.Scatter( x=series.index, y=series, name=label_arr[index], visible=visibility ) # Add seperate axis <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the series <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> seperate_y_axis: trace[<span class="hljs-string"><span class="hljs-string">'yaxis'</span></span>] = <span class="hljs-string"><span class="hljs-string">'y{}'</span></span>.format(index + <span class="hljs-number"><span class="hljs-number">1</span></span>) layout[<span class="hljs-string"><span class="hljs-string">'yaxis{}'</span></span>.format(index + <span class="hljs-number"><span class="hljs-number">1</span></span>)] = y_axis_config trace_arr.append(trace) fig = go.Figure(data=trace_arr, layout=layout) py.iplot(fig)</code> </pre> <br>  Por uma questão de brevidade, não entrarei em detalhes sobre o funcionamento de uma função auxiliar.  Se você estiver interessado em aprender mais sobre isso, consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pandas</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Plotly</a> . <br><br>  Podemos facilmente gerar um gráfico para dados de preços de bitcoin. <br><br><pre> <code class="javascript hljs"># Plot all <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the BTC exchange prices df_scatter(btc_usd_datasets, <span class="hljs-string"><span class="hljs-string">'Bitcoin Price (USD) By Exchange'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/1b5/f48/c9e/1b5f48c9ec2e4257a281ec2632dbec76.png" alt="imagem"><br></a> <br><h4>  2.6 Limpando e combinando dados de preços </h4><br>  Podemos ver que, apesar de todas as quatro séries de dados se comportarem aproximadamente da mesma maneira, existem vários desvios da norma neles que precisam ser eliminados. <br><br>  Vamos remover todos os valores zero do quadro, pois sabemos que o preço do bitcoin nunca foi zero dentro do período que estamos considerando. <br><br><pre> <code class="javascript hljs"># Remove <span class="hljs-string"><span class="hljs-string">"0"</span></span> values btc_usd_datasets.replace(<span class="hljs-number"><span class="hljs-number">0</span></span>, np.nan, inplace=True)</code> </pre> <br>  Tendo construído o gráfico novamente, obtemos uma curva mais limpa, sem quedas acentuadas. <br><br><pre> <code class="javascript hljs"># Plot the revised dataframe df_scatter(btc_usd_datasets, <span class="hljs-string"><span class="hljs-string">'Bitcoin Price (USD) By Exchange'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/d24/960/13e/d2496013e0ca41e1acd421ff44b97cd0.png" alt="imagem"></a> <br><br>  E agora podemos calcular uma nova coluna contendo o preço médio diário do bitcoin com base nos dados de todas as trocas. <br><br><pre> <code class="javascript hljs"># Calculate the average BTC price <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> column btc_usd_datasets[<span class="hljs-string"><span class="hljs-string">'avg_btc_price_usd'</span></span>] = btc_usd_datasets.mean(axis=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Esta nova coluna é o nosso índice de preços Bitcoin!  Vamos plotá-lo para garantir que pareça normal. <br><br><pre> <code class="javascript hljs"># Plot the average BTC price btc_trace = go.Scatter(x=btc_usd_datasets.index, y=btc_usd_datasets[<span class="hljs-string"><span class="hljs-string">'avg_btc_price_usd'</span></span>]) py.iplot([btc_trace])</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/fad/289/9de/fad2899de9c14304a8964df909a9883f.png" alt="imagem"></a> <br><br>  Sim, parece bom.  Usaremos a série de preços combinados no futuro para converter as taxas de câmbio de outras criptomoedas em dólar americano. <br><br><h3>  Etapa 3. Obtenção dos dados de preços do altcoin </h3><br>  Agora que temos uma série temporal confiável de preços para bitcoin, solicitamos alguns dados para criptomoedas que não sejam bitcoin, que geralmente são chamadas de altcoins. <br><br><h4>  3.1 Definindo funções auxiliares para trabalhar com a API Poloniex </h4><br>  Para obter dados de altcoin, usaremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a API Poloniex</a> .  Duas funções auxiliares que baixam e armazenam em cache os dados JSON passados ​​para esta API nos ajudarão nisso. <br><br>  Primeiro, definimos <code>get_json_data</code> , que fará o download e armazenará em cache os dados JSON na URL fornecida. <br><br><pre> <code class="javascript hljs">def get_json_data(json_url, cache_path): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Download and cache JSON data, return as a dataframe.'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: f = open(cache_path, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) df = pickle.load(f) print(<span class="hljs-string"><span class="hljs-string">'Loaded {} from cache'</span></span>.format(json_url)) except (OSError, IOError) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'Downloading {}'</span></span>.format(json_url)) df = pd.read_json(json_url) df.to_pickle(cache_path) print(<span class="hljs-string"><span class="hljs-string">'Cached {} at {}'</span></span>.format(json_url, cache_path)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df</code> </pre> <br>  Em seguida, definimos uma função que gera solicitações HTTP para a API do Poloniex e, em seguida, chama <code>get_json_data</code> , que, por sua vez, armazena os dados solicitados. <br><br><pre> <code class="javascript hljs">base_polo_url = <span class="hljs-string"><span class="hljs-string">'https://poloniex.com/public?command=returnChartData&amp;currencyPair={}&amp;start={}&amp;end={}&amp;period={}'</span></span> start_date = datetime.strptime(<span class="hljs-string"><span class="hljs-string">'2015-01-01'</span></span>, <span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>) # get data <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the start <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">2015</span></span> end_date = datetime.now() # up until today pediod = <span class="hljs-number"><span class="hljs-number">86400</span></span> # pull daily data (<span class="hljs-number"><span class="hljs-number">86</span></span>,<span class="hljs-number"><span class="hljs-number">400</span></span> seconds per day) def get_crypto_data(poloniex_pair): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Retrieve cryptocurrency data from poloniex'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> json_url = base_polo_url.format(poloniex_pair, start_date.timestamp(), end_date.timestamp(), pediod) data_df = get_json_data(json_url, poloniex_pair) data_df = data_df.set_index(<span class="hljs-string"><span class="hljs-string">'date'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_df</code> </pre> <br>  Ela pega uma sequência que indica o par de criptomoedas (por exemplo, BTC_ETH) e retorna um quadro de dados contendo dados históricos em sua taxa de câmbio. <br><br><h4>  3.2 Fazendo download de dados comerciais com o Poloniex </h4><br>  A maioria das altcoins não pode ser comprada diretamente por dólares americanos.  Para adquiri-los, as pessoas costumam comprar bitcoins e trocá-los por altcoins em bolsas.  Portanto, baixamos as taxas de câmbio do BTC para cada moeda e usamos os dados ao preço do BTC para calcular o custo das altcoins em USD. <br><br>  Fazemos o download dos dados de estoque das nove criptomoedas mais populares - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ethereum</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Litecoin</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ripple</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ethereum Classic</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Stellar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dashcoin</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Siacoin</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monero</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NEM</a> . <br><br><pre> <code class="javascript hljs">altcoins = [<span class="hljs-string"><span class="hljs-string">'ETH'</span></span>,<span class="hljs-string"><span class="hljs-string">'LTC'</span></span>,<span class="hljs-string"><span class="hljs-string">'XRP'</span></span>,<span class="hljs-string"><span class="hljs-string">'ETC'</span></span>,<span class="hljs-string"><span class="hljs-string">'STR'</span></span>,<span class="hljs-string"><span class="hljs-string">'DASH'</span></span>,<span class="hljs-string"><span class="hljs-string">'SC'</span></span>,<span class="hljs-string"><span class="hljs-string">'XMR'</span></span>,<span class="hljs-string"><span class="hljs-string">'XEM'</span></span>] altcoin_data = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> altcoin <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> altcoins: coinpair = <span class="hljs-string"><span class="hljs-string">'BTC_{}'</span></span>.format(altcoin) crypto_price_df = get_crypto_data(coinpair) altcoin_data[altcoin] = crypto_price_df</code> </pre> <br>  Agora, temos um dicionário de 9 quadros de dados, cada um dos quais contém dados históricos sobre os pares de preços médios diários de troca de altcoins e bitcoin. <br>  Mais uma vez, verificaremos as últimas cinco linhas da tabela de preços do Ethereum para garantir que tudo esteja em ordem. <br><br><pre> <code class="javascript hljs">altcoin_data[<span class="hljs-string"><span class="hljs-string">'ETH'</span></span>].tail()</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/632/68a/4ba/63268a4bae1e449cb5d0a336ae117236.png" alt="imagem"></a> <br><br><h4>  3.3 conversão de preços em dólares americanos </h4><br>  Agora podemos comparar os dados dos pares de preços com o nosso índice de preços de bitcoin para obter diretamente dados históricos sobre o valor das altcoins em dólares americanos. <br><br><pre> <code class="javascript hljs"># Calculate USD Price <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> column <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> each altcoin dataframe <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> altcoin <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> altcoin_data.keys(): altcoin_data[altcoin][<span class="hljs-string"><span class="hljs-string">'price_usd'</span></span>] = altcoin_data[altcoin][<span class="hljs-string"><span class="hljs-string">'weightedAverage'</span></span>] * btc_usd_datasets[<span class="hljs-string"><span class="hljs-string">'avg_btc_price_usd'</span></span>]</code> </pre> <br>  Usando esse código, criamos uma nova coluna no quadro de dados de cada altcoin com os preços das moedas em dólares. <br><br>  Além disso, podemos reutilizar a função definida anteriormente <code>merge_dfs_on_column</code> para criar um quadro de dados contendo preços em dólares para cada criptomoeda. <br><br><pre> <code class="javascript hljs"># Merge USD price <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> each altcoin into single dataframe combined_df = merge_dfs_on_column(list(altcoin_data.values()), list(altcoin_data.keys()), <span class="hljs-string"><span class="hljs-string">'price_usd'</span></span>)</code> </pre> <br>  Assim mesmo.  Agora, vamos também adicionar os preços do bitcoin à última coluna do quadro de dados combinado. <br><br><pre> <code class="javascript hljs"># Add BTC price to the dataframe combined_df[<span class="hljs-string"><span class="hljs-string">'BTC'</span></span>] = btc_usd_datasets[<span class="hljs-string"><span class="hljs-string">'avg_btc_price_usd'</span></span>]</code> </pre> <br>  E agora temos um único quadro contendo preços diários em dólar para as dez criptomoedas que estamos estudando. <br><br>  Vamos reutilizar a função <code>df_scatter</code> definida anteriormente para desenhar um gráfico comparativo das mudanças de preço das criptomoedas. <br><br><pre> <code class="javascript hljs"># Chart all <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the altocoin prices df_scatter(combined_df, <span class="hljs-string"><span class="hljs-string">'Cryptocurrency Prices (USD)'</span></span>, seperate_y_axis=False, y_axis_label=<span class="hljs-string"><span class="hljs-string">'Coin Value (USD)'</span></span>, scale=<span class="hljs-string"><span class="hljs-string">'log'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/19d/b4f/4de/19db4f4de0ad482e8c92376c67fb8ebb.png" alt="imagem"></a> <br><br>  Ótimo!  O gráfico permite avaliar claramente a dinâmica das taxas de câmbio de cada criptomoeda nos últimos anos. <br><br>  <i>Observe que usamos a escala de ordenadas logarítmicas, porque ela permite ajustar todas as moedas em um gráfico.</i>  <i>Mas, se desejar, você pode tentar diferentes valores de parâmetros (como <code>scale='linear'</code> ) para examinar os dados de uma perspectiva diferente.</i> <br><br><h4>  3.4 Análise de Correlação </h4><br>  Você deve ter notado que as taxas de câmbio de criptomoedas, apesar de seus valores e volatilidade completamente diferentes, parecem ter alguma correlação entre elas.  Especialmente se você observar o intervalo após o aumento de agosto, até pequenas flutuações ocorrem com tokens diferentes, como se fossem sincronizadas. <br><br>  Mas uma premonição baseada em semelhança externa não é melhor do que um simples palpite até que possamos fazer backup com dados estatísticos. <br><br>  Podemos testar nossa hipótese de correlação usando o método <code>corr()</code> do conjunto Pandas, usando-o para calcular o coeficiente de correlação de Pearson de todas as colunas do quadro em relação uma à outra. <br><br>  <i>Correção de 22/8/2017 - Esta parte do trabalho foi revisada.</i>  <i>Agora, para calcular os coeficientes de correlação, em vez dos valores absolutos de preços, são usados ​​os valores percentuais de suas alterações diárias.</i> <br><br>  O cálculo das correlações diretamente entre séries temporais não estacionárias (como dados brutos de preços) pode levar a resultados tendenciosos.  Nós corrigiremos esse defeito aplicando o método <code>pct_change()</code> , que converte o valor de cada célula de quadro de um valor absoluto em uma porcentagem de sua alteração diária. <br><br>  Para começar, calculamos a correlação em 2016. <br><br><pre> <code class="javascript hljs"># Calculate the pearson correlation coefficients <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cryptocurrencies <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">2016</span></span> combined_df_2016 = combined_df[combined_df.index.year == <span class="hljs-number"><span class="hljs-number">2016</span></span>] combined_df_2016.pct_change().corr(method=<span class="hljs-string"><span class="hljs-string">'pearson'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/f11/5bd/753/f115bd7536414f45bbf6f509d5c76b25.png" alt="imagem"></a> <br><br>  Agora temos chances em todos os lugares.  Valores próximos a 1 ou -1 dizem que, entre as séries temporais, há uma forte correlação direta ou reversa, respectivamente.  Coeficientes próximos de zero significam que os valores não se correlacionam e variam independentemente um do outro. <br><br>  Para visualizar os resultados, precisamos criar outra função de visualização auxiliar. <br><br><pre> <code class="javascript hljs">def correlation_heatmap(df, title, absolute_bounds=True): <span class="hljs-string"><span class="hljs-string">''</span></span><span class="hljs-string"><span class="hljs-string">'Plot a correlation heatmap for the entire dataframe'</span></span><span class="hljs-string"><span class="hljs-string">''</span></span> heatmap = go.Heatmap( z=df.corr(method=<span class="hljs-string"><span class="hljs-string">'pearson'</span></span>).as_matrix(), x=df.columns, y=df.columns, colorbar=dict(title=<span class="hljs-string"><span class="hljs-string">'Pearson Coefficient'</span></span>), ) layout = go.Layout(title=title) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> absolute_bounds: heatmap[<span class="hljs-string"><span class="hljs-string">'zmax'</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0</span></span> heatmap[<span class="hljs-string"><span class="hljs-string">'zmin'</span></span>] = <span class="hljs-number"><span class="hljs-number">-1.0</span></span> fig = go.Figure(data=[heatmap], layout=layout) py.iplot(fig)</code> </pre> <br><pre> <code class="javascript hljs">correlation_heatmap(combined_df_2016.pct_change(), <span class="hljs-string"><span class="hljs-string">"Cryptocurrency Correlations in 2016"</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/4f5/576/1da/4f55761daa17402ea0b059fcca93df45.png" alt="imagem"><br></a> <br>  As células vermelhas escuras no gráfico indicam uma forte correlação (e cada uma das moedas obviamente se correlacionará consigo mesma o máximo possível), azul escuro - uma forte correlação inversa.  Todas as cores azul, laranja, cinza e areia entre elas indicam diferentes graus de correlação fraca ou sua ausência. <br><br>  O que esse gráfico nos diz?  De fato, mostra que a relação estatisticamente significativa entre flutuações de preços de várias criptomoedas em 2016 é pequena. <br><br>  E agora, para testar nossa hipótese de que as criptomoedas se tornaram mais correlacionadas nos últimos meses, vamos repetir o mesmo teste usando dados já para 2017. <br><br><pre> <code class="javascript hljs">combined_df_2017 = combined_df[combined_df.index.year == <span class="hljs-number"><span class="hljs-number">2017</span></span>] combined_df_2017.pct_change().corr(method=<span class="hljs-string"><span class="hljs-string">'pearson'</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/740/946/579/7409465791b8437582055aa2ec4297c8.png" alt="imagem"></a> <br><br>  Os coeficientes obtidos indicam a presença de uma correlação mais significativa.  Ela é forte o suficiente para tirar proveito desse fato para investimento?  Definitivamente não. <br><br>  Porém, devemos prestar atenção ao fato de que quase todas as criptomoedas como um todo se tornaram mais correlatas. <br><br><pre> <code class="javascript hljs">correlation_heatmap(combined_df_2017.pct_change(), <span class="hljs-string"><span class="hljs-string">"Cryptocurrency Correlations in 2017"</span></span>)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/web/0a9/fd4/de3/0a9fd4de30f446b3aeed700aaed5e377.png" alt="imagem"></a> <br><br>  E esta é uma observação bastante interessante. <br><br><h3>  Por que isso está acontecendo? </h3><br>  Boa pergunta  Não tenho certeza. <br><br>  O primeiro pensamento que vem à mente: a razão é que os fundos de hedge começaram recentemente a negociar abertamente nos mercados de criptomoedas.  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a> ] [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a> ] Esses fundos têm quantias muito maiores de capital do que os negociadores médios e, se se protegerem dos riscos, borrifando seus fundos em uma variedade de criptomoedas e usando estratégias de negociação semelhantes para cada um deles, com base em variáveis ​​independentes (como fazem , por exemplo, no mercado de ações), uma conseqüência lógica dessa abordagem pode ser o surgimento de uma tendência para correlações crescentes. <br><br><h4>  Análise aprofundada: XRP e STR </h4><br>  Por exemplo, uma das tendências confirma indiretamente o raciocínio acima.  XRP (Ripple token) está menos correlacionado com outras altcoins.  Mas há uma exceção notável - STR (o token estelar, o oficial é chamado de “Lumens”), cujo coeficiente de correlação com o XRP é 0,62. <br><br>  Curiosamente, Stellar e Ripple são plataformas fintech bastante semelhantes, cujas atividades visam simplificar o processo de pagamentos interbancários internacionais. <br><br>  Vejo uma situação muito real na qual alguns jogadores ricos e fundos de hedge usam estratégias semelhantes para negociar fundos investidos no Stellar e Ripple, já que os dois serviços por trás desses tokens são de natureza muito semelhante.  Essa suposição pode explicar por que o XRP está muito mais correlacionado com o STR do que com outras criptomoedas. <br><br><h3>  Sua vez </h3><br>  No entanto, essa explicação é em grande parte uma conclusão especulativa.  Mas talvez você possa fazer melhor?  A base que lançamos neste trabalho nos permite continuar o estudo de dados em várias direções. <br><br>  Aqui estão algumas idéias para verificar: <br><br><ul><li>  Adicione dados para mais criptomoedas à análise. </li><li>  Corrija o prazo e o grau de detalhe da análise de correlação, considerando as tendências em mais detalhes, ou vice-versa, em termos mais gerais. </li><li>  Procure tendências em volumes de negociação e / ou conjuntos de dados para mineração de blockchain.  Os índices de vendas / compra são mais adequados para prever flutuações de preços do que dados brutos de preços. </li><li>  Adicione dados de preços de estoques, commodities e matérias-primas, moedas fiduciárias para descobrir quais desses ativos se correlacionam com as criptomoedas.  (Mas lembre-se sempre do bom e velho ditado: "Correlação ainda não implica causalidade".) </li><li>  Quantifique a quantidade de hype em torno de criptomoedas usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Registro de Eventos</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GDELT</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google Trends</a> . </li><li>  Usando o aprendizado de máquina, treine um programa para analisar dados e prever tendências de preços.  Se a ambição permitir, você pode tentar fazê-lo com uma rede neural recorrente. </li><li>  Use sua análise para criar uma negociação automatizada de comerciantes de bot em sites como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Poloniex</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Coinbase</a> usando as APIs apropriadas.  Mas tenha cuidado: um robô de negociação mal otimizado pode privá-lo rapidamente de todos os fundos disponíveis. </li><li>  <b>Compartilhe suas descobertas!</b>  A melhor característica do Bitcoin e de outras criptomoedas em geral é que sua natureza descentralizada as torna mais livres e democráticas, em comparação com quase todos os outros ativos.     ,    ,   ,     -. </li></ul><br> HTML-  python-  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br> ,       ,           -  ,      ,  ,         . <br><br>    , ,  ,     - ,   .     -   ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Github-</a> . <br><br>     , , ,   .   ,  ,      ,        . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/4bd/bf6/597/4bdbf659775744b1bdbb4d8a00a0a980.png" alt="imagem"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt406363/">https://habr.com/ru/post/pt406363/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt406345/index.html">NIMS - software de cenário específico (para role-playing games de ação ao vivo)</a></li>
<li><a href="../pt406347/index.html">FDA aprova primeiro terapia genética para leucemia</a></li>
<li><a href="../pt406353/index.html">Cientistas dizem que inteligência de macacos foi julgada mal por décadas</a></li>
<li><a href="../pt406359/index.html">Detalhes da criação de um bot para o Dota 2</a></li>
<li><a href="../pt406361/index.html">M.SMART - Hackathon de setembro "M. Video": chatbots, IA e aprendizado de máquina</a></li>
<li><a href="../pt406365/index.html">Kaspersky Lab paga trolls de patentes por evitar litígios</a></li>
<li><a href="../pt406367/index.html">Canon Mobile Print: imprima de qualquer lugar do mundo</a></li>
<li><a href="../pt406369/index.html">Entrevista com Aubrey de Gray - As pessoas podem viver 1000 anos ou mais?</a></li>
<li><a href="../pt406373/index.html">300.000 milhas no Tesla Model S</a></li>
<li><a href="../pt406375/index.html">Monstros, milagres e o nascimento da ciência</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>