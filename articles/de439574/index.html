<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò° üë®üèæ‚ÄçüöÄ üöë SmartCard I2C-Protokoll. Tauschen Sie APDU-Befehle √ºber die I2C-Schnittstelle aus üå∑ ü§î üêÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Vor einiger Zeit war ich an der Entwicklung eines Ger√§ts beteiligt, bei dem die russische Kryptographie implementiert werden musste. Da d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SmartCard I2C-Protokoll. Tauschen Sie APDU-Befehle √ºber die I2C-Schnittstelle aus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439574/"><h2>  Einf√ºhrung </h2><br>  Vor einiger Zeit war ich an der Entwicklung eines Ger√§ts beteiligt, bei dem die russische Kryptographie implementiert werden musste.  Da diese Entscheidung k√ºnftig bescheinigt werden sollte, wurden bestimmte Anforderungen an die Implementierung der Kryptographie gestellt.  Als eine der Optionen zur Vereinfachung der Implementierung dieser Anforderungen haben wir die M√∂glichkeit in Betracht gezogen, einen Smartcard-Leser in das Ger√§t zu integrieren oder einen Smartcard-Chip zu installieren, in dem bereits viele notwendige Szenarien f√ºr die Arbeit mit Schl√ºsselinformationen implementiert wurden. <br><br>  Leider passte eine solche L√∂sung aus irgendeinem Grund nicht, obwohl die Verwendung der bereits vorbereiteten russischen Hardware-Kryptographie die Entwicklung und anschlie√üende Zertifizierung des Endprodukts erheblich beschleunigen w√ºrde.  Die Gr√ºnde f√ºr die Unm√∂glichkeit, USB-Token oder Smartcards zu verwenden, waren weit verbreitet: Das Ger√§t sollte recht kompakt sein (ein kleines Modul f√ºr M2M- oder IoT-Ger√§te), haupts√§chlich im wartungsfreien Modus betrieben werden und in einem weiten Temperaturbereich arbeiten. <br><br>  In diesem Artikel m√∂chte ich √ºber eine m√∂gliche L√∂sung f√ºr einen solchen Fall unter Verwendung des A7001-Chips sprechen, der √ºber die I2C-Schnittstelle mit dem System verbunden ist. <br><br><img src="https://habrastorage.org/webt/e5/bw/lh/e5bwlh2fhtuxpwj7cdmmt7ujtjc.png"><br><a name="habracut"></a><br><h2>  Probleme bei der Implementierung der Kryptographie im PAC </h2><br>  Ich m√∂chte nicht auf die Probleme der Kryptografie-Zertifizierung eingehen.  Wer damit arbeitet, ist sich dessen sowieso bewusst, aber der Rest scheint es nicht zu brauchen.  Zu einigen wichtigen Punkten lohnt es sich jedoch noch zu sagen. <br><br>  Theoretisch sollte es keine besonderen Probleme mit der Kryptographie geben.  Schlie√ülich reicht es aus, eine der kryptografischen Bibliotheken, zum Beispiel OpenSSL, oder eine andere von vielen vorhandenen zu verwenden. <br><br>  Probleme beginnen, wenn diese L√∂sung zertifiziert werden muss.  Und die reine Software-Implementierung der Kryptografie in der Firmware macht das Ger√§t zu einem vollwertigen Ger√§t zum Schutz kryptografischer Informationen, das in einem Testlabor genau untersucht werden muss.  Schlie√ülich m√ºssen Sie bei der Entwicklung einer L√∂sung mit Kryptografie fr√ºher oder sp√§ter √ºber Dinge wie ein Schl√ºsselschema nachdenken, Schl√ºssel speichern, Zufallszahlen generieren und andere subtile Dinge. <br><br>  F√ºr einige L√∂sungen gibt es eine elegante Methode zur Implementierung zertifizierter russischer kryptografischer Algorithmen, mit der wir den Prozess der Erstellung von Endger√§ten leicht vereinfachen und die Zeit f√ºr deren Entwicklung und anschlie√üende Zertifizierung verk√ºrzen k√∂nnen.  Es reicht aus, eine Smartcard oder einen Smartcard-Chip in das Ger√§t einzubetten und diese als eine Art ‚ÄûVertrauenswurzel‚Äú zu verwenden, um so eine erhebliche Anzahl schmerzhafter Probleme zu l√∂sen, die langwierige Forschung und Best√§tigung in Testlabors erfordern. <br><br><img src="https://habrastorage.org/webt/e2/iq/6i/e2iq6i49c7ber2rkbgu6sv8fl3u.png"><br><br><h2>  Smartcard-Mikrocontroller mit I2C-Schnittstelle </h2><br>  Um diesen Artikel zu schreiben, habe ich den A7001-Chip verwendet, der √ºber den I2C-Bus, der in fast jedem Ger√§t verf√ºgbar ist, mit dem Endger√§t verbunden ist.  Der Chip wurde von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aladdin RD</a> bereitgestellt, auf dem bereits eine Firmware installiert ist, die die russische Kryptographie unterst√ºtzt. <br><br>  Der Mikrocontroller A7001AG (Secure Authentication Microcontroller) wird von NXP hergestellt.  Laut Datenblatt auf dem Chip ist der <b>A7001AG</b> ein Mikrocontroller, der auf der klassischen 80C51-Architektur mit einem kryptografischen Coprozessor vor unbefugtem Zugriff gesch√ºtzt ist. <br><br>  Im Energiesparmodus verbraucht der Mikrocontroller 50 ŒºA.  Es unterst√ºtzt Versorgungsspannungen im Bereich von 1,62 V bis 5,5 V und kann bei Temperaturen von ‚Äì25 ¬∞ C bis + 85 ¬∞ C betrieben werden. <br><br>  F√ºr die Interaktion mit externen Ger√§ten wird die I2C-Slave-Schnittstelle mit einer Geschwindigkeit von bis zu 100 kbit / s verwendet. <br><br>  Der Mikrocontroller ist in verschiedenen Geh√§useoptionen erh√§ltlich.  Ich bin im HVQFN32-Format gelandet.  Dies ist ein Kunststoffgeh√§use von 5 x 5 x 0,85 mm mit 32 Kontakten und einem Abstand von 0,5 mm. <br><br>  Aussehen des Falles: <br><br><img src="https://habrastorage.org/webt/tn/7r/mz/tn7rmzk8pbzw1ezupbdv7fxvqhm.png"><br><br>  Seine Pinbelegung: <br><br><img src="https://habrastorage.org/webt/tr/bo/5r/trbo5rlj2_q0v-lxbs7wbqevlu0.png"><br><br><h2>  Hostsystem zum Anschlie√üen des A7001-Chips </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ESP32 WiFi Kit 32-Karte von Heltec</a> wurde als Layout des Host-Systems mit der I2C-Schnittstelle verwendet.  Es kostet weniger als 1000 Rubel, verf√ºgt √ºber alle erforderlichen kabelgebundenen und kabellosen Schnittstellen, einen Anschluss zum Anschlie√üen einer Lithiumbatterie an eine Ladeschaltung sowie ein 0,96-Zoll-OLED-Display. <br><br><img src="https://habrastorage.org/webt/uf/kq/li/ufkqlihfpi9w0692rq8junv0ybo.jpeg"><br><br>  Ein nahezu perfektes System f√ºr das Prototyping verschiedener IoT- und M2M-Ger√§te, mit denen ich schon lange spielen wollte. <br><br>  Das Board kann sowohl in der nativen Entwicklungsumgebung als auch in der Arduino IDE programmiert werden.  Es gibt viele Beispiele f√ºr die Arbeit damit.  Der Einfachheit halber habe ich mich f√ºr die Standard-Arduino-IDE entschieden. <br><br><h2>  Schaltplan </h2><br>  Das Schaltbild zum Anschlie√üen des A7001-Chips ist in der Abbildung dargestellt.  <s>Es unterscheidet sich geringf√ºgig vom empfohlenen Datenblatt.</s>  <s>Gem√§√ü der Beschreibung des Herstellers sollte Klemme 22 (R√ºcksetzsignal RST_N) ein hohes Potential haben, aber die Schaltung startete nicht gem√§√ü diesem Schema.</s>  <s>Infolge des ‚Äûwissenschaftlichen Sto√ües‚Äú wurde die Bedienbarkeit durch Anschlie√üen eines Pull-up-Widerstands R4 an den negativen Leistungsleiter erreicht.</s> <br><br>  <i>UPDATE: Wie in den Kommentaren vorgeschlagen, entspricht das Schema dem Datenblatt, w√§hrend mich die Ausgabebeschreibung verwirrte</i> <blockquote>  RST_N - Eingang zur√ºcksetzen, <b>aktiv LOW</b> </blockquote><br><br><img src="https://habrastorage.org/webt/ud/l3/nd/udl3nd7nz2ck8gtwkb3dhdudzqy.png"><br><br>  Die Schaltung ist auf einem kleinen Steckbrett montiert.  Strom- und I2C-Signale werden √ºber vier Verbindungskabel verbunden, und das ESP32-Modul selbst wird √ºber USB mit dem Computer verbunden, um den gesamten Stromkreis mit Strom zu versorgen und die Firmware zu f√ºllen. <br><br><img src="https://habrastorage.org/webt/de/xz/w1/dexzw1kvlnoixvk0ko-9svuvkbg.png"><br><br><h2>  Smart Card I2C-Protokoll </h2><br>  Als ich zum ersten Mal von der Verbindung von Smartcard-Mikrocontrollern √ºber den I2C-Bus h√∂rte, erkl√§rten sie mir, dass die physische Schicht der Smartcard-Schnittstelle (GOST R ISO / IEC 7816-3-2013) durch I2C (SMBus) ersetzt wurde und alles andere wie gewohnt funktionierte Smartcards gem√§√ü GOST R ISO / IEC 7816-4-2013 mit APDU-Befehlen. <br><br>  Es stellte sich heraus, dass dies nicht ganz oder gar nicht stimmt.  Die Interaktion mit dem Mikrocontroller auf hoher Ebene erfolgt zwar mit herk√∂mmlichen APDU-Befehlen, es gab jedoch auch einige ‚ÄûAber‚Äú. <br><br><ol><li>  Die I2C-Schnittstelle (SMBus) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ru.wikipedia.org/wiki/I%C2%B2C</a> ist ein Bus mit Slave-Adressierung, der sich grundlegend von der seriellen UART-Schnittstelle unterscheidet, die f√ºr die Kommunikation von zwei Ger√§ten auf Punkt-zu-Punkt-Basis und ohne Adressierung ausgelegt ist .  Dies bedeutet, dass alle √ºbertragenen Daten (APDU-Befehle) in das I2C-Bus-Datenformat ‚Äûgepackt‚Äú werden m√ºssen. </li><li>  Die Arbeit mit einer Smartcard beginnt mit dem Zur√ºcksetzen, normalerweise durch Ausschalten der Stromversorgung, z. B. durch physisches Entfernen der Karte aus dem Kartenleser.  Nach dem Zur√ºcksetzen sendet die Smartcard zuerst den ATR-Datenblock (Answer To Reset), der die Konfigurationsinformationen enth√§lt, die zum Konfigurieren der Interaktion mit der Smartcard erforderlich sind. <br>  Und der Chip auf dem I2C-Bus ist keine Ausnahme, aber in dem Fall, in dem der Mikrocontroller auf die Leiterplatte gel√∂tet werden sollte, verf√ºgt er m√∂glicherweise nicht √ºber eine Stromversorgungsschaltung der Mikroschaltung oder eine Softwaresteuerung des R√ºcksetzausgangs.  Daher wird das Zur√ºcksetzen des Chips implementiert, einschlie√ülich auf der Ebene der I2C-Protokollbefehle. </li></ol><br>  Diese und andere Probleme werden durch das Smart Card I2C-Protokoll <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">behoben</a> , dessen Beschreibung auf der NXP-Website unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.nxp.com/docs/en/supporting-information/AN12207.pdf zu finden ist</a> . <br><br><h2>  Software-Teil </h2><br>  Eine Bibliothekssuche mit der Implementierung des <i>Smart Card I2C-Protokollprotokolls</i> ergab keine Ergebnisse.  Daher musste ich die Spezifikationen verstehen und die Grundfunktionen des vorliegenden Objekts umsetzen. <br><br><div class="spoiler">  <b class="spoiler_title">Skizzieren Sie Quellen f√ºr Arduino IDE</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Wire.h&gt; #include &lt;vector&gt; // I2C address on chip A7001 #define ADDR_A7001 static_cast&lt;uint16_t&gt;(0x48) using namespace std; typedef std::vector&lt;uint8_t&gt; vect; //-------------------------------------------------------------------------- // Output dump data by serial port void vect_dump(const char * prefix, const vect &amp; v, const size_t start = 0, const size_t count = 0) { if(prefix) { Serial.print(prefix); } if(v.size() &lt; start) { Serial.println("Empty"); return; } for(size_t i=0; i &lt; (v.size()-start) &amp;&amp; (count == 0 || i &lt; count); i++) { uint8_t b = v[start + i]; // Format output HEX data if(i) Serial.print(" "); if(b &lt; 0x0F) Serial.print("0"); Serial.print(b, HEX); } Serial.println(""); } //-------------------------------------------------------------------------- // Send array bytes by I2C to address A7001 and read response result_size bytes vect sci2c_exchange(const vect data, const uint8_t result_size) { Wire.beginTransmission(ADDR_A7001); Wire.write(data.data(), data.size()); Wire.endTransmission(false); Wire.requestFrom(ADDR_A7001, result_size, true); //delay(1); vect result(result_size, 0); if(result_size &gt;= 2) { result[0] = Wire.read(); // Data size CDB result[1] = Wire.read(); // PCB for(size_t i=2; i&lt;result.size()-2 &amp;&amp; Wire.available(); i++) { result[i+2] = Wire.read(); } } return result; } //-------------------------------------------------------------------------- // Read Status Code uint8_t sci2c_status(const char * msg = nullptr) { vect v = sci2c_exchange({0b0111}, 2); uint8_t status = v[1] &gt;&gt; 4; if(msg) { Serial.print(msg); // Prefix switch(status) { case 0b0000: Serial.println("OK (Ready)"); break; case 0b0001: Serial.println("OK (Busy)"); break; case 0b1000: Serial.println("ERROR (Exception raised)"); break; case 0b1001: Serial.println("ERROR (Over clocking)"); break; case 0b1010: Serial.println("ERROR (Unexpected Sequence)"); break; case 0b1011: Serial.println("ERROR (Invalid Data Length)"); break; case 0b1100: Serial.println("ERROR (Unexpected Command)"); break; case 0b1101: Serial.println("ERROR (Invalid EDC)"); break; default: Serial.print("ERROR (Other Exception "); Serial.print(status, BIN); Serial.println("b)"); break; } } return status; } static uint8_t apdu_master_sequence_counter = 0; // Sequence Counter Master, Master to Slave //-------------------------------------------------------------------------- // Send APDU void sci2c_apdu_send(const vect apdu) { vect_dump("C-APDU =&gt; ", apdu); vect data(2, 0); // 0x00 - Master to Slave Data Transmission command + reserve to length data.insert(data.end(), std::begin(apdu), std::end(apdu)); data[0] |= (apdu_master_sequence_counter &lt;&lt; 4); if(++apdu_master_sequence_counter &gt; 0b111) { apdu_master_sequence_counter = 0; } data[1] = data.size() - 2; sci2c_exchange(data, 2); delay(10); sci2c_status(""); } //-------------------------------------------------------------------------- // Receive APDU vect sci2c_apdu_recv(uint8_t result_size) { Wire.beginTransmission(ADDR_A7001); Wire.write(0b0010); // 0010b - Slave to Master Data Transmission command Wire.endTransmission(false); Wire.requestFrom(ADDR_A7001, result_size, true); vect result(result_size, 0); for(size_t i=0; i&lt;result.size() &amp;&amp; Wire.available(); i++) { result[i] = Wire.read(); } vect_dump("R-APDU &lt;= ", result); return result; } //-------------------------------------------------------------------------- void setup(){ Wire.begin(); Serial.begin(9600); while (!Serial); Serial.println(""); Serial.println("Smart Card I2C Protocol Arduino demo on A7001"); Serial.println(""); sci2c_exchange({0b00001111}, 2); //The bits b0 to b5 set to 001111b indicate the Wakeup command. sci2c_status("Status Wakeup: "); sci2c_exchange({0b00001111}, 2); //The bits b0 to b5 set to 001111b indicate the Wakeup command. sci2c_status("Status Wakeup: "); // Soft Reset sci2c_exchange({0b00011111}, 2); //The bits b0 to b5 set to 011111b indicate the Soft Reset command. delay(5); // Wait at least tRSTG (time, ReSeT Guard) sci2c_status("Status SoftReset: "); // Read ATR vect ATR = sci2c_exchange({0b101111}, 29+2); //The bits b0 to b5 set to 101111b indicate the Read Answer to Reset command. sci2c_status("Status ATR: "); vect_dump("ATR: ", ATR, 2); // Parameter Exchange // The bits b0 to b5 set to 111111b of the PCB send by the master device indicate the Parameter Exchange command. // The bits b6 and b7 of the PCB send by the master device code the CDBIsm,max(Command Data Bytes Integer, Slave to Master, MAXimum) vect CDB = sci2c_exchange({0b11111111}, 2); sci2c_status("Status CDB: "); vect_dump("CDB: ", CDB, 1); // Further examples of the exchange of APDU // Exchanges APDU from exmaple chapter sci2c_apdu_send({0x00, 0xA4, 0x04, 0x04, 0x04, 0x54, 0x65, 0x73, 0x74, 0x00}); sci2c_status("Status Test send: "); sci2c_apdu_recv(3+1); // R-APDU size + 1 byte PBC sci2c_status("Status Test recv: "); // Read Card Production Life Cycle sci2c_apdu_send({0x80, 0xCA, 0x9F, 0x7F, 0x00}); sci2c_status("Status card LC send: "); sci2c_apdu_recv(0x30+1); // R-APDU size + 1 byte PBC sci2c_status("Status card LC recv: "); // Read Card Info sci2c_apdu_send({0x80, 0xCA, 0x00, 0x66, 0x00}); sci2c_status("Status card info send: "); sci2c_apdu_recv(0x51+1); // R-APDU size + 1 byte PBC sci2c_status("Status card info recv: "); // Read Key Info sci2c_apdu_send({0x80, 0xCA, 0x00, 0xE0, 0x00}); sci2c_status("Status key send: "); sci2c_apdu_recv(0x17+1); // R-APDU size + 1 byte PBC sci2c_status("Status key recv: "); // Again exchanges APDU from exmaple chapter sci2c_apdu_send({0x00, 0xA4, 0x04, 0x04, 0x04, 0x54, 0x65, 0x73, 0x74, 0x00}); sci2c_status("Status Test send: "); sci2c_apdu_recv(3+1); // R-APDU size + 1 byte PBC sci2c_status("Status Test recv: "); Serial.println("Done!\n"); } //-------------------------------------------------------------------------- void loop() { delay(100); }</span></span></span></span></code> </pre> <br></div></div><br>  Um mit dem I2C-Port zu arbeiten, habe ich die Standard-Wire-Bibliothek verwendet.  Ich muss sofort sagen, dass diese Bibliothek nicht f√ºr die vollst√§ndige Implementierung des Smart Card I2C-Protokolls geeignet ist, weil  Es ist nicht m√∂glich, ACK und NACK beim Senden und Lesen einzelner Bytes zu steuern, was erforderlich ist, um den korrekten Empfang von Daten variabler L√§nge von einer Smartcard zu implementieren. <br><br>  Ja, und die √ºblichen Beispiele f√ºr den Wire-Code funktionierten nicht beim ersten Mal, aber nach einigem Tanzen mit einer <s>Tamburin-</s> Tastatur, mehreren Litern Kaffee, Googeln in Yandex und Yandex in Google wurde eine L√∂sung gefunden. <br><br><pre> <code class="cpp hljs">Wire.write ( ); Wire.endTransmission (<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Wire.requestFrom (ADDR_A7001, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  Gemessen an der Bibliotheksdokumentation gibt dieses Design den I2C-Bus nach dem Aufruf von <i>endTransmission nicht frei</i> .  Es stellte sich jedoch heraus, dass f√ºr das von mir verwendete ESP32-basierte Modul die Daten√ºbertragung nicht physisch w√§hrend des Aufrufs von <i>endTransmission (false) erfolgt</i> , wie in der Dokumentation f√ºr die Wire-Bibliothek beschrieben, sondern w√§hrend des Aufrufs von <i>requestFrom (true)</i> , w√§hrend die Daten nur davor in die Warteschlange gestellt werden zu √ºbertragen. <br><br>  Angesichts dieser Einschr√§nkungen musste ich einige ‚ÄûKr√ºcken‚Äú herstellen, aber ich wollte unbedingt den A7001-Chip starten, ohne die Standardbibliotheken neu zu schreiben.  Aus diesem Grund wurde die Behandlung von Protokollfehlern nicht implementiert, und es war auch nicht m√∂glich, Daten variabler L√§nge zu empfangen (d. H. Es ist immer erforderlich, die genaue Anzahl der zu lesenden Bytes anzugeben). <br><br>  Solche Einschr√§nkungen sind in einem realen System nicht zul√§ssig, aber nicht unbedingt erforderlich, um die Verwendung von APDU-Befehlen bei der Arbeit am I2C-Bus zu demonstrieren.  Wenn daher beim Austausch von Daten √ºber den I2C-Port ein Fehler im Austauschprotokoll auftritt, geh√∂rt der Kippschalter uns. <br>  Mit anderen Worten, wenn w√§hrend der Wiederholung dieser Experimente alles funktioniert hat und pl√∂tzlich angehalten hat, bevor nach einem Fehler im Code gesucht wurde, schalten Sie das Ger√§t aus und wieder ein.  Mit hoher Wahrscheinlichkeit kann dies das Problem beheben. <br><br><h2>  Codebeispiele f√ºr die Arbeit mit dem A7001-Chip </h2><br>  In den Beispielen verwende ich mehrere Hilfsfunktionen: <br><br>  <b>vect_dump</b> - Ausgabe von Dump-Daten im HEX-Format an den Debug-Port; <br>  <b>sci2c_exchange</b> - sendet ein <b>Datenarray</b> √ºber I2C und liest die angegebene Anzahl von Antwortbytes; <br>  <b>sci2c_status</b> - liest den Antwortstatus des Mikroschaltkreises und zeigt gegebenenfalls seinen Status im Debug-Port an; <br>  <b>sci2c_apdu_send</b> - sendet einen APDU-Befehl; <br>  <b>sci2c_apdu_recv</b> - <b>Liest</b> die Antwort auf den APDU-Befehl. <br><br><h3>  Mikrochip-Initialisierung </h3><br>  Gem√§√ü der Beschreibung des <i>Smart Card I2C-Protokolls</i> sollten vor Beginn der Arbeit mit dem Chip drei Befehle nacheinander ausgef√ºhrt werden: Neustart (Cold oder Soft Reset), Read ATR (Read Answer to Reset) und Setup-Austauschparameter (Master Device Exchange Parameters).  Und erst danach ist der Chip bereit, APDU-Befehle anzunehmen. <br><br><h3>  Soft Reset </h3><br>  Hier ist alles einfach, wir senden einen Neustartbefehl und warten auf die eingestellte Zeit: <br><br><pre> <code class="cpp hljs">sci2c_exchange ({<span class="hljs-number"><span class="hljs-number">0b00011111</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>); delay(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      (tRSTG, time, ReSeT Guard)</span></span></code> </pre><br><h3>  Antwort zum Zur√ºcksetzen lesen </h3><br>  Das Lesen von ATR ist etwas komplizierter  Sie m√ºssen nicht nur einen Befehl senden, sondern auch die Antwortdaten lesen.  Gem√§√ü der Protokollbeschreibung kann die maximale Gr√∂√üe der zur√ºckgegebenen Daten CDBATS, MAX (Befehlsdatenbytes, Antwort zum Zur√ºcksetzen, MAXimum) 29 Bytes betragen. <br><br><pre> <code class="cpp hljs">vect ATR = sci2c_exchange({<span class="hljs-number"><span class="hljs-number">0b101111</span></span>}, <span class="hljs-number"><span class="hljs-number">29</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 29  + 1  PCB + 1  ‚Äî   vect_dump("ATR: ", ATR);</span></span></code> </pre><br>  ATR-Daten lesen: <b>1E 00 00 00 B8 03 11 01 05 B9 02 01 01 BA 01 01 BB 0D 41 37 30 30 31 43 47 20 32 34 32 52 31</b> <br><br>  Dabei ist 1E die Gr√∂√üe der zur√ºckgegebenen Daten (29 Bytes + 1 Byte der Leiterplatte) und 00 die Leiterplatte (Protocol Control Byte), die gleich 0 sein sollte, und anscheinend wurden in diesem Beispiel die Daten nicht korrekt gelesen (es sollte ein Byte der Leiterplatte vorhanden sein). und es gibt drei von ihnen). <br><br>  Die folgenden Daten sind im TLV-Format codiert: <br><br>  <b>B8h</b> - <b>Datenobjekt auf</b> <i>niedriger Ebene</i> , Gr√∂√üe 3 Byte ( <i>11h 01h 05h</i> ); <br>  <b>B9h</b> - <i>Protokollbindungsdatenobjekt</i> , 2 Bytes gro√ü ( <i>01h 01h</i> ); <br>  <b>BAh</b> - <b>Datenobjekt</b> <i>h√∂herer Ebene</i> , 1 Byte ( <i>01h</i> ) gro√ü; <br>  <b>BBh</b> - <i>Betriebssystemdatenobjekt</i> , 13 Byte ( <i>41 37 30 30 31 43 47 20 32 34 32 52 31</i> ). <br><br>  <b>Entschl√ºsselung der Lesekonfiguration des Chips</b> <br>  <i>Low-Level-Datenobjekt</i> : <b>11h</b> - <b>Haupt-</b> und Nebenversionen des unterst√ºtzten Protokolls. <br><br>  <b>Fehlererkennungscodes</b> : <b>01h</b> - Unterst√ºtzung f√ºr die Fehlererkennung und Integrit√§tskontrolle √ºbertragener Daten mithilfe von LRC (Longitudinal Redundancy Code). <br><br>  <i>Frame Waiting Integer (FWI)</i> : <b>05h</b> - maximale Verz√∂gerung zwischen zwei Befehlen.  Der Wertebereich kann zwischen 10 ms und 5120 ms liegen, der Standardwert ist 5120 ms.  Der Wert wird nach der Formel T = 10ms x 2 ^ FWI berechnet.  Dies ergibt in diesem Fall eine Verz√∂gerung von 320 ms (10 ms x 2 ^ 5). <br><br>  <i>Protokollbindungsdatenobjekt</i> - besteht aus zwei Werten, <b>01h 01h</b> , die das unterst√ºtzte Protokoll und das Standardprotokoll codieren.  Diese Werte bedeuten Unterst√ºtzung f√ºr das APDU-Protokoll [GOST R ISO / IEC 7816-3-2013], und wie Sie sich vorstellen k√∂nnen, wird standardm√§√üig dasselbe Protokoll installiert. <br><br>  <i>Datenobjekt mit h√∂herer Schicht</i> - Die Nummer <b>01h</b> bedeutet Unterst√ºtzung f√ºr das kurze und erweiterte APDU-Format. <br><br>  <i>Das Betriebssystemdatenobjekt</i> ist eine Kennung mit einer Gr√∂√üe von bis zu 15 Byte, wie in der Norm [GOST R ISO / IEC 7816-4-2013] definiert.  In unserem Fall ist dies die Zeichenfolge " <i>A7001CG 242R1</i> ". <br><br><h3>  Master-Ger√§t tauscht Parameter aus </h3><br>  Der letzte Befehl zum Initialisieren der Austauscheinstellungen: <br><br><pre> <code class="cpp hljs">vect CDB = sci2c_exchange({<span class="hljs-number"><span class="hljs-number">0b11111111</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>); sci2c_status(<span class="hljs-string"><span class="hljs-string">"Status CDB: "</span></span>); vect_dump(<span class="hljs-string"><span class="hljs-string">"CDB: "</span></span>, CDB, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  R√ºckgabewert: <b>CCh</b> - (11001100b) Gem√§√ü Datenblatt m√ºssen 4 und 5 Bits eine bitweise Negation der Bits 2 und 3 sein (NNb codiert das bitweise negierte CDBIMS, MAX), und gem√§√ü dem codierten Wert unterst√ºtzt der Chip die maximal m√∂gliche Befehlsgr√∂√üe von 252 Byte CDBIMS , MAX-Wert (Command Data Bytes Integer, Master to Slave, MAXimum). <br><br>  Gem√§√ü der Protokollbeschreibung ist die Mikroschaltung nach dem Ausf√ºhren dieser drei Befehle und in dieser Reihenfolge bereit, die √ºblichen APDU-Befehle auszuf√ºhren (obwohl es zu funktionieren scheint, ohne Austauschparameter einzustellen, d. H. Es war ausreichend, einen Soft-Reset durchzuf√ºhren und ATR zu lesen). <br><br><h2>  Ausf√ºhren von APDU-Befehlen </h2><br>  <b>Jeder Zyklus der Ausf√ºhrung von APDU-Befehlen besteht aus den folgenden Schritten:</b> <br><br><ol><li>  APDU senden (Master to Slave-Daten√ºbertragungsbefehl). </li><li>  Warten Sie auf die Schutzzeit f√ºr den Empfang und die Verarbeitung des Befehls. </li><li>  Warten Sie, bis die Verarbeitung des Befehls den Status gelesen hat (Statusbefehl). </li><li>  Antwortdaten lesen (Befehl Slave-to-Master-Daten√ºbertragung). </li></ol><br>  Diese Logik ist in den <b>Funktionen</b> <b>sci2c_apdu_send</b> und <b>sci2c_apdu_recv</b> implementiert, und hier gibt es einen wichtigen Punkt: Im Format des Smart Card I2C-Protokollprotokolls gibt es Z√§hler der √ºbertragenen APDU-Befehle.  Diese Z√§hler m√ºssen sowohl das Master- als auch das Slave-Ger√§t steuern und dienen zur Steuerung der Reihenfolge der √ºbertragenen Daten, sodass im Falle eines Empfangsfehlers APDU-Daten erneut gesendet oder angefordert werden k√∂nnen. <br><br>  Beispiele f√ºr die Implementierung dieser Funktionen finden Sie im Code. Nachfolgend sind nur APDU-Befehle und Antwortdaten aufgef√ºhrt. <br><br><h3>  Beispiel aus Datenblatt: </h3><br>  C-APDU =&gt; <b>00 A4 04 04 04 54 65 73 74 00</b> - Lesen Sie die Datei mit dem Namen "Test". <br>  R-APDU &lt;= <b>6A 86</b> - Laut Datenblatt sollte die Antwort <b>64 82 sein</b> ( <i>Datei oder Anwendung nicht gefunden</i> ). In unserem Fall wird die Firmware jedoch in den Mikrokreis hochgeladen, und die Antwort unterscheidet sich von dem in der Dokumentation beschriebenen Beispiel. <br><br><h3>  Lebenszyklus der Lesekartenproduktion </h3><br>  C-APDU =&gt; <b>80 CA 9F 7F 00</b> <br>  R-APDU &lt;= <b>9F 7F 2A 47 90 51 67 47 91 12 10 38 00 53 56 00 40 39 93 73 50 48 12 53 63 00 00 00 00 13 2C 19 30 34 30 33 39 00 00 00 00 00 00 90 00</b> <br><br><h3>  Read Read Card Info </h3><br><br>  C-APDU =&gt; <b>80 CA 00 66 00</b> <br>  R-APDU &lt;= <b>66 4C 73 4A 06 07 2A 86 48 86 FC 6B 01 60 0C 06 0A 2A 86 48 86 FC 6B 02 02 01 01 63 09 06 07 2A 86 48 86 FC 6B 03 64 0B 06 09 2A 86 48 86 FC 6B 04 02 55 65 0B 06 09 2B 85 10 86 48 64 02 01 03 66 0C 06 0A 2B 06 01 04 01 2A 02 6E 01 02 90 00</b> <br><br><h3>  Read Read Key Info </h3><br>  C-APDU =&gt; <b>80 CA 00 E0 00</b> <br>  R-APDU &lt;= <b>E0 12 C0 04 01 FF 80 10 C0 04 02 FF 80 10 C0 04 03 FF 80 10 90 00</b> <br><br><h2>  Abschlie√üend </h2><br>  Diese Erfahrung bei der Implementierung des Austauschs von APDU-Teams √ºber die I2C-Schnittstelle war sehr interessant.  Ich habe sogar mehrmals gedacht, dass es mir Spa√ü macht, verschiedene Probleme aus dem Bereich der Schaltkreise und auch aus dem normalen L√∂ten zu l√∂sen, seit ich vor mehr als 5 Jahren das letzte Mal einen L√∂tkolben in die Hand nehmen musste. <br><br>  Ich hoffe, dieser Artikel ist n√ºtzlich und hilft, die an diesem Thema Interessierten zu verstehen.  Schreiben Sie, ob Sie das Material interessiert.  Ich werde versuchen, alle Fragen zu diesem Artikel zu beantworten. Wenn das Thema der Verwendung des Smart Card I2C-Protokolls interessant ist, werde ich versuchen, es in den folgenden Ver√∂ffentlichungen ausf√ºhrlicher zu ver√∂ffentlichen. <br><br><h2>  Referenzen: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschreibung der I2C-Schnittstelle (SMBus)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenblatt zum Mikrocontroller A7001AG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschreibung des Smart Card I2C-Protokolls</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GOST R ISO / IEC 7816-3-2013</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GOST R ISO / IEC 7816-4-2013</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439574/">https://habr.com/ru/post/de439574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439564/index.html">Praktische Anwendung der AST-Baumtransformation am Beispiel von Putout</a></li>
<li><a href="../de439566/index.html">Warum SRE-Dokumentation wichtig ist. Teil 3</a></li>
<li><a href="../de439568/index.html">QLC-basierte SSDs - ein Festplattenkiller? Nicht wirklich</a></li>
<li><a href="../de439570/index.html">IPython-Magie zum Bearbeiten von Jupyter-Zellen-Tags</a></li>
<li><a href="../de439572/index.html">Computergest√ºtztes Design elektronischer Ger√§te</a></li>
<li><a href="../de439576/index.html">Ein umfassender √úberblick √ºber Python-Interviews. Tipps & Tricks</a></li>
<li><a href="../de439578/index.html">Zur Frage der Transformationen und anderer Operationen</a></li>
<li><a href="../de439580/index.html">Git f√ºr Windows in ReactOS zum Laufen bringen</a></li>
<li><a href="../de439584/index.html">Lenergy-Projekt als Umdenken bei tragbaren Netzteilen</a></li>
<li><a href="../de439586/index.html">SPBm-Protokoll als Grundlage des Extreme Automated Campus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>