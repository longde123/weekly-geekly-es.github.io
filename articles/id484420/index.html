<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßí ü§∑üèø ü§ûüèª Perubahan antichita BattlEye yang populer dan cara untuk mengelak dari mereka üßùüèæ üë®üèª üë•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pembaruan shellcode Major BattlEye 
 Waktu berlalu, anti-cheat berubah, dan untuk meningkatkan efektivitas produk, fungsi muncul dan menghilang di dal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perubahan antichita BattlEye yang populer dan cara untuk mengelak dari mereka</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484420/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/c7/fe/zdc7ferp6hnuf19n_aid_mh4tca.png"></div><br><h2>  Pembaruan shellcode Major BattlEye </h2><br>  Waktu berlalu, anti-cheat berubah, dan untuk meningkatkan efektivitas produk, fungsi muncul dan menghilang di dalamnya.  Setahun yang lalu, saya menyiapkan deskripsi terperinci dari shellcode BattlEye di <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">blog</a> saya [ <a href="https://habr.com/ru/post/483068/">terjemahan</a> di Habr√©], dan bagian artikel ini akan menjadi refleksi sederhana dari perubahan yang dilakukan pada shellcode. <br><br><h2>  Stempel Waktu Hitam </h2><br>  Dalam analisis BattlEye baru-baru ini, hanya ada dua cap waktu kompilasi dalam daftar larangan bayangan, dan sepertinya para pengembang memutuskan untuk menambahkan lebih banyak lagi: <br><br> <code>0x5B12C900 (action_x64.dll) <br> 0x5A180C35 (TerSafe.dll, Epic Games) <br> 0xFC9B9325 (?) <br> 0x456CED13 (d3dx9_32.dll) <br> 0x46495AD9 (d3dx9_34.dll) <br> 0x47CDEE2B (d3dx9_32.dll) <br> 0x469FF22E (d3dx9_35.dll) <br> 0x48EC3AD7 (D3DCompiler_40.dll) <br> 0x5A8E6020 (?) <br> 0x55C85371 (d3dx9_32.dll) <br> 0x456CED13 (?) <br> 0x46495AD9 (D3DCompiler_40.dll) <br> 0x47CDEE2B (D3DX9_37.dll) <br> 0x469FF22E (?) <br> 0x48EC3AD7 (?) <br> 0xFC9B9325 (?) <br> 0x5A8E6020 (?) <br> 0x55C85371 (?)</code> <br> <br>  Saya tidak dapat mengidentifikasi cap waktu yang tersisa, dan dua <b>0xF *******</b> adalah hash yang dibuat oleh majelis deterministik Visual Studio.  Terima kasih kepada @mottikraus dan T0B1 untuk mengidentifikasi beberapa cap waktu. <br><a name="habracut"></a><br><h2>  Pemeriksaan Modul </h2><br>  Seperti yang ditunjukkan analisis utama, fitur utama BattlEye adalah enumerasi modul, dan sejak saat analisis terakhir, modul lain ditambahkan ke daftar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::misc::module_unknown1() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetProcAddress(current_module, <span class="hljs-string"><span class="hljs-string">"NSPStartup"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0x1B20</span></span> || optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0xE70</span></span> || optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0x1A38</span></span> || timestamp &gt;= <span class="hljs-number"><span class="hljs-number">0x5C600000</span></span> &amp;&amp; timestamp &lt; <span class="hljs-number"><span class="hljs-number">0x5C700000</span></span>) { report_module_unknown report = {}; report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span>; report.report_id = <span class="hljs-number"><span class="hljs-number">0x35</span></span>; report.val1 = <span class="hljs-number"><span class="hljs-number">0x5C0</span></span>; report.timestamp = timestamp; report.image_size = optional_header.size_of_image; report.entrypoint = optional_header.address_of_entry_point; report.directory_size = optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size; battleye::report(&amp;report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(report), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br>  Ini mungkin deteksi dll proxy tertentu, karena ukuran tabel redirect diperiksa di sini. <br><br><h2>  Judul jendela </h2><br>  Dalam analisis sebelumnya, berbagai penyedia cheat ditandai dengan nama jendela, tetapi sejak itu shellcode telah berhenti memeriksa header jendela ini.  Daftar judul jendela telah sepenuhnya diganti oleh: <br><br> <code>Chod's <br> Satan5</code> <br> <br><h2>  Nama gambar </h2><br>  BattlEye terkenal karena menggunakan metode deteksi yang sangat primitif, dan salah satunya adalah daftar nama hitam.  Setiap tahun, daftar nama gambar yang dilarang semakin lama, dan selama 11 bulan terakhir lima nama baru telah ditambahkan: <br><br> <code>frAQBc8W.dll <br> C:\\Windows\\mscorlib.ni.dll <br> DxtoryMM_x64.dll <br> Project1.dll <br> OWClient.dll <br></code> <br>  Perlu dicatat bahwa kehadiran modul dengan nama yang sesuai dengan salah satu item dalam daftar tidak akan berarti bahwa Anda akan segera dilarang.  Mesin pelaporan juga menyampaikan informasi modul dasar, yang kemungkinan besar digunakan untuk membedakan kode curang dari tabrakan di server BattlEye. <br><br><h2>  7-zip </h2><br>  7-Zip banyak digunakan dan terus digunakan oleh peserta dalam adegan cheat sebagai pengisi memori untuk rongga kode (kode-gua).  BattlEye mencoba menangani ini dengan melakukan pemeriksaan integritas yang <b>sangat</b> buruk, yang telah berubah sejak artikel saya sebelumnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_7zip() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"..\\..\\Plugins\\ZipUtility\\ThirdParty\\7zpp\\dll\\Win64\\7z.dll"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// --- REMOVED --- // if (module_handle &amp;&amp; *(int*)(module_handle + 0x1000) != 0xFF1441C7) // --- ADDED --- if (module_handle &amp;&amp; *(int*)(module_handle + 0x1008) != 0x83485348) { sevenzip_report.unknown_1 = 0; sevenzip_report.report_id = 0x46; sevenzip_report.unknown_2 = 0; sevenzip_report.data1 = *(__int64*)(module_handle + 0x1000; sevenzip_report.data2 = *(__int64*)(module_handle + 0x1008; battleye::report(&amp;sevenzip_report, sizeof(sevenzip_report), false); } }</span></span></code> </pre> <br>  Tampaknya para pengembang BattlEye telah menebak bahwa artikel saya sebelumnya telah menyebabkan banyak pengguna mem-bypass cek ini hanya dengan menyalin byte yang diinginkan ke lokasi yang diperiksa oleh BattlEye.  Bagaimana mereka memperbaiki situasi?  Kami menggeser verifikasi sebanyak delapan byte dan terus menggunakan metode buruk yang sama untuk memeriksa integritas.  Partisi executable read-only, dan yang perlu Anda lakukan adalah mengunduh 7-Zip dari disk dan membandingkan partisi yang dipindahkan satu sama lain;  jika ada perbedaan, maka ada sesuatu yang salah.  Serius, kawan, melakukan pemeriksaan integritas tidaklah sulit. <br><br><h2>  Pemeriksaan jaringan </h2><br>  Menghitung tabel TCP masih berfungsi, tetapi setelah saya merilis analisis sebelumnya yang mengkritik pengembang karena menandai alamat IP Cloudflare, mereka masih menghapus pemeriksaan ini.  Anti-cheat masih melaporkan port yang digunakan xera.ph untuk koneksi, tetapi pengembang menambahkan cek baru untuk menentukan apakah proses dengan koneksi memiliki perlindungan aktif (mungkin ini dilakukan menggunakan handler). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> network::scan_tcp_table { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(local_port_buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(local_port_buffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (iteration_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; iteration_index; &lt; <span class="hljs-number"><span class="hljs-number">500</span></span> ++iteration_index) { <span class="hljs-comment"><span class="hljs-comment">// GET NECESSARY SIZE OF TCP TABLE auto table_size = 0; GetExtendedTcpTable(0, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0); // ALLOCATE BUFFER OF PROPER SIZE FOR TCP TABLE auto allocated_ip_table = (MIB_TCPTABLE_OWNER_MODULE*)malloc(table_size); if (GetExtendedTcpTable(allocated_ip_table, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0) != NO_ERROR) goto cleanup; for (entry_index = 0; entry_index &lt; allocated_ip_table-&gt;dwNumEntries; ++entry_index) { // --- REMOVED --- // const auto ip_address_match_1 = // allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656B1468; // 104.20.107.101 // // const auto ip_address_match_2 = // allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656C1468; // 104.20.108.101 // +++ ADDED +++ const auto target_process = OpenProcess(QueryLimitedInformation, 0, ip_table-&gt;table[entry_index].dwOwningPid); const auto protected = target_process == INVALID_HANDLE &amp;&amp; GetLastError() == 0x57; if (!protected) { CloseHandle(target_process); return; } const auto port_match = allocated_ip_table-&gt;table[entry_index].dwRemotePort == 20480; for (port_index = 0; port_index &lt; 10 &amp;&amp; allocated_ip_table-&gt;table[entry_index].dwLocalPort != local_port_buffer[port_index]; ++port_index) { if (local_port_buffer[port_index]) continue tcp_table_report.unknown = 0; tcp_table_report.report_id = 0x48; tcp_table_report.module_id = 0x5B9; tcp_table_report.data = BYTE1(allocated_ip_table-&gt;table[entry_index].dwLocalPort) | (LOBYTE(allocated_ip_table-&gt;table[entry_index.dwLocalPort) &lt;&lt; 8; battleye::report(&amp;tcp_table_report, sizeof(tcp_table_report), false); local_port_buffer[port_index] = allocated_ip_table-&gt;table[entry_index].dwLocalPort; break } } cleanup: // FREE TABLE AND SLEEP free(allocated_ip_table); Sleep(10 } }</span></span></code> </pre> <br>  Terima kasih, Anda memilih dan abstrak <br><br><h2>  BattlEye Stack Bypass </h2><br>  Permainan meretas adalah permainan kucing dan tikus yang konstan, sehingga rumor trik baru menyebar seperti api.  Pada bagian ini, kita akan melihat teknik heuristik baru yang baru-baru ini ditambahkan ke gudang senjata kita oleh penyedia besar anti-cheat BattlEye.  Paling sering, teknik ini disebut stack walking.  Biasanya mereka diimplementasikan dengan memproses fungsi dan melalui tumpukan untuk mencari tahu siapa yang secara spesifik memanggil fungsi ini.  Mengapa Anda perlu melakukan ini?  Seperti program lainnya, peretasan gim video memiliki serangkaian fungsi terkenal yang mereka gunakan untuk mendapatkan informasi dari keyboard, output ke konsol, atau menghitung ekspresi matematika tertentu.  Selain itu, video game hacks suka menyembunyikan keberadaan mereka, baik di memori atau di disk, sehingga perangkat lunak anti-cheat tidak menemukannya.  Tetapi yang dilupakan oleh program cheat adalah mereka secara rutin memanggil fungsi dari perpustakaan lain, dan ini dapat digunakan untuk mendeteksi heurist secara curang.  Dengan mengimplementasikan mesin stack traversal untuk fungsi-fungsi seperti <code>std::print</code> , kita dapat menemukan cheat ini bahkan jika mereka bertopeng. <br><br>  BattlEye <strong>menerapkan</strong> "tumpukan bypass", meskipun fakta bahwa ini tidak diumumkan secara publik dan pada saat publikasi artikel hanya ada desas-desus.  Perhatikan tanda kutip - apa yang akan Anda lihat di sini sebenarnya bukan tur tumpukan nyata, tetapi hanya kombinasi memeriksa alamat pengirim dan dump program panggilan.  Implementasi stack traversal yang sebenarnya akan melalui stack dan menghasilkan stack panggilan nyata. <br><br>  Seperti yang saya jelaskan di artikel sebelumnya tentang BattlEye, sistem anti-cheat secara dinamis mengalirkan shellcode ke dalam game ketika sedang berjalan.  Kode shell ini memiliki ukuran dan tugas yang berbeda, dan tidak dikirimkan secara bersamaan.  Sifat luar biasa dari sistem semacam itu adalah bahwa para peneliti perlu menganalisis secara dinamis anti-cheat selama pertandingan multi-pemain, yang mempersulit penentuan karakteristik anti-cheat ini.  Hal ini juga memungkinkan anti-cheat untuk menerapkan berbagai tindakan pada pengguna yang berbeda, misalnya, untuk mentransfer modul invasif yang lebih dalam hanya kepada orang yang memiliki rasio pembunuhan dan kematian yang sangat tinggi, dan sejenisnya. <br><br>  Salah satu kode shell ini, BattlEye, bertanggung jawab untuk melakukan analisis tumpukan ini;  kita akan menyebutnya <em>shellcode8kb</em> karena sedikit lebih kecil dibandingkan dengan <em>shellcodemain</em> , yang saya dokumentasikan di <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">sini</a> .  Kode shell kecil ini menggunakan fungsi <strong>AddVectoredExceptionHandler</strong> menyiapkan handler pengecualian vektor dan kemudian mengatur jebakan interupsi pada fungsi-fungsi berikut: <br><br> <code>GetAsyncKeyState <br> GetCursorPos <br> IsBadReadPtr <br> NtUserGetAsyncKeyState <br> GetForegroundWindow <br> CallWindowProcW <br> NtUserPeekMessage <br> NtSetEvent <br> sqrtf <br> __stdio_common_vsprintf_s <br> CDXGIFactory::TakeLock <br> TppTimerpExecuteCallback</code> <br> <br>  Untuk melakukan ini, ia hanya berputar di sekitar daftar fungsi yang digunakan secara standar, mengatur instruksi pertama dari fungsi yang sesuai ke <strong>int3</strong> , yang digunakan sebagai breakpoint.  Setelah mengatur breakpoint, semua panggilan ke fungsi yang sesuai melewati penangan pengecualian yang memiliki akses penuh ke register dan tumpukan.  Memiliki akses ini, pawang pengecualian membuang alamat program panggilan dari atas tumpukan, dan jika salah satu kondisi heuristik terpenuhi, 32 byte fungsi panggilan dibuang dan dikirim ke server BattlEye dengan pengidentifikasi laporan <strong>0x31</strong> : <br><br><pre> <code class="cpp hljs">__int64 battleye::exception_handler(_EXCEPTION_POINTERS *exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exception-&gt;ExceptionRecord-&gt;ExceptionCode != STATUS_BREAKPOINT) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> caller_function = *(__int64 **)exception-&gt;ContextRecord-&gt;Rsp; MEMORY_BASIC_INFORMATION caller_memory_information = {}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> desired_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// QUERY THE MEMORY PAGE OF THE CALLER const auto call_failed = NtQueryVirtualMemory( GetCurrentProcess(), caller_function, MemoryBasicInformation, &amp;caller_memory_information, sizeof(caller_memory_information), &amp;desired_size) &lt; 0; // IS THE MEMORY SOMEHOW NOT COMMITTED? (WOULD SUGGEST VAD MANIPULATIUON) const auto non_commit = caller_memory_information.State != MEM_COMMIT; // IS THE PAGE EXECUTABLE BUT DOES NOT BELONG TO A PROPERLY LOADED MODULE? const auto foreign_image = caller_memory_information.Type != MEM_IMAGE &amp;&amp; caller_memory_information.RegionSize &gt; 0x2000; // IS THE CALL BEING SPOOFED BY NAMAZSO? const auto spoof = *(_WORD *)caller_function == 0x23FF; // jmp qword ptr [rbx] // FLAG ALL ANBORMALITIES if (call_failed || non_commit || foreign_image || spoof) { report_stack.unknown = 0; report_stack.report_id = 0x31; report_stack.hook_id = hook_id; report_stack.caller = (__int64)caller_function; report_stack.function_dump[0] = *caller_function; report_stack.function_dump[1] = caller_function[1]; report_stack.function_dump[2] = caller_function[2]; report_stack.function_dump[3] = caller_function[3]; if (!call_failed) { report_stack.allocation_base = caller_memory_information.AllocationBase; report_stack.base_address = caller_memory_information.BaseAddress; report_stack.region_size = caller_memory_information.RegionSize; report_stack.type_protect_state = caller_memory_information.Type | caller_memory_information.Protect | caller_memory_information.State; } battleye::report(&amp;report_stack, sizeof(report_stack), false); return -1; } }</span></span></code> </pre> <br>  Seperti yang dapat kita lihat, pengendali pengecualian membuang semua fungsi panggilan jika terjadi perubahan yang tidak serius pada halaman memori atau ketika fungsi tersebut tidak termasuk dalam modul proses yang diketahui (jenis halaman memori MEM_IMAGE tidak diatur oleh pembuat manual).  Itu juga membuang fungsi panggilan ketika gagal memanggil <strong>NtQueryVirtualMemory</strong> sehingga menipu tidak mengikat panggilan sistem ini dan menyembunyikan modul mereka dari tumpukan dump.  Kondisi terakhir sebenarnya cukup menarik, ini menandai semua fungsi panggilan yang menggunakan <strong>gadget jmp qword ptr [rbx]</strong> - metode yang digunakan untuk "menipu alamat pengirim".  Album ini <a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/268039-x64-return-address-spoofing-source-explanation.html">dirilis oleh</a> co-sekretaris saya, julukan namazso.  Tampaknya para pengembang BattlEye melihat bahwa orang menggunakan metode spoofing ini dalam gim mereka dan memutuskan untuk membidiknya secara langsung.  Perlu disebutkan di sini bahwa metode yang dijelaskan oleh namazsos berfungsi dengan baik, cukup gunakan gadget yang berbeda, atau sangat berbeda, atau hanya register yang berbeda - tidak masalah. <br><br>  Tip Pengembang BattlEye: <code>CDXGIFactory::TakeLock</code> dalam memori Anda salah karena Anda (secara tidak sengaja atau sengaja) mengaktifkan padding CC, yang sangat berbeda setiap kali Anda kompilasi.  Untuk kompatibilitas maksimum, Anda harus menghapus bantalan (byte pertama dalam tanda tangan) dan kemungkinan besar Anda akan menangkap lebih banyak curang :) <br><br>  Struktur lengkap yang dikirim ke server BattlEye terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unaligned</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">battleye_stack_report</span></span></span><span class="hljs-class"> {</span></span> __int8 unknown; __int8 report_id; __int8 val0; __int64 caller; __int64 function_dump[<span class="hljs-number"><span class="hljs-number">4</span></span>]; __int64 allocation_base; __int64 base_address; __int32 region_size; __int32 type_protect_state; };</code> </pre> <br><h2>  Pengakuan hypervisor di BattlEye </h2><br>  Permainan kucing dan tikus di bidang permainan peretasan terus menjadi sumber inovasi dalam eksploitasi dan perang melawan penipuan.  Penggunaan teknologi virtualisasi dalam permainan peretasan mulai berkembang secara aktif setelah munculnya hypervisor yang mudah digunakan seperti <a href="https://github.com/tandasat/DdiMon">DdiMon</a> Satoshi Tanda dan <a href="https://github.com/wbenny/hvpp">hvpp</a> Peter Benes.  Kedua proyek ini digunakan oleh sebagian besar penipu bayaran dari adegan hacker bawah tanah karena ambang masuk yang rendah dan dokumentasi terperinci.  Rilis ini kemungkinan akan mempercepat perlombaan senjata di bidang hypervisors, yang sekarang mulai mewujud dalam komunitas peretas game.  Inilah yang dikatakan administrator dari salah satu komunitas peretas game terbesar dengan julukan <a href="https://www.unknowncheats.me/">wlan</a> tentang situasi ini: <br><br><blockquote>  Dengan munculnya sistem hypervisor yang siap digunakan untuk permainan hacking, menjadi tidak terhindarkan bahwa anti-cheat seperti BattlEye akan fokus pada pengenalan umum virtualisasi. </blockquote><br>  Meluasnya penggunaan hypervisor disebabkan oleh peningkatan terbaru dalam anti-cheat, yang membuat peretas sangat sedikit kesempatan untuk memodifikasi game dengan cara tradisional.  Popularitas hypervisor dapat dijelaskan oleh kesederhanaan menghindari anti-cheat, karena virtualisasi menyederhanakan penyembunyian informasi menggunakan mekanisme seperti <a href="https://revers.engineering/syscall-hooking-via-extended-feature-enable-register-efer/">syscall hooks</a> dan <a href="https://www.anandtech.com/show/2480/10">virtualisasi MMU</a> . <br><br>  Baru-baru ini, BattlEye telah menerapkan pengenalan hypervisor umum seperti platform yang disebutkan di atas (DdiMon, hvpp) menggunakan deteksi berbasis waktu.  Pengakuan ini mencoba mendeteksi nilai waktu instruksi CPUID yang tidak standar.  CPUID adalah instruksi yang relatif murah untuk peralatan nyata, biasanya hanya membutuhkan dua ratus siklus, dan dalam lingkungan virtual, pelaksanaannya dapat memakan waktu sepuluh kali lebih banyak karena operasi yang tidak perlu yang disebabkan oleh mesin introspeksi.  Mesin introspeksi tidak seperti peralatan nyata, yang hanya melakukan operasi dengan cara yang diharapkan, karena berdasarkan kriteria sewenang-wenang ia melacak dan secara kondisional mengubah data yang dikembalikan ke tamu. <br><br>  <strong>Fakta menyenangkan:</strong> CPUID secara aktif digunakan dalam prosedur pengenalan sementara ini karena merupakan instruksi dengan output tanpa syarat, serta instruksi dengan serialisasi yang tidak terjangkau.  Ini berarti bahwa CPUID digunakan sebagai <a href="https://en.wikipedia.org/wiki/Memory_barrier">penghalang</a> dan memastikan bahwa instruksi sebelum dan sesudah diikuti;  pada saat yang sama, penentuan waktu menjadi independen dari pemesanan ulang instruksi yang biasa.  Anda juga dapat menggunakan instruksi seperti <a href="https://www.felixcloutier.com/x86/xsetbv">XSETBV</a> , yang juga melakukan jalan keluar tanpa syarat, tetapi untuk memastikan waktu yang bebas, ini akan memerlukan semacam instruksi penghalang sehingga tidak ada pemesanan ulang yang terjadi sebelum atau setelah itu, yang mempengaruhi keandalan pengaturan waktu. <br><br><h4>  Pengakuan </h4><br>  Berikut ini adalah prosedur pengenalan dari modul BattlEye ‚ÄúBEClient2‚Äù;  Saya melakukan reverse engineering dan membuat ulang kode di pseudo-C, dan kemudian mempostingnya di <a href="https://twitter.com/vm_call">twitter</a> .  Sehari setelah tweet saya, para pengembang BattlEye tiba-tiba mengubah kebingungan BEClient2, tampaknya berharap bahwa ini akan mencegah saya menganalisis modul.  Kebingungan sebelumnya tidak berubah selama lebih dari setahun, tetapi berubah sehari setelah tweet saya tentang hal itu - kecepatan yang mengesankan. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::take_time() { <span class="hljs-comment"><span class="hljs-comment">// SET THREAD PRIORITY TO THE HIGHEST const auto old_priority = SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL); // CALCULATE CYCLES FOR 1000MS const auto timestamp_calibrator = __rdtsc(); Sleep(1000); const auto timestamp_calibration = __rdtsc() - timestamp_calibrator; // TIME CPUID auto total_time = 0; for (std::size_t count = 0; count &lt; 0x6694; count++) { // SAVE PRE CPUID TIME const auto timestamp_pre = __rdtsc(); std::uint32_t cpuid_data[4] = {}; __cpuid(cpuid_data, 0); // SAVE THE DELTA total_time += __rdtsc() - timestamp_pre; } // SAVE THE RESULT IN THE GLOBAL REPORT TABLE battleye::report_table[0x1A8] = 10000000 * total_time / timestamp_calibration / 0x65; // RESTORE THREAD PRIORITY SetThreadPriority(GetCurrentThread(), old_priority); }</span></span></code> </pre> <br>  Seperti yang saya katakan di atas, ini adalah teknik pengenalan yang paling umum menggunakan instruksi yang diinterupsi tanpa syarat.  Namun, ini rentan terhadap waktu palsu, dan kami akan membicarakan ini secara rinci di bagian selanjutnya. <br><br><h4>  Bypass pengakuan </h4><br>  Metode pengenalan ini memiliki masalah.  Pertama, ini rentan terhadap waktu palsu, yang biasanya dilakukan dengan dua cara: dengan menggeser TSC di VMCS atau dengan mengurangi TSC setiap kali CPUID dieksekusi.  Ada banyak cara lain untuk menangani serangan berbasis waktu, tetapi yang terakhir jauh lebih mudah diimplementasikan, karena Anda dapat menjamin bahwa waktu pelaksanaan instruksi akan berada dalam satu atau dua siklus siklus sinkronisasi eksekusi pada peralatan nyata.  Kesulitan menemukan teknik pemalsuan saat ini tergantung pada pengalaman pengembang.  Di bagian selanjutnya, kita akan melihat pemalsuan waktu dan meningkatkan implementasi yang dibuat di BattlEye.  Alasan kedua untuk cacat metode pengenalan ini adalah bahwa keterlambatan CPUID (runtime) dalam prosesor yang berbeda sangat berbeda tergantung pada nilai lembar.  Mungkin perlu hingga 70-300 siklus jam untuk menyelesaikannya.  Masalah ketiga dengan prosedur pengenalan ini adalah menggunakan SetThreadPriority.  Fungsi Windows ini digunakan untuk mengatur nilai prioritas dari deskriptor aliran yang diberikan, namun OS tidak selalu mendengarkan permintaan.  Fungsi ini hanyalah saran untuk meningkatkan prioritas utas, dan tidak ada jaminan bahwa itu akan terjadi.  Dengan demikian, ada kemungkinan bahwa metode ini akan dipengaruhi oleh interupsi atau proses lainnya. <br><br>  Dalam hal ini, mudah untuk melewati pengenalan, dan teknik pemalsuan waktu yang dijelaskan secara efektif mengalahkan metode pengenalan ini.  Jika pengembang BattlEye ingin meningkatkan metode ini, maka bagian berikut memberikan beberapa rekomendasi. <br><br><h4>  Perbaikan </h4><br>  Fitur ini dapat ditingkatkan dengan banyak cara.  Pertama, Anda dapat dengan sengaja menonaktifkan interupsi dan memaksakan prioritas utas dengan mengubah CR8 ke IRQL tertinggi.  Ini juga akan ideal untuk mengisolasi cek ini dalam satu inti CPU.  Peningkatan lainnya: Anda harus menggunakan timer yang berbeda, tetapi banyak dari mereka yang tidak seakurat TSC, tetapi ada satu timer seperti yang disebut APERF, atau Clock Kinerja Aktual.  Saya merekomendasikan timer ini karena lebih sulit untuk menipu dengan itu dan hanya mengakumulasi penghitung ketika prosesor logis dalam kondisi daya C0.  Ini adalah alternatif yang bagus untuk menggunakan TSC.  Anda juga dapat menggunakan ACPI, HPET, timer PIT, timer GPU, timer NTP, atau timer PPERF, yang mirip dengan APERF, tetapi menghitung ukuran yang dianggap sebagai instruksi pelaksanaan.  Kerugiannya adalah Anda harus mengaktifkan HWP, yang dapat dinonaktifkan oleh operator perantara, dan oleh karena itu tidak berguna. <br><br>  Di bawah ini adalah versi perbaikan dari prosedur pengenalan yang harus dilakukan di kernel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::take_time() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cpuid_regs[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {}; _disable(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_pre = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; __cpuid(&amp;cpuid_regs, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_post = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_diff = aperf_post - aperf_pre; <span class="hljs-comment"><span class="hljs-comment">// CPUID IET ARRAY STORE // BATTLEYE REPORT TABLE STORE _enable(); }</span></span></code> </pre> <br>  <strong>Catatan:</strong> IET adalah singkatan dari Instruction Execution Time. <br><br>  Namun, prosedur ini masih bisa sangat tidak dapat diandalkan dalam mendeteksi hypervisor umum, karena runtime CPUID dapat sangat bervariasi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akan lebih baik untuk membandingkan IET dari dua instruksi. Salah satunya harus memiliki penundaan eksekusi yang lebih lama daripada CPUID. Sebagai contoh, itu mungkin FYL2XP1 - instruksi aritmatika yang membutuhkan waktu lebih lama untuk menyelesaikan daripada rata-rata IET dari instruksi CPUID. Selain itu, tidak menyebabkan jebakan dalam hypervisor dan waktunya dapat diukur dengan andal. Menggunakan kedua fungsi ini, fungsi pembuatan profil dapat membuat larik untuk menyimpan instruksi IET, CPUID dan FYL2XP1. Dengan menggunakan pengatur waktu APERF, dimungkinkan untuk mendapatkan jam awal dari instruksi aritmatika, menjalankan instruksi dan menghitung delta jam untuknya. Hasil dapat disimpan dalam array IET untuk siklus profil N, mendapatkan nilai rata-rata, dan mengulangi proses untuk CPUID. Jika waktu pelaksanaan instruksi CPUID lebih panjang dari instruksi aritmatika,maka ini adalah tanda yang dapat diandalkan bahwa sistem ini virtual, karena instruksi aritmatika dalam keadaan apa pun tidak dapat menghabiskan lebih banyak waktu daripada mengeksekusi CPUID untuk mendapatkan informasi tentang produsen atau versi. Prosedur pengenalan semacam itu juga akan dapat mendeteksi mereka yang menggunakan offset / penskalaan TSC.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya ulangi, pengembang harus memaksakan pengikatan pada inti komputasi untuk melakukan pemeriksaan ini pada satu inti, menonaktifkan interupsi dan memaksa IRQL untuk menetapkan nilai maksimum untuk menjamin data yang konsisten dan andal. </font><font style="vertical-align: inherit;">Akan mengejutkan jika para pengembang BattlEye memutuskan untuk mengimplementasikan ini, karena itu membutuhkan lebih banyak usaha. </font><font style="vertical-align: inherit;">Dalam driver kernel, BattlEye makan dua rutinitas pengenalan mesin virtual lainnya, tetapi ini adalah topik untuk artikel lain.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484420/">https://habr.com/ru/post/id484420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484408/index.html">Era RUTM</a></li>
<li><a href="../id484410/index.html">Kebiasaan pengembang yang berguna</a></li>
<li><a href="../id484412/index.html">Prosesor NXP S32G untuk arsitektur elektronik otomotif modern</a></li>
<li><a href="../id484414/index.html">Memilih pengarsip untuk log cadangan</a></li>
<li><a href="../id484418/index.html">CEO Motoriki Ilya Chekh: Terkadang mereka mengharapkan pekerjaan ideal dari prostesis eksperimental, dan kemudian mereka kecewa</a></li>
<li><a href="../id484424/index.html">Nvidia Orin - sebuah chip untuk kendaraan robot</a></li>
<li><a href="../id484426/index.html">Aku dan mopedku. Penskalaan inefisiensi</a></li>
<li><a href="../id484428/index.html">Memilih ide untuk memulai tanpa investor: dari sebaliknya</a></li>
<li><a href="../id484430/index.html">Kacamata VR berkemampuan HDR pertama di dunia: apa yang diketahui tentang prototipe dari Panasonic</a></li>
<li><a href="../id484436/index.html">Opensource tidak berterima: pengembang server web tercepat telah menghapus repositori - Pembaruan penting</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>