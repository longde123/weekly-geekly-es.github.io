<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•à üë©‚Äçüíª üåè Erstellen Sie Tools in maschinellen Lernprojekten, eine √úbersicht üö§ üíô üë≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe mich √ºber maschinelles Lernen / datenwissenschaftliche Projektstruktur / Workflow gewundert und verschiedene Meinungen zu diesem Thema gelese...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie Tools in maschinellen Lernprojekten, eine √úbersicht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451962/"> Ich habe mich √ºber maschinelles Lernen / datenwissenschaftliche Projektstruktur / Workflow gewundert und verschiedene Meinungen zu diesem Thema gelesen.  Und wenn Leute anfangen, √ºber Workflows zu sprechen, m√∂chten sie, dass ihre Workflows reproduzierbar sind.  Es gibt viele Posts, die empfehlen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">make</a> zu verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> um den Workflow reproduzierbar zu halten.  Obwohl <code>make</code> sehr stabil und weit verbreitet ist, mag ich pers√∂nlich plattform√ºbergreifende L√∂sungen.  Es ist immerhin 2019, nicht 1977. Man kann argumentieren, dass make plattform√ºbergreifend ist, aber in Wirklichkeit werden Sie Probleme haben und Zeit damit verbringen, Ihr Werkzeug zu reparieren, anstatt die eigentliche Arbeit zu erledigen.  Also habe ich beschlossen, mich umzuschauen und herauszufinden, welche anderen Tools verf√ºgbar sind.  Ja, ich habe beschlossen, einige Zeit mit Werkzeugen zu verbringen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aff/fbf/656/afffbf6566a6e67ea6427d28d76d7eea.png" alt="Bild"></div><br>  Dieser Beitrag ist eher eine Einladung zum Dialog als ein Tutorial.  Vielleicht ist Ihre L√∂sung perfekt.  Wenn ja, wird es interessant sein, davon zu h√∂ren. <br><br>  In diesem Beitrag werde ich ein kleines Python-Projekt verwenden und die gleichen Automatisierungsaufgaben mit verschiedenen Systemen ausf√ºhren: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CMake</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pybuilder</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pynt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fertiger</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">doit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Luigi</a> </li></ul><br>  Am Ende des Beitrags wird eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleichstabelle angezeigt</a> . <br><a name="habracut"></a><br>  Die meisten Tools, die ich mir ansehen werde, sind als <em>Build-Automatisierungssoftware</em> oder <em>Build-Systeme bekannt</em> .  Es gibt unz√§hlige von ihnen in allen verschiedenen Geschmacksrichtungen, Gr√∂√üen und Komplexit√§ten.  Die Idee ist dieselbe: Der Entwickler definiert Regeln f√ºr die automatisierte und konsistente Erstellung einiger Ergebnisse.  Ein Ergebnis kann beispielsweise ein Bild mit einem Diagramm sein.  Um dieses Bild zu erstellen, m√ºsste man die Daten herunterladen, die Daten bereinigen und einige Datenmanipulationen durchf√ºhren (wirklich ein klassisches Beispiel).  Sie k√∂nnen mit ein paar Shell-Skripten beginnen, die den Job erledigen.  Wenn Sie ein Jahr sp√§ter zum Projekt zur√ºckkehren, wird es schwierig sein, sich alle Schritte und deren Reihenfolge zu merken, die Sie ausf√ºhren m√ºssen, um dieses Bild zu erstellen.  Die naheliegende L√∂sung besteht darin, alle Schritte zu dokumentieren.  Gute Nachrichten!  Mit Build-Systemen k√∂nnen Sie die Schritte in Form eines Computerprogramms dokumentieren.  Einige Build-Systeme √§hneln Ihren Shell-Skripten, verf√ºgen jedoch √ºber zus√§tzliche Schnickschnack. <br><br>  Die Grundlage dieses Beitrags ist eine Reihe von Beitr√§gen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mateusz Bednarski</a> zum automatisierten Workflow f√ºr ein maschinelles Lernprojekt.  Mateusz erkl√§rt seine Ansichten und liefert Rezepte f√ºr die Verwendung von <code>make</code> .  Ich ermutige Sie, zuerst seine Beitr√§ge zu √ºberpr√ºfen.  Ich werde haupts√§chlich seinen Code verwenden, aber mit verschiedenen Build-Systemen. <br><br>  Wenn Sie mehr √ºber <code>make</code> erfahren m√∂chten, finden Sie im Folgenden einige Referenzen f√ºr einige Beitr√§ge.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brooke Kennedy</a> bietet einen allgemeinen √úberblick in 5 einfachen Schritten, um Ihr Data Science-Projekt reproduzierbar zu machen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zachary Jones</a> gibt weitere Details zur Syntax und zu den Funktionen sowie Links zu anderen Posts.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">David Stevens</a> schreibt einen sehr Hype-Beitrag dar√ºber, warum Sie <code>make</code> sofort verwenden m√ºssen.  Er liefert sch√∂ne Beispiele, die <i>den alten</i> und <i>den neuen Weg vergleichen</i> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Samuel Lampa</a> hingegen schreibt dar√ºber, warum die Verwendung von <code>make</code> eine schlechte Idee ist. <br><br>  Meine Auswahl an Build-Systemen ist weder umfassend noch unvoreingenommen.  Wenn Sie Ihre Liste erstellen m√∂chten, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> m√∂glicherweise ein guter Ausgangspunkt.  Wie oben erw√§hnt, werde ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CMake</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyBuilder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pynt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paver</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Doit</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Luigi behandeln</a> .  Die meisten Tools in dieser Liste basieren auf Python und sind sinnvoll, da sich das Projekt in Python befindet.  In diesem Beitrag wird nicht beschrieben, wie die Tools installiert werden.  Ich gehe davon aus, dass Sie Python ziemlich gut beherrschen. <br><br>  Ich bin haupts√§chlich daran interessiert, diese Funktionalit√§t zu testen: <br><br><ol><li>  Angeben einiger Ziele mit Abh√§ngigkeiten.  Ich m√∂chte sehen, wie es geht und wie einfach es ist. </li><li>  √úberpr√ºfen, ob inkrementelle Builds m√∂glich sind.  Dies bedeutet, dass das Build-System nicht neu erstellt, was seit dem letzten Lauf nicht ge√§ndert wurde, d. H. Sie m√ºssen Ihre Rohdaten nicht erneut herunterladen.  Eine andere Sache, nach der ich suchen werde, sind inkrementelle Builds, wenn sich die Abh√§ngigkeit √§ndert.  Stellen Sie sich vor, wir haben ein Diagramm der Abh√§ngigkeiten <code>A -&gt; B -&gt; C</code>  Wird Ziel <code>C</code> wiederhergestellt, wenn sich <code>B</code> √§ndert?  Wenn ein? </li><li>  √úberpr√ºfen, ob eine Neuerstellung ausgel√∂st wird, wenn der Quellcode ge√§ndert wird, d. H. Wir √§ndern den Parameter des generierten Diagramms. Beim n√§chsten Erstellen des Bildes muss es neu erstellt werden. </li><li>  √úberpr√ºfen der M√∂glichkeiten zum Bereinigen von Build-Artefakten, d. H. Entfernen von Dateien, die w√§hrend des Builds erstellt wurden, und Zur√ºcksetzen auf den sauberen Quellcode. </li></ol><br>  Ich werde nicht alle Build-Ziele aus Mateusz 'Post verwenden, nur drei davon, um die Prinzipien zu veranschaulichen. <br><br>  Der gesamte Code ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verf√ºgbar. <br><br><h2><a name="CMake"></a>  CMake </h2><br>  CMake ist ein Build-Skript-Generator, der Eingabedateien f√ºr verschiedene Build-Systeme generiert.  Und sein Name steht f√ºr plattform√ºbergreifende Marke.  CMake ist ein Software-Engineering-Tool.  Das Hauptanliegen ist das Erstellen von ausf√ºhrbaren Dateien und Bibliotheken.  CMake wei√ü also, wie man <i>Ziele</i> aus dem Quellcode in unterst√ºtzten Sprachen erstellt.  CMake wird in zwei Schritten ausgef√ºhrt: Konfiguration und Generierung.  W√§hrend der Konfiguration ist es m√∂glich, den zuk√ºnftigen Build nach Bedarf zu konfigurieren.  In diesem Schritt werden beispielsweise vom Benutzer bereitgestellte Variablen angegeben.  Die Generierung ist normalerweise unkompliziert und erzeugt Dateien, mit denen Build-Systeme arbeiten k√∂nnen.  Mit CMake k√∂nnen Sie weiterhin <code>make</code> , aber anstatt Makefile direkt zu schreiben, schreiben Sie eine CMake-Datei, die das Makefile f√ºr Sie generiert. <br><br>  Ein weiteres wichtiges Konzept ist, dass CMake <i>Out-of-Source-Builds</i> f√∂rdert.  Out-of-Source-Builds halten den Quellcode von Artefakten fern, die er erzeugt.  Dies ist sehr sinnvoll f√ºr ausf√ºhrbare Dateien, bei denen eine einzelne Quellcodebasis unter verschiedenen CPU-Architekturen und Betriebssystemen kompiliert werden kann.  Dieser Ansatz kann jedoch der Arbeitsweise vieler Datenwissenschaftler widersprechen.  Es scheint mir, dass die Data Science Community tendenziell eine hohe Kopplung von Daten, Code und Ergebnissen aufweist. <br><br>  Mal sehen, was wir brauchen, um unsere Ziele mit CMake zu erreichen.  Es gibt zwei M√∂glichkeiten, benutzerdefinierte Dinge in CMake zu definieren: benutzerdefinierte Ziele und benutzerdefinierte Befehle.  Leider m√ºssen wir beide verwenden, was zu mehr Typisierung im Vergleich zu Vanila-Makefile f√ºhrt.  Ein benutzerdefiniertes Ziel wird als immer veraltet angesehen, d. H. Wenn es ein Ziel zum Herunterladen von Rohdaten gibt, l√§dt CMake es immer wieder herunter.  Eine Kombination aus benutzerdefiniertem Befehl und benutzerdefiniertem Ziel erm√∂glicht es, Ziele auf dem neuesten Stand zu halten. <br><br>  F√ºr unser Projekt erstellen wir eine Datei mit dem Namen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CMakeLists.txt</a> und legen sie im Stammverzeichnis des Projekts ab.  Schauen wir uns den Inhalt an: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">cmake_minimum_required</span></span>(VERSION <span class="hljs-number"><span class="hljs-number">3.14</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> FATAL_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">project</span></span>(Cmake_in_ml VERSION <span class="hljs-number"><span class="hljs-number">0.1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> LANGUAGES NONE)</code> </pre><br>  Dieser Teil ist grundlegend.  Die zweite Zeile definiert den Namen Ihres Projekts und Ihre Version und gibt an, dass wir keine integrierte Sprachunterst√ºtzung verwenden (Sinus werden wir Python-Skripte nennen). <br><br>  Unser erstes Ziel wird den IRIS-Datensatz herunterladen: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(IRIS_URL <span class="hljs-string"><span class="hljs-string">"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"</span></span> CACHE <span class="hljs-keyword"><span class="hljs-keyword">STRING</span></span> <span class="hljs-string"><span class="hljs-string">"URL to the IRIS data"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_DIR <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/raw) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_FILE <span class="hljs-variable"><span class="hljs-variable">${IRIS_DIR}</span></span>/iris.csv) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Downloading IRIS."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/download.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_URL}</span></span> <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Done. Checkout ${IRIS_FILE}."</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(rawdata ALL DEPENDS <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span>)</code> </pre><br>  Die erste Zeile definiert den Parameter <code>IRIS_URL</code> , der dem Benutzer w√§hrend des Konfigurationsschritts zur Verf√ºgung gestellt wird.  Wenn Sie die CMake-GUI verwenden, k√∂nnen Sie diese Variable √ºber die GUI festlegen: <br><br><img src="https://habrastorage.org/webt/oo/za/pj/oozapjujvjg_q86ndg6r7c5u36a.png"><br><br>  Als N√§chstes definieren wir Variablen mit dem heruntergeladenen Speicherort des IRIS-Datasets.  Dann f√ºgen wir einen benutzerdefinierten Befehl hinzu, der <code>IRIS_FILE</code> als Ausgabe erzeugt.  Am Ende definieren wir benutzerdefinierte Ziel- <code>rawdata</code> , die von <code>rawdata</code> abh√§ngen. <code>IRIS_FILE</code> bedeutet, dass zum Erstellen von <code>rawdata</code> <code>IRIS_FILE</code> muss.  Option <code>ALL</code> des benutzerdefinierten Ziels besagt, dass <code>rawdata</code> eines der zu erstellenden Standardziele sind.  Beachten Sie, dass ich <code>CMAKE_CURRENT_SOURCE_DIR</code> verwende, um die heruntergeladenen Daten im <code>CMAKE_CURRENT_SOURCE_DIR</code> und nicht im Build-Ordner zu speichern.  Dies ist nur, um es das gleiche wie Mateusz zu machen. <br><br>  Okay, mal sehen, wie wir es nutzen k√∂nnen.  Ich f√ºhre es derzeit auf Windows mit installiertem MinGW-Compiler aus.  M√∂glicherweise m√ºssen Sie die Generatoreinstellung an Ihre Bed√ºrfnisse anpassen (f√ºhren Sie <code>cmake --help</code> , um die Liste der verf√ºgbaren Generatoren <code>cmake --help</code> ).  Starten Sie das Terminal und wechseln Sie in den √ºbergeordneten Ordner des Quellcodes. <br><br><pre> <code class="bash hljs">mkdir overcome-the-chaos-build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> overcome-the-chaos-build cmake -G <span class="hljs-string"><span class="hljs-string">"MinGW Makefiles"</span></span> ../overcome-the-chaos</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text">  - Konfiguration abgeschlossen <br>  - Generieren erledigt <br>  - Build-Dateien wurden geschrieben in: C: / home / workspace / √ºberwinden-das-Chaos-Build <br></div></div><br>  Mit modernem CMake k√∂nnen wir das Projekt direkt aus CMake erstellen.  Dieser Befehl ruft <code>build all</code> Befehl <code>build all</code> : <br><br><pre> <code class="bash hljs">cmake --build .</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text">  Scannen von Abh√§ngigkeiten von Ziel-Rohdaten <br>  [100%] Ziel-Rohdaten erstellt <br></div></div><br>  Wir k√∂nnen auch die Liste der verf√ºgbaren Ziele anzeigen: <br><br><pre> <code class="bash hljs">cmake --build . --target <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  Und wir k√∂nnen heruntergeladene Dateien entfernen durch: <br><br><pre> <code class="bash hljs">cmake --build . --target clean</code> </pre><br>  Stellen Sie sicher, dass wir das saubere Ziel nicht manuell erstellen mussten. <br><br>  Gehen wir nun zum n√§chsten Ziel - den vorverarbeiteten IRIS-Daten.  Mateusz erstellt zwei Dateien aus einer einzigen Funktion: <code>processed.pickle</code> und <code>processed.xlsx</code> .  Sie k√∂nnen sehen, wie er diese Excel-Datei mit <code>rm</code> mit Platzhalter bereinigt.  Ich denke, das ist kein sehr guter Ansatz.  In CMake haben wir zwei M√∂glichkeiten, damit umzugehen.  Die erste Option ist die Verwendung der Verzeichniseigenschaft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ADDITIONAL_MAKE_CLEAN_FILES</a> .  Der Code lautet: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(PROCESSED_FILE <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/processed/processed.pickle) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Additional files to clean set_property(DIRECTORY PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx )</span></span></code> </pre><br>  Die zweite Option besteht darin, eine Liste von Dateien als benutzerdefinierte Befehlsausgabe anzugeben: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">LIST</span></span>(APPEND PROCESSED_FILE <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.pickle"</span></span> <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> data/processed/processed.pickle --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> src/data/preprocess.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>)</code> </pre><br>  In diesem Fall habe ich die Liste erstellt, sie jedoch nicht im benutzerdefinierten Befehl verwendet.  Ich kenne keine M√∂glichkeit, auf Ausgabeargumente eines benutzerdefinierten Befehls darin zu verweisen. <br><br>  Eine weitere interessante Sache ist die Verwendung von <code>depends</code> in diesem benutzerdefinierten Befehl.  Wir legen die Abh√§ngigkeit nicht nur von einem benutzerdefinierten Ziel fest, sondern auch von der Ausgabe und dem Python-Skript.  Wenn wir <code>IRIS_FILE</code> keine Abh√§ngigkeit <code>IRIS_FILE</code> , <code>iris.csv</code> manuelle √Ñndern von <code>iris.csv</code> nicht zur <code>IRIS_FILE</code> des <code>preprocess</code> .  Nun, Sie sollten Dateien in Ihrem Build-Verzeichnis zun√§chst nicht manuell √§ndern.  Lass es dich nur wissen.  Weitere Details in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sam Thursfields Beitrag</a> .  Die Abh√§ngigkeit zum Python-Skript wird ben√∂tigt, um das Ziel neu zu erstellen, wenn sich das Python-Skript √§ndert. <br><br>  Und schlie√ülich das dritte Ziel: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(EXPLORATORY_IMG <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/reports/figures/exploratory.png) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/visualization/exploratory.py <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> src/visualization/exploratory.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(exploratory DEPENDS <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span>)</code> </pre><br>  Dieses Ziel ist im Grunde das gleiche wie das zweite. <br><br>  Zum Abschluss.  CMake sieht chaotisch und schwieriger aus als Make.  In der Tat kritisieren viele Leute CMake wegen seiner Syntax.  Nach meiner Erfahrung wird das Verst√§ndnis kommen und es ist absolut m√∂glich, auch sehr komplizierte CMake-Dateien zu verstehen. <br><br>  Sie werden immer noch viel selbst kleben, da Sie die richtigen Variablen weitergeben m√ºssen.  Ich sehe keine einfache M√∂glichkeit, die Ausgabe eines benutzerdefinierten Befehls in einem anderen zu referenzieren.  Es scheint m√∂glich zu sein, dies √ºber benutzerdefinierte Ziele zu tun. <br><br><h2><a name="PyBuilder"></a>  Pybuilder </h2><br>  Der PyBuilder-Teil ist sehr kurz.  Ich habe Python 3.7 in meinem Projekt verwendet und PyBuilder aktuelle Version 0.11.17 unterst√ºtzt es nicht.  Die vorgeschlagene L√∂sung ist die Verwendung der Entwicklungsversion.  Diese Version ist jedoch an pip v9 gebunden.  Pip ist zum Zeitpunkt des Schreibens Version 19.3.  Schade.  Nachdem ich ein bisschen herumgespielt hatte, funktionierte es bei mir √ºberhaupt nicht.  Die PyBuilder-Bewertung war von kurzer Dauer. <br><br><h2><a name="pynt"></a>  pynt </h2><br>  Pynt basiert auf Python, was bedeutet, dass wir Python-Funktionen direkt verwenden k√∂nnen.  Es ist nicht erforderlich, sie mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klick</a> zu verpacken und eine Befehlszeilenschnittstelle bereitzustellen.  Pynt kann jedoch auch Shell-Befehle ausf√ºhren.  Ich werde Python-Funktionen verwenden. <br><br>  Build-Befehle werden in einer Datei <code>build.py</code> .  Ziele / Aufgaben werden mit Funktionsdekoratoren erstellt.  Aufgabenabh√§ngigkeiten werden √ºber denselben Dekorator bereitgestellt. <br><br>  Da ich Python-Funktionen verwenden m√∂chte, muss ich sie in das Build-Skript importieren.  Pynt enth√§lt das aktuelle Verzeichnis nicht als Python-Skript. Schreiben Sie also Folgendes: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  wird nicht funktionieren.  Wir m√ºssen tun: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys sys.path.append(os.path.join(os.path.dirname(__file__), <span class="hljs-string"><span class="hljs-string">'.'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  Meine anf√§ngliche <code>build.py</code> Datei war wie <code>build.py</code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python import os import sys sys.path.append(os.path.join(os.path.dirname(__file__), '.')) from pynt import task from path import Path import glob from src.data.download import pydownload_file from src.data.preprocess import pypreprocess iris_file = 'data/raw/iris.csv' processed_file = 'data/processed/processed.pickle' @task() def rawdata(): '''Download IRIS dataset''' pydownload_file('https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data', iris_file) @task() def clean(): '''Clean all build artifacts''' patterns = ['data/raw/*.csv', 'data/processed/*.pickle', 'data/processed/*.xlsx', 'reports/figures/*.png'] for pat in patterns: for fl in glob.glob(pat): Path(fl).remove() @task(rawdata) def preprocess(): '''Preprocess IRIS dataset''' pypreprocess(iris_file, processed_file, 'data/processed/processed.xlsx')</span></span></code> </pre><br>  Und das <code>preprocess</code> hat nicht funktioniert.  Es beschwerte sich st√§ndig √ºber Eingabeargumente der <code>pypreprocess</code> Funktion.  Es scheint, dass Pynt optionale Funktionsargumente nicht sehr gut verarbeitet.  Ich musste das Argument f√ºr die Erstellung der Excel-Datei entfernen.  Denken Sie daran, wenn Ihr Projekt Funktionen mit optionalen Argumenten hat. <br><br>  Wir k√∂nnen pynt aus dem Ordner des Projekts ausf√ºhren und alle verf√ºgbaren Ziele auflisten: <br><br><pre> <code class="bash hljs">pynt -l</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text"><pre> <code class="bash hljs">Tasks <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> build file build.py: clean Clean all build artifacts exploratory Make an image with pairwise distribution preprocess Preprocess IRIS dataset rawdata Download IRIS dataset Powered by pynt 0.8.2 - A Lightweight Python Build Tool.</code> </pre><br></div></div><br>  Machen wir die paarweise Verteilung: <br><br><pre> <code class="bash hljs">pynt exploratory</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text"><pre> <code class="bash hljs">[ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] Downloading from https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data to data/raw/iris.csv [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] Preprocessing data [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ] Plotting pairwise distribution... [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ]</code> </pre><br></div></div><br>  Wenn wir jetzt denselben Befehl erneut <code>pynt exploratory</code> (dh <code>pynt exploratory</code> ), wird eine vollst√§ndige <code>pynt exploratory</code> .  Pynt hat nicht verfolgt, dass sich nichts ge√§ndert hat. <br><br><h2><a name="Paver"></a>  Fertiger </h2><br>  Paver sieht fast genauso aus wie Pynt.  Es unterscheidet sich geringf√ºgig in einer Weise, wie man Abh√§ngigkeiten zwischen Zielen definiert (ein anderer Dekorateur <code>@needs</code> ).  Paver f√ºhrt jedes Mal eine vollst√§ndige Neuerstellung durch und spielt nicht gut mit Funktionen, die optionale Argumente haben.  Bauanweisungen finden Sie in der Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pavement.py</a> . <br><br><h2><a name="doit"></a>  doit </h2><br>  Doit scheint ein Versuch zu sein, ein wirklich erstelltes Automatisierungstool in Python zu erstellen.  Es kann Python-Code und Shell-Befehle ausf√ºhren.  Es sieht ziemlich vielversprechend aus.  Was (im Kontext unserer spezifischen Ziele) zu fehlen scheint, ist die F√§higkeit, mit Abh√§ngigkeiten zwischen Zielen umzugehen.  Angenommen, wir m√∂chten eine kleine Pipeline erstellen, in der die Ausgabe von Ziel A als Eingabe von Ziel B verwendet wird. Nehmen wir an, wir verwenden Dateien als Ausgaben. Ziel A erstellt also eine Datei mit dem Namen <code>outA</code> . <br><br><img src="https://habrastorage.org/webt/xh/te/ol/xhteolpanywbjxanltb8uxdsoly.png"><br><br>  Um eine solche Pipeline zu erstellen, <code>outA</code> wir die Datei <code>outA</code> zweimal in Ziel A angeben (als Ergebnis eines Ziels, aber auch den Namen als Teil der Zielausf√ºhrung zur√ºckgeben).  Dann m√ºssen wir es als Eingabe f√ºr Ziel B angeben. Es gibt also insgesamt 3 Stellen, an denen wir Informationen √ºber die Datei <code>outA</code> .  Und selbst nachdem wir dies getan haben, f√ºhrt die √Ñnderung der Datei <code>outA</code> nicht zu einer automatischen <code>outA</code> von Ziel B. Dies bedeutet, dass doit nur dann pr√ºft, ob Ziel B auf dem neuesten Stand ist, ohne dass eines √ºberpr√ºft wird der Abh√§ngigkeiten.  Um dies zu √ºberwinden, m√ºssen wir <code>outA</code> viermal angeben - auch als <code>outA</code> von Ziel B. Ich sehe dies als Nachteil.  Sowohl Make als auch CMake k√∂nnen mit solchen Situationen richtig umgehen. <br><br>  Abh√§ngigkeiten in doit sind dateibasiert und werden als Zeichenfolgen ausgedr√ºckt.  Dies bedeutet, dass die Abh√§ngigkeiten <code>./myfile.txt</code> und <code>myfile.txt</code> als unterschiedlich angesehen werden.  Wie ich oben geschrieben habe, finde ich die Art und Weise, wie Informationen von Ziel zu Ziel (bei Verwendung von Python-Zielen) weitergegeben werden, etwas seltsam.  Das Ziel hat eine Liste von Artefakten, die es produzieren wird, aber ein anderes Ziel kann sie nicht verwenden.  Stattdessen muss die Python-Funktion, die das Ziel bildet, ein W√∂rterbuch zur√ºckgeben, auf das in einem anderen Ziel zugegriffen werden kann.  Sehen wir uns ein Beispiel an: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_preprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Preprocess IRIS dataset"""</span></span> pickle_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.pickle'</span></span> excel_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.xlsx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'file_dep'</span></span>: [<span class="hljs-string"><span class="hljs-string">'src/data/preprocess.py'</span></span>], <span class="hljs-string"><span class="hljs-string">'targets'</span></span>: [pickle_file, excel_file], <span class="hljs-string"><span class="hljs-string">'actions'</span></span>: [doit_pypreprocess], <span class="hljs-string"><span class="hljs-string">'getargs'</span></span>: {<span class="hljs-string"><span class="hljs-string">'input_file'</span></span>: (<span class="hljs-string"><span class="hljs-string">'rawdata'</span></span>, <span class="hljs-string"><span class="hljs-string">'filename'</span></span>)}, <span class="hljs-string"><span class="hljs-string">'clean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, }</code> </pre><br>  Hier h√§ngt der <code>rawdata</code> von den <code>rawdata</code> .  Die Abh√§ngigkeit wird √ºber <code>getargs</code> Eigenschaft <code>getargs</code> bereitgestellt.  Es hei√üt, dass das Argument <code>input_file</code> der Funktion <code>doit_pypreprocess</code> der Ausgabedateiname der Ziel- <code>rawdata</code> .  Schauen Sie sich das vollst√§ndige Beispiel in der Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dodo.py an.</a> <br><br>  Es kann sich lohnen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Erfolgsgeschichten</a> von doit zu lesen.  Es hat definitiv nette Funktionen wie die M√∂glichkeit, eine benutzerdefinierte, aktuelle Zielpr√ºfung bereitzustellen. <br><br><h2><a name="Luigi"></a>  Luigi </h2><br>  Luigi unterscheidet sich von anderen Tools, da es sich um ein System zum Bau komplexer Pipelines handelt.  Es erschien auf meinem Radar, nachdem mir ein Kollege erz√§hlt hatte, dass er Make ausprobiert hatte, es nie unter Windows / Linux verwenden konnte und nach Luigi zog. <br><br>  Luigi strebt serienreife Systeme an.  Es wird mit einem Server geliefert, mit dem Sie Ihre Aufgaben visualisieren oder einen Verlauf der Aufgabenausf√ºhrungen abrufen k√∂nnen.  Der Server wird als <em>zentraler Schedler bezeichnet</em> .  F√ºr Debugging-Zwecke steht ein lokaler Scheduler zur Verf√ºgung. <br><br>  Luigi unterscheidet sich auch von anderen Systemen darin, wie Aufgaben erstellt werden.  Lugi reagiert nicht auf eine vordefinierte Datei (wie <code>dodo.py</code> , <code>pavement.py</code> oder <code>dodo.py</code> ).  Vielmehr muss man einen Python-Modulnamen √ºbergeben.  Wenn wir also versuchen, es auf √§hnliche Weise wie andere Tools zu verwenden (eine Datei mit Aufgaben im Stammverzeichnis des Projekts platzieren), funktioniert es nicht.  Wir m√ºssen entweder unser Projekt installieren oder die Umgebungsvariable <code>PYTHONPATH</code> √§ndern, indem <code>PYTHONPATH</code> den Pfad zum Projekt hinzuf√ºgen. <br><br>  Was an luigi gro√üartig ist, ist die Art und Weise, Abh√§ngigkeiten zwischen Aufgaben anzugeben.  Jede Aufgabe ist eine Klasse.  Die Methodenausgabe teilt Luigi mit, wo die Ergebnisse der Aufgabe landen werden.  Ergebnisse k√∂nnen ein einzelnes Element oder eine Liste sein.  Methode <code>requires</code> spezifiziert Aufgabenabh√§ngigkeiten (andere Aufgaben; obwohl es m√∂glich ist, eine Abh√§ngigkeit von sich selbst zu machen).  Und das war's.  Was in Aufgabe A als <code>output</code> angegeben ist, wird als Eingabe an Aufgabe B √ºbergeben, wenn Aufgabe B auf Aufgabe A beruht. <br><img src="https://habrastorage.org/getpro/habr/post_images/ba2/95c/bb9/ba295cbb9b744767e709aa7b3a0e358f.png"><br><br>  Luigi k√ºmmert sich nicht um Dateimodifikationen.  Es k√ºmmert sich um die Existenz von Dateien.  Es ist daher nicht m√∂glich, Neuerstellungen auszul√∂sen, wenn sich der Quellcode √§ndert.  Luigi verf√ºgt nicht √ºber eine integrierte <i>Clean-</i> Funktionalit√§t. <br><br>  Luigi-Aufgaben f√ºr dieses Projekt sind in der Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">luigitasks.py</a> verf√ºgbar.  Ich starte sie vom Terminal aus: <br><br><pre> <code class="plaintext hljs">luigi --local-scheduler --module luigitasks Exploratory</code> </pre><br><h2><a name="Comparison"></a>  Vergleich </h2><br>  Die folgende Tabelle fasst zusammen, wie verschiedene Systeme in Bezug auf unsere spezifischen Ziele funktionieren. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Ziel mit Abh√§ngigkeit definieren </th><th>  Inkrementelle Builds </th><th>  Inkrementelle Builds, wenn der Quellcode ge√§ndert wird </th><th>  M√∂glichkeit herauszufinden, welche Artefakte w√§hrend des <code>clean</code> </th></tr><tr><td>  <strong>CMake</strong> </td><td>  ja </td><td>  ja </td><td>  ja </td><td>  ja </td></tr><tr><td>  <strong>Pynt</strong> </td><td>  ja </td><td>  nein </td><td>  nein </td><td>  nein </td></tr><tr><td>  <strong>Fertiger</strong> </td><td>  ja </td><td>  nein </td><td>  nein </td><td>  nein </td></tr><tr><td>  <strong>doit</strong> </td><td>  Etwas ja </td><td>  ja </td><td>  ja </td><td>  ja </td></tr><tr><td>  <strong>Luigi</strong> </td><td>  ja </td><td>  nein </td><td>  nein </td><td>  nein </td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451962/">https://habr.com/ru/post/de451962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451950/index.html">Virtuelle Kraftwerke. Ist es m√∂glich, die Quellen "gr√ºner" Energie zu verwalten?</a></li>
<li><a href="../de451954/index.html">Weitere geheime Telegramme</a></li>
<li><a href="../de451956/index.html">Verwenden von AppDynamics mit Red Hat OpenShift v3</a></li>
<li><a href="../de451958/index.html">Wir schauen Torrents auf Smart TV ohne SMS und Registrierung</a></li>
<li><a href="../de451960/index.html">90 Sicherheitsl√ºcken bei der Remotecodeausf√ºhrung im Mai Update Dienstag</a></li>
<li><a href="../de451966/index.html">Moderne E / A-Ger√§te sind schneller als Prozessoren. Artikel√ºbersicht</a></li>
<li><a href="../de451968/index.html">Top 3D Academy - Schulung in additiven Technologien bei f√ºhrenden russischen Unternehmen</a></li>
<li><a href="../de451970/index.html">Thrangrycat: Durch eine kritische Sicherheitsl√ºcke in der Cisco-Ger√§tefirmware k√∂nnen Hacker Backdoors auf ihnen installieren</a></li>
<li><a href="../de451972/index.html">QuadCast - Klingt echt</a></li>
<li><a href="../de451974/index.html">AMD-Geschichte: 50 Jahre rasante Entwicklung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>