<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥈 👩‍💻 🌏 Erstellen Sie Tools in maschinellen Lernprojekten, eine Übersicht 🚤 💙 👭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe mich über maschinelles Lernen / datenwissenschaftliche Projektstruktur / Workflow gewundert und verschiedene Meinungen zu diesem Thema gelese...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie Tools in maschinellen Lernprojekten, eine Übersicht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451962/"> Ich habe mich über maschinelles Lernen / datenwissenschaftliche Projektstruktur / Workflow gewundert und verschiedene Meinungen zu diesem Thema gelesen.  Und wenn Leute anfangen, über Workflows zu sprechen, möchten sie, dass ihre Workflows reproduzierbar sind.  Es gibt viele Posts, die empfehlen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">make</a> zu verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> um den Workflow reproduzierbar zu halten.  Obwohl <code>make</code> sehr stabil und weit verbreitet ist, mag ich persönlich plattformübergreifende Lösungen.  Es ist immerhin 2019, nicht 1977. Man kann argumentieren, dass make plattformübergreifend ist, aber in Wirklichkeit werden Sie Probleme haben und Zeit damit verbringen, Ihr Werkzeug zu reparieren, anstatt die eigentliche Arbeit zu erledigen.  Also habe ich beschlossen, mich umzuschauen und herauszufinden, welche anderen Tools verfügbar sind.  Ja, ich habe beschlossen, einige Zeit mit Werkzeugen zu verbringen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aff/fbf/656/afffbf6566a6e67ea6427d28d76d7eea.png" alt="Bild"></div><br>  Dieser Beitrag ist eher eine Einladung zum Dialog als ein Tutorial.  Vielleicht ist Ihre Lösung perfekt.  Wenn ja, wird es interessant sein, davon zu hören. <br><br>  In diesem Beitrag werde ich ein kleines Python-Projekt verwenden und die gleichen Automatisierungsaufgaben mit verschiedenen Systemen ausführen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CMake</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pybuilder</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pynt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fertiger</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">doit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Luigi</a> </li></ul><br>  Am Ende des Beitrags wird eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleichstabelle angezeigt</a> . <br><a name="habracut"></a><br>  Die meisten Tools, die ich mir ansehen werde, sind als <em>Build-Automatisierungssoftware</em> oder <em>Build-Systeme bekannt</em> .  Es gibt unzählige von ihnen in allen verschiedenen Geschmacksrichtungen, Größen und Komplexitäten.  Die Idee ist dieselbe: Der Entwickler definiert Regeln für die automatisierte und konsistente Erstellung einiger Ergebnisse.  Ein Ergebnis kann beispielsweise ein Bild mit einem Diagramm sein.  Um dieses Bild zu erstellen, müsste man die Daten herunterladen, die Daten bereinigen und einige Datenmanipulationen durchführen (wirklich ein klassisches Beispiel).  Sie können mit ein paar Shell-Skripten beginnen, die den Job erledigen.  Wenn Sie ein Jahr später zum Projekt zurückkehren, wird es schwierig sein, sich alle Schritte und deren Reihenfolge zu merken, die Sie ausführen müssen, um dieses Bild zu erstellen.  Die naheliegende Lösung besteht darin, alle Schritte zu dokumentieren.  Gute Nachrichten!  Mit Build-Systemen können Sie die Schritte in Form eines Computerprogramms dokumentieren.  Einige Build-Systeme ähneln Ihren Shell-Skripten, verfügen jedoch über zusätzliche Schnickschnack. <br><br>  Die Grundlage dieses Beitrags ist eine Reihe von Beiträgen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mateusz Bednarski</a> zum automatisierten Workflow für ein maschinelles Lernprojekt.  Mateusz erklärt seine Ansichten und liefert Rezepte für die Verwendung von <code>make</code> .  Ich ermutige Sie, zuerst seine Beiträge zu überprüfen.  Ich werde hauptsächlich seinen Code verwenden, aber mit verschiedenen Build-Systemen. <br><br>  Wenn Sie mehr über <code>make</code> erfahren möchten, finden Sie im Folgenden einige Referenzen für einige Beiträge.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brooke Kennedy</a> bietet einen allgemeinen Überblick in 5 einfachen Schritten, um Ihr Data Science-Projekt reproduzierbar zu machen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zachary Jones</a> gibt weitere Details zur Syntax und zu den Funktionen sowie Links zu anderen Posts.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">David Stevens</a> schreibt einen sehr Hype-Beitrag darüber, warum Sie <code>make</code> sofort verwenden müssen.  Er liefert schöne Beispiele, die <i>den alten</i> und <i>den neuen Weg vergleichen</i> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Samuel Lampa</a> hingegen schreibt darüber, warum die Verwendung von <code>make</code> eine schlechte Idee ist. <br><br>  Meine Auswahl an Build-Systemen ist weder umfassend noch unvoreingenommen.  Wenn Sie Ihre Liste erstellen möchten, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> möglicherweise ein guter Ausgangspunkt.  Wie oben erwähnt, werde ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CMake</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyBuilder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pynt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paver</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Doit</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Luigi behandeln</a> .  Die meisten Tools in dieser Liste basieren auf Python und sind sinnvoll, da sich das Projekt in Python befindet.  In diesem Beitrag wird nicht beschrieben, wie die Tools installiert werden.  Ich gehe davon aus, dass Sie Python ziemlich gut beherrschen. <br><br>  Ich bin hauptsächlich daran interessiert, diese Funktionalität zu testen: <br><br><ol><li>  Angeben einiger Ziele mit Abhängigkeiten.  Ich möchte sehen, wie es geht und wie einfach es ist. </li><li>  Überprüfen, ob inkrementelle Builds möglich sind.  Dies bedeutet, dass das Build-System nicht neu erstellt, was seit dem letzten Lauf nicht geändert wurde, d. H. Sie müssen Ihre Rohdaten nicht erneut herunterladen.  Eine andere Sache, nach der ich suchen werde, sind inkrementelle Builds, wenn sich die Abhängigkeit ändert.  Stellen Sie sich vor, wir haben ein Diagramm der Abhängigkeiten <code>A -&gt; B -&gt; C</code>  Wird Ziel <code>C</code> wiederhergestellt, wenn sich <code>B</code> ändert?  Wenn ein? </li><li>  Überprüfen, ob eine Neuerstellung ausgelöst wird, wenn der Quellcode geändert wird, d. H. Wir ändern den Parameter des generierten Diagramms. Beim nächsten Erstellen des Bildes muss es neu erstellt werden. </li><li>  Überprüfen der Möglichkeiten zum Bereinigen von Build-Artefakten, d. H. Entfernen von Dateien, die während des Builds erstellt wurden, und Zurücksetzen auf den sauberen Quellcode. </li></ol><br>  Ich werde nicht alle Build-Ziele aus Mateusz 'Post verwenden, nur drei davon, um die Prinzipien zu veranschaulichen. <br><br>  Der gesamte Code ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verfügbar. <br><br><h2><a name="CMake"></a>  CMake </h2><br>  CMake ist ein Build-Skript-Generator, der Eingabedateien für verschiedene Build-Systeme generiert.  Und sein Name steht für plattformübergreifende Marke.  CMake ist ein Software-Engineering-Tool.  Das Hauptanliegen ist das Erstellen von ausführbaren Dateien und Bibliotheken.  CMake weiß also, wie man <i>Ziele</i> aus dem Quellcode in unterstützten Sprachen erstellt.  CMake wird in zwei Schritten ausgeführt: Konfiguration und Generierung.  Während der Konfiguration ist es möglich, den zukünftigen Build nach Bedarf zu konfigurieren.  In diesem Schritt werden beispielsweise vom Benutzer bereitgestellte Variablen angegeben.  Die Generierung ist normalerweise unkompliziert und erzeugt Dateien, mit denen Build-Systeme arbeiten können.  Mit CMake können Sie weiterhin <code>make</code> , aber anstatt Makefile direkt zu schreiben, schreiben Sie eine CMake-Datei, die das Makefile für Sie generiert. <br><br>  Ein weiteres wichtiges Konzept ist, dass CMake <i>Out-of-Source-Builds</i> fördert.  Out-of-Source-Builds halten den Quellcode von Artefakten fern, die er erzeugt.  Dies ist sehr sinnvoll für ausführbare Dateien, bei denen eine einzelne Quellcodebasis unter verschiedenen CPU-Architekturen und Betriebssystemen kompiliert werden kann.  Dieser Ansatz kann jedoch der Arbeitsweise vieler Datenwissenschaftler widersprechen.  Es scheint mir, dass die Data Science Community tendenziell eine hohe Kopplung von Daten, Code und Ergebnissen aufweist. <br><br>  Mal sehen, was wir brauchen, um unsere Ziele mit CMake zu erreichen.  Es gibt zwei Möglichkeiten, benutzerdefinierte Dinge in CMake zu definieren: benutzerdefinierte Ziele und benutzerdefinierte Befehle.  Leider müssen wir beide verwenden, was zu mehr Typisierung im Vergleich zu Vanila-Makefile führt.  Ein benutzerdefiniertes Ziel wird als immer veraltet angesehen, d. H. Wenn es ein Ziel zum Herunterladen von Rohdaten gibt, lädt CMake es immer wieder herunter.  Eine Kombination aus benutzerdefiniertem Befehl und benutzerdefiniertem Ziel ermöglicht es, Ziele auf dem neuesten Stand zu halten. <br><br>  Für unser Projekt erstellen wir eine Datei mit dem Namen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CMakeLists.txt</a> und legen sie im Stammverzeichnis des Projekts ab.  Schauen wir uns den Inhalt an: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">cmake_minimum_required</span></span>(VERSION <span class="hljs-number"><span class="hljs-number">3.14</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> FATAL_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">project</span></span>(Cmake_in_ml VERSION <span class="hljs-number"><span class="hljs-number">0.1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> LANGUAGES NONE)</code> </pre><br>  Dieser Teil ist grundlegend.  Die zweite Zeile definiert den Namen Ihres Projekts und Ihre Version und gibt an, dass wir keine integrierte Sprachunterstützung verwenden (Sinus werden wir Python-Skripte nennen). <br><br>  Unser erstes Ziel wird den IRIS-Datensatz herunterladen: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(IRIS_URL <span class="hljs-string"><span class="hljs-string">"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"</span></span> CACHE <span class="hljs-keyword"><span class="hljs-keyword">STRING</span></span> <span class="hljs-string"><span class="hljs-string">"URL to the IRIS data"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_DIR <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/raw) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_FILE <span class="hljs-variable"><span class="hljs-variable">${IRIS_DIR}</span></span>/iris.csv) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Downloading IRIS."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/download.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_URL}</span></span> <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Done. Checkout ${IRIS_FILE}."</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(rawdata ALL DEPENDS <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span>)</code> </pre><br>  Die erste Zeile definiert den Parameter <code>IRIS_URL</code> , der dem Benutzer während des Konfigurationsschritts zur Verfügung gestellt wird.  Wenn Sie die CMake-GUI verwenden, können Sie diese Variable über die GUI festlegen: <br><br><img src="https://habrastorage.org/webt/oo/za/pj/oozapjujvjg_q86ndg6r7c5u36a.png"><br><br>  Als Nächstes definieren wir Variablen mit dem heruntergeladenen Speicherort des IRIS-Datasets.  Dann fügen wir einen benutzerdefinierten Befehl hinzu, der <code>IRIS_FILE</code> als Ausgabe erzeugt.  Am Ende definieren wir benutzerdefinierte Ziel- <code>rawdata</code> , die von <code>rawdata</code> abhängen. <code>IRIS_FILE</code> bedeutet, dass zum Erstellen von <code>rawdata</code> <code>IRIS_FILE</code> muss.  Option <code>ALL</code> des benutzerdefinierten Ziels besagt, dass <code>rawdata</code> eines der zu erstellenden Standardziele sind.  Beachten Sie, dass ich <code>CMAKE_CURRENT_SOURCE_DIR</code> verwende, um die heruntergeladenen Daten im <code>CMAKE_CURRENT_SOURCE_DIR</code> und nicht im Build-Ordner zu speichern.  Dies ist nur, um es das gleiche wie Mateusz zu machen. <br><br>  Okay, mal sehen, wie wir es nutzen können.  Ich führe es derzeit auf Windows mit installiertem MinGW-Compiler aus.  Möglicherweise müssen Sie die Generatoreinstellung an Ihre Bedürfnisse anpassen (führen Sie <code>cmake --help</code> , um die Liste der verfügbaren Generatoren <code>cmake --help</code> ).  Starten Sie das Terminal und wechseln Sie in den übergeordneten Ordner des Quellcodes. <br><br><pre> <code class="bash hljs">mkdir overcome-the-chaos-build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> overcome-the-chaos-build cmake -G <span class="hljs-string"><span class="hljs-string">"MinGW Makefiles"</span></span> ../overcome-the-chaos</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text">  - Konfiguration abgeschlossen <br>  - Generieren erledigt <br>  - Build-Dateien wurden geschrieben in: C: / home / workspace / überwinden-das-Chaos-Build <br></div></div><br>  Mit modernem CMake können wir das Projekt direkt aus CMake erstellen.  Dieser Befehl ruft <code>build all</code> Befehl <code>build all</code> : <br><br><pre> <code class="bash hljs">cmake --build .</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text">  Scannen von Abhängigkeiten von Ziel-Rohdaten <br>  [100%] Ziel-Rohdaten erstellt <br></div></div><br>  Wir können auch die Liste der verfügbaren Ziele anzeigen: <br><br><pre> <code class="bash hljs">cmake --build . --target <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  Und wir können heruntergeladene Dateien entfernen durch: <br><br><pre> <code class="bash hljs">cmake --build . --target clean</code> </pre><br>  Stellen Sie sicher, dass wir das saubere Ziel nicht manuell erstellen mussten. <br><br>  Gehen wir nun zum nächsten Ziel - den vorverarbeiteten IRIS-Daten.  Mateusz erstellt zwei Dateien aus einer einzigen Funktion: <code>processed.pickle</code> und <code>processed.xlsx</code> .  Sie können sehen, wie er diese Excel-Datei mit <code>rm</code> mit Platzhalter bereinigt.  Ich denke, das ist kein sehr guter Ansatz.  In CMake haben wir zwei Möglichkeiten, damit umzugehen.  Die erste Option ist die Verwendung der Verzeichniseigenschaft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ADDITIONAL_MAKE_CLEAN_FILES</a> .  Der Code lautet: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(PROCESSED_FILE <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/processed/processed.pickle) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Additional files to clean set_property(DIRECTORY PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx )</span></span></code> </pre><br>  Die zweite Option besteht darin, eine Liste von Dateien als benutzerdefinierte Befehlsausgabe anzugeben: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">LIST</span></span>(APPEND PROCESSED_FILE <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.pickle"</span></span> <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> data/processed/processed.pickle --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> src/data/preprocess.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>)</code> </pre><br>  In diesem Fall habe ich die Liste erstellt, sie jedoch nicht im benutzerdefinierten Befehl verwendet.  Ich kenne keine Möglichkeit, auf Ausgabeargumente eines benutzerdefinierten Befehls darin zu verweisen. <br><br>  Eine weitere interessante Sache ist die Verwendung von <code>depends</code> in diesem benutzerdefinierten Befehl.  Wir legen die Abhängigkeit nicht nur von einem benutzerdefinierten Ziel fest, sondern auch von der Ausgabe und dem Python-Skript.  Wenn wir <code>IRIS_FILE</code> keine Abhängigkeit <code>IRIS_FILE</code> , <code>iris.csv</code> manuelle Ändern von <code>iris.csv</code> nicht zur <code>IRIS_FILE</code> des <code>preprocess</code> .  Nun, Sie sollten Dateien in Ihrem Build-Verzeichnis zunächst nicht manuell ändern.  Lass es dich nur wissen.  Weitere Details in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sam Thursfields Beitrag</a> .  Die Abhängigkeit zum Python-Skript wird benötigt, um das Ziel neu zu erstellen, wenn sich das Python-Skript ändert. <br><br>  Und schließlich das dritte Ziel: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(EXPLORATORY_IMG <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/reports/figures/exploratory.png) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/visualization/exploratory.py <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> src/visualization/exploratory.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(exploratory DEPENDS <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span>)</code> </pre><br>  Dieses Ziel ist im Grunde das gleiche wie das zweite. <br><br>  Zum Abschluss.  CMake sieht chaotisch und schwieriger aus als Make.  In der Tat kritisieren viele Leute CMake wegen seiner Syntax.  Nach meiner Erfahrung wird das Verständnis kommen und es ist absolut möglich, auch sehr komplizierte CMake-Dateien zu verstehen. <br><br>  Sie werden immer noch viel selbst kleben, da Sie die richtigen Variablen weitergeben müssen.  Ich sehe keine einfache Möglichkeit, die Ausgabe eines benutzerdefinierten Befehls in einem anderen zu referenzieren.  Es scheint möglich zu sein, dies über benutzerdefinierte Ziele zu tun. <br><br><h2><a name="PyBuilder"></a>  Pybuilder </h2><br>  Der PyBuilder-Teil ist sehr kurz.  Ich habe Python 3.7 in meinem Projekt verwendet und PyBuilder aktuelle Version 0.11.17 unterstützt es nicht.  Die vorgeschlagene Lösung ist die Verwendung der Entwicklungsversion.  Diese Version ist jedoch an pip v9 gebunden.  Pip ist zum Zeitpunkt des Schreibens Version 19.3.  Schade.  Nachdem ich ein bisschen herumgespielt hatte, funktionierte es bei mir überhaupt nicht.  Die PyBuilder-Bewertung war von kurzer Dauer. <br><br><h2><a name="pynt"></a>  pynt </h2><br>  Pynt basiert auf Python, was bedeutet, dass wir Python-Funktionen direkt verwenden können.  Es ist nicht erforderlich, sie mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klick</a> zu verpacken und eine Befehlszeilenschnittstelle bereitzustellen.  Pynt kann jedoch auch Shell-Befehle ausführen.  Ich werde Python-Funktionen verwenden. <br><br>  Build-Befehle werden in einer Datei <code>build.py</code> .  Ziele / Aufgaben werden mit Funktionsdekoratoren erstellt.  Aufgabenabhängigkeiten werden über denselben Dekorator bereitgestellt. <br><br>  Da ich Python-Funktionen verwenden möchte, muss ich sie in das Build-Skript importieren.  Pynt enthält das aktuelle Verzeichnis nicht als Python-Skript. Schreiben Sie also Folgendes: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  wird nicht funktionieren.  Wir müssen tun: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys sys.path.append(os.path.join(os.path.dirname(__file__), <span class="hljs-string"><span class="hljs-string">'.'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  Meine anfängliche <code>build.py</code> Datei war wie <code>build.py</code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python import os import sys sys.path.append(os.path.join(os.path.dirname(__file__), '.')) from pynt import task from path import Path import glob from src.data.download import pydownload_file from src.data.preprocess import pypreprocess iris_file = 'data/raw/iris.csv' processed_file = 'data/processed/processed.pickle' @task() def rawdata(): '''Download IRIS dataset''' pydownload_file('https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data', iris_file) @task() def clean(): '''Clean all build artifacts''' patterns = ['data/raw/*.csv', 'data/processed/*.pickle', 'data/processed/*.xlsx', 'reports/figures/*.png'] for pat in patterns: for fl in glob.glob(pat): Path(fl).remove() @task(rawdata) def preprocess(): '''Preprocess IRIS dataset''' pypreprocess(iris_file, processed_file, 'data/processed/processed.xlsx')</span></span></code> </pre><br>  Und das <code>preprocess</code> hat nicht funktioniert.  Es beschwerte sich ständig über Eingabeargumente der <code>pypreprocess</code> Funktion.  Es scheint, dass Pynt optionale Funktionsargumente nicht sehr gut verarbeitet.  Ich musste das Argument für die Erstellung der Excel-Datei entfernen.  Denken Sie daran, wenn Ihr Projekt Funktionen mit optionalen Argumenten hat. <br><br>  Wir können pynt aus dem Ordner des Projekts ausführen und alle verfügbaren Ziele auflisten: <br><br><pre> <code class="bash hljs">pynt -l</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text"><pre> <code class="bash hljs">Tasks <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> build file build.py: clean Clean all build artifacts exploratory Make an image with pairwise distribution preprocess Preprocess IRIS dataset rawdata Download IRIS dataset Powered by pynt 0.8.2 - A Lightweight Python Build Tool.</code> </pre><br></div></div><br>  Machen wir die paarweise Verteilung: <br><br><pre> <code class="bash hljs">pynt exploratory</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text"><pre> <code class="bash hljs">[ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] Downloading from https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data to data/raw/iris.csv [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] Preprocessing data [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ] Plotting pairwise distribution... [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ]</code> </pre><br></div></div><br>  Wenn wir jetzt denselben Befehl erneut <code>pynt exploratory</code> (dh <code>pynt exploratory</code> ), wird eine vollständige <code>pynt exploratory</code> .  Pynt hat nicht verfolgt, dass sich nichts geändert hat. <br><br><h2><a name="Paver"></a>  Fertiger </h2><br>  Paver sieht fast genauso aus wie Pynt.  Es unterscheidet sich geringfügig in einer Weise, wie man Abhängigkeiten zwischen Zielen definiert (ein anderer Dekorateur <code>@needs</code> ).  Paver führt jedes Mal eine vollständige Neuerstellung durch und spielt nicht gut mit Funktionen, die optionale Argumente haben.  Bauanweisungen finden Sie in der Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pavement.py</a> . <br><br><h2><a name="doit"></a>  doit </h2><br>  Doit scheint ein Versuch zu sein, ein wirklich erstelltes Automatisierungstool in Python zu erstellen.  Es kann Python-Code und Shell-Befehle ausführen.  Es sieht ziemlich vielversprechend aus.  Was (im Kontext unserer spezifischen Ziele) zu fehlen scheint, ist die Fähigkeit, mit Abhängigkeiten zwischen Zielen umzugehen.  Angenommen, wir möchten eine kleine Pipeline erstellen, in der die Ausgabe von Ziel A als Eingabe von Ziel B verwendet wird. Nehmen wir an, wir verwenden Dateien als Ausgaben. Ziel A erstellt also eine Datei mit dem Namen <code>outA</code> . <br><br><img src="https://habrastorage.org/webt/xh/te/ol/xhteolpanywbjxanltb8uxdsoly.png"><br><br>  Um eine solche Pipeline zu erstellen, <code>outA</code> wir die Datei <code>outA</code> zweimal in Ziel A angeben (als Ergebnis eines Ziels, aber auch den Namen als Teil der Zielausführung zurückgeben).  Dann müssen wir es als Eingabe für Ziel B angeben. Es gibt also insgesamt 3 Stellen, an denen wir Informationen über die Datei <code>outA</code> .  Und selbst nachdem wir dies getan haben, führt die Änderung der Datei <code>outA</code> nicht zu einer automatischen <code>outA</code> von Ziel B. Dies bedeutet, dass doit nur dann prüft, ob Ziel B auf dem neuesten Stand ist, ohne dass eines überprüft wird der Abhängigkeiten.  Um dies zu überwinden, müssen wir <code>outA</code> viermal angeben - auch als <code>outA</code> von Ziel B. Ich sehe dies als Nachteil.  Sowohl Make als auch CMake können mit solchen Situationen richtig umgehen. <br><br>  Abhängigkeiten in doit sind dateibasiert und werden als Zeichenfolgen ausgedrückt.  Dies bedeutet, dass die Abhängigkeiten <code>./myfile.txt</code> und <code>myfile.txt</code> als unterschiedlich angesehen werden.  Wie ich oben geschrieben habe, finde ich die Art und Weise, wie Informationen von Ziel zu Ziel (bei Verwendung von Python-Zielen) weitergegeben werden, etwas seltsam.  Das Ziel hat eine Liste von Artefakten, die es produzieren wird, aber ein anderes Ziel kann sie nicht verwenden.  Stattdessen muss die Python-Funktion, die das Ziel bildet, ein Wörterbuch zurückgeben, auf das in einem anderen Ziel zugegriffen werden kann.  Sehen wir uns ein Beispiel an: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_preprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Preprocess IRIS dataset"""</span></span> pickle_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.pickle'</span></span> excel_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.xlsx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'file_dep'</span></span>: [<span class="hljs-string"><span class="hljs-string">'src/data/preprocess.py'</span></span>], <span class="hljs-string"><span class="hljs-string">'targets'</span></span>: [pickle_file, excel_file], <span class="hljs-string"><span class="hljs-string">'actions'</span></span>: [doit_pypreprocess], <span class="hljs-string"><span class="hljs-string">'getargs'</span></span>: {<span class="hljs-string"><span class="hljs-string">'input_file'</span></span>: (<span class="hljs-string"><span class="hljs-string">'rawdata'</span></span>, <span class="hljs-string"><span class="hljs-string">'filename'</span></span>)}, <span class="hljs-string"><span class="hljs-string">'clean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, }</code> </pre><br>  Hier hängt der <code>rawdata</code> von den <code>rawdata</code> .  Die Abhängigkeit wird über <code>getargs</code> Eigenschaft <code>getargs</code> bereitgestellt.  Es heißt, dass das Argument <code>input_file</code> der Funktion <code>doit_pypreprocess</code> der Ausgabedateiname der Ziel- <code>rawdata</code> .  Schauen Sie sich das vollständige Beispiel in der Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dodo.py an.</a> <br><br>  Es kann sich lohnen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Erfolgsgeschichten</a> von doit zu lesen.  Es hat definitiv nette Funktionen wie die Möglichkeit, eine benutzerdefinierte, aktuelle Zielprüfung bereitzustellen. <br><br><h2><a name="Luigi"></a>  Luigi </h2><br>  Luigi unterscheidet sich von anderen Tools, da es sich um ein System zum Bau komplexer Pipelines handelt.  Es erschien auf meinem Radar, nachdem mir ein Kollege erzählt hatte, dass er Make ausprobiert hatte, es nie unter Windows / Linux verwenden konnte und nach Luigi zog. <br><br>  Luigi strebt serienreife Systeme an.  Es wird mit einem Server geliefert, mit dem Sie Ihre Aufgaben visualisieren oder einen Verlauf der Aufgabenausführungen abrufen können.  Der Server wird als <em>zentraler Schedler bezeichnet</em> .  Für Debugging-Zwecke steht ein lokaler Scheduler zur Verfügung. <br><br>  Luigi unterscheidet sich auch von anderen Systemen darin, wie Aufgaben erstellt werden.  Lugi reagiert nicht auf eine vordefinierte Datei (wie <code>dodo.py</code> , <code>pavement.py</code> oder <code>dodo.py</code> ).  Vielmehr muss man einen Python-Modulnamen übergeben.  Wenn wir also versuchen, es auf ähnliche Weise wie andere Tools zu verwenden (eine Datei mit Aufgaben im Stammverzeichnis des Projekts platzieren), funktioniert es nicht.  Wir müssen entweder unser Projekt installieren oder die Umgebungsvariable <code>PYTHONPATH</code> ändern, indem <code>PYTHONPATH</code> den Pfad zum Projekt hinzufügen. <br><br>  Was an luigi großartig ist, ist die Art und Weise, Abhängigkeiten zwischen Aufgaben anzugeben.  Jede Aufgabe ist eine Klasse.  Die Methodenausgabe teilt Luigi mit, wo die Ergebnisse der Aufgabe landen werden.  Ergebnisse können ein einzelnes Element oder eine Liste sein.  Methode <code>requires</code> spezifiziert Aufgabenabhängigkeiten (andere Aufgaben; obwohl es möglich ist, eine Abhängigkeit von sich selbst zu machen).  Und das war's.  Was in Aufgabe A als <code>output</code> angegeben ist, wird als Eingabe an Aufgabe B übergeben, wenn Aufgabe B auf Aufgabe A beruht. <br><img src="https://habrastorage.org/getpro/habr/post_images/ba2/95c/bb9/ba295cbb9b744767e709aa7b3a0e358f.png"><br><br>  Luigi kümmert sich nicht um Dateimodifikationen.  Es kümmert sich um die Existenz von Dateien.  Es ist daher nicht möglich, Neuerstellungen auszulösen, wenn sich der Quellcode ändert.  Luigi verfügt nicht über eine integrierte <i>Clean-</i> Funktionalität. <br><br>  Luigi-Aufgaben für dieses Projekt sind in der Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">luigitasks.py</a> verfügbar.  Ich starte sie vom Terminal aus: <br><br><pre> <code class="plaintext hljs">luigi --local-scheduler --module luigitasks Exploratory</code> </pre><br><h2><a name="Comparison"></a>  Vergleich </h2><br>  Die folgende Tabelle fasst zusammen, wie verschiedene Systeme in Bezug auf unsere spezifischen Ziele funktionieren. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Ziel mit Abhängigkeit definieren </th><th>  Inkrementelle Builds </th><th>  Inkrementelle Builds, wenn der Quellcode geändert wird </th><th>  Möglichkeit herauszufinden, welche Artefakte während des <code>clean</code> </th></tr><tr><td>  <strong>CMake</strong> </td><td>  ja </td><td>  ja </td><td>  ja </td><td>  ja </td></tr><tr><td>  <strong>Pynt</strong> </td><td>  ja </td><td>  nein </td><td>  nein </td><td>  nein </td></tr><tr><td>  <strong>Fertiger</strong> </td><td>  ja </td><td>  nein </td><td>  nein </td><td>  nein </td></tr><tr><td>  <strong>doit</strong> </td><td>  Etwas ja </td><td>  ja </td><td>  ja </td><td>  ja </td></tr><tr><td>  <strong>Luigi</strong> </td><td>  ja </td><td>  nein </td><td>  nein </td><td>  nein </td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451962/">https://habr.com/ru/post/de451962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451950/index.html">Virtuelle Kraftwerke. Ist es möglich, die Quellen "grüner" Energie zu verwalten?</a></li>
<li><a href="../de451954/index.html">Weitere geheime Telegramme</a></li>
<li><a href="../de451956/index.html">Verwenden von AppDynamics mit Red Hat OpenShift v3</a></li>
<li><a href="../de451958/index.html">Wir schauen Torrents auf Smart TV ohne SMS und Registrierung</a></li>
<li><a href="../de451960/index.html">90 Sicherheitslücken bei der Remotecodeausführung im Mai Update Dienstag</a></li>
<li><a href="../de451966/index.html">Moderne E / A-Geräte sind schneller als Prozessoren. Artikelübersicht</a></li>
<li><a href="../de451968/index.html">Top 3D Academy - Schulung in additiven Technologien bei führenden russischen Unternehmen</a></li>
<li><a href="../de451970/index.html">Thrangrycat: Durch eine kritische Sicherheitslücke in der Cisco-Gerätefirmware können Hacker Backdoors auf ihnen installieren</a></li>
<li><a href="../de451972/index.html">QuadCast - Klingt echt</a></li>
<li><a href="../de451974/index.html">AMD-Geschichte: 50 Jahre rasante Entwicklung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>