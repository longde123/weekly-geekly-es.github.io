<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😃 🤶🏿 👎 Micropython en módulo GSM + GPS A9G 👳🏿 🌎 🥓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta vez pensé en esconder un rastreador GPS en mi bicicleta como medida de precaución. Hay toneladas de dispositivos autónomos en el mercado para ras...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Micropython en módulo GSM + GPS A9G</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446090/"><p>  Esta vez pensé en esconder un rastreador GPS en mi bicicleta como medida de precaución.  Hay toneladas de dispositivos autónomos en el mercado para rastrear automóviles, carga, bicicletas, equipaje, niños y animales.  La gran mayoría de ellos interactúa con el usuario a través de SMS.  Las opciones más caras proporcionan la funcionalidad Buscar mi teléfono, pero están vinculadas a un servicio en línea específico. <br>  Idealmente, me gustaría tener control total sobre el rastreador: utilícelo en un modo conveniente sin SMS ni registro.  Google superficial me trajo un par de módulos de China, uno de los cuales pedí (tablero de pudín A9G) (~ $ 15). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f7f/b34/fe0/f7fb34fe016bb3a6c532712b9b2e75e1.png" alt="Modulo"></p><br><p>  Este artículo trata sobre cómo hice que Python funcionara en este módulo. </p><a name="habracut"></a><br><p>  Si el A9G es un análogo de ESP (el fabricante, por cierto, es el mismo), entonces el tablero de pudín en sí es un análogo de la placa NodeMCU, excepto que el tablero de pudín no tiene un convertidor USB-UART incorporado.  Pero hay muchas otras cosas interesantes.  Especificaciones del <a href="">fabricante</a> : </p><br><ul><li>  Núcleo de 32 bits (RISC), hasta 312MHz </li><li>  GPIO 29x (todos están soldados, todas las interfaces están incluidas en este número) </li><li>  relojes y perro guardián </li><li>  1x interfaz USB 1.1 (no la encontré allí, pero copie desde fuera del sitio) y microUSB para poder </li><li>  2x UART (+1 servicio) </li><li>  2x SPI (no probado) </li><li>  3x I2C (no probado) </li><li>  1x SDMMC (con ranura física) </li><li>  2 entradas analógicas (10 bits, posiblemente uno de ellos sea utilizado por controladores de batería de litio) </li><li>  Flash de 4Mb </li><li>  PSRAM de 4Mb </li><li>  ADC (micrófono, existe físicamente en el tablero) y DAC (altavoz, ausente) </li><li>  controlador de carga de la batería (no hay batería en sí) </li><li>  de hecho, GSM (800, 900, 1800, 1900 MHz) con SMS, voz y GPRS </li><li>  GPS conectado a través de UART2 (hay un módulo "A9" sin él) </li><li>  Ranura SIM (nanoSIM) </li><li>  dos botones (uno restablecer, el otro - inclusión y función programable) </li><li>  dos LEDs </li></ul><br><p>  El voltaje de operación es 3.3V, el voltaje de entrada es 5-3.8V (dependiendo de la conexión).  En general, el módulo tiene todo el hardware necesario para ensamblar un simple dispositivo móvil con un solo botón.  Pero a partir de los ejemplos, parece que los chinos lo están comprando para la venta en máquinas tragamonedas o máquinas tragamonedas o algo así.  Las alternativas al módulo son los módulos SIM800 bastante populares, que, desafortunadamente, no tienen un SDK en el dominio público (es decir, los módulos se venden como módems AT). </p><br><h1>  SDK </h1><br><p> El módulo viene con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SDK</a> en inglés satisfactorio.  Se instala en Ubuntu, pero se prefieren Windows y contenedores.  Todo funciona a través de la interfaz gráfica de usuario: ESPtool para este módulo aún no se ha revertido.  El firmware en sí está construido por el Makefile.  El depurador está presente: antes de congelar, el módulo arroja el seguimiento de la pila en el puerto de servicio.  Pero personalmente, no pude traducir las direcciones en líneas de código (gdb informa que las direcciones no corresponden a nada).  Es posible que esto se deba a un mal soporte para Linux como tal.  En consecuencia, si desea jugar con el módulo, intente hacerlo en Windows (y anule la suscripción en github).  De lo contrario, aquí están las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instrucciones</a> para Linux.  Después de la instalación, debe verificar la corrección de las rutas en .bashrc y eliminar (renombrar) todos los <code>CSDTK/lib/libQt*</code> : de lo contrario, el flasher (también conocido como depurador) simplemente no se iniciará debido a un conflicto con, probablemente, libQt instalado. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a7/955/5bc/7a79555bca02e1ad6363b8da9559c91e.png" alt="Intermitente"></p><br><p>  Para la luz intermitente hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instrucción</a> . </p><br><h1>  Conexión </h1><br><p>  Todo es más complicado que en NodeMCU.  Los módulos tienen un aspecto similar, pero no hay un chip USB-TTY en la placa de pudín y el microUSB se usa solo para alimentación.  En consecuencia, necesitará USB-TTY a 3.3V.  Dos son mejores: uno para el puerto de depuración y otro para UART1: el primero se usa para cargar firmware y el segundo se puede usar como terminal normal.  Para no arrastrar todos estos mocos a la computadora, compré adicionalmente un divisor USB de 4 puertos con un cable de dos metros y una fuente de alimentación externa (requerida).  El costo total de este kit con el módulo en sí será de $ 25-30 (sin fuente de alimentación: uso desde el teléfono). </p><br><h1>  Firmware </h1><br><p>  El módulo viene con firmware AT: puede conectarse a un arduino de 3.3V y usarlo como módem a través de UART1.  Su firmware está escrito en C. <code>make</code> crea dos archivos de firmware: uno está cosido durante aproximadamente un minuto, el otro es lo suficientemente rápido.  Solo se puede coser uno de estos archivos: la primera vez es grande, las siguientes son pequeñas.  En total, durante el proceso de desarrollo, tengo el SDK chino ( <code>coolwatcher</code> ) abierto en el escritorio para administrar el módulo, miniterm como stdio y el editor de código. </p><br><h1>  API </h1><br><p>  El contenido de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API</a> refleja la lista anterior y se parece al ESP8266 en sus primeros días: me llevó aproximadamente 3 horas lanzar HelloWorld.  Desafortunadamente, el conjunto de funciones disponibles para el usuario es muy limitado: por ejemplo, no hay acceso a la guía telefónica en la tarjeta SIM, información de bajo nivel sobre cómo conectarse a la red celular, etc.  La documentación de la API es aún menos completa, por lo que debe confiar en ejemplos (de los cuales hay dos docenas) e incluir archivos.  Sin embargo, el módulo puede hacer muchas cosas hasta conexiones SSL: obviamente, el fabricante se centró en las funciones más prioritarias. </p><br><p>  Sin embargo, la programación de los microcontroladores chinos a través de la API china debe ser amada.  Para todos los demás, el fabricante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comenzó a portar</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">micropython</a> a este módulo.  Decidí probarme en un proyecto de código abierto y continuar este buen trabajo (enlace al final del artículo). </p><br><h1>  micropython </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9a1/b46/e00/9a1b46e00d290db2f478ebb54f7d9e74.jpg" alt="logo"></p><br><p>  Micropython es un proyecto de código abierto que transfiere cPython a microcontroladores.  El desarrollo se lleva a cabo en dos direcciones.  El primero es el soporte y desarrollo de bibliotecas centrales comunes a todos los microcontroladores que describen el trabajo con los principales tipos de datos en python: objetos, funciones, clases, cadenas, tipos atómicos y más.  El segundo es, de hecho, los puertos: para cada microcontrolador es necesario "enseñar" a la biblioteca cómo trabajar con UART para entrada-salida, seleccionar una pila para una máquina virtual, especificar un conjunto de optimizaciones.  Opcionalmente, se describe el trabajo con hardware: GPIO, alimentación, inalámbrico, sistema de archivos. <br>  Todo esto está escrito en C puro con macros: micropython tiene un conjunto de recetas recomendadas desde declarar cadenas en ROM hasta escribir módulos.  Además de esto, los módulos escritos por Python son totalmente compatibles (lo principal es no olvidarse del tamaño de la memoria).  Los curadores del proyecto establecieron como objetivo la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">oportunidad de lanzar un dzhanga</a> (imagen con una barra de pan).  Como anuncio: el proyecto vende su propia placa para los estudiantes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pyboard</a> , pero los puertos para los módulos ESP8266 y ESP32 también son populares. </p><br><p>  Cuando el firmware esté listo y cargado, simplemente conéctese al microcontrolador a través de UART y entre en Python REPL. </p><br><pre> <code class="bash hljs">$ miniterm.py /dev/ttyUSB1 115200 --raw MicroPython cd2f742 on 2017-11-29; unicorn with Cortex-M3 Type <span class="hljs-string"><span class="hljs-string">"help()"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) hello</code> </pre> <br><p>  Después de eso, puede comenzar a escribir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en python3 casi normal</a> sin olvidarse de las limitaciones de memoria. </p><br><p>  El módulo A9G no es oficialmente compatible (una lista de módulos oficialmente compatibles está disponible en <code>micropython/ports</code> , hay una docena de ellos).  Sin embargo, el fabricante de hierro bifurcó micropython y creó el entorno para el puerto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>micropython/ports/gprs_a9</code></a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>micropython/ports/gprs_a9</code></a> , por lo que muchas gracias a él.  En el momento en que me interesé en este problema, el puerto se compiló con éxito y el microcontrolador me recibió con REPL.  Pero, desafortunadamente, en los módulos de terceros solo había trabajo con el sistema de archivos y GPIO: no había nada relacionado con la red inalámbrica y el GPS.  Decidí solucionar este defecto y me propuse portar todas las funciones necesarias para un rastreador GPS.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La documentación oficial</a> para este caso es innecesariamente concisa: por lo tanto, tuve que hurgar en el código. </p><br><h2>  Por donde empezar </h2><br><p>  Primero, vaya a <code>micropython/ports</code> y copie <code>micropython/ports/minimal</code> a la nueva carpeta donde se ubicará el puerto.  Luego, edite <code>main.c</code> para su plataforma.  Tenga en cuenta que todo lo delicioso está en la función <code>main</code> , donde debe llamar al inicializador <code>mp_init()</code> , ya que ha preparado previamente el microcontrolador y la configuración de la pila.  Luego, para la API controlada por eventos, debe llamar a <code>pyexec_event_repl_init()</code> y alimentar los caracteres ingresados ​​a través de UART a la función <code>pyexec_event_repl_process_char(char)</code> .  Esto proporcionará interoperabilidad a través de REPL.  El segundo archivo, <code>micropython/ports/minimal/uart_core.c</code> describe el bloqueo de entrada y salida en UART.  Traigo el código original para STM32 para aquellos que son demasiado vagos para buscar. </p><br><p> <code>main.c</code> </p> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stack_dummy; stack_top = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)&amp;stack_dummy; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_ENABLE_GC gc_init(heap, heap + sizeof(heap)); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> mp_init(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_ENABLE_COMPILER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_REPL_EVENT_DRIVEN pyexec_event_repl_init(); for (;;) { int c = mp_hal_stdin_rx_chr(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (pyexec_event_repl_process_char(c)) { break; } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> pyexec_friendly_repl(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//do_str("print('hello world!', list(x+1 for x in range(10)), end='eol\\n')", MP_PARSE_SINGLE_INPUT); //do_str("for i in range(10):\r\n print(i)", MP_PARSE_FILE_INPUT); #else pyexec_frozen_module("frozentest.py"); #endif mp_deinit(); return 0; }</span></span></span></span></code> </pre> <br><p> <code>uart_core.c</code> </p> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Receive single character int mp_hal_stdin_rx_chr(void) { unsigned char c = 0; #if MICROPY_MIN_USE_STDOUT int r = read(0, &amp;c, 1); (void)r; #elif MICROPY_MIN_USE_STM32_MCU // wait for RXNE while ((USART1-&gt;SR &amp; (1 &lt;&lt; 5)) == 0) { } c = USART1-&gt;DR; #endif return c; } // Send string of given length void mp_hal_stdout_tx_strn(const char *str, mp_uint_t len) { #if MICROPY_MIN_USE_STDOUT int r = write(1, str, len); (void)r; #elif MICROPY_MIN_USE_STM32_MCU while (len--) { // wait for TXE while ((USART1-&gt;SR &amp; (1 &lt;&lt; 7)) == 0) { } USART1-&gt;DR = *str++; } #endif }</span></span></code> </pre> <br><p>  Después de eso, debe volver a escribir el Makefile utilizando las recomendaciones / compilador del fabricante: aquí todo es individual.  Todo, esto idealmente debería ser suficiente: recopilamos, completamos el firmware y vemos REPL en UART. <br>  Después de revivir <code>micropython</code> debe cuidar su bienestar: configure el recolector de basura, la reacción correcta a Ctrl-D (reinicio por software) y algunas otras cosas en las que no me <code>mpconfigport.h</code> : consulte el archivo <code>mpconfigport.h</code> . </p><br><h2>  Crear un módulo </h2><br><p>  Lo más interesante es escribir sus propios módulos.  Entonces, el módulo (no necesario, pero deseable) comienza con su propio archivo <code>mod[].c</code> , que se agrega mediante el <code>Makefile</code> (variable <code>SRC_C</code> si sigue la convención).  Un módulo vacío es el siguiente: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// nlr - non-local return:  C  ,      goto-  . //  nlr_raise             . #include "py/nlr.h" //   .  ,  mp_map_elem_t,  ,   . #include "py/obj.h" //   . mp_raise_ValueError(char* msg)  mp_raise_OSError(int errorcode)   . //  ,   mp_call_function_*     Callable (  callback-). #include "py/runtime.h" #include "py/binary.h" //  header   :       #include "portmodules.h" //    --  .     MP_QSTR_[ ]. MP_OBJ_NEW_QSTR   . //             RAM. //      -      __name__ STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, }; //      STATIC MP_DEFINE_CONST_DICT (mp_module_mymodule_globals, mymodule_globals_table); //   :             const mp_obj_module_t mp_module_mymodule = { .base = { &amp;mp_type_module }, .globals = (mp_obj_dict_t*)&amp;mp_module_mymodule_globals, };</span></span></code> </pre> <br><p>  Por supuesto, el puerto en sí no reconoce la constante <code>mp_module_mymodule</code> : debe agregarse a la variable <code>MICROPY_PORT_BUILTIN_MODULES</code> en la <code>mpconfigport.h</code> puerto <code>mpconfigport.h</code> .  Por cierto <del>  fondos de pantalla aburridos </del>  el nombre del chip y el nombre del puerto también cambian allí.  Después de todos estos cambios, puede intentar compilar el módulo e importarlo desde REPL.  Solo un atributo <code>__name__</code> con el nombre del módulo estará disponible para el módulo (un gran caso para verificar la finalización automática en REPL a través de Tab). </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.__name__ <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span></code> </pre> <br><h2>  Constantes </h2><br><p>  La siguiente etapa en complejidad es agregar constantes.  Las constantes son a menudo necesarias para la configuración ( <code>INPUT</code> , <code>OUTPUT</code> , <code>HIGH</code> , <code>LOW</code> , etc.) Aquí todo es bastante simple.  Aquí, por ejemplo, la constante <code>magic_number = 10</code> : </p><br><pre> <code class="cpp hljs">STATIC <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mp_map_elem_t</span></span> mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(<span class="hljs-number"><span class="hljs-number">10</span></span>) }, };</code> </pre> <br><p>  Prueba: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.magic_number <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><h2>  Las funciones </h2><br><p>  Agregar una función a un módulo sigue el principio general: declarar, ajustar, agregar (doy un ejemplo un poco más complejo que en la documentación). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  STATIC mp_obj_t conditional_add_one(mp_obj_t value) { //   int.         -  :   . int value_int = mp_obj_get_int(value); value_int ++; if (value_int == 10) { //  None return mp_const_none; } //   int return mp_obj_new_int(value); } //    .     // runtime.h   . STATIC MP_DEFINE_CONST_FUN_OBJ_1(conditional_add_one_obj, conditional_add_one); //  STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(10) }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;conditional_add_one_obj }, };</span></span></code> </pre> <br><p>  Prueba: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.conditional_add_one(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;&gt; mymodule.conditional_add_one(<span class="hljs-number"><span class="hljs-number">9</span></span>) &gt;&gt;&gt;</code> </pre> <br><h2>  Clases (tipos) </h2><br><p>  Con las clases (tipos), todo también es relativamente simple.  Aquí hay un ejemplo de la documentación (bueno, casi): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     STATIC const mp_map_elem_t mymodule_hello_locals_dict_table[] = {}; //   STATIC MP_DEFINE_CONST_DICT(mymodule_hello_locals_dict, mymodule_hello_locals_dict_table); // ,  ,   const mp_obj_type_t mymodule_helloObj_type = { //    { &amp;mp_type_type }, // : helloObj .name = MP_QSTR_helloObj, //  .locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, }; //    STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(10) }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;conditional_add_one_obj }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;mymodule_helloObj_type }, };</span></span></code> </pre> <br><p>  Prueba: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>mymodule.helloObj &lt;type <span class="hljs-string"><span class="hljs-string">'helloObj'</span></span>&gt;</code> </pre> <br><p>  El tipo resultante se puede heredar, comparar, pero no tiene un constructor ni ningún dato asociado.  Los datos se agregan "al lado" del constructor: se propone crear una estructura separada en la que el tipo Python se almacenará por separado y por separado, un conjunto de datos arbitrario. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  -. ,    typedef struct _mymodule_hello_obj_t { //   mp_obj_base_t base; // -  uint8_t hello_number; } mymodule_hello_obj_t;</span></span></code> </pre> <br><p>  ¿Cómo interactuar con estos datos?  Una de las formas más difíciles es a través del constructor. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// -,   (,  ,   mymodule_helloObj_type //   ,     - ),   (args  kwargs)  //        : args, kwargs STATIC mp_obj_t mymodule_hello_make_new( const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args ) { //    mp_arg_check_num(n_args, n_kw, 1, 1, true); //   mymodule_hello_obj_t *self = m_new_obj(mymodule_hello_obj_t); //     self-&gt;base.type = &amp;mymodule_hello_type; //   self-&gt;hello_number = mp_obj_get_int(args[0]) //   return MP_OBJ_FROM_PTR(self); //    __init__, ,  } //      make_new const mp_obj_type_t mymodule_helloObj_type = { { &amp;mp_type_type }, .name = MP_QSTR_helloObj, .locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, //  .make_new = mymodule_hello_make_new, };</span></span></code> </pre> <br><p>  De los otros campos, también hay <code>.print</code> , y supongo que el resto de la magia de <code>Python3</code> . </p><br><p>  Pero <code>make_new</code> no es necesario para obtener una instancia de un objeto: la inicialización se puede hacer en una función arbitraria.  Aquí hay un buen ejemplo de <code>micropython/ports/esp32/modsocket.c</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   :       STATIC mp_obj_t get_socket(size_t n_args, const mp_obj_t *args) { socket_obj_t *sock = m_new_obj_with_finaliser(socket_obj_t); sock-&gt;base.type = &amp;socket_type; sock-&gt;domain = AF_INET; sock-&gt;type = SOCK_STREAM; sock-&gt;proto = 0; sock-&gt;peer_closed = false; if (n_args &gt; 0) { sock-&gt;domain = mp_obj_get_int(args[0]); if (n_args &gt; 1) { sock-&gt;type = mp_obj_get_int(args[1]); if (n_args &gt; 2) { sock-&gt;proto = mp_obj_get_int(args[2]); } } } sock-&gt;fd = lwip_socket(sock-&gt;domain, sock-&gt;type, sock-&gt;proto); if (sock-&gt;fd &lt; 0) { exception_from_errno(errno); } _socket_settimeout(sock, UINT64_MAX); return MP_OBJ_FROM_PTR(sock); } //     0-3  STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(get_socket_obj, 0, 3, get_socket);</span></span></code> </pre> <br><h2>  Métodos vinculados </h2><br><p>  El siguiente paso es agregar los métodos enlazados.  Sin embargo, esto no es muy diferente de todos los demás métodos.  Volvemos al ejemplo de la documentación: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    :     1 (self) STATIC mp_obj_t mymodule_hello_increment(mp_obj_t self_in) { mymodule_hello_obj_t *self = MP_OBJ_TO_PTR(self_in); self-&gt;hello_number += 1; return mp_const_none; } //     MP_DEFINE_CONST_FUN_OBJ_1(mymodule_hello_increment_obj, mymodule_hello_increment); //      'inc' STATIC const mp_map_elem_t mymodule_hello_locals_dict_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR_inc), (mp_obj_t)&amp;mymodule_hello_increment_obj }, }</span></span></code> </pre> <br><p>  Eso es todo! </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = mymodule.helloObj(<span class="hljs-number"><span class="hljs-number">12</span></span>) &gt;&gt;&gt; x.inc()</code> </pre> <br><h2>  Todos los demás atributos: <strong>getattr</strong> , <strong>setattr</strong> </h2><br><p>  ¿Qué hay de agregar no funciones, usando <code>@property</code> y generalmente su propio <code>__getattr__</code> ?  Por favor: esto se hace manualmente sin pasar por <code>mymodule_hello_locals_dict_table</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     ... STATIC void mymodule_hello_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) { mymodule_hello_obj_t *self = MP_OBJ_TO_PTR(self_in); if (dest[0] != MP_OBJ_NULL) { // __setattr__ if (attr == MP_QSTR_val) { self-&gt;val = dest[1]; dest[0] = MP_OBJ_NULL; } } else { // __getattr__ if (attr == MP_QSTR_val) { dest[0] = self-&gt;val; } } } // ...     attr const mp_obj_type_t mymodule_helloObj_type = { { &amp;mp_type_type }, .name = MP_QSTR_helloObj, //     //.locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, .make_new = mymodule_hello_make_new, //   - attr .attr = mymodule_hello_attr, };</span></span></code> </pre><br><p>  Algo dolorosamente conciso resultó, dices.  ¿Dónde están todos estos <code>mp_raise_AttributeError</code> ( <em>nota</em> : tal función no existe)?  De hecho, se llamará automáticamente a un <code>AttributeError</code> .  El secreto es que <code>dest</code> es una matriz de dos elementos.  El primer elemento tiene el significado de "salida", de solo escritura: toma el valor <code>MP_OBJ_SENTINEL</code> si el valor debe escribirse y <code>MP_OBJ_NULL</code> si necesita leerse.  En consecuencia, a la salida de la función, se espera <code>MP_OBJ_NULL</code> en el primer caso y algo <code>mp_obj_t</code> en el segundo.  El segundo elemento es input, solo lectura: toma el valor del objeto a escribir si el valor necesita ser escrito y <code>MP_OBJ_NULL</code> si necesita ser leído.  No necesitas cambiarlo. </p><br><p>  Eso es todo, puedes verificar: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = mymodule.helloObj(<span class="hljs-number"><span class="hljs-number">12</span></span>) &gt;&gt;&gt; x.val = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; x.val <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Lo más interesante es que la finalización de Tab en REPL todavía funciona y ofrece <code>.val</code> !  Para ser honesto, no soy un experto en C, por lo que solo puedo adivinar cómo sucede esto (redefiniendo el operador '=='). </p><br><h2>  Puerto </h2><br><p>  Volviendo al módulo A9G, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">describí el</a> soporte de todas las funciones básicas, a saber, SMS, GPRS (usockets), GPS, administración de energía.  Ahora puede cargar algo como esto en el módulo y funcionará: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cellular <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usocket <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sock <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gps <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> machine <span class="hljs-comment"><span class="hljs-comment">#   print("Waiting network registration ...") while not c.is_network_registered(): time.sleep(1) time.sleep(2) #  GPRS print("Activating ...") c.gprs_activate("internet", "", "") print("Local IP:", sock.get_local_ip()) #  GPS gps.on() #    thingspeak host = "api.thingspeak.com" api_key = "some-api-key" fields = ('latitude', 'longitude', 'battery', 'sat_visible', 'sat_tracked') #  ,      ! fields = dict(zip(fields, map(lambda x: "field{}".format(x+1), range(len(fields))) )) x, y = gps.get_location() level = machine.get_input_voltage()[1] sats_vis, sats_tracked = gps.get_satellites() s = sock.socket() print("Connecting ...") s.connect((host, 80)) print("Sending ...") #      ,     HTTP.           HTTP, SSL   print("Sent:", s.send("GET /update?api_key={}&amp;{latitude}={:f}&amp;{longitude}={:f}&amp;{battery}={:f}&amp;{sat_visible}={:d}&amp;{sat_tracked}={:d} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n".format( api_key, x, y, level, sats_vis, sats_tracked, host, **fields ))) print("Receiving ...") print("Received:", s.recv(128)) s.close()</span></span></code> </pre> <br><p>  El proyecto agradece cualquier ayuda factible.  Si le gustó el proyecto y / o este artículo, no olvide dejar un me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gusta en el github</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446090/">https://habr.com/ru/post/446090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446078/index.html">"Sonido": debate sobre un podcast sobre tecnología de audio</a></li>
<li><a href="../446080/index.html">En los Estados Unidos, el tribunal recomendó prohibir la importación de ciertos modelos de iPhone debido a la violación de las patentes de Qualcomm Apple</a></li>
<li><a href="../446082/index.html">El cuento de los medios anillos</a></li>
<li><a href="../446086/index.html">Historia de Linux Parte III: nuevos mercados y viejos "enemigos"</a></li>
<li><a href="../446088/index.html">Cosas que no sé en 2018</a></li>
<li><a href="../446092/index.html">¡Solo sin manos! Robots que no repiten acciones del usuario</a></li>
<li><a href="../446094/index.html">Con una tabla periódica de por vida.</a></li>
<li><a href="../446096/index.html">El libro "TasteVill: Cómo hacer una revolución en el comercio minorista, haciendo todo mal"</a></li>
<li><a href="../446098/index.html">Centro de control de vuelo soviético de los tiempos de "Vostok" y "Sunrise"</a></li>
<li><a href="../446100/index.html">Cree automáticamente archivos de localización de Android e iOS a partir de una hoja de cálculo de Excel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>