<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏽 🆗 🔽 LLVM IR und Go 👩‍👧 👨🏻‍🏭 🎶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird erläutert, wie Sie ein Go-Programm erstellen, z. B. einen Compiler oder einen statischen Analysator, der mithilfe der LLVM-IR-A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>LLVM IR und Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459704/">  In diesem Artikel wird erläutert, wie Sie ein Go-Programm erstellen, z. B. einen Compiler oder einen statischen Analysator, der mithilfe der LLVM-IR-Assemblersprache mit dem LLVM-Kompilierungsframework interagiert. <br><br>  <b>TL; DR</b> Wir haben eine Bibliothek für die Interaktion mit LLVM IR auf pure Go geschrieben. Siehe Links zu Code und ein Beispielprojekt. <br><a name="habracut"></a><br><h3>  Ein einfaches Beispiel für LLVM IR </h3><br>  (Diejenigen unter Ihnen, die mit LLVM IR vertraut sind, können mit dem nächsten Abschnitt fortfahren.) <br><br>  LLVM IR ist die Low-Level-Zwischendarstellung, die vom LLVM-Kompilierungsframework verwendet wird.  Sie können sich LLVM IR als plattformunabhängigen Assembler mit einer unendlichen Anzahl lokaler Register vorstellen. <br><br>  Beim Entwerfen eines Compilers besteht ein großer Vorteil darin, die Quellsprache in eine Zwischendarstellung (IR) zu kompilieren, anstatt sie in die Zielarchitektur (z. B. x86) zu kompilieren. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  Die Idee, eine Zwischensprache in Compilern zu verwenden, ist weit verbreitet.  GCC verwendet GIMPLE, Roslyn verwendet CIL, LLVM verwendet LLVM IR. <br></div></div><br>  Da viele Optimierungstechniken üblich sind (z. B. Entfernen von nicht verwendetem Code, Verteilen von Konstanten), können diese Optimierungsdurchläufe direkt auf IR-Ebene durchgeführt und von allen Zielplattformen verwendet werden. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  Die Verwendung einer Zwischensprache (IR) reduziert somit die Anzahl der für n Quellsprachen und m Zielarchitekturen (Backends) erforderlichen Kombinationen von n * m auf n + m. <br></div></div><br>  Daher bestehen Compiler häufig aus drei Teilen: Frontend, Middleland und Backend. Jeder von ihnen führt seine eigene Aufgabe aus, akzeptiert Eingaben und / oder gibt IR-Ausgaben. <br><br><ul><li>  Frontend: Kompiliert die Ausgangssprache im IR </li><li>  Middleland: optimiert IR </li><li>  Backend: Kompiliert IR in Maschinencode </li></ul><br><img src="https://habrastorage.org/webt/i_/pc/q6/i_pcq6eyhimm7drjixdnwrkog60.png"><br><br><h4>  Beispielprogramm für LLVM IR-Assembler </h4><br>  Betrachten Sie das folgende Programm, um eine Vorstellung davon zu bekommen, wie der LLVM-IR-Assembler aussieht. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">2</span></span>*b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); }</code> </pre> <br>  Wir verwenden Clang und kompilieren den obigen C-Code in LLVM IR Assembler. <br><br><div class="spoiler">  <b class="spoiler_title">Clang</b> <div class="spoiler_text">  clang -S -emit-llvm -o foo.ll foo.c. <br></div></div><br><pre> <code class="cpp hljs">define i32 @f(i32 %a, i32 %b) { ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">0</span></span> %<span class="hljs-number"><span class="hljs-number">1</span></span> = mul i32 <span class="hljs-number"><span class="hljs-number">2</span></span>, %b %<span class="hljs-number"><span class="hljs-number">2</span></span> = add i32 %a, %<span class="hljs-number"><span class="hljs-number">1</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">2</span></span> } define i32 @main() { ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">0</span></span> %<span class="hljs-number"><span class="hljs-number">1</span></span> = call i32 @f(i32 <span class="hljs-number"><span class="hljs-number">10</span></span>, i32 <span class="hljs-number"><span class="hljs-number">20</span></span>) ret i32 %<span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Wenn wir uns den obigen LLVM-IR-Assembler-Code ansehen, können wir einige bemerkenswerte LLVM-IR-Funktionen feststellen, nämlich: <br><br>  LLVM IR ist statisch typisiert (d. H. 32-Bit-Ganzzahlen werden vom Typ i32 geschnitten). <br><br>  Lokale Variablen haben einen Gültigkeitsbereich innerhalb der Funktion (d. H.% 1 in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">main</a> unterscheidet sich von% 1 in @f). <br><br>  Unbenannte (temporäre Register) erhalten in jeder der Funktionen lokale Kennungen (z. B.% 1,% 2) in aufsteigender Reihenfolge.  Jede Funktion kann eine unendliche Anzahl von Registern verwenden (nicht auf 32 Allzweckregister beschränkt).  Globale Bezeichner (z. B. @f) und lokale Bezeichner (z. B.% a,% 1) werden durch ein Präfix (@ bzw.%) unterschieden. <br><br>  Die meisten Befehle machen das, was Sie erwarten, also multipliziert mul, addiert Addition usw. <br><br>  Kommentare beginnen mit, wie es in Assemblersprachen üblich ist. <br><br><h4>  LLMV IR Assembler Struktur </h4><br>  Der Inhalt der LLVM-IR-Assemblydatei ist ein Modul.  Das Modul enthält übergeordnete Deklarationen wie globale Variablen und Funktionen. <br><br>  Eine Funktionsdeklaration enthält keine Basisblöcke, eine Funktionsdefinition enthält einen oder mehrere Basisblöcke (d. H. Einen Funktionskörper). <br><br>  Ein detaillierteres Beispiel des LLVM-IR-Moduls ist unten angegeben.  einschließlich der Definition der globalen Variablen @foo und der Definition der @ f-Funktion, die drei Basisblöcke enthält (% entry,% block_1 und% block_2). <br><br><pre> <code class="cpp hljs">;  ,  <span class="hljs-number"><span class="hljs-number">32</span></span>-  <span class="hljs-number"><span class="hljs-number">21</span></span> @foo = global i32 <span class="hljs-number"><span class="hljs-number">21</span></span> ; f  <span class="hljs-number"><span class="hljs-number">42</span></span>,   cond ,  <span class="hljs-number"><span class="hljs-number">0</span></span>    define i32 @f(i1 %cond) { ;       ,     ;      entry: ;     br    block_1,  %cond ; ,   block_2   . br i1 %cond, label %block_1, label %block_2 ;     ,    ,     block_1: %tmp = load i32, i32* @foo %result = mul i32 %tmp, <span class="hljs-number"><span class="hljs-number">2</span></span> ret i32 %result ;     ,     ,     block_2: ret i32 <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><h4>  Basiseinheit </h4><br>  Eine Basiseinheit ist eine Folge von Befehlen, die keine Übergangsbefehle (Beendigungsbefehle) sind.  Die Schlüsselidee der Basiseinheit ist, dass, wenn ein Befehl der Basiseinheit ausgeführt wird, alle anderen Befehle der Basiseinheit ausgeführt werden.  Dies vereinfacht die Analyse des Ausführungsflusses. <br><br><h4>  Das Team </h4><br>  Ein Befehl, der kein Sprungbefehl ist, führt normalerweise Berechnungen oder Speicherzugriff durch (z. B. Hinzufügen, Laden), ändert jedoch nicht den Steuerungsfluss des Programms. <br><br><h4>  Kündigungsteam </h4><br>  Der Beendigungsbefehl befindet sich am Ende jeder Basiseinheit und bestimmt, wo der Übergang am Ende der Basiseinheit erfolgen soll.  Beispielsweise gibt der Befehl zum Beenden von ret den Steuerungsfluss der aufrufenden Funktion zurück, und br führt den Übergang aus, bedingt oder bedingungslos. <br><br><h4>  SSA-Formular </h4><br>  Eine sehr wichtige Eigenschaft von LLVM IR ist, dass es in der SSA-Form (Static Single Assignment) geschrieben ist, was im Wesentlichen bedeutet, dass jedes Register nur einmal zugewiesen wird.  Diese Eigenschaft vereinfacht die statische Analyse des Datenstroms. <br><br>  Um Variablen zu verarbeiten, die im ursprünglichen Quellcode mehrmals zugewiesen wurden, wird der Befehl phi in LLVM IR verwendet.  Der Befehl phi gibt im Wesentlichen einen einzelnen Wert aus einer Reihe von Eingabewerten zurück, je nachdem, auf welchem ​​Ausführungspfad dieser Befehl erreicht wurde.  Jeder Eingabewert ist somit einem vorhergehenden Eingabeblock zugeordnet. <br><br>  Betrachten Sie als Beispiel die folgende LLVM-IR-Funktion: <br><br><pre> <code class="cpp hljs">define i32 @f(i32 %a) { ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> i32 %a, label %<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [ i32 <span class="hljs-number"><span class="hljs-number">42</span></span>, label %case1 ] case1: %x<span class="hljs-number"><span class="hljs-number">.1</span></span> = mul i32 %a, <span class="hljs-number"><span class="hljs-number">2</span></span> br label %ret <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: %x<span class="hljs-number"><span class="hljs-number">.2</span></span> = mul i32 %a, <span class="hljs-number"><span class="hljs-number">3</span></span> br label %ret ret: %x<span class="hljs-number"><span class="hljs-number">.0</span></span> = phi i32 [ %x<span class="hljs-number"><span class="hljs-number">.2</span></span>, %<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> ], [ %x<span class="hljs-number"><span class="hljs-number">.1</span></span>, %case1 ] ret i32 %x<span class="hljs-number"><span class="hljs-number">.0</span></span> }</code> </pre> <br>  Der Befehl phi (manchmal auch als Phi-Knoten bezeichnet) im obigen Beispiel simuliert verschiedene Zuweisungen unter Verwendung einer Reihe möglicher Eingabewerte, einen für jeden möglichen Pfad im Ausführungsthread, was zu einer Variablenzuweisung führt.  Beispielsweise lautet einer der entsprechenden Pfade im Datenstrom wie folgt: <br><br><img src="https://habrastorage.org/webt/ng/zd/h3/ngzdh3seqkmiww9rsn9as7czeg4.png"><br><br>  Im Allgemeinen können bei der Entwicklung eines Compilers, der Quellcode in LLVM-IR konvertiert, alle lokalen Quellcodevariablen in SSA-Form konvertiert werden, mit Ausnahme der Variablen, für die ihre Adresse verwendet wird. <br><br>  Um die Implementierung des LLVM-Frontends zu vereinfachen, wird empfohlen, lokale Variablen in der Ausgangssprache als im Speicher zugewiesene Variablen (unter Verwendung von Alloca) zu modellieren, Zuweisungen zu lokalen Variablen als Schreibvorgänge in den Speicher zu simulieren und eine lokale Variable als Lesevorgänge aus dem Speicher zu verwenden.  Der Grund ist, dass es eine nicht triviale Aufgabe sein kann, die Ausgangssprache in SSA-Form direkt in LLVM IR zu übersetzen.  Solange Speicherzugriffe bestimmten Mustern folgen, können wir uns auf den mem2reg-Optimierungsdurchlauf als Teil von LLVM verlassen, um im Speicher zugewiesene lokale Variablen in Register in SSA-Form umzuwandeln (ggf. unter Verwendung von Phi-Knoten). <br><br><h3>  LLVM IR-Bibliothek auf pure Go </h3><br>  Es gibt zwei Hauptbibliotheken für die Arbeit mit LLVM IR in Go: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://godoc.org/llvm.org/llvm/bindings/go/llvm</a> : offizielle LLVM-Bindungen für die Go-Sprache. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/llir/llvm</a> : Eine saubere Go-Bibliothek für die Interaktion mit LLVM IR. <br><br>  Offizielle LLVM-Bindungen für die Go-Sprache verwenden Cgo, um Zugriff auf die umfangreichen und leistungsstarken APIs des LLVM-Compiler-Frameworks zu gewähren, während das llir / llvm-Projekt vollständig in Go geschrieben ist und LLVM-IR für die Interaktion mit dem LLVM-Framework verwendet. <br><br>  Dieser Artikel konzentriert sich auf llir / llvm, kann jedoch verallgemeinert werden, um mit anderen Bibliotheken zu arbeiten. <br><br><h4>  Warum eine neue Bibliothek schreiben? </h4><br>  Die Hauptmotivation für die Entwicklung einer sauberen Go-Bibliothek für die Interaktion mit LLVM IR bestand darin, das Schreiben von Compilern und statischen Analysetools, die auf dem LLVM IR-Kompilierungsframework basieren, zu einer unterhaltsameren Aufgabe zu machen.  Es wurde auch durch die Tatsache beeinflusst, dass die Kompilierungszeit eines Projekts, das auf offiziellen LLVM-Bindungen mit Go basiert, erheblich sein kann (dank @aykevl, dem Autor von TinyGo, ist es jetzt möglich, die Kompilierung aufgrund dynamischer Verknüpfung im Gegensatz zur Standardversion von LLVM 4 zu beschleunigen). <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  Das Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/aykevl/go-llvm</a> bietet Go-Ordner für das auf dem System installierte LLVM. <br></div></div><br>  Eine weitere große Motivation war es, die Go-API von Grund auf neu zu entwickeln.  Der Hauptunterschied zwischen den LLVM-Bindungs-APIs für Go und llir / llvm besteht darin, wie LLVM-Werte modelliert werden.  In LLVM-Bindemitteln für Go werden LLVM-Werte als konkreter Strukturtyp modelliert, der im Wesentlichen alle möglichen Methoden für alle möglichen LLVM-Werte enthält.  Meine persönlichen Erfahrungen mit dieser API legen nahe, dass es schwierig ist zu wissen, welche Teilmenge von Methoden einen bestimmten Wert aufrufen darf.  Um beispielsweise einen Opcode für Anweisungen zu erhalten, rufen Sie die intuitive InstructionOpcode-Methode auf.  Wenn Sie jedoch stattdessen die Opcode-Methode aufrufen, mit der der Opcode eines konstanten Ausdrucks abgerufen werden soll, wird ein Laufzeitfehler angezeigt: "Argument cast () vom inkompatiblen Typ!"  (Umwandlung des Arguments in einen inkompatiblen Typ). <br><br>  Die llir / llvm-Bibliothek wurde entwickelt, um Typen zur Kompilierungszeit zu überprüfen und sicherzustellen, dass sie mit dem Go-Typsystem korrekt verwendet werden.  LLVM-Werte in llir / llvm werden als Schnittstellentypen modelliert.  Dieser Ansatz stellt nur eine minimale Anzahl von Methoden zur Verfügung, die von allen Werten gemeinsam genutzt werden. Wenn Sie auf bestimmte Methoden oder Felder zugreifen möchten, verwenden Sie die Typumschaltung (wie im folgenden Beispiel gezeigt). <br><br><h4>  Anwendungsbeispiel </h4><br>  Schauen wir uns nun einige Beispiele für bestimmte Verwendungszwecke an.  Lassen Sie uns eine Bibliothek haben, aber was sollen wir mit dem LLVM IR tun? <br><br>  Zunächst möchten wir möglicherweise die LLVM-IR analysieren, die von einem anderen Tool wie Clang und dem Optimierer LLVM opt generiert wurde (siehe Beispieleingabe unten). <br><br>  Zweitens möchten wir möglicherweise das LLVM-IR verarbeiten und eine eigene Analyse durchführen oder eigene Optimierungsdurchläufe durchführen oder einen Interpreter oder einen JIT-Compiler implementieren (siehe das folgende Analysebeispiel). <br><br>  Drittens möchten wir möglicherweise eine LLVM-IR generieren, die als Eingabe für andere Instrumente dient.  Dieser Ansatz kann gewählt werden, wenn wir ein Frontend für eine neue Programmiersprache entwickeln (siehe den folgenden Beispielausgabecode). <br><br>  Beispiel-Eingabecode - LLVM-IR-Analyse <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       LLVM IR,    //     package main import ( "fmt" "github.com/llir/llvm/asm" ) func main() { //    LLVM IR. m, err := asm.ParseFile("foo.ll") if err != nil { panic(err) } // ,    LLVM IR. // Print LLVM IR module. fmt.Println(m) }</span></span></code> </pre> <br>  Analysebeispiel - Verarbeitung von LLVM IR <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      LLVM IR     //  Graphviz DOT package main import ( "bytes" "fmt" "io/ioutil" "github.com/llir/llvm/asm" "github.com/llir/llvm/ir" ) func main() { //    LLVM IR. m, err := asm.ParseFile("foo.ll") if err != nil { panic(err) } //    . callgraph := genCallgraph(m) //      Graphviz DOT. if err := ioutil.WriteFile("callgraph.dot", callgraph, 0644); err != nil { panic(err) } } // genCallgraph      Graphviz DOT    LLVM IR func genCallgraph(m *ir.Module) []byte { buf := &amp;bytes.Buffer{} buf.WriteString("digraph {\n") //      for _, f := range m.Funcs { //   caller := f.Ident() fmt.Fprintf(buf, "\t%q\n", caller) //       for _, block := range f.Blocks { //   ,       . for _, inst := range block.Insts { //  .   call. switch inst := inst.(type) { case *ir.InstCall: callee := inst.Callee.Ident() //        . fmt.Fprintf(buf, "\t%q -&gt; %q\n", caller, callee) } } //     switch term := block.Term.(type) { case *ir.TermRet: //  - _ = term } } } buf.WriteString("}") return buf.Bytes() }</span></span></code> </pre> <br>  Beispielausgabecode - LLVM-IR-Generierung <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     LLVM IR,    C, //    . // // int abs(int x); // // int seed = 0; // // // ref: https://en.wikipedia.org/wiki/Linear_congruential_generator // // a = 0x15A4E35 // // c = 1 // int rand(void) { // seed = seed*0x15A4E35 + 1; // return abs(seed); // } package main import ( "fmt" "github.com/llir/llvm/ir" "github.com/llir/llvm/ir/constant" "github.com/llir/llvm/ir/types" ) func main() { //      i32 := types.I32 zero := constant.NewInt(i32, 0) a := constant.NewInt(i32, 0x15A4E35) //  PRNG. c := constant.NewInt(i32, 1) //  PRNG. //    LLVM IR. m := ir.NewModule() //         . // // int abs(int x); abs := m.NewFunc("abs", i32, ir.NewParam("x", i32)) //         . // // int seed = 0; seed := m.NewGlobalDef("seed", zero) //        . // // int rand(void) { ... } rand := m.NewFunc("rand", i32) //           `rand`. entry := rand.NewBlock("") //         . tmp1 := entry.NewLoad(seed) tmp2 := entry.NewMul(tmp1, a) tmp3 := entry.NewAdd(tmp2, c) entry.NewStore(tmp3, seed) tmp4 := entry.NewCall(abs, tmp3) entry.NewRet(tmp4) //   LLVM IR  . fmt.Println(m) }</span></span></code> </pre> <br><h3>  Fazit </h3><br>  Die Entwicklung und Implementierung von llir / llvm wurde von einer Community von Mitwirkenden durchgeführt und geleitet, die nicht nur Code geschrieben, sondern auch Diskussionen geführt, Programmiersitzungen gepaart, debuggt, profiliert und im Lernprozess neugierig gezeigt haben. <br><br>  Einer der schwierigsten Teile des llir / llvm-Projekts war die Erstellung einer EBNF-Grammatik für LLVM-IR, die die gesamte LLVM-IR-Sprache bis zur Version LLVM 7.0 abdeckt.  Die Schwierigkeit liegt hier nicht im Prozess selbst, sondern in der Tatsache, dass es keine offiziell veröffentlichte Grammatik gibt, die die gesamte Sprache abdeckt.  Einige Open-Source-Communities haben versucht, eine formale Grammatik für den LLVM-Assembler zu definieren, aber sie decken, soweit wir wissen, nur Teilmengen der Sprache ab. <br><br>  Grammatik LLVM IR ebnet den Weg für interessante Projekte.  Beispielsweise kann die Generierung eines syntaktisch gültigen LLVM-IR-Assemblers für verschiedene Tools und Bibliotheken unter Verwendung von LLVM-IR verwendet werden. Ein ähnlicher Ansatz wird in GoSmith verwendet.  Dies kann zur Kreuzvalidierung von in anderen Sprachen implementierten LLVM-Projekten sowie zur Überprüfung auf Schwachstellen und Implementierungsfehler verwendet werden. <br><br>  Die Zukunft ist wunderbar, fröhliches Hacken! <br><br><h3>  Referenzen </h3><br>  1. Ein sehr gut geschriebenes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel</a> über LLVM, geschrieben von Chris Lattner, dem Autor des ersten LLVM-Projekts, im Buch „Architektur von Open Source-Anwendungen“. <br><br>  2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Tutorial Implementieren einer Sprache mit LLVM</a> - oft auch als Kaleidoscope Language Guide bezeichnet - beschreibt ausführlich, wie eine einfache Programmiersprache implementiert wird, die in LLVM IR kompiliert wurde.  Der Artikel beschreibt alle Hauptphasen des Schreibens eines Frontends, einschließlich eines lexikalischen Analysators, eines Parsers und der Codegenerierung. <br><br>  3. Für diejenigen, die einen Compiler aus der Eingabesprache in LLVM IR schreiben möchten, wird das Buch " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mapping High Level Constructs to LLVM IR</a> " empfohlen. <br><br>  Ein guter Satz von Folien ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM,</a> das ausführlich die wichtigen Konzepte von LLVM IR beschreibt, eine Einführung in die LLVM C ++ - API bietet und einige sehr nützliche Passagen zur LLVM-Optimierung beschreibt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Go-Bindungen für LLVM</a> eignen sich für viele Projekte. Sie repräsentieren die LLVM C-API, sind leistungsstark und stabil. <br><br>  Eine gute Ergänzung zum Beitrag ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Einführung in LLVM in Go.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459704/">https://habr.com/ru/post/de459704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459688/index.html">Urbanismus in China: Weniger Hipster, mehr Wissenschaft und IT</a></li>
<li><a href="../de459692/index.html">Wie wir Materialmodifikationen entdeckten, die etablierten chemischen Prinzipien widersprechen</a></li>
<li><a href="../de459694/index.html">Museum DataArt. Packen Sie Radio 86RK aus und starten Sie es</a></li>
<li><a href="../de459696/index.html">AI-basierte Fotorestaurierung</a></li>
<li><a href="../de459698/index.html">Wie kann Oracle BI 12c gezwungen werden, so viele Sitzungsvariablen zu erstellen, wie ein Programmierer benötigt?</a></li>
<li><a href="../de459706/index.html">5 Gründe, warum Sie Redux in React-Anwendungen vergessen sollten</a></li>
<li><a href="../de459708/index.html">Design der Spieloberfläche. Brent Fox Worum geht es in dem Buch?</a></li>
<li><a href="../de459710/index.html">Überlebe eine Frontalkollision und warum Amnesie nicht das ist, was du denkst</a></li>
<li><a href="../de459712/index.html">Mama Hacker bei einem offiziellen Job: Was Pentester tun</a></li>
<li><a href="../de459714/index.html">Virtuelle Maschine auf dem ESP8266 zum Ausführen von Spielen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>