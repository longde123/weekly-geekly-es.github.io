<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•î üí´ üöü Debugging sebagai suatu proses ‚öóÔ∏è üßóüèæ üëë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dipercayai bahwa pengembangan membutuhkan sekitar 10% dari waktu, dan debugging membutuhkan 90%. Mungkin pernyataan ini dilebih-lebihkan, tetapi penge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Debugging sebagai suatu proses</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/420793/"> Dipercayai bahwa pengembangan membutuhkan sekitar 10% dari waktu, dan debugging membutuhkan 90%.  Mungkin pernyataan ini dilebih-lebihkan, tetapi pengembang mana pun akan setuju bahwa debugging adalah proses yang sangat intensif sumber daya, terutama dalam sistem multi-utas besar. <br><br>  Dengan demikian, optimasi dan sistematisasi dari proses debugging dapat membawa manfaat yang signifikan dalam bentuk jam kerja yang disimpan, meningkatkan kecepatan penyelesaian masalah dan, pada akhirnya, meningkatkan loyalitas pengguna Anda. <br><br><img src="https://habrastorage.org/webt/lm/eb/rk/lmebrkzzdxjbw-vsbub7ybrlxjq.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sergey Shchegrikovich</a> (dotmailer) pada konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DotNext 2018 Piter</a> menyarankan untuk melihat debugging sebagai proses yang dapat dijelaskan dan dioptimalkan.  Jika Anda masih belum memiliki rencana yang jelas untuk menemukan bug - di bawah potongan video dan transkrip teks dari laporan Sergey. <br><br>  (Dan di akhir posting, kami menambahkan permohonan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">John Skeet</a> ke semua afiliasi, pastikan untuk melihat) <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Paxi4K5Om1Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Tujuan saya adalah menjawab pertanyaan: bagaimana memperbaiki bug secara efisien dan apa yang harus menjadi fokus.  Saya pikir jawaban untuk pertanyaan ini adalah sebuah proses.  Proses debugging, yang terdiri dari aturan yang sangat sederhana, dan Anda mengetahuinya dengan baik, tetapi Anda mungkin menggunakannya tanpa sadar.  Karena itu, tugas saya adalah mensistematisasikan mereka dan menunjukkan bagaimana menjadi lebih efektif menggunakan contoh. <br><br>  Kami akan mengembangkan bahasa umum untuk komunikasi selama debugging, dan kami juga akan melihat jalur langsung untuk menemukan masalah utama.  Pada contoh saya, saya akan menunjukkan apa yang terjadi karena pelanggaran aturan ini. <br><br><h2>  Utilitas Debug </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/292/518/f94/292518f94ecd468e034d8ec952398980.png"><br>  Tentu saja, debugging apa pun tidak dimungkinkan tanpa utilitas debugging.  Favorit saya adalah: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Windbg</a> , yang di samping debugger itu sendiri, memiliki fungsi yang kaya untuk mempelajari dump memori.  Memori dump adalah sepotong keadaan proses.  Di dalamnya Anda dapat menemukan nilai bidang objek, tumpukan panggilan, tetapi, sayangnya, dump memori statis. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PerfView</a> adalah profiler yang ditulis di atas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teknologi ETW</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sysinternals</a> adalah utilitas yang ditulis oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mark Russinovich</a> , yang memungkinkan Anda untuk menggali sedikit lebih jauh ke dalam perangkat sistem operasi. <br></li></ul><br><h2>  Layanan jatuh </h2><br>  Mari kita mulai dengan contoh dari hidup saya di mana saya akan menunjukkan bagaimana sifat tidak sistematis dari proses debugging mengarah pada inefisiensi. <br><br>  Mungkin, ini terjadi pada semua orang, ketika Anda datang ke perusahaan baru dalam tim baru untuk proyek baru, maka sejak hari pertama Anda ingin melakukan manfaat yang tidak dapat diperbaiki.  Begitu juga dengan saya.  Pada saat itu, kami memiliki layanan yang menerima html untuk input, dan gambar output untuk output. <br><br>  Layanan ini ditulis di bawah .Net 3.0 dan sudah sangat lama.  Layanan ini memiliki fitur kecil - macet.  Jatuh sesering mungkin, sekitar sekali setiap dua atau tiga jam.  Kami memperbaiki ini secara elegan - mengatur properti mulai ulang di properti layanan setelah musim gugur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0cc/b02/1a2/0ccb021a20b6c50d1639cd3e2bef7c28.png"><br><br>  Layanan itu tidak penting bagi kami dan kami bisa bertahan.  Tetapi saya bergabung dengan proyek dan hal pertama yang saya putuskan adalah memperbaikinya. <br><br>  Di mana pengembang .NET pergi jika ada sesuatu yang tidak berfungsi?  Mereka pergi ke EventViewer.  Tetapi di sana saya tidak menemukan apa pun kecuali catatan bahwa layanan itu jatuh.  Tidak ada pesan tentang kesalahan asli, atau tumpukan panggilan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be3/bdf/2fe/be3bdf2fe39777092ad0f2989e35d92e.png"><br><br>  Ada alat yang terbukti untuk apa yang harus dilakukan selanjutnya - kami membungkus seluruh <code>main</code> dalam <code>try-catch</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ProcessRequest(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogError(ex); }</code> </pre><br>  Idenya sederhana: <code>try-catch</code> akan bekerja, itu akan mengganggu kita, kita akan membacanya dan memperbaiki layanan.  Kami mengkompilasi, menyebarkan ke produksi, layanan macet, tidak ada kesalahan.  Tambahkan <code>catch</code> lain. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ProcessRequest(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogError(ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { LogError(); }</code> </pre><br>  Kami ulangi prosesnya: layanan macet, tidak ada kesalahan dalam log.  Hal terakhir yang dapat membantu <code>finally</code> , yang selalu disebut. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ProcessRequest(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogError(ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { LogError(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { LogEndOfExecution(); }</code> </pre><br>  Kami mengkompilasi, menyebarkan, layanan macet, tidak ada kesalahan.  Tiga hari berlalu di belakang proses ini, sekarang pikiran sudah datang bahwa kita akhirnya harus mulai berpikir dan melakukan sesuatu yang lain.  Anda dapat melakukan banyak hal: mencoba mereproduksi kesalahan pada mesin lokal, menonton dump memori, dll.  Sepertinya dua hari lagi dan saya akan memperbaiki bug ini ... <br><br>  Dua minggu telah berlalu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1eb/f02/0c3/1ebf020c3dde595f5423fd8247c3137b.png"><br><br>  Saya mencari di PerformanceMonitor, di mana saya melihat layanan yang macet, lalu naik, lalu turun lagi.  Kondisi ini disebut <i>keputusasaan</i> dan terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/e07/904/98be07904a35b99130ba9ddf871af47f.png"><br><br>  Dalam berbagai label ini, apakah Anda mencoba mencari tahu di mana masalahnya sebenarnya?  Setelah beberapa jam meditasi, masalah tiba-tiba muncul: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/379/2ba/caa/3792bacaa7c418f5fcffa318729bf1a0.png"><br><br>  Garis merah adalah jumlah pegangan asli yang dimiliki proses.  Pegangan asli adalah referensi ke sumber daya sistem operasi: file, registri, kunci registri, mutex, dll.  Untuk beberapa kombinasi situasi yang aneh, penurunan dalam jumlah gagang bertepatan dengan saat-saat ketika layanan turun.  Ini mengarah pada gagasan bahwa di suatu tempat ada kebocoran pegangan. <br><br>  Kami mengambil dump memori, buka di WinDbg.  Kami mulai menjalankan perintah.  Mari kita coba untuk melihat antrian finalisasi objek-objek yang harus dibebaskan oleh aplikasi. <br><br><pre> <code class="hljs erlang-repl"><span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">000</span></span>&gt; !FinalizeQueue</code> </pre><br>  Di akhir daftar, saya menemukan browser web. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6f/aa5/eb3/d6faa5eb38c3b7a4429e55d7f8af655e.png"><br>  Solusinya sederhana - ambil WebBrowser dan panggil <code>dispose</code> untuk itu: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> webBrowser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebBrowser()) { <span class="hljs-comment"><span class="hljs-comment">// Processing ... } }</span></span></code> </pre><br>  Kesimpulan dari cerita ini dapat ditarik sebagai berikut: dua minggu terlalu lama dan terlalu lama untuk menemukan <code>dispose</code> diundang;  bahwa kami menemukan solusi untuk masalah ini - keberuntungan, karena tidak ada pendekatan khusus, tidak ada sifat sistematis. <br><br>  Setelah itu, saya punya pertanyaan: bagaimana cara debut yang efektif dan apa yang harus dilakukan? <br><br>  Untuk melakukan ini, Anda hanya perlu tahu tiga hal: <br><br><ol><li>  Aturan Debugging <br></li><li>  Algoritma untuk menemukan kesalahan. <br></li><li>  Teknik debugging proaktif. <br></li></ol><br><h2>  Aturan Debugging </h2><br><ol><li>  Ulangi kesalahan itu. <br></li><li>  Jika Anda belum memperbaiki kesalahan, maka itu tidak diperbaiki. <br></li><li>  Pahami sistemnya. <br></li><li>  Periksa colokannya. <br></li><li>  Bagilah dan taklukkan. <br></li><li>  Menyegarkan diri. <br></li><li>  Ini adalah bug Anda. <br></li><li>  Lima alasannya. <br></li></ol><br>  Ini adalah aturan yang cukup jelas yang menggambarkan diri mereka sendiri. <br><br>  Ulangi kesalahan itu.  Aturan yang sangat sederhana, karena jika Anda tidak dapat membuat kesalahan, maka tidak ada yang diperbaiki.  Tetapi ada beberapa kasus yang berbeda, terutama untuk bug di lingkungan multi-threaded.  Kami entah bagaimana memiliki kesalahan yang hanya muncul pada prosesor Itanium dan hanya pada server produksi.  Oleh karena itu, tugas pertama dalam proses debugging adalah menemukan konfigurasi bangku tes tempat kesalahan akan direproduksi. <br><br>  Jika Anda belum memperbaiki kesalahan, maka itu tidak diperbaiki.  Kadang-kadang ini terjadi: pelacak bug berisi bug yang muncul setengah tahun yang lalu, tidak ada yang melihatnya sejak lama, dan ada keinginan untuk menutupnya.  Tetapi pada saat ini kita kehilangan kesempatan untuk mengetahui, kesempatan untuk memahami cara kerja sistem kita dan apa yang sebenarnya terjadi padanya.  Karenanya, bug apa pun adalah peluang baru untuk mempelajari sesuatu, mempelajari lebih lanjut tentang sistem Anda. <br><br>  Pahami sistemnya.  Brian Kernighan pernah berkata bahwa jika kita begitu pintar untuk menulis sistem ini, maka kita harus pintar dua kali lipat untuk memulai itu. <br><br>  Contoh kecil untuk aturan.  Pemantauan kami menggambar grafik: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/bfa/85b/4cfbfa85be2cf375741646b55aa373e6.png"><br>  Ini adalah grafik jumlah permintaan yang diproses oleh layanan kami.  Setelah melihatnya, kami datang dengan ide bahwa mungkin untuk meningkatkan kecepatan layanan.  Dalam hal ini, jadwal meningkat, dimungkinkan untuk mengurangi jumlah server. <br><br>  Optimalisasi kinerja web dilakukan cukup: kita mengambil PerfView, menjalankannya di mesin produksi, menghilangkan jejak dalam waktu 3-4 menit, kita mengambil jejak ini ke mesin lokal dan mulai mempelajarinya. <br><br>  Salah satu statistik yang ditampilkan PerfView adalah pengumpul sampah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3a/ed0/c3f/d3aed0c3f4d3c6de77840aa9ffc10004.png"><br><br>  Melihat statistik ini, kami melihat bahwa layanan ini menghabiskan 85% waktunya mengumpulkan sampah.  Anda dapat melihat di PerfView persis di mana waktu ini dihabiskan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb5/cd2/e4a/bb5cd2e4a54d4f71d832482217233281.png"><br><br>  Dalam kasus kami, ini menciptakan string.  Koreksi itu sendiri menunjukkan sendiri: kami mengganti semua string dengan StringBuilders.  Secara lokal, kami mendapatkan peningkatan produktivitas 20-30%.  Menyebarkan produksi, lihat hasilnya dibandingkan dengan jadwal lama: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/060/d63/21d/060d6321d41fa993d80d7b9d19d2d95c.png"><br><br>  Aturan "Memahami Sistem" tidak hanya tentang memahami bagaimana interaksi terjadi di sistem Anda, bagaimana pesan pergi, tetapi tentang mencoba memodelkan sistem Anda. <br><br>  Dalam contoh, grafik menunjukkan bandwidth.  Tetapi jika Anda melihat keseluruhan sistem dari sudut pandang teori antrian, ternyata throughput sistem kami hanya bergantung pada satu parameter - kecepatan kedatangan pesan baru.  Faktanya, sistem tidak memiliki lebih dari 80 pesan sekaligus, jadi tidak ada cara untuk mengoptimalkan jadwal ini. <br><br>  Periksa colokannya.  Jika Anda membuka dokumentasi alat rumah, maka pasti akan tertulis di sana: jika alat tidak berfungsi, periksa apakah steker dimasukkan ke dalam stopkontak.  Setelah beberapa jam di debugger, saya sering mendapati diri saya berpikir bahwa saya hanya perlu mengkompilasi ulang atau hanya mengambil versi terbaru. <br><br>  Aturan "periksa colokan" adalah tentang fakta dan data.  Debugging tidak dimulai dengan menjalankan WinDbg atau PerfView pada mesin produksi, itu dimulai dengan memeriksa fakta dan data.  Jika layanan tidak merespons, itu mungkin tidak berjalan. <br><br>  Bagilah dan taklukkan.  Ini adalah aturan pertama dan mungkin satu-satunya yang menyertakan debugging sebagai suatu proses.  Ini tentang hipotesis, promosi dan pengujian mereka. <br><br>  Salah satu layanan kami tidak mau berhenti. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f2/cff/169/4f2cff1697473f917e815384d773149a.png"><br><br>  Kami membuat hipotesis: mungkin ada siklus dalam proyek yang memproses sesuatu tanpa henti. <br><br>  Anda dapat menguji hipotesis dengan berbagai cara, satu opsi adalah mengambil dump memori.  Kami mengeluarkan tumpukan panggilan dari dump dan semua utas menggunakan perintah <code>~*e!ClrStack</code> .  Kami mulai melihat dan melihat tiga aliran. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d3/a54/35b/1d3a5435b697646daaf802e2bd838c7e.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f3/185/6b2/2f31856b23147722d7b3e534689572f8.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0f/ac7/760/d0fac7760f4e8e201d0f028c4deae23e.png"><br><br>  Utas pertama ada di Main, yang kedua ada di handler <code>OnStop()</code> , dan utas ketiga menunggu beberapa tugas internal.  Dengan demikian, hipotesis kami tidak dibenarkan.  Tidak ada perulangan, semua utas sedang menunggu sesuatu.  Kemungkinan besar jalan buntu. <br><br>  Layanan kami berfungsi sebagai berikut.  Ada dua tugas - inisialisasi dan kerja.  Inisialisasi membuka koneksi ke database, pekerja mulai memproses data.  Komunikasi di antara mereka terjadi melalui flag umum, yang diimplementasikan menggunakan <code>TaskCompletionSource</code> . <br><br>  Kami membuat hipotesis kedua: mungkin kami memiliki jalan buntu dari satu tugas untuk yang kedua.  Untuk memeriksa ini, Anda dapat melihat setiap tugas secara terpisah melalui WinDbg. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c0f/536/1cf/c0f5361cf09ba6cd40d9a72e6d5dfb06.png"><br><br>  Ternyata salah satu tugas jatuh, dan yang kedua tidak.  Dalam proyek tersebut, kami melihat kode berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> openAsync(); _initLock.SetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  Ini berarti bahwa tugas inisialisasi membuka koneksi dan setelah itu menetapkan <code>TaskCompletionSource</code> menjadi true.  Tetapi bagaimana jika suatu Pengecualian jatuh di sini?  Maka kita tidak punya waktu untuk mengatur <code>SetResult</code> menjadi true, jadi perbaikan untuk bug ini seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> openAsync(); _initLock.SetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception ex) { _initLock.SetException(ex); }</code> </pre><br>  Dalam contoh ini, kami mengajukan dua hipotesis: loop tak terbatas dan jalan buntu.  Aturan "membagi dan menaklukkan" membantu untuk melokalisasi kesalahan.  Perkiraan yang berurutan memecahkan masalah seperti itu. <br><br>  Hal terpenting dalam aturan ini adalah hipotesis, karena seiring waktu mereka berubah menjadi pola.  Dan tergantung pada hipotesis, kami menggunakan tindakan yang berbeda. <br><br>  Menyegarkan diri.  Aturan ini adalah Anda hanya perlu bangkit dari meja dan berjalan, minum air, jus atau kopi, melakukan apa saja, tetapi yang paling penting adalah mengalihkan perhatian dari masalah Anda. <br><br>  Ada metode yang sangat bagus yang disebut bebek.  Menurut metodenya, kita harus menceritakan tentang masalah <i>merunduk</i> .  Anda bisa menggunakan kolega sebagai <i>bebek</i> .  Apalagi dia tidak harus menjawab, cukup dengarkan dan setujui.  Dan seringkali, setelah pembicaraan pertama tentang masalah, Anda sendiri menemukan solusinya. <br><br>  Ini adalah bug Anda.  Saya akan menceritakan tentang aturan ini dengan sebuah contoh. <br><br>  Ada masalah dalam satu <code>AccessViolationException</code> .  Mencari di tumpukan panggilan, saya melihat bahwa itu terjadi ketika kami membuat permintaan LinqToSql di dalam klien sql. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd2/849/7a6/fd28497a66853c5bcf17eaa9d978524a.png"><br><br>  Dari bug ini jelas bahwa di suatu tempat integritas memori dilanggar.  Untungnya, saat itu kami sudah menggunakan sistem manajemen perubahan.  Akibatnya, setelah beberapa jam, menjadi jelas apa yang terjadi: kami memasang .Net 4.5.2 di mesin produksi kami. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f24/bc8/438/f24bc84388e43df0ad4e7af27c0bbc24.png"><br><br>  Oleh karena itu, kami mengirim bug ke Microsoft, mereka memeriksanya, kami berkomunikasi dengan mereka, mereka memperbaiki bug di .Net 4.6.1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44a/c39/535/44ac39535a874ff0ea0f599a55f07252.png"><br><br>  Bagi saya, ini menghasilkan 11 bulan bekerja dengan dukungan Microsoft, tentu saja, tidak setiap hari, tetapi butuh 11 bulan sejak awal untuk memperbaikinya.  Selain itu, kami mengirimi mereka puluhan gigabytes dump memori, kami menempatkan ratusan rakitan pribadi untuk menangkap kesalahan ini.  Dan selama ini, kami tidak bisa memberi tahu pelanggan kami bahwa Microsoft yang harus disalahkan, bukan kami.  Karena itu, bug selalu menjadi milik Anda. <br><br>  Lima alasannya.  Kami di perusahaan kami menggunakan Elastis.  Elastis bagus untuk agregasi log. <br><br>  Anda datang untuk bekerja di pagi hari, dan kebohongan elastis. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a1/c80/09b/1a1c8009b49f9c288b3c4b29daf194cc.png"><br><br>  Pertanyaan pertama adalah mengapa elastis?  Segera menjadi jelas - Master Nodes jatuh.  Mereka mengoordinasikan pekerjaan seluruh cluster dan ketika mereka jatuh, seluruh cluster berhenti merespons.  Mengapa mereka tidak bangkit?  Mungkin harus ada start otomatis?  Setelah mencari jawabannya, kami menemukan bahwa versi plugin tidak cocok.  Mengapa Master Nodes jatuh sama sekali?  Mereka dibunuh oleh OOM Killer.  Ini adalah hal seperti itu pada mesin linux, yang dalam kasus kekurangan memori menutup proses yang tidak perlu.  Mengapa tidak ada cukup memori?  Karena proses pembaruan telah dimulai, yang mengikuti dari log sistem.  Mengapa itu berhasil sebelumnya, tetapi tidak sekarang?  Dan karena kami menambahkan node baru seminggu sebelumnya, maka Master Nodes membutuhkan lebih banyak memori untuk menyimpan indeks, konfigurasi cluster. <br><br>  Pertanyaan "mengapa?"  membantu menemukan akar masalah.  Dalam contoh, kita bisa mematikan jalur yang benar berkali-kali, tetapi perbaikan penuh terlihat seperti ini: kita memperbarui plugin, memulai layanan, menambah memori dan membuat catatan untuk masa depan, bahwa lain kali, ketika menambahkan node baru ke cluster, kita perlu memastikan bahwa ada cukup memori pada Master Nodes <br><br>  Penerapan aturan-aturan ini memungkinkan Anda untuk mengungkapkan masalah nyata, menggeser fokus Anda untuk menyelesaikan masalah ini dan membantu untuk berkomunikasi.  Tetapi akan lebih baik lagi jika aturan-aturan ini membentuk suatu sistem.  Dan ada sistem seperti itu, itu disebut algoritma debugging. <br><br><h2>  Algoritma debugging </h2><br>  Untuk pertama kalinya, saya membaca tentang algoritma debug dalam aplikasi Debugging buku John Robbins.  Ini menjelaskan proses debugging sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1e/2af/a07/f1e2afa078f2ab8587467660b25df052.png"><br><br>  Algoritma ini berguna untuk loop dalam - bekerja dengan hipotesis. <br><br>  Dengan setiap putaran siklus kita dapat memeriksa diri kita sendiri: apakah kita tahu lebih banyak tentang sistem atau tidak?  Jika kami mengajukan hipotesis, periksa, itu tidak berfungsi, kami tidak mempelajari hal baru tentang operasi sistem, maka mungkin saatnya untuk menyegarkan diri.  Dua pertanyaan saat ini pada titik ini: hipotesis mana yang telah Anda uji dan hipotesis mana yang Anda uji sekarang. <br><br>  Algoritma ini sangat sesuai dengan aturan debug yang kita bicarakan di atas: ulangi kesalahan - ini adalah bug Anda, jelaskan masalahnya - pahami sistemnya, rumuskan hipotesis - bagilah dan taklukkan, uji hipotesis - periksa steker, pastikan stekernya diperbaiki, lima alasannya. <br><br>  Saya punya contoh yang bagus untuk algoritma ini.  Pengecualian jatuh pada salah satu layanan web kami. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/206/a57/d71/206a57d711a7c783c9f22389120d1bf8.png"><br><br>  Pikiran pertama kita bukanlah masalah kita.  Tapi menurut aturan, ini masih masalah kita. <br><br>  Pertama, ulangi kesalahannya.  Untuk setiap seribu permintaan, ada sekitar satu <code>StructureMapException</code> , sehingga kami dapat mereproduksi masalahnya. <br><br>  Kedua, kami mencoba menggambarkan masalahnya: jika pengguna membuat permintaan http untuk layanan kami saat ini ketika StructureMap mencoba membuat ketergantungan baru, maka pengecualian terjadi. <br><br>  Ketiga, kami berhipotesis bahwa StructureMap adalah pembungkus dan ada sesuatu di dalamnya yang melempar pengecualian internal.  Kami menguji hipotesis menggunakan procdump.exe. <br><br><pre> <code class="hljs powershell">procdump.exe <span class="hljs-literal"><span class="hljs-literal">-ma</span></span> <span class="hljs-literal"><span class="hljs-literal">-e</span></span> <span class="hljs-operator"><span class="hljs-operator">-f</span></span> StructureMap w3wp.exe</code> </pre><br>  Ternyata di dalamnya ada <code>NullReferenceException</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2da/773/500/2da773500ffd18d1c28b91f6ff5b45e3.png"><br><br>  Mempelajari panggilan-tumpukan pengecualian ini, kami memahami bahwa itu terjadi di dalam objek-pembangun di StructureMap itu sendiri. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fd/347/8fc/5fd3478fc54df6295244471a33560a3d.png"><br><br>  Tapi <code>NullReferenceException</code> bukan masalah itu sendiri, tetapi konsekuensinya.  Anda perlu memahami di mana itu terjadi dan siapa yang menghasilkannya. <br><br>  Kami mengajukan hipotesis berikut: untuk beberapa alasan, kode kami mengembalikan dependensi nol.  Mengingat bahwa di. Net semua objek di memori terletak satu per satu, jika kita melihat objek di tumpukan yang ada di depan <code>NullReferenceException</code> , maka mereka mungkin akan menunjuk ke kode yang melemparkan pengecualian. <br><br>  Di WinDbg ada perintah - Daftar Objek Dekat <code>!lno</code> .  Ini menunjukkan bahwa objek yang kita minati adalah fungsi lambda, yang digunakan dalam kode berikut. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CompoundInterceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindInterceptor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type</span></span></span><span class="hljs-function">)</span></span> { CompoundInterceptop interceptor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_analyzedInterceptors.TryGetValue(type, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> interceptor)) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_locker) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_analyzedInterceptors.TryGetValue(type, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> interceptor)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interceptorArray = _interceptors.FindAll(i =&gt; i.MatchesType(type)); interceptor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompoundInterceptor(interceptorArray); _analyzedInterceptors.Add(type, interceptor); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interceptor; }</code> </pre><br>  Dalam kode ini, pertama-tama kita memeriksa apakah nilai dalam <code>Dictionary</code> <code>_analyzedInterceptors</code> di <code>_analyzedInterceptors</code> , jika kita tidak menemukannya, maka tambahkan nilai baru di dalam <code>lock</code> . <br><br>  Secara teori, kode ini tidak pernah dapat mengembalikan nol.  Tetapi masalahnya di sini adalah <code>_analyzedInterceptors</code> , yang menggunakan <code>Dictionary</code> reguler di lingkungan multi-utas, bukan <code>ConcurrentDictionary</code> . <br><br>  Akar masalah ditemukan, kami memperbarui ke versi terbaru dari StructureMap, dikerahkan, memastikan bahwa semuanya sudah diperbaiki.  Langkah terakhir dari algoritma kami adalah "belajar dan memberi tahu".  Dalam kasus kami, pencarian dalam kode semua <code>Dictionary</code> yang digunakan terkunci dan memeriksa bahwa semuanya digunakan dengan benar. <br><br>  Jadi, algoritma debugging adalah algoritma intuitif yang secara signifikan menghemat waktu.  Dia berfokus pada hipotesis - dan ini adalah hal terpenting dalam debugging. <br><br><h2>  Debugging Proaktif </h2><br>  Pada intinya, debugging proaktif menjawab pertanyaan "apa yang terjadi ketika bug muncul." <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7aa/718/900/7aa71890010a8c32900fa5b01e0b690a.png"><br><br>  Pentingnya teknik debugging proaktif dapat dilihat pada diagram siklus hidup bug. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be0/f6f/06c/be0f6f06cb0c810ca6b19cb861d998c4.png"><br><br>  Masalahnya adalah semakin lama bug hidup, semakin banyak sumber daya (waktu) yang kita habiskan untuk itu. <br><br>  Aturan debugging dan algoritma debugging memfokuskan kita pada saat bug ditemukan dan kita bisa mencari tahu apa yang harus dilakukan selanjutnya.  Bahkan, kami ingin mengalihkan fokus kami pada saat bug itu dibuat.  Saya percaya bahwa kita harus melakukan Minimum Debuggable Product (MDP), yaitu produk yang memiliki set infrastruktur minimum yang diperlukan untuk debugging yang efisien dalam produksi. <br><br>  MDP terdiri dari dua hal: fungsi kebugaran dan metode USE. <br><br>  Fitur kebugaran.  Mereka dipopulerkan oleh Neil Ford dan rekan penulis dalam buku Building Evolutionary Architecture.  Pada intinya, fungsi kebugaran, menurut penulis buku ini, terlihat seperti ini: ada arsitektur aplikasi yang dapat kita potong pada sudut yang berbeda, mendapatkan properti arsitektur seperti <i>rawatan</i> , <i>kinerja</i> , dll., Dan untuk setiap bagian seperti itu kita harus menulis tes - kebugaran -fungsi.  Dengan demikian, fungsi kebugaran adalah tes arsitektur. <br><br>  Dalam kasus MDP, fungsi kebugaran adalah tes debuggability.  Anda dapat menggunakan apa pun yang Anda suka untuk menulis tes seperti itu: NUnit, MSTest, dan sebagainya.  Tapi, karena debugging sering bekerja dengan alat eksternal, saya akan menunjukkan menggunakan Pester (kerangka pengujian unit powershell) sebagai contoh.  Kelebihannya di sini adalah bahwa ia bekerja dengan baik dengan baris perintah. <br><br>  Misalnya, di dalam perusahaan kami setuju bahwa kami akan menggunakan perpustakaan tertentu untuk login;  saat login kita akan menggunakan pola tertentu;  karakter pdb harus selalu diberikan ke server simbol.  Ini akan menjadi konvensi yang akan kami uji dalam pengujian kami. <br><br><pre> <code class="hljs powershell">Describe <span class="hljs-string"><span class="hljs-string">'Debuggability'</span></span> { It <span class="hljs-string"><span class="hljs-string">'Contains line numbers in PDBs'</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Get-ChildItem</span></span> <span class="hljs-literal"><span class="hljs-literal">-Path</span></span> . <span class="hljs-literal"><span class="hljs-literal">-Recurse</span></span> <span class="hljs-literal"><span class="hljs-literal">-Include</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span>(<span class="hljs-string"><span class="hljs-string">"*.exe"</span></span>, <span class="hljs-string"><span class="hljs-string">"*. dll "</span></span>) ` | <span class="hljs-built_in"><span class="hljs-built_in">ForEach-Object</span></span> { &amp;symchk.exe /v <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_</span></span></span><span class="hljs-string">"</span></span> /s <span class="hljs-string"><span class="hljs-string">"\\network\"</span></span> *&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> } ` | <span class="hljs-built_in"><span class="hljs-built_in">Where-Object</span></span> { <span class="hljs-variable"><span class="hljs-variable">$_</span></span> <span class="hljs-operator"><span class="hljs-operator">-like</span></span> <span class="hljs-string"><span class="hljs-string">"*Line nubmers: TRUE*"</span></span> } ` | Should <span class="hljs-operator"><span class="hljs-operator">-Not</span></span> ‚ÄìBeNullOrEmpty } }</code> </pre><br>  Tes ini memverifikasi bahwa semua karakter pdb diberikan ke server simbol dan diberikan dengan benar, yaitu yang berisi nomor baris di dalamnya.  Untuk melakukan ini, ambil versi kompilasi dari produksi, temukan semua file exe dan dll, lewati semua binari ini melalui utilitas syschk.exe, yang termasuk dalam paket alat Debugging untuk windows.  Utilitas syschk.exe memeriksa biner dengan server simbol dan, jika menemukan file pdb di sana, mencetak laporan tentang hal itu.  Dalam laporan tersebut, kami mencari baris "Nomor baris: BENAR".  Dan pada akhirnya kami memeriksa bahwa hasilnya tidak "nol atau kosong". <br><br>  Tes-tes ini harus diintegrasikan ke dalam pipa penyebaran berkelanjutan.  Setelah tes integrasi dan tes unit lulus, fungsi kebugaran diluncurkan. <br><br>  Saya akan menunjukkan satu contoh lagi dengan memeriksa pustaka yang diperlukan dalam kode. <br><br><pre> <code class="hljs powershell">Describe <span class="hljs-string"><span class="hljs-string">'Debuggability'</span></span> { It <span class="hljs-string"><span class="hljs-string">'Contains package for logging'</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Get-ChildItem</span></span> <span class="hljs-literal"><span class="hljs-literal">-Path</span></span> . <span class="hljs-literal"><span class="hljs-literal">-Recurse</span></span> <span class="hljs-literal"><span class="hljs-literal">-Name</span></span> <span class="hljs-string"><span class="hljs-string">"packages.config"</span></span> ` | <span class="hljs-built_in"><span class="hljs-built_in">ForEach-Object</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Get-Content</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_</span></span></span><span class="hljs-string">"</span></span> } ` | <span class="hljs-built_in"><span class="hljs-built_in">Where-Object</span></span> { <span class="hljs-variable"><span class="hljs-variable">$_</span></span> <span class="hljs-operator"><span class="hljs-operator">-like</span></span> <span class="hljs-string"><span class="hljs-string">"*nlog*"</span></span> } ` | Should <span class="hljs-operator"><span class="hljs-operator">-Not</span></span> ‚ÄìBeNullOrEmpty } }</code> </pre><br>  Dalam pengujian, kami mengambil semua file packages.config dan mencoba mencari pustaka nlog di dalamnya.  Demikian pula, kami dapat memverifikasi bahwa bidang id korelasi digunakan di dalam bidang nlog. <br><br>  Metode PENGGUNAAN.  Hal terakhir yang terdiri dari MDP adalah metrik yang perlu Anda kumpulkan. <br><br>  Saya akan menunjukkan dengan contoh metode USE, yang dipopulerkan oleh Brendan Gregg.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idenya sederhana: jika ada masalah dalam kode, cukup untuk mengambil tiga metrik: pemanfaatan (saturasi), kesalahan (kesalahan), yang akan membantu untuk memahami di mana masalahnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa perusahaan, misalnya Circonus (mereka melakukan pemantauan lunak), </font><font style="vertical-align: inherit;">membangun </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dashboard</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mereka </font><font style="vertical-align: inherit;">dalam bentuk metrik yang ditunjuk. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/70a/f58/382/70af583826e562f796fb0473c520db15.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda melihat secara rinci, misalnya, pada memori, kemudian gunakan adalah jumlah memori bebas, saturasi adalah jumlah akses disk, kesalahan adalah kesalahan yang telah muncul. </font><font style="vertical-align: inherit;">Karena itu, untuk membuat produk nyaman untuk debugging, Anda perlu mengumpulkan metrik USE untuk semua fitur dan semua bagian dari subsistem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda menggunakan fitur bisnis, maka, kemungkinan besar, Anda dapat membedakan tiga metrik di dalamnya:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penggunaan - waktu pemrosesan permintaan. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kejenuhan adalah panjang antrian. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesalahan - segala situasi luar biasa. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai contoh, mari kita lihat grafik jumlah permintaan yang diproses yang dibuat oleh salah satu sistem kami. </font><font style="vertical-align: inherit;">Seperti yang Anda lihat, layanan belum memproses permintaan selama tiga jam terakhir. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6cc/f89/7ab/6ccf897ab0758b344dfc940eb9be548b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hipotesis pertama yang kami buat adalah bahwa layanan telah jatuh dan kami harus memulainya kembali. </font><font style="vertical-align: inherit;">Saat memeriksa, ternyata layanan tersebut berfungsi, ia menggunakan 4-5% dari CPU. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e1/9a3/f4a/7e19a3f4a52547627e150401b0f1e7e7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hipotesis kedua adalah bahwa ada kesalahan dalam layanan yang tidak kita lihat. </font><font style="vertical-align: inherit;">Kami akan menggunakan utilitas etrace.</font></font><br><br><pre> <code class="hljs powershell">etrace -<span class="hljs-literal"><span class="hljs-literal">-kernel</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Process</span></span> ^ -<span class="hljs-literal"><span class="hljs-literal">-where</span></span> ProcessName=Ex5<span class="hljs-literal"><span class="hljs-literal">-Service</span></span> ^ -<span class="hljs-literal"><span class="hljs-literal">-clr</span></span> Exception</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilitas ini memungkinkan Anda untuk berlangganan acara ETW secara realtime dan menampilkannya di layar. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1a/d13/52b/f1ad1352bc6e02e3a660f64ce90fdc87.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melihat bahwa itu jatuh </font></font><code>OutOfMemoryException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tapi, pertanyaan kedua, mengapa tidak ada di log? </font><font style="vertical-align: inherit;">Jawabannya cepat - kami mencegatnya, mencoba membersihkan memori, menunggu sebentar dan mulai bekerja lagi.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ShouldContinue()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Do(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OutOfMemoryException) { Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); GC.CollectionCount(<span class="hljs-number"><span class="hljs-number">2</span></span>); GC.WaitForPendingFinalizers(); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hipotesis berikutnya adalah seseorang memakan seluruh ingatan. </font><font style="vertical-align: inherit;">Menurut dump memori, sebagian besar objek berada di cache.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Cache</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ConcurrentDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, String&gt; _items = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DateTime _nextClearTime = DateTime.UtcNow; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFromCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_nextClearTime &lt; DateTime.UtcNow) { _nextClearTime = DateTime.UtcNow.AddHours(<span class="hljs-number"><span class="hljs-number">1</span></span>); _items.Clear(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _items[key]; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode menunjukkan bahwa setiap jam cache harus dihapus. </font><font style="vertical-align: inherit;">Tetapi ingatan itu tidak cukup, mereka bahkan tidak mencapai pembersihan. </font><font style="vertical-align: inherit;">Mari kita lihat contoh metrik cache USE. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c6/174/634/0c6174634447a3bd1af03adf10c14cbe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menurut jadwal, segera terlihat - memori meningkat, kesalahan segera dimulai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, kesimpulan tentang apa itu debugging proaktif.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debugging adalah persyaratan arsitektur. </font><font style="vertical-align: inherit;">Sebenarnya, apa yang kami kembangkan adalah model sistem. </font><font style="vertical-align: inherit;">Sistem itu sendiri adalah byte dan bit yang ada di memori pada server produksi. </font><font style="vertical-align: inherit;">Debugging proaktif menyarankan Anda untuk memikirkan lingkungan operasional Anda.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurangi jalur bug di sistem. </font><font style="vertical-align: inherit;">Teknik debugging proaktif mencakup memeriksa semua metode publik dan argumennya; </font><font style="vertical-align: inherit;">melemparkan Pengecualian segera setelah muncul, dan tidak men-debug sampai beberapa titik dan seterusnya.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Minimum Produk Debuggable adalah alat yang baik untuk berkomunikasi satu sama lain dan mengembangkan persyaratan untuk debugging produk. </font></font><br></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jadi bagaimana cara memperbaiki bug secara efisien? </font></font></h2><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gunakan debugging proaktif. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ikuti algoritma. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uji hipotesis. </font></font><br></li></ol><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kali ini sponsor iklan kami adalah Jon Skeet. </font><font style="vertical-align: inherit;">Bahkan jika Anda tidak pergi ke Moskow untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baru </font><font style="vertical-align: inherit;">, videonya layak untuk dilihat (John berusaha keras).</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/p2SQbq-umy4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420793/">https://habr.com/ru/post/id420793/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420781/index.html">Pergudangan Data Terdistribusi dalam Konsep Danau Data: Administrasi Cluster</a></li>
<li><a href="../id420783/index.html">Manajemen Ketergantungan, Acara, dan Pola Pengamat dan Mediator</a></li>
<li><a href="../id420785/index.html">Bekerja sebagai spesialis IT di Timur Jauh - Sakhalin Oblast</a></li>
<li><a href="../id420789/index.html">(A | a) arsitektur: mengapa ini mitap non-standar untuk pengembang sistem yang sangat dimuat</a></li>
<li><a href="../id420791/index.html">Robot rumah: apa yang bisa Anda beli. Tinjauan Umum Robot Rumah Komersial yang Tersedia</a></li>
<li><a href="../id420795/index.html">Kesalahpahaman analis</a></li>
<li><a href="../id420797/index.html">Belajar tidak bisa ditunda</a></li>
<li><a href="../id420799/index.html">MPS 2018.2: Tes Generator, Plugin GitHub, Aspek VCS, Pemberitahuan Migrasi, dan Lainnya</a></li>
<li><a href="../id420803/index.html">Pelajaran pencetakan 3D. Menghemat plastik saat mencetak model non-fungsional dari 3Dtool</a></li>
<li><a href="../id420805/index.html">[Terjemahan] Kapan harus menggunakan aliran paralel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>