<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèª üìê üç§ Das Beste ist der Feind des Guten üîÄ üìØ üï¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel haben wir uns einmal entschlossen, unser internes SelfTester-Tool zu verbessern, mit dem wir die Qualit√§t des PVS-Studio-Analysators...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Beste ist der Feind des Guten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/466739/"><p><img src="https://habrastorage.org/getpro/habr/post_images/982/355/890/982355890903cccb9e35a693d48d72cf.png" alt="Bild 6" align="left"></p>  In diesem Artikel haben wir uns einmal entschlossen, unser internes SelfTester-Tool zu verbessern, mit dem wir die Qualit√§t des PVS-Studio-Analysators testen.  Die Verbesserung war einfach und schien n√ºtzlich zu sein, brachte uns aber in einige Schwierigkeiten.  Sp√§ter stellte sich heraus, dass wir die Idee besser aufgeben sollten. <br><a name="habracut"></a><br><h2>  Selftester </h2><br>  Wir entwickeln und f√∂rdern den statischen Code-Analysator PVS-Studio f√ºr C, C ++, C # und Java.  Um die Qualit√§t unseres Analysators zu testen, verwenden wir interne Tools, die allgemein als SelfTester bezeichnet werden.  Wir haben f√ºr jede unterst√ºtzte Sprache eine separate SelfTester-Version erstellt.  Es ist auf die Besonderheiten des Testens zur√ºckzuf√ºhren und einfach bequemer.  Daher haben wir derzeit drei interne SelfTester-Tools in unserem Unternehmen f√ºr C \ C ++, C # bzw. Java.  Au√üerdem erz√§hle ich Ihnen etwas √ºber die Windows-Version von SelfTester f√ºr C \ C ++ Visual Studio-Projekte und nenne sie einfach SelfTester.  Dieser Tester war der erste in der Reihe √§hnlicher interner Tools. Er ist der fortschrittlichste und komplexeste von allen. <br><br>  Wie funktioniert SelfTester?  Die Idee ist einfach: Nehmen Sie einen Pool von Testprojekten (wir verwenden echte Open Source-Projekte) und analysieren Sie sie mit PVS-Studio.  Als Ergebnis wird f√ºr jedes Projekt ein Analysatorprotokoll erstellt.  Dieses Protokoll wird mit dem <i>Referenzprotokoll</i> desselben Projekts verglichen.  Beim Vergleichen von Protokollen erstellt SelfTester eine <i>Zusammenfassung</i> der Protokolle, die auf bequeme, entwicklerfreundliche Weise verglichen werden. <br><br>  Nach dem Studium der Zusammenfassung kommt ein Entwickler zu √Ñnderungen des Verhaltens des Analysators in Abh√§ngigkeit von Anzahl und Art der Warnungen, Arbeitsgeschwindigkeit, internen Analysatorfehlern usw.  All diese Informationen sind sehr wichtig: Sie k√∂nnen sich dar√ºber im Klaren sein, wie der Analysator mit seiner Arbeit umgeht. <br><br>  Basierend auf der Zusammenfassung des Protokollvergleichs f√ºhrt ein Entwickler √Ñnderungen im Analysatorkern ein (z. B. beim Erstellen einer neuen Diagnoseregel) und steuert sofort das Ergebnis seiner √Ñnderungen.  Wenn ein Entwickler keine Probleme mehr mit einem regul√§ren Protokollvergleich hat, erstellt er eine <i>aktuelle</i> Warnprotokollreferenz f√ºr ein Projekt.  Ansonsten geht die Arbeit weiter. <br><br>  Die Aufgabe von SelfTester besteht also darin, mit einem Pool von Testprojekten zu arbeiten (es gibt √ºbrigens mehr als 120 davon f√ºr C / C ++).  Projekte f√ºr den Pool werden in Form von Visual Studio-L√∂sungen ausgew√§hlt.  Dies geschieht, um zus√§tzlich die Arbeit des Analysators an verschiedenen Visual Studio-Versionen zu √ºberpr√ºfen, die den Analysator unterst√ºtzen (zu diesem Zeitpunkt von Visual Studio 2010 bis Visual Studio 2019). <br><br>  <i>Hinweis:</i> Au√üerdem werde ich die Konzepte <i>L√∂sung</i> und <i>Projekt</i> trennen und ein Projekt als Teil einer L√∂sung betrachten. <br><br>  Die Benutzeroberfl√§che von SelfTester sieht folgenderma√üen aus: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/627/355/1d0627355eb338938aa789d33aedec83.png" alt="Bild 3"></div><br>  Links befindet sich eine Liste der L√∂sungen, rechts die Ergebnisse einer √úberpr√ºfung f√ºr jede Visual Studio-Version. <br><br>  Graue Bezeichnungen "Nicht unterst√ºtzt" zeigen an, dass eine L√∂sung eine ausgew√§hlte Visual Studio-Version nicht unterst√ºtzt oder f√ºr diese Version nicht konvertiert wurde.  Einige L√∂sungen verf√ºgen √ºber eine Konfiguration in einem Pool, die eine bestimmte Visual Studio-Version zur √úberpr√ºfung angibt.  Wenn keine Version angegeben ist, wird eine L√∂sung f√ºr alle nachfolgenden Visual Studio-Versionen aktualisiert.  Ein Beispiel f√ºr eine solche L√∂sung finden Sie im Screenshot "smart_ptr_check.sln" (eine √úberpr√ºfung wird f√ºr alle Visual Studio-Versionen durchgef√ºhrt). <br><br>  Ein gr√ºnes Etikett "OK" zeigt an, dass bei einer regelm√§√üigen √úberpr√ºfung keine Unterschiede zum Referenzprotokoll festgestellt wurden.  Ein rotes Etikett "Diff" zeigt Unterschiede an.  Diese Etiketten m√ºssen besonders beachtet werden.  Nach zweimaligem Klicken auf das gew√ºnschte Etikett wird die ausgew√§hlte L√∂sung in einer verwandten Visual Studio-Version ge√∂ffnet.  Dort wird auch ein Fenster mit einem Warnprotokoll ge√∂ffnet.  Mit den Steuertasten unten k√∂nnen Sie die Analyse der ausgew√§hlten oder aller L√∂sungen erneut ausf√ºhren, das ausgew√§hlte Protokoll (oder alle auf einmal) referenzieren usw. <br><br>  Die Ergebnisse von SelfTester werden immer im HTML-Bericht (Diffs-Bericht) dupliziert. <br><br>  Zus√§tzlich zur grafischen Benutzeroberfl√§che verf√ºgt SelfTester √ºber automatisierte Modi f√ºr Nacht-Build-L√§ufe.  Das √ºbliche Verwendungsmuster, das Entwickler wiederholen, wird jedoch von einem Entwickler w√§hrend des Arbeitstages ausgef√ºhrt.  Daher ist eine der wichtigsten Eigenschaften von SelfTester die Arbeitsgeschwindigkeit. <br><br>  Warum Geschwindigkeit wichtig ist: <br><br><ol><li> Die Leistung jedes Schritts ist f√ºr Nachttestl√§ufe sehr wichtig.  Je schneller die Tests bestehen, desto besser.  Derzeit betr√§gt die durchschnittliche Leistungszeit von SelfTester mehr als 2 Stunden. </li><li>  Wenn SelfTester tags√ºber ausgef√ºhrt wird, muss ein Entwickler weniger auf das Ergebnis warten, was die Produktivit√§t seiner Mitarbeiter erh√∂ht. </li></ol><br>  Diesmal war es die Beschleunigung der Leistung, die zum Grund f√ºr Verbesserungen wurde. <br><br><h2>  Multithreading in SelfTester </h2><br>  SelfTester wurde urspr√ºnglich als Multithread-Anwendung mit der M√∂glichkeit entwickelt, mehrere L√∂sungen gleichzeitig zu testen.  Die einzige Einschr√§nkung bestand darin, dass Sie nicht gleichzeitig dieselbe L√∂sung f√ºr verschiedene Visual Studio-Versionen √ºberpr√ºfen konnten, da viele L√∂sungen vor dem Testen auf bestimmte Versionen von Visual Studio aktualisiert werden m√ºssen.  W√§hrenddessen werden √Ñnderungen direkt in Dateien der <i>.vcxproj-</i> Projekte √ºbernommen, was zu Fehlern beim parallelen Ausf√ºhren f√ºhrt. <br><br>  Um die Arbeit effizienter zu gestalten, verwendet SelfTester einen intelligenten Taskplaner, um einen streng begrenzten Wert f√ºr parallele Threads festzulegen und zu verwalten. <br><br>  Der Planer wird auf zwei Ebenen verwendet.  Die erste ist die <i>L√∂sungsebene</i> , mit der die <i>.sln-</i> L√∂sung mit dem Dienstprogramm <i>PVS-Studio_Cmd.exe getestet wird</i> .  Der gleiche Scheduler, jedoch mit einer anderen Einstellung f√ºr den <i>Parallelit√§tsgrad</i> , wird in <i>PVS-Studio_Cmd.exe</i> (auf der Ebene der Quelldateien) verwendet. <br><br>  Der Parallelit√§tsgrad ist ein Parameter, der angibt, wie viele parallele Threads gleichzeitig ausgef√ºhrt werden m√ºssen.  F√ºr den Parallelit√§tsgrad der L√∂sungen bzw. der Dateiebene wurden <i>vier</i> und <i>acht</i> Standardwerte ausgew√§hlt.  Daher muss die Anzahl der parallelen Threads in dieser Implementierung 32 betragen (4 gleichzeitig getestete L√∂sungen und 8 Dateien).  Diese Einstellung erscheint uns f√ºr die Arbeit des Analysators auf einem Acht-Kern-Prozessor optimal. <br><br>  Ein Entwickler kann andere Werte des Parallelit√§tsgrads selbst entsprechend seiner Computerleistung oder aktuellen Aufgaben festlegen.  Wenn ein Entwickler diesen Parameter nicht angibt, wird standardm√§√üig die Anzahl der logischen Systemprozessoren ausgew√§hlt. <br><br>  <i>Hinweis:</i> Nehmen wir weiter an, dass wir uns mit dem Standardgrad der Parallelit√§t befassen. <br><br>  Der Scheduler <i>LimitedConcurrencyLevelTaskScheduler</i> wird von <i>System.Threading.Tasks.TaskScheduler</i> geerbt und verfeinert, um beim Arbeiten √ºber <i>ThreadPool</i> die maximale Parallelit√§tsstufe <i>bereitzustellen</i> .  Vererbungshierarchie: <br><br><pre><code class="cs hljs">LimitedConcurrencyLevelTaskScheduler : PausableTaskScheduler { .... } PausableTaskScheduler: TaskScheduler { .... }</code> </pre> <br>  <i>Mit PausableTaskScheduler</i> k√∂nnen Sie die Aufgabenleistung <i>unterbrechen. Dar√ºber</i> hinaus bietet <i>LimitedConcurrencyLevelTaskScheduler</i> eine intellektuelle Kontrolle √ºber die Aufgabenwarteschlange und die Planung ihrer Leistung unter Ber√ºcksichtigung des Parallelit√§tsgrads, des Umfangs der geplanten Aufgaben und anderer Faktoren.  Ein Scheduler wird verwendet, wenn <i>LimitedConcurrencyLevelTaskScheduler-</i> Tasks ausgef√ºhrt werden. <br><br><h2>  Gr√ºnde f√ºr Verfeinerungen </h2><br>  Das oben beschriebene Verfahren hat einen Nachteil: Es ist nicht optimal, wenn es sich um L√∂sungen unterschiedlicher Gr√∂√üe handelt.  Die Gr√∂√üe der L√∂sungen im Testpool ist <i>sehr</i> unterschiedlich: von 8 KB bis 4 GB - die Gr√∂√üe eines Ordners mit einer L√∂sung und von 1 bis zu mehreren Tausend Quellcodedateien in jeder. <br><br>  Der Scheduler stellt L√∂sungen einfach nacheinander ohne intelligente Komponente in die Warteschlange.  Ich m√∂chte Sie daran erinnern, dass standardm√§√üig nicht mehr als vier L√∂sungen gleichzeitig getestet werden k√∂nnen.  Wenn derzeit vier gro√üe L√∂sungen getestet werden (die Anzahl der Dateien in jeder ist mehr als acht), wird davon ausgegangen, dass wir effektiv arbeiten, da wir so viele Threads wie m√∂glich verwenden (32). <br><br>  Stellen wir uns jedoch eine ziemlich h√§ufige Situation vor, in der mehrere kleine L√∂sungen getestet werden.  Beispielsweise ist eine L√∂sung gro√ü und enth√§lt 50 Dateien (die maximale Anzahl von Threads wird verwendet), w√§hrend andere drei L√∂sungen jeweils drei, vier, f√ºnf Dateien enthalten.  In diesem Fall verwenden wir nur 20 Threads (8 + 3 + 4 + 5).  Die Prozessorzeit wird nicht ausreichend genutzt und die Gesamtleistung reduziert. <br><br>  <i>Hinweis</i> : Tats√§chlich ist der Engpass normalerweise das Festplattensubsystem und nicht der Prozessor. <br><br><h2>  Verbesserungen </h2><br>  Die Verbesserung, die in diesem Fall offensichtlich ist, ist das Ranking der Liste der getesteten L√∂sungen.  Wir m√ºssen die festgelegte Anzahl gleichzeitig ausgef√ºhrter Threads (32) optimal nutzen, indem wir Testprojekte mit der richtigen Anzahl von Dateien √ºbergeben. <br><br>  Betrachten wir noch einmal unser Beispiel zum Testen von vier L√∂sungen mit jeweils der folgenden Anzahl von Dateien: 50, 3, 4 und 5. Die Aufgabe, die eine L√∂sung mit <i>drei</i> Dateien √ºberpr√ºft, funktioniert wahrscheinlich am schnellsten.  Es ist am besten, stattdessen eine L√∂sung mit acht oder mehr Dateien hinzuzuf√ºgen (um das Maximum aus den verf√ºgbaren Threads f√ºr diese L√∂sung zu verwenden).  Auf diese Weise werden 25 Threads gleichzeitig verwendet (8 + <b>8</b> + 4 + 5).  Nicht schlecht.  Sieben Threads sind jedoch noch nicht beteiligt.  Und hier kommt die Idee einer weiteren Verfeinerung, die darin besteht, die Beschr√§nkung auf vier Threads f√ºr Testl√∂sungen aufzuheben.  Weil wir jetzt nicht nur eine, sondern mehrere L√∂sungen mit 32 Threads hinzuf√ºgen k√∂nnen.  Stellen wir uns vor, wir haben zwei weitere L√∂sungen mit jeweils drei und vier Dateien.  Durch Hinzuf√ºgen dieser Aufgaben wird die "L√ºcke" nicht verwendeter Threads vollst√§ndig geschlossen, und es werden 32 (8 + 8 + 4 + 5 + <b>3</b> + <b>4</b> ) davon vorhanden sein. <br><br>  Hoffentlich ist die Idee klar.  Tats√§chlich erforderte die Implementierung dieser Verbesserungen auch keinen gro√üen Aufwand.  Alles war an einem Tag erledigt. <br><br>  Wir mussten die Aufgabenklasse √ºberarbeiten: Erben von <i>System.Threading.Tasks.Task</i> und Zuweisung des Feldes "weight".  Wir verwenden einen einfachen Algorithmus, um das Gewicht einer L√∂sung festzulegen: Wenn die Anzahl der Dateien weniger als acht betr√§gt, entspricht das Gewicht dieser Anzahl (z. B. 5).  Wenn die Zahl gr√∂√üer oder gleich acht ist, ist das Gewicht gleich acht. <br><br>  Wir mussten auch den Scheduler ausarbeiten: Bringen Sie ihm bei, L√∂sungen mit dem erforderlichen Gewicht auszuw√§hlen, um einen Maximalwert von 32 Threads zu erreichen.  Wir mussten auch mehr als vier Threads f√ºr das gleichzeitige Testen von L√∂sungen zulassen. <br><br>  Schlie√ülich brauchten wir einen ersten Schritt, um alle L√∂sungen im Pool zu analysieren (Auswertung mit der MSBuild-API), um die L√∂sungen auszuwerten und das Gewicht festzulegen (Anzahl der Dateien mit Quellcode abrufen). <br><br><h2>  Ergebnis </h2><br>  Ich denke, nach einer so langen Einf√ºhrung haben Sie bereits vermutet, dass nichts daraus geworden ist. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91c/6c1/fca/91c6c1fca4017036c0fca83fd2113474.png" alt="Bild 12"></div><br>  Es ist jedoch gut, dass die Verbesserungen einfach und schnell waren. <br><br>  Hier kommt der Teil des Artikels, in dem ich Ihnen erz√§hlen werde, was "uns in viele Schwierigkeiten gebracht hat" und was damit zu tun hat. <br><br><h2>  Nebenwirkungen </h2><br>  Ein negatives Ergebnis ist also auch ein Ergebnis.  Es stellte sich heraus, dass die Anzahl der gro√üen L√∂sungen im Pool die Anzahl der kleinen (weniger als acht Dateien) bei <i>weitem √ºbersteigt</i> .  In diesem Fall haben diese Verbesserungen keine nennenswerten Auswirkungen, da sie fast unsichtbar sind: Das Testen kleiner Projekte nimmt im Vergleich zur Zeit, die f√ºr gro√üe Projekte ben√∂tigt wird, winzig viel Zeit in Anspruch. <br><br>  Wir haben uns jedoch entschlossen, die neue Verfeinerung als "nicht st√∂rend" und potenziell n√ºtzlich zu belassen.  Dar√ºber hinaus wird der Pool an Testl√∂sungen st√§ndig aufgef√ºllt, sodass sich die Situation in Zukunft m√∂glicherweise √§ndern wird. <br><br>  Und dann ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdf/906/0ea/bdf9060ea6b9d1ce17ed820acc1468c7.png" alt="Bild 5"></div><br>  Einer der Entwickler beschwerte sich √ºber den Absturz des SelfTesters.  Nun, das Leben passiert.  Um zu verhindern, dass dieser Fehler verloren geht, haben wir einen internen Vorfall (Ticket) mit dem Namen "Ausnahme bei der Arbeit mit SelfTester" erstellt.  Der Fehler ist bei der Auswertung des Projekts aufgetreten.  Obwohl eine gro√üe Anzahl von Fenstern mit Fehlern das Problem wieder in der Fehlerbehandlungsroutine anzeigte.  Dies wurde jedoch schnell beseitigt, und in der n√§chsten Woche st√ºrzte nichts ab.  Pl√∂tzlich beschwerte sich ein anderer Benutzer √ºber SelfTester.  Wieder der Fehler einer Projektevaluierung: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/1f3/bd5/0fa1f3bd596a2a4bdbbc0f9ace32664c.png" alt="Bild 8"></div><br>  Diesmal enthielt der Stapel viele n√ºtzliche Informationen - der Fehler lag im XML-Format vor.  Es ist wahrscheinlich, dass beim <i>Behandeln</i> der Datei des <i>Proto_IRC.vcxproj-</i> Projekts (seiner XML-Darstellung) etwas mit der Datei selbst passiert ist, weshalb <i>XmlTextReader</i> dies nicht verarbeiten konnte. <br><br>  Da wir in relativ kurzer Zeit zwei Fehler hatten, haben wir uns das Problem genauer angesehen.  Dar√ºber hinaus wird SelfTester, wie oben erw√§hnt, von Entwicklern sehr aktiv genutzt. <br><br>  Zun√§chst haben wir den letzten Absturz analysiert.  Leider fanden wir nichts Verd√§chtiges.  Nur f√ºr den Fall, dass wir Entwickler (SelfTester-Benutzer) gebeten haben, ein Auge auf m√∂gliche Fehler zu werfen und diese zu melden. <br><br>  Wichtiger Punkt: Der fehlerhafte Code wurde in SelfTester wiederverwendet.  Es wurde urspr√ºnglich verwendet, um Projekte im Analysator selbst ( <i>PVS-Studio_Cmd.exe</i> ) <i>auszuwerten</i> .  Deshalb ist die Aufmerksamkeit auf das Problem gewachsen.  Es gab jedoch keine derartigen Abst√ºrze im Analysator. <br><br>  In der Zwischenzeit wurde das Ticket √ºber Probleme mit SelfTester durch neue Fehler erg√§nzt: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b49/15a/0ae/b4915a0aecc426246419f4a26e62a233.png" alt="Bild 9"></div><br>  <i>Wieder XmlException</i> .  Offensichtlich gibt es irgendwo konkurrierende Threads, die mit dem Lesen und Schreiben von Projektdateien arbeiten.  SelfTester arbeitet in folgenden F√§llen mit Projekten: <br><br><ol><li>  Projektevaluierung im Zuge der vorl√§ufigen Berechnung der L√∂sungsgewichte: ein neuer Schritt, der zun√§chst Verdacht erregte; </li><li>  Aktualisieren von Projekten auf die erforderlichen Visual Studio-Versionen: Wird direkt vor dem Testen durchgef√ºhrt (Projekte st√∂ren nicht) und darf den Arbeitsprozess nicht beeintr√§chtigen. </li><li>  Projektevaluierung w√§hrend des Testens: ein etablierter thread-sicherer Mechanismus, der von <i>PVS-Studio_Cmd.exe</i> wiederverwendet <i>wird</i> ; </li><li>  Wiederherstellen von Projektdateien (Ersetzen ge√§nderter <i>.vcxproj-</i> Dateien durch anf√§ngliche Referenzdateien) beim Beenden von SelfTester, da Projektdateien w√§hrend der Arbeit auf die erforderlichen Visual Studio-Versionen aktualisiert werden k√∂nnen.  Dies ist ein letzter Schritt, der keine Auswirkungen auf andere Mechanismen hat. </li></ol><br>  Der Verdacht fiel auf den neuen Code, der zur Optimierung hinzugef√ºgt wurde (Gewichtsberechnung).  Die Codeuntersuchung ergab jedoch, dass der Tester immer korrekt bis zum Ende der Vorbewertung wartet, wenn ein Benutzer die Analyse direkt nach dem Start von SelfTester ausf√ºhrt.  Dieser Ort sah sicher aus. <br><br>  Auch hier konnten wir die Ursache des Problems nicht identifizieren. <br><br><h2>  Schmerz </h2><br>  Den ganzen n√§chsten Monat st√ºrzte SelfTester immer wieder ab.  Das Ticket f√ºllte sich weiterhin mit Daten, aber es war nicht klar, was mit diesen Daten zu tun war.  Die meisten Abst√ºrze waren mit derselben <i>XmlException.</i>  Gelegentlich gab es noch etwas anderes, aber denselben wiederverwendeten Code aus <i>PVS-Studio_Cmd.exe</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/fbe/c11/c31fbec1152210e397b6d9d1ffdb5aa6.png" alt="Bild 1"></div><br>  Traditionell stellen interne Tools keine sehr hohen Anforderungen, daher haben wir die Fehler von SelfTester immer wieder nach einem Restprinzip herausgesucht.  Von Zeit zu Zeit wurden verschiedene Personen involviert (w√§hrend des gesamten Vorfalls arbeiteten sechs Personen an dem Problem, darunter zwei Praktikanten).  Wir mussten uns jedoch von dieser Aufgabe ablenken lassen. <br><br>  <i>Unser erster Fehler.</i>  Zu diesem Zeitpunkt h√§tten wir dieses Problem ein f√ºr alle Mal l√∂sen k√∂nnen.  Wie?  Es war klar, dass der Fehler durch eine neue Optimierung verursacht wurde.  Immerhin hat vorher alles gut funktioniert, und der wiederverwendete Code kann eindeutig nicht so schlecht sein.  Dar√ºber hinaus hatte diese Optimierung keinen Nutzen gebracht.  Was musste also getan werden?  <i>Entfernen Sie diese Optimierung.</i>  Wie Sie wahrscheinlich verstehen, wurde es nicht getan.  Wir haben weiter an dem Problem gearbeitet, das wir selbst geschaffen haben.  Wir suchten weiter nach der Antwort: "WIE ???"  Wie st√ºrzt es ab?  Es schien richtig geschrieben zu sein. <br><br>  <i>Unser zweiter Fehler.</i>  <i>Andere Leute haben sich an der</i> L√∂sung des Problems beteiligt <i>.</i>  Es ist ein sehr, sehr gro√üer Fehler.  Das Problem wurde nicht nur nicht gel√∂st, sondern es wurden auch zus√§tzliche Ressourcen verschwendet.  Ja, neue Leute brachten neue Ideen mit, aber es hat viel Arbeitszeit gekostet, diese Ideen (umsonst) umzusetzen.  Irgendwann hatten unsere Praktikanten Testprogramme geschrieben, die die Bewertung ein und desselben Projekts in verschiedenen Threads mit paralleler √Ñnderung eines Projekts in einem anderen Projekt emulierten.  Es hat nicht geholfen.  Wir haben nur herausgefunden, dass die MSBuild-API im Inneren threadsicher ist, was wir bereits kennen.  Wir haben auch das automatische Speichern von Mini-Dumps hinzugef√ºgt, wenn die <i>XmlException-</i> Ausnahme auftritt.  Wir hatten jemanden, der das alles debuggte.  Armer Kerl!  Es gab Diskussionen, wir haben andere unn√∂tige Dinge getan. <br><br>  <i>Zum Schluss noch der dritte Fehler.</i>  Wissen Sie, wie viel Zeit von dem Moment an vergangen ist, als das SelfTester-Problem aufgetreten ist, bis es gel√∂st wurde?  Nun, du kannst dich selbst z√§hlen.  Das Ticket wurde am 17.09.2008 erstellt und am 20.02.2019 geschlossen.  Es gab mehr als 40 Kommentare!  Leute, das ist viel Zeit!  Wir haben <i>uns erlaubt</i> , f√ºnf Monate mit DIESEM besch√§ftigt zu sein.  Gleichzeitig waren wir damit besch√§ftigt, Visual Studio 2019 zu unterst√ºtzen, die Java-Sprachunterst√ºtzung hinzuzuf√ºgen, den MISRA C / C ++ - Standard einzuf√ºhren, den C # -Analysator zu verbessern, aktiv an Konferenzen teilzunehmen, eine Reihe von Artikeln zu schreiben usw.  Alle diese Aktivit√§ten erhielten aufgrund eines dummen Fehlers in SelfTester weniger Zeit f√ºr Entwickler. <br><br>  Leute, lernt aus unseren Fehlern und macht das nie so.  Wir werden auch nicht. <br><br>  Das war's, ich bin fertig. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/a29/f94/3a8a29f94aeed35ddeaec17222a4f990.png" alt="Bild 15"></div><br>  Okay, es war ein Witz, ich werde dir sagen, was das Problem mit SelfTester war :) <br><br><h2>  Bingo! </h2><br>  Gl√ºcklicherweise gab es unter uns eine Person mit klaren Augen (mein Kollege Sergey Vasiliev), die das Problem nur aus einem ganz anderen Blickwinkel betrachtete (und auch - er hatte ein bisschen Gl√ºck).  Was ist, wenn es im SelfTester in Ordnung ist, aber etwas von au√üen die Projekte zum Absturz bringt?  Normalerweise hatten wir nichts mit SelfTester gestartet, in einigen F√§llen haben wir die Ausf√ºhrungsumgebung streng kontrolliert.  In diesem Fall k√∂nnte dieses "Etwas" SelfTester selbst sein, aber eine andere Instanz. <br><br>  Beim Beenden von SelfTester funktioniert der Thread, der Projektdateien aus Referenzen wiederherstellt, noch eine Weile.  Zu diesem Zeitpunkt wird der Tester m√∂glicherweise erneut gestartet.  Der Schutz gegen die gleichzeitige Ausf√ºhrung mehrerer SelfTester-Instanzen wurde <i>sp√§ter</i> hinzugef√ºgt und sieht nun wie folgt aus: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/7bf/437/0a37bf4373e3beb9bbfe2542afb258a0.png" alt="Bild 16"></div><br>  Aber zu diesem Zeitpunkt hatten wir es nicht. <br><br>  N√ºsse, aber wahr - w√§hrend fast sechs Monaten der Qual hat niemand darauf geachtet.  Das Wiederherstellen von Projekten aus Referenzen ist ein relativ schneller Hintergrundvorgang, der jedoch leider nicht schnell genug ist, um den Neustart von SelfTester nicht zu beeintr√§chtigen.  Und was passiert, wenn wir es starten?  Das ist richtig, die Gewichte von L√∂sungen zu berechnen.  Ein Prozess schreibt <i>.vcxproj-</i> Dateien neu, w√§hrend ein anderer versucht, sie zu lesen.  Sagen Sie Hallo zu <i>XmlException</i> . <br><br>  Sergey fand dies alles heraus, als er dem Tester die M√∂glichkeit hinzuf√ºgte, zu einem anderen Satz von Referenzprotokollen zu wechseln.  Dies wurde erforderlich, nachdem dem Analysator eine Reihe von MISRA-Regeln hinzugef√ºgt wurden.  Sie k√∂nnen direkt in der Benutzeroberfl√§che wechseln, w√§hrend der Benutzer dieses Fenster sieht: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/9b0/87d/0a59b087d0e13688ab41a690ed490a3f.png" alt="Bild 14"></div><br>  Danach wird <i>SelfTester</i> neu <i>gestartet</i> .  Und fr√ºher haben Benutzer das Problem anscheinend selbst emuliert und den Tester erneut ausgef√ºhrt. <br><br><h2>  Schuldzuweisungen und Schlussfolgerungen </h2><br>  Nat√ºrlich haben wir die zuvor erstellte Optimierung entfernt (dh deaktiviert).  Dar√ºber hinaus war es viel einfacher, als eine Art Synchronisation zwischen den Neustarts des Testers selbst durchzuf√ºhren.  Und alles begann nach wie vor perfekt zu funktionieren.  Als zus√§tzliche Ma√ünahme haben wir den oben genannten Schutz gegen den gleichzeitigen Start des Testers hinzugef√ºgt. <br><br>  Ich habe oben bereits √ºber unsere Hauptfehler bei der Suche nach dem Problem geschrieben, also genug von Selbstkennzeichnung.  Wir sind Menschen, also k√∂nnten wir uns irren.  Es ist wichtig, aus eigenen Fehlern zu lernen und Schlussfolgerungen zu ziehen.  Die Schlussfolgerungen aus diesem Fall sind recht einfach: <br><br><ul><li>  Wir sollten die Komplexit√§t der Aufgaben √ºberwachen und absch√§tzen. </li><li>  Manchmal m√ºssen wir irgendwann aufh√∂ren; </li><li>  Versuchen Sie, das Problem genauer zu betrachten.  Mit der Zeit kann man einen Tunnelblick auf den Fall bekommen, w√§hrend dies eine neue Perspektive erfordert. </li><li>  Haben Sie keine Angst, alten oder unn√∂tigen Code zu l√∂schen. </li></ul><br>  Das war's, diesmal bin ich definitiv fertig.  Vielen Dank f√ºr das Lesen bis zum Ende.  Ich w√ºnsche Ihnen fehlerfreien Code! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466739/">https://habr.com/ru/post/de466739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466729/index.html">Das Buch "Data Mining. Informationen von Facebook, Twitter, LinkedIn, Instagram, GitHub abrufen ¬ª</a></li>
<li><a href="../de466731/index.html">Extravaganz. Der September steigt</a></li>
<li><a href="../de466733/index.html">Willkommen zu DINS Java ABEND am 18. September</a></li>
<li><a href="../de466735/index.html">Eine einfache M√∂glichkeit, einen Sprachalarm im Home Automation-System (‚ÄûSmart Home‚Äú) zu erstellen.</a></li>
<li><a href="../de466737/index.html">Warum das soziale Netzwerk von Google+ fehlgeschlagen ist</a></li>
<li><a href="../de466741/index.html">Das Beste ist der Feind des Guten</a></li>
<li><a href="../de466745/index.html">Der erste Arbeitsplatz oder wie man mit der Entwicklung der API auf Node.js beginnt</a></li>
<li><a href="../de466747/index.html">Mitap iOS-Entwickler bei Redmadrobot</a></li>
<li><a href="../de466753/index.html">Netzwerkadministration schnell und effizient - Netzwerk-MACMonitor</a></li>
<li><a href="../de466755/index.html">Der Computer wird Sie lecker machen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>