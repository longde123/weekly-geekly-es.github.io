<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜó üîÆ üë∂üèø Rendu des polices √† l'aide de masques de couverture, partie 1 üßöüèº üßúüèæ üë®üèΩ‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsque nous avons commenc√© √† d√©velopper notre profileur de performances , nous savions que nous ferions presque tout le rendu de l'interface utilisat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendu des polices √† l'aide de masques de couverture, partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433670/"><div style="text-align:center;"><img width="310" height="458" src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png" alt="image"></div><br>  Lorsque nous avons commenc√© √† d√©velopper notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">profileur de performances</a> , nous savions que nous ferions presque tout le rendu de l'interface utilisateur par nous-m√™mes.  Bient√¥t, nous avons d√ª d√©cider quelle approche choisir pour le rendu des polices.  Nous avions les exigences suivantes: <br><br><ol><li>  Nous devons √™tre capables de rendre n'importe quelle police de n'importe quelle taille en temps r√©el afin de nous adapter aux polices syst√®me et √† leurs tailles choisies par les utilisateurs de Windows. </li><li>  Le rendu des polices doit √™tre tr√®s rapide, aucun freinage lorsque le rendu des polices est autoris√©. </li><li>  Notre interface utilisateur a un tas d'animations fluides, donc le texte devrait pouvoir se d√©placer en douceur sur l'√©cran. </li><li>  Il doit √™tre lisible avec de petites tailles de police. </li></ol><br>  N'√©tant pas un grand sp√©cialiste √† cette √©poque, j'ai cherch√© des informations sur Internet et trouv√© de nombreuses techniques utilis√©es pour rendre les polices.  J'ai √©galement parl√© au directeur technique des Jeux de Guerrilla, Michail van der Leu.  Cette soci√©t√© a exp√©riment√© de nombreuses fa√ßons de rendre les polices, et leur moteur de rendu √©tait l'un des meilleurs au monde.  Mihil a bri√®vement expliqu√© son id√©e d'une nouvelle technique de rendu des polices.  Bien que nous en ayons eu assez des techniques d√©j√† disponibles, cette id√©e m'a intrigu√© et j'ai commenc√© √† l'impl√©menter, sans pr√™ter attention au monde merveilleux du rendu des polices qui s'ouvrait √† moi. <br><a name="habracut"></a><br>  Dans cette s√©rie d'articles, je d√©crirai en d√©tail la technique que nous utilisons, divisant la description en trois parties: <br><br><ul><li>  Dans la <strong>premi√®re partie,</strong> nous apprendrons √† rendre des glyphes en temps r√©el √† l'aide de 16xAA, √©chantillonn√©s √† partir d'une grille uniforme. </li><li>  Dans la <strong>deuxi√®me partie,</strong> nous allons passer √† la grille pivot√©e pour effectuer magnifiquement l'anticr√©nelage des bords horizontaux et verticaux.  Nous verrons √©galement comment le shader fini est presque compl√®tement r√©duit √† une texture et √† une table de recherche. </li><li>  Dans la <strong>troisi√®me partie,</strong> nous apprendrons √† pixelliser les glyphes en temps r√©el √† l'aide de Calcul et CPU. </li></ul><br>  Vous pouvez √©galement voir les r√©sultats finaux dans le profileur, mais voici un exemple d'√©cran avec la police Segoe UI rendue √† l'aide de notre rendu de police: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/518/faf/57f/518faf57f2f977406e864ddbd939af6b.png"></div><br>  Voici une augmentation de la lettre S, une taille tram√©e de seulement 6x9 texels.  Les donn√©es vectorielles d'origine sont rendues sous la forme d'un chemin et le motif d'√©chantillonnage pivot√© est rendu √† partir de rectangles verts et rouges.  Puisqu'il est rendu avec une r√©solution bien sup√©rieure √† 6 √ó 9, les nuances de gris ne sont pas repr√©sent√©es dans la teinte finale des pixels, il affiche la teinte du sous-pixel.  Il s'agit d'une visualisation de d√©bogage tr√®s utile pour vous assurer que tous les calculs au niveau des sous-pixels fonctionnent correctement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba1/aa9/5b3/ba1aa95b30f977d242d90994416b8ef8.png"></div><br><h1>  Id√©e: stocker le rev√™tement au lieu de l'ombre </h1><br>  Le principal probl√®me auquel les rendus de polices doivent faire face est l'affichage des donn√©es de polices vectorielles √©volutives dans une grille de pixels fixe.  La m√©thode de transition de l'espace vectoriel aux pixels finis dans diff√©rentes techniques est tr√®s diff√©rente.  Dans la plupart de ces techniques, les donn√©es de courbe sont tram√©es avant d'√™tre rendues dans un stockage temporaire (par exemple, une texture) pour obtenir une taille sp√©cifique en pixels.  Le stockage temporaire est utilis√© comme cache de glyphes: lorsque le m√™me glyphe est rendu plusieurs fois, les glyphes sont extraits du cache et r√©utilis√©s pour √©viter une nouvelle pixellisation. <br><br>  La diff√©rence de technique est clairement visible dans la fa√ßon dont les donn√©es sont stock√©es dans un format de donn√©es interm√©diaire.  Par exemple, le syst√®me de polices Windows pixellise les glyphes √† une taille sp√©cifique en pixels.  Les donn√©es sont stock√©es sous la forme d'une <strong>teinte</strong> par pixel.  L'ombre d√©crit la meilleure approximation de la couverture par le glyphe de ce pixel.  Lors du rendu, les pixels sont simplement copi√©s du cache de glyphes vers la grille de pixels cible.  Lors de la conversion de donn√©es au format pixel, elles ne sont pas bien mises √† l'√©chelle.Par cons√©quent, lors d'un zoom arri√®re, des glyphes flous apparaissent et lors d'un zoom avant, des glyphes apparaissent dans lesquels les blocs sont clairement visibles.  Par cons√©quent, pour chaque taille finale, les glyphes sont rendus dans le cache de glyphes. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les champs distants sign√©s</a> utilisent une approche diff√©rente.  Au lieu de la teinte du pixel, la <strong>distance</strong> jusqu'au bord le plus proche du glyphe est conserv√©e.  L'avantage de cette m√©thode est que pour les bords incurv√©s, les donn√©es √©voluent bien mieux que les nuances.  Lorsque le glyphe se rapproche, les courbes restent lisses.  L'inconv√©nient de cette approche est que les bords droits et tranchants sont liss√©s.  Beaucoup mieux que SDF est atteint par des solutions avanc√©es comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FreeType</a> , qui stockent les donn√©es de couleur. <br><br>  Dans les cas o√π une teinte est conserv√©e pour un pixel, vous devez d'abord calculer sa couverture.  Par exemple, stb_truetype a de bons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemples</a> de la fa√ßon dont vous pouvez calculer la couverture et la teinte.  Une autre fa√ßon populaire d'estimer la couverture consiste √† √©chantillonner le glyphe √† une fr√©quence plus √©lev√©e que la r√©solution finale.  Cela compte le nombre d'√©chantillons qui tiennent dans le glyphe dans la zone de pixel cible.  Le nombre de hits divis√© par le nombre maximum d'√©chantillons possibles d√©termine la teinte.  √âtant donn√© que la couverture a d√©j√† √©t√© convertie en une teinte pour une r√©solution et un <strong>alignement de</strong> grille de pixels sp√©cifiques, il est impossible de placer des glyphes entre les pixels cibles: la teinte ne peut pas refl√©ter correctement la vraie couverture avec des √©chantillons de la fen√™tre de pixel cible.  Pour cela, ainsi que pour d'autres raisons que nous examinerons plus loin, de tels syst√®mes ne prennent pas en charge le mouvement sous-pixel. <br><br>  Mais que se passe-t-il si nous devons d√©placer librement le glyphe entre les pixels?  Si la teinte est calcul√©e √† l'avance, nous ne pouvons pas d√©terminer quelle devrait √™tre la teinte lors du d√©placement entre les pixels dans la zone de pixels cible.  Cependant, nous pouvons retarder la conversion de la couverture en teinte au moment du rendu.  Pour ce faire, nous ne conserverons pas l'ombre, mais le <strong>rev√™tement</strong> .  Nous √©chantillonnons un glyphe avec une fr√©quence de 16 r√©solution cible, et pour chaque √©chantillon, nous enregistrons un seul bit.  Lors d'un √©chantillonnage sur une grille 4 √ó 4, il suffit de stocker seulement 16 bits par pixel.  Ce sera notre <strong>masque de couverture</strong> .  Pendant le rendu, nous devons compter le nombre de bits entrant dans la fen√™tre de pixel cible, qui a la m√™me r√©solution que le r√©f√©rentiel de texels, mais qui n'y est pas physiquement attach√©e.  L'animation ci-dessous montre une partie du glyphe (bleu) tram√© en quatre texels.  Chaque texel est divis√© en une grille de 4 √ó 4 cellules.  Un rectangle gris indique une fen√™tre de pixels qui se d√©place dynamiquement √† travers le glyphe.  Au moment de l'ex√©cution, le nombre d'√©chantillons qui tombent dans la fen√™tre de pixels est compt√© pour d√©terminer la teinte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/6d3/dca/f796d3dcaf7c4b1763ff8ee5621c09c9.gif"></div><br><h2>  En bref sur les techniques de base de rendu des polices </h2><br>  Avant de passer √† la mise en ≈ìuvre de notre syst√®me de rendu des polices, je voudrais parler bri√®vement des principales techniques utilis√©es dans ce processus: l'indication des polices et le rendu des sous-pixels (cette technique est appel√©e ClearType sous Windows).  Vous pouvez ignorer cette section si vous √™tes uniquement int√©ress√© par les techniques d'anticr√©nelage. <br><br>  Au cours de la mise en ≈ìuvre du moteur de rendu, j'ai appris de plus en plus sur la longue histoire du d√©veloppement du rendu des polices.  La recherche se concentre enti√®rement sur le seul aspect du rendu des polices - la lisibilit√© √† de petites tailles.  La cr√©ation d'un excellent rendu pour les grandes polices est assez simple, mais il est incroyablement difficile d'√©crire un syst√®me qui maintient la lisibilit√© √† de petites tailles.  L'√©tude du rendu des polices a une longue histoire, frappante dans sa profondeur.  Lisez, par exemple, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trag√©die raster</a> .  Il est logique que ce soit le principal probl√®me pour les informaticiens, car au d√©but des ordinateurs, la r√©solution de l'√©cran √©tait assez faible.  Cela a d√ª √™tre l'une des premi√®res t√¢ches auxquelles les d√©veloppeurs de syst√®mes d'exploitation ont d√ª faire face: comment rendre le texte lisible sur des appareils √† faible r√©solution d'√©cran?  √Ä ma grande surprise, les syst√®mes de rendu de polices de haute qualit√© sont tr√®s orient√©s pixels.  Par exemple, un glyphe est construit de telle mani√®re qu'il commence au bord du pixel, sa largeur est un multiple du nombre de pixels et le contenu est ajust√© pour s'adapter aux pixels.  Cette technique est appel√©e maillage.  J'ai l'habitude de travailler avec des jeux informatiques et des graphiques 3D, o√π le monde est construit √† partir d'unit√©s et projet√© en pixels, j'ai donc √©t√© un peu surpris.  J'ai d√©couvert que dans le domaine du rendu des polices, c'est un choix tr√®s important. <br><br>  Pour montrer l'importance du maillage, examinons un sc√©nario possible pour la pixellisation des glyphes.  Imaginez qu'un glyphe est tram√© sur une grille de pixels, mais la forme du glyphe ne correspond pas parfaitement √† la structure de la grille: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c2/b4f/aa1/2c2b4faa132766685d630964d582d9dd.png"></div><br>  L'anticr√©nelage rend les pixels √† droite et √† gauche du glyphe √©galement gris.  Si le glyphe est l√©g√®rement d√©cal√© pour mieux correspondre aux bordures des pixels, alors un seul pixel sera color√© et il deviendra compl√®tement noir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/c63/1b0/9b5c631b00fcdcfcd2a3a36f06ab9d2d.png"></div><br>  Maintenant que le glyphe correspond bien aux pixels, les couleurs sont devenues moins floues.  La diff√©rence de nettet√© est tr√®s grande.  Les polices occidentales ont de nombreux glyphes avec des lignes horizontales et verticales, et si elles ne correspondent pas bien √† la grille de pixels, les nuances de gris rendent la police floue.  M√™me la meilleure technique d'anticr√©nelage n'est pas en mesure de faire face √† ce probl√®me. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'indication de police a</a> √©t√© propos√©e comme solution.  Les auteurs de polices doivent ajouter des informations √† leurs polices sur la fa√ßon dont les glyphes doivent s'accrocher aux pixels s'ils ne correspondent pas parfaitement.  Le syst√®me de rendu des polices d√©forme ces courbes pour les accrocher √† la grille de pixels.  Cela augmente consid√©rablement la clart√© de la police, mais a un prix: <br><br><ul><li>  Les polices deviennent l√©g√®rement <em>d√©form√©es</em> .  Les polices ne semblent pas exactement comme pr√©vu. </li><li>  Tous les glyphes doivent √™tre attach√©s √† la grille de pixels: le d√©but du glyphe et la largeur du glyphe.  Il est donc impossible de les animer entre pixels. </li></ul><br>  Fait int√©ressant, pour r√©soudre ce probl√®me, Apple et Microsoft ont opt√© pour des m√©thodes diff√©rentes.  Microsoft adh√®re √† une clart√© absolue et Apple cherche √† afficher plus pr√©cis√©ment les polices.  Sur Internet, vous pouvez trouver des gens qui se plaignent des polices floues sur les machines Apple, mais beaucoup de gens aiment ce qu'ils voient sur Apple.  C'est en partie une question de go√ªt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici le</a> post de Joel sur le logiciel, et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici le</a> post de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Peter Bilak</a> sur ce sujet, mais si vous effectuez une recherche sur Internet, vous pouvez trouver beaucoup plus d'informations. <br><br>  √âtant donn√© que la r√©solution DPI dans les √©crans modernes augmente rapidement, la question se pose de savoir si un indice de police sera n√©cessaire √† l'avenir, comme c'est le cas aujourd'hui.  Dans mon √©tat actuel, je trouve que l'indication des polices est une technique tr√®s utile pour rendre les polices clairement.  Cependant, la technique d√©crite dans mon article peut devenir une alternative int√©ressante √† l'avenir, car les glyphes peuvent √™tre librement plac√©s sur la toile sans distorsion.  Et comme il s'agit essentiellement d'une technique d'anticr√©nelage, elle peut √™tre utilis√©e √† n'importe quelle fin, et pas seulement pour le rendu des polices. <br><br>  Enfin, je parlerai bri√®vement du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rendu sous-pixel</a> .  Dans le pass√©, les gens se rendaient compte que vous pouvez tripler la r√©solution horizontale de l'√©cran en utilisant les rayons rouges, verts et bleus individuels d'un √©cran d'ordinateur.  Chaque pixel est construit √† partir de ces rayons, qui sont physiquement s√©par√©s.  Notre ≈ìil m√©lange leurs valeurs, cr√©ant une couleur d'un seul pixel.  Lorsque le glyphe ne couvre qu'une partie du pixel, seul le faisceau qui est superpos√© au glyphe est activ√©, ce qui triple la r√©solution horizontale.  Si vous agrandissez l'image √† l'√©cran en utilisant une technique comme ClearType, vous pouvez voir les couleurs autour des bords du glyphe: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fff/998/d3e/fff998d3e0cc29ff6abe7b18a0725e61.png"></div><br>  Fait int√©ressant, l'approche que je vais discuter dans l'article peut √™tre √©tendue au rendu sous-pixel.  J'ai d√©j√† impl√©ment√© son prototype.  Son seul inconv√©nient est qu'en raison de l'ajout de filtrage dans des techniques comme ClearType, nous devons prendre plus d'√©chantillons de texture.  J'y r√©fl√©chirai peut-√™tre √† l'avenir. <br><br><h1>  Rendu de glyphe √† l'aide d'une grille uniforme </h1><br>  Supposons que nous √©chantillonnions un glyphe avec une r√©solution 16 fois la cible et l'enregistrions dans une texture.  Je vais d√©crire comment cela se fait dans la troisi√®me partie de l'article.  Un motif d'√©chantillonnage est une grille uniforme, c'est-√†-dire que 16 points d'√©chantillonnage sont r√©partis uniform√©ment sur le texel.  Chaque glyphe est rendu avec la m√™me r√©solution que la r√©solution cible, nous stockons 16 bits par texel, et chaque bit correspond √† un √©chantillon.  Comme nous le verrons dans le processus de calcul du masque de couverture, l'ordre de stockage des √©chantillons est important.  En g√©n√©ral, les points d'√©chantillonnage et leurs positions pour un texel ressemblent √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7b/b2c/7f4/a7bb2c7f477e44883b531d2bae004058.png"></div><br><h2>  Obtenir des texels </h2><br>  Nous d√©placerons la fen√™tre de pixels par les bits de couverture stock√©s dans les texels.  Nous devons r√©pondre √† la question suivante: combien d'√©chantillons entreront dans notre fen√™tre de pixels?  Il est illustr√© par l'image suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/027/d8f/bf0/027d8fbf08ed742fa9d5c529778f91a3.png"></div><br>  Nous voyons ici quatre texels, sur lesquels un glyphe est partiellement superpos√©.  Un pixel (indiqu√© en bleu) couvre une partie des texels.  Nous devons d√©terminer combien d'√©chantillons notre fen√™tre de pixels traverse.  Nous avons d'abord besoin des √©l√©ments suivants: <br><br><ul><li>  Calculez la position relative de la fen√™tre de pixels par rapport √† 4 texels. </li><li>  Obtenez les texels que notre fen√™tre de pixels recoupe. </li></ul><br>  Notre impl√©mentation est bas√©e sur OpenGL, donc l'origine de l'espace de texture commence en bas √† gauche.  Commen√ßons par calculer la position relative de la fen√™tre de pixels.  La coordonn√©e UV transmise au pixel shader est la coordonn√©e UV du centre du pixel.  En supposant que les UV sont normalis√©s, nous pouvons d'abord convertir les UV en espace texel en le multipliant par la taille de la texture.  En soustrayant 0,5 du centre du pixel, nous obtenons le coin inf√©rieur gauche de la fen√™tre de pixel.  En arrondissant cette valeur vers le bas, nous calculons la position inf√©rieure gauche du texel inf√©rieur gauche.  L'image montre un exemple de ces trois points dans l'espace texel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82b/437/a14/82b437a149bdf438c840e6d7a61695ba.png"></div><br>  La diff√©rence entre le coin inf√©rieur gauche du pixel et le coin inf√©rieur gauche de la grille de texels est la position relative de la fen√™tre de pixel en coordonn√©es normalis√©es.  Dans cette image, la position de la fen√™tre de pixels sera [0,69, 0,37].  Dans le code: <br><br> <code>vec2 bottomLeftPixelPos = uv * size -0.5; <br> vec2 bottomLeftTexelPos = floor(bottomLeftPixelPos); <br> vec2 weigth = bottomLeftPixelPos - bottomLeftTexelPos;</code> <br> <br>  En utilisant l'instruction textureGather, nous pouvons obtenir quatre texels √† la fois.  Il n'est disponible que dans OpenGL 4.0 et sup√©rieur, vous pouvez donc ex√©cuter quatre texelFetch √† la place.  Si nous passons juste les coordonn√©es UV de textureGather, alors avec une correspondance parfaite de la fen√™tre de pixels avec le texel, un probl√®me se posera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d19/f39/8ab/d19f398abc0e3f871f186fec042975cf.png"></div><br>  Ici, nous voyons trois texels horizontaux avec une fen√™tre de pixels (montr√©e en bleu) correspondant exactement au texel central.  Le poids calcul√© est proche de 1,0, mais textureGather a plut√¥t choisi les texels centre et droit.  La raison en est que les calculs effectu√©s par textureGather peuvent diff√©rer l√©g√®rement du calcul du poids en virgule flottante.  La diff√©rence d'arrondi des calculs GPU et des calculs de pond√©ration en virgule flottante entra√Æne des probl√®mes autour des centres de pixels. <br><br>  Pour r√©soudre ce probl√®me, vous devez vous assurer que les calculs de poids correspondent √† l'√©chantillonnage textureGather.  Pour ce faire, nous n'√©chantillonnerons jamais les centres de pixels et, √† la place, nous √©chantillonnerons toujours au centre de la grille de 2 √ó 2 texels.  √Ä partir de la position inf√©rieure du texel gauche calcul√©e et d√©j√† arrondie, nous ajoutons le texel complet pour arriver au centre de la grille de texels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4a/34c/730/f4a34c7308653a6b1f19d429adb11bf4.png"></div><br>  Cette image montre qu'en utilisant le centre de la grille de texels, les quatre points d'√©chantillonnage pris par textureGather seront toujours au centre des texels.  Dans le code: <br><br> <code>vec2 centerTexelPos = (bottomLeftTexelPos + vec2(1.0, 1.0)) / size; <br> uvec4 result = textureGather(fontSampler, centerTexelPos, 0);</code> <br> <br><h2>  Masque horizontal de fen√™tre pixel </h2><br>  Nous avons obtenu quatre texels et ensemble ils forment une grille de 8 √ó 8 bits de couverture.  Pour compter les bits dans une fen√™tre de pixels, nous devons d'abord r√©initialiser les bits en dehors de la fen√™tre de pixels.  Pour ce faire, nous allons cr√©er un masque de fen√™tre de pixels et effectuer un ET au niveau du bit entre le masque de pixels et les masques de couverture de texels.  Le masquage horizontal et vertical sont effectu√©s s√©par√©ment. <br><br>  Le masque de pixels horizontal doit se d√©placer avec le poids horizontal, comme indiqu√© dans cette animation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/6e0/195/c086e01955d3c85a93bd655bddff089d.gif"></div><br>  L'image montre un masque 8 bits avec la valeur 0x0F0 se d√©pla√ßant vers la droite (des z√©ros sont ins√©r√©s √† gauche).  En animation, un masque est anim√© lin√©airement avec du poids, mais en r√©alit√©, un d√©calage de bits est une op√©ration √©tape par √©tape.  Le masque change de valeur lorsque la fen√™tre de pixels traverse la bordure de l'√©chantillon.  Dans l'animation suivante, cela est indiqu√© dans des colonnes rouges et vertes, anim√©es √©tape par √©tape.  La valeur ne change que lorsque les centres des √©chantillons se croisent: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a10/cfe/946/a10cfe946385aec1041c87eef64d707f.gif"></div><br>  Pour que le masque se d√©place uniquement au centre de la cellule, mais pas sur ses bords, un simple arrondi suffit: <br><br> <code>unsigned int pixelMask = 0x0F0 &gt;&gt; int(round(weight.x * 4.0));</code> <br> <br>  Nous avons maintenant un masque de pixels d'une cha√Æne compl√®te de 8 bits couvrant deux texels.  Si nous choisissons le bon type de stockage dans notre masque de couverture 16 bits, il existe des moyens de combiner le texel gauche et droit et d'effectuer un masquage horizontal des pixels pour une ligne 8 bits compl√®te √† la fois.  Cependant, cela devient probl√©matique avec le masquage vertical lorsque nous passons aux grilles tourn√©es.  Par cons√©quent, nous combinons √† la place deux texels gauches et s√©par√©ment deux texels droits pour cr√©er deux masques de couverture 32 bits.  Nous masquons les r√©sultats gauche et droit s√©par√©ment. <br><br>  Les masques pour les texels gauches utilisent les 4 bits sup√©rieurs du masque de pixels, et les masques pour les texels droits utilisent les 4 bits inf√©rieurs.  Dans une grille uniforme, chaque ligne a le m√™me masque horizontal, nous pouvons donc simplement copier le masque pour chaque ligne, apr√®s quoi le masque horizontal sera pr√™t: <br><br> <code>unsigned int leftRowMask = pixelMask &gt;&gt; 4; <br> unsigned int rightRowMask = pixelMask &amp; 0xF; <br> unsigned int leftMask = (leftRowMask &lt;&lt; 12) | (leftRowMask &lt;&lt; 8) | (leftRowMask &lt;&lt; 4) | leftRowMask; <br> unsigned int rightMask = (rightRowMask &lt;&lt; 12) | (rightRowMask &lt;&lt; 8) | (rightRowMask &lt;&lt; 4) | rightRowMask;</code> <br> <br>  Pour masquer, nous combinons deux texels gauches et deux texels droits, puis masquons les lignes horizontales: <br><br> <code>unsigned int left = ((topLeft &amp; leftMask) &lt;&lt; 16) | (bottomLeft &amp; leftMask); <br> unsigned int right = ((topRight &amp; rightMask) &lt;&lt; 16) | (bottomRight &amp; rightMask);</code> <br> <br>  Maintenant, le r√©sultat peut ressembler √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a4/c67/0a8/2a4c670a8c523334f9b01dddd790d11e.png"></div><br>  Nous pouvons d√©j√† compter les bits de ce r√©sultat en utilisant l'instruction bitCount.  Nous ne devons pas diviser par 16, mais par 32, car apr√®s le masquage vertical, nous pouvons toujours avoir 32 bits potentiels, et non 16. Voici le rendu complet du glyphe √† ce stade: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/334/c6f/ae9334c6fdaedfcd4c17b75c26e4836b.png"></div><br>  Ici, nous voyons une lettre agrandie S rendue sur la base des donn√©es vectorielles originales (contour blanc) et la visualisation des points d'√©chantillonnage.  Si le point est vert, il se trouve √† l'int√©rieur du glyphe, s'il est rouge, alors non.  Niveaux de gris affiche les teintes calcul√©es √† ce stade.  Dans le processus de rendu des polices, il existe de nombreuses possibilit√©s d‚Äôerreurs, allant de la pixellisation, de la fa√ßon dont les donn√©es sont stock√©es dans un atlas de texture et du calcul de la teinte finale.  Ces visualisations sont incroyablement utiles pour valider les calculs.  Ils sont particuli√®rement importants pour le d√©bogage d'artefacts au niveau sous-pixel. <br><br><h2>  Masquage vertical </h2><br>  Nous sommes maintenant pr√™ts √† masquer les bits verticaux.  Pour masquer verticalement, nous utilisons une m√©thode l√©g√®rement diff√©rente.  Pour g√©rer le d√©calage vertical, il est important de se rappeler comment nous avons enregistr√© les bits: par ordre de rang.  La ligne du bas est les quatre bits les moins significatifs et la ligne du haut est les quatre bits les plus significatifs.  Nous pouvons simplement nettoyer un par un, en les d√©calant en fonction de la position verticale de la fen√™tre de pixels. <br><br>  Nous allons cr√©er un seul masque couvrant toute la hauteur de deux texels.  En cons√©quence, nous voulons enregistrer quatre lignes <strong>compl√®tes</strong> de texels et masquer tout le reste, c'est-√†-dire que le masque sera de 4 √ó 4 bits, ce qui est √©gal √† 0xFFFF.  En fonction de la position de la fen√™tre de pixels, nous d√©calons les lignes du bas et effa√ßons les lignes du haut. <br><br> <code>int shiftDown = int(round(weightY * 4.0)) * 4; <br> left = (left &gt;&gt; shiftDown) &amp; 0xFFFF; <br> right = (right &gt;&gt; shiftDown) &amp; 0xFFFF;</code> <br> <br>  En cons√©quence, nous avons √©galement masqu√© les bits verticaux en dehors de la fen√™tre de pixels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9e/007/90d/d9e00790d66da0f0caac1226937136dc.png"></div><br>  Maintenant, il nous suffit de compter les bits restants dans les texels, ce qui peut √™tre fait avec l'op√©ration bitCount, puis diviser le r√©sultat par 16 et obtenir la nuance souhait√©e! <br><br> <code>float shade = (bitCount(left) + bitCount(right)) / 16.0;</code> <br> <br>  Maintenant, le rendu complet de la lettre ressemble √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png"></div><br><h1>  √Ä suivre ... </h1><br>  Dans la deuxi√®me partie, nous passerons √† l'√©tape suivante et verrons comment appliquer cette technique aux grilles tourn√©es.  Nous allons calculer ce sch√©ma: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/f7a/c09/ee0f7ac0925a10db70b9b7330a879961.png"></div><br>  Et nous verrons que presque tout cela peut √™tre r√©duit √† plusieurs tableaux. <br><br>  Merci √† Sebastian Aaltonen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">@SebAaltonen</a> ) pour son aide dans la r√©solution du probl√®me de textureGather et, bien s√ªr, √† Michael van der Leu ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">@MvdleeuwGG</a> ) pour ses id√©es et conversations int√©ressantes le soir. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433670/">https://habr.com/ru/post/fr433670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433652/index.html">La 5G vue par les utilisateurs. Attentes et pr√©occupations</a></li>
<li><a href="../fr433658/index.html">IT in Germany - comment chercher du travail dans les grandes villes en Allemagne</a></li>
<li><a href="../fr433660/index.html">Comment j'ai parl√© √† DefCamp pour la cinqui√®me fois</a></li>
<li><a href="../fr433664/index.html">SATA SSD Enterprise dans le stockage Infortrend √† 2 contr√¥leurs - Mesure des performances</a></li>
<li><a href="../fr433666/index.html">Dictionnaire Funcorp</a></li>
<li><a href="../fr433672/index.html">Les gars, Ruby est mort ou non?</a></li>
<li><a href="../fr433674/index.html">Ouverture ce soir d'un tunnel d'essai pour une soci√©t√© ennuyeuse en Californie</a></li>
<li><a href="../fr433676/index.html">Qui gagne le plus en informatique: les employ√©s de bureau ou distants?</a></li>
<li><a href="../fr433678/index.html">Piratage cryptographique - un nouveau type d'attaque contre le centre de donn√©es</a></li>
<li><a href="../fr433680/index.html">√âv√©nements d'hiver pour l'industrie du jeu dans HSE et simulateur gamedev de bureau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>