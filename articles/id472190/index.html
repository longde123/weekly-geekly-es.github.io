<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛄 🌕 🙍🏾 Jalankan skrip PHP melalui php-fpm tanpa server web. Atau klien FastCGI Anda (di bawah tenda) 👍🏻 🎈 🛡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya menyambut semua pembaca "Habr". 
 Penafian 


 Artikel itu ternyata cukup panjang dan bagi mereka yang tidak ingin membaca latar belakang, tetapi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jalankan skrip PHP melalui php-fpm tanpa server web. Atau klien FastCGI Anda (di bawah tenda)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472190/"><p>  Saya menyambut semua pembaca "Habr". </p><br><h4 id="diskleymer">  Penafian </h4><br><p>  Artikel itu ternyata cukup panjang dan bagi mereka yang tidak ingin membaca latar belakang, tetapi ingin langsung ke intinya, saya meminta Anda langsung ke bab "Solusi". </p><br><h3 id="vstuplenie">  Entri </h3><br><p>  Dalam artikel ini, saya ingin berbicara tentang menyelesaikan masalah yang agak tidak standar yang harus saya hadapi selama proses kerja.  Yaitu, kami perlu menjalankan banyak skrip php dalam satu lingkaran.  Saya tidak akan membahas alasan dan kontroversi solusi arsitektural dalam artikel ini, karena  pada kenyataannya, itu sama sekali bukan tentang itu, itu hanya tugas, itu harus diselesaikan dan solusinya tampak cukup menarik untuk saya bagikan kepada Anda, terutama karena saya sama sekali tidak menemukan mana di Internet (ya, tentu saja, kecuali untuk spesifikasi resmi).  Speck, tentu saja, baik, dan tentu saja semuanya ada di dalamnya, tetapi saya pikir Anda akan setuju bahwa jika Anda tidak terlalu akrab dengan topik, dan bahkan terbatas dalam waktu, maka memahami mereka masih menyenangkan. </p><a name="habracut"></a><br><h3 id="dlya-kogo-eta-statya">  Untuk siapa artikel ini? </h3><br><p>  Untuk semua orang yang bekerja dengan web dan protokol <strong>FastCgi hanya</strong> tahu bahwa ini adalah protokol yang digunakan server web untuk menjalankan skrip php, tetapi ingin mempelajarinya secara lebih rinci dan mencari di bawah tenda. </p><br><h3 id="obosnovanie-zachem-eta-statya">  Pembenaran (mengapa artikel ini) </h3><br><p>  Secara umum, seperti yang saya tulis di atas ketika kita dihadapkan dengan kebutuhan untuk menjalankan banyak skrip php tanpa partisipasi server web (kira-kira berbicara dari skrip php lain), hal pertama yang terlintas dalam pikiran adalah ... </p><br><pre><code class="php hljs">shell_exec(<span class="hljs-string"><span class="hljs-string">'php \path\to\script.php'</span></span>)</code> </pre> <br><p>  Tetapi pada awal setiap skrip, sebuah lingkungan akan dibuat, proses terpisah akan diluncurkan, secara umum, tampaknya entah bagaimana mahal untuk sumber daya.  Implementasi ini ditolak.  Hal kedua yang terlintas dalam pikiran adalah tentu saja <strong>php-fpm</strong> , sangat keren, hanya memulai lingkungan sekali, memonitor memori, mencatat semuanya dengan benar, memulai dan menghentikan skrip, secara umum semuanya tidak keren, dan tentu saja kami menyukai cara ini lebih lanjut. </p><br><p>  Tapi itu nasib buruk, secara teori kami tahu cara kerjanya, secara umum (ternyata sangat umum), tetapi ternyata cukup sulit untuk menerapkan protokol ini dalam praktik tanpa partisipasi server web.  Membaca spesifikasi dan beberapa jam upaya yang gagal menunjukkan bahwa akan membutuhkan waktu untuk mengimplementasikan, yang tidak kami miliki saat itu.  Tidak ada mana untuk pelaksanaan usaha ini di mana interaksi ini dapat secara sederhana dan jelas dijelaskan, kami juga tidak dapat mengambil spesifikasi, dari solusi siap pakai kami menemukan skrip Python dan lib Pykhov di github, yang pada akhirnya tidak ingin diseret ke proyek saya (mungkin itu tidak benar, tetapi tidak benar-benar, kami menyukai semua jenis perpustakaan pihak ketiga dan bahkan yang tidak terlalu populer, dan karenanya tidak diuji).  Secara umum, sebagai hasil dari ide ini, kami menolak dan mengimplementasikan semua ini melalui rabbitmq tua yang baik. </p><br><p>  Meskipun masalah akhirnya diselesaikan, saya masih memutuskan untuk memahami FastCgi secara rinci, dan di samping itu saya memutuskan untuk menulis artikel tentang itu, yang akan secara sederhana dan rinci menjelaskan cara mendapatkan <strong>php-fpm</strong> untuk menjalankan skrip php tanpa server web, atau lebih tepatnya, sebagai server web akan memiliki skrip yang berbeda, maka saya akan menyebutnya klien Fcgi.  Secara umum, saya berharap artikel ini akan membantu mereka yang dihadapkan dengan tugas yang sama seperti yang kita lakukan dan setelah membacanya akan dapat dengan cepat menulis semua yang dia butuhkan. </p><br><h3 id="tvorcheskiy-poisk-lozhnyy-put">  Pencarian kreatif (jalur salah) </h3><br><p>  Jadi masalahnya ditunjukkan, kita harus melanjutkan ke solusi.  Secara alami, seperti halnya programmer "normal", untuk memecahkan masalah yang tidak ditulis di mana pun apa yang harus dilakukan dan apa yang harus dimasukkan ke dalam konsol, saya tidak membaca dan menerjemahkan spesifikasinya, tetapi segera muncul dengan solusi "brilian" saya sendiri.  Esensinya adalah sebagai berikut, saya tahu bahwa <strong>nginx</strong> (kami menggunakan nginx dan agar tidak menulis <strong>hal-hal bodoh</strong> lebih lanjut - server web, saya akan menulis nginx, karena lebih simpatik) mentransfer sesuatu ke <strong>php-fpm</strong> , ia <strong>juga</strong> memproses <strong>php-fpm</strong> untuk itu menjalankan skrip berdasarkan itu, well, semuanya tampak sederhana, saya akan mengambilnya dan berjanji itu yang mentransmisikan <strong>nginx</strong> dan saya akan melewati hal yang sama. </p><br><p>  <strong>Netcat</strong> hebat akan membantu di sini (utilitas UNIX untuk bekerja dengan lalu lintas jaringan, yang menurut saya dapat melakukan hampir semua hal).  Jadi kami mengatur <strong>netcat</strong> untuk mendengarkan pada port lokal, dan mengkonfigurasi <strong>nginx</strong> agar berfungsi dengan file php melalui socket (tentu saja, socket pada port yang sama dengan yang <strong>netcat</strong> dengarkan) </p><br><p>  mendengarkan 9000 port </p><br><pre> <code class="plaintext hljs">nc -l 9000</code> </pre> <br><p>  Anda dapat memeriksa bahwa semuanya OK, Anda dapat menghubungi alamat 127.0.0.1:9000 melalui browser dan gambar berikut harus </p><br><img src="https://habrastorage.org/webt/ux/9s/_f/ux9s_fkir12e0yn3arj010nnezw.png"><br><p>  konfigurasikan <strong>nginx</strong> sehingga memproses skrip php melalui soket pada port 9000 (dalam pengaturan '/ etc / nginx / sites-available / default', tentu saja, mereka mungkin berbeda) </p><br><pre> <code class="plaintext hljs">location ~ \.php$ { include snippets/fastcgi-php.conf; fastcgi_pass 127.0.0.1:9000; }</code> </pre><br><p>  Setelah manipulasi ini, kami akan memeriksa apa yang terjadi dengan menghubungi skrip php melalui browser </p><br><img src="https://habrastorage.org/webt/u_/hf/j1/u_hfj1xa4tnqyb35rdmfu5nf-na.png"><br><p>  Dapat dilihat bahwa <strong>nginx</strong> mengirimkan variabel lingkungan, serta karakter yang tidak dapat dicetak, yaitu, data ditransmisikan dalam pengkodean biner, yang berarti tidak dapat dengan mudah disalin dan dikirim ke <strong>soket php-fpm</strong> .  Jika Anda menyimpannya ke file, misalnya, maka mereka disimpan dalam pengkodean heksadesimal, itu akan terlihat seperti ini berlaku </p><br><img src="https://habrastorage.org/webt/le/7e/9y/le7e9ycpkn8n3mezj7ksa9xhkki.png"><br><p>  Tapi ini juga tidak memberi kita banyak, mungkin murni secara teoritis mereka dapat dikonversi ke pengkodean biner, entah bagaimana (saya bahkan tidak bisa membayangkan bagaimana) untuk mengirim mereka ke soket fpm, dan bahkan ada kemungkinan bahwa seluruh motor ini entah bagaimana akan bekerja, dan bahkan memulai semacam sebuah skrip, tapi entah bagaimana semuanya jelek dan canggung. </p><br><p>  Menjadi jelas bahwa jalan ini benar-benar salah, Anda dapat melihat sendiri betapa menyedihkannya semua ini terlihat, dan terlebih lagi, semua tindakan ini tidak akan memungkinkan kita untuk mengontrol koneksi, juga tidak akan membawa kita lebih dekat untuk memahami interaksi antara <strong>php-fpm</strong> dan <strong>nginx</strong> . </p><br><p>  Semuanya hilang, spesifikasinya tidak bisa dihindari! </p><br><h3 id="reshenie-tut-sobstvenno-nachinaetsya-vsya-sol-dannoy-stati">  Solusi (di sini semua garam dari artikel ini sebenarnya dimulai) </h3><br><h4 id="teoreticheskaya-podgotovka">  Pelatihan teori </h4><br><p>  Sekarang mari kita pertimbangkan bagaimana semua yang sama ada koneksi dan pertukaran data antara <strong>nginx</strong> dan <strong>php-fpm</strong> .  Sedikit teori, semua komunikasi terjadi seperti yang sudah jelas melalui soket, kami selanjutnya akan mempertimbangkan koneksi melalui soket TCP. </p><br><p>  Unit informasi dalam protokol <strong>FastCgi</strong> adalah <strong>catatan cgi</strong> .  Server mengirimkan catatan tersebut ke aplikasi dan menerima catatan yang sama persis sebagai tanggapan. </p><br><h5 id="nemnogo-teorii-struktury">  Sedikit teori (struktur) </h5><br><p>  Selanjutnya, perhatikan struktur catatan.  Untuk memahami apa yang terdiri dari catatan, Anda perlu memahami seperti apa struktur C dan memahami sebutannya.  Bagi mereka yang tidak tahu lebih jauh, ini akan dijelaskan secara singkat (tetapi cukup untuk pemahaman).  Saya akan mencoba menggambarkannya sesederhana mungkin, tidak ada gunanya untuk merinci, dan saya takut bahwa saya akan bingung dalam detailnya, hal utama adalah memiliki pemahaman yang sama. </p><br><p>  Struktur hanyalah kumpulan byte, dan notasi untuknya memungkinkannya ditafsirkan.  Artinya, Anda hanya memiliki urutan nol dan satu, dan beberapa data dienkripsi dalam urutan ini, tetapi sejauh ini Anda tidak memiliki anotasi untuk urutan ini, maka data ini tidak mewakili nilai apa pun bagi Anda, karena  Anda tidak dapat menafsirkannya. </p><br><pre> <code class="plaintext hljs">//     1101111000000010010110000010011100010000</code> </pre> <br><p>  Apa yang terlihat di sini, kita memiliki beberapa bit, jenis bit apa yang kita tidak tahu.  Sebagai contoh, mari kita coba untuk membaginya menjadi byte dan mewakili dalam sistem desimal </p><br><pre> <code class="plaintext hljs">//   5  11011110 00000010 01011000 00100111 00010000 //    222 2 88 39 16</code> </pre> <br><p>  Nah, kami menafsirkannya dan mendapatkan beberapa hasil, katakanlah bahwa data ini bertanggung jawab atas berapa banyak apartemen tertentu berutang untuk listrik.  Ternyata di rumah 222 apartemen nomor 2 harus membayar 88 rubel.  Dan apa lagi untuk dua digit, apa yang harus dilakukan dengan hanya menjatuhkannya?  Tentu tidak!  Faktanya adalah bahwa kita tidak memiliki notasi (format) yang akan memberi tahu kita bagaimana menafsirkan data, dan menafsirkannya dengan cara kita sendiri, dalam hal ini kita menerima tidak hanya hasil yang tidak berguna, tetapi juga berbahaya.  Akibatnya, apartemen 2 dibayar sama sekali tidak seperti yang seharusnya.  (Contoh-contohnya jelas dibuat-buat dan hanya berfungsi untuk menjelaskan situasi dengan lebih jelas) </p><br><p>  Sekarang mari kita lihat bagaimana kita harus menafsirkan data ini dengan benar, memiliki notasi (format).  Selanjutnya saya akan memanggil sekop sekop, yaitu notation = format (di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini format</a> ). </p><br><pre> <code class="plaintext hljs">//  "Cnn" //  //C -   (char) (8 ) //n -  short (16 ) //      11011110 0000001001011000 0010011100010000 //    222 600 10000</code> </pre> <br><p>  Sekarang semuanya bertemu di rumah No. 222, apartemen 600 untuk listrik harus 1.000 rubel. Saya pikir sekarang pentingnya formatnya jelas, dan sekarang sudah jelas bagaimana kira-kira struktur yang mirip.  (harap perhatikan, di sini tujuannya bukan untuk menjelaskan secara terperinci apa struktur ini, tetapi untuk memberikan pemahaman umum tentang apa itu dan bagaimana kerjanya) </p><br><p>  Simbol dari struktur ini adalah </p><br><pre> <code class="plaintext hljs">struct { unsigned char houseNumber; unsigned char flatNumperA1; unsigned char flatNumperA2; unsigned char summB1; unsigned char summB2; }; // ,           // houseNumber -  // flatNumperA1 &amp;&amp; flatNumperA2 -  // summB1 &amp;&amp; summB2 -  </code> </pre> <br><h5 id="esche-nemnogo-teorii-fastcgi-zapisi">  Beberapa teori lagi (entri FastCgi) </h5><br><p>  Seperti yang saya katakan di atas, unit informasi dalam protokol FastCgi adalah catatan.  Server mengirim catatan ke aplikasi dan menerima catatan yang sama sebagai tanggapan.  Catatan terdiri dari header dan isi dengan data. </p><br><p>  Struktur header: </p><br><ol><li>  versi protokol (selalu 1) dilambangkan dengan 1 byte ('C') </li><li>  jenis rekaman.  Untuk membuka, menutup koneksi, dll. Saya tidak akan mempertimbangkan segalanya, maka saya hanya akan mempertimbangkan apa yang diperlukan untuk tugas tertentu, jika orang lain diperlukan, selamat datang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasinya di</a> sini.  Itu ditunjukkan oleh 1 byte ('C'). </li><li>  ID Permintaan, nomor arbitrer, ditunjukkan oleh 2 byte ('n') </li><li>  panjang badan rekaman (data), ditunjukkan oleh 2 byte ('n') </li><li>  panjang data penyelarasan dan data yang dicadangkan, masing-masing satu byte (tidak perlu memberikan perhatian khusus agar tidak terganggu dari yang utama dalam kasus kami akan selalu ada 0) </li></ol><br><p>  Berikutnya adalah badan catatan: </p><br><ol><li>  data itu sendiri (ini dia justru variabel yang ditransfer) bisa cukup besar (hingga 65535 byte) </li></ol><br><p>  Berikut adalah contoh dari catatan biner FastCgi paling sederhana dengan format </p><br><pre> <code class="plaintext hljs">struct { // unsigned char version; unsigned char type; unsigned char idA1; unsigned char idA2; unsigned char bodyLengthB1; unsigned char bodyLengthB2; unsigned char paddingLength; unsigned char reserved; //  unsigned char contentData; // 65535  unsigned char paddingData; };</code> </pre> <br><h4 id="praktika">  Berlatih </h4><br><h5 id="skript-klient-i-peredayuschiy-soket">  Klien skrip dan soket pengirim </h5><br><p>  Untuk transfer data kami akan menggunakan ekstensi soket php standar.  Dan hal pertama yang perlu dilakukan adalah mengkonfigurasi <strong>php-fpm</strong> untuk mendengarkan pada port di host lokal, misalnya 9000. Hal ini dilakukan dalam kebanyakan kasus di file '/etc/php/7.3/fpm/pool.d/www.conf', jalur tentu saja Tergantung pada pengaturan sistem Anda.  Di sana Anda perlu mendaftarkan sesuatu seperti yang berikut ini (saya membawa seluruh alas kaki sehingga Anda dapat menavigasi, bagian utama adalah dengarkan di sini) </p><br><pre> <code class="plaintext hljs">; The address on which to accept FastCGI requests. ; Valid syntaxes are: ; 'ip.add.re.ss:port' - to listen on a TCP socket to a specific IPv4 address on ; a specific port; ; '[ip:6:addr:ess]:port' - to listen on a TCP socket to a specific IPv6 address on ; a specific port; ; 'port' - to listen on a TCP socket to all addresses ; (IPv6 and IPv4-mapped) on a specific port; ; '/path/to/unix/socket' - to listen on a unix socket. ; Note: This value is mandatory. ;listen = /run/php/php7.3-fpm.sock listen = 127.0.0.1:9002</code> </pre> <br><p>  Setelah mengatur fpm, langkah selanjutnya adalah menghubungkan ke soket </p><br><pre> <code class="php hljs">$service_port = <span class="hljs-number"><span class="hljs-number">9000</span></span>; $address = <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>; $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); $result = socket_connect($socket, $address, $service_port);</code> </pre> <br><h4 id="nachalo-zaprosa-fcgi_begin_request">  Mulai dari permintaan FCGI_BEGIN_REQUEST </h4><br><p>  Untuk membuka koneksi, kita harus mengirim entri dengan tipe FCGI_BEGIN_REQUEST = 1 Judul entri akan seperti ini (untuk mengonversi nilai numerik ke string biner dengan format yang ditentukan, paket fungsi php () akan digunakan) </p><br><pre> <code class="php hljs">socket_write($socket, pack(<span class="hljs-string"><span class="hljs-string">'CCnnCx'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  - 1 //  - 1 - FCGI_BEGIN_REQUEST //id - 1 //   - 8  // - 0</span></span></code> </pre> <br><p>  Badan rekaman untuk membuka koneksi harus mengandung peran perekaman dan bendera yang mengendalikan koneksi </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//      //struct { // unsigned char roleB1; // unsigned char roleB0; // unsigned char flags; // unsigned char reserved[5]; //}; //php  socket_write($socket, pack('nCxxxxx', 1, 0)); // - 1 -  // - 1 -    1   </span></span></code> </pre> <br><p>  Jadi, catatan untuk membuka koneksi berhasil dikirim, <strong>php-fpm</strong> akan menerimanya dan akan terus mengharapkan dari kami catatan lebih lanjut di mana kita perlu mentransfer data untuk menyebarkan lingkungan dan menjalankan skrip. </p><br><h4 id="peredacha-parametrov-okruzheniya-fcgi_params">  Melewati Parameter Lingkungan FCGI_PARAMS </h4><br><p>  Dalam catatan ini, kami akan meneruskan semua parameter yang diperlukan untuk menyebarkan lingkungan, serta nama skrip yang akan kami jalankan. </p><br><p>  Pengaturan lingkungan minimum yang disyaratkan </p><br><pre> <code class="php hljs">$url = <span class="hljs-string"><span class="hljs-string">'/path/to/script.php'</span></span> $env = [ <span class="hljs-string"><span class="hljs-string">'REQUEST_METHOD'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'SCRIPT_FILENAME'</span></span> =&gt; $url, ];</code> </pre> <br><p>  Hal pertama yang perlu kita lakukan di sini adalah menyiapkan variabel-variabel yang diperlukan, yaitu pasangan nilai name =&gt; yang akan kita berikan ke aplikasi. </p><br><p>  Struktur nilai nama pasangan akan seperti itu </p><br><pre> <code class="plaintext hljs">//          128  typedef struct { unsigned char nameLength; unsigned char valueLength; unsigned char nameData unsigned char valueData; }; //    1 </code> </pre> <br><p>  Ada 1 byte pertama - namanya panjang, lalu 1 byte adalah nilainya </p><br><pre> <code class="plaintext hljs">//         128  typedef struct { unsigned char nameLengthA1; unsigned char nameLengthA2; unsigned char nameLengthA3; unsigned char nameLengthA4; unsigned char valueLengthB1; unsigned char valueLengthB2; unsigned char valueLengthB3; unsigned char valueLengthB4; unsigned char nameData unsigned char valueData; }; //    4 </code> </pre> <br><p>  Dalam kasus kami, baik nama dan artinya pendek dan sesuai dengan opsi pertama, jadi kami akan mempertimbangkannya. </p><br><p>  Encode variabel kami sesuai dengan format </p><br><pre> <code class="php hljs">$keyValueFcgiString = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($env <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $value) { <span class="hljs-comment"><span class="hljs-comment">//        //  128         $keyLen = strlen($key); $lenKeyChar = $keyLen &lt; 128 ? chr($keyLen) : pack('N', $keyLen); $valLen = strlen($value); $valLenChar = $valLen &lt; 128 ? chr($valLen) : pack('N', $valLen); $keyValueFcgiString .= $lenKeyChar . $valLenChar . $key . $value; }</span></span></code> </pre> <br><p>  Di sini nilai yang kurang dari 128 bit dikodekan oleh fungsi <em>chr ($ keyLen)</em> , lebih dari <em>paket ('N', $ valLen)</em> , di mana 'N' adalah singkatan dari 4 byte.  Dan kemudian semua ini terjebak bersama dalam satu baris sesuai dengan format struktur.  Tubuh rekaman sudah siap. </p><br><p>  Di tajuk catatan, kami mentransfer semuanya sama seperti pada catatan sebelumnya, kecuali untuk tipe (itu akan menjadi FCGI_PARAMS = 4) dan panjang data (itu akan sama dengan panjang pasangan nama =&gt; nilai, atau panjang string $ keyValueFcgiString yang kami buat sebelumnya). </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  socket_write($socket, pack('CCnnCx', 1, 4, 1, strlen($keyValueFcgiString), 0)); // body socket_write($socket, $keyValueFcgiString); //             //  body socket_write($socket, pack('CCnnCx', 1, 4, 1, 0, 0));</span></span></code> </pre> <br><h4 id="poluchenie-otveta-fcgi_params">  Dapatkan tanggapan dari FCGI_PARAMS </h4><br><p>  Sebenarnya, setelah semua yang sebelumnya telah dilakukan, dan semua yang diharapkan telah dikirim ke aplikasi, itu mulai berfungsi dan kita hanya dapat mengambil hasil pekerjaan ini dari soket. <br>  Ingat bahwa sebagai respons kita mendapatkan catatan yang sama dan kita juga perlu menafsirkannya. </p><br><p>  Kami mendapatkan tajuk, selalu 8 byte (kami akan menerima data dengan byte) </p><br><pre> <code class="php hljs">$buf = <span class="hljs-string"><span class="hljs-string">''</span></span>; $arrData = []; $len = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($len) { socket_recv($socket, $buf, <span class="hljs-number"><span class="hljs-number">1</span></span>, MSG_WAITALL); <span class="hljs-comment"><span class="hljs-comment">//   1       $arrData[] = $buf; $len--; } //      'CCnnCx' $protocol = unpack('C', $arrData[0]); $type = unpack('C', $arrData[1]); $id = unpack('n', $arrData[2] . $arrData[3]); $dataLen = unpack('n', $arrData[4] . $arrData[5])[1]; //   ,        (unpack  ,    ) $foo = unpack('C', $arrData[6]); var_dump($dataLen); //     </span></span></code> </pre> <br><p>  Sekarang, sesuai dengan panjang tubuh respons yang diterima, kami akan melakukan pembacaan lain dari soket </p><br><pre> <code class="php hljs">$buf2 = <span class="hljs-string"><span class="hljs-string">''</span></span>; $result = []; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($dataLen) { socket_recv($socket, $buf2, <span class="hljs-number"><span class="hljs-number">1</span></span>, MSG_WAITALL); $result[] = $buf2; $dataLen--; } var_dump(implode(<span class="hljs-string"><span class="hljs-string">''</span></span>, $result)); <span class="hljs-comment"><span class="hljs-comment">//       socket_close($socket);</span></span></code> </pre> <br><p>  Hore itu berhasil!  Akhirnya itu! <br>  Apa yang kita miliki di jawabannya, kalau misalnya di file ini </p><br><pre> <code class="php hljs">$url = <span class="hljs-string"><span class="hljs-string">'/path/to/script.php'</span></span> <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre> <br><p>  kami akan menulis </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"My fcgi script"</span></span>;</code> </pre> <br><p>  maka dalam jawaban yang kita dapatkan sebagai hasilnya </p><br><p><img src="https://habrastorage.org/webt/dq/pc/ox/dqpcox1zbmcutdzxxeh69i_hbsc.png" alt="gambar"></p><br><h3 id="itogi">  Ringkasan </h3><br><p>  Saya tidak akan menulis banyak di sini, jadi artikel yang panjang ternyata.  Saya harap dia membantu seseorang.  Dan saya akan memberikan skrip final itu sendiri, ternyata cukup kecil.  Tentu saja, dia bisa melakukan sedikit hal dalam formulir ini, dan dia tidak memiliki penanganan kesalahan dan semua ini, tetapi dia tidak membutuhkannya, dia membutuhkannya sebagai contoh untuk menunjukkan dasar-dasarnya. </p><br><div class="spoiler">  <b class="spoiler_title">Versi lengkap skrip</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $url = <span class="hljs-string"><span class="hljs-string">'/path/to/script.php'</span></span>; $env = [ <span class="hljs-string"><span class="hljs-string">'REQUEST_METHOD'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'SCRIPT_FILENAME'</span></span> =&gt; $url, ]; $service_port = <span class="hljs-number"><span class="hljs-number">9000</span></span>; $address = <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>; $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); $result = socket_connect($socket, $address, $service_port); <span class="hljs-comment"><span class="hljs-comment">//  //     php-fpm //    ,   (    ), id ,   ,     socket_write($socket, pack('CCnnCx', 1, 1, 1, 8, 0)); //     // ,     socket_write($socket, pack('nCxxxxx', 1, 0)); $keyValueFcgiString = ''; foreach ($env as $key =&gt; $value) { //        //  128         $keyLen = strlen($key); $lenKeyChar = $keyLen &lt; 128 ? chr($keyLen) : pack('N', $keyLen); $valLen = strlen($value); $valLenChar = $valLen &lt; 128 ? chr($valLen) : pack('N', $valLen); $keyValueFcgiString .= $lenKeyChar . $valLenChar . $key . $value; } // ,      php-fpm           //      //1- ( ), 4-  (,    - FCGI_PARAMS), id  ( ),    (   -),     socket_write($socket, pack('CCnnCx', 1, 4, 1, strlen($keyValueFcgiString), 0)); //      socket_write($socket, $keyValueFcgiString); //  socket_write($socket, pack('CCnnCx', 1, 4, 1, 0, 0)); $buf = ''; $arrData = []; $len = 8; while ($len) { socket_recv($socket, $buf, 1, MSG_WAITALL); //   1       $arrData[] = $buf; $len--; } //      'CCnnCx' $protocol = unpack('C', $arrData[0]); $type = unpack('C', $arrData[1]); $id = unpack('n', $arrData[2] . $arrData[3]); $dataLen = unpack('n', $arrData[4] . $arrData[5])[1]; //   ,        (unpack  ,    ) $foo = unpack('C', $arrData[6]); $buf2 = ''; $result = []; while ($dataLen) { socket_recv($socket, $buf2, 1, MSG_WAITALL); $result[] = $buf2; $dataLen--; } var_dump(implode('', $result)); //       socket_close($socket);</span></span></code> </pre></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472190/">https://habr.com/ru/post/id472190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472178/index.html">Holivar. Sejarah Runet. Bagian 7. YouTube: pelawak, cicit, dan Lembah Silikon</a></li>
<li><a href="../id472182/index.html">Mengumumkan .NET Core 3.1 Pratinjau 1</a></li>
<li><a href="../id472184/index.html">Remote SSH: Tip dan Trik</a></li>
<li><a href="../id472186/index.html">Prinsip terbuka-tertutup</a></li>
<li><a href="../id472188/index.html">Yang Perlu Anda Ketahui tentang Verifikasi Pemeriksaan Toko Aplikasi (tanda terima App Store)</a></li>
<li><a href="../id472196/index.html">"Gula" buatan rumah untuk proyek Android atau "Bagaimana tidak melakukannya"</a></li>
<li><a href="../id472198/index.html">Lokalisasi pesan push dalam aplikasi seluler</a></li>
<li><a href="../id472200/index.html">Modernisasi kelas ilmu komputer di sekolah Rusia dengan raspberry: murah dan ceria</a></li>
<li><a href="../id472202/index.html">Windows 10 + Python = VS Code + WSL</a></li>
<li><a href="../id472204/index.html">Eksperimen sederhana dengan mikrokontroler STM32F103 (Blue Tablet)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>