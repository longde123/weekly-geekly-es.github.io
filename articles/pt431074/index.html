<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📝 👨🏿‍🚒 👃🏻 Guia de JavaScript Parte 8: Visão geral dos recursos do ES6 ✂️ ♒️ 🐎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje, na oitava parte da tradução do manual JavaScript, revisaremos os recursos do idioma que apareceram após o lançamento do padrão ES6. De um jeito ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia de JavaScript Parte 8: Visão geral dos recursos do ES6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431074/">  Hoje, na oitava parte da tradução do manual JavaScript, revisaremos os recursos do idioma que apareceram após o lançamento do padrão ES6.  De um jeito ou de outro, já vimos muitas dessas oportunidades anteriormente, em algum lugar delas em mais detalhes, em algum lugar que é dado como certo.  Esta seção do guia destina-se, juntamente com a divulgação de alguns tópicos que não foram abordados anteriormente, a otimizar o conhecimento de um desenvolvedor iniciante no campo do JavaScript moderno. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1: primeiro programa, recursos de linguagem, padrões</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2: estilo do código e estrutura do programa</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3: variáveis, tipos de dados, expressões, objetos</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 4: recursos</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 5: matrizes e loops</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 6: exceções, ponto e vírgula, literais curinga</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 7: modo estrito, esta palavra-chave, eventos, módulos, cálculos matemáticos</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 8: Visão geral dos recursos do ES6</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 9: Visão geral dos padrões ES7, ES8 e ES9</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Sobre o ES6</font> </h2><br>  O padrão ES6, que seria mais correto chamar ES2015 ou ECMAScript 2015 (esses são seus nomes oficiais, embora todos o chamem de ES6), apareceu quatro anos após o lançamento do padrão anterior - ES5.1.  Demorou cerca de dez anos para desenvolver tudo o que foi incluído no padrão ES5.1.  Atualmente, tudo o que apareceu nesse padrão se tornou as ferramentas usuais do desenvolvedor JS.  Deve-se notar que o ES6 fez grandes alterações no idioma (mantendo a compatibilidade com versões anteriores).  Para apreciar a magnitude dessas alterações, pode-se observar que o tamanho do documento que descreve o padrão ES5 é de aproximadamente 250 páginas, e o padrão ES6 é descrito em um documento que já possui aproximadamente 600 páginas. <br><br>  A lista das inovações mais importantes do padrão ES2015 pode incluir o seguinte: <br><br><ul><li>  Funções de seta </li><li>  Promessas </li><li>  Geradores </li><li> Palavras-chave <code>let</code> e <code>const</code> </li><li>  Aulas </li><li>  Módulos </li><li>  Suporte literal de modelo </li><li>  Suporte para parâmetros de função padrão </li><li>  Operador de propagação </li><li>  Atribuição destrutiva </li><li>  Aprimorando literais de objetos </li><li>  <code>for...of</code> loop </li><li>  Suporte para estruturas de dados <code>Map</code> e <code>Set</code> </li></ul><br>  Considere estas possibilidades. <br><br><h2>  <font color="#3AC1EF">Funções de seta</font> </h2><br>  As funções de seta mudaram a aparência do código JavaScript.  Em termos de aparência, seu uso torna as declarações de função mais curtas e fáceis.  Aqui está a declaração de uma função regular. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Mas quase a mesma função de seta (embora não seja completamente semelhante à acima). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Se o corpo da função de seta consistir em apenas uma linha, cujo resultado deve ser retornado dessa função, ela será gravada ainda mais curta. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething()</code> </pre> <br>  Se a função de seta usar apenas um parâmetro, você poderá escrevê-lo da seguinte maneira. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething(param)</code> </pre> <br>  Deve-se notar que, com o advento das funções das setas, as funções comuns não desapareceram, elas ainda podem ser usadas no código, funcionam da mesma maneira que antes. <br><br><h2>  <font color="#3AC1EF">Recursos desta palavra-chave nas funções de seta</font> </h2><br>  As funções de seta não possuem seu próprio valor; elas o herdam do contexto de execução. <br><br>  Isso corrige o problema, para o qual, ao usar funções regulares, era necessário usar construções como <code>var that = this</code> para preservar o contexto.  No entanto, como foi mostrado nas partes anteriores do manual, essa alteração afeta seriamente os recursos do trabalho com funções de seta e o escopo de sua aplicação. <br><br><h2>  <font color="#3AC1EF">Promessas</font> </h2><br>  As promessas permitem que você se livre do conhecido problema chamado "inferno de retorno de chamada", embora seu uso implique o uso de estruturas bastante complexas.  Esse problema foi resolvido no padrão ES2017 com o advento da construção <code>async/await</code> aguardada, que é baseada em promessas. <br><br>  Os desenvolvedores de JavaScript usaram promessas anteriores ao padrão ES2015, usando várias bibliotecas para isso (por exemplo - jQuery, q, deferred.js, voto).  Isso indica a importância e a relevância desse mecanismo.  Diferentes bibliotecas o implementam de maneiras diferentes, o surgimento de um padrão nessa área pode ser considerado um fato muito positivo. <br>  Aqui está o código escrito usando as funções de retorno de chamada (retornos de chamada). <br><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br>  Usando promessas, isso pode ser reescrito da seguinte maneira. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) wait().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wait() }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">Geradores</font> </h2><br>  Geradores são funções especiais que podem pausar sua própria execução e continuar com ela.  Isso permite que outro código seja executado enquanto o gerador estiver ocioso. <br><br>  O gerador decide por si próprio que precisa pausar e permitir que outro código, "aguardando" sua vez, seja executado.  Ao mesmo tempo, o gerador tem a oportunidade de continuar sua execução após a operação, cujos resultados estão aguardando, são concluídos. <br><br>  Tudo isso é feito graças a um único e simples <code>yield</code> palavras-chave.  Quando essa palavra-chave é encontrada no gerador, sua execução é pausada. <br>  Um gerador pode conter muitas linhas com essa palavra-chave, pausando sua própria execução várias vezes.  Os geradores são declarados usando a construção da <code>*function</code> .  Esse asterisco antes da <code>function</code> word não deve ser considerado como um operador de cancelamento de referência de ponteiro usado em idiomas como C, C ++ ou Go. <br><br>  Os geradores marcam o advento de um novo paradigma de programação JavaScript.  Em particular, eles permitem a troca de dados bidirecional entre o gerador e outro código e permitem a criação de loops de longa duração que não "paralisam" o programa. <br><br>  Considere um exemplo que ilustra os recursos da operação de geradores.  Aqui está o próprio gerador. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doubleThat = <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (input / <span class="hljs-number"><span class="hljs-number">2</span></span>))   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> another = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (doubleThat)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (input * doubleThat * another) }</code> </pre> <br>  Com este comando, inicializamos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calc = calculator(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br>  Em seguida, voltamos ao seu iterador. <br><br><pre> <code class="javascript hljs">calc.next()</code> </pre> <br>  Este comando inicia um iterador, retorna um objeto desse tipo. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br>  Aqui acontece o seguinte.  O código executa uma função usando o valor de <code>input</code> passado ao construtor do gerador.  O código do gerador é executado até que a palavra-chave <code>yield</code> seja encontrada nele.  Nesse ponto, ele retorna o resultado da divisão da <code>input</code> por <code>2</code> , que, como a <code>input</code> é <code>10</code> , fornece o número <code>5</code> .  Obtemos esse número graças ao iterador e, junto com ele, uma indicação de que o gerador ainda não foi concluído (a propriedade <code>done</code> no objeto retornado pelo iterador está configurada como <code>false</code> ), ou seja, a função foi suspensa. <br>  Na próxima vez que o iterador for chamado, passamos o número <code>7</code> para o gerador. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre> <br>  Em resposta a isso, o iterador retorna o próximo objeto para nós. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">14</span></span> }</code> </pre> <br>  Aqui, o número <code>7</code> foi usado para calcular o valor <code>doubleThat</code> . <br><br>  À primeira vista, pode parecer que o código de <code>input / 2</code> é como um argumento para alguma função, mas esse é apenas o valor retornado na primeira iteração.  Aqui, pulamos esse valor e usamos o novo valor de entrada <code>7</code> , multiplicando-o por <code>2</code> .  Depois disso, chegamos à segunda palavra-chave <code>yield</code> , como resultado, o valor obtido na segunda iteração é <code>14</code> . <br><br>  Na próxima iteração, que é a última, passamos o número <code>100</code> para o gerador. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  Em resposta, obtemos o seguinte objeto. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> value: <span class="hljs-number"><span class="hljs-number">14000</span></span> }</code> </pre> <br>  A iteração é concluída (a palavra-chave <code>yield</code> não é mais encontrada no gerador), o resultado da avaliação da expressão <code>(input * doubleThat * another)</code> retornado no objeto, ou seja, - <code>10 * 14 * 100</code> e uma indicação da conclusão do iterador ( <code>done: true</code> ). <br><br><h2>  <font color="#3AC1EF">Palavras-chave let e const</font> </h2><br>  O JavaScript sempre usou a palavra-chave <code>var</code> para declarar variáveis.  Tais variáveis ​​têm um escopo funcional.  As palavras-chave <code>let</code> e <code>const</code> , respectivamente, permitem declarar variáveis ​​e constantes que têm um escopo de bloco. <br><br>  Isso significa que, por exemplo, uma variável declarada usando a palavra-chave <code>let</code> em um loop, dentro de um bloco <code>if</code> ou dentro de um bloco de código regular limitado por chaves, não irá além desse bloco.  As variáveis ​​declaradas com <code>var</code> não são mantidas nesses blocos, tornando-se disponíveis na função no nível em que são declaradas. <br><br>  A palavra-chave <code>const</code> funciona como <code>let</code> , mas com ela são declaradas constantes imutáveis. <br><br>  No código JS moderno, a palavra-chave <code>var</code> raramente é usada.  Deu lugar às palavras-chave <code>let</code> e <code>const</code> .  Ao mesmo tempo, o que pode parecer incomum, a palavra-chave <code>const</code> é usada hoje amplamente, o que indica a popularidade das idéias de imunidade de entidades na programação moderna. <br><br><h2>  <font color="#3AC1EF">Aulas</font> </h2><br>  Descobriu-se que o JavaScript era a única linguagem extremamente difundida usando o modelo de herança de protótipo.  Os programadores que mudam para JS a partir de linguagens que implementam o mecanismo de herança baseado em classe se sentiram desconfortáveis ​​nesse ambiente.  O padrão ES2015 introduziu o suporte de classe em JavaScript.  Isso é essencialmente "açúcar sintático" em torno dos mecanismos internos da JS usando protótipos.  No entanto, isso afeta como exatamente os aplicativos JS gravam. <br><br>  Os mecanismos de herança do JavaScript agora se parecem com mecanismos semelhantes em outras linguagens orientadas a objetos. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name } hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, I am '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name + <span class="hljs-string"><span class="hljs-string">'.'</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.hello() + <span class="hljs-string"><span class="hljs-string">' I am an actor.'</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomCruise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Actor(<span class="hljs-string"><span class="hljs-string">'Tom Cruise'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(tomCruise.hello())</code> </pre> <br>  Este programa exibe o texto <code>Hello, I am Tom Cruise. I am an actor</code> no console <code>Hello, I am Tom Cruise. I am an actor</code>  <code>Hello, I am Tom Cruise. I am an actor</code> <br>  Nas classes JS, as variáveis ​​de instância não podem ser declaradas; elas devem ser inicializadas nos construtores. <br><br><h3>  <font color="#3AC1EF">Construtor da classe </font> </h3><br>  As classes têm um método especial, <code>constructor</code> , chamado quando uma instância da classe é criada usando a <code>new</code> palavra-chave. <br><br><h3>  <font color="#3AC1EF">▍ Palavra-chave super</font> </h3><br>  A <code>super</code> palavra <code>super</code> chave permite acessar a classe pai das classes descendentes. <br><br><h3>  <font color="#3AC1EF">▍ Getters e setters</font> </h3><br>  O getter para uma propriedade pode ser definido da seguinte maneira. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ get fullName() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.firstName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.lastName}</span></span></span><span class="hljs-string">`</span></span> } }</code> </pre> <br>  O setter pode ser descrito como mostrado abaixo. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ set age(years) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.theAge = years } }</code> </pre> <br>  Eles trabalham com getters e setters como se não fossem funções, mas propriedades comuns de objetos. <br><br><h2>  <font color="#3AC1EF">Módulos</font> </h2><br>  Antes do padrão ES2015, havia várias abordagens concorrentes para trabalhar com módulos.  Em particular, estamos falando sobre as tecnologias RequireJS e CommonJS.  Essa situação levou a discordâncias na comunidade de desenvolvedores de JS. <br><br>  Atualmente, graças à padronização dos módulos no ES2015, a situação está se normalizando gradualmente. <br><br><h3>  <font color="#3AC1EF">▍ Importar módulos</font> </h3><br>  Os módulos são importados usando uma construção do formulário <code>import...from...</code>  Aqui estão alguns exemplos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { React, Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyLibrary <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Exportação de módulos</font> </h3><br>  Os mecanismos internos do módulo são fechados do mundo exterior, mas a partir do módulo você pode exportar tudo o que ele pode oferecer aos outros módulos.  Isso é feito usando a palavra-chave <code>export</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h3>  <font color="#3AC1EF">Literal Literais de modelo</font> </h3><br>  Literais de modelo são uma nova maneira de descrever seqüências de caracteres em JavaScript.  Aqui está como fica. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aString = <span class="hljs-string"><span class="hljs-string">`A string`</span></span></code> </pre> <br>  Além disso, o uso da sintaxe de literais de modelo permite incorporar expressões em seqüências de caracteres e interpolá-las.  Isso é feito usando uma construção do formulário <code>${a_variable}</code> .  Aqui está um exemplo simples de seu uso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${v}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-comment"><span class="hljs-comment">//something test</span></span></code> </pre> <br>  Aqui está um exemplo mais complicado, ilustrando a capacidade de avaliar qualquer expressão e substituir seus resultados em uma sequência. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str2 = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${foo() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'y'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span></code> </pre> <br>  Graças ao uso de literais de modelo, ficou muito mais fácil declarar seqüências de várias linhas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str3 = <span class="hljs-string"><span class="hljs-string">`Hey this string is awesome!`</span></span></code> </pre> <br>  Compare isso com o que você fez para descrever seqüências de várias linhas ao usar os recursos disponíveis no idioma anterior ao ES2015. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">'One\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Two\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Three'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Parâmetros de função padrão</font> </h2><br>  As funções Now suportam os parâmetros usados ​​por padrão - no caso de os argumentos correspondentes não serem transmitidos a eles ao chamar funções. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, testing = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } foo()</code> </pre> <br><h2>  <font color="#3AC1EF">Operador de propagação</font> </h2><br>  O operador de extensão (operador de extensão) permite "expandir" matrizes, objetos ou cadeias.  Esse operador parece três pontos ( <code>...</code> ).  Primeiro, considere-o com um exemplo de matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br>  Veja como criar uma nova matriz com base nessa matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = [...a, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]</code> </pre> <br>  Veja como criar uma cópia da matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = [...a]</code> </pre> <br>  Este operador também trabalha com objetos.  Por exemplo, veja como usá-lo para clonar um objeto. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newObj = { ...oldObj }</code> </pre> <br>  Aplicando o operador de propagação a uma sequência, você pode convertê-lo em uma matriz, cada elemento contendo um caractere dessa sequência. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hey = <span class="hljs-string"><span class="hljs-string">'hey'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrayized = [...hey] <span class="hljs-comment"><span class="hljs-comment">// ['h', 'e', 'y']</span></span></code> </pre> <br>  Esse operador, além das variantes acima de sua aplicação, é conveniente usar ao chamar funções que esperam uma lista normal de argumentos, transmitindo-lhes uma matriz com esses argumentos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) =&gt;</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] f(...a)</code> </pre> <br>  Anteriormente, isso era feito usando uma construção do formulário <code>f.apply(null, a)</code> , mas esse código é mais difícil de escrever e é menos legível. <br><br><h2>  <font color="#3AC1EF">Atribuição destrutiva</font> </h2><br>  A técnica de atribuição de desestruturação permite, por exemplo, pegar um objeto, extrair alguns valores dele e colocá-los em variáveis ​​ou constantes nomeadas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: <span class="hljs-string"><span class="hljs-string">'Tom'</span></span>, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: <span class="hljs-string"><span class="hljs-string">'Cruise'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actor</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">54</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {<span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: name, age} = person</code> </pre> <br>  Aqui, as propriedades <code>firstName</code> e <code>age</code> são recuperadas do objeto.  A propriedade <code>age</code> é gravada na constante declarada com o mesmo nome e a propriedade <code>firstName</code> , após a extração, cai no <code>name</code> da constante. <br><br>  A atribuição destrutiva também é adequada para trabalhar com matrizes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [first, second, , , fifth] = a</code> </pre> <br>  A <code>first</code> , a <code>second</code> e a <code>fifth</code> constantes obtêm o primeiro, o segundo e o quinto elementos da matriz, respectivamente. <br><br><h2>  <font color="#3AC1EF">Aprimorando literais de objetos</font> </h2><br>  O ES2015 expandiu bastante a capacidade de descrever objetos usando literais de objetos. <br><br><h3>  <font color="#3AC1EF">▍ Simplificação da inclusão de variáveis ​​em objetos</font> </h3><br>  Anteriormente, para atribuir uma variável à propriedade de um objeto, era necessário usar a seguinte construção. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">something</span></span>: something }</code> </pre> <br>  Agora, a mesma coisa pode ser feita assim. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { something }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Protótipos</font> </h3><br>  O protótipo do objeto agora pode ser definido usando a seguinte construção. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Palavra-chave super</font> </h3><br>  Usando a <code>super</code> palavra <code>super</code> chave, os objetos podem acessar objetos de protótipo.  Por exemplo, para chamar seus métodos que tenham os mesmos nomes que os métodos desses próprios objetos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span>, <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'zoo'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject, test() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.test() + <span class="hljs-string"><span class="hljs-string">'x'</span></span> } } x.test() <span class="hljs-comment"><span class="hljs-comment">//zoox</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">Names Nomes de propriedades calculados</font> </h3><br>  Os nomes de propriedades computados são formados no estágio de criação do objeto. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { [<span class="hljs-string"><span class="hljs-string">'a'</span></span> + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + <span class="hljs-string"><span class="hljs-string">'b'</span></span>]: <span class="hljs-string"><span class="hljs-string">'z'</span></span> } x.a_b <span class="hljs-comment"><span class="hljs-comment">//z</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">For ... de loop</font> </h2><br>  Em 2009, no padrão ES5, os loops <code>forEach()</code> apareceram.  Esse é um projeto útil, cuja desvantagem é o fato de que esses ciclos são muito inconvenientes para interromper.  O clássico <code>for</code> loop em situações em que você precisa interromper a execução do loop antes de sua conclusão normal é uma escolha muito mais apropriada. <br><br>  Um ciclo <code>for...of</code> apareceu no ES2015, que, por um lado, se distingue por sua sintaxe concisa e conveniência para <code>forEach</code> , e por outro lado, suporta a possibilidade de saída antecipada do ciclo. <br><br>  Aqui estão alguns exemplos <code>for...of</code> loop <code>for...of</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    for (const v of ['a', 'b', 'c']) { console.log(v); } //           entries() for (const [i, v] of ['a', 'b', 'c'].entries()) { console.log(i, v); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Mapear e definir estruturas de dados</font> </h2><br>  O ES2015 introduziu estruturas de dados <code>Map</code> e <code>Set</code> (bem como suas versões "fracas" <code>WeakMap</code> e <code>WeakSet</code> , cuja utilização melhora o desempenho do "coletor de lixo" - o mecanismo responsável pelo gerenciamento de memória nos mecanismos JS).  Essas são estruturas de dados muito populares que, antes do surgimento de sua implementação oficial, precisavam ser imitadas usando as ferramentas de linguagem disponíveis. <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  Hoje, revisamos os recursos do padrão ES2015, que influenciaram bastante o estado atual do idioma.  Nosso próximo tópico serão os recursos dos padrões ES2016, ES2017 e ES2018. <br><br>  <b>Caros leitores!</b>  Quais inovações do padrão ES6 você considera mais úteis? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431074/">https://habr.com/ru/post/pt431074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt431064/index.html">Manifesto de programador rígido</a></li>
<li><a href="../pt431066/index.html">DEFCON 16. Como posso contatá-lo? Deixe-me listar os caminhos. Parte 2</a></li>
<li><a href="../pt431068/index.html">A arte da educação: a ideologia das máquinas caça-níqueis</a></li>
<li><a href="../pt431070/index.html">Hara come? Estamos falando dos hábitos alimentares de um especialista em TI moderno</a></li>
<li><a href="../pt431072/index.html">Guia JavaScript parte 7: modo estrito, esta palavra-chave, eventos, módulos, matemática</a></li>
<li><a href="../pt431076/index.html">As estruturas Node.js. mais populares de 2018</a></li>
<li><a href="../pt431078/index.html">Guia de tratamento de erros JavaScript</a></li>
<li><a href="../pt431080/index.html">Como organizar escritórios remotos e não perder uma equipe no espaço</a></li>
<li><a href="../pt431082/index.html">Kotlin: procurando chefe de marketing</a></li>
<li><a href="../pt431084/index.html">Em qualquer situação incompreensível - escreva scripts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>