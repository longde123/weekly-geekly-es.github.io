<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìù üë®üèø‚Äçüöí üëÉüèª Guia de JavaScript Parte 8: Vis√£o geral dos recursos do ES6 ‚úÇÔ∏è ‚ôíÔ∏è üêé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje, na oitava parte da tradu√ß√£o do manual JavaScript, revisaremos os recursos do idioma que apareceram ap√≥s o lan√ßamento do padr√£o ES6. De um jeito ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia de JavaScript Parte 8: Vis√£o geral dos recursos do ES6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431074/">  Hoje, na oitava parte da tradu√ß√£o do manual JavaScript, revisaremos os recursos do idioma que apareceram ap√≥s o lan√ßamento do padr√£o ES6.  De um jeito ou de outro, j√° vimos muitas dessas oportunidades anteriormente, em algum lugar delas em mais detalhes, em algum lugar que √© dado como certo.  Esta se√ß√£o do guia destina-se, juntamente com a divulga√ß√£o de alguns t√≥picos que n√£o foram abordados anteriormente, a otimizar o conhecimento de um desenvolvedor iniciante no campo do JavaScript moderno. <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1: primeiro programa, recursos de linguagem, padr√µes</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2: estilo do c√≥digo e estrutura do programa</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3: vari√°veis, tipos de dados, express√µes, objetos</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 4: recursos</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 5: matrizes e loops</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 6: exce√ß√µes, ponto e v√≠rgula, literais curinga</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 7: modo estrito, esta palavra-chave, eventos, m√≥dulos, c√°lculos matem√°ticos</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 8: Vis√£o geral dos recursos do ES6</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 9: Vis√£o geral dos padr√µes ES7, ES8 e ES9</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Sobre o ES6</font> </h2><br>  O padr√£o ES6, que seria mais correto chamar ES2015 ou ECMAScript 2015 (esses s√£o seus nomes oficiais, embora todos o chamem de ES6), apareceu quatro anos ap√≥s o lan√ßamento do padr√£o anterior - ES5.1.  Demorou cerca de dez anos para desenvolver tudo o que foi inclu√≠do no padr√£o ES5.1.  Atualmente, tudo o que apareceu nesse padr√£o se tornou as ferramentas usuais do desenvolvedor JS.  Deve-se notar que o ES6 fez grandes altera√ß√µes no idioma (mantendo a compatibilidade com vers√µes anteriores).  Para apreciar a magnitude dessas altera√ß√µes, pode-se observar que o tamanho do documento que descreve o padr√£o ES5 √© de aproximadamente 250 p√°ginas, e o padr√£o ES6 √© descrito em um documento que j√° possui aproximadamente 600 p√°ginas. <br><br>  A lista das inova√ß√µes mais importantes do padr√£o ES2015 pode incluir o seguinte: <br><br><ul><li>  Fun√ß√µes de seta </li><li>  Promessas </li><li>  Geradores </li><li> Palavras-chave <code>let</code> e <code>const</code> </li><li>  Aulas </li><li>  M√≥dulos </li><li>  Suporte literal de modelo </li><li>  Suporte para par√¢metros de fun√ß√£o padr√£o </li><li>  Operador de propaga√ß√£o </li><li>  Atribui√ß√£o destrutiva </li><li>  Aprimorando literais de objetos </li><li>  <code>for...of</code> loop </li><li>  Suporte para estruturas de dados <code>Map</code> e <code>Set</code> </li></ul><br>  Considere estas possibilidades. <br><br><h2>  <font color="#3AC1EF">Fun√ß√µes de seta</font> </h2><br>  As fun√ß√µes de seta mudaram a apar√™ncia do c√≥digo JavaScript.  Em termos de apar√™ncia, seu uso torna as declara√ß√µes de fun√ß√£o mais curtas e f√°ceis.  Aqui est√° a declara√ß√£o de uma fun√ß√£o regular. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Mas quase a mesma fun√ß√£o de seta (embora n√£o seja completamente semelhante √† acima). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Se o corpo da fun√ß√£o de seta consistir em apenas uma linha, cujo resultado deve ser retornado dessa fun√ß√£o, ela ser√° gravada ainda mais curta. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething()</code> </pre> <br>  Se a fun√ß√£o de seta usar apenas um par√¢metro, voc√™ poder√° escrev√™-lo da seguinte maneira. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething(param)</code> </pre> <br>  Deve-se notar que, com o advento das fun√ß√µes das setas, as fun√ß√µes comuns n√£o desapareceram, elas ainda podem ser usadas no c√≥digo, funcionam da mesma maneira que antes. <br><br><h2>  <font color="#3AC1EF">Recursos desta palavra-chave nas fun√ß√µes de seta</font> </h2><br>  As fun√ß√µes de seta n√£o possuem seu pr√≥prio valor; elas o herdam do contexto de execu√ß√£o. <br><br>  Isso corrige o problema, para o qual, ao usar fun√ß√µes regulares, era necess√°rio usar constru√ß√µes como <code>var that = this</code> para preservar o contexto.  No entanto, como foi mostrado nas partes anteriores do manual, essa altera√ß√£o afeta seriamente os recursos do trabalho com fun√ß√µes de seta e o escopo de sua aplica√ß√£o. <br><br><h2>  <font color="#3AC1EF">Promessas</font> </h2><br>  As promessas permitem que voc√™ se livre do conhecido problema chamado "inferno de retorno de chamada", embora seu uso implique o uso de estruturas bastante complexas.  Esse problema foi resolvido no padr√£o ES2017 com o advento da constru√ß√£o <code>async/await</code> aguardada, que √© baseada em promessas. <br><br>  Os desenvolvedores de JavaScript usaram promessas anteriores ao padr√£o ES2015, usando v√°rias bibliotecas para isso (por exemplo - jQuery, q, deferred.js, voto).  Isso indica a import√¢ncia e a relev√¢ncia desse mecanismo.  Diferentes bibliotecas o implementam de maneiras diferentes, o surgimento de um padr√£o nessa √°rea pode ser considerado um fato muito positivo. <br>  Aqui est√° o c√≥digo escrito usando as fun√ß√µes de retorno de chamada (retornos de chamada). <br><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br>  Usando promessas, isso pode ser reescrito da seguinte maneira. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) wait().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wait() }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">Geradores</font> </h2><br>  Geradores s√£o fun√ß√µes especiais que podem pausar sua pr√≥pria execu√ß√£o e continuar com ela.  Isso permite que outro c√≥digo seja executado enquanto o gerador estiver ocioso. <br><br>  O gerador decide por si pr√≥prio que precisa pausar e permitir que outro c√≥digo, "aguardando" sua vez, seja executado.  Ao mesmo tempo, o gerador tem a oportunidade de continuar sua execu√ß√£o ap√≥s a opera√ß√£o, cujos resultados est√£o aguardando, s√£o conclu√≠dos. <br><br>  Tudo isso √© feito gra√ßas a um √∫nico e simples <code>yield</code> palavras-chave.  Quando essa palavra-chave √© encontrada no gerador, sua execu√ß√£o √© pausada. <br>  Um gerador pode conter muitas linhas com essa palavra-chave, pausando sua pr√≥pria execu√ß√£o v√°rias vezes.  Os geradores s√£o declarados usando a constru√ß√£o da <code>*function</code> .  Esse asterisco antes da <code>function</code> word n√£o deve ser considerado como um operador de cancelamento de refer√™ncia de ponteiro usado em idiomas como C, C ++ ou Go. <br><br>  Os geradores marcam o advento de um novo paradigma de programa√ß√£o JavaScript.  Em particular, eles permitem a troca de dados bidirecional entre o gerador e outro c√≥digo e permitem a cria√ß√£o de loops de longa dura√ß√£o que n√£o "paralisam" o programa. <br><br>  Considere um exemplo que ilustra os recursos da opera√ß√£o de geradores.  Aqui est√° o pr√≥prio gerador. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doubleThat = <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (input / <span class="hljs-number"><span class="hljs-number">2</span></span>))   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> another = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (doubleThat)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (input * doubleThat * another) }</code> </pre> <br>  Com este comando, inicializamos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calc = calculator(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br>  Em seguida, voltamos ao seu iterador. <br><br><pre> <code class="javascript hljs">calc.next()</code> </pre> <br>  Este comando inicia um iterador, retorna um objeto desse tipo. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br>  Aqui acontece o seguinte.  O c√≥digo executa uma fun√ß√£o usando o valor de <code>input</code> passado ao construtor do gerador.  O c√≥digo do gerador √© executado at√© que a palavra-chave <code>yield</code> seja encontrada nele.  Nesse ponto, ele retorna o resultado da divis√£o da <code>input</code> por <code>2</code> , que, como a <code>input</code> √© <code>10</code> , fornece o n√∫mero <code>5</code> .  Obtemos esse n√∫mero gra√ßas ao iterador e, junto com ele, uma indica√ß√£o de que o gerador ainda n√£o foi conclu√≠do (a propriedade <code>done</code> no objeto retornado pelo iterador est√° configurada como <code>false</code> ), ou seja, a fun√ß√£o foi suspensa. <br>  Na pr√≥xima vez que o iterador for chamado, passamos o n√∫mero <code>7</code> para o gerador. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre> <br>  Em resposta a isso, o iterador retorna o pr√≥ximo objeto para n√≥s. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">14</span></span> }</code> </pre> <br>  Aqui, o n√∫mero <code>7</code> foi usado para calcular o valor <code>doubleThat</code> . <br><br>  √Ä primeira vista, pode parecer que o c√≥digo de <code>input / 2</code> √© como um argumento para alguma fun√ß√£o, mas esse √© apenas o valor retornado na primeira itera√ß√£o.  Aqui, pulamos esse valor e usamos o novo valor de entrada <code>7</code> , multiplicando-o por <code>2</code> .  Depois disso, chegamos √† segunda palavra-chave <code>yield</code> , como resultado, o valor obtido na segunda itera√ß√£o √© <code>14</code> . <br><br>  Na pr√≥xima itera√ß√£o, que √© a √∫ltima, passamos o n√∫mero <code>100</code> para o gerador. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  Em resposta, obtemos o seguinte objeto. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> value: <span class="hljs-number"><span class="hljs-number">14000</span></span> }</code> </pre> <br>  A itera√ß√£o √© conclu√≠da (a palavra-chave <code>yield</code> n√£o √© mais encontrada no gerador), o resultado da avalia√ß√£o da express√£o <code>(input * doubleThat * another)</code> retornado no objeto, ou seja, - <code>10 * 14 * 100</code> e uma indica√ß√£o da conclus√£o do iterador ( <code>done: true</code> ). <br><br><h2>  <font color="#3AC1EF">Palavras-chave let e const</font> </h2><br>  O JavaScript sempre usou a palavra-chave <code>var</code> para declarar vari√°veis.  Tais vari√°veis ‚Äã‚Äãt√™m um escopo funcional.  As palavras-chave <code>let</code> e <code>const</code> , respectivamente, permitem declarar vari√°veis ‚Äã‚Äãe constantes que t√™m um escopo de bloco. <br><br>  Isso significa que, por exemplo, uma vari√°vel declarada usando a palavra-chave <code>let</code> em um loop, dentro de um bloco <code>if</code> ou dentro de um bloco de c√≥digo regular limitado por chaves, n√£o ir√° al√©m desse bloco.  As vari√°veis ‚Äã‚Äãdeclaradas com <code>var</code> n√£o s√£o mantidas nesses blocos, tornando-se dispon√≠veis na fun√ß√£o no n√≠vel em que s√£o declaradas. <br><br>  A palavra-chave <code>const</code> funciona como <code>let</code> , mas com ela s√£o declaradas constantes imut√°veis. <br><br>  No c√≥digo JS moderno, a palavra-chave <code>var</code> raramente √© usada.  Deu lugar √†s palavras-chave <code>let</code> e <code>const</code> .  Ao mesmo tempo, o que pode parecer incomum, a palavra-chave <code>const</code> √© usada hoje amplamente, o que indica a popularidade das id√©ias de imunidade de entidades na programa√ß√£o moderna. <br><br><h2>  <font color="#3AC1EF">Aulas</font> </h2><br>  Descobriu-se que o JavaScript era a √∫nica linguagem extremamente difundida usando o modelo de heran√ßa de prot√≥tipo.  Os programadores que mudam para JS a partir de linguagens que implementam o mecanismo de heran√ßa baseado em classe se sentiram desconfort√°veis ‚Äã‚Äãnesse ambiente.  O padr√£o ES2015 introduziu o suporte de classe em JavaScript.  Isso √© essencialmente "a√ß√∫car sint√°tico" em torno dos mecanismos internos da JS usando prot√≥tipos.  No entanto, isso afeta como exatamente os aplicativos JS gravam. <br><br>  Os mecanismos de heran√ßa do JavaScript agora se parecem com mecanismos semelhantes em outras linguagens orientadas a objetos. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name } hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, I am '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name + <span class="hljs-string"><span class="hljs-string">'.'</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.hello() + <span class="hljs-string"><span class="hljs-string">' I am an actor.'</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomCruise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Actor(<span class="hljs-string"><span class="hljs-string">'Tom Cruise'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(tomCruise.hello())</code> </pre> <br>  Este programa exibe o texto <code>Hello, I am Tom Cruise. I am an actor</code> no console <code>Hello, I am Tom Cruise. I am an actor</code>  <code>Hello, I am Tom Cruise. I am an actor</code> <br>  Nas classes JS, as vari√°veis ‚Äã‚Äãde inst√¢ncia n√£o podem ser declaradas; elas devem ser inicializadas nos construtores. <br><br><h3>  <font color="#3AC1EF">Construtor da classe </font> </h3><br>  As classes t√™m um m√©todo especial, <code>constructor</code> , chamado quando uma inst√¢ncia da classe √© criada usando a <code>new</code> palavra-chave. <br><br><h3>  <font color="#3AC1EF">‚ñç Palavra-chave super</font> </h3><br>  A <code>super</code> palavra <code>super</code> chave permite acessar a classe pai das classes descendentes. <br><br><h3>  <font color="#3AC1EF">‚ñç Getters e setters</font> </h3><br>  O getter para uma propriedade pode ser definido da seguinte maneira. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ get fullName() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.firstName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.lastName}</span></span></span><span class="hljs-string">`</span></span> } }</code> </pre> <br>  O setter pode ser descrito como mostrado abaixo. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ set age(years) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.theAge = years } }</code> </pre> <br>  Eles trabalham com getters e setters como se n√£o fossem fun√ß√µes, mas propriedades comuns de objetos. <br><br><h2>  <font color="#3AC1EF">M√≥dulos</font> </h2><br>  Antes do padr√£o ES2015, havia v√°rias abordagens concorrentes para trabalhar com m√≥dulos.  Em particular, estamos falando sobre as tecnologias RequireJS e CommonJS.  Essa situa√ß√£o levou a discord√¢ncias na comunidade de desenvolvedores de JS. <br><br>  Atualmente, gra√ßas √† padroniza√ß√£o dos m√≥dulos no ES2015, a situa√ß√£o est√° se normalizando gradualmente. <br><br><h3>  <font color="#3AC1EF">‚ñç Importar m√≥dulos</font> </h3><br>  Os m√≥dulos s√£o importados usando uma constru√ß√£o do formul√°rio <code>import...from...</code>  Aqui est√£o alguns exemplos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { React, Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyLibrary <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Exporta√ß√£o de m√≥dulos</font> </h3><br>  Os mecanismos internos do m√≥dulo s√£o fechados do mundo exterior, mas a partir do m√≥dulo voc√™ pode exportar tudo o que ele pode oferecer aos outros m√≥dulos.  Isso √© feito usando a palavra-chave <code>export</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h3>  <font color="#3AC1EF">Literal Literais de modelo</font> </h3><br>  Literais de modelo s√£o uma nova maneira de descrever seq√º√™ncias de caracteres em JavaScript.  Aqui est√° como fica. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aString = <span class="hljs-string"><span class="hljs-string">`A string`</span></span></code> </pre> <br>  Al√©m disso, o uso da sintaxe de literais de modelo permite incorporar express√µes em seq√º√™ncias de caracteres e interpol√°-las.  Isso √© feito usando uma constru√ß√£o do formul√°rio <code>${a_variable}</code> .  Aqui est√° um exemplo simples de seu uso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${v}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-comment"><span class="hljs-comment">//something test</span></span></code> </pre> <br>  Aqui est√° um exemplo mais complicado, ilustrando a capacidade de avaliar qualquer express√£o e substituir seus resultados em uma sequ√™ncia. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str2 = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${foo() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'y'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span></code> </pre> <br>  Gra√ßas ao uso de literais de modelo, ficou muito mais f√°cil declarar seq√º√™ncias de v√°rias linhas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str3 = <span class="hljs-string"><span class="hljs-string">`Hey this string is awesome!`</span></span></code> </pre> <br>  Compare isso com o que voc√™ fez para descrever seq√º√™ncias de v√°rias linhas ao usar os recursos dispon√≠veis no idioma anterior ao ES2015. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">'One\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Two\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Three'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Par√¢metros de fun√ß√£o padr√£o</font> </h2><br>  As fun√ß√µes Now suportam os par√¢metros usados ‚Äã‚Äãpor padr√£o - no caso de os argumentos correspondentes n√£o serem transmitidos a eles ao chamar fun√ß√µes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, testing = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } foo()</code> </pre> <br><h2>  <font color="#3AC1EF">Operador de propaga√ß√£o</font> </h2><br>  O operador de extens√£o (operador de extens√£o) permite "expandir" matrizes, objetos ou cadeias.  Esse operador parece tr√™s pontos ( <code>...</code> ).  Primeiro, considere-o com um exemplo de matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br>  Veja como criar uma nova matriz com base nessa matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = [...a, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]</code> </pre> <br>  Veja como criar uma c√≥pia da matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = [...a]</code> </pre> <br>  Este operador tamb√©m trabalha com objetos.  Por exemplo, veja como us√°-lo para clonar um objeto. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newObj = { ...oldObj }</code> </pre> <br>  Aplicando o operador de propaga√ß√£o a uma sequ√™ncia, voc√™ pode convert√™-lo em uma matriz, cada elemento contendo um caractere dessa sequ√™ncia. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hey = <span class="hljs-string"><span class="hljs-string">'hey'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrayized = [...hey] <span class="hljs-comment"><span class="hljs-comment">// ['h', 'e', 'y']</span></span></code> </pre> <br>  Esse operador, al√©m das variantes acima de sua aplica√ß√£o, √© conveniente usar ao chamar fun√ß√µes que esperam uma lista normal de argumentos, transmitindo-lhes uma matriz com esses argumentos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) =&gt;</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] f(...a)</code> </pre> <br>  Anteriormente, isso era feito usando uma constru√ß√£o do formul√°rio <code>f.apply(null, a)</code> , mas esse c√≥digo √© mais dif√≠cil de escrever e √© menos leg√≠vel. <br><br><h2>  <font color="#3AC1EF">Atribui√ß√£o destrutiva</font> </h2><br>  A t√©cnica de atribui√ß√£o de desestrutura√ß√£o permite, por exemplo, pegar um objeto, extrair alguns valores dele e coloc√°-los em vari√°veis ‚Äã‚Äãou constantes nomeadas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: <span class="hljs-string"><span class="hljs-string">'Tom'</span></span>, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: <span class="hljs-string"><span class="hljs-string">'Cruise'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actor</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">54</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {<span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: name, age} = person</code> </pre> <br>  Aqui, as propriedades <code>firstName</code> e <code>age</code> s√£o recuperadas do objeto.  A propriedade <code>age</code> √© gravada na constante declarada com o mesmo nome e a propriedade <code>firstName</code> , ap√≥s a extra√ß√£o, cai no <code>name</code> da constante. <br><br>  A atribui√ß√£o destrutiva tamb√©m √© adequada para trabalhar com matrizes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [first, second, , , fifth] = a</code> </pre> <br>  A <code>first</code> , a <code>second</code> e a <code>fifth</code> constantes obt√™m o primeiro, o segundo e o quinto elementos da matriz, respectivamente. <br><br><h2>  <font color="#3AC1EF">Aprimorando literais de objetos</font> </h2><br>  O ES2015 expandiu bastante a capacidade de descrever objetos usando literais de objetos. <br><br><h3>  <font color="#3AC1EF">‚ñç Simplifica√ß√£o da inclus√£o de vari√°veis ‚Äã‚Äãem objetos</font> </h3><br>  Anteriormente, para atribuir uma vari√°vel √† propriedade de um objeto, era necess√°rio usar a seguinte constru√ß√£o. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">something</span></span>: something }</code> </pre> <br>  Agora, a mesma coisa pode ser feita assim. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { something }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Prot√≥tipos</font> </h3><br>  O prot√≥tipo do objeto agora pode ser definido usando a seguinte constru√ß√£o. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Palavra-chave super</font> </h3><br>  Usando a <code>super</code> palavra <code>super</code> chave, os objetos podem acessar objetos de prot√≥tipo.  Por exemplo, para chamar seus m√©todos que tenham os mesmos nomes que os m√©todos desses pr√≥prios objetos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span>, <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'zoo'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject, test() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.test() + <span class="hljs-string"><span class="hljs-string">'x'</span></span> } } x.test() <span class="hljs-comment"><span class="hljs-comment">//zoox</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">Names Nomes de propriedades calculados</font> </h3><br>  Os nomes de propriedades computados s√£o formados no est√°gio de cria√ß√£o do objeto. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { [<span class="hljs-string"><span class="hljs-string">'a'</span></span> + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + <span class="hljs-string"><span class="hljs-string">'b'</span></span>]: <span class="hljs-string"><span class="hljs-string">'z'</span></span> } x.a_b <span class="hljs-comment"><span class="hljs-comment">//z</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">For ... de loop</font> </h2><br>  Em 2009, no padr√£o ES5, os loops <code>forEach()</code> apareceram.  Esse √© um projeto √∫til, cuja desvantagem √© o fato de que esses ciclos s√£o muito inconvenientes para interromper.  O cl√°ssico <code>for</code> loop em situa√ß√µes em que voc√™ precisa interromper a execu√ß√£o do loop antes de sua conclus√£o normal √© uma escolha muito mais apropriada. <br><br>  Um ciclo <code>for...of</code> apareceu no ES2015, que, por um lado, se distingue por sua sintaxe concisa e conveni√™ncia para <code>forEach</code> , e por outro lado, suporta a possibilidade de sa√≠da antecipada do ciclo. <br><br>  Aqui est√£o alguns exemplos <code>for...of</code> loop <code>for...of</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    for (const v of ['a', 'b', 'c']) { console.log(v); } //           entries() for (const [i, v] of ['a', 'b', 'c'].entries()) { console.log(i, v); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Mapear e definir estruturas de dados</font> </h2><br>  O ES2015 introduziu estruturas de dados <code>Map</code> e <code>Set</code> (bem como suas vers√µes "fracas" <code>WeakMap</code> e <code>WeakSet</code> , cuja utiliza√ß√£o melhora o desempenho do "coletor de lixo" - o mecanismo respons√°vel pelo gerenciamento de mem√≥ria nos mecanismos JS).  Essas s√£o estruturas de dados muito populares que, antes do surgimento de sua implementa√ß√£o oficial, precisavam ser imitadas usando as ferramentas de linguagem dispon√≠veis. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Hoje, revisamos os recursos do padr√£o ES2015, que influenciaram bastante o estado atual do idioma.  Nosso pr√≥ximo t√≥pico ser√£o os recursos dos padr√µes ES2016, ES2017 e ES2018. <br><br>  <b>Caros leitores!</b>  Quais inova√ß√µes do padr√£o ES6 voc√™ considera mais √∫teis? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431074/">https://habr.com/ru/post/pt431074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt431064/index.html">Manifesto de programador r√≠gido</a></li>
<li><a href="../pt431066/index.html">DEFCON 16. Como posso contat√°-lo? Deixe-me listar os caminhos. Parte 2</a></li>
<li><a href="../pt431068/index.html">A arte da educa√ß√£o: a ideologia das m√°quinas ca√ßa-n√≠queis</a></li>
<li><a href="../pt431070/index.html">Hara come? Estamos falando dos h√°bitos alimentares de um especialista em TI moderno</a></li>
<li><a href="../pt431072/index.html">Guia JavaScript parte 7: modo estrito, esta palavra-chave, eventos, m√≥dulos, matem√°tica</a></li>
<li><a href="../pt431076/index.html">As estruturas Node.js. mais populares de 2018</a></li>
<li><a href="../pt431078/index.html">Guia de tratamento de erros JavaScript</a></li>
<li><a href="../pt431080/index.html">Como organizar escrit√≥rios remotos e n√£o perder uma equipe no espa√ßo</a></li>
<li><a href="../pt431082/index.html">Kotlin: procurando chefe de marketing</a></li>
<li><a href="../pt431084/index.html">Em qualquer situa√ß√£o incompreens√≠vel - escreva scripts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>