<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßí üë©üèø‚Äçüé® üë©üèø‚Äçü§ù‚Äçüë®üèæ G√©n√©ration de signal PWM multiphas√© sur TMS320F28027 üõèÔ∏è üë©‚Äçüé® üêè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il √©tait une fois  dans une galaxie lointaine lointaine  J'ai √©crit un court article sur le contr√¥leur sp√©cialis√© Piccolo de Texas Instruments, qui es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>G√©n√©ration de signal PWM multiphas√© sur TMS320F28027</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457548/"><p>  Il √©tait une fois <del>  dans une galaxie lointaine lointaine </del>  J'ai √©crit un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">court article</a> sur le contr√¥leur sp√©cialis√© Piccolo de Texas Instruments, qui est con√ßu pour contr√¥ler les convertisseurs de puissance et les entra√Ænements √©lectriques.  Ces contr√¥leurs sont des outils de d√©veloppement tr√®s puissants dans de nombreuses t√¢ches et je voulais √©crire autre chose √† leur sujet ... simple et utile. </p><br><p>  R√©cemment, j'ai √©t√© perplexe de d√©velopper un contr√¥leur pour la commande de moteur et, en cons√©quence, un sujet pour l'article a √©t√© form√© - aujourd'hui, je vais parler du processus de formation d'un PWM triphas√© pour la commande de moteur, ainsi que d'expliquer les diff√©rences b√©n√©fiques entre le TMS320F28 et d'autres contr√¥leurs tels que STM32F334, STM32G484, XMC4200 et autres. </p><br><p>  En tant que stand, je vais utiliser le contr√¥leur en cours de d√©veloppement, h√©las, je ne peux pas parler de la partie en fer en d√©tail.  Cependant, si je dis que le contr√¥leur est construit sur la base du bundle TMS320F28027 + DRV8353RSRGZT, alors vous pouvez consulter la fiche technique du pilote et voir le concept g√©n√©ral des circuits + il y a un d√©bogage sur cette pierre et la conception de r√©f√©rence est ouverte dessus. </p><br><p><img src="https://habrastorage.org/webt/bu/ps/ur/bupsur6y9nfobnpa53zqjrfodmo.jpeg" alt="Pilote BLDC"></p><br><p>  En principe, sur le m√™me type de circuits, il est possible de contr√¥ler des moteurs BLDC qui "consomment" des niveaux de tension et des triphas√©s ordinaires, qui veulent d√©j√† une sortie sinuso√Ødale.  Je vais montrer les deux options, comme  le chemin vers le sinus passe par la formation de niveaux de tension. </p><br><p><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="Oscillogramme num√©ro 1"></p><a name="habracut"></a><br><h1 id="nemnogo-o-zheleze">  Un peu de fer </h1><br><p>  La partie puissance du pilote se compose id√©ologiquement de 3 convertisseurs demi-pont, probablement tous les chastotniks et contr√¥leurs pour contr√¥ler les moteurs BLDC dans tous les copters sont fabriqu√©s de la m√™me mani√®re: </p><br><p><img src="https://habrastorage.org/webt/fm/kd/3t/fmkd3tequjgg3gapytg5bvupwfw.png" alt="Pont triphas√©"></p><br><p>  Une diff√©rence - je n'ai pas de redresseur d'entr√©e, car  le contr√¥leur est initialement aliment√© par une tension constante.  La source d'alimentation dans mon cas est un assemblage de batteries Li-ion sous la forme de cellules 18650. Le pilote DRV8353RSRGZT utilis√© peut contr√¥ler seulement 3 demi-ponts de puissance, √©galement dans la version utilis√©e de la pierre, il y a √©galement des amplis op√©rationnels int√©gr√©s pour travailler avec des shunts comme capteurs de courant, int√©gr√©s dc / dc, qui peut dig√©rer jusqu'√† 70 ... 80V et tout cela est configur√© de mani√®re tr√®s flexible via SPI.  Par exemple, il est tr√®s pratique de pouvoir r√©gler le courant d'impulsion maximum de la commande du transistor. </p><br><p>  Dans cette s√©rie, il existe √©galement des pilotes avec un ensemble de fonctions diff√©rent, par exemple, avec un contr√¥le analogique et non SPI ou sans courant continu / courant continu int√©gr√© et sans ampli op√©rationnel.  Pour le prix elles ne sont pas tr√®s diff√©rentes et j'ai pris les plus "hardies" comme vous l'avez probablement d√©j√† compris.  Tout cela est tr√®s beau, mais j'ai abord√© de mani√®re plut√¥t frivole la conception de la liaison du pilote et j'ai eu 2 probl√®mes importants.  En fait, il n'y a qu'un seul probl√®me - c'est une forte surchauffe: </p><br><p><img src="https://habrastorage.org/webt/hh/ud/hh/hhudhh5jk3tpwowsivbvjjar66e.jpeg" alt="Imageur thermique"></p><br><p>  Mais ce probl√®me a √©t√© caus√© par 2 raisons.  En fait, l'essence du probl√®me est la surchauffe du conducteur lui-m√™me.  Sur le thermogramme, le driver est charg√© avec un courant de 5A (pour lui c'est presque inactif) et rien que le driver et le MK lui-m√™me sont un peu chauff√©s.  Les transistors ne sont m√™me pas visibles, ils ont une temp√©rature PCB, √† 5A il y a peu de pertes de chaleur. </p><br><ul><li>  <strong>Erreur n ¬∞ 1</strong> <br>  J'ai √©t√© incit√© par un de mes amis, honn√™tement, j'aurais pens√© √† cela comme la derni√®re chose - le pilote a un courant continu / continu int√©gr√©, qui re√ßoit une entr√©e de 15 √† 50 V et une sortie de 3,3 V pour alimenter le MK, la logique, les comparateurs et les amplificateurs op√©rationnels.  Il semblerait que mes projets ont des micropuces LM5008 et LM5017 sous forme de micropuces s√©par√©es et j'ai calmement r√©duit 60V √† ‚Äã‚Äã3,3V sans chauffage notable √† un courant de 100-150 mA, mais tout s'est av√©r√© plus d√©licat - l'efficacit√© globale du convertisseur s'est av√©r√©e √™tre d'environ 65-70% √† un courant 300 mA!  Le fait est que le convertisseur lui-m√™me peut fournir 3,3 V, mais l'efficacit√© sera faible, il est optimal de r√©gler la tension de sortie 10-12-15V.  Lorsque la sortie √©tait de 12V 100 mA, mon pilote a pratiquement cess√© de chauffer et l'efficacit√© a atteint un agr√©able 88%.  <strong>La solution au probl√®me</strong> est de baisser l'entr√©e 15 ... 50V √† 12V avec le DC / DC int√©gr√©, puis de la baisser de 12V √† 3,3V avec un DC / DC externe d√©j√† bon march√©. </li></ul><br><br><ul><li>  <strong>Erreur n ¬∞ 2</strong> <br>  La deuxi√®me erreur est plus √©vidente et la premi√®re chose que j'ai p√©ch√© comme j'ai pu.  Le fait est que pour les puces dans le paquet QFN, la chaleur principale est √©vacu√©e par le "ventre", elle repose g√©n√©ralement sur le GND et, √† travers plusieurs vias (via), s'accroche au sol et toute la chaleur y va calmement.  Au d√©part, je ne tenais pas compte de la faible efficacit√© du courant continu / continu int√©gr√© avec une grande diff√©rence de tension, donc cela ne me d√©rangeait pas que la goutte thermique ("ventre") s'accroch√¢t √† un polygone GND solide sur la couche int√©rieure, sur la couche ext√©rieure, je n'avais pas de cuivre sous le ventre comme polygone GND  En cons√©quence, il s'est av√©r√© que ~ 0,5 W de chaleur est lib√©r√© sur la puce, et il se dissipe dans la couche interne de la carte, c'est-√†-dire que l'efficacit√© est tr√®s m√©diocre.  <strong>La solution au probl√®me</strong> est que vous devez faire un test de terre sur la couche externe (couche inf√©rieure) et ne pas le faire: </li></ul><br><p><img src="https://habrastorage.org/webt/xj/hr/0g/xjhr0galowhdsrtub50fwouwj_s.png" alt="Circuit imprim√©"></p><br><p>  En cons√©quence, dans la deuxi√®me r√©vision du fer, ces erreurs ont √©t√© corrig√©es: un convertisseur externe CC / CC 12-3,3 V a √©t√© ajout√© et le polygone GND a en outre √©t√© rempli sur la couche inf√©rieure et le tampon √† puce a √©t√© plant√© dessus + le polygone de masse solide interne a √©t√© pr√©serv√©.  Apr√®s de telles am√©liorations, la temp√©rature en fonctionnement continu est pass√©e de +82 √† +43 <sup>o</sup> C: </p><br><p><img src="https://habrastorage.org/webt/_p/t9/qf/_pt9qfhtiicqqdj-kuo_ssg2zsm.png" alt="Thermogramme"></p><br><p>  Comme vous pouvez le voir, en raison de la r√©duction des pertes, la temp√©rature a consid√©rablement diminu√© dans les m√™mes conditions, ainsi que la chaleur est maintenant r√©partie plus uniform√©ment sur la zone de la carte et ne surchauffe localement ni le pilote ni le microcontr√¥leur.  En principe, tout √©tait en fer, rien de plus int√©ressant ne s'est produit et n'a fonctionn√© de mani√®re stable.  Par cons√©quent, ils peuvent recommander l'utilisation du pilote <strong>DRV8353</strong> . </p><br><h1 id="realizaciya-apparatnogo-sdviga-faz-na-120suposup">  Mise en place d'un d√©phasage mat√©riel de 120 <sup>o</sup> </h1><br><p>  Une caract√©ristique du r√©seau triphas√© est que le courant dans les phases n'est pas synchrone, mais est d√©cal√© de 120 <sup>o par</sup> rapport au voisin.  Quel est ce d√©phasage de 120 <sup>o</sup> en g√©n√©ral?  En termes simples, il s'agit d'un d√©calage du point de d√©part de la g√©n√©ration d'un tiers de la p√©riode.  D'un point de vue math√©matique, la p√©riode du signal est de <em>2œÄ</em> , ce qui signifie que le deuxi√®me signal doit √™tre d√©plac√© de 2œÄ / 3 et le troisi√®me de 4œÄ / 3.  D'un point de vue √©lectronique, la p√©riode est fix√©e par le compte √† rebours de notre temporisateur.  Par exemple, lors d'un cadencement √† 60 MHz, nous voulons obtenir un PWM avec une fr√©quence de 50 kHz, ce qui signifie que la p√©riode de compte √† rebours sera de 0 √† 1200 (60000000 Hz / 50000 Hz = 1200).  Maintenant, pour obtenir 3 phases avec un d√©calage de 120 <sup>o,</sup> nous n'avons pas besoin de toucher la 1√®re phase, d'ajouter +400 √† la valeur actuelle pour la 2√®me phase, d'ajouter +800 √† la phase actuelle. </p><br><p>  Si nous utilisons des microcontr√¥leurs sur le noyau du cortex, nous pouvons alors impl√©menter le d√©calage soit en √©crivant une formule math√©matique, soit en utilisant la synchronisation des √©v√©nements.  J'ai toujours √©t√© √©tonn√© que ST, NXP et d'autres n'aient pas simplement enregistr√© o√π la valeur de d√©calage serait √©crite.  Heureusement, TI l'a fait dans son TMS320F28xxx, pour r√©gler le d√©calage, il suffit d'√©crire un registre!  Je ne vais pas vous expliquer pourquoi la solution logicielle n‚Äôest pas optimale, je dirai simplement qu‚Äôelle consid√®re les formules MK pas tr√®s rapidement.  La version avec synchronisation des √©v√©nements est d√©j√† plus ad√©quate et sur stm je ferais juste cela, mais cette option ne permet pas de changer la valeur de phase "√† la vol√©e", c'est-√†-dire que pour certains ponts d√©phas√©s, seule la version logicielle reste.  L'avantage est-il de pouvoir contr√¥ler le mat√©riel de phase?  C'est √† vous de d√©cider, ma t√¢che est de vous dire que c'est possible.  Pour moi, c'est un plus √©vident lorsque nous parlons de contr√¥ler un entra√Ænement √©lectrique ou des onduleurs avec une sortie triphas√©e. </p><br><p>  Configurons maintenant la g√©n√©ration de signaux PWM sous forme de 3 paires compl√©mentaires avec temps mort et d√©phasage.  Jusqu'ici sans sinus.  J'utiliserai les paires suivantes: EPWM1A + EPWM1B, EPWM2A + EPWM2B et EPWM4A + EPWM4B.  Ce sont les signaux qui vont du microcontr√¥leur au pilote. </p><br><ul><li>  <strong>√âtape 1</strong> <br>  Il est n√©cessaire de configurer le multiplexeur GPIO √† l'aide du registre <em>GPAMUX</em> pour fonctionner avec PWM et de d√©sactiver les <em>tractions de la</em> sortie vers l'alimentation, de sorte que lorsque vous l'allumez, il n'y ait pas de log.1 sur toutes les jambes et les touches ne s'ouvrent pas.  La protection actuelle sauvera certainement, mais il vaut mieux ne pas le faire.  Il convient √©galement de se rappeler que pour acc√©der aux registres de configuration, vous devez l'obtenir avec la commande <em>EALLOW</em> , puis <em>r√©activer</em> la protection contre l'√©crasement avec la commande <em>EDIS</em> . </li></ul><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitGPIOforPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPAPUD.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Disable pull-up on GPIO0 (EPWM1A) GpioCtrlRegs.GPAPUD.bit.GPIO1 = 1; // Disable pull-up on GPIO1 (EPWM1B) GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1; // Configure GPIO0 as EPWM1A GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 1; // Configure GPIO1 as EPWM1B GpioCtrlRegs.GPAPUD.bit.GPIO2 = 1; // Disable pull-up on GPIO2 (EPWM2A) GpioCtrlRegs.GPAPUD.bit.GPIO3 = 1; // Disable pull-up on GPIO3 (EPWM2B) GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1; // Configure GPIO2 as EPWM2A GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1; // Configure GPIO3 as EPWM2B GpioCtrlRegs.GPAPUD.bit.GPIO6 = 1; // Disable pull-up on GPIO6 (EPWM4A) GpioCtrlRegs.GPAPUD.bit.GPIO7 = 1; // Disable pull-up on GPIO7 (EPWM4B) GpioCtrlRegs.GPAMUX1.bit.GPIO6 = 1; // Configure GPIO6 as EPWM4A GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 1; // Configure GPIO7 as EPWM4B EDIS; }</span></span></code> </pre> <br><ul><li>  <strong>√âtape 2</strong> <br>  Configurez la g√©n√©ration du signal PWM.  Il faut obtenir une fr√©quence de 50 kHz et un d√©phasage de 120 <sup>o</sup> .  Dans ce cas, j'utilise le PWM habituel, car dans ce contr√¥leur il y a aussi HRPWM, il est important de s'en souvenir.  Le module PWM est cadenc√© √† la fr√©quence de base, c'est-√†-dire 60 MHz, j'ai montr√© comment r√©gler la fr√©quence PLL dans le premier article sur TMS320, je ne le r√©p√©terai pas, mais √† la fin de l'article il y aura une archive avec le code et il sera possible d'y jeter un ≈ìil. </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// EPWM Module 1 config EPwm1Regs.TBPRD = 600; // Set priod EPwm1Regs.TBPHS.half.TBPHS = 0; // Set phase EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; // Symmetrical mode EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE; // Master enable EPwm1Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_CTR_ZERO; // Sync down-stream module EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm1Regs.AQCTLA.bit.CAU = AQ_SET; EPwm1Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm1Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // enable dead-time module EPwm1Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // Active Hi complementary EPwm1Regs.DBFED = 20; // dead-time on 20 tick EPwm1Regs.DBRED = 20; // dead-time off 20 tick // EPWM Module 2 config EPwm2Regs.TBPRD = 600; EPwm2Regs.TBPHS.half.TBPHS = 400; // Set phase = 400/1200 * 360 = 120 deg EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm2Regs.TBCTL.bit.PHSEN = TB_ENABLE; // Slave enable EPwm2Regs.TBCTL.bit.PHSDIR = TB_DOWN; // Count DOWN on sync (=120 deg) EPwm2Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm2Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // sync flow-through EPwm2Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm2Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm2Regs.AQCTLA.bit.CAU = AQ_SET; EPwm2Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm2Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm2Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm2Regs.DBFED = 20; EPwm2Regs.DBRED = 20; // EPWM Module 4 config EPwm4Regs.TBPRD = 600; EPwm4Regs.TBPHS.half.TBPHS = 400; EPwm4Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm4Regs.TBCTL.bit.PHSEN = TB_ENABLE; EPwm4Regs.TBCTL.bit.PHSDIR = TB_UP; EPwm4Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm4Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; EPwm4Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm4Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm4Regs.AQCTLA.bit.CAU = AQ_SET; EPwm4Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm4Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm4Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm4Regs.DBFED = 20; EPwm4Regs.DBRED = 20; }</span></span></code> </pre> <br><p>  Maintenant, un peu plus en d√©tail ... dans le registre <em>TBPRD</em> , √©crivez la p√©riode, ou plut√¥t "p√©riode / 2", car  le temporisateur est compt√© dans les deux sens, il s'av√®re que la p√©riode 600 correspond √† la fr√©quence du signal PWM de sortie de 50 kHz en mode paire compl√©mentaire.  Dans le registre <em>TBPHS, nous</em> √©crivons la valeur de phase par laquelle nous devons d√©caler, dans ce cas 400 sur 600, ce qui correspond √† 2œÄ / 3.  Il est √† noter que nous ne d√©pla√ßons pas la 1√®re phase, donc pour cela le d√©calage est de 0, pour la 2√®me phase le d√©calage est respectivement de 400, mais pour la 3√®me phase, il semblerait logique d'√©crire 800, mais 800 sur 600 d'une mani√®re ou d'une autre pas vraiment ... donc ils √©crivent le d√©calage non pas par rapport √† la 1√®re phase, mais par rapport √† la pr√©c√©dente, c'est-√†-dire la 2e.  En cons√©quence, nous obtenons que dans la 3e phase, nous √©crivons 400 et cela correspond √† 2œÄ / 3 entre la phase 2 et 3, et puisque la 2e est d√©j√† d√©cal√©e, alors entre les phases 1 et 3 il y aura "2œÄ / 3 + 2œÄ / 3 = 4œÄ / 3 "et du point de vue √©lectronique, tout semble logique. </p><br><p>  Pour que les phases comprennent qui se d√©place par rapport √† qui, un patron est n√©cessaire, donc EPWM1 ‚Äã‚Äãest d√©fini en utilisant le bit <em>PHSEN</em> en mode ma√Ætre et EPWM2 et EPWM4, respectivement, en tant qu'esclaves.  En utilisant les bits <em>SYNCOSEL</em> , le ¬´point¬ª de <em>synchronisation</em> est <em>√©galement</em> d√©fini, c'est-√†-dire o√π lire le d√©calage.  EPWM1 ‚Äã‚Äãest synchronis√© avec le d√©but de la minuterie, c'est-√†-dire avec une p√©riode nulle, et EPWM2 et EPWM4 sont d√©j√† synchronis√©s par rapport au front de signal du canal pr√©c√©dent: le canal pr√©c√©dent pour EPWM2 est EPWM1, et pour EPWM4 c'est EPWM2. </p><br><p>  Il reste maintenant √† activer des paires compl√©mentaires et √† d√©finir la dur√©e du temps mort.  En utilisant les bits <em>POLSEL</em> , <em>nous</em> d√©finissons un PWM non inverse, c'est-√†-dire qu'en atteignant la valeur d√©finie du comparateur (r√©f√©rence), un journal est g√©n√©r√© √† la sortie.  1. Dans <em>OUT_MODE, nous</em> d√©finissons la g√©n√©ration de temps mort √† la fois sur le bord et sur la chute du signal.  En cons√©quence, dans les registres <em>DBFED</em> et <em>DBRED,</em> √©crivez la dur√©e du temps mort en ticks. </p><br><ul><li>  <strong>√âtape 3</strong> <br>  Il reste maintenant √† √©crire la valeur du facteur d'utilisation dans le registre <em>CMPA</em> correspondant √† chaque canal et vous pouvez observer le r√©sultat. </li></ul><br><pre> <code class="cpp hljs"> EPwm1Regs.CMPA.half.CMPA = <span class="hljs-number"><span class="hljs-number">300</span></span>; <span class="hljs-comment"><span class="hljs-comment">// duty for output EPWM1A EPwm2Regs.CMPA.half.CMPA = 300; // duty for output EPWM2A EPwm4Regs.CMPA.half.CMPA = 300; // duty for output EPWM4A</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/sl/wy/6b/slwy6b5zoivfrdpbzlf9vpbsmms.png" alt="PWM triphas√©"></p><br><p>  Voila!  Les sondes de l'oscilloscope sont connect√©es √† la sortie du pilote.  Le canal jaune est notre EPWM1, c'est-√†-dire le ma√Ætre.  Le canal bleu est EPWM2 et il est d√©cal√© de 2œÄ / 3 (ou 400 √©chantillons) par rapport au canal jaune, et le canal vert est d√©cal√© de 400 autres √©chantillons.  On obtient ainsi 3 phases, o√π chaque phase est d√©cal√©e de 120 <sup>o</sup> . </p><br><p>  Transf√©rons maintenant les sondes de l'oscilloscope de la sortie du pont de puissance aux signaux de commande qui sortent du microcontr√¥leur et v√©rifions le temps mort √† l'int√©rieur de la paire compl√©mentaire: </p><br><p><img src="https://habrastorage.org/webt/cd/aj/k7/cdajk7vfo9vs5d1yzvbuvtggy00.png" alt="Oscillogramme num√©ro 2"></p><br><p>  Comme vous pouvez le voir, le temps mort r√©gl√© correspond au temps r√©el.  La dur√©e d'un √©chantillon est de <em>1/60 000 000 Hz = 16,6 ns</em> et nous obtenons 20 √©chantillons, ce qui √©quivaut au temps mort 20,6 <em>16</em> ns = 332 ns *, ce qui correspond approximativement √† ce qui est observ√© sur l'oscillogramme. </p><br><p>  En fait, o√π cela peut √™tre utile, sous la forme actuelle.  L'option la plus √©vidente est les convertisseurs dc / dc multiphas√©s, pour ceux qui souhaitent google le <strong>convertisseur dc / dc entrelac√©</strong> .  Il s'agit d'une solution technique extr√™mement int√©ressante qui peut r√©duire consid√©rablement la taille des inductances de puissance, r√©duire la capacit√© de sortie des condensateurs et √©galement augmenter l'efficacit√©.  Sur un simple TMS320F28027, vous pouvez impl√©menter un convertisseur 4 phases et tout cela sera tr√®s simplement impl√©ment√© dans le code et uniquement dans le mat√©riel. </p><br><h1 id="generiruem-trehfaznoe-peremennoe-napryazhenie">  Nous g√©n√©rons une tension alternative triphas√©e </h1><br><p>  Dans de nombreux probl√®mes, il ne suffira pas d'obtenir des valeurs discr√®tes de 0 ou VCC √† la sortie; une onde sinuso√Ødale est n√©cessaire.  J'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article</a> qui parle de la formation d'une tension alternative monophas√©e et la m√©thode "tabulaire" y est utilis√©e, c'est-√†-dire que les valeurs de l'onde sinuso√Ødale ont √©t√© initialement calcul√©es.  En principe, cela peut √©galement √™tre fait pour la phase triphas√©e, mais je veux montrer une option alternative, √† savoir le calcul de la valeur en douane en temps r√©el ou √† la vol√©e. </p><br><p>  Il y a une caract√©ristique.  La fr√©quence PWM dans ce cas est √©galement de 50 kHz et le d√©phasage est r√©gl√© entre les p√©riodes de ce signal.  En cons√©quence, lorsque nous modulons une sinuso√Øde avec une fr√©quence de 50 Hz, le d√©phasage mat√©riel est "perdu", il sera toujours pr√©sent entre les PWM, mais pas √† l'int√©rieur de la sinuso√Øde, il faudra donc le faire par logiciel.  La trigonom√©trie est une chose lourde pour le TMS320F28027, mais ce n'est pas tr√®s occup√© avec moi, alors laissez-le compter.  Si vous avez une t√¢che qui n√©cessite beaucoup de calculs, vous avez besoin d'un contr√¥leur avec TMU et FPU, par exemple, TMS320F280049, qui peut tourner les calculs beaucoup plus rapidement. </p><br><p>  Pour charger les valeurs de devoir dans le PWM, nous avons besoin d'une minuterie, dont la p√©riode d√©finira la fr√©quence d'√©chantillonnage.  J'ai besoin d'une p√©riode de 20 ms (1 / 50Hz = 20 ms) et je vais prendre le nombre de pas dans une sinuso√Øde, disons 20, par cons√©quent, une interruption doit √™tre g√©n√©r√©e avec une fr√©quence de 0,02 s / 20 = 0,001 ms = 1 kHz et dans cette interruption, j'√©crirai la valeur dans le PWM .  Pour plus de simplicit√©, je vais prendre un minuteur <em>CPU0</em> normal et le configurer: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitTimer0ForGenerator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; PieVectTable.TINT0 = &amp;cpu_timer0_isr; EDIS; InitCpuTimers(); ConfigCpuTimer(&amp;CpuTimer0, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); CpuTimer0Regs.TCR.bit.TIE = <span class="hljs-number"><span class="hljs-number">1</span></span>; CpuTimer0Regs.TCR.bit.TSS = <span class="hljs-number"><span class="hljs-number">0</span></span>; IER |= M_INT1; PieCtrlRegs.PIEIER1.bit.INTx7 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Enable TINT0 in the PIE: Group 1 interrupt 7 EINT; // Enable Global interrupt INTM ERTM; // Enable Global real-time interrupt DBGM } __interrupt void cpu_timer0_isr (void) { CpuTimer0.InterruptCount++; /* *   -  . ... */ PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre> <br><p>  Les fonctions <em>InitCpuTimers</em> et <em>ConfigCpuTimer sont</em> standard, tous les r√©glages y sont, il suffit de transf√©rer la fr√©quence centrale (60 MHz) et la p√©riode de comptage en microsecondes (1000 Œºs = 1 ms), ce qui √©quivaut √† 1 kHz, et nous en avions besoin.  Alors, o√π dans la fonction de configuration, nous activons les interruptions et passons l'adresse du gestionnaire de notre interruption, o√π tout se passera. </p><br><p>  Il faut maintenant "inventer" √† nouveau la formule sinuso√Ødale, pour cela il faut avoir des connaissances en trigonom√©trie scolaire et c'est tout.  Et donc ... nous avons une fonction <strong><em>y = sin (x)</em></strong> tra√ßons cette fonction: </p><br><p><img src="https://habrastorage.org/webt/hi/bx/ey/hibxeyajv_h7l7t-mqkbkfrq6-s.png" alt="y = sin (x)"></p><br><p>  Comme vous pouvez le voir sur le graphique, l'amplitude de y varie de -1 √† 1, mais nous voulons de 0 √† 1, car  avec une amplitude minimale, nous avons 0V, et avec un maximum (√©quivalent √† 1), nous avons + VCC.  Pour "dessiner" -1 ... + 1, nous avons besoin d'une nutrition bipolaire, mais ce n'est pas le cas.  Vous devez d√©placer le graphique dans une direction positive.  Si nous le soulevons, il passera de 0 √† +2, et nous ne pourrons que jusqu'√† +1.  Vous devez donc diviser par 2 et juste quelque chose!  Commen√ßons par diviser et tracer simplement pour <strong><em>y = (sin (x) / 2):</em></strong> </p><br><p><img src="https://habrastorage.org/webt/t_/n0/iw/t_n0iw1fym8aboggaxk1my7r4um.png" alt="y = (sin (x) / 2)"></p><br><p>  Ouais!  Maintenant, le graphique a une plage de -0,5 √† +0,5, c'est-√†-dire que l'amplitude est 1. C'est d√©j√† mieux, mais nous ne nous sommes pas encore d√©barrass√©s des valeurs n√©gatives, nous allons donc simplement augmenter le graphique de 0,5, pour cela nous avons juste besoin d'ajouter cette valeur au r√©sultat et d'obtenir la formule <strong><em>y = 0,5 + (sin (x) / 2)</em></strong> et tracez le graphique de cette fonction: </p><br><p><img src="https://habrastorage.org/webt/df/vu/ez/dfvuez1lks2uhg0cp3tkhie9cdq.png" alt="y = 0,5 + (sin (x) / 2)"></p><br><p>  Maintenant, tout est devenu absolument parfait: la sinuso√Øde a une amplitude de 0 √† 1, les valeurs n√©gatives sont absentes.  La formule <strong><em>y = 0,5 + (sin (x) / 2)</em></strong> d√©crit la 1√®re phase, il est maintenant n√©cessaire d'ajouter un d√©phasage pour obtenir les phases 2 et 3. Pour ce faire, soustrayez respectivement 2œÄ / 3 et 4œÄ / 3 de <em>x</em> et obtenez les formules pour le reste phases <strong><em>y = 0,5 + (sin (x-2œÄ / 3) / 2)</em></strong> et <strong><em>y = 0,5 + (sin (x-4œÄ / 3) / 2).</em></strong>  Nous construisons 3 graphiques et voyons si cela ressemble √† la v√©rit√©: </p><br><p><img src="https://habrastorage.org/webt/hj/kp/n9/hjkpn93-37r_rclbrevchhdzf_m.png" alt="3 phases"></p><br><p>  Pas mal!  L'image est similaire √† ce qui est g√©n√©ralement peint dans les manuels de g√©nie √©lectrique lorsqu'ils parlent d'un r√©seau triphas√© ou de moteurs asynchrones.  Soit dit en passant, 2,0943 est 2œÄ / 3 et 4,1866 est 4œÄ / 3, respectivement, je viens de les compter tout de suite et ils apparaissent dans mon code.  Au total, nous avons 3 √©quations: </p><br><ul><li>  Phase A - <strong><em>y = 0,5 + (sin (x) / 2)</em></strong> </li><li>  Phase B - <strong><em>y = 0,5 + (sin (x-2œÄ / 3) / 2)</em></strong> </li><li>  Phase C - <strong><em>y = 0,5 + (sin (x-4œÄ / 3) / 2)</em></strong> </li></ul><br><p>  Du c√¥t√© des math√©matiques, tout semble simple et clair, mais maintenant vous devez l'adapter aux r√©alit√©s des microcontr√¥leurs.  Notre onde sinuso√Ødale n'est pas analogique, mais a des "pas", c'est-√†-dire qu'elle est discr√®te, car nous ne pouvons r√©gler que la tension ou 0V ou + 15V (VCC) dans mon cas.  Plus t√¥t, j'ai √©crit que j'aurais 20 √©tapes, donc pour 1 p√©riode j'aurais 20 calculs. </p><br><p>  Tout d'abord, d√©cidons quoi remplacer <em>x</em> .  La p√©riode de notre sinuso√Øde est de <em>2œÄ</em> , ce qui signifie que le pas d'√©chantillonnage sera de <em>2œÄ / 20</em> .  Par cons√©quent, la sinuso√Øde sera constitu√©e de 20 points, comme si nous construisions un graphique sur les points, et approximativement entre eux.  Par cons√©quent, la valeur dans la premi√®re √©tape sera <strong><em>sin (2œÄ * (1/20),</em></strong> dans la deuxi√®me √©tape <strong><em>sin (2œÄ * (2/20)),</em></strong> dans la troisi√®me √©tape * <strong>sin (2œÄ <em>(3/20))</em></strong> et ainsi de suite, lorsque nous S'il atteint <em>20/20</em> , cela signifiera la fin de la p√©riode et il faudra recommencer le comptage. Sur la base des donn√©es re√ßues, corrigeons les formules: </p><br><ul><li>  Phase A - <strong><em>y = 0,5 + (sin (2œÄ * (n / N)) / 2)</em></strong> </li><li>  Phase B - <strong><em>y = 0,5 + (sin (2œÄ * (n / N) -2œÄ / 3) / 2)</em></strong> </li><li>  Phase C - <strong><em>y = 0,5 + (sin (2œÄ * (n / N) -4œÄ / 3) / 2)</em></strong> </li></ul><br><p>  Maintenant, nous consid√©rons maintenant la valeur du sinus √† chaque point sp√©cifique du graphique.  Par cons√©quent, <strong>n</strong> est l'√©tape actuelle, <strong>N</strong> est l'√©tape totale (20).  Apr√®s ces formules, nous obtenons une valeur de 0 √† 1, mais en r√©alit√© nous ne fonctionnons pas avec une amplitude abstraite.  L'amplitude dans notre cas d√©pend du rapport cyclique, car  le devoir varie de 0 √† 600 (√† partir des param√®tres PWM), puis 0 est 0 et 1 √©quivaut √† 600. Sur cette base, recalculons-le dans une formule r√©elle pour obtenir la valeur qui sera charg√©e dans le <em>registre PWM</em> CMPA: </p><br><ul><li>  Phase A - <strong><em>devoir1 = A <em>(0,5 + (sin (2œÄ</em> (n / N)) / 2))</em></strong> </li><li>  Phase B - <strong><em>devoir2 = A <em>(0,5 + (sin (2œÄ</em> (n / N) -2œÄ / 3) / 2))</em></strong> </li><li>  Phase C - <strong><em>devoir4 = A <em>(0,5 + (sin (2œÄ</em> (n / N) -4œÄ / 3) / 2))</em></strong> </li></ul><br><p>  Par cons√©quent, <strong>A</strong> est la valeur maximale de l'amplitude, c'est-√†-dire 600, <strong>n</strong> est le pas actuel, <strong>N</strong> est le nombre total de pas (20).  Les valeurs de <strong><em>duty1, duty2, duty4</em></strong> sont les valeurs r√©elles converties du facteur de devoir, qui est charg√© dans l' <em>ACPM.</em>  √âcrivons maintenant le code du gestionnaire d'interruption mis √† jour et d√©clarons toutes les variables n√©cessaires: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> activeStep = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> amplitude = <span class="hljs-number"><span class="hljs-number">600.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> allStep = <span class="hljs-number"><span class="hljs-number">20.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pi = <span class="hljs-number"><span class="hljs-number">3.1415</span></span>; <span class="hljs-comment"><span class="hljs-comment">// œÄ const float piTwo = 6.2831; // 2œÄ const float phaseShifted120deg = 2.0943; // 2œÄ/3 const float phaseShifted240deg = 4.1866; // 4œÄ/3 __interrupt void cpu_timer0_isr (void) { if (activeStep &gt;= allStep) {activeStep = 0;} activeStep++; EPwm1Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep)) / 2)))); EPwm2Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted120deg) / 2)))); EPwm4Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted240deg) / 2)))); PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre><br><p>  Le code, comme vous le voyez, est le plus simple, si vous comprenez ce qu'il fallait faire et les math√©matiques simples dans le probl√®me √† r√©soudre.  Chaque fois que l'interruption est appel√©e, nous incr√©mentons la variable <em>activeStep</em> , qui contient le num√©ro d'√©tape, elle passe de 0 √† 20 puis est r√©initialis√©e.  Il s'av√®re qu'en une p√©riode, nous effectuons 20 √©tapes et 20 calculs pour chaque phase.  Afin de ne pas compter tout le temps <em>2œÄ / 3</em> et <em>4œÄ / 3</em> dans la formule, je les ai compt√©s tout de suite pour les utiliser comme constantes. </p><br><p>  Les calculs se sont av√©r√©s minimum, pour ce MK ce n'est absolument rien.  Si vous le souhaitez, le nombre de points peut √™tre consid√©rablement augment√©, par exemple jusqu'√† 200. Tout d√©pend de la t√¢che.  La modification de la fr√©quence PWM se produit en modifiant la fr√©quence d'appel d'interruption et le nombre d'√©tapes.  Vous pouvez √©galement modifier l' <em>amplitude</em> variable et modifier la tension √† la sortie du convertisseur de puissance. </p><br><p>  Apr√®s avoir t√©l√©charg√© le code sur le microcontr√¥leur, vous obtiendrez l'image correspondante: </p><br><p><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="Oscillogramme num√©ro 1"></p><br><p>  Si vous √©tirez le graphique le long de <em>Y</em> , il devient pr√©f√©rable de voir les d√©fauts du signal.  Ceci est une cons√©quence du petit nombre d'√©tapes d'√©chantillonnage, une r√®gle conditionnelle s'applique: <strong>plus il y a de points, plus le signal est beau.</strong> </p><br><p><img src="https://habrastorage.org/webt/wh/4d/du/wh4dduwnbyshscey7rlmzs6s1mw.png" alt="Oscillogramme num√©ro 3"></p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Aujourd'hui, j'ai parl√© du processus de formation du d√©phasage dans les syst√®mes polyphasiques, en principe, il n'y a rien de compliqu√©, en particulier lors de l'utilisation du TMS320F28.  Le reste d√©pend des algorithmes, en principe, sur Internet, il existe de nombreux articles o√π le contr√¥le de la mastication et les moteurs sans balais, et asynchrones et toutes sortes d'autres, vous ne pouvez que changer la logique. </p><br><p>  J'esp√®re que ce mat√©riel sera utile et pas particuli√®rement ennuyeux √† lire.  Comme toujours, la source est jointe: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Archiver avec le projet pour Code Composer Studio</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457548/">https://habr.com/ru/post/fr457548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457534/index.html">Versions certifi√©es - le r√¢teau que nous choisissons</a></li>
<li><a href="../fr457538/index.html">Comment puis-je utiliser des machines virtuelles Yandex.Cloud interrompues et √©conomiser sur la r√©solution de probl√®mes √† grande √©chelle</a></li>
<li><a href="../fr457540/index.html">Intel Optane DC Persistent Memory, un an plus tard</a></li>
<li><a href="../fr457542/index.html">Piratage et protection des lecteurs de chiffrement LUKS</a></li>
<li><a href="../fr457546/index.html">Demo Day: pourquoi tout cela et comment le faire UPD + Broadcast</a></li>
<li><a href="../fr457550/index.html">De quoi l'industrie num√©rique doit-elle √™tre prot√©g√©e</a></li>
<li><a href="../fr457552/index.html">Grimpeurs √† Zafasadia. Comment fonctionnent les promalps de la tour du centre de Lakhta</a></li>
<li><a href="../fr457558/index.html">Analyse de vuln√©rabilit√© EvilParcel</a></li>
<li><a href="../fr457560/index.html">Actions Tokenized: Comment devenir un investisseur Gett avant de passer en bourse</a></li>
<li><a href="../fr457562/index.html">Ivideon Counter 3D: qui, comment et pourquoi compter les visiteurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>