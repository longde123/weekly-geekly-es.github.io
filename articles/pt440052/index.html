<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüè≠ üëêüèª üéé An√°lise est√°tica do BIOS / UEFI ou como obter um gr√°fico de depend√™ncia ‚ò†Ô∏è ü§© ‚§¥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Eu terminei de forjar ontem, 
 Eu enganei dois planos ... " 
 ... Can√ß√£o VS Vysotsky ... 
 H√° quase tr√™s anos (no in√≠cio de 2016), o desejo de um usu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lise est√°tica do BIOS / UEFI ou como obter um gr√°fico de depend√™ncia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440052/"><table><tbody><tr><td width="480"><img src="https://habrastorage.org/webt/bh/jy/lo/bhjylo0e06sv0b9flvjqzb4e62u.png" width="480"></td><td align="right">  <i>"Eu terminei de forjar ontem,</i> <i><br></i>  <i>Eu enganei dois planos ... "</i> <i><br></i>  <i>... Can√ß√£o VS Vysotsky ...</i> </td></tr></tbody></table><br>  H√° quase tr√™s anos (no in√≠cio de 2016), o desejo de um usu√°rio apareceu na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">edi√ß√£o</a> do projeto UEFITool no GitHub: criar um "Gr√°fico de Depend√™ncia" para m√≥dulos execut√°veis ‚Äã‚Äãinclu√≠dos no BIOS / UEFI. <br><br>  Mesmo uma pequena discuss√£o se seguiu, como resultado do qual finalmente ficou claro que essa tarefa n√£o √© de modo algum trivial, a funcionalidade dispon√≠vel para sua solu√ß√£o n√£o √© suficiente, as perspectivas naquele momento s√£o nebulosas ... <br><br>  E essa quest√£o permaneceu no limbo, com a perspectiva de realiza√ß√£o em um futuro indefinido (mas o desejo provavelmente permaneceu e a esperan√ßa, como voc√™ sabe, morre por √∫ltimo!). <br><br>  H√° uma sugest√£o: finalmente, encontre uma solu√ß√£o para este problema! <br><a name="habracut"></a><br><h2>  Defina os termos </h2><br>  Sup√µe-se ainda que estamos lidando com as arquiteturas Intel 64 e IA-32. <br><br>  Para determinar inequivocamente o que decidimos construir, teremos que lidar com mais detalhes com o funcionamento das fases individuais da opera√ß√£o BIOS / UEFI. <br><br>  Se voc√™ observar cuidadosamente os tipos de arquivo apresentados nos volumes de firmware do <abbr title="Sistema de arquivos de firmware">FFS</abbr> , a maioria dos arquivos existentes inclui uma se√ß√£o com m√≥dulos execut√°veis. <br><br>  Mesmo se considerarmos o novo firmware da ASUS ou ASRock, no qual voc√™ pode encontrar facilmente at√© meia centena de arquivos do tipo EFI_FV_FILETYPE_FREEFORM contendo imagens de diferentes formatos, no entanto, mesmo nesses firmwares, existem mais arquivos execut√°veis ‚Äã‚Äãdo que arquivos de outros tipos. <br><br><pre><code class="plaintext hljs">+--------------------------------------------------------------------------+ | File Types Information | +--------------------------------------------------------------------------+ | EFI_FV_FILETYPE_RAW = 6 | | EFI_FV_FILETYPE_FREEFORM = 83 | | EFI_FV_FILETYPE_SECURITY_CORE = 1 | | EFI_FV_FILETYPE_PEI_CORE = 1 | | EFI_FV_FILETYPE_DXE_CORE = 1 | | EFI_FV_FILETYPE_PEIM = 57 | | EFI_FV_FILETYPE_DRIVER = 196 | | EFI_FV_FILETYPE_APPLICATION = 1 | | EFI_FV_FILETYPE_SMM = 60 | | EFI_FV_FILETYPE_SMM_CORE = 1 | | EFI_FV_FILETYPE_PAD = 4 | +--------------------------------------------------------------------------+ | Total Files : = 411 | +--------------------------------------------------------------------------+</code> </pre>  <b>Um exemplo da composi√ß√£o de algum firmware comum (comum).</b> <br><br>  Embora os arquivos que cont√™m m√≥dulos execut√°veis ‚Äã‚Äãn√£o estejam marcados nesta tabela, eles (por defini√ß√£o) estar√£o todos nesta lista, exceto os arquivos com os sufixos RAW, FREEFORM e PAD. <br><br>  Arquivos com o sufixo "CORE" (SECURITY_CORE, PEI_CORE e DXE_CORE) s√£o os "kernels" correspondentes (m√≥dulos principais da fase correspondente) que recebem o controle de outras fases (ou ap√≥s o in√≠cio), SMM_CORE √© uma sub-fase da fase DXE e √© chamada durante ela. realiza√ß√£o.  O APLICATIVO pode ser realizado apenas a pedido do usu√°rio, n√£o possui uma liga√ß√£o espec√≠fica √†s fases. <br><br>  Os tipos de arquivos mais comuns n√£o foram listados: PEIM (m√≥dulos de fase PEI), DRIVER (m√≥dulos de fase DXE) e SMM (m√≥dulos de sub-fase DXE).  Os m√≥dulos CORE das fases PEI e DXE incluem um despachante, que controla a sequ√™ncia dos m√≥dulos de carregamento / partida da fase correspondente. <br><br>  No exemplo acima, n√£o h√° op√ß√µes combinadas, n√£o nos lembraremos delas: embora elas sejam encontradas em firmware real, √© bastante raro.  Aqueles que desejam receber informa√ß√µes mais detalhadas e detalhadas s√£o convidados a consultar os artigos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">CodeRush</a> .  E tamb√©m cite seu conselho: "Para os f√£s da documenta√ß√£o original, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a especifica√ß√£o UEFI PI est√°</a> sempre dispon√≠vel, tudo √© descrito com muito mais detalhes". <br><br>  Cada m√≥dulo de firmware execut√°vel √© um m√≥dulo de formato PE + (Portable Executable) ou seu derivado (Terse Executable: formato TE).  O m√≥dulo execut√°vel no formato PE + √© um conjunto de dados estruturados "levemente", contendo as informa√ß√µes necess√°rias ao carregador para mapear esse m√≥dulo na mem√≥ria. <br><br>  O pr√≥prio formato PE + (estrutura) n√£o possui nenhum mecanismo de intera√ß√£o entre os m√≥dulos individuais PE +.  Cada m√≥dulo execut√°vel ap√≥s o carregamento e o in√≠cio da execu√ß√£o √© um processo aut√¥nomo independente <b>(bem, deve ser assim!)</b> , Ou seja,  o m√≥dulo n√£o deve "assumir" nada sobre o que est√° sendo feito fora dele. <br><br>  A organiza√ß√£o da intera√ß√£o entre m√≥dulos execut√°veis ‚Äã‚Äãseparados de uma fase UEFI √© organizada por meio do m√≥dulo CORE da fase correspondente.  M√≥dulos execut√°veis ‚Äã‚Äãindividuais podem definir (Instalar) protocolos, solicitar (Localizar) e usar protocolos declarados por outros m√≥dulos, definir / declarar eventos e declarar (Notificar) manipuladores de eventos. <br><br>  Portanto, para cada m√≥dulo de firmware execut√°vel, estamos interessados ‚Äã‚Äãna presen√ßa dos seguintes artefatos: <br><br><ol><li>  Lista de protocolos que este m√≥dulo define.  (Cada protocolo √© identificado por um n√∫mero √∫nico - guia). </li><li>  Lista de protocolos que este m√≥dulo usa (tenta usar). </li><li>  Lista de eventos que este m√≥dulo anuncia.  (O evento possui um n√∫mero √∫nico - guia). </li><li>  Uma lista de manipuladores de eventos presentes (implementados e podem ser instalados / inicializados) neste m√≥dulo. </li></ol><blockquote>  <i><u>Um gr√°fico de depend√™ncia est√°tica</u></i> para uma determinada fase BIOS / UEFI √© considerado definido se, para cada m√≥dulo de fase execut√°vel, conhecermos todos os artefatos listados acima nas se√ß√µes 1-4.  (Em outras palavras, se tivermos definido todas as informa√ß√µes que descrevem as interdepend√™ncias entre os m√≥dulos). </blockquote>  Consideraremos apenas a op√ß√£o de an√°lise est√°tica, isso significa que alguns elementos do c√≥digo que implementam os itens 1-4 podem ser inating√≠veis (s√£o fragmentos do c√≥digo "morto") ou ser√£o alcan√ß√°veis ‚Äã‚Äãapenas com determinadas op√ß√µes para dados / par√¢metros de entrada. <br><br>  Tudo o que consideramos at√© agora √© baseado apenas na especifica√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BIOS / UEFI</a> .  E, para entender os ‚Äúrelacionamentos‚Äù dos m√≥dulos execut√°veis ‚Äã‚Äãexistentes do firmware em quest√£o, teremos que nos aprofundar em sua estrutura, o que significa que devemos revert√™-los pelo menos parcialmente (restaurar os algoritmos originais). <br><br>  Como j√° mencionado acima, o m√≥dulo execut√°vel no formato PE + √© apenas um conjunto de estruturas para o carregador, construindo na mem√≥ria um objeto para o qual o controle ser√° transferido, e esse objeto, por sua natureza, consiste em instru√ß√µes do processador e dados para essas instru√ß√µes. <br><blockquote>  Diremos que uma <i><u>desmontagem completa do</u></i> m√≥dulo execut√°vel foi feita se fosse poss√≠vel resolver o problema de separar os comandos e dados apresentados neste m√≥dulo. </blockquote>  Ao mesmo tempo, n√£o impomos nenhum requisito √† estrutura e aos tipos de dados, basta que, para cada byte pertencente √† imagem do m√≥dulo execut√°vel recebido pelo carregador, possamos dizer claramente a qual das duas categorias pertence: byte de comando ou byte de dados. <br><br>  A tarefa de <i><u>desmontar completamente o</u></i> pr√≥prio m√≥dulo execut√°vel geralmente n√£o √© trivial; al√©m disso, no caso geral, √© algoritmicamente insol√∫vel.  N√£o entraremos em detalhes desta quest√£o, nem romperemos as lan√ßas, consideramos essa afirma√ß√£o como um axioma. <br><br>  Suponha: <br><br><ol><li>  J√° resolvemos o problema da <i><u>desmontagem completa</u></i> de um m√≥dulo de execu√ß√£o BIOS / UEFI espec√≠fico, ou seja,  conseguimos separar comandos e dados. </li><li>  Existe o c√≥digo fonte do m√≥dulo na linguagem "C" (no firmware atual BIOS / UEFI, os m√≥dulos s√£o desenvolvidos principalmente apenas na linguagem "C"). </li></ol><br>  Mesmo neste caso, simplesmente comparar os resultados obtidos (o texto do assembler √© apenas uma representa√ß√£o textual das instru√ß√µes do processador) com o c√≥digo-fonte na linguagem ‚ÄúC‚Äù exigir√° quase sempre boa experi√™ncia / qualifica√ß√£o, com exce√ß√£o de casos absolutamente degenerados. <br><br>  Um estudo completo de exemplos mostrando dificuldades na identifica√ß√£o ou compara√ß√£o dos resultados da desmontagem com o c√≥digo fonte n√£o faz parte dos nossos planos atuais. <br>  Vamos considerar apenas um exemplo quando, na lista do assembler, encontramos o comando <b>"Indirect Call"</b> - uma chamada de procedimento impl√≠cita. <br><br>  Este √© um exemplo de uma chamada de procedimento referenciada em uma tabela.  Uma tabela contendo links para v√°rios procedimentos √© um caso t√≠pico de implementa√ß√£o da apresenta√ß√£o de interfaces de um protocolo arbitr√°rio. <br><br>  Essa tabela n√£o precisa consistir apenas de refer√™ncias a procedimentos; ningu√©m pro√≠be o armazenamento de dados arbitr√°rios nessa estrutura (e este √© um exemplo de uma estrutura "C" t√≠pica). <br><br>  Aqui est√° uma forma de chamada (em vez do registro ecx, quase todas as variantes dos registradores de processador de 32 bits s√£o poss√≠veis): <br><blockquote>  FF 51 18 chama o dword ptr [ecx + 18h] </blockquote>  Tendo obtido, ap√≥s an√°lise, um comando semelhante, √© poss√≠vel descobrir que tipo de procedimento est√° sendo chamado, uma lista de seus par√¢metros, o tipo e o valor do resultado retornado, s√≥ √© poss√≠vel se conhecermos o tipo de objeto (protocolo) cuja interface √© chamada por este comando. <br><br>  Se sabemos que no exemplo anterior o registro "ecx" cont√©m um ponteiro (o endere√ßo do in√≠cio da tabela EFI_PEI_SERVICES), podemos receber (apresentar) esse comando da seguinte maneira mais compreens√≠vel e "agrad√°vel": <blockquote>  Chamada FF 51 18 [exx + EFI_PEI_SERVICES.InstallPpi] </blockquote>  A obten√ß√£o de informa√ß√µes sobre o conte√∫do do registro que participa do comando <b>"Chamada indireta"</b> costuma ir al√©m dos recursos de um desmontador "t√≠pico", cuja tarefa √© simplesmente analisar e converter o c√≥digo bin√°rio do processador em uma forma leg√≠vel por humanos - uma representa√ß√£o textual do comando do processador correspondente. <br><br>  Para resolver esse problema, geralmente √© necess√°rio o uso de informa√ß√µes adicionais (Meta) que n√£o est√£o dispon√≠veis no m√≥dulo execut√°vel bin√°rio (perdidas como resultado da compila√ß√£o e vincula√ß√£o - √© usado nas transforma√ß√µes de uma representa√ß√£o do algoritmo para outra, mas o processador n√£o precisa mais executar os comandos recebidos). <br><br>  Se esses metadados ainda estiverem dispon√≠veis a partir de fontes adicionais, usando-os e realizando an√°lises adicionais, obteremos uma representa√ß√£o mais compreens√≠vel (e mais precisa) do comando <b>"Chamada indireta"</b> . <br><br>  De fato, essa an√°lise avan√ßada j√° lembra mais o processo de "descompila√ß√£o", embora o resultado n√£o se pare√ßa com o c√≥digo-fonte do m√≥dulo na linguagem "C", no entanto, no futuro, nos referiremos a esse processo como <i>descompila√ß√£o de comandos que s√£o <b>"chamada indireta"</b></i> ou <i>" descompila√ß√£o parcial</i> . <br><br>  Portanto, estamos prontos para determinar as condi√ß√µes suficientes para construir o gr√°fico da interdepend√™ncia dos m√≥dulos de firmware execut√°vel para a fase BIOS / UEFI especificada: <br><blockquote>  Para obter um <u><i>gr√°fico de depend√™ncia est√°tica</i></u> (qualquer uma das fases - PEI ou DXE), √© <b><i>suficiente</i></b> desmontar completamente todos os m√≥dulos execut√°veis ‚Äã‚Äãda fase correspondente (pelo menos separar todos os comandos) e descompilar os comandos <b>"Chamada indireta"</b> presentes nos m√≥dulos desmontados. </blockquote>  H√° imediatamente muitas perguntas sobre como o nosso conhecimento das equipes de <b>"Chamada indireta"</b> est√° conectado √†s intera√ß√µes entre m√≥dulos. <br>  Como mencionado acima, todo o servi√ßo de gerenciamento de intera√ß√£o √© fornecido pelo m√≥dulo "CORE" da fase correspondente, e os servi√ßos nas fases s√£o projetados como tabelas de servi√ßo "b√°sicas". <br><br>  Como os modelos de intera√ß√£o entre os m√≥dulos nas fases PEI e DXE, embora ideologicamente (estruturalmente) semelhantes, ainda sejam tecnicamente diferentes, prop√µe-se passar de algumas considera√ß√µes formais para considerar uma constru√ß√£o direta espec√≠fica de um <u><i>Gr√°fico de Depend√™ncia Est√°tica</i></u> para a fase PEI. <br><br>  Poderemos at√© determinar e formular as condi√ß√µes <b><i>necess√°rias e suficientes</i></b> para a possibilidade de construir um <u><i>gr√°fico de depend√™ncia est√°tica</i></u> para a fase PEI. <br><br><h2>  Construindo um <i><u>gr√°fico de depend√™ncia est√°tica</u></i> para a fase PEI </h2><br>  Descri√ß√µes da solu√ß√£o para o problema da <u><i>desmontagem completa de</i></u> m√≥dulos execut√°veis ‚Äã‚Äãda fase PEI e descompila√ß√£o dos comandos de <b>chamada indireta</b> presentes nesses m√≥dulos est√£o al√©m do escopo de nossa hist√≥ria e n√£o ser√£o divulgadas - a apresenta√ß√£o desse material em volume pode exceder o tamanho dessa obra. <br><br>  √â poss√≠vel que com o tempo isso aconte√ßa como um material separado, mas por enquanto - saiba como. <br><br>  Observamos apenas que o uso de metadados, al√©m da presen√ßa de uma certa estrutura para a constru√ß√£o de c√≥digo bin√°rio, possibilita na pr√°tica <i><u>desmontar completamente</u></i> os m√≥dulos execut√°veis ‚Äã‚ÄãBIOS / UEFI.  Prova formal desse fato n√£o √© suposta agora ou no futuro.  Pelo menos na an√°lise / processamento de mais de cem (100) BIOS / UEFI de v√°rios fabricantes, n√£o havia exemplos em que <i><u>a desmontagem completa</u></i> n√£o <i><u>fosse</u></i> poss√≠vel. <br><br>  Al√©m disso, apenas resultados espec√≠ficos (com explica√ß√µes: o que, como e quanto ...). <br><br>  A estrutura EFI_PEI_SERVICES √© a estrutura b√°sica da fase PEI, que √© passada como par√¢metro para o ponto de entrada de cada m√≥dulo PEI e cont√©m links para os servi√ßos b√°sicos necess√°rios para o funcionamento dos m√≥dulos PEI. <br><br>  Estaremos interessados ‚Äã‚Äãapenas nos campos localizados no in√≠cio da estrutura: <br><br><img src="https://habrastorage.org/webt/w_/iz/_m/w_iz_mocpact66z4c382r0o53zc.png"><br><br>  <b>Um fragmento de uma estrutura real do tipo EFI_PEI_SERVICES no desmontador do IDA Pro.</b> <br><br>  E √© assim que aparece no c√≥digo-fonte na linguagem "C" (lembre-se, isso √© apenas um fragmento da estrutura): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EFI_PEI_SERVICES</span></span></span><span class="hljs-class"> {</span></span> EFI_TABLE_HEADER Hdr; EFI_PEI_INSTALL_PPI InstallPpi; EFI_PEI_REINSTALL_PPI ReInstallPpi; EFI_PEI_LOCATE_PPI LocatePpi; EFI_PEI_NOTIFY_PPI NotifyPpi; <span class="hljs-comment"><span class="hljs-comment">//...      ... };</span></span></code> </pre> <br>  No in√≠cio da estrutura EFI_PEI_SERVICES, como em todas as tabelas de servi√ßo "b√°sicas" (tabelas de servi√ßos), est√° a estrutura EFI_TABLE_HEADER.  Os valores apresentados nesta estrutura de cabe√ßalho nos permitem afirmar inequivocamente que, se a pr√≥pria estrutura EFI_PEI_SERVICES est√° realmente presente no fragmento do desmontador (consulte o campo "Hdr.Signature"), pelo menos o modelo dessa estrutura! <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EFI_TABLE_HEADER</span></span></span><span class="hljs-class"> {</span></span> UINT64 Signature; UINT32 Revision; UINT32 HeaderSize; UINT32 CRC32; UINT32 Reserved; };</code> </pre> <br>  Ao longo do caminho, podemos estabelecer que o firmware estava sendo desenvolvido no momento em que a vers√£o da especifica√ß√£o UEFI PI era 1.2, cujo per√≠odo de relev√¢ncia foi de 2009 a 2013, mas, no momento (in√≠cio de 2019), a vers√£o atual da especifica√ß√£o j√° havia crescido (literalmente aumentado no outro dia). para a vers√£o 1.7. <br><br>  No campo "Hdr.HeaderSize", pode-se determinar que o comprimento total da estrutura √© 78h (e esse n√£o √© o comprimento do cabe√ßalho, como o nome indica, mas o comprimento de toda a estrutura de EFI_PEI_SERVICES). <br><br>  As interfaces EFI_PEI_SERVICES s√£o divididas em 7 categorias / classes.  Apenas as listamos: <br><br><ol><li>  Servi√ßos PPI. </li><li>  Servi√ßos do modo de inicializa√ß√£o. </li><li>  Servi√ßos HOB. </li><li>  Servi√ßos de volume de firmware. </li><li>  Servi√ßos de mem√≥ria PEI. </li><li>  Servi√ßos de c√≥digo de status. </li><li>  Redefinir servi√ßos. </li></ol><br>  Toda a narra√ß√£o adicional estar√° diretamente relacionada aos procedimentos pertencentes √† categoria / classe de Servi√ßos PPI, destinados √† organiza√ß√£o da intera√ß√£o entre m√≥dulos dos m√≥dulos execut√°veis ‚Äã‚Äãda fase PEI. <br><br>  E h√° apenas quatro para a fase PEI. <br><br>  Em geral, n√£o h√° necessidade de adivinhar o objetivo de cada uma das interfaces: a funcionalidade √© completamente determinada pelo nome da interface, todos os detalhes est√£o na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especifica√ß√£o</a> . <br><br>  A seguir, est√£o os prot√≥tipos desses procedimentos: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_INSTALL_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *PpiList)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_REINSTALL_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *OldPpi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *NewPpi)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_LOCATE_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_GUID *Guid, UINTN Instance, EFI_PEI_PPI_DESCRIPTOR **PpiDescriptor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **Ppi)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_NOTIFY_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_NOTIFY_DESCRIPTOR *NotifyList)</span></span></span></span>;</code> </pre> <br>  Observamos apenas que, al√©m dos comandos <b>"Chamada indireta"</b> que invocam os procedimentos / interfaces da classe "Servi√ßos PPI", √© poss√≠vel uma chamada expl√≠cita (direta - n√£o tabular) a esses procedimentos, o que √†s vezes acontece nos m√≥dulos executivos, onde a estrutura EFI_PEI_SERVICES √© definida / criada. <br><br>  Vou lhe contar um pequeno segredo: estranhamente, embora essa seja a tabela de servi√ßos "b√°sica" para a fase PEI, no entanto, como mostra a pr√°tica, ela pode ser definida n√£o apenas no m√≥dulo PEI_CORE. <br><br>  Na natureza real, existem firmwares nos quais a estrutura EFI_PEI_SERVICES foi definida / formada e usada em v√°rios m√≥dulos, e essas n√£o foram de forma alguma c√≥pias do m√≥dulo PEI_CORE. <br><br>  Assim, as seguintes op√ß√µes de c√≥digo s√£o poss√≠veis: <br><br><pre> <code class="cpp hljs">seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>0D B8 <span class="hljs-number"><span class="hljs-number">8</span></span>C A6 <span class="hljs-number"><span class="hljs-number">78</span></span>+ mov eax, offset ppiList_78A68C seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>12 <span class="hljs-number"><span class="hljs-number">50</span></span> push eax ; PpiList seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>13 <span class="hljs-number"><span class="hljs-number">57</span></span> push edi ; PeiServices seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>14 <span class="hljs-number"><span class="hljs-number">89</span></span> <span class="hljs-number"><span class="hljs-number">86</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>E+ mov [esi+<span class="hljs-number"><span class="hljs-number">0E40</span></span>h], eax seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>1A E8 <span class="hljs-number"><span class="hljs-number">70</span></span> FC FF+ call InstallPpi</code> </pre> <br>  <b>Um exemplo de uma chamada expl√≠cita para o procedimento "InstallPpi".</b> <br><br><pre> <code class="cpp hljs">seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBB <span class="hljs-number"><span class="hljs-number">8B</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>D FC mov ecx, [ebp+PeiServices] seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBE <span class="hljs-number"><span class="hljs-number">50</span></span> push eax ; PpiList seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBF C7 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>+ mov dword ptr [eax], <span class="hljs-number"><span class="hljs-number">80000010</span></span>h seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CC5 C7 <span class="hljs-number"><span class="hljs-number">43</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>C A8+ mov dword ptr [ebx+<span class="hljs-number"><span class="hljs-number">3</span></span>Ch], offset guid_78A9A8 seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCC <span class="hljs-number"><span class="hljs-number">8B</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> mov edx, [ecx] seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCE <span class="hljs-number"><span class="hljs-number">51</span></span> push ecx ; PeiServices seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCF FF <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call [edx+EFI_PEI_SERVICES.InstallPpi]</code> </pre> <br>  <b>Um exemplo de uma chamada impl√≠cita para a interface InstallPpi.</b> <br><br><pre> <code class="cpp hljs">FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">18</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call [ex+EFI_PEI_SERVICES.InstallPpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">1</span></span>Ch] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>C call [ex+EFI_PEI_SERVICES.ReInstallPpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">20</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> call [ex+EFI_PEI_SERVICES.LocatePpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">24</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> call [ex+EFI_PEI_SERVICES.NotifyPpi]</code> </pre>  <b>Exemplos de chamadas impl√≠citas da interface antes e depois da autentica√ß√£o.</b> <br><br>  Observamos um recurso caracter√≠stico: no caso da fase PEI para a arquitetura IA-32, as interfaces da classe Servi√ßos PPI t√™m deslocamentos de 18h, 1Ch, 20h e 24h. <br><br>  E agora declaramos a seguinte declara√ß√£o: <br><blockquote>  Para criar um <u><i>gr√°fico de depend√™ncia est√°tica da</i></u> fase PEI, <b>√© necess√°rio e suficiente</b> <u><i>desmontar completamente</i></u> todos os m√≥dulos execut√°veis ‚Äã‚Äãda fase (pelo menos separar todos os comandos) e descompilar os comandos <b>"Chamada Indireta"</b> com os desvios 18h, 1Ch, 20h, 24h nos m√≥dulos desmontados. </blockquote>  De fato, formulamos completamente um algoritmo para resolver o problema e, assim que conseguimos isolar todas as chamadas para as interfaces / procedimentos da classe PPI Services, resta apenas determinar quais par√¢metros s√£o passados ‚Äã‚Äãpara essas chamadas.  A tarefa pode n√£o ser a mais trivial, mas, como a pr√°tica demonstrou, √© completamente solucion√°vel, temos todos os dados para isso. <br><br>  E agora exemplos reais de dados reais para m√≥dulos reais da fase PEI.  N√£o indicamos conscientemente quais resultados de BIOS / UEFI da empresa foram obtidos, apenas d√™ exemplos de como eles se parecem. <br><br><h2>  Dois exemplos de descri√ß√µes de m√≥dulos PEIM com informa√ß√µes completas sobre o uso das interfaces de Servi√ßos PPI nesses m√≥dulos </h2><br><pre> <code class="plaintext hljs"> -- File 04-047/0x02F/: "TcgPlatformSetupPeiPolicy" : [007CCAF0 - 007CD144] DEPENDENCY_START EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI DEPENDENCY_END Install Protocols: [1] TCG_PLATFORM_SETUP_PEI_POLICY Locate Protocols: [2] EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI</code> </pre><pre> <code class="plaintext hljs">-- File 04-048/0x030/: "TcgPei" : [007CD160 - 007CF5DE] DEPENDENCY_START EFI_PEI_MASTER_BOOT_MODE_PEIM_PPI EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI AND DEPENDENCY_END Install Protocols: [1] AMI_TCG_PLATFORM_PPI [2] EFI_PEI_TCG_PPI [2] PEI_TPM_PPI Locate Protocols: [1] EFI_PEI_TCG_PPI [1] EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI [1] TCG_PLATFORM_SETUP_PEI_POLICY [5] PEI_TPM_PPI Notify Events: [1] AMI_TCM_CALLBACK ReInstall Protocols: [1] PEI_TPM_PPI</code> </pre><br><h2>  Lista de protocolos por tipos de interfaces nas quais eles foram usados </h2><br>  Abaixo, nos spoilers, h√° exemplos abreviados de listas de protocolos PPIM para cada uma das interfaces da classe Servi√ßos PPI. <br><br>  O formato das listas √© o seguinte: <br><pre> |  n√∫mero de s√©rie |  name_PPI |  guid_PPI |  executable_name: nome de usu√°rio |
</pre><br><div class="spoiler">  <b class="spoiler_title">***** Instale 99 ppi no "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/kl/o_/-q/klo_-qpqz-m_lokouctilmlnbxw.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Localize 194 Ppi em "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_i/bl/30/_ibl301bqdkcqk33z-i7ifzqejk.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Reinstale o 5 Ppi no "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/7g/pe/xb/7gpexbxvf_k4sla038anu32el7s.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Notifique 29 Ppi em "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ui/fj/m6/uifjm6sznoctafiav_4cez64ezc.png"><br></div></div><br><h2>  A lista final de todos os guias dos protocolos mencionados em um BIOS / UEFI espec√≠fico com uma legenda indicando em quais "Servi√ßos PPI" esses protocolos s√£o encontrados </h2><br>  Abaixo est√° uma lista de spoilers de 97 PPi-guids encontrados e usados ‚Äã‚Äãexplicitamente em um firmware espec√≠fico, cujos dados foram fornecidos anteriormente. <br><br>  Cada item da lista √© precedido por uma legenda, que reflete todos os tipos de uso de um protocolo espec√≠fico. <br><br><pre> <code class="plaintext hljs">"D" - in DEPENDENCY section used "I" - in "InstallPpi" functions used "L" - in "LocatePpi" functions used "R" - in "ReInstallPpi" functions used "N" - in "NotifyPpi" functions used</code> </pre><br><div class="spoiler">  <b class="spoiler_title">***** Listar Ppi em "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wn/cm/8y/wncm8ymfrh-8oxdssbu0kuazejc.png"><br><img src="https://habrastorage.org/webt/t1/sn/xq/t1snxq4jhzprqvwoq93ithtlfow.png"><br><img src="https://habrastorage.org/webt/y1/tg/mz/y1tgmz0bysbuzmszkope_hegfoa.png"><br></div></div><br>  Os seguintes intervalos da lista de protocolos s√£o dignos de nota neste BIOS / UEFI: <br><br><ol><li>  No. 38-50. <br>  Definindo protocolos / eventos (InstallPpi) que n√£o s√£o usados ‚Äã‚Äãpor nenhum m√≥dulo. </li><li>  87-95. <br>  Tente solicitar protocolos que n√£o foram instalados por nenhum m√≥dulo deste firmware. <br></li><li>  No. 96-97. <br>  Dois eventos ‚ÄúNotify‚Äù, para os quais nenhum m√≥dulo se preocupou em declarar a interface correspondente, respectivamente, embora esses procedimentos sejam declarados em m√≥dulos execut√°veis, eles nunca funcionar√£o. </li></ol><br><h2>  Conclus√£o </h2><br><ul><li>  Resultados semelhantes aos acima foram obtidos para BIOS / UEFI de v√°rios fabricantes, raz√£o pela qual todos os exemplos s√£o an√¥nimos. </li><li>  De fato, foram resolvidas tarefas mais gerais de reverter os algoritmos dos m√≥dulos execut√°veis ‚Äã‚ÄãBIOS / UEFI, e o gr√°fico resultante √© um resultado colateral, uma esp√©cie de b√¥nus adicional. </li><li><blockquote>  A solu√ß√£o correta da tarefa <i><u>"Obtendo gr√°fico de depend√™ncia est√°tica"</u></i> para m√≥dulos execut√°veis ‚Äã‚ÄãBIOS / UEFI requer uma an√°lise est√°tica do c√≥digo bin√°rio, que inclui a <i><u>desmontagem completa dos</u></i> m√≥dulos execut√°veis ‚Äã‚Äãe <i><u>a descompila√ß√£o parcial dos</u></i> comandos de <b>chamada indireta</b> desses m√≥dulos. </blockquote></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440052/">https://habr.com/ru/post/pt440052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440040/index.html">Em desenvolvimento - cada um por si. Mas √†s vezes isso leva a um beco sem sa√≠da.</a></li>
<li><a href="../pt440044/index.html">Hist√≥rico detalhado da Qualcomm</a></li>
<li><a href="../pt440046/index.html">Li√ß√£o aberta "Criando clientes REST no Spring"</a></li>
<li><a href="../pt440048/index.html">M√©tricas favoritas: 5 indicadores que toda equipe de vendas deve seguir</a></li>
<li><a href="../pt440050/index.html">Proxies DNS do tipo Fa√ßa Voc√™ Mesmo no Node.JS</a></li>
<li><a href="../pt440054/index.html">Transferir servi√ßo da web para o Yandex.Cloud com a AWS</a></li>
<li><a href="../pt440058/index.html">Relat√≥rio de problemas e disponibilidade da Internet 2018‚Äì2019</a></li>
<li><a href="../pt440060/index.html">TensorFlow no Apache Ignite</a></li>
<li><a href="../pt440062/index.html">Planejando com prazer. Como configuramos processos sem gerentes</a></li>
<li><a href="../pt440064/index.html">Data centers √† sua escolha: Londres, Moscou, Zurique, S√£o Petersburgo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>