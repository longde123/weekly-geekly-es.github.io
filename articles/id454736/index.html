<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèº‚Äçü§ù‚Äçüßëüèº üçø ‚úåÔ∏è Dukungan Visual Studio 2019 di PVS-Studio ü§≤ üìü ü§æüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dukungan Visual Studio 2019 di PVS-Studio memengaruhi sejumlah komponen: plugin itu sendiri, penganalisa baris perintah, inti dari penganalisa C ++ da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dukungan Visual Studio 2019 di PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/454736/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de3/aea/16e/de3aea16e3b6472a4d5034fd035d8827.png"></div><br>  Dukungan Visual Studio 2019 di PVS-Studio memengaruhi sejumlah komponen: plugin itu sendiri, penganalisa baris perintah, inti dari penganalisa C ++ dan C #, dan beberapa utilitas.  Pada artikel ini, saya akan menjelaskan secara singkat masalah apa yang kami temui ketika menerapkan dukungan IDE dan bagaimana kami mengatasinya. <br><a name="habracut"></a><br>  Sebelum kita mulai, saya ingin melihat kembali sejarah mendukung versi Visual Studio sebelumnya di PVS-Studio sehingga Anda lebih memahami visi tugas dan solusi yang kami buat dalam setiap situasi. <br><br>  Sejak versi pertama PVS-Studio yang dikirimkan bersama dengan plugin untuk Visual Studio (saat itu Visual Studio 2005), mendukung versi baru dari IDE ini merupakan tugas yang sangat sepele bagi kami, yang pada dasarnya turun untuk memperbarui proyek plugin. file dan dependensi dari berbagai ekstensi API Visual Studio.  Sesekali kita harus menambahkan dukungan untuk fitur-fitur baru C ++, yang secara bertahap dipelajari oleh kompiler Visual C ++ untuk bekerja dengannya, tetapi umumnya itu bukan tugas yang sulit juga dan dapat dengan mudah dilakukan tepat sebelum rilis Visual Studio baru .  Selain itu, PVS-Studio hanya memiliki satu alat analisa saat itu - untuk C / C ++. <br><br>  Banyak hal berubah ketika Visual Studio 2017 dirilis.  Selain perubahan besar pada banyak ekstensi API IDE, kami juga mengalami masalah dengan mempertahankan kompatibilitas mundur penganalisis C # baru yang ditambahkan sesaat sebelum itu (serta lapisan penganalisis baru untuk C ++ untuk bekerja dengan proyek MSBuild) dengan versi baru MSBuild \ Visual Studio. <br><br>  Mempertimbangkan semua ini, saya sangat menyarankan Anda melihat artikel terkait tentang dukungan Visual Studio 2017, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dukungan Visual Studio 2017 dan Roslyn 2.0 di PVS-Studio: kadang-kadang tidak mudah untuk menggunakan solusi yang sudah jadi karena tampaknya</a> ", sebelum membaca.  Artikel itu membahas masalah yang kami hadapi terakhir kali dan model interaksi antara berbagai komponen (seperti PVS-Studio, MSBuild, dan Roslyn).  Mengetahui detail ini dapat membantu Anda lebih memahami artikel saat ini. <br><br>  Mengatasi masalah tersebut pada akhirnya mengarah pada perubahan signifikan pada penganalisa, dan kami berharap bahwa pendekatan baru yang diterapkan kemudian akan membantu kami mendukung versi Visual Studio \ MSBuild yang akan datang lebih mudah dan lebih cepat.  Harapan ini sudah mulai terbukti realistis karena banyak pembaruan Visual Studio 2017 dirilis.  Apakah pendekatan baru membantu kami dalam mendukung Visual Studio 2019?  Baca terus untuk mengetahui. <br><br><h2>  Plugin PVS-Studio untuk Visual Studio 2019 </h2><br>  Awal mulanya tampak menjanjikan.  Kami tidak butuh banyak upaya untuk port plugin ke Visual Studio 2019 dan membuatnya diluncurkan dan berjalan dengan baik.  Tapi kami sudah menemui dua masalah sekaligus yang bisa membawa lebih banyak masalah nanti. <br><br>  Yang pertama berkaitan dengan antarmuka <i>IVsSolutionWorkspaceService yang</i> digunakan untuk mendukung mode Beban Solusi Ringan (yang, bagaimanapun, telah dinonaktifkan di salah satu pembaruan sebelumnya, kembali di Visual Studio 2017).  Itu dihiasi dengan atribut <i>usang</i> , yang saat ini hanya memicu peringatan saat membangun tetapi akan menjadi masalah besar di masa depan.  Mode ini tidak bertahan lama memang ... Itu mudah diperbaiki - kami hanya berhenti menggunakan antarmuka ini. <br><br>  Masalah kedua adalah pesan berikut yang kami dapatkan saat memuat Visual Studio dengan plugin diaktifkan: <i>Visual Studio telah mendeteksi satu atau lebih ekstensi yang berisiko atau tidak berfungsi dalam pembaruan fitur VS.</i> <br><br>  Log peluncuran Visual Studio (file ActivityLog) membantu menjernihkannya: <br><br>  <i>Peringatan: Ekstensi 'PVS-Studio' menggunakan fitur 'auto-load sinkron' dari Visual Studio.</i>  <i>Fitur ini tidak lagi didukung dalam pembaruan Visual Studio 2019 di masa depan, di mana ekstensi ini tidak akan berfungsi.</i>  <i>Silakan hubungi vendor ekstensi untuk mendapatkan pembaruan.</i> <br><br>  Apa artinya bagi kami adalah bahwa kami harus beralih dari mode beban sinkron ke asinkron.  Saya harap Anda tidak akan keberatan jika saya memberi Anda detail tentang bagaimana kami berinteraksi dengan antarmuka COM Visual Studio, dan hanya menjelaskan perubahan secara singkat. <br><br>  Ada sebuah artikel oleh Microsoft tentang memuat plugin secara tidak serempak: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara: Gunakan AsyncPackage untuk memuat VSPackages di latar belakang</a> ".  Namun, sudah jelas bahwa ada lebih banyak perubahan yang akan terjadi. <br><br>  Salah satu perubahan terbesar adalah pada mode pemuatan, atau lebih tepatnya mode inisialisasi.  Pada versi sebelumnya, semua inisialisasi yang diperlukan dilakukan dengan menggunakan dua metode: <i>Inisialisasi</i> kelas kita yang diwarisi dari <i>Package</i> , dan <i>OnShellPropertyChange</i> .  Yang terakhir harus ditambahkan karena ketika memuat secara bersamaan, Visual Studio itu sendiri mungkin masih dalam proses memuat dan inisialisasi, dan, oleh karena itu, beberapa tindakan yang diperlukan tidak mungkin dilakukan selama inisialisasi plugin.  Salah satu cara untuk memperbaikinya adalah dengan menunda eksekusi tindakan tersebut hingga Visual Studio keluar dari status 'zombie'.  Ini bagian dari logika yang kami <i>pilih</i> ke dalam metode <i>OnShellPropertyChange</i> dengan memeriksa status 'zombie'. <br><br>  Metode <i>Inisialisasi</i> kelas abstrak <i>AsyncPackage</i> , yang secara asinkron memuat plugin, <i>disegel</i> , jadi inisialisasi harus dilakukan dalam metode yang diganti, <i>InitializeAsync</i> , yang persis seperti yang kami lakukan.  Logika pemeriksaan 'zombie' juga harus diubah karena informasi status tidak lagi tersedia untuk plugin kami.  Selain itu, kami masih harus melakukan tindakan-tindakan yang harus dilakukan setelah inisialisasi plugin.  Kami memecahkan itu dengan menggunakan metode <i>OnPackageLoaded</i> dari antarmuka <i>IVsPackageLoadEvents</i> , yang merupakan tempat tindakan tertunda itu dilakukan. <br><br>  Masalah lain yang dihasilkan dari asynchronous load adalah bahwa perintah plugin tidak dapat digunakan sampai setelah Visual Studio dimuat.  Membuka log penganalisa dengan mengklik dua kali pada file manager (jika Anda perlu membukanya dari Visual Studio) menghasilkan meluncurkan versi yang sesuai dari devenv.exe dengan perintah untuk membuka log.  Perintah peluncuran terlihat seperti ini: <br><br><pre><code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\Common7\IDE\devenv.exe"</span></span> /command <span class="hljs-string"><span class="hljs-string">"PVSStudio.OpenAnalysisReport C:\Users\vasiliev\source\repos\ConsoleApp\ConsoleApp.plog"</span></span></code> </pre> <br>  Bendera "/ perintah" digunakan di sini untuk menjalankan perintah yang terdaftar di Visual Studio.  Pendekatan ini tidak berfungsi lagi karena perintah tidak lagi tersedia sampai setelah plugin dimuat.  Solusi yang kami temukan adalah membuat perintah peluncuran devenv.exe diuraikan setelah plugin telah memuat dan menjalankan perintah log terbuka jika ditemukan dalam perintah peluncuran.  Dengan demikian, membuang ide untuk menggunakan antarmuka "yang sesuai" untuk bekerja dengan perintah memungkinkan kami untuk menjaga fungsionalitas yang diperlukan, dengan pembukaan log yang tertunda setelah plugin sepenuhnya dimuat. <br><br>  Fiuh, sepertinya kita akhirnya berhasil;  plugin memuat dan terbuka seperti yang diharapkan, tanpa peringatan apa pun. <br><br>  Dan di sinilah semuanya salah.  Paul (Hai Paul!) Instal plugin di komputernya dan tanyakan mengapa kita masih belum beralih ke beban asinkron. <br><br>  Untuk mengatakan bahwa kami terkejut akan menjadi pernyataan yang meremehkan.  Itu tidak mungkin!  Tapi ini nyata: inilah versi baru plugin, dan inilah pesan yang mengatakan bahwa paket memuat secara bersamaan.  Alexander (Hai Alexander!) Dan saya mencoba versi yang sama di komputer masing-masing - ini berfungsi dengan baik.  Bagaimana itu mungkin?  Kemudian terpikir oleh kami untuk memeriksa versi pustaka PVS-Studio yang dimuat di Visual Studio - dan kami menemukan bahwa ini adalah pustaka untuk Visual Studio 2017, sedangkan paket VSIX berisi versi baru, mis. Untuk Visual Studio 2019. <br><br>  Setelah bermain-main dengan VSIXInstaller untuk sementara waktu, kami berhasil mengetahui bahwa masalahnya ada pada cache paket.  Teori ini juga didukung oleh fakta bahwa membatasi akses ke paket cache (C: \ ProgramData \ Microsoft \ VisualStudio \ Packages) yang disebabkan oleh VSIXInstaller untuk menampilkan pesan kesalahan dalam log.  Anehnya, ketika kesalahan tidak terjadi, informasi tentang menginstal paket cache tidak muncul. <br><br>  <b>Catatan samping</b> .  Saat mempelajari perilaku Penginstal VSIX dan perpustakaan yang menyertainya, saya berpikir betapa kerennya bahwa Roslyn dan MSBuild adalah open-source, yang memungkinkan Anda untuk dengan mudah membaca dan men-debug kode mereka dan melacak logika kerjanya. <br><br>  Jadi, inilah yang terjadi: ketika menginstal plugin, VSIX Installer melihat bahwa paket yang sesuai sudah di-cache (itu sebenarnya paket .vsix untuk Visual Studio 2017) dan menginstal paket itu bukan yang baru.  Mengapa ia mengabaikan pembatasan / persyaratan yang ditentukan dalam file .vsixmanifest (yang, antara lain, pemasangan ekstensi yang dibatasi ke versi Visual Studio tertentu) adalah pertanyaan yang belum dijawab.  Akibatnya, plugin yang dirancang untuk Visual Studio 2017 terinstal di Visual Studio 2019 - meskipun ada pembatasan yang ditentukan dalam file .vsixmanifest. <br><br>  Terburuk dari semua, instalasi itu mematahkan grafik dependensi Visual Studio, dan meskipun IDE tampaknya berjalan dengan baik, semuanya benar-benar mengerikan.  Anda tidak dapat menginstal atau menghapus ekstensi, memperbarui, dll.  Proses "pemulihan" juga menyakitkan karena kami harus menghapus ekstensi (yaitu file yang berisi itu) secara manual dan - juga secara manual - mengedit file konfigurasi yang menyimpan informasi tentang paket yang diinstal.  Dengan kata lain, itu sama sekali tidak menyenangkan. <br><br>  Untuk memperbaikinya dan memastikan kami tidak mengalami situasi seperti itu di masa mendatang, kami memutuskan untuk membuat GUID kami sendiri untuk paket baru agar paket-paket untuk Visual Studio 2017 dan Visual Studio 2019 diisolasi dengan aman satu sama lain ( paket lama baik-baik saja; mereka selalu menggunakan GUID bersama). <br><br>  Karena kami mulai berbicara tentang kejutan yang tidak menyenangkan, inilah yang lain: setelah memperbarui ke Pratinjau 2, menu PVS-Studio "pindah" ke tab "Ekstensi".  Bukan masalah besar, tetapi itu membuat mengakses fungsi plugin menjadi kurang nyaman.  Perilaku ini bertahan melalui versi Visual Studio 2019 berikutnya, termasuk rilis.  Saya telah menemukan menyebutkan "fitur" ini baik di dokumentasi maupun di blog. <br><br>  Oke, sekarang semuanya tampak baik-baik saja dan kami tampaknya telah selesai dengan dukungan Visual Studio 2019 pada akhirnya.  Ini terbukti salah pada hari berikutnya setelah merilis PVS-Studio 7.02.  Itu adalah mode muat asinkron lagi.  Saat membuka jendela hasil analisis (atau memulai analisis), jendela analisa akan tampak "kosong" bagi pengguna - tanpa tombol, tanpa kisi, tidak ada sama sekali. <br><br>  Masalah ini sebenarnya terjadi setiap saat selama analisis.  Tapi itu mempengaruhi hanya satu komputer dan tidak muncul sampai Visual Studio diperbarui ke salah satu iterasi pertama 'Pratinjau'.  Kami menduga ada sesuatu yang rusak selama instalasi atau pembaruan.  Masalahnya, bagaimanapun, menghilang beberapa waktu kemudian dan tidak akan terjadi bahkan pada komputer tertentu, jadi kami pikir itu "diperbaiki sendiri."  Tapi tidak - kami hanya beruntung.  Atau sial, dalam hal ini. <br><br>  Ketika kami temukan, itu adalah urutan di mana jendela IDE itu sendiri (kelas yang berasal dari <i>ToolWindowPane</i> ) dan isinya (kontrol kami dengan kisi-kisi dan tombol) diinisialisasi.  Dalam kondisi tertentu, kontrol akan diinisialisasi sebelum panel dan meskipun semuanya berjalan dengan baik dan metode <i>FindToolWindowAsync</i> (membuat jendela saat diakses untuk pertama kali) melakukan tugasnya dengan baik, kontrol tetap tidak terlihat.  Kami memperbaikinya dengan menambahkan inisialisasi malas untuk kontrol kami ke kode pane-filling. <br><br><h2>  Dukungan C # 8.0 </h2><br>  Ada satu keuntungan besar tentang menggunakan Roslyn sebagai dasar untuk penganalisa: Anda tidak perlu menambahkan dukungan untuk konstruksi bahasa baru secara manual - itu dilakukan secara otomatis melalui perpustakaan Analisis Kode Microsoft, dan kami hanya menggunakan solusi yang sudah jadi.  Ini berarti sintaks baru didukung dengan hanya memperbarui perpustakaan. <br><br>  Adapun analisis itu sendiri, kami harus mengubah hal-hal kami sendiri, tentu saja - khususnya, menangani konstruksi bahasa baru.  Tentu, kami memiliki pohon sintaksis baru yang dihasilkan secara otomatis hanya dengan memperbarui Roslyn, tetapi kami masih harus mengajar analisanya bagaimana tepatnya menafsirkan dan memproses simpul pohon sintaksis yang baru atau yang dimodifikasi. <br><br>  Jenis referensi yang dapat dibatalkan mungkin merupakan fitur baru yang paling banyak dibahas dari C # 8. Saya tidak akan membicarakannya sekarang karena topik yang sebesar itu layak untuk artikel yang terpisah (yang saat ini sedang ditulis).  Untuk saat ini, kami telah memutuskan untuk mengabaikan anotasi yang tidak dapat dibatalkan dalam mekanisme aliran data kami (yaitu, kami memahami, menguraikan, dan melewatkannya).  Idenya adalah bahwa suatu variabel, bahkan dari tipe referensi yang tidak dapat <i>dibatalkan</i> , masih dapat dengan mudah (atau tidak sengaja) diberi nilai <i>nol</i> , diakhiri dengan NRE ketika mencoba melakukan dereferensi.  Penganalisa kami dapat menemukan kesalahan tersebut dan melaporkan potensi null dereference (jika tentu saja menemukan penugasan tersebut dalam kode) bahkan jika variabelnya adalah tipe referensi yang tidak dapat dibatalkan. <br><br>  Menggunakan jenis referensi yang dapat dibatalkan dan sintaks terkait memungkinkan Anda untuk menulis kode yang cukup menarik.  Kami menjulukinya "sintaksis emosional".  Cuplikan ini dapat dikompilasi dengan sempurna: <br><br><pre> <code class="cpp hljs">obj.Calculate(); obj?.Calculate(); obj.Calculate(); obj!?.Calculate(); obj!!!.Calculate();</code> </pre> <br>  Omong-omong, eksperimen saya membuat saya menemukan beberapa trik yang dapat Anda gunakan untuk "crash" Visual Studio menggunakan sintaks baru.  Mereka didasarkan pada kenyataan bahwa Anda diperbolehkan menulis sebanyak '!'  karakter yang Anda inginkan.  Ini berarti Anda tidak hanya dapat menulis kode seperti ini: <br><br><pre> <code class="cpp hljs">object temp = null!</code> </pre> <br>  tetapi juga seperti ini: <br><br><pre> <code class="cpp hljs">object temp = null!!!;</code> </pre> <br>  Dan, mendorongnya lebih jauh, Anda bisa menulis hal-hal gila seperti ini: <br><br><pre> <code class="cpp hljs">object temp = null!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!;</code> </pre> <br>  Kode ini dapat dikompilasi, tetapi jika Anda mencoba untuk melihat pohon sintaks di Sintaks Visualizer dari .NET Compiler Platform SDK, Visual Studio akan macet. <br><br>  Laporan kegagalan dapat ditarik dari Peraga Peristiwa: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.28803</span></span><span class="hljs-number"><span class="hljs-number">.352</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5cc37012</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: WindowsBase.ni.dll, version: <span class="hljs-number"><span class="hljs-number">4.8</span></span><span class="hljs-number"><span class="hljs-number">.3745</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5c5bab63</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xc00000fd</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x000c9af4</span></span> Faulting process id: <span class="hljs-number"><span class="hljs-number">0x3274</span></span> Faulting application start time: <span class="hljs-number"><span class="hljs-number">0x01d5095e7259362e</span></span> Faulting application path: C:\<span class="hljs-function"><span class="hljs-function">Program </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Files</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x86)</span></span></span><span class="hljs-function">\ Microsoft Visual Studio\2019\Community\Common7\IDE\devenv.exe Faulting </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">module</span></span></span><span class="hljs-function"> path: C:\WINDOWS\assembly\NativeImages_v4.0.30319_32\ WindowsBase\4480dfedf0d7b4329838f4bbf953027d\WindowsBase.ni.dll Report Id: 66d41eb2-c658-486d-b417-02961d9c3e4f Faulting package full name: Faulting package-relative application ID:</span></span></code> </pre> <br>  Jika Anda menjadi lebih gila dan menambahkan beberapa kali lebih banyak tanda seru, Visual Studio akan mulai macet dengan sendirinya, tanpa bantuan dari Syntax Visualizer.  Pustaka Microsoft.CodeAnalysis dan kompiler csc.exe juga tidak bisa mengatasi kode tersebut. <br><br>  Contoh-contoh ini dibuat-buat, tentu saja, tetapi saya menemukan trik itu lucu. <br><br><h2>  Toolset </h2><br>  Jelas bahwa memperbarui toolset akan menjadi bagian yang paling sulit.  Setidaknya seperti itulah awalnya, tetapi sekarang saya cenderung berpikir bahwa dukungan plugin adalah bagian yang paling sulit.  Untuk satu hal, kami sudah memiliki perangkat dan mekanisme untuk mengevaluasi proyek-proyek MSBuild, yang bagus meskipun itu masih harus diperpanjang.  Fakta bahwa kami tidak harus menulis algoritme dari awal membuatnya lebih mudah.  Strategi mengandalkan toolset "kami", yang kami sukai untuk tetap bertahan saat mendukung Visual Studio 2017, sekali lagi terbukti benar. <br><br>  Secara tradisional, proses dimulai dengan memperbarui paket NuGet.  Tab untuk mengelola paket NuGet untuk solusi saat ini berisi tombol "Perbarui" ... tetapi tidak membantu.  Memperbarui semua paket sekaligus menyebabkan banyak konflik versi, dan mencoba menyelesaikannya sepertinya bukan ide yang baik.  Cara yang lebih menyakitkan namun mungkin lebih aman adalah dengan memperbarui paket target Microsoft secara selektif. Build / Microsoft.CodeAnalysis. <br><br>  Satu perbedaan langsung terlihat ketika menguji diagnostik: struktur pohon sintaks berubah pada node yang ada.  Bukan masalah besar;  kami memperbaikinya dengan cepat. <br><br>  Biarkan saya mengingatkan Anda, kami menguji analisis kami (untuk C #, C ++, Java) pada proyek sumber terbuka.  Ini memungkinkan kami untuk menguji diagnostik secara menyeluruh - misalnya, memeriksanya untuk positif palsu atau melihat apakah kami melewatkan kasus apa pun (untuk mengurangi jumlah negatif palsu).  Tes-tes ini juga membantu kami melacak kemungkinan kemunduran pada langkah awal memperbarui perpustakaan / toolset.  Kali ini mereka menangkap sejumlah masalah juga. <br><br>  Salah satunya adalah bahwa perilaku di dalam perpustakaan CodeAnalysis semakin buruk.  Secara khusus, ketika memeriksa proyek tertentu, kami mulai mendapatkan pengecualian dari kode perpustakaan pada berbagai operasi seperti memperoleh informasi semantik, membuka proyek, dan sebagainya. <br><br>  Anda yang telah membaca artikel tentang dukungan Visual Studio 2017 dengan hati-hati ingat bahwa distribusi kami disertai dengan dummy - file MSBuild.exe sebesar 0 byte. <br><br>  Sekarang kami harus mendorong praktik ini lebih jauh dan menyertakan boneka kosong untuk kompiler csc.exe, vbc.exe, dan VBCSCompiler.exe.  Mengapa  Kami datang dengan solusi ini setelah menganalisis salah satu proyek dari basis pengujian kami dan mendapatkan laporan berbeda: versi baru dari penganalisa tidak akan menghasilkan beberapa peringatan yang diharapkan. <br><br>  Kami menemukan bahwa itu ada hubungannya dengan simbol kompilasi bersyarat, beberapa di antaranya tidak diekstraksi dengan benar ketika menggunakan versi baru dari penganalisis.  Untuk mencapai akar masalahnya, kami harus menggali lebih dalam kode perpustakaan Roslyn. <br><br>  Simbol kompilasi bersyarat diuraikan menggunakan metode <i>GetDefineConstantsSwitch</i> dari <i>Csc</i> kelas dari perpustakaan <i>Microsoft.Build.Tasks.CodeAnalysis</i> .  Penguraian dilakukan menggunakan metode <i>String.Split</i> pada sejumlah pemisah: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] allIdentifiers = originalDefineConstants.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span> });</code> </pre> <br>  Mekanisme parsing ini bekerja dengan sempurna;  semua simbol kompilasi bersyarat diekstraksi dengan benar.  Oke, mari terus menggali. <br><br>  Titik kunci berikutnya adalah panggilan metode <i>ComputePathToTool</i> dari <i>ToolTask</i> kelas.  Metode ini menghitung jalur ke file yang dapat dieksekusi ( <i>csc.exe</i> ) dan memeriksa apakah ada di sana.  Jika demikian, metode mengembalikan jalur ke sana atau <i>nol</i> sebaliknya. <br><br>  Kode panggilan: <br><br><pre> <code class="cpp hljs">.... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pathToTool = ComputePathToTool(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTool == null) { <span class="hljs-comment"><span class="hljs-comment">// An appropriate error should have been logged already. return false; } ....</span></span></code> </pre> <br>  Karena tidak ada file <i>csc.exe</i> (mengapa kita membutuhkannya?), <i>PathToTool</i> diberi nilai <i>null</i> pada titik ini, dan metode saat ini ( <i>ToolTask.Execute</i> ) mengembalikan <i>false</i> .  Hasil dari mengeksekusi tugas, termasuk simbol kompilasi bersyarat yang diekstrak, diabaikan. <br><br>  Oke, mari kita lihat apa yang terjadi jika kita meletakkan file <i>csc.exe di</i> tempat yang seharusnya. <br><br>  Sekarang <i>pathToTool</i> menyimpan path sebenarnya ke file sekarang-sekarang, dan <i>ToolTask.Execute</i> terus mengeksekusi.  Poin kunci berikutnya adalah panggilan metode <i>ManagedCompiler.ExecuteTool</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteTool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathToTool, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> responseFileCommands, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commandLineCommands)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ProvideCommandLineArgs) { CommandLineArgs = GetArguments(commandLineCommands, responseFileCommands) .Select(arg =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskItem(arg)).ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SkipCompilerExecution) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } .... }</code> </pre> <br>  Properti <i>SkipCompilerExecution</i> <i>benar</i> (cukup logis karena kami tidak mengkompilasi nyata).  Metode pemanggilan ( <i>ToolTask.Execute yang</i> telah disebutkan) memeriksa apakah nilai kembali untuk <i>ExecuteTool</i> adalah 0 dan, jika demikian, mengembalikan <i>true</i> .  Apakah <i>csc.exe</i> Anda adalah kompiler yang sebenarnya atau "War and Peace" oleh Leo Tolstoy tidak masalah sama sekali. <br><br>  Jadi, masalahnya berkaitan dengan urutan langkah-langkahnya: <br><br><ul><li>  periksa kompiler; </li><li>  periksa apakah kompiler harus diluncurkan; </li></ul><br>  Dan kami mengharapkan pesanan terbalik.  Ini untuk memperbaiki ini bahwa boneka untuk kompiler ditambahkan. <br><br>  Oke, tapi bagaimana kita bisa mendapatkan simbol kompilasi sama sekali, dengan absennya file csc.exe (dan hasil tugas diabaikan)? <br><br>  Nah, ada metode untuk kasus ini juga: <i>CSharpCommandLineParser.ParseConditionalCompilationSymbols</i> dari perpustakaan <i>Microsoft.CodeAnalysis.CSharp</i> .  Itu juga parsing dengan memanggil metode <i>String.Split</i> pada sejumlah pemisah: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] values = value.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*, StringSplitOptions.RemoveEmptyEntries*/</span></span>);</code> </pre> <br>  Lihat bagaimana set pemisah ini berbeda dari yang ditangani oleh metode <i>Csc.GetDefineConstantsSwitch</i> ?  Di sini, spasi bukan pemisah.  Ini berarti bahwa simbol kompilasi bersyarat yang dipisahkan oleh spasi tidak akan diuraikan dengan benar dengan metode ini. <br><br>  Itulah yang terjadi ketika kami memeriksa proyek masalah: mereka menggunakan simbol kompilasi bersyarat ruang-terpisah dan, oleh karena itu, berhasil diurai oleh metode <i>GetDefineConstantsSwitch</i> tetapi tidak dengan metode <i>ParseConditionalCompilationSymbols</i> . <br><br>  Masalah lain yang muncul setelah memperbarui perpustakaan adalah perilaku yang rusak dalam kasus-kasus tertentu - khususnya, pada proyek-proyek yang tidak dibangun.  Ini memengaruhi perpustakaan <i>Analisis Kode</i> Microsoft dan memanifestasikan dirinya sebagai pengecualian dari semua jenis: <i>ArgumentNullException</i> (gagal inisialisasi beberapa logger internal), <i>NullReferenceException</i> , dan sebagainya. <br><br>  Saya ingin memberi tahu Anda tentang satu kesalahan tertentu yang menurut saya cukup menarik. <br><br>  Kami menemukannya ketika memeriksa versi baru proyek Roslyn: salah satu perpustakaan melempar <i>NullReferenceException</i> .  Berkat informasi terperinci tentang sumbernya, kami dengan cepat menemukan kode sumber masalah dan - hanya untuk rasa ingin tahu - memutuskan untuk memeriksa apakah kesalahan akan tetap ada ketika bekerja di Visual Studio. <br><br>  Kami berhasil mereproduksi dalam Visual Studio (versi 16.0.3).  Untuk melakukan itu, Anda memerlukan definisi kelas seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  Anda juga akan memerlukan Sintaks Visualizer (dilengkapi dengan .NET Compiler Platform SDK).  Cari <i>TypeSymbol</i> (dengan mengklik item menu "Lihat TypeSymbol (jika ada)") dari simpul pohon sintaks tipe <i>ConstantPatternSyntax</i> ( <i>null</i> ).  Visual Studio akan memulai kembali, dan info pengecualian - khususnya, jejak tumpukan - akan tersedia di Peraga Peristiwa: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.NullReferenceException at Microsoft.CodeAnalysis.CSharp.ConversionsBase. ClassifyImplicitBuiltInConversionSlow( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet<span class="hljs-string"><span class="hljs-string">'1 &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyBuiltInConversion( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet'</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoForNode( Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode) at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo( Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) ....</code> </pre> <br>  Seperti yang Anda lihat, masalahnya disebabkan oleh referensi referensi nol. <br><br>  Seperti yang sudah saya sebutkan, kami mengalami masalah serupa saat menguji analyzer.  Jika Anda membangunnya menggunakan debug perpustakaan dari Microsoft. <i>Code Analysis</i> , Anda bisa langsung ke tempat masalah dengan mencari <i>TypeSymbol</i> dari simpul pohon sintaksis yang sesuai. <br><br>  Ini pada akhirnya akan membawa kita ke metode <i>ClassifyImplicitBuiltInConversionSlow</i> yang disebutkan dalam jejak tumpukan di atas: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } Conversion conversion = ClassifyStandardImplicitConversion(source, destination, ref useSiteDiagnostics); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conversion.Exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversion; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; }</code> </pre> <br>  Di sini, parameter <i>tujuan</i> adalah <i>nol</i> , sehingga memanggil <i>tujuan. Khusus Jenis</i> hasil melempar <i>NullReferenceException</i> .  Ya, operasi dereference didahului oleh <i>Debug.Assert</i> , tetapi tidak membantu karena sebenarnya tidak melindungi dari apa pun - itu hanya memungkinkan Anda untuk menemukan masalah dalam versi debug perpustakaan.  Atau tidak. <br><br><h3>  Perubahan pada mekanisme evaluasi proyek C ++ </h3><br>  Tidak banyak yang menarik di bagian ini: algoritma yang ada tidak memerlukan modifikasi besar yang layak disebutkan, tetapi Anda mungkin ingin tahu tentang dua masalah kecil. <br><br>  Yang pertama adalah kami harus memodifikasi algoritma yang bergantung pada nilai numerik ToolsVersion.  Tanpa merinci, ada kasus-kasus tertentu ketika Anda perlu membandingkan toolets dan memilih, katakanlah, versi terbaru.  Versi baru, tentu saja, memiliki nilai lebih besar.  Kami berharap ToolsVersion untuk MSBuild / Visual Studio baru akan memiliki nilai 16.0.  Ya tentu!  Tabel di bawah ini menunjukkan bagaimana nilai properti yang berbeda berubah sepanjang sejarah pengembangan Visual Studio: <br><div class="scrollable-table"><table><tbody><tr><td>  Nama produk studio visual <br></td><td>  Nomor versi studio visual <br></td><td>  Versi Alat <br></td><td>  Versi PlatformToolset <br></td></tr><tr><td>  Visual studio 2010 <br></td><td>  10.0 <br></td><td>  4.0 <br></td><td>  100 <br></td></tr><tr><td>  Visual studio 2012 <br></td><td>  11.0 <br></td><td>  4.0 <br></td><td>  110 <br></td></tr><tr><td>  Visual studio 2013 <br></td><td>  12.0 <br></td><td>  12.0 <br></td><td>  120 <br></td></tr><tr><td>  Visual studio 2015 <br></td><td>  14.0 <br></td><td>  14.0 <br></td><td>  140 <br></td></tr><tr><td>  Visual studio 2017 <br></td><td>  15.0 <br></td><td>  15.0 <br></td><td>  141 <br></td></tr><tr><td>  Visual studio 2019 <br></td><td>  16.0 <br></td><td>  Saat ini <br></td><td>  142 <br></td></tr></tbody></table></div><br>  Saya tahu bahwa lelucon tentang nomor versi Windows dan Xbox yang berantakan adalah yang lama, tetapi ini membuktikan bahwa Anda tidak dapat membuat prediksi yang dapat diandalkan tentang nilai-nilai (baik dalam nama atau versi) dari produk Microsoft di masa depan.  :) <br><br>  Kami menyelesaikannya dengan mudah dengan menambahkan memprioritaskan untuk toolet (yaitu memilih prioritas sebagai entitas terpisah). <br><br>  Masalah kedua melibatkan masalah dengan bekerja di Visual Studio 2017 atau lingkungan terkait (misalnya, ketika variabel lingkungan <i>VisualStudioVersion</i> diatur).  Itu terjadi karena parameter komputasi yang diperlukan untuk mengevaluasi proyek C ++ adalah tugas yang jauh lebih sulit daripada mengevaluasi proyek .NET.  Untuk .NET, kami menggunakan perangkat kami sendiri dan nilai ToolsVersion yang sesuai.  Untuk C ++, kita dapat menggunakan toolset kita sendiri dan yang disediakan oleh sistem.  Dimulai dengan Alat Bangun untuk Visual Studio 2017, alat ditetapkan dalam file <i>MSBuild.exe.config</i> bukan registri.  Itu sebabnya kami tidak bisa mendapatkannya lagi dari daftar global perangkat (menggunakan <i>Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.Toolsets</i> , misalnya) tidak seperti yang didefinisikan dalam registri (yaitu untuk Visual Studio 2015 dan sebelumnya). <br><br>  Semua ini mencegah kita mengevaluasi proyek menggunakan <i>ToolsVersion 15.0</i> karena sistem tidak akan melihat <i>set</i> alat yang diperlukan.  Toolset terbaru, <i>Lancar</i> , masih akan tersedia karena itu adalah toolset kami sendiri, dan, oleh karena itu, tidak ada masalah seperti itu di Visual Studio 2019. Solusinya cukup sederhana dan memungkinkan kami untuk memperbaikinya tanpa mengubah algoritma evaluasi yang ada: kami hanya harus memasukkan set alat lain, <i>15.0</i> , ke dalam daftar set alat kami sendiri selain <i>Lancar</i> . <br><br><h3>  Perubahan pada mekanisme evaluasi proyek Inti C # .NET </h3><br>  Tugas ini melibatkan dua masalah yang saling terkait: <br><br><ul><li>  menambahkan toolset 'Current' yang memecah analisis proyek .NET Core di Visual Studio 2017; </li><li>  analisis tidak akan bekerja untuk proyek .NET Core pada sistem tanpa setidaknya satu salinan Visual Studio diinstal. </li></ul><br>  Kedua masalah tersebut berasal dari sumber yang sama: beberapa file .targets / .props dasar terlihat di jalur yang salah.  Ini mencegah kami mengevaluasi proyek menggunakan perangkat kami. <br><br>  Jika Anda tidak menginstal instance Visual Studio, Anda akan mendapatkan kesalahan berikut (dengan versi toolset sebelumnya, <i>15.0</i> ): <br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Windows\Microsoft.NET\Framework64\ 15.0\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found.</code> </pre> <br>  Saat mengevaluasi proyek C # .NET Core di Visual Studio 2017, Anda akan mendapatkan kesalahan berikut (dengan versi toolset saat ini, <i>Lancar</i> ): <br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\MSBuild\Current\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found. ....</code> </pre> <br>  Karena masalah-masalah ini mirip (yang nampaknya memang demikian), kita dapat mencoba membunuh dua burung dengan satu batu. <br><br>  Dalam paragraf berikutnya, saya akan menjelaskan bagaimana kami mencapai itu, tanpa merinci.  Rincian ini (tentang bagaimana C # .NET Core proyek dievaluasi serta perubahan mekanisme evaluasi dalam perangkat kami) akan menjadi topik dari salah satu artikel kami di masa depan.  Ngomong-ngomong, jika Anda membaca artikel ini dengan cermat, Anda mungkin memperhatikan bahwa ini adalah referensi kedua untuk artikel mendatang kami.  :) <br><br>  Sekarang, bagaimana kita mengatasi masalah itu?  Kami memperluas toolset kami sendiri dengan file .targets / .props dasar dari .NET Core SDK ( <i>Sdk.props</i> , <i>Sdk.targets</i> ).  Itu memberi kami lebih banyak kontrol atas situasi dan fleksibilitas dalam manajemen impor serta evaluasi proyek .NET Core secara umum.  Ya, toolset kami menjadi sedikit lebih besar lagi, dan kami juga harus menambahkan logika untuk mengatur lingkungan yang diperlukan untuk evaluasi proyek .NET Core, tetapi tampaknya sepadan. <br><br>  Sampai saat itu, kami telah mengevaluasi proyek .NET Core dengan hanya meminta evaluasi dan mengandalkan MSBuild untuk melakukan pekerjaan itu. <br><br>  Sekarang kami memiliki kendali lebih besar atas situasi, mekanismenya berubah sedikit: <br><br><ul><li>  mengatur lingkungan yang diperlukan untuk mengevaluasi proyek .NET Core; </li><li>  evaluasi: <ul><li>  mulai evaluasi menggunakan file .targets / .props dari perangkat kami; </li><li>  lanjutkan evaluasi menggunakan file eksternal. </li></ul></li></ul><br>  Urutan ini menunjukkan bahwa pengaturan lingkungan mengejar dua tujuan utama: <br><br><ul><li>  memulai evaluasi menggunakan file .targets / .props dari perangkat kami; </li><li>  mengarahkan semua operasi selanjutnya ke file .targets / .props eksternal. </li></ul><br>  Perpustakaan khusus Microsoft.DotNet.MSBuildSdkResolver digunakan untuk mencari file .targets / .props yang diperlukan.  Untuk memulai pengaturan lingkungan menggunakan file dari toolset kami, kami menggunakan variabel lingkungan khusus yang digunakan oleh perpustakaan itu sehingga kami dapat menunjuk pada sumber tempat mengimpor file yang diperlukan dari (yaitu toolset kami).  Karena perpustakaan dimasukkan ke dalam distribusi kami, tidak ada risiko kegagalan logika tiba-tiba. <br><br>  Sekarang kami memiliki file Sdk dari toolset kami yang diimpor terlebih dahulu, dan karena kami dapat dengan mudah mengubahnya sekarang, kami sepenuhnya mengendalikan sisa logika evaluasi.  Ini berarti kita sekarang dapat memutuskan file mana dan dari lokasi mana yang akan diimpor.  Hal yang sama berlaku untuk Microsoft.Common.props yang disebutkan di atas.  Kami mengimpor ini dan file dasar lainnya dari perangkat kami sehingga kami tidak perlu khawatir tentang keberadaan atau kontennya. <br><br>  Setelah semua impor yang diperlukan dilakukan dan properti ditetapkan, kami memberikan kontrol atas proses evaluasi ke .NET Core SDK yang sebenarnya, tempat semua operasi yang diperlukan dilakukan. <br><br><h2>  Kesimpulan </h2><br>  Mendukung Visual Studio 2019 umumnya lebih mudah daripada mendukung Visual Studio 2017 karena sejumlah alasan.  Pertama, Microsoft tidak mengubah banyak hal seperti yang mereka miliki ketika memperbarui dari Visual Studio 2015 ke Visual Studio 2017. Ya, mereka memang mengubah toolset dasar dan memaksa plugin Visual Studio untuk beralih ke mode beban asinkron, tetapi perubahan ini tidak drastis itu.  Kedua, kami sudah memiliki solusi siap pakai yang melibatkan alat kami sendiri dan mekanisme evaluasi proyek dan kami tidak perlu mengerjakan semuanya dari awal - hanya membangun apa yang sudah kami miliki.  Proses analisis pendukung yang relatif tidak menyakitkan dari proyek .NET Core dalam kondisi baru (dan pada komputer tanpa salinan Visual Studio terpasang) dengan memperluas sistem evaluasi proyek kami juga memberi kami harapan bahwa kami telah membuat pilihan yang tepat dengan mengambil beberapa kendali dalam tangan kita. <br><br>  Tetapi saya ingin mengulangi gagasan yang dikomunikasikan dalam artikel sebelumnya: kadang-kadang menggunakan solusi yang sudah jadi tidak semudah kelihatannya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454736/">https://habr.com/ru/post/id454736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454720/index.html">Bagaimana cara menghidupkan kembali dokumentasinya?</a></li>
<li><a href="../id454728/index.html">Buka Akses Internet: Teknologi LUWRAIN Membantu Pengguna Buta</a></li>
<li><a href="../id454730/index.html">Allure Server meetup: rekaman video dari laporan</a></li>
<li><a href="../id454732/index.html">5 Teknik Prioritas yang Kuat untuk Tim TI</a></li>
<li><a href="../id454734/index.html">Cadangan, Bagian 4: Tinjauan Umum dan Pengujian zbackup, restic, borgbackup</a></li>
<li><a href="../id454738/index.html">Dukungan Visual Studio 2019 dalam PVS-Studio</a></li>
<li><a href="../id454740/index.html">Mei 2019 Pencernaan Joomla</a></li>
<li><a href="../id454742/index.html">Setidaknya satu trik Vim yang tidak Anda ketahui</a></li>
<li><a href="../id454744/index.html">Tinjauan Java Track Reports dari RigaDevDays Conference</a></li>
<li><a href="../id454748/index.html">Panduan Kelangsungan Hidup MongoDB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>