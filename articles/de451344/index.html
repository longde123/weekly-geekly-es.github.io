<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßê üë©üèΩ‚Äçüíª üîá Mit dem Optimierer verstecken und suchen. Spiel vorbei, das ist CTE PostgreSQL 12 ‚ôçÔ∏è ü¶Ö ‚úçÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist eine Fortsetzung der Geschichte √ºber Neuheiten in PostgreSQL 12. Wir haben SQL / JSON (JSONPath-Patch) bereits im Artikel ‚ÄûWas sie ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mit dem Optimierer verstecken und suchen. Spiel vorbei, das ist CTE PostgreSQL 12</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/451344/"><img src="https://habrastorage.org/webt/lx/r3/ps/lxr3psy9oebq4i01moowesbn_mq.png"><br><br>  Dieser Artikel ist eine Fortsetzung der Geschichte √ºber Neuheiten in PostgreSQL 12. Wir haben SQL / JSON (JSONPath-Patch) bereits im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûWas sie beim Einfrieren von Features 2019 eingefroren haben‚Äú analysiert. Teil I. JSONPath ‚Äú</a> , jetzt ist CTE an der Reihe. <br><br><h2>  Cte </h2><br>  CTE ist Common Table Expression - Common Table Expression, sie werden auch als WITH-Konstrukte bezeichnet.  Tats√§chlich werden tempor√§re Tabellen erstellt, die jedoch nur f√ºr eine Abfrage und nicht f√ºr die Sitzung vorhanden sind.  Sie k√∂nnen innerhalb dieser Anfrage abgerufen werden.  Eine solche Anfrage ist gut gelesen, verst√§ndlich und bei Bedarf leicht zu √§ndern.  Dies ist eine sehr beliebte Sache, und sie ist seit langer Zeit in PostgreSQL. <br><br>  Aber Annehmlichkeiten k√∂nnen teuer sein.  Die Probleme h√§ngen mit der Materialisierung des Ausdrucks nach AS innerhalb des WITH ... AS () -Konstrukts zusammen.  Es wird auch als interner Ausdruck bezeichnet und berechnet, bevor Sie mit der Berechnung des Restes beginnen. Es kann nicht in eine Abfrage der obersten Ebene eingebettet werden (kein Inlining).  Bei der Planung dieses Ausdrucks wird der Rest der Abfrage nicht ber√ºcksichtigt.  Dieses Verhalten wird als Hindernis f√ºr die Optimierung oder das Fechten bezeichnet.  Dar√ºber hinaus erfordert die Materialisierung selbst work_mem.  Und wenn die Stichprobe gro√ü ist, beginnen die Probleme (zum Beispiel gibt es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht von</a> Ivan Frolkov auf der PGConf 2019). <br><a name="habracut"></a><br>  Das Verstecken mit dem Optimierer, den wir unten analysieren werden, ist im Allgemeinen kein Fehler, sondern eine Funktion.  Nat√ºrlich gibt es Situationen, in denen die vorl√§ufige Berechnung eines Teils eines Ausdrucks beispielsweise unn√∂tige wiederholte Operationen in rekursiven Abfragen eliminiert.  Auf der anderen Seite verwendeten viele Entwickler CTE als Ansicht, ohne √ºber die Barriere nachzudenken, und infolgedessen wurden Anforderungen von CTE nicht nur langsamer als √§quivalente (aber komplexere) Anforderungen mit Unterabfragen ausgef√ºhrt, sondern auch um Gr√∂√üenordnungen langsamer.  Nach dem Abw√§gen der Vor- und Nachteile hat die Community einen entscheidenden Schritt getan: Sie hat das Standardverhalten ge√§ndert. <br><br>  Wir werden die Arbeit von CTE auf einer solchen Platte beobachten: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> xytable <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> x, x <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> xytable(x,y);</code> </pre> <br><pre> <code class="plaintext hljs">Table "public.xytable" Column | Type | Collation | Nullable | Default --------------+---------+------------------+----------------+--------- x | integer | | | y | integer | | | Indexes: "xytable_x_y_idx" btree (x, y)</code> </pre> <br>  Beginnen wir mit einer einfachen Anfrage: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> xytable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x=<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> y&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------------- Index Only Scan using xytable_x_y_idx on xytable (cost=0.43..8.46 rows=1 width=8) (actual time=0.016..0.017 rows=1 loops=1) Index Cond: ((x = 2) AND (y &gt; 1)) Heap Fetches: 1 Planning Time: 0.075 ms Execution Time: 0.035 ms (5 rows)</span></span></code> </pre> <br>  Alles wird sofort ber√ºcksichtigt, nur der Index wird verwendet. <br><br>  Eine Abfrage mit einer Unterabfrage, die dasselbe berechnet, jedoch mit einer etwas komplizierteren Syntax: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> xytable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> y&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x=<span class="hljs-number"><span class="hljs-number">2</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------- Index Only Scan using xytable_x_y_idx on xytable (cost=0.43..8.46 rows=1 width=8) (actual time=0.016..0.016 rows=1 loops=1) Index Cond: ((x = 2) AND (y &gt; 1)) Heap Fetches: 1 Planning Time: 0.062 ms Execution Time: 0.029 ms (5 rows)</span></span></code> </pre> <br>  Alles ist in Ordnung, sehr schnelle Indexberechnung. <br><br>  Und jetzt noch eine logisch √§quivalente Anfrage, aber mit CTE: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> xytable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> y&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x=<span class="hljs-number"><span class="hljs-number">2</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------ CTE Scan on yy (actual time=0.099..3672.842 rows=1 loops=1) Filter: (x = 2) Rows Removed by Filter: 9999998 CTE yy -&gt; Seq Scan on cte (actual time=0.097..1355.367 rows=9999999 loops=1) Filter: (y &gt; 1) Rows Removed by Filter: 1 Planning Time: 0.088 ms Execution Time: 3735.986 ms (9 rows)</span></span></code> </pre> <br>  Eine solche Verz√∂gerung ist bereits mit blo√üem Auge sichtbar.  Sie werden keinen Kaffee trinken, aber es bleibt gen√ºgend Zeit, um in die Post zu schauen (wenn wir die 11. Version oder fr√ºher haben). <br><br>  Und Folgendes ist passiert: Bei Unterabfragen hat der Optimierer sofort erkannt, dass die Bedingungen x = 2 und y&gt; 1 zu einem Filter kombiniert und nach Index durchsucht werden k√∂nnen.  Im Fall von CTE hat der Optimierer keine Wahl: Er muss sich zuerst mit der Bedingung innerhalb des WITH ... AS-Konstrukts befassen, das Ergebnis materialisieren und erst dann daran arbeiten. <br><br>  Und hier geht es nicht darum, dass f√ºr die Materialisierung Ressourcen erforderlich sind: Wenn die Bedingung y &lt;3 ist, m√ºssen nicht Millionen von Datens√§tzen materialisiert werden, sondern nur 2. Die ungeheure Zeit f√ºr eine einfache Abfrage wird f√ºr die sequentielle Suche aufgewendet, da der Optimierer die Indexsuche nicht verwenden kann, da Damit der zusammengesetzte Index auf x und erst dann auf y basiert und er nichts √ºber eine Abfrage mit der Bedingung x = 2 wei√ü, bis er die interne CTE-Bedingung erf√ºllt.  Es ist jenseits der Barriere. <br><br>  Vor PostgreSQL 12 war die Standardeinstellung Materialisierung, jetzt fehlt sie.  Wir starten die gleiche Anfrage basierend auf der neuen Version.  Barriere sieht der Optimierer sozusagen sofort die gesamte Anfrage: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> xytable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> y&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x=<span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">QUERY PLAN ------------------------------------------ Index Only Scan using xytable_x_y_idx1 on xytable (cost=0.43..8.46 rows=1 width=8) (actual time=0.015..0.016 rows=1 loops=1) Index Cond: ((x = 2) AND (y &gt; 1)) Heap Fetches: 1 Planning Time: 0.067 ms Execution Time: 0.029 ms (5 rows)</code> </pre> <br>  Der Optimierer lernte sofort, die Bedingungen in der optimalen Reihenfolge zu kombinieren - wie es bei den Unterabfragen der Fall war. <br><br>  Die Standardeinstellungen sind jedoch Standardeinstellungen, und f√ºr die vollst√§ndige √úbernahme der Situation gibt es in Version 12 eine kontrollierte, kontrollierte Materialisierung von CTE: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> cte_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">MATERIALIZED</span></span></code> </pre> <br>  Lassen Sie uns materialisieren: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATERIALIZED</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> xytable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> y&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x=<span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">QUERY PLAN --------------------------- CTE Scan on yy (cost=356423.68..581401.19 rows=49995 width=8) (actual time=661.038..3603.292 rows=1 loops=1) Filter: (x = 2) Rows Removed by Filter: 9999998 CTE yy -&gt; Bitmap Heap Scan on cte (cost=187188.18..356423.68 rows=9999000 width=8) (actual time=661.032..2102.040 rows=9999999 loops=1) Recheck Cond: (y &gt; 1) Heap Blocks: exact=44248 -&gt; Bitmap Index Scan on xytable_x_y_idx1 (cost=0.00..184688.43 rows=9999000 width=0) (actual time=655.519..655.519 rows=9999999 loops=1) Index Cond: (y &gt; 1) Planning Time: 0.086 ms Execution Time: 3612.840 ms (11 rows)</code> </pre> <br>  Alles ist wie in 11 und davor k√∂nnen Sie E-Mails im Standby-Modus der Abfrageergebnisse anzeigen.  Wir verbieten Materialisierung, entfernen die Barriere: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATERIALIZED</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> xytable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> y&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x=<span class="hljs-number"><span class="hljs-number">2</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------- Index Only Scan using xytable_x_y_idx1 on xytable (cost=0.43..8.46 rows=1 width=8) (actual time=0.070..0.072 rows=1 loops=1) Index Cond: ((x = 2) AND (y &gt; 1)) Heap Fetches: 1 Planning Time: 0.182 ms Execution Time: 0.108 ms (5 rows)</span></span></code> </pre> <br>  Wieder keine Pause: es z√§hlt sofort. <br>  Verbleibende Nuancen.  Aber wichtige Nuancen. <br><br><h3>  CTE tritt standardm√§√üig auf, wenn mehrmals darauf zugegriffen wird. </h3><br>  Auf den ersten Blick ist die Materialisierung in solchen F√§llen eine vern√ºnftige Entscheidung: Warum zweimal dasselbe berechnen?  In der Praxis f√ºhrt dies oft zu dem, was wir oben beobachtet haben.  Um die Ablehnung der Materialisierung zu erzwingen, muss der Optimierer explizit bestellt werden: NICHT MATERIALISIERT. <br><br>  Wir f√ºhren ohne NICHT MATERIALISIERTE Anfrage mit double WHERE aus: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> xytable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> y &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x=<span class="hljs-number"><span class="hljs-number">2</span></span>), ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x=<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><pre> <code class="plaintext hljs">QUERY PLAN --------------------------------------------------------------------------- Result (actual time=3922.274..3922.275 rows=1 loops=1) CTE yy -&gt; Seq Scan on xytable (actual time=0.023..1295.262 rows=9999999 loops=1) Filter: (y &gt; 1) Rows Removed by Filter: 1 InitPlan 2 (returns $1) -&gt; Aggregate (actual time=3109.687..3109.687 rows=1 loops=1) -&gt; CTE Scan on yy (actual time=0.027..3109.682 rows=1 loops=1) Filter: (x = 2) Rows Removed by Filter: 9999998 InitPlan 3 (returns $2) -&gt; Aggregate (actual time=812.580..812.580 rows=1 loops=1) -&gt; CTE Scan on yy yy_1 (actual time=0.016..812.575 rows=1 loops=1) Filter: (x = 2) Rows Removed by Filter: 9999998 Planning Time: 0.136 ms Execution Time: 3939.848 ms (17 rows)</code> </pre> <br>  Und jetzt schreiben wir ausdr√ºcklich ein Materialisierungsverbot: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATERIALIZED</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> xytable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> y &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x=<span class="hljs-number"><span class="hljs-number">2</span></span>), ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x=<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><pre> <code class="plaintext hljs">QUERY PLAN --------------------------------------------------------------------------- Result (actual time=0.035..0.035 rows=1 loops=1) InitPlan 1 (returns $0) -&gt; Aggregate (actual time=0.024..0.024 rows=1 loops=1) -&gt; Index Only Scan using xytable_x_y_idx on xytable (actual time=0.019..0.020 rows=1 loops=1) Index Cond: ((x = 2) AND (y &gt; 1)) Heap Fetches: 1 InitPlan 2 (returns $1) -&gt; Aggregate (actual time=0.006..0.006 rows=1 loops=1) -&gt; Index Only Scan using xytable_x_y_idx on xytable cte_1 (actual time=0.004..0.005 rows=1 loops=1) Index Cond: ((x = 2) AND (y &gt; 1)) Heap Fetches: 1 Planning Time: 0.253 ms Execution Time: 0.075 ms (13 rows)</code> </pre> <br><h3>  Das Schreiben von CTEs wird immer ausgef√ºhrt, und CTEs, auf die nicht verwiesen wird, werden nie ausgef√ºhrt. </h3><br>  Dies geht aus dem Plan hervor: not_executed ist nicht enthalten.  Dies gilt f√ºr fr√ºhere Versionen, es ist jedoch zu beachten, dass das Konstrukt (NOT) MATERIALIZED f√ºr den ausf√ºhrbaren Ausdruck in Version 12 gilt. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (COSTS <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> xytable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> y &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>), not_executed <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> xytable), always_executed <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> xytable <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> *) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> yy <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x=<span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">QUERY PLAN ----------------------------- CTE Scan on yy Filter: (x = 2) CTE yy -&gt; Seq Scan on cte Filter: (y &gt; 1) CTE always_executed -&gt; Insert on cte cte_1 -&gt; Result (5 rows)</code> </pre> <br>  Und noch eine Regel: <br><br><h3>  rekursive Abfragen mit WITH werden immer materialisiert. </h3><br>  Es ist immer und nicht standardm√§√üig.  Wenn wir den Optimierer bestellen: NICHT MATERIALISIERT, tritt kein Fehler auf, und die Materialisierung bleibt bestehen.  Dies ist eine gemeinschaftsbewusste Entscheidung. <br><br>  Wir werden das anschauliche Beispiel Hausaufgaben betrachten.  Das ist alles f√ºr heute. <br><br>  <i>In diesem Teil des Berichts √ºber das Neue in CTE werden Beispiele und Fragmente aus dem Bericht ‚ÄûPostgres 12 in Etudes‚Äú verwendet, den Oleg Bartunov am 9. April dieses Jahres bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Saint Highload ++</a> in St. Petersburg las.</i> <br><br>  In der n√§chsten Serie - <b>KNN</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451344/">https://habr.com/ru/post/de451344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451332/index.html">Hepatitis C: "liebevoller Killer"</a></li>
<li><a href="../de451334/index.html">Ank√ºndigung von ML.NET 1.0</a></li>
<li><a href="../de451336/index.html">Einf√ºhrung in die GitHub-Paketregistrierung</a></li>
<li><a href="../de451338/index.html">Der Entwickler der beliebten Linux-Distribution plant, an die B√∂rse zu gehen und sich mit Cloud-L√∂sungen zu befassen</a></li>
<li><a href="../de451340/index.html">Pr√§sentiert von GitHub Package Registry</a></li>
<li><a href="../de451346/index.html">NeoBook: eine Programmierumgebung f√ºr Nicht-Programmierer</a></li>
<li><a href="../de451350/index.html">Verbesserungen an der Visual Studio App Center-Verteilung</a></li>
<li><a href="../de451352/index.html">Visual Studio C ++ - Vorlage IntelliSense wird basierend auf Instanziierungen in Ihrem Code ausgef√ºllt</a></li>
<li><a href="../de451354/index.html">Was ist wichtig und was dringend?</a></li>
<li><a href="../de451356/index.html">Funktionsweise der Komprimierung in einer objektorientierten Speicherarchitektur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>