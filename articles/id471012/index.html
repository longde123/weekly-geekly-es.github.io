<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↘️ 🏇🏾 🤧 Pendekatan teknik untuk pengembangan perangkat lunak. Dari teori ke praktik 👨🏼‍🚀 🧕 🤾🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagaimana cara menguji ide, arsitektur dan algoritma tanpa menulis kode? Bagaimana cara merumuskan dan memverifikasi propertinya? Apa itu pemeriksa mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pendekatan teknik untuk pengembangan perangkat lunak. Dari teori ke praktik</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/471012/"><p> Bagaimana cara menguji ide, arsitektur dan algoritma tanpa menulis kode?  Bagaimana cara merumuskan dan memverifikasi propertinya?  Apa itu pemeriksa model dan pencari model?  Apa yang harus dilakukan ketika kemampuan pengujian tidak cukup? </p><br><p>  Hai  Nama saya Vasil Dyadov, sekarang saya bekerja sebagai programmer di Yandex.Mail, sebelum saya bekerja di Intel, saya sebelumnya telah mengembangkan kode RTL (register transfer level) pada Verilog / VHDL untuk ASIC / FPGA.  Saya telah lama menyukai topik keandalan perangkat lunak dan perangkat keras, matematika, alat, dan metode yang digunakan untuk mengembangkan perangkat lunak dan logika dengan properti yang telah ditentukan sebelumnya. </p><br><p>  Ini adalah artikel kedua dalam seri (artikel pertama di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ), yang dirancang untuk menarik perhatian pengembang dan manajer terhadap pendekatan rekayasa untuk pengembangan perangkat lunak.  Baru-baru ini, ia telah diabaikan dengan tidak patut, meskipun ada perubahan revolusioner dalam pendekatan dan alat pendukungnya. </p><a name="habracut"></a><br><p>  Artikel pertama bagi sebagian pembaca tampaknya terlalu abstrak.  Banyak yang ingin melihat contoh penggunaan pendekatan teknik dan spesifikasi formal dalam kondisi yang dekat dengan kenyataan. </p><br><p>  Pada artikel ini, kita akan melihat contoh aplikasi nyata dari TLA + untuk memecahkan masalah praktis. </p><br><p>  Saya selalu terbuka untuk membahas masalah yang terkait dengan pengembangan perangkat lunak, dan saya akan senang mengobrol dengan pembaca (koordinat untuk komunikasi ada di profil saya). </p><br><h1 id="chto-takoe-tla">  Apa itu TLA +? </h1><br><p>  Untuk mulai dengan, saya ingin mengatakan beberapa kata tentang TLA + dan TLC. </p><br><p>  TLA + (Temporal Logic of Actions + Data) adalah formalisme yang didasarkan pada semacam logika temporal.  Dirancang oleh Leslie Lamport. </p><br><p>  Dalam kerangka formalisme ini, seseorang dapat menggambarkan ruang varian perilaku sistem dan sifat-sifat perilaku ini. </p><br><p>  Untuk kesederhanaan, kita dapat mengasumsikan bahwa perilaku sistem diwakili oleh urutan keadaannya (seperti manik-manik yang tak terbatas, bola pada tali), dan rumus TLA + mendefinisikan kelas rantai yang menggambarkan semua varian yang mungkin dari perilaku sistem (sejumlah besar manik-manik). </p><br><p>  TLA + sangat cocok untuk menggambarkan mesin negara hingga non-deterministik yang berinteraksi (misalnya, interaksi layanan dalam suatu sistem), meskipun ekspresifitasnya cukup untuk menggambarkan banyak hal lain (yang dapat diekspresikan dalam logika orde pertama). </p><br><p>  Dan TLC adalah pemeriksa model keadaan eksplisit: sebuah program yang, sesuai dengan deskripsi sistem TLA + dan rumus properti yang diberikan, beralih ke status sistem dan menentukan apakah sistem memenuhi properti yang ditentukan. </p><br><p>  Biasanya, bekerja dengan TLA + / TLC dibangun dengan cara ini: kami menggambarkan sistem dalam TLA +, memformalkan properti menarik di TLA +, menjalankan TLC untuk verifikasi. </p><br><p>  Karena tidak mudah untuk secara langsung menggambarkan sistem yang lebih atau kurang kompleks dalam TLA +, bahasa tingkat yang lebih tinggi diciptakan - PlusCal, yang diterjemahkan ke dalam TLA +.  PlusCal ada dalam dua cara: dengan sintaks Pascal dan C-like.  Dalam artikel yang saya gunakan sintaksis seperti Pascal, menurut saya lebih baik dibaca.  PlusCal sehubungan dengan TLA + kira-kira sama dengan C sehubungan dengan assembler. </p><br><p>  Di sini kita tidak akan masuk jauh ke dalam teori.  Literatur untuk pencelupan dalam TLA + / PlusCal / TLC disediakan di akhir artikel. </p><br><p>  Tugas utama saya adalah menunjukkan aplikasi TLA + / TLC dalam contoh kehidupan nyata yang sederhana dan mudah dipahami. </p><br><p>  Dalam beberapa komentar pada artikel sebelumnya, saya ditegur bahwa saya tidak melukis fondasi teoritis alat, tetapi tujuan dari seri artikel ini adalah untuk menunjukkan aplikasi praktis alat untuk pendekatan teknik dalam pengembangan perangkat lunak. </p><br><p>  Saya pikir perendaman mendalam dalam teori ini tidak terlalu menarik bagi siapa pun, tetapi jika Anda tertarik, Anda selalu dapat pergi ke PM untuk tautan dan penjelasan, dan sejauh yang saya punya cukup pengetahuan (lagipula, saya bukan ahli teori matematika, tetapi seorang insinyur perangkat lunak), saya akan mencoba menjawab . </p><br><h1 id="postanovka-zadachi">  Pernyataan masalah </h1><br><p>  Pertama, saya akan berbicara sedikit tentang tugas yang digunakan TLA +. </p><br><p>  Tugas tersebut terkait dengan pemrosesan aliran peristiwa.  Yaitu, untuk membuat antrian untuk menyimpan acara dan mengirim pemberitahuan tentang acara ini. </p><br><p>  Gudang data diatur secara fisik berdasarkan DBMS PostgreSQL. </p><br><p>  Hal utama yang perlu Anda ketahui: </p><br><ol><li>  Ada sumber acara.  Untuk tujuan kita, kita dapat membatasi diri pada kenyataan bahwa setiap peristiwa dicirikan oleh waktu di mana prosesnya direncanakan.  Sumber-sumber ini menulis peristiwa ke database.  Biasanya waktu penulisan ke basis data dan waktu pemrosesan yang direncanakan tidak berhubungan dengan cara apa pun. </li><li>  Ada proses koordinasi yang membaca acara dari database dan mengirim pemberitahuan acara mendatang ke komponen-komponen sistem yang harus menanggapi pemberitahuan ini. </li><li>  Persyaratan mendasar: kita tidak boleh kehilangan acara.  Pemberitahuan acara dalam kasus ekstrem dapat diulangi, yaitu harus ada jaminan <em>setidaknya satu kali</em> .  Dalam sistem terdistribusi, sangat sulit untuk menerapkan jaminan <em>hanya sekali</em> (bahkan mungkin tidak mungkin, tetapi perlu dibuktikan) tanpa mekanisme konsensus, dan mereka (setidaknya semua yang saya tahu) memiliki efek yang sangat kuat pada sistem dalam hal keterlambatan dan throughput. </li></ol><br><p>  Sekarang beberapa detail: </p><br><ol><li>  Ada banyak proses sumber, mereka dapat menghasilkan jutaan (dalam kasus terburuk) peristiwa jatuh ke dalam interval waktu yang sempit. </li><li>  Acara dapat dihasilkan baik untuk masa depan dan untuk waktu yang lalu (misalnya, jika proses sumber telah melambat dan merekam acara untuk saat yang telah berlalu). </li><li>  Prioritas pemrosesan acara adalah dalam waktu, mis., Kita harus terlebih dahulu memproses acara yang paling awal. </li><li>  Untuk setiap peristiwa, proses sumber menghasilkan angka acak <em>worker_id</em> , karena peristiwa yang didistribusikan di antara koordinator. </li><li>  Ada beberapa proses koordinasi (skala sesuai dengan kebutuhan berdasarkan beban sistem). </li><li>  Setiap proses koordinator memproses acara untuk set <em>worker_id</em> sendiri, yaitu, karena <em>worker_id,</em> kami menghindari persaingan antara koordinator dan kebutuhan akan kunci. </li></ol><br><p>  Seperti yang dapat dilihat dari deskripsi, kita hanya dapat mempertimbangkan satu proses koordinasi dan tidak memperhitungkan <em>pekerja_id</em> dalam tugas kita. </p><br><p>  Artinya, untuk kesederhanaan, kami menganggap bahwa: </p><br><ol><li>  Ada banyak proses sumber. </li><li>  Proses koordinasi adalah satu. </li></ol><br><p>  Saya akan menjelaskan evolusi ide untuk menyelesaikan masalah ini secara bertahap, sehingga lebih mudah dipahami bagaimana pemikiran berkembang dari implementasi yang sederhana menjadi yang dioptimalkan. </p><br><h1 id="reshenie-v-lob">  Keputusan dahi </h1><br><p>  Kami akan membuat piring untuk acara di mana kami akan menyimpan acara dalam bentuk hanya <em>stempel waktu</em> (kami tidak tertarik pada parameter lain dalam tugas ini).  Mari kita membangun indeks pada bidang <em>cap waktu</em> . </p><br><p>  Tampaknya menjadi solusi yang sangat normal. </p><br><p>  Hanya ada masalah dengan skalabilitas: semakin banyak peristiwa, semakin lambat operasi basis data. </p><br><p>  Acara dapat datang untuk waktu yang lalu, sehingga koordinator harus terus meninjau seluruh waktu. </p><br><p>  Masalahnya dapat dipecahkan secara luas dengan memecah basis data menjadi pecahan oleh waktu, dll. Tapi ini adalah cara yang intensif sumber daya. </p><br><p>  Akibatnya, pekerjaan koordinator akan melambat, karena Anda harus membaca dan menggabungkan data dari beberapa basis data. </p><br><p>  Sulit untuk menerapkan caching acara di koordinator sehingga tidak pergi ke pangkalan untuk memproses setiap acara. </p><br><p>  Lebih banyak basis data - lebih banyak masalah toleransi kesalahan. </p><br><p>  Dan sebagainya. </p><br><p>  Kami tidak akan membahas solusi frontal ini secara terperinci, karena ini sepele dan tidak menarik. </p><br><h1 id="pervaya-optimizaciya">  Optimasi pertama </h1><br><p>  Mari kita lihat bagaimana cara meningkatkan solusi frontal. </p><br><p>  Untuk mengoptimalkan akses ke basis data, Anda dapat sedikit mempersulit indeks, menambahkan pengenal yang meningkat secara monoton ke peristiwa yang akan dihasilkan saat melakukan transaksi dalam basis data.  Artinya, acara sekarang ditandai oleh pasangan <em>{time, id}</em> , di mana <em>waktu</em> adalah waktu di mana acara dijadwalkan, <em>id</em> adalah penghitung yang meningkat secara monoton.  Ada jaminan keunikan <em>id</em> untuk setiap peristiwa, tetapi tidak ada jaminan bahwa nilai <em>id</em> berjalan tanpa lubang (yaitu, bisa ada urutan seperti itu: <em>1</em> , <em>2</em> , <em>7</em> , <em>15</em> ). </p><br><p>  Tampaknya sekarang kita dapat menyimpan pengidentifikasi peristiwa baca terakhir dalam proses koordinator dan, saat mengambil, pilih peristiwa dengan pengidentifikasi lebih besar dari peristiwa yang diproses terakhir. </p><br><p>  Tapi di sini masalah segera muncul: proses sumber dapat merekam acara dengan timestamp jauh di masa depan.  Maka kita harus terus-menerus mempertimbangkan serangkaian peristiwa dengan pengidentifikasi kecil dalam proses koordinasi, waktu pemrosesan yang belum tiba. </p><br><p>  Anda dapat melihat bahwa peristiwa relatif terhadap waktu saat ini dibagi menjadi dua kelas: </p><br><ol><li>  Acara dengan stempel waktu di masa lalu, tetapi dengan pengidentifikasi besar.  Mereka ditulis ke database baru-baru ini, setelah kami memproses interval waktu itu.  Ini adalah acara dengan prioritas tinggi, dan harus diproses terlebih dahulu agar notifikasi - yang sudah terlambat - bahkan tidak terlambat. </li><li>  Acara direkam sekali waktu dengan perangko waktu dekat dengan saat ini.  Peristiwa semacam itu akan memiliki nilai pengidentifikasi rendah. </li></ol><br><p>  Dengan demikian, keadaan saat ini dari proses koordinator ditandai oleh pasangan {state.time, state.id}. </p><br><p>  Ternyata peristiwa dengan prioritas tinggi di sebelah kiri dan di atas titik ini (wilayah merah muda), dan acara normal di sebelah kanan (biru muda): </p><br><p><img src="https://habrastorage.org/webt/n3/x3/q-/n3x3q-kjbxuerrkffffqqnh6hh8.png"></p><br><h2 id="blok-shema">  Bagan arus </h2><br><p>  Algoritma kerja koordinator adalah sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/j6/4d/ge/j64dgeq_jubcbyn4e3zu9ekfasy.png"></p><br><p><img src="https://habrastorage.org/webt/8y/ux/si/8yuxsi4nubi7q5yvclqizezo6xq.png"></p><br><p>  Saat mempelajari algoritme, pertanyaan dapat muncul: </p><br><ol><li>  Bagaimana jika pemrosesan peristiwa normal dimulai dan pada saat itu peristiwa baru di masa lalu tiba (di wilayah merah muda), tidakkah mereka akan hilang?  Jawab: mereka akan diproses dalam siklus berikutnya untuk memproses acara dengan prioritas tinggi.  Mereka tidak bisa tersesat, karena <em>id</em> mereka dijamin lebih tinggi dari state.id. </li><li>  Bagaimana jika setelah memproses semua peristiwa normal - pada saat beralih ke pemrosesan acara prioritas tinggi - peristiwa baru dengan stempel waktu dari interval [state.time, state.time + Delta] tiba, apakah kita kehilangan mereka?  Jawaban: mereka akan jatuh ke area merah muda, karena mereka akan punya <em>waktu</em> &lt;state.time dan <em>id</em> &gt; state.id: mereka tiba baru-baru ini, dan <em>id</em> meningkat secara monoton. </li></ol><br><h2 id="primer-raboty-algoritma">  Contoh Pengoperasian Algoritma </h2><br><p>  Mari kita lihat beberapa langkah dari algoritma ini: </p><br><p><img src="https://habrastorage.org/webt/jl/lf/5v/jllf5vhoz843at6gfrtmjmasppw.png"></p><br><p><img src="https://habrastorage.org/webt/z-/ri/zx/z-rizxhocuxtepr7_wnflvgqm14.png"></p><br><p><img src="https://habrastorage.org/webt/oc/dr/pv/ocdrpv4ozmf-pq_itridvcjookc.png"></p><br><p><img src="https://habrastorage.org/webt/uv/xt/aw/uvxtawqbs5ftd8uzebcwqosdrvw.png"></p><br><p><img src="https://habrastorage.org/webt/uo/_s/cg/uo_scglk7ucb_yze8he8b___wro.png"></p><br><p><img src="https://habrastorage.org/webt/ko/8q/24/ko8q24qizzqz5ddew4jbodavvts.png"></p><br><p><img src="https://habrastorage.org/webt/iw/-f/el/iw-felnslp1mdme-thbu_nicbly.png"></p><br><p><img src="https://habrastorage.org/webt/vf/vs/tz/vfvstz05jy9aowpndr-okgajxpk.png"></p><br><h2 id="model">  Model </h2><br><p>  Kami akan memastikan bahwa algoritme tidak ketinggalan acara dan semua pemberitahuan akan dikirim: kami akan membuat model sederhana dan memverifikasinya. </p><br><p>  Untuk model kami menggunakan TLA +, lebih tepatnya PlusCal, yang diterjemahkan menjadi TLA +. </p><br><pre><code class="plaintext hljs">---------------- MODULE events ---------------- EXTENDS Naturals, FiniteSets, Sequences, TLC (* --algorithm Events \*      \*   (by Daniel Jackson) \* small-scope hypothesis,   \*  ,  ́   \*     \*   \*  : \* Events -   - ,   \*    [time, id], \*     \*      \*   \* Event_Id -    \*   id \* MAX_TIME -  ,   \*   \* TIME_DELTA -   Delta, \*     \*  variables Events = {}, Event_Id = 0, MAX_TIME = 5, TIME_DELTA \in 1..3 define \*   \*   ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x \*  fold_left/fold_right    RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) (*     (  ) *) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) (* :    *) ToSet(S) == {S[i] : i \in DOMAIN(S)} (*  map    *) MapSet(Op(_), S) == {Op(x) : x \in S} (*   *) \*   id  GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) \*   time  GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) (*   SQL  *) \*     \*   ORDER BY EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \*   time, id \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) \* SELECT * FROM events \* WHERE time &lt;= curr_time AND id &gt;= max_id \* ORDER BY time, id SELECT_HIGH_PRIO(state) == LET \*      \* time &lt;= curr_time \* AND id &gt;= maxt_id selected == {e \in Events : /\ e.time &lt;= state.time /\ e.id &gt;= state.id } IN selected \* SELECT * FROM events \* WHERE time &gt; current_time AND time - Time &lt;= delta_time \* ORDER BY time, id SELECT_NORMAL(state, delta_time) == LET selected == {e \in Events : /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } IN selected \* Safety predicate \*       ALL_EVENTS_PROCESSED(state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt;= state.id end define; \*  -   fair process inserter = "Sources" variable n, t; begin forever: while TRUE do \*      get_time: \*     \* ,     , \*    with evt_time \in 0..MAX_TIME do t := evt_time; end with; \*     ; \*   : \* 1.   . \* 2.  ,    \* Event_Id -   , \*     commit: \* either -     either Events := Events \cup {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process coordinator = "Coordinator" variable state = ZERO_EVT, events = {}; begin forever: while TRUE do \*    high_prio: events := SELECT_HIGH_PRIO(state); \*   process_high_prio: \*          , \*    Events, \*       state.id := MAX({state.id} \union GetIds(events)) || \*      , \*      Events := Events \ events || \*  events  , \*      events := {}; \*  -   normal: events := SELECT_NORMAL(state, TIME_DELTA); process_normal: state.time := MAX({state.time} \union GetTimes(events)) || Events := Events \ events || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ================================</code> </pre> <br><p>  Seperti yang Anda lihat, uraiannya relatif kecil, meskipun ada bagian definisi yang agak banyak (definisikan), yang dapat diambil dalam modul terpisah, dan kemudian digunakan kembali. </p><br><p>  Dalam komentar saya mencoba menjelaskan apa yang terjadi dalam model.  Semoga ini <br>  Saya berhasil dan tidak perlu melukis model lebih detail. </p><br><p>  Saya hanya ingin mengklarifikasi satu hal mengenai atomitas transisi antara status dan fitur pemodelan. </p><br><p>  Pemodelan dilakukan dengan melakukan langkah-langkah proses atom.  Dalam satu transisi, satu langkah atom dari suatu proses dilakukan di mana langkah ini dapat dilakukan.  Pilihan langkah dan proses adalah non-deterministik: selama pemodelan, semua rantai langkah atom yang mungkin dari semua proses diurutkan. </p><br><p>  Mungkin timbul pertanyaan: bagaimana dengan memodelkan paralelisme sejati, ketika kita secara bersamaan melakukan beberapa langkah atom dalam proses yang berbeda? </p><br><p>  Pertanyaan ini Leslie Lamport telah lama dijawab dalam buku Specifying Systems dan karya-karya lainnya. </p><br><p>  Saya tidak akan mengutip jawaban sepenuhnya, secara singkat intinya adalah: jika tidak ada skala waktu yang tepat di mana setiap peristiwa terkait dengan momen tertentu, maka tidak ada perbedaan dalam pemodelan peristiwa paralel sebagai peristiwa sekuensial yang terjadi secara non-deterministik, karena kita selalu dapat berasumsi bahwa satu peristiwa terjadi lebih awal daripada yang lain nilai sangat kecil. </p><br><p>  Tetapi yang benar-benar penting adalah alokasi langkah-langkah atom yang kompeten.  Jika jumlahnya terlalu banyak, maka ledakan kombinatorial ruang negara akan terjadi.  Jika Anda mengambil langkah yang lebih sedikit dari yang diperlukan, atau memilihnya secara tidak benar - yaitu, probabilitas kehilangan status / transisi yang tidak valid (mis., Kami akan kehilangan kesalahan pada model). </p><br><p>  Untuk memecah proses menjadi langkah-langkah atom, Anda harus memiliki ide yang bagus tentang bagaimana sistem bekerja dalam hal ketergantungan proses pada data dan mekanisme sinkronisasi. </p><br><p>  Sebagai aturan, proses pemisahan menjadi langkah-langkah atom tidak menyebabkan masalah besar.  Dan jika ya, maka itu menunjukkan kurangnya pemahaman tentang masalah, dan bukan tentang masalah dengan menyusun model dan menulis spesifikasi TLA +.  Ini adalah fitur lain yang sangat berguna dari spesifikasi formal: mereka memerlukan studi dan analisis menyeluruh. <br>  masalah  Sebagai aturan, jika tugas itu bermakna dan dipahami dengan baik, tidak ada masalah dengan formalisasi. </p><br><h2 id="proverka-modeli">  Cek model </h2><br><p>  Untuk pemodelan saya akan menggunakan TLA-toolbox.  Anda tentu saja dapat menjalankan semuanya dari baris perintah, tetapi <em>IDE</em> masih lebih nyaman, terutama untuk mulai belajar tentang pemodelan menggunakan TLA +. </p><br><p>  Penciptaan proyek dijelaskan dengan baik dalam manual, artikel dan buku, tautan yang saya kutip di akhir artikel, jadi saya tidak akan mengulangi lagi.  Satu-satunya hal yang saya akan menarik perhatian Anda adalah pengaturan simulasi. </p><br><p>  TLC adalah <em>pemeriksa model</em> dengan <em>pemeriksaan</em> keadaan eksplisit.  Jelas bahwa ruang negara harus dibatasi oleh batasan yang masuk akal.  Di satu sisi, itu harus cukup besar untuk dapat memverifikasi properti yang menarik bagi kami, dan di sisi lain, cukup kecil untuk simulasi diselesaikan dalam waktu yang dapat diterima menggunakan sumber daya yang dapat diterima. </p><br><p>  Ini adalah titik yang cukup rumit, di sini Anda perlu memahami sifat-sifat sistem dan model.  Tetapi dengan cepat disertai dengan pengalaman.  Sebagai permulaan, Anda cukup menetapkan batas maksimum yang mungkin masih dapat diterima dalam hal waktu simulasi dan sumber daya yang dikonsumsi. </p><br><p>  Ada juga mode memeriksa bukan seluruh ruang negara, tetapi rantai selektif ke kedalaman tertentu.  Terkadang juga mungkin dan perlu untuk digunakan. </p><br><p>  Kami kembali ke pengaturan simulasi. </p><br><p>  Pertama, kami mendefinisikan batasan ruang keadaan sistem.  Keterbatasan diatur di bagian <em>Advanced Options / State constraintaint</em> simulasi simulasi. </p><br><p>  Di sana saya menunjukkan ekspresi TLA +: <code>Cardinality(Events) &lt;= 5 /\ Event_Id &lt;= 5</code> , <br>  di mana Event_Id adalah batas atas pada nilai pengidentifikasi acara, <code>Cardinality(Events)</code> adalah ukuran kumpulan catatan acara (terbatas model dasar <br>  data oleh lima catatan dalam piring). </p><br><p>  Dalam simulasi, TLC hanya akan melihat kondisi di mana rumus ini benar. </p><br><p>  Anda masih dapat mengizinkan transisi status yang valid ( <em>Opsi Lanjut / Kendala Tindakan</em> ), <br>  tapi kami tidak membutuhkannya. </p><br><p>  Selanjutnya, kami menunjukkan rumus TLA + yang menggambarkan sistem kami: <em>Model Overview / Temporal Formula</em> = <code>Spec</code> , di mana <em>Spec</em> adalah nama rumus TLA + yang diautogasi secara otomatis oleh PlusCal (dalam kode model di atas bukan: untuk menghemat ruang, saya tidak mengutip hasil menerjemahkan PlusCal ke TLA +) . </p><br><p>  Pengaturan selanjutnya yang perlu diperhatikan adalah pemeriksaan kebuntuan. <br>  (centang pada <em>Model Overview / Deadlock</em> ).  Ketika bendera ini diaktifkan, TLC akan memeriksa model untuk status "menggantung", yaitu yang tidak ada transisi keluar.  Jika ada keadaan seperti itu di ruang keadaan, ini berarti kesalahan yang jelas dalam model.  Atau di TLC, yang, seperti program non-sepele lainnya, tidak kebal dari kesalahan :) Dalam praktik saya (tidak begitu besar), saya belum menemukan kebuntuan. </p><br><p>  Dan akhirnya, untuk semua pengujian ini dimulai, rumus keamanan dalam <em>Model Overview / Invariants</em> = <code>ALL_EVENTS_PROCESSED(state)</code> . </p><br><p>  TLC akan memverifikasi validitas rumus di setiap negara, dan jika itu menjadi salah, <br>  akan menampilkan pesan kesalahan dan menampilkan urutan status yang menyebabkan kesalahan. </p><br><p>  Setelah memulai TLC, setelah bekerja selama sekitar 8 menit, dilaporkan "Tidak ada kesalahan".  Ini berarti bahwa model diuji dan memenuhi properti yang ditentukan. </p><br><p>  TLC juga menampilkan banyak statistik menarik.  Sebagai contoh, untuk model ini, 7 677 824 keadaan unik diperoleh, secara total, TLC tampak pada 27109 029 negara, diameter ruang keadaan adalah 47 (ini adalah panjang maksimum rantai keadaan sebelum pengulangan, <br>  panjang siklus maksimum dari kondisi tidak berulang dalam kondisi dan grafik transisi). </p><br><p>  Jika kita membagi 27 juta negara bagian menjadi 8 menit, kita memperoleh sekitar 56 ribu negara bagian per detik, yang mungkin kelihatannya tidak terlalu cepat.  Tetapi perlu diingat bahwa saya menjalankan simulasi pada laptop yang bekerja dalam mode hemat energi (saya memaksakan frekuensi inti menjadi 800 MHz, karena saya bepergian pada saat itu di kereta listrik), dan tidak mengoptimalkan model untuk kecepatan simulasi sama sekali. </p><br><p>  Ada banyak cara untuk mempercepat simulasi: mulai dari mem-porting bagian dari kode model TLA + ke Jawa dan menghubungkan ke TLC dengan cepat (berguna untuk mempercepat semua jenis fungsi pembantu) hingga menjalankan TLC di awan dan pada kluster (Dukungan cloud Amazon dan Azure dibangun langsung ke TLC itu sendiri). </p><br><h1 id="vtoraya-optimizaciya">  Optimasi kedua </h1><br><p>  Dalam algoritma sebelumnya, semuanya baik-baik saja, kecuali untuk beberapa masalah: </p><br><ol><li>  Sampai kami memproses semua peristiwa dari zona biru dalam interval <code>[state.time, state.time + Delta]</code> , kami tidak dapat beralih ke acara prioritas tinggi.  Artinya, acara terlambat akan terlambat bahkan lebih.  Dan biasanya penundaan itu tidak dapat diprediksi.  Karena itu, state.time dapat jauh tertinggal dari waktu saat ini, dan ini adalah penyebab masalah berikutnya. </li><li>  Acara yang tiba di wilayah acara normal mungkin terlambat ( <em>id</em> &gt; state.id).  Mereka sudah menjadi prioritas tinggi dan harus dianggap peristiwa dari wilayah merah muda, dan kami masih menganggapnya normal dan memperlakukannya seperti biasa. </li><li>  Sulit untuk mengatur penyimpanan acara caching dan cache (membaca dari database). </li></ol><br><p>  Jika dua poin pertama jelas, maka yang ketiga mungkin akan memunculkan sebagian besar pertanyaan.  Mari kita bahas lebih detail. </p><br><p>  Misalkan kita ingin terlebih dahulu membaca sejumlah peristiwa tetap ke dalam memori dan kemudian memprosesnya. </p><br><p>  Setelah diproses, kami ingin menandai peristiwa dalam database dengan kueri blok yang diproses, karena jika Anda bekerja bukan dengan blok, tetapi dengan peristiwa tunggal, maka tidak akan ada keuntungan besar dari caching. </p><br><p>  Misalkan kita telah memproses sebagian dari blok dan ingin menambah cache.  Kemudian, jika terlambat acara prioritas tinggi tiba selama pemrosesan, kami dapat memprosesnya lebih awal. </p><br><p>  Artinya, sangat diinginkan untuk dapat membaca peristiwa dalam blok kecil untuk memproses yang terlambat secepat mungkin, tetapi untuk memperbarui atribut pemrosesan dalam database dengan blok besar sekaligus - untuk efisiensi. </p><br><p>  Apa yang harus dilakukan dalam kasus ini? </p><br><p>  Cobalah untuk bekerja dengan database dalam blok kecil dengan area biru dan merah muda dan pindahkan titik negara bagian dalam langkah-langkah kecil. </p><br><p>  Dengan demikian, cache diperkenalkan dan dibaca ke dalamnya dari basis data potongan data, setelah masing-masing membaca, titik status digeser agar tidak membaca kembali peristiwa yang sudah dibaca. </p><br><p>  Sekarang algoritme telah menjadi sedikit lebih rumit, kami mulai membaca dalam porsi terbatas. </p><br><h2 id="blok-shema-1">  Bagan arus </h2><br><p><img src="https://habrastorage.org/webt/as/8n/qk/as8nqk0dmos8bsiwiigzphb7gns.png"></p><br><p><img src="https://habrastorage.org/webt/wn/9x/yx/wn9xyxfi4j2021hibcqxe3abhn8.png"></p><br><p>  Dalam algoritma ini, dapat dilihat bahwa karena pembatasan pada blok peristiwa yang dapat dibaca, penundaan maksimum dalam transisi dari pemrosesan prioritas rendah ke pemrosesan prioritas tinggi akan sama dengan waktu pemrosesan maksimum blok. </p><br><p>  Yaitu, sekarang kita dapat membaca peristiwa ke dalam cache dalam blok kecil, dan mengontrol penundaan maksimum dalam transisi untuk memproses peristiwa prioritas tinggi melalui kontrol ukuran blok maksimum untuk membaca. </p><br><h2 id="primer-raboty-algoritma-1">  Contoh Pengoperasian Algoritma </h2><br><p>  Mari kita lihat algoritma dalam pekerjaan, dalam langkah-langkah.  Untuk kenyamanan, ambil <code>LIMIT = 2</code> . </p><br><p><img src="https://habrastorage.org/webt/-i/u8/qz/-iu8qzxfabbn9gcig_ekb1xhabu.png"></p><br><p><img src="https://habrastorage.org/webt/3x/if/ju/3xifju7ktzac6eyyutbhfanpufs.png"></p><br><p><img src="https://habrastorage.org/webt/ab/dg/o7/abdgo7ieinh8ddx6tnthfcsrwre.png"></p><br><p><img src="https://habrastorage.org/webt/ei/qg/al/eiqgal0lfwfiwtdltnb-e1bjyc0.png"></p><br><p><img src="https://habrastorage.org/webt/hp/2i/kd/hp2ikd4mgcqsswoiwwexz_kmp-e.png"></p><br><p><img src="https://habrastorage.org/webt/tq/ct/fv/tqctfvtnrqo939zqut2-8lwjale.png"></p><br><p><img src="https://habrastorage.org/webt/yk/3j/jk/yk3jjkf9htxfmdvwsa1dyrogqqo.png"></p><br><p><img src="https://habrastorage.org/webt/ym/9d/vt/ym9dvt1_ykho82n4xhxwtlbkeow.png"></p><br><p>  Ternyata masalah terpecahkan?  Tapi tidak.  (Jelas bahwa jika masalah telah dipecahkan sepenuhnya pada tahap ini, maka <br>  artikel ini tidak akan :)) </p><br><h2 id="oshibka">  Kesalahannya? </h2><br><p>  Dalam bentuk ini, algoritma bekerja untuk waktu yang agak lama.  Semua tes berjalan dengan baik.  Tidak ada masalah dalam produksi juga. </p><br><p>  Tetapi pengembang algoritma dan implementasinya (kolega saya Peter Reznikov) sangat berpengalaman, dan dia secara intuitif merasa ada sesuatu yang salah di sini.  Oleh karena itu, pemeriksa dibuat di sebelah kode utama, yang diperiksa sesekali pada timer untuk melihat apakah ada peristiwa yang terlewat, dan <br>  jika ada, saya memprosesnya. </p><br><p>  Dalam bentuk ini, sistem bekerja dengan sukses.  Benar, tidak ada yang menyimpan statistik tentang jumlah acara yang dipilih oleh pemeriksa.  Jadi kami, sayangnya, tidak tahu berapa banyak kegagalan yang terkait dengan pemrosesan acara yang tidak tepat waktu. </p><br><p>  Saya menerapkan antrian objek terikat waktu yang serupa.  Membahas implementasi dan optimalisasi algoritma dengan Peter Reznikov, kami berbicara tentang algoritma ini untuk bekerja dengan acara.  Mereka meragukan bahwa algoritme itu benar.  Kami memutuskan untuk membuat model kecil untuk mengkonfirmasi atau menghilangkan keraguan.  Akibatnya, kami menemukan kesalahan. </p><br><h2 id="model-1">  Model </h2><br><p>  Sebelum membongkar jejak dengan kesalahan, saya akan memberikan kode sumber model di mana kesalahan terdeteksi. </p><br><p>  Perbedaan dari model sebelumnya sangat kecil, hanya ada batasan pada ukuran blok baca: operator Batas ditambahkan dan, oleh karena itu, operator pemilihan acara diubah. </p><br><p>  Untuk menghemat ruang, saya hanya meninggalkan komentar pada bagian-bagian model yang berubah. </p><br><pre> <code class="plaintext hljs">---------------- MODULE events ---------------- EXTENDS Naturals, FiniteSets, Sequences, TLC (* --algorithm Events \*    LIMIT, \*     \*     \*   variables Events = {}, Event_Id = 0, MAX_TIME = 5, LIMIT \in 1..3, TIME_DELTA \in 1..2 define ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) ToSet(S) == {S[i] : i \in DOMAIN(S)} MapSet(Op(_), S) == {Op(x) : x \in S} GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) Limit(S, limit) == LET amount == MIN({limit, Len(S)}) result == IF amount &gt; 0 THEN SubSeq(S, 1, amount) ELSE &lt;&lt; &gt;&gt; IN result \* SELECT * FROM events \* WHERE time &lt;= curr_time AND id &gt; max_id \* ORDER BY id \* LIMIT limit SELECT_HIGH_PRIO(state, limit) == LET selected == {e \in Events : /\ e.time &lt;= state.time /\ e.id &gt;= state.id } \*   Id sorted == SortSeq(ToSeq(selected), EventsOrderById) \*    limited == Limit(sorted, limit) IN ToSet(limited) \* SELECT * FROM events \* WHERE time &gt; current_time \* AND time - Time &lt;= delta_time \* ORDER BY time, id \* LIMIT limit SELECT_NORMAL(state, delta_time, limit) == LET selected == {e \in Events: /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } \*   sorted == SortSeq(ToSeq(selected), EventsOrder) \*   limited == Limit(sorted, limit) IN ToSet(limited) ALL_EVENTS_PROCESSED(state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt;= state.id end define; fair process inserter = "Sources" variable t; begin forever: while TRUE do get_time: with evt_time \in 0..MAX_TIME do t := evt_time; end with; commit: either Events := Events \union {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process event_processor = "Event_processor" variable state = ZERO_EVT, events = {}; begin forever: while TRUE do select: events := LET evts_high_prio == SELECT_HIGH_PRIO(state, LIMIT) new_limit == LIMIT - Cardinality(evts_high_prio) evts_normal == SELECT_NORMAL(state, TIME_DELTA, new_limit) IN evts_high_prio \union evts_normal; proc_evts: Events := Events \ events || state := [ time |-&gt; MAX({state.time} \union GetTimes(events)), id |-&gt; MAX({state.id} \union GetIds(events))] || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ===================================================</code> </pre> <br><p>  Pembaca yang penuh perhatian mungkin memperhatikan bahwa, selain memperkenalkan Limit, label pada event_processor juga telah diubah.  Tujuannya adalah sedikit lebih baik untuk mensimulasikan kode nyata yang dieksekusi oleh dua pilihan dalam satu transaksi, yaitu, pemilihan peristiwa dapat dikatakan dilakukan secara atom. </p><br><p>  Nah, dan jika kita menemukan kesalahan dalam model dengan operasi atom yang lebih besar, ini praktis menjamin bahwa kesalahan yang sama terjadi pada model yang sama, tetapi dengan langkah-langkah atom yang lebih kecil (pernyataan yang agak kuat, tapi saya pikir itu intuitif; meskipun itu harus baik jika tidak terbukti, kemudian diperiksa pada berbagai pilihan model). </p><br><h2 id="proverka-modeli-1">  Cek model </h2><br><p>  Kami memulai simulasi dengan parameter yang sama seperti pada perwujudan pertama. </p><br><p>  Dan kami mendapatkan pelanggaran pada properti ALL_EVENTS_PROCESSED pada langkah ke-19 dari simulasi saat mencari dengan lebar. </p><br><p>  Untuk data awal yang diberikan (ini adalah ruang keadaan yang sangat kecil), kesalahan pada langkah ke-19 menunjukkan bahwa kesalahan itu sangat jarang dan sulit untuk dideteksi, karena sebelum itu semua rantai negara dengan panjang kurang dari 19 diperiksa. </p><br><p>  Karenanya, kesalahan ini sulit ditangkap dalam tes.  Hanya jika Anda tahu ke mana harus mencari, dan secara khusus pilih tes dan pondok sementara. </p><br><p>  Saya tidak akan membawa seluruh rute demi menghemat ruang dan waktu.  Berikut adalah segmen dari beberapa negara bersama dengan kesalahan: </p><br><p><img src="https://habrastorage.org/webt/1g/xq/en/1gxqen3cvdftawczsxb5apskzlc.png"></p><br><p><img src="https://habrastorage.org/webt/5r/b6/ml/5rb6mlga8u0rfalc1_3klnb6-ky.png"></p><br><p><img src="https://habrastorage.org/webt/5_/cz/n4/5_czn4pqrkbkhy6uocf3zllz39w.png"></p><br><p><img src="https://habrastorage.org/webt/_v/s8/d6/_vs8d6feegcimnw9bla8ylm-878.png"></p><br><p><img src="https://habrastorage.org/webt/wo/0j/qu/wo0jquth7jszanamlk7l3dpkspc.png"></p><br><h2 id="analiz-i-ispravlenie">  Analisis dan Koreksi </h2><br><p>  Apa yang terjadi </p><br><p>  Seperti yang dapat Anda lihat, kesalahan itu memanifestasikan dirinya dalam kenyataan bahwa kami melewatkan acara {2, 3} karena fakta bahwa batas berakhir pada acara {2, 1}, dan setelah itu kami mengubah status koordinator.  Ini bisa terjadi hanya jika pada suatu saat ada beberapa peristiwa. </p><br><p>  Itu sebabnya kesalahan sulit dipahami dalam tes.  Untuk manifestasinya, perlu bahwa hal-hal yang sangat jarang terjadi bersamaan: </p><br><ol><li>  Beberapa peristiwa mencapai titik waktu yang sama. </li><li>  Batas pemilihan acara berakhir sebelum saat membaca semua acara ini. </li></ol><br><p>  Kesalahan dapat relatif mudah diperbaiki jika keadaan koordinator sedikit diperluas: tambahkan waktu dan pengidentifikasi acara baca terakhir dari area acara normal dengan id maksimum jika waktu acara ini sesuai dengan nilai state.time berikutnya. </p><br><p>  Jika tidak ada acara seperti itu, maka kami mengatur status ekstra (extra_state) ke keadaan tidak valid (UNDEF_EVT) dan tidak memperhitungkannya saat bekerja. </p><br><p>  Peristiwa-peristiwa dari wilayah normal yang tidak diproses pada langkah sebelumnya dari koordinator, kami akan mempertimbangkan prioritas yang sudah tinggi dan dengan demikian memperbaiki pemilihan predikat prioritas tinggi dan keselamatan. </p><br><p>  Dimungkinkan untuk memperkenalkan area lain yang menengah antara prioritas tinggi dan normal, dan mengubah algoritme.  Pertama, ia akan memproses yang berprioritas tinggi, kemudian yang menengah, dan kemudian beralih ke yang normal dengan perubahan status selanjutnya. </p><br><p>  Tetapi perubahan seperti itu akan menghasilkan volume refactoring yang lebih besar dengan manfaat yang tidak terlihat (algoritme akan sedikit lebih jelas; keuntungan lainnya tidak langsung terlihat). </p><br><p>  Oleh karena itu, kami memutuskan untuk hanya sedikit menyesuaikan keadaan saat ini dan pemilihan acara dari database. </p><br><h2 id="skorrektirovannaya-model">  Model yang disesuaikan </h2><br><p>  Berikut adalah model yang diperbaiki. </p><br><pre> <code class="plaintext hljs">------------------- MODULE events ------------------- EXTENDS Naturals, FiniteSets, Sequences, TLC \*        CONSTANTS MAX_TIME, LIMIT, TIME_DELTA (* --algorithm Events variables Events = {}, Limit \in LIMIT, Delta \in TIME_DELTA, Event_Id = 0 define \*    \*  ,   extra_state UNDEF_EVT == [time |-&gt; MAX_TIME + 1, id |-&gt; 0] ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) ToSet(S) == {S[i] : i \in DOMAIN(S)} MapSet(Op(_), S) == {Op(x) : x \in S} GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) TakeN(S, limit) == LET amount == MIN({limit, Len(S)}) result == IF amount &gt; 0 THEN SubSeq(S, 1, amount) ELSE &lt;&lt; &gt;&gt; IN result (* SELECT * FROM events WHERE time &lt;= curr_time AND id &gt; max_id ORDER BY id Limit limit *) SELECT_HIGH_PRIO(state, limit, extra_state) == LET \*      \* time &lt;= curr_time \* AND id &gt; maxt_id selected == {e \in Events : \/ /\ e.time &lt;= state.time /\ e.id &gt;= state.id \/ /\ e.time = extra_state.time /\ e.id &gt; extra_state.id} sorted == \*  SortSeq(ToSeq(selected), EventsOrderById) limited == TakeN(sorted, limit) IN ToSet(limited) SELECT_NORMAL(state, delta_time, limit) == LET selected == {e \in Events : /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } sorted == SortSeq(ToSeq(selected), EventsOrder) limited == TakeN(sorted, limit) IN ToSet(limited) \*    extra_state UpdateExtraState(events, state, extra_state) == LET exact == {evt \in events : evt.time = state.time} IN IF exact # {} THEN CHOOSE evt \in exact : \A e \in exact: e.id &lt;= evt.id ELSE UNDEF_EVT \*    extra_state ALL_EVENTS_PROCESSED(state, extra_state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt; state.id \/ /\ e.time = extra_state.time /\ e.id &gt; extra_state.id end define; fair process inserter = "Sources" variable t; begin forever: while TRUE do get_time: with evt_time \in 0..MAX_TIME do t := evt_time; end with; commit: either Events := Events \union {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process event_processor = "Event_processor" variable events = {}, state = ZERO_EVT, extra_state = UNDEF_EVT; begin forever: while TRUE do select: events := LET evts_high_prio == SELECT_HIGH_PRIO(state, Limit, extra_state) new_limit == Limit - Cardinality(evts_high_prio) evts_normal == SELECT_NORMAL(state, Delta, new_limit) IN evts_high_prio \union evts_normal; proc_evts: Events := Events \ events || state := [ time |-&gt; MAX({state.time} \union GetTimes(events)), id |-&gt; MAX({state.id} \union GetIds(events)) ]; extra_state := UpdateExtraState(events, state, extra_state) || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ===================================================</code> </pre> <br><p>  Seperti yang Anda lihat, perubahannya sangat kecil: </p><br><ol><li>  Menambahkan data ekstra ke status extra_state. </li><li>  Mengubah pemilihan acara dengan prioritas tinggi. </li><li>   UpdateExtraState   extra_state. </li><li>  <em>safety</em> -    . </li></ol><br><h2 id="modelirovanie">  </h2><br><p>    ,   . ,      (,  ,    ,     ). <br>       ,       ,  TLA+/TLC .  :) </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>     , ,     ( , ,  ,    ). </p><br><p>  ,            ,        TLA+/TLC,     . ,    . </p><br><p>         TLA+/TLC  ,   ,           ( ,     )  . </p><br><p>  ,     ,     ,  TLA+/TLC                . </p><br><h1 id="bibliografiya">  </h1><br><h2 id="knigi">  Buku </h2><br><h3 id="dlya-pogruzheniya-v-oblast">     </h3><br><p>   ,    ,   ,    .      . </p><br><ol><li><p> Michael Jackson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Problem Frames: Analysing &amp; Structuring Software Development Problems</a> </p><br><p>      (  !),     .   ,   .      ,        . </p><br></li><li><p> Hillel Wayne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Practical TLA+: Planning Driven Development</a> </p><br><p>     TLA+/PlusCal     .  ,    .      .         :    . </p><br></li><li><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MODEL CHECKING.      </a> </p><br><p>     .  ,    ,  .      ,            . </p><br></li><li><p> Leslie Lamport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers</a> </p><br><p>    TLA+.   ,   .      :     ,   .  ,     TLA+  ,    . </p><br></li></ol><br><h3 id="primery-iz-promyshlennosti">    </h3><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Formal Development of a Network-Centric RTOS</a> </p><br><p>    TLA+          ( <em>RTOS</em> )       TLC. </p><br><p>      ,      .   ,   TLA+      ,             ,    <em>RTOS</em>   — Virtuoso.       ,       . </p><br><p>          ,           (, ,  ,  ,    ). </p><br></li><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">w Amazon Web Services Uses Formal Methods</a> </p><br><p>   TLA+      AWS.        : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://lamport.azurewebsites.net/tla/amazon-excerpt.html</a> </p><br></li></ol><br><h2 id="internet">  </h2><br><h3 id="blogi">  Blog </h3><br><ol><li><p> Hillel Wayne (  "Practical TLA+") <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> </p><br><p>     .  ,  .   ,  -   . </p><br></li><li><p> Ron Pressler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> </p><br><p>   .        .  ,      TLA+.       TLA+,    <em>computer</em> <em>science</em>    . </p><br></li><li><p> Leslie Lamport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> </p><br><p>      TLA+  <em>computer</em> <em>science</em> .  <em>TLA+</em>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p><br></li></ol><br><h3 id="prezentacii-i-videokursy">    </h3><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">. . , . . , . . .      </a> </p><br><p>  ,   ,       . </p><br></li><li><p>   TLA+,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> </p><br><p>   ,     TLA+. ,       TLA+. </p><br></li><li><p> Hillel Wayne </p><br><p>      Hillel Wayne  .      . </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Two Hardest Problems in CS (June 5, 2018)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Everything about distributed systems is terrible | Code Mesh LDN 18</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Designing Distributed Systems with TLA+ | Øredev 2018</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tackling Concurrency Bugs with TLA+</a> </li></ul><br></li><li><p> Ron Pressler </p><br><p>  ,   Hillel Wayne,     .  ,    . Ron Pressler      . ́       ,    ,     . </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Practice and Theory of TLA+</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Why Writing Correct Software Is Hard and Why Math (Alone) Won't Help Us</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">On the Nature of Abstraction</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Finite of sense &amp; infinite of thought | Code Mesh LDN 18</a> </li></ul><br></li></ol><br><h3 id="modelirovanie-1">  </h3><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TLA toolbox</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TLAPS</a> :        TLA+  <br>           .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alloy Analyzer</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471012/">https://habr.com/ru/post/id471012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471000/index.html">Mainan kayu, bagian terakhir - 1997</a></li>
<li><a href="../id471004/index.html">Mainan kayu - epilog yang tetap dipakukan di langit-langit</a></li>
<li><a href="../id471006/index.html">$ 500 per bulan: apa yang digunakan oleh penerima pendapatan dasar tanpa syarat?</a></li>
<li><a href="../id471008/index.html">Mari kita bicara tentang pemantauan: rekaman langsung podcast Devops Deflope dengan New Relic pada pertemuan pada 23 Oktober</a></li>
<li><a href="../id471010/index.html">Algoritma Grover dan Pencarian Data</a></li>
<li><a href="../id471014/index.html">Kami membuat drone air otonom, atau ketika saya bermimpi membantu Baikal, tapi saya bukan Gazprom. Bagian 1</a></li>
<li><a href="../id471016/index.html">Desain Basis Data. Praktik terbaik</a></li>
<li><a href="../id471018/index.html">Perbandingan kinerja PC dan smartphone, termasuk iPhone 11</a></li>
<li><a href="../id471020/index.html">Cara menemukan bug di mikroprosesor yang dirilis tiga puluh lima tahun yang lalu</a></li>
<li><a href="../id471022/index.html">Mengungkap rahasia fisika berusia 140 tahun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>