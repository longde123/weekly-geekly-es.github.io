<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìä üçÄ ü§¥üèø Angulareact üêç üë©üèº‚Äçü§ù‚Äçüë®üèø üíÖüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya punya masalah. Aplikasi ini ditulis dalam Angular, dan pustaka komponen di Bereaksi. Mengkloning perpustakaan terlalu mahal. Jadi, Anda perlu men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angulareact</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468063/"><p>  Saya punya masalah.  Aplikasi ini ditulis dalam Angular, dan pustaka komponen di Bereaksi.  Mengkloning perpustakaan terlalu mahal.  Jadi, Anda perlu menggunakan komponen Bereaksi dalam aplikasi Angular dengan biaya minimal.  Kami mencari cara untuk melakukannya. </p><a name="habracut"></a><br><h1 id="diskleymer">  Penafian </h1><br><p>  Saya bukan spesialis di Angular sama sekali.  Saya mencoba versi pertama pada tahun 2017, kemudian melihat sedikit pada AngularDart, dan sekarang saya telah menemukan dukungan aplikasi pada versi modern dari framework.  Jika Anda merasa bahwa keputusan itu aneh atau "dari dunia lain", itu tampaknya tidak bagi Anda. </p><br><p>  Solusi yang disajikan dalam artikel ini belum diuji dalam proyek nyata dan hanya konsep.  Gunakan dengan risiko Anda sendiri. </p><br><h1 id="problema">  Masalah </h1><br><p>  Saya sekarang mendukung dan mengembangkan aplikasi yang cukup besar pada Angular 8. Plus, ada beberapa aplikasi kecil di Bereaksi dan berencana untuk membangun selusin lebih (juga di Bereaksi).  Semua aplikasi digunakan untuk kebutuhan internal perusahaan dan harus dalam gaya yang sama.  Satu-satunya cara logis adalah membuat pustaka komponen dengan dasar di mana Anda dapat dengan cepat membangun aplikasi apa pun. </p><br><p>  Tetapi dalam situasi saat ini, Anda tidak bisa hanya mengambil dan menulis perpustakaan di Bereaksi.  Anda tidak dapat menggunakannya dalam aplikasi terbesar - ini ditulis dalam Angular.  Saya bukan orang pertama yang menghadapi masalah ini.  Hal pertama yang ada di Google untuk "bereaksi dalam sudut" adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori Microsoft</a> .  Sayangnya, solusi ini tidak memiliki dokumentasi sama sekali.  Plus, dalam readme proyek itu jelas dikatakan bahwa paket tersebut digunakan secara internal oleh Microsoft, tim tidak memiliki rencana yang jelas untuk pengembangannya dan hanya risiko Anda sendiri untuk menggunakannya.  Saya belum siap untuk menyeret paket ambigu ke dalam produksi, jadi saya memutuskan untuk menulis sepeda </p><br><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/829e9e3b-1673-4067-9278-982f01e95d52/__2019-09-18__20.15.04.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45FTZDIACS%2F20190919%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190919T122008Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjENv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCwuWc5hbwOjFa2gBX2qSa%2BrPvZmF79lBk8yc%2FXnhR5OgIgVv7r%2B%2FVK4eHtMZ4VXucxi3NFCVA8KGyzNOFcqsvvb0gq4wMIpP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDIQt1CA3IZ1diLWvKSq3A%2F7R4EFxWqz0ZQ3cWqbpSl7qAIZE6%2BRc8fFwpNm25pdxvEdKJXJAPDdmXjAfCd0QSedX2LOyOJ9aBjD1QXuPFe1EbMLho%2FztYBqFQyGw10VbM46reb9hex75UyV9W%2F4n%2Fx9A112LY%2FcYImpbCNz7C03aCnSybewd8uI6CbFQxR2T%2FttEuN%2BM7MINO3IiyviPzfxQH1%2FOh6%2BXJ%2FXnn7Hqy1cl07wbV9etV2Ul%2Bp71IAlE4sBaP2ZLCasQEwCbMS7dqxuQBD2vIaoW6xePr5UnIirdOwoTHmyCgkUvJbcMC159%2Bo2MXfWmwyYq3Zfv%2B%2FVoJAwiaSewM1LSls%2FUkj4TF0ILK58Isc2qFD9%2F07VV%2BoA9i0ppr%2BZhyxhLr02OftacApW638RhHUT2I%2B0DqSRdtLpRA0%2FJzJKfUvTuWY0P5sA7ulAEzvCZe3MuavIxQY9mAGyRJja%2BfRx6l3W49Gfk2Fdzv7054xQ0nJaaoaOrM7jR7taTU8HzoGnH1M3Ap0UXLu%2FVXYWFot78zsa0aDta2RIREzoL%2FDb7i8Sm6Ec5gPeTu7udP%2F2Zrgyidr0wPy1FEir0wGZJYj4wpLCN7AU6tAGdmaM%2F3OTcKirVsB97LangLG7SvqYaEZ0QCtZjQ1ismZ2d0epUNHq8J%2FbnEpM4DugcaKiXTKgLERS6nk61%2Bz3BEKh3GGUVz%2FS%2BYpHJEAo5QsoHBXiwvWlxEfnDVvYkyob2qghv0NjLp9ljkrHLnzgFGLAasNIDiPZT69zfBffDJwBhDVp6p7s3LefdevJiv5lMaMm3P272igMJjgxTiSCHiJrUVMvSgZ9PLY9ZICyyJCc2z60%3D&amp;X-Amz-Signature=5102f76091725ed13505a80485bbb95a0bcf5fc1ec2205aad9525c46ad70b09e&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22__2019-09-18__20.15.04.png%22" alt="gambar"></p><br><p>  Situs resmi @ angular-react / core </p><br><h1 id="reshenie">  Solusi </h1><br><p>  Bereaksi adalah perpustakaan yang dirancang untuk memecahkan satu masalah khusus - mengelola pohon DOM dokumen.  Kita bisa meletakkan elemen Bereaksi apa pun di simpul DOM yang arbitrer. </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Hello = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;p&gt;Hello, React!<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Hello</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, document.getElementById('#hello'));</span></span></code> </pre> <br><p>  Selain itu, tidak ada batasan pada panggilan berulang ke fungsi <code>render</code> .  Artinya, dimungkinkan untuk membuat setiap komponen secara terpisah di DOM.  Dan inilah yang akan membantu mengambil langkah pertama dalam integrasi. </p><br><h2 id="podgotovka">  Persiapan </h2><br><p>  Pertama-tama, penting untuk dipahami bahwa Bereaksi secara default tidak memerlukan kondisi khusus selama perakitan.  Jika Anda tidak menggunakan JSX, tetapi membatasi <code>createElement</code> untuk memanggil <code>createElement</code> , maka Anda tidak perlu mengambil langkah apa pun, semuanya hanya akan berjalan di luar kotak. </p><br><p>  Tapi, tentu saja, kita terbiasa menggunakan JSX dan tidak mau kehilangan itu.  Untungnya, Angular menggunakan TypeScript secara default, yang dapat mengubah JSX menjadi panggilan fungsi.  Anda hanya perlu menambahkan flag compiler <code>--jsx=react</code> atau di <code>tsconfig.json</code> di bagian <code>compilerOptions</code> tambahkan baris <code>"jsx": "react"</code> . </p><br><h2 id="integraciya-otobrazheniya">  Integrasi Tampilan </h2><br><p>  Untuk memulai, kita perlu memastikan bahwa komponen Bereaksi ditampilkan di dalam aplikasi Angular.  Yaitu, sehingga elemen DOM yang dihasilkan dari pekerjaan perpustakaan mengambil tempat yang tepat di pohon elemen. </p><br><p>  Setiap kali Anda menggunakan komponen Bereaksi, berpikir untuk memanggil fungsi <code>render</code> dengan benar terlalu sulit.  Plus, di masa depan kita perlu mengintegrasikan komponen di tingkat data dan pengendali acara.  Dalam hal ini, masuk akal untuk membuat komponen Angular yang akan merangkum seluruh logika membuat dan mengendalikan elemen Bereaksi. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Hello.tsx export const Hello = () =&gt; &lt;p&gt;Hello, React!&lt;/p&gt;; // hello.component.ts import { createElement } from 'react'; import { render } from 'react-dom'; import { Hello } from './Hello'; @Component({ selector: 'app-hello', template: `&lt;div #react&gt;&lt;/div&gt;`, }) export class HelloComponent implements OnInit { @ViewChild('react', { read: ElementRef, static: true }) ref: ElementRef; ngOnInit() { this.renderReactElement(); } private renderReactElement() { const props = {}; const reactElement = createElement(Hello, props); render(reactElement, this.ref.nativeElement); } }</span></span></code> </pre> <br><p>  Kode komponen Angular sangat sederhana.  Itu sendiri hanya membuat wadah kosong dan mendapat tautan ke sana.  Dalam hal ini, pada saat inisialisasi, render dari elemen React disebut.  Itu dibuat menggunakan fungsi <code>createElement</code> dan diteruskan ke fungsi <code>render</code> , yang menempatkannya di simpul DOM yang dibuat dari Angular.  Anda dapat menggunakan komponen seperti itu seperti komponen Angulat lainnya, tanpa syarat khusus. </p><br><h2 id="integraciya-vhodnyh-dannyh">  Integrasi Input </h2><br><p>  Biasanya, saat menampilkan elemen antarmuka, Anda perlu mentransfer data kepada mereka.  Semuanya di sini juga cukup membosankan - saat memanggil <code>createElement</code> Anda dapat meneruskan data apa pun melalui alat peraga ke komponen. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Hello.tsx export const Hello = ({ name }) =&gt; &lt;p&gt;Hello, {name}!&lt;/p&gt;; // hello.component.ts import { createElement } from 'react'; import { render } from 'react-dom'; import { Hello } from './Hello'; @Component({ selector: 'app-hello', template: `&lt;div #react&gt;&lt;/div&gt;`, }) export class HelloComponent implements OnInit { @ViewChild('react', { read: ElementRef, static: true }) ref: ElementRef; @Input() name: string; ngOnInit() { this.renderReactElement(); } private renderReactElement() { const props = { name: this.name, }; const reactElement = createElement(Hello, props); render(reactElement, this.ref.nativeElement); } }</span></span></code> </pre> <br><p>  Sekarang Anda dapat meneruskan string <code>name</code> ke komponen Angular, itu akan jatuh ke komponen Bereaksi dan akan diberikan.  Tetapi jika garis berubah karena beberapa alasan eksternal, Bereaksi tidak akan mengetahuinya dan kami akan mendapatkan tampilan yang ketinggalan zaman.  Angular memiliki <code>ngOnChanges</code> siklus hidup <code>ngOnChanges</code> yang memungkinkan Anda untuk melacak perubahan dalam parameter komponen dan reaksi terhadapnya.  Kami mengimplementasikan antarmuka <code>OnChanges</code> dan menambahkan metode: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... ngOnChanges(_: SimpleChanges) { this.renderReactElement(); } // ...</span></span></code> </pre> <br><p>  Cukup memanggil fungsi <code>render</code> lagi dengan elemen yang dibuat dari properti baru, dan perpustakaan itu sendiri akan mencari tahu bagian mana dari pohon yang harus dirender.  Status lokal di dalam komponen juga akan dipertahankan. </p><br><p>  Setelah manipulasi ini, komponen Sudut dapat digunakan dengan cara biasa dan meneruskan data ke sana. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Angular"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Untuk pekerjaan yang lebih baik dengan memperbarui komponen, Anda dapat melihat ke arah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">strategi deteksi perubahan</a> .  Saya tidak akan mempertimbangkan ini secara rinci. </p><br><h2 id="integraciya-vyhodnyh-dannyh">  Integrasi Output </h2><br><p>  Masalah lain tetap - reaksi aplikasi terhadap peristiwa di dalam komponen-React.  Mari kita <code>@Output</code> dekorator <code>@Output</code> dan meneruskan panggilan balik ke komponen melalui alat peraga. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Hello.tsx export const Hello = ({ name, onClick }) =&gt; ( &lt;div&gt; &lt;p&gt;Hello, {name}!&lt;/p&gt; &lt;button onClick={onClick}&gt;Say "hello"&lt;/button&gt; &lt;/div&gt; ); // hello.component.ts import { createElement } from 'react'; import { render } from 'react-dom'; import { Hello } from './Hello'; @Component({ selector: 'app-hello', template: `&lt;div #react&gt;&lt;/div&gt;`, }) export class HelloComponent implements OnInit { @ViewChild('react', { read: ElementRef, static: true }) ref: ElementRef; @Input() name: string; @Output() click = new EventEmitter&lt;string&gt;(); ngOnInit() { this.renderReactElement(); } private renderReactElement() { const props = { name: this.name, onClick: () =&gt; this.lick.emit(`Hello, ${this.name}!`), }; const reactElement = createElement(Hello, props); render(reactElement, this.ref.nativeElement); } }</span></span></code> </pre> <br><p>  Selesai  Saat menggunakan komponen, Anda dapat mendaftarkan penangan acara dan meresponsnya. </p><br><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sayHello($event)"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Hasilnya adalah pembungkus yang berfungsi penuh untuk komponen Bereaksi untuk digunakan di dalam aplikasi Angular.  Itu dapat mengirimkan data dan menanggapi peristiwa di dalamnya. </p><br><h2 id="one-more-thing">  Satu hal lagi ... </h2><br><p>  Bagi saya, hal yang paling nyaman di Angular adalah Pengikatan Data Dua <code>ngModel</code> , <code>ngModel</code> .  Lebih mudah, sederhana, hanya membutuhkan sedikit kode.  Namun dalam implementasi saat ini, integrasi tidak dimungkinkan.  Ini bisa diperbaiki.  Sejujurnya, saya tidak begitu mengerti bagaimana mekanisme ini bekerja dari sudut pandang perangkat internal.  Oleh karena itu, saya akui bahwa solusi saya super-suboptimal dan saya akan senang jika Anda menulis di komentar cara yang lebih indah untuk mendukung <code>ngModel</code> . </p><br><p>  Pertama-tama, Anda perlu mengimplementasikan antarmuka <code>ControlValueAccessor</code> (dari paket <code>@angular/forms</code> dan menambahkan penyedia baru ke komponen. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NG_VALUE_ACCESSOR, ControlValueAccessor } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/forms'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> REACT_VALUE_ACCESSOR: any = { <span class="hljs-attr"><span class="hljs-attr">provide</span></span>: NG_VALUE_ACCESSOR, <span class="hljs-attr"><span class="hljs-attr">useExisting</span></span>: forwardRef(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> HelloComponent), <span class="hljs-attr"><span class="hljs-attr">multi</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; @Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'app-hello'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">`&lt;div #react&gt;&lt;/div&gt;`</span></span>, <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [PREACT_VALUE_ACCESSOR], }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreactComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnChanges</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ControlValueAccessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Antarmuka ini membutuhkan implementasi metode <code>onBlur</code> , <code>writeValue</code> , <code>registerOnChange</code> , <code>registerOnTouched</code> .  Semuanya dijelaskan dengan baik dalam dokumentasi.  Kami menyadarinya. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    const noop = () =&gt; {}; @Component({ selector: 'app-hello', template: `&lt;div #react&gt;&lt;/div&gt;`, providers: [PREACT_VALUE_ACCESSOR], }) export class PreactComponent implements OnInit, OnChanges, ControlValueAccessor { // ... private innerValue: string; //      ngModel private onTouchedCallback: Callback = noop; private onChangeCallback: Callback = noop; //       //       get value(): string { return this.innerValue; } set value(v: string) { if (v !== this.innerValue) { this.innerValue = v; //    ,   this.onChangeCallback(v); } } writeValue(value: string) { if (value !== this.innerValue) { this.innerValue = value; //        this.renderReactElement(); } } //   registerOnChange(fn: Callback) { this.onChangeCallback = fn; } registerOnTouched(fn: Callback) { this.onTouchedCallback = fn; } //    onBlur() { this.onTouchedCallback(); } }</span></span></code> </pre> <br><p>  Setelah itu, Anda perlu memastikan bahwa semua ini diteruskan ke komponen Bereaksi.  Sayangnya, Bereaksi tidak dapat bekerja dengan Pengikatan Data Dua Arah, jadi kami akan memberinya nilai dan panggilan balik untuk mengubahnya.  <code>renderReactElement</code> metode <code>renderReactElement</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... private renderReactElement() { const props = { name: this.name, onClick: () =&gt; this.lick.emit(`Hello, ${this.name}!`), model: { value: this.value, onChange: v =&gt; { this.value = v; } }, }; const reactElement = createElement(Hello, props); render(reactElement, this.ref.nativeElement); } // ...</span></span></code> </pre> <br><p>  Dan dalam komponen Bereaksi, kita akan menggunakan nilai ini dan panggilan balik. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Hello = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, onClick, model }</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello, {name}!</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Say "hello"</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{model.value}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{e</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> model.onChange(e.target.value)} /&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> );</span></span></code> </pre> <br><p>  Sekarang, kami benar-benar mengintegrasikan Bereaksi ke Angular.  Anda dapat menggunakan komponen yang dihasilkan sesuka Anda. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sayHello($event)"</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-hello</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h1 id="itog">  Ringkasan </h1><br><p>  React adalah perpustakaan yang sangat sederhana yang mudah diintegrasikan dengan apa pun.  Dengan menggunakan pendekatan yang ditunjukkan, Anda tidak hanya dapat menggunakan komponen Bereaksi apa pun di dalam aplikasi Angular secara berkelanjutan, tetapi juga secara bertahap memigrasikan seluruh aplikasi. </p><br><p>  Pada artikel ini, saya tidak menyentuh masalah styling sama sekali.  Jika Anda menggunakan solusi CSS-in-JS klasik (komponen gaya, emosi, JSS), Anda tidak perlu mengambil tindakan tambahan apa pun.  Tetapi jika proyek membutuhkan solusi yang lebih produktif (astroturf, linaria, Modul CSS), Anda harus bekerja pada konfigurasi webpack.  Cerita fitur - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sesuaikan Konfigurasi Webpack di Aplikasi Sudut Anda</a> . </p><br><p>  Untuk memigrasikan aplikasi sepenuhnya dari Angular ke React, Anda masih perlu menyelesaikan masalah penerapan layanan dalam komponen React.  Cara sederhana adalah dengan mendapatkan layanan dalam komponen pembungkus dan menyebarkannya melalui alat peraga.  Cara yang sulit adalah menulis layer yang akan mendapatkan layanan dari injektor dengan token.  Pertimbangan masalah ini di luar cakupan artikel. </p><br><h1 id="bonus">  Bonus </h1><br><p>  Penting untuk dipahami bahwa dengan pendekatan ini ke 85KB Angular, hampir 40KB kode <code>react</code> dan <code>react-dom</code> <code>react</code> .  Ini dapat memiliki dampak signifikan pada kecepatan aplikasi.  Saya sarankan mempertimbangkan menggunakan miniatur Preact, yang beratnya hanya 3KB.  Integrasi hampir tidak berbeda. </p><br><ol><li>  Di <code>tsconfig.json</code> menambahkan opsi kompilasi baru - <code>"jsxFactory": "h"</code> , ini akan menunjukkan bahwa Anda perlu menggunakan fungsi <code>h</code> untuk mengkonversi JSX.  Sekarang, di setiap file dengan kode JSX - <code>import { h } from 'preact'</code> . </li><li>  Semua panggilan ke <code>React.createElement</code> digantikan oleh <code>Preact.h</code> . </li><li>  Semua panggilan ke <code>ReactDOM.render</code> digantikan oleh <code>Preact.render</code> . </li></ol><br><p>  Selesai!  Baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi untuk bermigrasi dari React ke Preact</a> .  Praktis tidak ada perbedaan. </p><br><h1 id="upd-19919-1649">  UPD 19.9.19 16.49 </h1><br><p>  Tematik tautan dari komentar - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Micro Frontends</a> </p><br><h1 id="upd-20919-1430">  UPD 20.9.19 14.30 </h1><br><p>  Link tematis lain dari komentar - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Micro Frontends</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468063/">https://habr.com/ru/post/id468063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468049/index.html">Menggunakan werf untuk meluncurkan grafik Helm yang kompleks</a></li>
<li><a href="../id468051/index.html">VDS dengan Windows Server berlisensi untuk 100 rubel: mitos atau kenyataan?</a></li>
<li><a href="../id468053/index.html">Pembelajaran Mesin untuk berburu flat Anda. Bagian 1</a></li>
<li><a href="../id468057/index.html">Pengembangan OS seperti Unix - Multitasking dan panggilan sistem (7)</a></li>
<li><a href="../id468061/index.html">Cron di Linux: History, Usage, dan Device</a></li>
<li><a href="../id468065/index.html">Model manajemen produk mental untuk semua orang</a></li>
<li><a href="../id468067/index.html">Cara kerja penggabungan alfa</a></li>
<li><a href="../id468071/index.html">Eduard Medvedev, CTO di Tungsten Labs: "Kami telah berkembang ke titik di mana teknologi dapat menyebabkan kerusakan besar"</a></li>
<li><a href="../id468073/index.html">Andrei Terekhov: "Anda dapat mengatakan sebanyak mungkin bahwa orang Amerika itu lebih baik, tetapi mobil kami tidak pernah mogok"</a></li>
<li><a href="../id468075/index.html">Penggunaan jaringan saraf siam dalam pencarian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>