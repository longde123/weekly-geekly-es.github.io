<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåé üëª üè™ Mudan√ßas no antichita popular do BattlEye e maneiras de contorn√°-los ‚õÖÔ∏è üî£ ‚õ∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Principais atualiza√ß√µes do c√≥digo do shell do BattlEye 
 O tempo passa, os anti-cheats mudam e, para aumentar a efic√°cia do produto, as fun√ß√µes aparec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mudan√ßas no antichita popular do BattlEye e maneiras de contorn√°-los</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484420/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/c7/fe/zdc7ferp6hnuf19n_aid_mh4tca.png"></div><br><h2>  Principais atualiza√ß√µes do c√≥digo do shell do BattlEye </h2><br>  O tempo passa, os anti-cheats mudam e, para aumentar a efic√°cia do produto, as fun√ß√µes aparecem e desaparecem neles.  H√° um ano, preparei uma descri√ß√£o detalhada do c√≥digo de shell BattlEye no meu <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">blog</a> [ <a href="https://habr.com/ru/post/483068/">tradu√ß√£o</a> em Habr√©], e esta parte do artigo ser√° um reflexo simples das altera√ß√µes feitas no c√≥digo de shell. <br><br><h2>  Timestamps na lista negra </h2><br>  Em uma an√°lise recente do BattlEye, havia apenas dois carimbos de data e hora de compila√ß√£o na lista de proibi√ß√µes de sombra, e parece que os desenvolvedores decidiram adicionar muito mais: <br><br> <code>0x5B12C900 (action_x64.dll) <br> 0x5A180C35 (TerSafe.dll, Epic Games) <br> 0xFC9B9325 (?) <br> 0x456CED13 (d3dx9_32.dll) <br> 0x46495AD9 (d3dx9_34.dll) <br> 0x47CDEE2B (d3dx9_32.dll) <br> 0x469FF22E (d3dx9_35.dll) <br> 0x48EC3AD7 (D3DCompiler_40.dll) <br> 0x5A8E6020 (?) <br> 0x55C85371 (d3dx9_32.dll) <br> 0x456CED13 (?) <br> 0x46495AD9 (D3DCompiler_40.dll) <br> 0x47CDEE2B (D3DX9_37.dll) <br> 0x469FF22E (?) <br> 0x48EC3AD7 (?) <br> 0xFC9B9325 (?) <br> 0x5A8E6020 (?) <br> 0x55C85371 (?)</code> <br> <br>  N√£o consegui identificar os carimbos de data / hora restantes e os dois <b>0xF *******</b> s√£o os hashes criados pelos assemblies determin√≠sticos do Visual Studio.  Agradecemos a @mottikraus e T0B1 por identificar alguns registros de data e hora. <br><a name="habracut"></a><br><h2>  Verifica√ß√µes do m√≥dulo </h2><br>  Como a an√°lise principal mostrou, o principal recurso do BattlEye √© a enumera√ß√£o de m√≥dulos e, a partir do momento da √∫ltima an√°lise, outro m√≥dulo foi adicionado √† lista: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::misc::module_unknown1() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetProcAddress(current_module, <span class="hljs-string"><span class="hljs-string">"NSPStartup"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0x1B20</span></span> || optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0xE70</span></span> || optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0x1A38</span></span> || timestamp &gt;= <span class="hljs-number"><span class="hljs-number">0x5C600000</span></span> &amp;&amp; timestamp &lt; <span class="hljs-number"><span class="hljs-number">0x5C700000</span></span>) { report_module_unknown report = {}; report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span>; report.report_id = <span class="hljs-number"><span class="hljs-number">0x35</span></span>; report.val1 = <span class="hljs-number"><span class="hljs-number">0x5C0</span></span>; report.timestamp = timestamp; report.image_size = optional_header.size_of_image; report.entrypoint = optional_header.address_of_entry_point; report.directory_size = optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size; battleye::report(&amp;report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(report), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br>  Provavelmente, essa √© a detec√ß√£o de determinadas DLLs do proxy, pois o tamanho da tabela de redirecionamento √© verificado aqui. <br><br><h2>  T√≠tulos das janelas </h2><br>  Na an√°lise anterior, v√°rios provedores de truques foram marcados com nomes de janelas, mas desde ent√£o o c√≥digo de shell parou de verificar esses cabe√ßalhos de janela.  A lista de t√≠tulos de janelas foi completamente substitu√≠da por: <br><br> <code>Chod's <br> Satan5</code> <br> <br><h2>  Nomes das imagens </h2><br>  O BattlEye √© famoso por usar m√©todos de detec√ß√£o muito primitivos, e um deles √© uma lista negra de nomes de imagens.  A cada ano, a lista de nomes proibidos de imagens est√° aumentando e, nos √∫ltimos 11 meses, cinco novas foram adicionadas: <br><br> <code>frAQBc8W.dll <br> C:\\Windows\\mscorlib.ni.dll <br> DxtoryMM_x64.dll <br> Project1.dll <br> OWClient.dll <br></code> <br>  Vale ressaltar que a presen√ßa de um m√≥dulo com um nome correspondente a qualquer um dos itens da lista n√£o significa que voc√™ ser√° banido imediatamente.  O mecanismo de relat√≥rio tamb√©m transmite informa√ß√µes b√°sicas do m√≥dulo, que provavelmente s√£o usadas para distinguir truques de colis√µes no servidor BattlEye. <br><br><h2>  7 zip </h2><br>  O 7-Zip foi amplamente utilizado e continua sendo usado pelos participantes na cena de trapa√ßa como um preenchedor de mem√≥ria para espa√ßos vazios (code-caves).  O BattlEye tenta lidar com isso executando uma verifica√ß√£o de integridade <b>muito</b> ruim, que mudou desde o meu artigo anterior: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_7zip() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"..\\..\\Plugins\\ZipUtility\\ThirdParty\\7zpp\\dll\\Win64\\7z.dll"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// --- REMOVED --- // if (module_handle &amp;&amp; *(int*)(module_handle + 0x1000) != 0xFF1441C7) // --- ADDED --- if (module_handle &amp;&amp; *(int*)(module_handle + 0x1008) != 0x83485348) { sevenzip_report.unknown_1 = 0; sevenzip_report.report_id = 0x46; sevenzip_report.unknown_2 = 0; sevenzip_report.data1 = *(__int64*)(module_handle + 0x1000; sevenzip_report.data2 = *(__int64*)(module_handle + 0x1008; battleye::report(&amp;sevenzip_report, sizeof(sevenzip_report), false); } }</span></span></code> </pre> <br>  Parece que os desenvolvedores do BattlEye imaginaram que meu artigo anterior levou muitos usu√°rios a ignorar essa verifica√ß√£o simplesmente copiando os bytes desejados para o local verificado pelo BattlEye.  Como eles resolveram a situa√ß√£o?  Mudamos a verifica√ß√£o em oito bytes e continuamos a usar o mesmo m√©todo ruim de verificar a integridade.  A parti√ß√£o execut√°vel somente leitura, e tudo o que voc√™ precisa fazer √© baixar o 7-Zip do disco e comparar as parti√ß√µes movidas entre si;  se houver discrep√¢ncias, algo est√° errado.  S√©rio, pessoal, realizar verifica√ß√µes de integridade n√£o √© t√£o dif√≠cil. <br><br><h2>  Verifica√ß√£o de rede </h2><br>  Enumerar a tabela TCP ainda funciona, mas depois que lancei uma an√°lise anterior criticando os desenvolvedores por sinalizarem os endere√ßos IP do Cloudflare, eles ainda removeram essa verifica√ß√£o.  O Anti-cheat ainda relata a porta que o xera.ph usa para a conex√£o, mas os desenvolvedores adicionaram uma nova verifica√ß√£o para determinar se o processo com a conex√£o tem prote√ß√£o ativa (presumivelmente isso √© feito usando o manipulador). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> network::scan_tcp_table { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(local_port_buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(local_port_buffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (iteration_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; iteration_index; &lt; <span class="hljs-number"><span class="hljs-number">500</span></span> ++iteration_index) { <span class="hljs-comment"><span class="hljs-comment">// GET NECESSARY SIZE OF TCP TABLE auto table_size = 0; GetExtendedTcpTable(0, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0); // ALLOCATE BUFFER OF PROPER SIZE FOR TCP TABLE auto allocated_ip_table = (MIB_TCPTABLE_OWNER_MODULE*)malloc(table_size); if (GetExtendedTcpTable(allocated_ip_table, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0) != NO_ERROR) goto cleanup; for (entry_index = 0; entry_index &lt; allocated_ip_table-&gt;dwNumEntries; ++entry_index) { // --- REMOVED --- // const auto ip_address_match_1 = // allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656B1468; // 104.20.107.101 // // const auto ip_address_match_2 = // allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656C1468; // 104.20.108.101 // +++ ADDED +++ const auto target_process = OpenProcess(QueryLimitedInformation, 0, ip_table-&gt;table[entry_index].dwOwningPid); const auto protected = target_process == INVALID_HANDLE &amp;&amp; GetLastError() == 0x57; if (!protected) { CloseHandle(target_process); return; } const auto port_match = allocated_ip_table-&gt;table[entry_index].dwRemotePort == 20480; for (port_index = 0; port_index &lt; 10 &amp;&amp; allocated_ip_table-&gt;table[entry_index].dwLocalPort != local_port_buffer[port_index]; ++port_index) { if (local_port_buffer[port_index]) continue tcp_table_report.unknown = 0; tcp_table_report.report_id = 0x48; tcp_table_report.module_id = 0x5B9; tcp_table_report.data = BYTE1(allocated_ip_table-&gt;table[entry_index].dwLocalPort) | (LOBYTE(allocated_ip_table-&gt;table[entry_index.dwLocalPort) &lt;&lt; 8; battleye::report(&amp;tcp_table_report, sizeof(tcp_table_report), false); local_port_buffer[port_index] = allocated_ip_table-&gt;table[entry_index].dwLocalPort; break } } cleanup: // FREE TABLE AND SLEEP free(allocated_ip_table); Sleep(10 } }</span></span></code> </pre> <br>  Obrigado IChooseYou e resumo <br><br><h2>  BattlEye Stack Bypass </h2><br>  Jogos de hackers s√£o um jogo constante de gato e rato, ent√£o rumores de novos truques est√£o se espalhando como fogo.  Nesta parte, veremos novas t√©cnicas heur√≠sticas que foram recentemente adicionadas ao nosso arsenal por um grande fornecedor de BattlEye anti-cheats.  Na maioria das vezes, essas t√©cnicas s√£o chamadas de stack walking.  Geralmente eles s√£o implementados processando uma fun√ß√£o e percorrendo a pilha para descobrir quem chamou especificamente essa fun√ß√£o.  Por que voc√™ precisa fazer isso?  Como qualquer outro programa, os hacks de videogame t√™m um conjunto de fun√ß√µes conhecidas que eles usam para obter informa√ß√µes do teclado, enviar para o console ou calcular certas express√µes matem√°ticas.  Al√©m disso, os hackers de videogame adoram esconder sua exist√™ncia, seja na mem√≥ria ou no disco, para que o software anti-fraude n√£o os encontre.  Mas o que os programas de truques esquecem √© que eles chamam fun√ß√µes regularmente de outras bibliotecas, e isso pode ser usado para detectar heuristicamente truques desconhecidos.  Ao implementar o mecanismo de deslocamento de pilha para fun√ß√µes como <code>std::print</code> , podemos encontrar esses truques, mesmo que estejam mascarados. <br><br>  O BattlEye <strong>implementou um</strong> ‚Äúdesvio de pilha‚Äù, apesar de isso n√£o ter sido anunciado publicamente e no momento da publica√ß√£o do artigo havia apenas rumores.  Preste aten√ß√£o √†s aspas - o que voc√™ ver√° aqui n√£o √© realmente um tour de pilha real, mas apenas uma combina√ß√£o de verificar o endere√ßo de retorno e o dump do programa de chamada.  Uma implementa√ß√£o de passagem de pilha verdadeira passaria pela pilha e geraria uma pilha de chamadas real. <br><br>  Como expliquei em um artigo anterior sobre o BattlEye, o sistema anti-fraude transmite dinamicamente o c√≥digo do shell para o jogo quando est√° em execu√ß√£o.  Esses c√≥digos de shell t√™m tamanhos e tarefas diferentes e n√£o s√£o transmitidos simultaneamente.  Uma propriedade not√°vel desse sistema √© que os pesquisadores precisam analisar dinamicamente o anti-cheat durante a partida multiplayer, o que complica a determina√ß√£o das caracter√≠sticas desse anti-cheat.  Ele tamb√©m permite que o anti-fraude aplique v√°rias medidas a diferentes usu√°rios, por exemplo, para transferir um m√≥dulo mais profundamente invasivo apenas para uma pessoa que tenha uma taxa incomumente alta de assassinatos e mortes, e similares. <br><br>  Um desses c√≥digos de shell, BattlEye, √© respons√°vel por executar essa an√°lise de pilha;  o chamaremos <em>shellcode8kb</em> porque √© um pouco menor em compara√ß√£o com o <em>shellcodemain</em> , que eu documentei <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">aqui</a> .  Esse pequeno c√≥digo de shell usando a fun√ß√£o <strong>AddVectoredExceptionHandler</strong> prepara um manipulador de exce√ß√µes vetorizado e define traps de interrup√ß√£o nas seguintes fun√ß√µes: <br><br> <code>GetAsyncKeyState <br> GetCursorPos <br> IsBadReadPtr <br> NtUserGetAsyncKeyState <br> GetForegroundWindow <br> CallWindowProcW <br> NtUserPeekMessage <br> NtSetEvent <br> sqrtf <br> __stdio_common_vsprintf_s <br> CDXGIFactory::TakeLock <br> TppTimerpExecuteCallback</code> <br> <br>  Para fazer isso, ele simplesmente percorre a lista de fun√ß√µes usadas de maneira padr√£o, configurando a primeira instru√ß√£o da fun√ß√£o correspondente como <strong>int3</strong> , que √© usada como um ponto de interrup√ß√£o.  Ap√≥s definir um ponto de interrup√ß√£o, todas as chamadas para a fun√ß√£o correspondente passam pelo manipulador de exce√ß√µes, que tem acesso total aos registradores e √† pilha.  Com esse acesso, o manipulador de exce√ß√µes despeja o endere√ßo do programa de chamada da parte superior da pilha e, se uma das condi√ß√µes heur√≠sticas for atendida, 32 bytes da fun√ß√£o de chamada ser√£o despejados e enviados ao servidor BattlEye com o identificador de relat√≥rio <strong>0x31</strong> : <br><br><pre> <code class="cpp hljs">__int64 battleye::exception_handler(_EXCEPTION_POINTERS *exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exception-&gt;ExceptionRecord-&gt;ExceptionCode != STATUS_BREAKPOINT) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> caller_function = *(__int64 **)exception-&gt;ContextRecord-&gt;Rsp; MEMORY_BASIC_INFORMATION caller_memory_information = {}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> desired_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// QUERY THE MEMORY PAGE OF THE CALLER const auto call_failed = NtQueryVirtualMemory( GetCurrentProcess(), caller_function, MemoryBasicInformation, &amp;caller_memory_information, sizeof(caller_memory_information), &amp;desired_size) &lt; 0; // IS THE MEMORY SOMEHOW NOT COMMITTED? (WOULD SUGGEST VAD MANIPULATIUON) const auto non_commit = caller_memory_information.State != MEM_COMMIT; // IS THE PAGE EXECUTABLE BUT DOES NOT BELONG TO A PROPERLY LOADED MODULE? const auto foreign_image = caller_memory_information.Type != MEM_IMAGE &amp;&amp; caller_memory_information.RegionSize &gt; 0x2000; // IS THE CALL BEING SPOOFED BY NAMAZSO? const auto spoof = *(_WORD *)caller_function == 0x23FF; // jmp qword ptr [rbx] // FLAG ALL ANBORMALITIES if (call_failed || non_commit || foreign_image || spoof) { report_stack.unknown = 0; report_stack.report_id = 0x31; report_stack.hook_id = hook_id; report_stack.caller = (__int64)caller_function; report_stack.function_dump[0] = *caller_function; report_stack.function_dump[1] = caller_function[1]; report_stack.function_dump[2] = caller_function[2]; report_stack.function_dump[3] = caller_function[3]; if (!call_failed) { report_stack.allocation_base = caller_memory_information.AllocationBase; report_stack.base_address = caller_memory_information.BaseAddress; report_stack.region_size = caller_memory_information.RegionSize; report_stack.type_protect_state = caller_memory_information.Type | caller_memory_information.Protect | caller_memory_information.State; } battleye::report(&amp;report_stack, sizeof(report_stack), false); return -1; } }</span></span></code> </pre> <br>  Como podemos ver, o manipulador de exce√ß√µes descarta todas as fun√ß√µes de chamada no caso de uma altera√ß√£o sem cerim√¥nia na p√°gina de mem√≥ria ou quando a fun√ß√£o n√£o pertence a um m√≥dulo de processo conhecido (o tipo de p√°gina de mem√≥ria MEM_IMAGE n√£o foi definido pelo manualmappers).  Ele tamb√©m despeja fun√ß√µes de chamada quando falha em chamar <strong>NtQueryVirtualMemory,</strong> para que os cheats n√£o se vinculem a essa chamada do sistema e ocultam seu m√≥dulo do despejo de pilha.  A √∫ltima condi√ß√£o √© realmente bastante interessante, marca todas as fun√ß√µes de chamada que usam o dispositivo <strong>jmp qword ptr [rbx]</strong> - o m√©todo usado para "falsificar o endere√ßo de retorno".  Foi <a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/268039-x64-return-address-spoofing-source-explanation.html">lan√ßado pelo</a> apelido de meu co-secret√°rio namazso.  Parece que os desenvolvedores do BattlEye viram que as pessoas usam esse m√©todo de falsifica√ß√£o em seus jogos e decidiram apontar diretamente para ele.  Vale ressaltar aqui que o m√©todo descrito por namazsos funciona bem, basta usar um dispositivo diferente, ou completamente diferente, ou apenas um registro diferente - isso n√£o importa. <br><br>  Dica do desenvolvedor do BattlEye: O <code>CDXGIFactory::TakeLock</code> na mem√≥ria est√° incorreto porque voc√™ (acidentalmente ou intencionalmente) ativou o preenchimento CC, que √© muito diferente a cada compila√ß√£o.  Para m√°xima compatibilidade, voc√™ precisa remover o preenchimento (o primeiro byte da assinatura) e, portanto, provavelmente pegar√° mais trapaceiros :) <br><br>  A estrutura completa enviada ao servidor BattlEye √© assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unaligned</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">battleye_stack_report</span></span></span><span class="hljs-class"> {</span></span> __int8 unknown; __int8 report_id; __int8 val0; __int64 caller; __int64 function_dump[<span class="hljs-number"><span class="hljs-number">4</span></span>]; __int64 allocation_base; __int64 base_address; __int32 region_size; __int32 type_protect_state; };</code> </pre> <br><h2>  Reconhecimento de hipervisor no BattlEye </h2><br>  O jogo de gato e rato no campo dos jogos de hackers continua a ser uma fonte de inova√ß√£o em fa√ßanhas e luta contra trapa√ßas.  O uso da tecnologia de virtualiza√ß√£o em jogos de hackers come√ßou a se desenvolver ativamente ap√≥s o advento de hipervisores f√°ceis de usar como <a href="https://github.com/tandasat/DdiMon">DdiMon</a> Satoshi Tanda e o <a href="https://github.com/wbenny/hvpp">hvpp</a> Peter Benes.  Esses dois projetos s√£o usados ‚Äã‚Äãpelos truques mais pagos da cena dos hackers clandestinos devido ao baixo limite de entrada e √† documenta√ß√£o detalhada.  √â prov√°vel que esses lan√ßamentos acelerem a corrida armamentista no campo dos hipervisores, que agora est√° come√ßando a se manifestar na comunidade de hackers de jogos.  Aqui est√° o que o administrador de uma das maiores comunidades de hackers de jogos com o apelido <a href="https://www.unknowncheats.me/">wlan</a> diz sobre esta situa√ß√£o: <br><br><blockquote>  Com o advento de sistemas de hipervisor prontos para uso para jogos de hackers, tornou-se inevit√°vel que anti-cheats como o BattlEye se concentrassem no reconhecimento generalizado da virtualiza√ß√£o. </blockquote><br>  O uso generalizado de hipervisores se deve a melhorias recentes no anti-cheat, que deixaram aos hackers muito poucas oportunidades de modificar os jogos de maneira tradicional.  A popularidade dos hipervisores pode ser explicada pela simplicidade de evitar anti-fraude, porque a virtualiza√ß√£o simplifica a oculta√ß√£o de informa√ß√µes usando mecanismos como <a href="https://revers.engineering/syscall-hooking-via-extended-feature-enable-register-efer/">syscall hooks</a> e <a href="https://www.anandtech.com/show/2480/10">MMU virtualization</a> . <br><br>  Recentemente, o BattlEye implementou o reconhecimento de hipervisores comuns, como as plataformas mencionadas acima (DdiMon, hvpp), usando detec√ß√£o baseada em tempo.  Este reconhecimento tenta detectar valores de tempo de instru√ß√£o CPUID n√£o padr√£o.  O CPUID √© uma instru√ß√£o de custo relativamente baixo em equipamentos reais, geralmente exigindo apenas duzentos ciclos, e em um ambiente virtual, sua execu√ß√£o pode demorar dez vezes mais devido a opera√ß√µes desnecess√°rias causadas pelo mecanismo de introspec√ß√£o.  O mecanismo de introspec√ß√£o √© diferente do equipamento real, que simplesmente executa a opera√ß√£o da maneira esperada, porque, com base em um crit√©rio arbitr√°rio, rastreia e altera condicionalmente os dados retornados ao h√≥spede. <br><br>  <strong>Curiosidade: o</strong> CPUID √© usado ativamente nesses procedimentos de reconhecimento tempor√°rio porque √© uma instru√ß√£o com uma sa√≠da incondicional, bem como uma instru√ß√£o com serializa√ß√£o sem privil√©gios.  Isso significa que o CPUID √© usado como uma <a href="https://en.wikipedia.org/wiki/Memory_barrier">barreira</a> e garante que as instru√ß√µes antes e depois sejam seguidas;  ao mesmo tempo, os hor√°rios se tornam independentes da reordena√ß√£o usual das instru√ß√µes.  Voc√™ tamb√©m pode usar instru√ß√µes como <a href="https://www.felixcloutier.com/x86/xsetbv">XSETBV</a> , que tamb√©m executam uma sa√≠da incondicional, mas para garantir o tempo independente, isso exigir√° algum tipo de instru√ß√£o de barreira, para que nenhuma reordena√ß√£o ocorra antes ou depois dela, afetando a confiabilidade dos tempos. <br><br><h4>  Reconhecimento </h4><br>  A seguir, √© apresentado o procedimento de reconhecimento do m√≥dulo BattlEye "BEClient2";  Executei sua engenharia reversa e recriei o c√≥digo em pseudo-C, e depois o publiquei no <a href="https://twitter.com/vm_call">twitter</a> .  No dia seguinte ao meu tweet, os desenvolvedores do BattlEye inesperadamente mudaram a ofusca√ß√£o do BEClient2, aparentemente esperando que isso me impedisse de analisar o m√≥dulo.  A ofusca√ß√£o anterior n√£o mudou por mais de um ano, mas mudou no dia seguinte ao meu tweet sobre isso - uma velocidade impressionante. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::take_time() { <span class="hljs-comment"><span class="hljs-comment">// SET THREAD PRIORITY TO THE HIGHEST const auto old_priority = SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL); // CALCULATE CYCLES FOR 1000MS const auto timestamp_calibrator = __rdtsc(); Sleep(1000); const auto timestamp_calibration = __rdtsc() - timestamp_calibrator; // TIME CPUID auto total_time = 0; for (std::size_t count = 0; count &lt; 0x6694; count++) { // SAVE PRE CPUID TIME const auto timestamp_pre = __rdtsc(); std::uint32_t cpuid_data[4] = {}; __cpuid(cpuid_data, 0); // SAVE THE DELTA total_time += __rdtsc() - timestamp_pre; } // SAVE THE RESULT IN THE GLOBAL REPORT TABLE battleye::report_table[0x1A8] = 10000000 * total_time / timestamp_calibration / 0x65; // RESTORE THREAD PRIORITY SetThreadPriority(GetCurrentThread(), old_priority); }</span></span></code> </pre> <br>  Como eu disse acima, esta √© a t√©cnica de reconhecimento mais comum usando instru√ß√µes interceptadas incondicionalmente.  No entanto, √© vulner√°vel ao tempo falso, e falaremos sobre isso em detalhes na pr√≥xima se√ß√£o. <br><br><h4>  Bypass de reconhecimento </h4><br>  Este m√©todo de reconhecimento tem problemas.  Em primeiro lugar, √© propenso ao tempo falso, o que geralmente √© feito de duas maneiras: alterando o TSC no VMCS ou diminuindo o TSC toda vez que o CPUID √© executado.  Existem muitas outras maneiras de lidar com ataques baseados em tempo, mas o √∫ltimo √© muito mais f√°cil de implementar, porque voc√™ pode garantir que o tempo de execu√ß√£o da instru√ß√£o esteja dentro de um ou dois ciclos de sincroniza√ß√£o de execu√ß√£o em equipamentos reais.  A dificuldade de descobrir essa t√©cnica de falsifica√ß√£o de tempo depende da experi√™ncia do desenvolvedor.  Na pr√≥xima se√ß√£o, veremos o tempo de falsifica√ß√£o e melhoria da implementa√ß√£o criada no BattlEye.  A segunda raz√£o para essa falha no m√©todo de reconhecimento √© que o atraso do CPUID (tempo de execu√ß√£o) em diferentes processadores √© muito diferente, dependendo do valor da planilha.  Pode levar at√© 70-300 ciclos de rel√≥gio para concluir.  O terceiro problema com este procedimento de reconhecimento √© usar SetThreadPriority.  Essa fun√ß√£o do Windows √© usada para definir o valor da prioridade de um determinado descritor de fluxo, mas o sistema operacional nem sempre atende √† solicita√ß√£o.  Essa fun√ß√£o √© simplesmente uma sugest√£o para aumentar a prioridade do encadeamento e n√£o h√° garantia de que isso aconte√ßa.  Assim, √© poss√≠vel que esse m√©todo seja afetado por interrup√ß√µes ou outros processos. <br><br>  Nesse caso, √© f√°cil ignorar o reconhecimento, e a t√©cnica descrita de contrafa√ß√£o derrota efetivamente esse m√©todo de reconhecimento.  Se os desenvolvedores do BattlEye quiserem melhorar esse m√©todo, a se√ß√£o a seguir fornece algumas recomenda√ß√µes. <br><br><h4>  Melhoria </h4><br>  Esse recurso pode ser aprimorado de v√°rias maneiras.  Primeiro, voc√™ pode desativar intencionalmente as interrup√ß√µes e for√ßar a prioridade de um encadeamento alterando CR8 para o IRQL mais alto.  Tamb√©m seria ideal isolar essa verifica√ß√£o em um n√∫cleo da CPU.  Outra melhoria: voc√™ deve usar cron√¥metros diferentes, mas muitos deles n√£o s√£o t√£o precisos quanto o TSC, mas existe um cron√¥metro chamado APERF, ou Actual Performance Clock.  Eu recomendo esse timer porque √© mais dif√≠cil trapacear com ele e ele s√≥ acumula um contador quando o processador l√≥gico est√° no estado de energia C0.  Essa √© uma √≥tima alternativa ao uso do TSC.  Voc√™ tamb√©m pode usar o timer ACPI, HPET, PIT, GPU, NTP ou PPERF, que √© semelhante ao APERF, mas conta as medidas que s√£o percebidas como instru√ß√µes de execu√ß√£o.  A desvantagem disso √© que voc√™ precisa habilitar o HWP, que pode ser desativado pelo operador intermedi√°rio e, portanto, √© in√∫til. <br><br>  Abaixo est√° uma vers√£o aprimorada do procedimento de reconhecimento que deve ser executado no kernel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::take_time() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cpuid_regs[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {}; _disable(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_pre = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; __cpuid(&amp;cpuid_regs, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_post = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_diff = aperf_post - aperf_pre; <span class="hljs-comment"><span class="hljs-comment">// CPUID IET ARRAY STORE // BATTLEYE REPORT TABLE STORE _enable(); }</span></span></code> </pre> <br>  <strong>Nota:</strong> IET significa Tempo de Execu√ß√£o da Instru√ß√£o. <br><br>  No entanto, o procedimento ainda pode ser muito confi√°vel na detec√ß√£o de hipervisores comuns, pois os tempos de execu√ß√£o da CPUID podem variar bastante.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seria melhor comparar o IET das duas instru√ß√µes. Um deles deve ter um atraso de execu√ß√£o maior que o CPUID. Por exemplo, pode ser FYL2XP1 - uma instru√ß√£o aritm√©tica que demora um pouco mais para ser conclu√≠da do que o IET m√©dio da instru√ß√£o CPUID. Al√©m disso, ele n√£o causa nenhuma intercepta√ß√£o no hipervisor e seu tempo pode ser medido com seguran√ßa. Usando essas duas fun√ß√µes, a fun√ß√£o de cria√ß√£o de perfil pode criar uma matriz para armazenar as instru√ß√µes IET CPUID e FYL2XP1. Usando o temporizador APERF, seria poss√≠vel obter o rel√≥gio inicial de uma instru√ß√£o aritm√©tica, executar a instru√ß√£o e calcular o delta do rel√≥gio para ela. Os resultados podem ser armazenados na matriz IET por N ciclos de cria√ß√£o de perfil, obtendo o valor m√©dio e repetindo o processo para o CPUID. Se o tempo de execu√ß√£o da instru√ß√£o CPUID for maior que a instru√ß√£o aritm√©tica,esse √© um sinal confi√°vel de que o sistema √© virtual, porque uma instru√ß√£o aritm√©tica sob nenhuma circunst√¢ncia poderia gastar mais tempo do que executar o CPUID para obter informa√ß√µes sobre o fabricante ou a vers√£o. Esse procedimento de reconhecimento tamb√©m poder√° detectar aqueles que usam o deslocamento / escala do TSC.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repito, os desenvolvedores precisariam for√ßar a liga√ß√£o ao n√∫cleo computacional para executar essa verifica√ß√£o em um √∫nico n√∫cleo, desativar as interrup√ß√µes e for√ßar o IRQL a definir o valor m√°ximo para garantir dados consistentes e confi√°veis. </font><font style="vertical-align: inherit;">Seria surpreendente se os desenvolvedores do BattlEye decidissem implementar isso, porque requer muito mais esfor√ßo. </font><font style="vertical-align: inherit;">Existem outras duas rotinas de reconhecimento de m√°quina virtual no driver do kernel BattlEye, mas este √© um t√≥pico para outro artigo.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484420/">https://habr.com/ru/post/pt484420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484408/index.html">Era RUTM</a></li>
<li><a href="../pt484410/index.html">H√°bitos √∫teis para desenvolvedores</a></li>
<li><a href="../pt484412/index.html">Processador NXP S32G para arquitetura eletr√¥nica automotiva moderna</a></li>
<li><a href="../pt484414/index.html">Escolhendo um arquivador para logs de backup</a></li>
<li><a href="../pt484418/index.html">CEO Motoriki Ilya Chekh: √Äs vezes, eles esperam um trabalho ideal das pr√≥teses experimentais e ficam decepcionados</a></li>
<li><a href="../pt484424/index.html">Nvidia Orin - um chip para ve√≠culos rob√≥ticos</a></li>
<li><a href="../pt484426/index.html">Eu e meu ciclomotor. Escala de inefici√™ncia</a></li>
<li><a href="../pt484428/index.html">Escolhendo uma ideia para uma startup sem um investidor: pelo contr√°rio</a></li>
<li><a href="../pt484430/index.html">Os primeiros √≥culos VR habilitados para HDR do mundo: o que se sabe sobre o prot√≥tipo da Panasonic</a></li>
<li><a href="../pt484436/index.html">C√≥digo-fonte ingrato: o desenvolvedor do servidor da Web mais r√°pido excluiu seu reposit√≥rio - Atualiza√ß√£o importante</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>