<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôãüèª üë®üèª‚Äçüè≠ üë©‚Äçüè´ Fast C / C ++ Cache, Thread Safety ‚úùÔ∏è üò∏ ‚õ≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengujian komparatif dari cache multi-threaded diimplementasikan dalam C / C ++ dan deskripsi bagaimana cache LRU / MRU dari cache O (n) Cache ** RU d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fast C / C ++ Cache, Thread Safety</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450004/"><h2>  Pengujian komparatif dari cache multi-threaded diimplementasikan dalam C / C ++ dan deskripsi bagaimana cache LRU / MRU dari cache O (n) Cache ** RU diatur </h2><a name="habracut"></a><br><p>  Selama beberapa dekade, banyak algoritma caching telah dikembangkan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LRU, MRU, ARC, dan lainnya ....</a>  Namun, ketika cache diperlukan untuk pekerjaan multi-threaded, google pada topik ini memberikan satu setengah opsi, dan pertanyaan tentang StackOverflow umumnya tetap tidak terjawab.  Saya menemukan <a href="">solusi dari Facebook</a> yang bergantung pada wadah aman dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori Intel TBB</a> .  Yang terakhir juga memiliki <a href="">cache LRU multi-threaded</a> yang masih dalam pengujian beta dan oleh karena itu, untuk menggunakannya, Anda harus secara eksplisit menentukan dalam proyek: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TBB_PREVIEW_CONCURRENT_LRU_CACHE true</span></span></code> </pre> <br><p>  Jika tidak, kompiler akan menampilkan kesalahan karena ada tanda centang pada kode Intel TBB: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ! TBB_PREVIEW_CONCURRENT_LRU_CACHE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> Set TBB_PREVIEW_CONCURRENT_LRU_CACHE to </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> concurrent_lru_cache.h #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><p>  Saya ingin entah bagaimana membandingkan kinerja cache - yang mana yang harus dipilih?  Atau tulis sendiri?  Sebelumnya, ketika saya membandingkan cache single-threaded ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ), saya menerima penawaran untuk mencoba kondisi lain dengan kunci lain dan menyadari bahwa diperlukan bangku tes yang dapat diperpanjang yang lebih nyaman.  Agar lebih mudah untuk menambahkan algoritma yang bersaing ke dalam tes, saya memutuskan untuk membungkusnya dalam antarmuka standar: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAlgorithmTester</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: IAlgorithmTester() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IAlgorithmTester() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;IConfig&gt; &amp;cfg)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *elem)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *elem)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_algorithm_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: IAlgorithmTester(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IAlgorithmTester&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; IAlgorithmTester&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IAlgorithmTester&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>  Demikian pula, antarmuka dibungkus: bekerja dengan sistem operasi, mendapatkan pengaturan, menguji kasus, dll. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber diletakkan dalam repositori</a> .  Ada dua test case di stand: sisipkan / cari hingga 1.000.000 elemen dengan kunci dari angka yang dihasilkan secara acak dan hingga 100.000 elemen dengan kunci string (diambil dari 10Mb garis wiki.train.tokens).  Untuk mengevaluasi waktu eksekusi, setiap cache tes pertama-tama dipanaskan ke volume target tanpa pengukuran waktu, kemudian semaphore mengeluarkan aliran dari rantai untuk menambahkan dan mencari data.  Jumlah utas dan <a href="">pengaturan</a> test case diatur dalam <a href="">aset / settings.json</a> .  Petunjuk kompilasi langkah demi langkah dan deskripsi pengaturan JSON dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori WiKi</a> .  Waktu dilacak sejak semafor dilepaskan hingga utas terakhir berhenti.  Inilah yang terjadi: </p><br><p>  Test case1 - kunci dalam bentuk array angka acak uint64_t keyArray [3]: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2af/2d2/f31/2af2d2f3164176a1cf471c2cad1a4046.png" alt="TestCase1.Nthread"></p><br><p>  Uji case2 - kunci sebagai string: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c7/217/af4/1c7217af425c0aa4df787539f1da5533.png" alt="TestCase2.Nthread"></p><br><p>  Harap dicatat bahwa volume data yang dimasukkan / dicari pada setiap langkah dari test case meningkat 10 kali lipat.  Kemudian, waktu yang dihabiskan untuk memproses volume berikutnya, saya bagi dengan 10, 100, 1000, masing-masing ... Jika algoritma berperilaku seperti O (n) dalam kompleksitas waktu, maka timeline akan tetap kira-kira sejajar dengan sumbu X. Selanjutnya, saya akan mengungkapkan pengetahuan suci, seperti yang saya kelola dapatkan 3-5 kali keunggulan dari cache Facebook di algoritme O (n) Cache ** RU saat bekerja dengan kunci string: </p><br><ol><li>  Fungsi hash, alih-alih membaca setiap huruf dari string, cukup melemparkan pointer ke data string ke uint64_t keyArray [3] dan menghitung jumlah bilangan bulat.  Yaitu, ini berfungsi seperti program "Tebak melodi" - dan saya kira melodi dengan 3 catatan ... 3 * 8 = 24 huruf jika itu bahasa Latin, dan ini sudah memungkinkan Anda untuk menyebarkan garis dengan cukup baik di keranjang hash.  Ya, banyak baris dapat dikumpulkan dalam keranjang hash, dan di sini algoritme mulai dipercepat: </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftar Lewati</a> di setiap keranjang memungkinkan Anda untuk melompat dengan cepat terlebih dahulu dalam hash yang berbeda (id keranjang = hash% jumlah keranjang, sehingga hash yang berbeda dapat muncul dalam satu keranjang), lalu dalam hash yang sama di sepanjang simpul: <br><img src="https://habrastorage.org/getpro/habr/post_images/920/cc6/95b/920cc695bd3a4a41f956a7782a3b65aa.gif" alt="lewati"></li><li>  Node di mana kunci dan data disimpan diambil dari array node yang sebelumnya dialokasikan, jumlah node bertepatan dengan kapasitas cache.  Pengidentifikasi Atom menunjukkan simpul mana yang akan diambil berikutnya - jika mencapai akhir kumpulan simpul, dimulai dengan 0 = sehingga pengalokasi berjalan dalam lingkaran menimpa node lama ( <a href="">cache LRU di OnCacheMLRU</a> ). </li></ol><br><p>  Untuk kasus ketika perlu bahwa elemen paling populer dalam permintaan pencarian disimpan dalam cache, <a href="">kelas OnCacheMMRU kedua dibuat</a> , algoritma adalah sebagai berikut: selain kapasitas cache, konstruktor kelas juga melewati parameter kedua uint32_t kegunaan, batas popularitas adalah jika jumlah permintaan pencarian yang ingin simpul saat ini dari cyclic pool berkurang Jika batas-batasnya tidak berguna, maka simpul tersebut digunakan kembali untuk operasi penyisipan berikutnya (akan digusur).  Jika pada lingkaran ini popularitas node (std :: atomic &lt;uint32_t&gt; yang digunakan {0}) tinggi, maka pada saat meminta pengalokasi dari kumpulan siklus, node akan dapat bertahan, tetapi penghitung popularitas akan diatur ulang ke 0. Jadi akan ada lingkaran lain dari pengalokasi pengalokasian pada kumpulan node dan akan mendapatkan kesempatan untuk mendapatkan kembali popularitas agar terus eksis.  Yaitu, itu adalah campuran dari algoritma MRU (di mana yang paling populer bertahan dalam cache selamanya) dan MQ (di mana seumur hidup dilacak).  Cache terus diperbarui dan pada saat yang sama berfungsi dengan sangat cepat - alih-alih 10 server Anda dapat menempatkan 1 .. </p><br><p>  Secara umum, algoritma caching menghabiskan waktu untuk hal-hal berikut: </p><br><ol><li>  Memelihara infrastruktur cache (wadah, pengalokasi, pelacakan masa pakai dan popularitas elemen) </li><li>  Perhitungan hash dan operasi perbandingan utama saat menambahkan / mencari data </li><li>  Algoritma Pencarian: Pohon Merah-Hitam, Tabel Hash, Daftar Lewati, ... </li></ol><br><p>  Itu hanya perlu untuk mengurangi waktu operasi dari masing-masing item ini, mengingat fakta bahwa algoritma paling sederhana adalah kompleks untuk sementara dan seringkali paling efisien, karena logika apa pun membutuhkan siklus CPU.  Yaitu, apa pun yang Anda tulis, ini adalah operasi yang harus terbayar tepat waktu dibandingkan dengan metode enumerasi sederhana: sementara fungsi selanjutnya disebut, enumerasi harus melalui ratusan atau dua node lainnya.  Dalam hal ini, cache multi-threaded akan selalu hilang dalam mode single-threaded, karena melindungi keranjang melalui std :: shared_mutex dan node melalui std :: atomic_flag in_use tidak gratis.  Oleh karena itu, untuk mengeluarkan di server, saya menggunakan <a href="">cache</a> single-threaded OnCacheSMRU di utas server Epoll utama (hanya operasi panjang pada bekerja dengan DBMS, disk, kriptografi diambil dalam alur kerja paralel).  Untuk penilaian komparatif, versi kasus uji single-threaded digunakan: </p><br><p>  Test case1 - kunci dalam bentuk array angka acak uint64_t keyArray [3]: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1ce/b9f/648/1ceb9f648a8899ed3ac711d236c6c0d1.png" alt="TestCase1.1thread"></p><br><p>  Uji case2 - kunci sebagai string: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d9d/b3f/aef/d9db3faefdd6c2ab68dd86b89fda15a6.png" alt="TestCase2.1thread"></p><br><p>  Sebagai kesimpulan, saya ingin memberi tahu Anda hal lain yang menarik yang dapat diekstraksi dari sumber bangku tes: </p><br><ul><li>  <a href="">Parsing pustaka JSON, yang terdiri dari satu file specjson.h,</a> adalah algoritma cepat kecil yang sederhana untuk mereka yang tidak ingin menyeret beberapa megabyte kode orang lain ke dalam proyek mereka untuk mengurai file pengaturan atau JSON masuk dari format yang dikenal. </li><li>  Suatu pendekatan dengan menyuntikkan implementasi operasi platform spesifik dalam bentuk (kelas LinuxSystem: public ISystem {...}) alih-alih tradisional (#ifdef _WIN32).  Lebih mudah untuk membungkus, misalnya, semaphore, bekerja dengan perpustakaan yang terhubung secara dinamis, layanan - di kelas hanya ada kode dan header dari sistem operasi tertentu.  Jika Anda membutuhkan sistem operasi lain, Anda menyuntikkan implementasi lain (kelas WindowsSystem: public ISystem {...}). </li><li>  Stand akan menuju CMake - akan lebih mudah untuk membuka proyek CMakeLists.txt di Qt Creator atau Microsoft Visual Studio 2017. Bekerja dengan proyek melalui CmakeLists.txt memungkinkan Anda untuk mengotomatiskan beberapa operasi persiapan - misalnya, menyalin file kasus uji dan file konfigurasi ke direktori instalasi: </li></ul><br><pre> <code class="cmake hljs"> <span class="hljs-comment"><span class="hljs-comment"># Coping assets (TODO any change&amp;rerun CMake to copy): FILE(MAKE_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/assets) FILE(GLOB_RECURSE SpecAssets ${CMAKE_CURRENT_SOURCE_DIR}/assets/*.* ${CMAKE_CURRENT_SOURCE_DIR}/assets/* ) FOREACH(file ${SpecAssets}) FILE(RELATIVE_PATH ITEM_PATH_REL ${CMAKE_CURRENT_SOURCE_DIR}/assets ${file} ) GET_FILENAME_COMPONENT(dirname ${ITEM_PATH_REL} DIRECTORY) FILE(MAKE_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/assets/${dirname}) FILE(COPY ${file} DESTINATION ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/assets/${dirname}) ENDFOREACH()</span></span></code> </pre> <br><ul><li>  Bagi mereka yang menguasai fitur-fitur baru C ++ 17, ini adalah contoh bekerja dengan std :: shared_mutex, std :: pengalokasi &lt;std :: shared_mutex&gt;, static thread_local di templat (ada nuansa - di mana mengalokasikan?), Meluncurkan sejumlah besar tes di utas dalam berbagai cara dengan mengukur waktu eksekusi: </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//Prepare insert threads: for (i = cnt_insert_threads; i; --i) { std::promise&lt;InsertResults&gt; prom; fut_insert_results.emplace_back(prom.get_future()); threads.emplace_back(std::thread (&amp;TestCase2::insert_in_thread, this, curSize, std::move(prom), p_tester)); } // for insert //Prepare find threads: for (i = cnt_find_threads; i; --i) { std::packaged_task&lt;FindResults(TestCase2 *i, int, IAlgorithmTester *)&gt; ta( [](TestCase2 *i, int count, IAlgorithmTester *p_tester){ return i-&gt;find_in_thread(count, p_tester); }); fut_find_results.emplace_back(ta.get_future()); threads.emplace_back( std::thread (std::move(ta), this, curSize, p_tester)); } // for find //Banzai!!! auto start = std::chrono::high_resolution_clock::now(); l_cur_system.get()-&gt;signal_semaphore(cnt_find_threads + cnt_insert_threads); std::for_each(threads.begin(), threads.end(), std::mem_fn(&amp;std::thread::join)); auto end = std::chrono::high_resolution_clock::now();</span></span></code> </pre> <br><ul><li>  Petunjuk langkah demi langkah tentang cara mengompilasi, mengkonfigurasi dan menjalankan bangku tes ini - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WiKi</a> . <br>  Jika Anda belum memiliki petunjuk langkah demi langkah untuk sistem operasi yang nyaman, saya akan berterima kasih atas kontribusi ke repositori untuk menerapkan ISystem dan instruksi kompilasi langkah demi langkah (untuk WiKi) ... Atau cukup tulis saya - Saya akan mencoba mencari waktu untuk meningkatkan mesin virtual dan menjelaskan langkah-langkah untuk perakitan. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450004/">https://habr.com/ru/post/id450004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449994/index.html">Delapan aturan emas Schneiderman akan membantu Anda membuat antarmuka yang lebih baik</a></li>
<li><a href="../id449996/index.html">Memahami Algoritma FFT</a></li>
<li><a href="../id449998/index.html">FAQ: apa yang perlu diketahui oleh seorang pelancong tentang vaksinasi sebelum bepergian</a></li>
<li><a href="../id450000/index.html">(Kanan ke kiri (Melalui Kaca Mencari</a></li>
<li><a href="../id450002/index.html">Menemukan Bug di LLVM 8 dengan PVS-Studio</a></li>
<li><a href="../id450006/index.html">Pendinginan pusat data chiller: pendingin mana yang harus dipilih?</a></li>
<li><a href="../id450008/index.html">Temukan bug di LLVM 8 menggunakan penganalisa PVS-Studio</a></li>
<li><a href="../id450010/index.html">Penyimpanan, cadangan, dan katalogisasi foto</a></li>
<li><a href="../id450016/index.html">Pembuatan sistem verifikasi formal dari awal. Bagian 1: mesin virtual karakter dalam PHP dan Python</a></li>
<li><a href="../id450018/index.html">Duo matematika memetakan wilayah permukaan minimal yang tak berujung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>