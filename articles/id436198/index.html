<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚍 ⚫️ 👨🏿 Graph Node Dungeon Generator 🙁 👷 👋🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam posting ini saya akan menjelaskan algoritma untuk generasi prosedural tingkat dungeon dua dimensi dengan struktur yang telah ditentukan. Di bagi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Graph Node Dungeon Generator</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436198/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pt/uh/r0/ptuhr0jo9giaq3dkb15uiqlfp30.png" alt="gambar"></div><br>  Dalam posting ini saya akan menjelaskan algoritma untuk generasi prosedural tingkat dungeon dua dimensi dengan struktur yang telah ditentukan.  Di bagian pertama, deskripsi umum akan disajikan, dan di bagian kedua, implementasi algoritma. <br><br><h2>  Pendahuluan </h2><br>  Algoritma ini ditulis sebagai bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari pekerjaan sarjana</a> dan didasarkan pada artikel oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ma et al (2014)</a> .  Tujuan dari pekerjaan ini adalah untuk mempercepat algoritma dan melengkapi dengan fungsi-fungsi baru.  Saya cukup senang dengan hasilnya, karena kami membuat algoritma yang cukup cepat untuk menggunakannya selama eksekusi permainan.  Setelah menyelesaikan pekerjaan sarjana, kami memutuskan untuk mengubahnya menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> dan mengirimkannya ke konferensi Game-ON 2018. <br><br><h2>  Algoritma </h2><br>  Untuk membuat level gim, algoritma menerima sebagai input sekumpulan blok bangunan poligonal dan grafik konektivitas level (level topologi).  Node pada grafik menunjukkan ruang, dan ujung-ujungnya menentukan koneksi di antara mereka.  Tujuan dari algoritma ini adalah untuk menetapkan setiap node dari grafik bentuk dan lokasi ruangan sehingga tidak ada dua bentuk ruangan yang bersilangan, dan setiap pasangan kamar tetangga dapat dihubungkan dengan pintu. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41f/ed9/68f/41fed968fc3150ffb6285e660ff2ec5c.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96a/68a/302/96a68a302c5af7bc046644a659f0cc81.png"></div><br>  (b) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc1/79e/c88/fc179ec88afc1fa1889937a2df25c029.png"></div><br>  (c) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9f/898/224/d9f8982240071dcb3d9205207912a46f.png"></div><br>  (d) <br><br>  Gambar (c) dan (d) menunjukkan diagram yang dihasilkan dari grafik input (a) dan blok bangunan (b). <br><br>  Menggunakan grafik konektivitas, seorang desainer game dapat dengan mudah mengontrol alur permainan.  Apakah Anda memerlukan satu jalur umum ke ruang bos dengan beberapa jalur samping opsional?  Mulai saja dengan grafik jalur dan kemudian tentukan beberapa node di mana pemain dapat memilih: pergi di sepanjang jalur utama, atau menjelajahi jalur samping, dengan kemungkinan harta dan / atau monster yang menunggunya.  Apakah Anda perlu memotong jalan?  Cukup pilih dua node dalam grafik dan tambahkan jalan pendek yang menghubungkannya.  Kemungkinan skema ini tidak terbatas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/619/044/41a/61904441a82fd281642664a0e784513d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fe/b4e/65e/9feb4e65e116328e42b3e9638911fae5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83c/fd9/d63/83cfd9d6388c784f88c818e7bc6c9513.png"></div><br>  <i>Contoh grafik input.</i>  <i>Jalur utama ditunjukkan dengan warna merah, jalur bantu berwarna biru, jalur pendek berwarna oranye.</i> <br><br>  Algoritme ini tidak hanya memungkinkan perancang permainan untuk mengelola struktur tingkat tinggi dari peta yang dihasilkan, tetapi juga menyediakan kemampuan untuk mengontrol tampilan masing-masing kamar dan bagaimana menghubungkannya satu sama lain. <br><br><h3>  Bentuk berbeda untuk ruangan berbeda </h3><br>  Saya menyebutkan ruang bos di akhir level.  Kami tidak ingin ruang bos terlihat seperti kamar biasa lainnya, bukan?  Algoritme memungkinkan Anda untuk mengatur formulir untuk setiap kamar.  Sebagai contoh, kita dapat membuat ruang di awal level dan ruang bos, yang harus memiliki set bentuk ruangan sendiri, dan satu set umum untuk semua kamar lainnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/988/e05/e1f988e05bf84eea4209c128ac0b9e60.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f97/b39/b15/f97b39b15661d51ad7cf3a30a4e9b80a.png"></div><br>  Dua sirkuit dihasilkan dari grafik input, di mana bentuk khusus kamar dikaitkan dengan nomor kamar 8. <br><br><h3>  Posisi pintu yang ditunjukkan secara eksplisit </h3><br>  Bayangkan bahwa Anda memiliki skrip rapat bos berkualitas tinggi, dan kami membutuhkan pemain untuk memasuki ruang bos dari ubin tertentu.  Atau kami mungkin memiliki templat kamar tempat beberapa ubin dicadangkan untuk dinding dan hambatan lainnya.  Algoritma ini memungkinkan para desainer untuk secara eksplisit mengatur posisi pintu yang mungkin untuk bentuk ruang individu. <br><br>  Namun terkadang tujuannya mungkin sebaliknya.  Kita bisa membuat templat ruang sedemikian rupa sehingga pintu-pintunya bisa ada di mana saja.  Karena itu, kami menerapkan batasan lebih sedikit pada algoritme, oleh karena itu, sering berjalan lebih cepat, dan sirkuit yang dihasilkan mungkin tampak kurang monoton dan lebih organik.  Untuk situasi seperti itu, dimungkinkan untuk hanya menunjukkan panjang pintu dan seberapa jauh mereka harus dari sudut.  Jarak dari sudut adalah semacam kompromi antara pengaturan manual semua pintu dan keberadaan pintu di mana saja. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13d/cf8/05f/13dcf805f54ce10ad637ce1c6e298b28.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/e9f/51e/7bee9f51e10cda43d07163e27f7ff1dd.png"></div><br>  (b) <br><br>  Gambar (a) menggambarkan berbagai jenis penempatan pintu - ruang persegi memiliki 8 posisi pintu yang jelas, dan ruang persegi panjang menggunakan panjang dan jarak dari sudut.  Gambar (b) menunjukkan diagram sederhana yang dihasilkan dengan bentuk ruangan pada Gambar (a). <br><br><h3>  Koridor antar kamar </h3><br>  Ketika kita berbicara tentang tingkat bawah tanah, kita sering membayangkan kamar yang dihubungkan oleh koridor yang sempit.  Saya ingin berasumsi bahwa koneksi pada grafik input menunjukkan koridor, tetapi tidak.  Mereka hanya menjamin bahwa semua node tetangga akan terhubung langsung oleh pintu.  Jika kita ingin kamar dihubungkan oleh koridor, maka kita perlu memasukkan simpul baru di antara semua pasangan kamar tetangga dan berpura-pura bahwa ini adalah kamar koridor (dengan bentuk kamar tertentu dan posisi pintu tertentu). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/56a/2b3/b5956a2b30f27882272fa44fe540f0bb.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbc/91d/b4e/fbc91db4e3beec215ad06cc7799cc56a.png"></div><br>  (b) <br><br>  Sebuah ilustrasi tentang bagaimana kita dapat memodifikasi grafik input untuk menambahkan koridor antar ruangan.  Gambar (a) menunjukkan grafik input sebelum menambahkan ruang koridor.  Gambar (b) menunjukkan grafik input yang dibuat dari (a) dengan menambahkan kamar baru antara semua kamar yang berdekatan dari grafik asli. <br><br>  Sayangnya, ini sangat menyulitkan tugas algoritma, karena sering kali jumlah node berlipat ganda.  Oleh karena itu, saya menerapkan versi algoritma yang memperhitungkan koridor akun, yang memungkinkan untuk mengurangi penurunan kinerja ketika mengatur ruang koridor.  Saat ini, algoritma mendukung baik koridor antara semua kamar, atau tidak adanya koridor, tetapi di masa depan saya berencana untuk membuatnya lebih fleksibel. <br><br><h2>  Contohnya </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/c4c/b17/b01c4cb173e0b315ce81c842a617e32c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2b/5a0/5aa/a2b5a05aa014d12b0fc70d23a540997d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/5b7/de6/3055b7de654c62dc96c1e83ad510e199.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80e/d9e/b26/80ed9eb26994f6b395e9fa2af34b6dce.png"></div><br>  <i>Beberapa skema dihasilkan dari set blok bangunan yang berbeda dan dengan koridor dihidupkan.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/738/8a4/a44/7388a4a4466fe32fc9b9975e71473936.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1e/1ed/95b/c1e1ed95b4a9236c02fc11ed1bb33ed9.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/628/f19/025/628f19025acf78eed8aa199347804f9e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa7/7e5/03d/aa77e503dbb791e78189777bc875e2cd.png"></div><br>  <i>Beberapa skema dihasilkan dari set blok bangunan yang berbeda dengan koridor menyala dan mati.</i> <br><br>  Pada bagian kedua posting saya akan berbicara tentang operasi internal dari algoritma. <br><br>  Saya juga sedang mengerjakan plugin Unity untuk pembuatan dungeon prosedural, yang akan menyertakan algoritma ini.  Saya melakukan ini karena meskipun kemungkinan menggunakan algoritma ini secara langsung dalam Unity (ditulis dalam C #), kenyamanan bekerja dengannya jauh dari ideal.  Dibutuhkan banyak waktu untuk membuat templat ruang tanpa GUI, dan banyak kode diperlukan untuk mengubah output dari algoritma ke representasi yang digunakan di dalam gim. <br><br>  Karena saya sendiri bukan pengembang game, tujuan saya adalah membuat plugin yang cukup baik untuk digunakan orang lain.  Jika semuanya berjalan dengan baik, maka saya akan mencoba untuk mempublikasikan pembaruan ketika saya memiliki sesuatu yang menarik untuk dikatakan.  Saya sudah punya beberapa ide tentang generator itu sendiri dan tentang pengujian kemampuannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d12/43f/2c0/d1243f2c05e18826eb3d97a30b6f743c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ed/34f/05c/7ed34f05ca19aa127aae0938e26d63ec.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad4/d48/39f/ad4d4839f9ca1c333c2fbb3e0333989e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0e/805/121/c0e805121b2cda153980875d780d5f9b.png"></div><br>  <i>Screenshot dari plugin Unity (proyek sedang dalam pengembangan)</i> <br><br><h2>  Bagian 2. Implementasi algoritma </h2><br>  Pada bagian ini saya akan berbicara tentang ide-ide dasar yang diletakkan di dasar algoritma yang dijelaskan di bagian pertama posting.  Awalnya, saya ingin menggambarkan konsep dasar bersama dengan perbaikan utama yang diperlukan agar algoritma menjadi cukup cepat.  Namun, ternyata, bahkan konsep dasar lebih dari cukup untuk posting ini.  Oleh karena itu, saya memutuskan untuk mengungkapkan peningkatan kinerja di artikel mendatang. <br><br><h2>  Motivasi </h2><br>  Sebelum beralih ke implementasi, saya ingin menunjukkan hasil dari apa yang akan kami lakukan.  Video di bawah ini menunjukkan 30 sirkuit berbeda yang dihasilkan dari satu grafik input dan satu set blok bangunan.  Algoritme selalu berhenti selama 500 ms setelah menghasilkan rangkaian, dan kemudian mencoba untuk menghasilkan yang berikutnya. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Browser Anda tidak mendukung video HTML5. <source src="https://ondra.nepozitek.cz/blog/wp-content/uploads/2019/01/GeneratorWindow-12_01_2019-23_48_40.mp4" type="video/mp4"></video></div></div></div><br><h2>  Bagaimana cara kerjanya </h2><br>  Tujuan dari algoritma ini adalah untuk menetapkan bentuk dan posisi ruangan untuk setiap node dalam grafik sehingga tidak ada dua kamar yang bersilangan, dan kamar-kamar tetangga terhubung dengan pintu. <br><br>  Salah satu cara untuk mencapai ini adalah mencoba semua kemungkinan kombinasi bentuk ruangan dan posisi mereka.  Namun, seperti yang Anda duga, ini akan sangat tidak efisien, dan kami mungkin tidak akan dapat menghasilkan sirkuit, bahkan berdasarkan pada grafik input yang sangat sederhana. <br><br>  Alih-alih mencari semua kemungkinan kombinasi, algoritme ini menghitung cara menghubungkan semua kamar secara tepat (yang disebut ruang konfigurasi) dan menggunakan informasi ini untuk mengarahkan pencarian.  Sayangnya, bahkan dengan informasi ini, masih cukup sulit untuk menemukan skema yang tepat.  Oleh karena itu, untuk studi ruang pencarian yang efektif, kami menggunakan teknik optimisasi probabilistik (dalam hal ini, simulasi anil).  Dan untuk percepatan optimalisasi lebih lanjut, kami memecah tugas input menjadi lebih kecil dan lebih mudah untuk menyelesaikan subtugas.  Ini dilakukan dengan membagi grafik menjadi bagian-bagian yang lebih kecil (disebut rantai) dengan pembuatan skema berikutnya untuk masing-masing secara berurutan. <br><br><h2>  Ruang Konfigurasi </h2><br>  Untuk sepasang poligon di mana satu tetap di tempatnya dan yang lain dapat bergerak bebas, ruang konfigurasi adalah seperangkat posisi poligon bebas di mana dua poligon tidak berpotongan dan dapat dihubungkan dengan pintu.  Saat bekerja dengan poligon, setiap ruang konfigurasi dapat direpresentasikan sebagai kumpulan garis yang mungkin kosong dan dihitung dengan alat geometris sederhana. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/134/823/45e/13482345ed98c982677a10e53ddaec2d.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8c/1eb/62c/b8c1eb62c2f6d8f166670781dfe35336.png"></div><br>  (b) <br><br>  Konfigurasi ruang.  Gambar (a) menunjukkan ruang konfigurasi (garis merah) dari persegi panjang bebas relatif terhadap poligon berbentuk L tetap.  Ini menentukan semua lokasi pusat alun-alun di mana dua blok tidak bersinggungan dan saling menyentuh.  Gambar (b) menunjukkan persimpangan (titik-titik kuning) dari ruang konfigurasi dari bujur sangkar yang bergerak sehubungan dengan dua persegi panjang tetap. <br><br>  Algoritma berikut digunakan untuk menghitung ruang konfigurasi satu blok tetap dan satu blok gratis.  Kami memilih titik referensi pada blok bergerak dan mempertimbangkan semua lokasi di <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>b</mi><mi>b</mi><msup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>R</mi></mrow><mn>2</mn></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.843ex" height="2.539ex" viewBox="0 -987.6 4668.4 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-6D" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-61" x="1128" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-74" x="1658" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-68" x="2019" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-62" x="2596" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-62" x="3025" y="0"></use><g transform="translate(3455,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-52" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMAIN-32" x="1074" y="581"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>b</mi><mi>b</mi><msup><mrow class="MJX-TeXAtom-ORD"><mi>R</mi></mrow><mn>2</mn></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ mathbb {R} ^ 2 </script>  , sedemikian rupa sehingga ketika memindahkan poligon sehingga titik rujukannya terletak di lokasi ini, baik balok yang dapat bergerak maupun yang sudah terpasang saling bersentuhan, tetapi tidak berpotongan.  Himpunan semua titik tersebut membentuk ruang konfigurasi dua blok (Gambar (a) di atas).  Untuk mendapatkan ruang konfigurasi blok bergerak sehubungan dengan dua atau lebih blok tetap, persimpangan ruang konfigurasi individu dihitung (Gambar (b) di atas). <br><br>  Algoritma menggunakan ruang konfigurasi dalam dua cara.  Pertama, alih-alih mencoba posisi acak dari masing-masing kamar, kami menggunakan ruang konfigurasi untuk mencari posisi yang mengarah ke jumlah kamar terdekat yang terbesar yang terhubung oleh pintu.  Untuk melakukan ini, kita perlu memperoleh persimpangan ruang kosong maksimum dari tetangga.  Kedua, kami menggunakan ruang konfigurasi untuk memeriksa apakah semua pasangan kamar tetangga dapat dihubungkan dengan pintu.  Ini dilakukan dengan memeriksa apakah posisi ruangan berada di dalam ruang konfigurasi semua tetangganya. <br><br>  Karena bentuk ruang tidak berubah selama pelaksanaan permainan, kami dapat menghitung pra-ruang konfigurasi semua pasang bentuk ruang sebelum algoritma dimulai.  Berkat ini, keseluruhan algoritma dipercepat secara signifikan. <br><br><h2>  Skema tambahan </h2><br>  Saat memecahkan masalah yang kompleks, salah satu pendekatan yang mungkin adalah membaginya menjadi subtugas yang lebih kecil dan sederhana, dan menyelesaikannya.  Inilah tepatnya yang akan kita lakukan dengan tugas menempatkan masing-masing kamar.  Alih-alih mengatur semua kamar pada satu waktu, kami akan memecah grafik input menjadi subgraph yang lebih kecil dan mencoba membuat diagram dari mereka satu per satu.  Para penulis algoritma asli menyebut subgraph ini "rantai" karena prinsip dari grafik ini, di mana setiap node memiliki tidak lebih dari dua tetangga, dan karena itu cukup mudah untuk membuat skema mereka. <br><br>  Sirkuit keluaran akhir selalu merupakan satu komponen yang terhubung, sehingga tidak masuk akal untuk menghubungkan masing-masing komponen ke dalam rangkaian, dan kemudian mencoba menggabungkannya, karena proses penggabungannya bisa sangat rumit.  Oleh karena itu, setelah menempatkan rantai, rantai terhubung berikutnya akan selalu menjadi yang terhubung ke simpul yang sudah berbaris di sirkuit. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Layout </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateLayout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inputGraph</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> emptyLayout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Layout(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;Layout&gt;(); stack.Push(emptyLayout); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!stack.Empty()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> layout = stack.Pop(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextChain = GetNextChain(layout, inputGraph); Layout[] partialLayouts = AddChain(layout, nextChain); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!partialLayouts.Empty()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsFullLayout(partialLayouts[<span class="hljs-number"><span class="hljs-number">0</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> partialLayouts[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { stack.Push(partialLayouts); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  <i>Pseudo-code menunjukkan pendekatan inkremental untuk menemukan skema yang tepat.</i> <br><br>  Kode pseudo yang ditunjukkan di atas menunjukkan implementasi skema tambahan.  Pada setiap iterasi algoritma (baris 6-18), pertama-tama kita mengambil sirkuit terakhir dari stack (baris 7) dan menghitung rantai mana yang akan ditambahkan berikutnya (baris 8).  Ini dapat dilakukan dengan hanya menyimpan jumlah sirkuit terakhir yang ditambahkan ke setiap sirkuit parsial.  Pada langkah berikutnya, kami menambahkan rantai berikut ke sirkuit (jalur 9), menghasilkan beberapa sirkuit terperinci, dan menyimpannya.  Jika fase ekspansi gagal, tetapi tidak ada skema parsial baru yang ditambahkan ke tumpukan, dan algoritma perlu melanjutkan dengan skema parsial yang terakhir disimpan.  Kami menyebut situasi ini sebagai pencarian balik karena algoritme tidak dapat memperpanjang skema parsial saat ini dan harus kembali dan melanjutkan dengan skema tersimpan lainnya.  Ini biasanya diperlukan ketika tidak ada cukup ruang untuk menghubungkan sirkuit tambahan ke simpul yang sudah tersusun di sirkuit.  Juga, pencarian kembali adalah alasan bahwa kami selalu mencoba untuk menghasilkan beberapa skema lanjutan (baris 9).  Kalau tidak, kita tidak akan punya apa-apa untuk dikembalikan.  Proses berakhir ketika kita menghasilkan rangkaian lengkap, atau tumpukan kosong. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90e/909/ca4/90e909ca4640401cf869e4ad2e558d32.png"></div><br>  (a) Input grafik <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/736/f69/8ca736f69ce1ba31910d12c49f0546a4.png"></div><br>  (b) Diagram sebagian <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0e/74f/284/d0e74f2846ea5cdd8351bd1a20561704.png"></div><br>  (c) Diagram sebagian <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c4/708/d35/2c4708d351e2b4a13a98cffa9a090a58.png"></div><br>  (d) Garis besar penuh <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3b/13b/796/b3b13b796d79dd8587d23d82cee6da52.png"></div><br>  (e) Garis besar lengkap <br><br>  Skema tambahan.  Gambar (b) dan (c) menunjukkan dua diagram parsial setelah merencanakan rangkaian pertama.  Gambar (d) menunjukkan sirkuit lengkap setelah ekspansi (b) oleh sirkuit kedua.  Gambar (e) menunjukkan sirkuit lengkap setelah ekspansi (c) oleh sirkuit kedua. <br><br>  Untuk membagi grafik menjadi beberapa bagian, Anda perlu menemukan embedding datar dari grafik input, yaitu gambar pada bidang di mana ujung-ujungnya hanya bersilangan pada titik akhir.  Lampiran ini kemudian digunakan untuk mendapatkan semua wajah grafik.  Gagasan utama dari dekomposisi adalah bahwa lebih sulit untuk membuat sirkuit dari siklus, karena node mereka memiliki batasan lebih.  Oleh karena itu, kami mencoba mengatur siklus pada awal dekomposisi, sehingga mereka diproses sedini mungkin dan mengurangi kemungkinan perlunya kembali pada tahap berikutnya.  Rantai dekomposisi pertama dibentuk oleh wajah terkecil dari lampiran, dan wajah selanjutnya kemudian ditambahkan dalam urutan pencarian pertama.  Jika ada wajah lain yang bisa dipilih, maka yang terkecil dari mereka digunakan.  Ketika tidak ada lagi wajah yang tersisa, komponen non-siklik yang tersisa ditambahkan.  Gambar 4 menunjukkan contoh dekomposisi dalam rantai, yang diperoleh sesuai dengan langkah-langkah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/c57/c57/e0fc57c571633c5f70b818c412e8d80c.png"></div><br>  (a) <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bb/02c/950/4bb02c950ef9309be5df082e0c630ec3.png"></div><br>  (b) <br><br>  Dekomposisi menjadi rantai.  Gambar (b) menunjukkan contoh cara meletakkan gambar (a) pada suatu rangkaian.  Setiap warna mewakili rantai yang terpisah.  Angka menunjukkan urutan pembuatan rantai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0c/ad3/554/f0cad3554aa63d7cc46e5d9dae334209.png"></div><br>  (c) Desain parsial yang baik <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d00/839/114/d0083911404026fa33a26f529d1db1a0.png"></div>  (d) Garis besar penuh <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b27/f99/ed2/b27f99ed239d73e25a14e3f785ba5bd2.png"></div><br>  (a) Input grafik <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/60c/13b/85c60c13b6479b643855f71f5138f738.png"></div><br>  (B) Grafik parsial buruk <br><br>  Cari dengan pengembalian.  Gambar (b) menunjukkan contoh sirkuit parsial yang buruk, karena tidak ada ruang yang cukup di dalamnya untuk menghubungkan node 0 dan 9. Untuk menghasilkan sirkuit penuh (d), diperlukan kembali ke sirkuit parsial lain (c). <br><br><h2>  Simulasi anil </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritma simulasi anil</a> adalah teknik optimisasi probabilistik yang tujuannya adalah untuk mempelajari ruang sirkuit yang mungkin.  Itu dipilih oleh penulis artikel asli karena ternyata bermanfaat dalam situasi serupa di masa lalu.  Ketika mengimplementasikan algoritma, saya memutuskan untuk menggunakan metode yang sama, karena saya ingin memulai dengan apa yang sudah terbukti efektif dalam menyelesaikan masalah ini.  Namun, saya pikir itu bisa diganti dengan metode lain dan pustaka saya ditulis sedemikian rupa sehingga proses penggantian metode ini cukup sederhana. <br><br>  Algoritma simulasi anil secara iteratif mengevaluasi perubahan kecil dalam konfigurasi saat ini, atau sirkuit.  Ini berarti bahwa kami membuat konfigurasi baru dengan memilih secara acak satu simpul dan mengubah posisi atau bentuknya.  Jika konfigurasi baru meningkatkan fungsi energi, itu selalu diterima.  Jika tidak, ada sedikit peluang untuk menerima konfigurasi.  Kemungkinan membuat keputusan yang lebih buruk berkurang seiring waktu.  Fungsi energi dirancang sedemikian rupa sehingga membebankan denda besar pada titik persimpangan dan titik yang berdekatan tidak saling bersentuhan. <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>E</mi><mo>=</mo><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>A</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>D</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="32.209ex" height="2.66ex" viewBox="0 -987.6 13867.5 1145.2" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-45" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMAIN-3D" x="1042" y="0"></use><g transform="translate(2098,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-65" x="0" y="0"></use><g transform="translate(466,412)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-66" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-72" x="904" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-61" x="1355" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-63" x="1885" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-41" x="2318" y="0"></use><g transform="translate(2170,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-6F" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-6D" x="839" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-65" x="1717" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-67" x="2184" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-61" x="2664" y="0"></use></g></g></g><g transform="translate(7093,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-65" x="0" y="0"></use><g transform="translate(466,412)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-66" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-72" x="904" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-61" x="1355" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-63" x="1885" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-44" x="2318" y="0"></use><g transform="translate(2225,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-6F" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-6D" x="839" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-65" x="1717" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-67" x="2184" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-61" x="2664" y="0"></use></g></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMAIN-2212" x="12366" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMAIN-31" x="13367" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>E</mi><mo>=</mo><msup><mi>e</mi><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>A</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><msup><mi>e</mi><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>D</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><mo>−</mo><mn>1</mn></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> E = e ^ {\ frac {A} {\ omega}} e ^ {\ frac {D} {\ omega}} - 1 </script></p><br>  A adalah total luas persimpangan antara semua pasangan blok dalam diagram.  D adalah jumlah kuadrat dari jarak antara pusat pasangan blok dalam grafik input yang bertetangga tetapi tidak saling menyentuh.  Nilai <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.178ex" height="1.817ex" viewBox="0 -520.7 3090.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-6F" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-6D" x="735" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-65" x="1614" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-67" x="2080" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhIMA51vvsXekfMmkkxHhINs0xuuw#MJMATHI-61" x="2561" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ omega </script>  mempengaruhi kemungkinan anil yang disimulasikan dibiarkan masuk ke konfigurasi terburuk;  parameter ini dihitung dari luas rata-rata blok bangunan. <br><br>  Setelah memilih simpul untuk diubah, kami mengubah bentuk atau posisinya.  Bagaimana kita memilih posisi baru?  Anda dapat memilihnya secara acak, tetapi ini akan sering menurunkan fungsi energi, dan algoritma akan menyatu sangat lambat.  Bisakah kita memilih posisi yang lebih mungkin meningkatkan fungsi energi?  Lihat apa yang saya tuju?  Kami menggunakan ruang konfigurasi untuk memilih posisi yang memenuhi batas jumlah kamar tetangga terbesar. <br><br>  Kemudian, untuk mengubah bentuk, cukup pilih salah satu bentuk ruang yang tersedia.  Sementara algoritma tidak mencoba untuk memutuskan bentuk mana yang paling mungkin membawa kita ke skema yang benar.  Namun, akan menarik untuk mencoba fitur ini dan melihat apakah itu mempercepat algoritma. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">List&lt;Layout&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddChain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chain, layout</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentLayout = GetInitialLayout(layout, chain); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> generatedLayouts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Layout&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n, i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*       */</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= m, j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newLayout = PerturbLayout(currentLayout, chain); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsValid(newLayout)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DifferentEnough(newLayout, generatedLayouts)) { generatedLayouts.Add(newLayout); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/* newLayout ,  currentLayout */</span></span>) { currentLayout = newLayout; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/* ,   ,    newLayout */</span></span>) { currentLayout = newLayout; } } <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> generatedLayouts; }</code> </pre> <br>  Ini adalah pseudo-code dari metode yang bertanggung jawab untuk membuat rangkaian sirkuit terpisah dengan mensimulasikan annealing. <br><br>  Untuk mempercepat seluruh proses, kami akan mencoba menemukan konfigurasi awal berenergi rendah.  Untuk melakukan ini, kami akan mengatur node dalam rantai saat ini untuk pencarian pertama kali, mulai dari yang berdekatan dengan node yang sudah termasuk dalam skema.  Kemudian node yang dipesan ditempatkan satu per satu dan bagi mereka posisi dengan energi terendah dipilih dari ruang konfigurasi.  Di sini kita tidak melakukan backtracking - ini adalah proses serakah yang sederhana. <br><br><h2>  Video Bonus </h2><br>  Video di bawah ini menunjukkan diagram yang dihasilkan dari grafik input yang sama seperti pada video pertama.  Namun, kali ini pendekatan tambahan ditampilkan.  Anda mungkin memperhatikan bahwa algoritme menambahkan rantai simpul satu per satu.  Terlihat juga bahwa kadang-kadang ada dua sirkuit parsial berturut-turut dengan jumlah node yang sama.  Ini terjadi ketika algoritma kembali.  Jika upaya pertama untuk menambahkan rangkaian lain ke rangkaian parsial pertama gagal, maka algoritma akan mencoba sirkuit parsial lain. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Browser Anda tidak mendukung video HTML5. <source src="https://ondra.nepozitek.cz/blog/wp-content/uploads/2019/01/GeneratorWindow-13_01_2019-23_23_30.mp4" type="video/mp4"></video></div></div></div><br><h2>  Bahan yang bisa diunduh </h2><br>  Implementasi algoritma pada .NET dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github saya</a> .  Repositori berisi .NET DLL dan aplikasi WinForms GUI, dikendalikan oleh file konfigurasi YAML. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436198/">https://habr.com/ru/post/id436198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436186/index.html">Apa yang harus dipikirkan selama wawancara NALSD</a></li>
<li><a href="../id436188/index.html">Kebebasan untuk terbang di ujung jari Anda dengan Kontroler Cerdas DJI</a></li>
<li><a href="../id436192/index.html">Simulasi Browser Fisika</a></li>
<li><a href="../id436194/index.html">Cara Kerja Sistem Ivisionon Video Surveillance: Tinjauan Umum Aplikasi Seluler</a></li>
<li><a href="../id436196/index.html">Penguji voyeurisme: cara memata-matai orang dengan benar dan mengapa itu perlu</a></li>
<li><a href="../id436200/index.html">Putusan pengadilan AS: pihak berwenang tidak memiliki hak untuk memaksa seseorang untuk membuka kunci ponsel dengan jari atau wajah</a></li>
<li><a href="../id436202/index.html">Saya kehilangan kepercayaan dalam pengembangan, terbakar, tetapi alat kultus menyelamatkan saya</a></li>
<li><a href="../id436206/index.html">Bagaimana Menyatukan Seni Tanpa Susah payah dengan Java, JavaScript, dan Grafik atau Kisah di Baliknya Membuat Produk Teater Interaktif</a></li>
<li><a href="../id436208/index.html">Torrents baru tidak lagi muncul di Teluk Pirate</a></li>
<li><a href="../id436210/index.html">Biquaternions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>