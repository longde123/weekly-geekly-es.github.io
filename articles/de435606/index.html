<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•§ üî≠ üîì Wie schreibe ich Unit-Tests f√ºr Schauspieler? SObjectizer-Ansatz ‚ôàÔ∏è üôâ üë©üèº‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Akteure vereinfachen die Multithread-Programmierung, indem sie einen gemeinsamen, gemeinsamen ver√§nderlichen Zustand vermeiden. Jeder Schauspieler bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie schreibe ich Unit-Tests f√ºr Schauspieler? SObjectizer-Ansatz</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435606/">  Akteure vereinfachen die Multithread-Programmierung, indem sie einen gemeinsamen, gemeinsamen ver√§nderlichen Zustand vermeiden.  Jeder Schauspieler besitzt seine eigenen Daten, die f√ºr niemanden sichtbar sind.  Akteure interagieren nur √ºber asynchrone Nachrichten.  Daher sind die schrecklichsten Schrecken des Multithreading in Form von Rennen und Deadlocks bei der Verwendung von Schauspielern nicht schrecklich (obwohl Schauspieler ihre Probleme haben, aber darum geht es jetzt nicht). <br><br>  Im Allgemeinen ist das Schreiben von Multithread-Anwendungen mit Akteuren einfach und unterhaltsam.  Einschlie√ülich, weil die Schauspieler selbst leicht und nat√ºrlich geschrieben sind.  Man k√∂nnte sogar sagen, dass das Schreiben von Schauspielercode der einfachste Teil des Jobs ist.  Aber wenn der Schauspieler geschrieben ist, stellt sich eine sehr gute Frage: "Wie kann man die Richtigkeit seiner Arbeit √ºberpr√ºfen?" <br><br>  Die Frage ist wirklich sehr gut.  Wir werden regelm√§√üig gefragt, wenn wir √ºber Schauspieler im Allgemeinen und √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer</a> im Besonderen sprechen.  Und bis vor kurzem konnten wir diese Frage nur allgemein beantworten. <br><br>  Es wurde jedoch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 5.5.24 ver√∂ffentlicht</a> , in der die M√∂glichkeit des Unit-Tests von Akteuren experimentell unterst√ºtzt wurde.  Und in diesem Artikel werden wir versuchen, dar√ºber zu sprechen, was es ist, wie man es benutzt und mit was es implementiert wurde. <br><a name="habracut"></a><br><h1>  Wie sehen Schauspielertests aus? </h1><br>  Wir werden die neuen Funktionen von SObjectizer anhand einiger Beispiele betrachten und weitergeben, was was ist.  Der Quellcode f√ºr die besprochenen Beispiele befindet sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Repository</a> . <br><br>  In der gesamten Geschichte werden die Begriffe "Schauspieler" und "Agent" synonym verwendet.  Sie bezeichnen dasselbe, aber SObjectizer hat in der Vergangenheit den Begriff "Agent" verwendet, so dass im Folgenden "Agent" h√§ufiger verwendet wird. <br><br><h2>  Das einfachste Beispiel mit Pinger und Ponger </h2><br>  Das Beispiel der Schauspieler Pinger und Ponger ist wahrscheinlich das h√§ufigste Beispiel f√ºr Schauspieler-Frameworks.  Man kann sagen, ein Klassiker.  Wenn ja, dann fangen wir mit den Klassikern an. <br><br>  Wir haben also einen Pinger-Agenten, der zu Beginn seiner Arbeit eine Ping-Nachricht an den Ponger-Agenten sendet.  Und der Ponger-Agent sendet eine Pong-Nachricht zur√ºck.  So sieht es im C ++ - Code aus: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Types of signals to be used. struct ping final : so_5::signal_t {}; struct pong final : so_5::signal_t {}; // Pinger agent. class pinger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : pinger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;pong&gt;) { so_deregister_agent_coop_normally(); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } void so_evt_start() override { so_5::send&lt; ping &gt;( m_target ); } }; // Ponger agent. class ponger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : ponger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;ping&gt;) { so_5::send&lt; pong &gt;( m_target ); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } };</span></span></code> </pre> <br>  Unsere Aufgabe ist es, einen Test zu schreiben, der best√§tigt, dass Ponger bei der Registrierung dieser Agenten bei SObjectizer eine Ping-Nachricht und Pinger als Antwort eine Pong-Nachricht erh√§lt. <br><br>  OK  Wir schreiben einen solchen Test mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Doctest</a> Unit-Test-Framework und erhalten: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;doctest/doctest.h&gt; #include &lt;ping_pong/agents.hpp&gt; #include &lt;so_5/experimental/testing.hpp&gt; namespace tests = so_5::experimental::testing; TEST_CASE( "ping_pong" ) { tests::testing_env_t sobj; pinger_t * pinger{}; ponger_t * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::coop_t &amp; coop) { pinger = coop.make_agent&lt; pinger_t &gt;(); ponger = coop.make_agent&lt; ponger_t &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); }); sobj.scenario().define_step("ping") .when(*ponger &amp; tests::reacts_to&lt;ping&gt;()); sobj.scenario().define_step("pong") .when(*pinger &amp; tests::reacts_to&lt;pong&gt;()); sobj.scenario().run_for(std::chrono::milliseconds(100)); REQUIRE(tests::completed() == sobj.scenario().result()); }</span></span></span></span></code> </pre> <br>  Es scheint einfach zu sein.  Mal sehen, was hier passiert. <br><br>  Zun√§chst laden wir Beschreibungen der Support-Tools f√ºr Agententests herunter: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/experimental/testing.hpp&gt;</span></span></span></span></code> </pre> <br>  Alle diese Tools werden im so_5 :: experimentellen :: Test-Namespace beschrieben. Um einen so langen Namen nicht zu wiederholen, f√ºhren wir einen k√ºrzeren und bequemeren Alias ‚Äã‚Äãein: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tests = so_5::experimental::testing;</code> </pre> <br>  Das Folgende ist eine Beschreibung eines einzelnen Testfalls (und wir brauchen hier nicht mehr). <br><br>  Innerhalb des Testfalls gibt es mehrere wichtige Punkte. <br><br>  Erstens ist dies die Erstellung und der Start einer speziellen Testumgebung f√ºr SObjectizer: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj;</code> </pre> <br>  Ohne diese Umgebung kann der ‚ÄûTestlauf‚Äú f√ºr Agenten nicht abgeschlossen werden, aber wir werden etwas sp√§ter dar√ºber sprechen. <br><br>  Die Klasse "testing_env_t" ist der Klasse "wrap_env_t" in SObjectizer sehr √§hnlich.  Auf die gleiche Weise startet der SObjectizer im Konstruktor und stoppt im Destruktor.  Wenn Sie also Tests schreiben, m√ºssen Sie nicht daran denken, SObjectizer zu starten und zu stoppen. <br><br>  Als n√§chstes m√ºssen wir Pinger- und Ponger-Agenten erstellen und registrieren.  In diesem Fall m√ºssen wir diese Agenten zur Bestimmung der sogenannten verwenden.  "Testszenario."  Daher speichern wir Zeiger auf Agenten separat: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  Und dann beginnen wir mit dem ‚ÄûTestszenario‚Äú zu arbeiten. <br><br>  Ein Testfall ist ein Teil, der aus einer direkten Abfolge von Schritten besteht, die von Anfang bis Ende ausgef√ºhrt werden m√ºssen.  Der Ausdruck "aus einer direkten Sequenz" bedeutet, dass in SObjectizer-5.5.24 die Skriptschritte streng sequentiell "arbeiten", ohne Verzweigungen oder Schleifen. <br><br>  Das Schreiben eines Tests f√ºr Agenten ist die Definition eines Testskripts, das ausgef√ºhrt werden muss.  Das hei√üt,  Alle Schritte des Testszenarios sollten funktionieren, vom ersten bis zum letzten. <br><br>  Daher definieren wir in unserem Testfall ein zweistufiges Szenario.  Im ersten Schritt wird √ºberpr√ºft, ob der Ponger-Agent die Ping-Nachricht empf√§ngt und verarbeitet: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"ping"</span></span>) .when(*ponger &amp; tests::reacts_to&lt;ping&gt;());</code> </pre> <br>  Der zweite Schritt √ºberpr√ºft, ob der Pinger-Agent eine Pong-Nachricht empf√§ngt: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"pong"</span></span>) .when(*pinger &amp; tests::reacts_to&lt;pong&gt;());</code> </pre> <br>  Diese beiden Schritte reichen f√ºr unseren Testfall v√∂llig aus, daher fahren wir nach ihrer Bestimmung mit der Ausf√ºhrung des Skripts fort.  Wir f√ºhren das Skript aus und lassen es nicht l√§nger als 100 ms funktionieren: <br><br><pre> <code class="cpp hljs">sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>));</code> </pre> <br>  Hundert Millisekunden sollten mehr als genug sein, damit die beiden Agenten Nachrichten austauschen k√∂nnen (selbst wenn der Test in einer sehr langsamen virtuellen Maschine ausgef√ºhrt wird, wie dies manchmal bei Travis CI der Fall ist).  Wenn wir beim Schreiben von Agenten einen Fehler gemacht oder ein Testskript falsch beschrieben haben, macht es keinen Sinn, l√§nger als 100 ms auf die Fertigstellung eines fehlerhaften Skripts zu warten. <br><br>  Nach der R√ºckkehr von run_for () kann unser Skript entweder erfolgreich abgeschlossen werden oder nicht.  Deshalb √ºberpr√ºfen wir einfach das Ergebnis des Skripts: <br><br><pre> <code class="cpp hljs">REQUIRE(tests::completed() == sobj.scenario().result());</code> </pre> <br>  Wenn das Skript nicht erfolgreich abgeschlossen wurde, f√ºhrt dies zum Fehlschlagen unseres Testfalls. <br><br><h3>  Einige Klarstellungen und Erg√§nzungen </h3><br>  Wenn wir diesen Code in einem normalen SObjectizer ausf√ºhren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  Dann w√ºrden die Agenten von Pinger und Ponger h√∂chstwahrscheinlich Nachrichten austauschen und ihre Arbeit abschlie√üen, bevor sie von Introduce_coop zur√ºckkehren (Wunder des Multithreading sind solche).  In der Testumgebung, die dank testing_env_t erstellt wird, geschieht dies jedoch nicht. Die Agenten von Pinger und Ponger warten geduldig, bis wir unser Testskript ausf√ºhren.  Wie passiert das? <br><br>  Tatsache ist, dass sich die Agenten in der Testumgebung in einem eingefrorenen Zustand zu befinden scheinen.  Das hei√üt,  Nach der Registrierung sind sie in SObjectizer vorhanden, k√∂nnen jedoch keine ihrer Nachrichten verarbeiten.  Daher wird auch so_evt_start () nicht f√ºr Agenten aufgerufen, bevor das Testskript ausgef√ºhrt wird. <br><br>  Wenn wir das Testskript mit der Methode run_for () ausf√ºhren, taut das Testskript zuerst alle eingefrorenen Agenten auf.  Anschlie√üend empf√§ngt das Skript vom SObjectizer Benachrichtigungen dar√ºber, was mit den Agenten geschieht.  Zum Beispiel, dass der Ponger-Agent die Ping-Nachricht empfangen hat und dass der Ponger-Agent die Nachricht verarbeitet, aber nicht abgelehnt hat. <br><br>  Wenn solche Benachrichtigungen beim Testskript eingehen, versucht das Skript, sie bis zum ersten Schritt ‚Äûanzuprobieren‚Äú.  Wir haben also eine Benachrichtigung, dass Ponger Ping erhalten und verarbeitet hat - ist es f√ºr uns interessant oder nicht?  Es stellt sich heraus, dass es interessant ist, weil die Beschreibung des Schritts genau das sagt: Es funktioniert, wenn Ponger auf Ping reagiert.  Was wir im Code sehen: <br><br><pre> <code class="cpp hljs">.when(*ponger &amp; tests::reacts_to&lt;ping&gt;())</code> </pre> <br>  OK  Also hat der erste Schritt funktioniert, fahren Sie mit dem n√§chsten Schritt fort. <br><br>  Als n√§chstes kommt eine Benachrichtigung, dass Agent Pinger auf Pong reagiert hat.  Und genau das brauchen Sie, damit der zweite Schritt funktioniert: <br><br><pre> <code class="cpp hljs">.when(*pinger &amp; tests::reacts_to&lt;pong&gt;())</code> </pre> <br>  OK  Der zweite Schritt hat also funktioniert. Haben wir noch etwas?  Nein.  Dies bedeutet, dass das gesamte Testskript abgeschlossen ist und Sie die Steuerung von run_for () zur√ºckgeben k√∂nnen. <br><br>  Hier im Prinzip, wie das Testskript funktioniert.  Tats√§chlich ist alles etwas komplizierter, aber wir werden komplexere Aspekte ansprechen, wenn wir ein komplexeres Beispiel betrachten. <br><br><h2>  Beispiel Essphilosophen </h2><br>  Komplexere Beispiele f√ºr Testmittel lassen sich bei der L√∂sung der bekannten Aufgabe "Dining Philosophen" erkennen.  Bei den Schauspielern kann dieses Problem auf verschiedene Arten gel√∂st werden.  Als n√§chstes betrachten wir die trivialste L√∂sung: Sowohl Schauspieler als auch Philosophen sind in Form von Akteuren vertreten, f√ºr die Philosophen k√§mpfen m√ºssen.  Jeder Philosoph denkt eine Weile nach und versucht dann, die Gabelung links zu nehmen.  Wenn dies gelingt, versucht er, die Gabelung rechts zu nehmen.  Gelingt dies, dann isst der Philosoph einige Zeit, danach legt er die Gabeln nieder und beginnt zu denken.  Wenn es nicht m√∂glich war, den Stecker rechts zu nehmen (d. H. Er wurde von einem anderen Philosophen genommen), gibt der Philosoph den Stecker links zur√ºck und denkt noch einige Zeit nach.  Das hei√üt,  Dies ist keine gute L√∂sung in dem Sinne, dass ein Philosoph m√∂glicherweise zu lange verhungert.  Aber dann ist es sehr einfach.  Und hat den Umfang, die F√§higkeit zu demonstrieren, Agenten zu testen. <br><br>  Quellcodes mit der Implementierung von Fork- und Philosopher-Agenten finden Sie <a href="">hier</a> . In dem Artikel werden wir sie nicht als platzsparend betrachten. <br><br><h3>  Test auf Gabel </h3><br>  Der erste Test f√ºr Agenten der Dining Philosophers wird f√ºr Agent Fork sein. <br><br>  Dieser Agent arbeitet nach einem einfachen Schema.  Er hat zwei Zust√§nde: Frei und Genommen.  Wenn sich der Agent im Status "Frei" befindet, antwortet er auf eine Take-Nachricht.  In diesem Fall wechselt der Agent in den Status "Aufgenommen" und antwortet mit einer Antwortnachricht "Aufgenommen". <br><br>  Wenn sich der Agent im Status "Aufgenommen" befindet, reagiert er anders auf die Nachricht "Nehmen": Der Status des Agenten √§ndert sich nicht, und "Besetzt" wird als Antwortnachricht gesendet.  Ebenfalls im Status "Aufgenommen" antwortet der Agent auf die Nachricht "Put": Der Agent kehrt in den Status "Frei" zur√ºck. <br><br>  Im freien Zustand wird die Put-Nachricht ignoriert. <br><br>  Wir werden versuchen, diesen anhand des folgenden Testfalls zu testen: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"fork"</span></span> ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } }; tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>&gt;(); }); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_taken"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;(), *philosopher &amp; tests::reacts_to&lt;msg_busy&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>) .impact&lt;msg_put&gt;(*fork) .when( *fork &amp; tests::reacts_to&lt;msg_put&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>)); REQUIRE(tests::completed() == sobj.scenario().result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"free"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); }</code> </pre> <br>  Da es viel Code gibt, werden wir uns in Teilen damit befassen und die Fragmente √ºberspringen, die bereits klar sein sollten. <br><br>  Das erste, was wir hier brauchen, ist, den echten Philosophenagenten zu ersetzen.  Ein Fork-Agent muss Nachrichten von jemandem empfangen und auf jemanden antworten.  Aber wir k√∂nnen den echten Philosophen in diesem Testfall nicht verwenden, da der echte Philosoph-Agent seine eigene Verhaltenslogik hat, er selbst Nachrichten sendet und diese Unabh√§ngigkeit uns hier st√∂ren wird. <br><br>  Daher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verspotten</a> wir, d.h.  Anstelle des echten Philosophen werden wir einen Ersatz daf√ºr einf√ºhren: einen leeren Agenten, der selbst nichts sendet, sondern nur gesendete Nachrichten ohne n√ºtzliche Verarbeitung empf√§ngt.  Dies ist der im Code implementierte Pseudo-Philosoph: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } };</code> </pre> <br>  Als N√§chstes erstellen wir eine Zusammenarbeit zwischen dem Fork-Agenten und dem PseudoPhilospher-Agenten und beginnen, den Inhalt unseres Testfalls zu bestimmen. <br><br>  Der erste Schritt des Skripts besteht darin, zu √ºberpr√ºfen, ob Fork im Status "Frei" (und dies ist der Ausgangszustand) nicht auf die Put-Nachricht reagiert.  So wird dieser Scheck geschrieben: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;());</code> </pre> <br>  Das erste, was Aufmerksamkeit erregt, ist die Aufprallkonstruktion. <br><br>  Sie wird gebraucht, weil unser Agent Fork selbst nichts tut, er reagiert nur auf eingehende Nachrichten.  Daher sollte jemand eine Nachricht an den Agenten senden.  Aber wer? <br><br>  Aber der Skriptschritt selbst sendet durch Wirkung.  In der Tat ist Impact ein Analogon der √ºblichen Sendefunktion (und das Format ist das gleiche). <br><br>  Nun, der Skriptschritt selbst sendet eine Nachricht durch Auswirkung.  Aber wann wird er es tun? <br><br>  Und er wird es tun, wenn er an der Reihe ist.  Das hei√üt,  Wenn der Schritt im Skript der erste ist, wird die Auswirkung unmittelbar nach der Eingabe von run_for ausgef√ºhrt.  Wenn der Schritt im Skript nicht der erste ist, wird die Auswirkung ausgef√ºhrt, sobald der vorherige Schritt ausgef√ºhrt wurde, und das Skript f√§hrt mit der Verarbeitung des n√§chsten Schritts fort. <br><br>  Das zweite, was wir hier diskutieren m√ºssen, ist das Ignorieren von Anrufen.  Diese Hilfsfunktion besagt, dass der Schritt ausgel√∂st wird, wenn der Agent die Nachricht verarbeitet.  Das hei√üt,  In diesem Fall muss der Fork-Agent die Verarbeitung der Put-Nachricht ablehnen. <br><br>  Betrachten wir einen weiteren Schritt des Testszenarios genauer: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;());</code> </pre><br>  Zuerst sehen wir hier when_all statt when.  Dies liegt daran, dass wir mehrere Bedingungen gleichzeitig erf√ºllen m√ºssen, um einen Schritt auszul√∂sen.  Der Gabelagent muss mit Take umgehen.  Und der Philosoph muss mit der Antwort umgehen.  Deshalb schreiben wir when_all, nicht when.  √úbrigens gibt es auch wann_jeder, aber wir werden ihn in den heute betrachteten Beispielen nicht treffen. <br><br>  Zweitens m√ºssen wir auch √ºberpr√ºfen, ob sich der Fork-Agent nach der Take-Verarbeitung im Status Taken befindet.  Wir f√ºhren die √úberpr√ºfung wie folgt durch: Zuerst geben wir an, dass der Name seines aktuellen Status mit dem Tag-Tag "fork" gespeichert werden soll, sobald der Fork-Agent die Verarbeitung von Take abgeschlossen hat.  Diese Konstruktion bewahrt nur den Statusnamen des Agenten: <br><br><pre> <code class="cpp hljs">&amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)</code> </pre> <br>  Wenn das Skript erfolgreich abgeschlossen wurde, √ºberpr√ºfen wir diesen gespeicherten Namen: <br><pre> <code class="cpp hljs">REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>));</code> </pre> <br>  Das hei√üt,  Wir fragen das Skript: Geben Sie uns den Namen, der mit dem Fork-Tag f√ºr den Schritt take_when_free gespeichert wurde, und vergleichen Sie den Namen mit dem erwarteten Wert. <br><br>  Hier ist vielleicht alles, was im Testfall f√ºr den Fork-Agenten notiert werden k√∂nnte.  Wenn Leser Fragen haben, dann fragen Sie in den Kommentaren, wir werden gerne antworten. <br><br><h3>  Erfolgreicher Skripttest f√ºr Philosophen </h3><br>  F√ºr den Philosophenagenten betrachten wir nur einen Testfall - f√ºr den Fall, dass der Philosoph beide Gabeln nehmen und essen kann. <br><br>  Dieser Testfall sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"philosopher (takes both forks)"</span></span> ) { tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } }; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * left_fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * right_fork{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { left_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); right_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>&gt;( <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>, left_fork-&gt;so_direct_mbox(), right_fork-&gt;so_direct_mbox()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scenario = sobj.scenario(); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_left"</span></span>) .when( *left_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_right"</span></span>) .when( *right_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_eating&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"return_forks"</span></span>) .when_all( *left_fork &amp; tests::reacts_to&lt;msg_put&gt;(), *right_fork &amp; tests::reacts_to&lt;msg_put&gt;() ); scenario.run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds(<span class="hljs-number"><span class="hljs-number">1</span></span>)); REQUIRE(tests::completed() == scenario.result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_left"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_right"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"eating"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"thinking"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); }</code> </pre> <br>  Ziemlich umfangreich, aber trivial.  √úberpr√ºfen Sie zun√§chst, ob der Philosoph mit dem Nachdenken fertig ist und sich auf das Essen vorbereitet.  Dann √ºberpr√ºfen wir, ob er versucht hat, die linke Gabel zu nehmen.  Als n√§chstes sollte er versuchen, die richtige Gabel zu nehmen.  Dann sollte er essen und diese Aktivit√§t beenden.  Dann muss er beide Gabeln nehmen. <br><br>  Im Allgemeinen ist alles einfach.  Sie sollten sich jedoch auf zwei Dinge konzentrieren. <br><br>  Erstens k√∂nnen Sie mit der Klasse "testing_env_t" wie mit ihrem Prototyp "wrap_env_t" die SObjectizer-Umgebung anpassen.  Wir werden dies verwenden, um den Mechanismus zur Verfolgung der Nachrichten√ºbermittlung zu aktivieren: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } };</code> </pre> <br>  Mit diesem Mechanismus k√∂nnen Sie den Nachrichten√ºbermittlungsprozess ‚Äûvisualisieren‚Äú, was bei der Untersuchung des Agentenverhaltens hilfreich ist (dar√ºber haben wir bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausf√ºhrlicher gesprochen</a> ). <br><br>  Zweitens f√ºhrt der Agent Philosoph eine Reihe von Aktionen nicht sofort, sondern nach einiger Zeit aus.  Um zu arbeiten, muss sich der Agent eine ausstehende StopThinking-Nachricht senden.  Diese Nachricht sollte also nach einigen Millisekunden beim Agenten eingehen.  Was wir anzeigen, indem wir die notwendige Einschr√§nkung f√ºr einen bestimmten Schritt festlegen: <br><br><pre> <code class="cpp hljs">scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) );</code> </pre> <br>  Das hei√üt,  hier sagen wir, dass wir nicht an einer Reaktion des Philosophenagenten auf StopThinking interessiert sind, sondern nur an der, die fr√ºhestens 250 ms nach Beginn der Verarbeitung dieses Schritts auftrat. <br><br>  Eine Einschr√§nkung des Typs not_before teilt dem Skript mit, dass alle Ereignisse, die vor Ablauf des angegebenen Zeitlimits auftreten, ignoriert werden sollen. <br><br>  Es gibt auch eine Einschr√§nkung des Formulars not_after, es funktioniert umgekehrt: Es werden nur die Ereignisse ber√ºcksichtigt, die auftreten, bis das angegebene Zeitlimit abgelaufen ist. <br><br>  Die Einschr√§nkungen not_before und not_after k√∂nnen kombiniert werden, zum Beispiel: <br><br><pre> <code class="cpp hljs">.constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)), tests::not_after(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">1250</span></span>)))</code> </pre> <br>  In diesem Fall √ºberpr√ºft SObjectizer jedoch nicht die Konsistenz der angegebenen Werte. <br><br><h1>  Wie haben Sie das umgesetzt? </h1><br>  Ich m√∂chte ein paar Worte dar√ºber sagen, wie alles funktioniert hat.  Schlie√ülich standen wir im Gro√üen und Ganzen vor einer gro√üen ideologischen Frage: "Wie testet man Agenten im Prinzip?"  und eine kleinere Frage, bereits technisch: "Wie implementiert man das?" <br><br>  Und wenn es in Bezug auf die Testideologie m√∂glich war, sich aus dem Kopf zu verlieren, dann war die Situation in Bezug auf die Implementierung komplizierter.  Es war notwendig, eine L√∂sung zu finden, die erstens keine radikale Ver√§nderung der Innenr√§ume von SObjectizer erfordert.  Und zweitens sollte es eine L√∂sung sein, die in absehbarer und sehr w√ºnschenswerter kurzer Zeit implementiert werden kann. <br><br>  Als Ergebnis des schwierigen Prozesses des Rauchens von Bambus wurde eine L√∂sung gefunden.  Daf√ºr war es tats√§chlich erforderlich, nur eine kleine Neuerung im regul√§ren Verhalten von SObjectizer vorzunehmen.  Grundlage der L√∂sung ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mechanismus f√ºr</a> den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachrichtenumschlag, der in Version 5.5.23 hinzugef√ºgt wurde und √ºber den wir bereits gesprochen haben</a> . <br><br>  In der Testumgebung wird jede gesendete Nachricht in einen speziellen Umschlag verpackt.  Wenn dem Agenten ein Umschlag mit einer Nachricht zur Verarbeitung √ºbergeben wird (oder umgekehrt vom Agenten abgelehnt wird), wird das Testszenario darauf aufmerksam.  Dank der Umschl√§ge wei√ü das Testskript, was gerade passiert, und kann die Momente bestimmen, in denen das Skript die Schritte ‚ÄûArbeit‚Äú ausf√ºhrt. <br><br>  Aber wie kann SObjectizer jede Nachricht in einen speziellen Umschlag einwickeln? <br><br>  Das war eine interessante Frage.  Er entschied sich wie folgt: Ein Konzept wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">event_queue_hook</a> wurde erfunden.  Dies ist ein spezielles Objekt mit zwei Methoden - on_bind und on_unbind. <br><br>  Wenn ein Agent an einen bestimmten Dispatcher gebunden ist, gibt der Dispatcher eine Agent-Ereigniswarteschlange an den Agenten aus.  √úber diese event_queue gelangen Anforderungen f√ºr den Agenten in die erforderliche Warteschlange und stehen dem Dispatcher zur Verarbeitung zur Verf√ºgung.  Wenn ein Agent in einem SObjectizer ausgef√ºhrt wird, hat er einen Zeiger auf event_queue.  Wenn ein Agent aus einem SObjectizer entfernt wird, wird sein Zeiger auf event_queue ung√ºltig. <br><br>  Ab Version 5.5.24 muss der Agent nach Erhalt von event_queue die on_bind-Methode von event_queue_hook aufrufen.  Wo der Agent den empfangenen Zeiger an event_queue √ºbergeben soll.  Und event_queue_hook kann als Antwort entweder denselben Zeiger oder einen anderen Zeiger zur√ºckgeben.  Und der Agent muss den zur√ºckgegebenen Wert verwenden. <br><br>  Wenn ein Agent aus einem SObjectizer entfernt wird, muss er on_unbind on event_queue_hook aufrufen.  In on_unbind √ºbergibt der Agent den Wert, der von der on_bind-Methode zur√ºckgegeben wurde. <br><br>  Diese ganze K√ºche wird im SObjectizer ausgef√ºhrt und der Benutzer sieht nichts davon.  Und im Prinzip wissen Sie vielleicht √ºberhaupt nichts davon.  Die Testumgebung von SObjectizer, dieselbe Testumgebung, nutzt jedoch genau event_queue_hook.  Innerhalb von testing_env_t wird eine spezielle Implementierung von event_queue_hook erstellt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Implementierung in on_bind umschlie√üt jede event_queue mit einem speziellen Proxy-Objekt. </font><font style="vertical-align: inherit;">Und bereits dieses Proxy-Objekt legt die an den Agenten gesendeten Nachrichten in einem speziellen Umschlag ab.</font></font><br><br>  Das ist aber noch nicht alles.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen sich daran erinnern, dass in einer Testumgebung Agenten eingefroren werden m√ºssen. </font><font style="vertical-align: inherit;">Dies wird auch durch die genannten Proxy-Objekte implementiert. </font><font style="vertical-align: inherit;">W√§hrend das Testskript nicht ausgef√ºhrt wird, speichert das Proxy-Objekt Nachrichten, die zu Hause an den Agenten gesendet werden. </font><font style="vertical-align: inherit;">Wenn das Skript ausgef√ºhrt wird, √ºbertr√§gt das Proxy-Objekt alle zuvor gesammelten Nachrichten in die aktuelle Nachrichtenwarteschlange des Agenten.</font></font><br><br><h1>  Fazit </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschlie√üend m√∂chte ich zwei Dinge sagen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst haben wir unsere Ansicht umgesetzt, wie Agenten in SObjectizer getestet werden k√∂nnen. Meine Meinung, weil es nicht so viele gute Vorbilder gibt. Wir schauten zu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akka</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Akka und SObjectizer sind jedoch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu unterschiedlich</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die in Akka funktionierenden Ans√§tze auf SObjectizer zu portieren. Und C ++ ist nicht Scala / Java, in dem einige Dinge im Zusammenhang mit Introspektion aufgrund von Reflexion erledigt werden k√∂nnen. Also musste ich mir einen Ansatz einfallen lassen, der auf SObjectizer fallen w√ºrde.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Version 5.5.24 wurde die allererste experimentelle Implementierung verf√ºgbar. Sicher k√∂nnen Sie es besser machen. Aber wie kann man verstehen, was n√ºtzlich sein wird und was nutzlose Fantasien sind? Leider nichts. Sie m√ºssen versuchen, zu sehen, was in der Praxis passiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also haben wir eine Minimalversion erstellt, die Sie ausprobieren k√∂nnen. Was wir f√ºr alle tun m√∂chten: Probieren Sie es aus, experimentieren Sie und teilen Sie Ihre Eindr√ºcke mit uns. Was hat dir gefallen, was hat dir nicht gefallen? Vielleicht fehlt etwas? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens wurden die Worte, die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu Beginn des Jahres 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gesagt wurden, noch relevanter </font><font style="vertical-align: inherit;">:</font></font><br><blockquote> ‚Ä¶       ,   ,   ,    .      -      ‚Äî      .             .      . :  ,   . <br><br>    ,  ,   ,       ‚Äî    ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher mein Rat an diejenigen, die nach einem vorgefertigten Rahmen f√ºr Schauspieler suchen: Achten Sie nicht nur auf die Originalit√§t der Ideen und die Sch√∂nheit der Beispiele. </font><font style="vertical-align: inherit;">Schauen Sie sich auch alle m√∂glichen Hilfsprogramme an, die Ihnen dabei helfen, herauszufinden, was in Ihrer Anwendung geschieht: Um beispielsweise herauszufinden, wie viele Akteure sich jetzt in der Warteschlange befinden, wie gro√ü ihre Warteschlange ist, ob die Nachricht den Empf√§nger nicht erreicht, wohin geht sie dann ... Wenn das Framework dies tut bietet so etwas, wird es f√ºr Sie einfacher sein. </font><font style="vertical-align: inherit;">Wenn dies nicht der Fall ist, haben Sie mehr Arbeit.</font></font><br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All dies ist noch wichtiger, wenn es darum geht, Schauspieler zu testen. </font><font style="vertical-align: inherit;">Achten Sie daher bei der Auswahl eines Schauspieler-Frameworks darauf, was darin enthalten ist und was nicht. </font><font style="vertical-align: inherit;">Zum Beispiel haben wir bereits in unserem Toolkit, um das Testen zu vereinfachen :)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435606/">https://habr.com/ru/post/de435606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435592/index.html">Azoren: letztes Pflanzenreservat mitten im Atlantik</a></li>
<li><a href="../de435594/index.html">Routendiagramm f√ºr Apache Camel</a></li>
<li><a href="../de435600/index.html">So migrieren Sie zu einem anderen Mobilfunkbetreiber und gehen nicht bankrott (f√ºr iOS-Besitzer)</a></li>
<li><a href="../de435602/index.html">Azure-Pr√ºfungsvorbereitung</a></li>
<li><a href="../de435604/index.html">BlaBlaCar wurde zu dem, wof√ºr es nicht gedacht war</a></li>
<li><a href="../de435608/index.html">DIY-Bildschirme</a></li>
<li><a href="../de435610/index.html">Ostereier f√ºr ZX Spectrum - im Musikalbum und Film</a></li>
<li><a href="../de435612/index.html">Vertrauen Sie Codd oder Ihren Einrichtungen?</a></li>
<li><a href="../de435614/index.html">Rust News # 4 (Dezember 2018)</a></li>
<li><a href="../de435616/index.html">Wie Peer Zoning unser Leben vereinfacht und dazu beigetragen hat, die Belastung durch EMC VPLEX auszugleichen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>