<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📶 🛐 🐅 Seluruh kebenaran tentang RTOS. Artikel # 33. Menggunakan Sistem Operasi Real-Time Nucleus SE 👩🏼‍🤝‍👨🏻 🍶 👨‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sejauh ini dalam seri artikel ini, kami telah melihat fitur apa yang disediakan Nucleus SE. Sekarang saatnya untuk melihat bagaimana itu dapat digunak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang RTOS. Artikel # 33. Menggunakan Sistem Operasi Real-Time Nucleus SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467763/">  Sejauh ini dalam seri artikel ini, kami telah melihat fitur apa yang disediakan Nucleus SE.  Sekarang saatnya untuk melihat bagaimana itu dapat digunakan dalam aplikasi firmware nyata. <br><br><img src="https://habrastorage.org/webt/8y/ch/3t/8ych3tyabi2vdvohugo65t3uekk.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Artikel sebelumnya dalam seri:</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 32.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Migrasi SE Inti: Fitur dan Kompatibilitas yang Tidak Direalisasikan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 31.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Diagnostik dan pengecekan kesalahan RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 30.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Inisialisasi Nucleus SE dan Prosedur Memulai</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 29.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gangguan pada Nucleus SE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengatur waktu perangkat lunak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Waktu sistem</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saluran: layanan tambahan dan struktur data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saluran Data: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antrian: layanan tambahan dan struktur data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antrian: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Surat: Layanan Tambahan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Surat: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semaphores: Layanan Tambahan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semaphores: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Layanan Pembantu dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sinyal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Partisi Memori: Layanan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian memori: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur data tugas dan panggilan API yang tidak didukung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan untuk bekerja dengan tugas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas: konfigurasi dan pengantar API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: fitur canggih dan pelestarian konteks</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Desain dan Penyebaran Internal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan RTOS lainnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interaksi tugas dan sinkronisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas, pengalihan konteks, dan interupsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas dan Perencanaan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: Struktur dan mode waktu-nyata</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: pengantar.</a> <br></div></div><br><h2>  Apa itu Nucleus SE? </h2><br>  Kita tahu bahwa Nucleus SE adalah inti dari sistem operasi waktu-nyata, tetapi Anda perlu memahami bagaimana hal itu sesuai dengan aplikasi lainnya.  Dan itu hanya cocok, karena tidak seperti sistem operasi desktop (misalnya, Windows), aplikasi tidak dimulai pada Nucleus SE;  kernel hanyalah bagian dari program yang berjalan pada perangkat tertanam.  Ini adalah kasus penggunaan yang paling umum untuk RTOS. <br><br>  Dari sudut pandang tingkat tinggi, aplikasi tertanam adalah semacam kode yang dimulai ketika CPU dimulai.  Dalam hal ini, lingkungan perangkat keras dan perangkat lunak diinisialisasi, dan kemudian fungsi <b>main ()</b> dipanggil, yang meluncurkan kode aplikasi utama. <br><br>  Saat menggunakan Nucleus SE (dan banyak kernel serupa lainnya), perbedaannya adalah bahwa fungsi <b>main ()</b> adalah bagian dari kode kernel.  Fungsi ini hanya menginisialisasi struktur data kernel, dan kemudian memanggil scheduler, yang mengarah pada peluncuran kode aplikasi (tugas).  Pengguna dapat menambahkan kode inisialisasi asli ke fungsi <b>utama ()</b> . <br><br>  Nucleus SE juga mencakup serangkaian fungsi - antarmuka pemrograman aplikasi (API) yang menyediakan serangkaian fungsi seperti komunikasi dan sinkronisasi tugas, bekerja dengan penghitung waktu, alokasi memori, dll.  Semua fungsi API dijelaskan sebelumnya dalam artikel dalam seri ini. <br><br>  Semua perangkat lunak Nucleus SE disediakan sebagai kode sumber (terutama dalam bahasa C).  Untuk mengkonfigurasi kode sesuai dengan persyaratan aplikasi tertentu, kompilasi bersyarat digunakan.  Ini dijelaskan secara rinci dalam artikel ini di bagian Konfigurasi. <br><br>  Setelah kode dikompilasi, modul objek Nucleus SE yang terkait dikaitkan dengan modul kode aplikasi, menghasilkan gambar biner tunggal, yang biasanya ditempatkan dalam memori flash perangkat tertanam.  Hasil dari pengikatan statis ini adalah bahwa semua informasi simbolik tetap tersedia baik dari kode aplikasi dan kode kernel.  Ini berguna untuk debugging, namun diperlukan kehati-hatian untuk menghindari penyalahgunaan data Nucleus SE. <br><br><h2>  Dukungan CPU dan alat </h2><br>  Karena Nucleus SE datang sebagai kode sumber, itu harus portabel.  Namun, kode berjalan pada tingkat rendah (ketika menggunakan penjadwal di mana pengalihan konteks diperlukan, yaitu, selain dari Run to Completion), tidak dapat sepenuhnya independen dari bahasa assembly.  Saya meminimalkan ketergantungan ini, dan untuk porting ke pemrograman tingkat rendah CPU baru hampir tidak diperlukan.  Menggunakan seperangkat alat pengembangan baru (compiler, assembler, linker, dll.) Juga dapat menyebabkan masalah porting. <br><br><h2>  Menyiapkan aplikasi Nucleus SE </h2><br>  Kunci untuk penggunaan Nucleus SE yang efisien adalah pengaturan yang tepat.  Mungkin terlihat rumit, tetapi pada kenyataannya, semuanya cukup logis dan hanya membutuhkan pendekatan sistematis.  Hampir semua konfigurasi dilakukan dengan mengedit dua file: <b>nuse_config.h</b> dan <b>nuse_config.c</b> . <br><br><h3>  Pengaturan Nuse_config.h </h3><br>  File ini hanyalah serangkaian karakter dari direktif <b>#define</b> , yang diberi nilai yang sesuai untuk mendapatkan konfigurasi kernel yang diperlukan.  Dalam file <b>nuse_config.h,</b> secara default, semua karakter ada, tetapi mereka diberikan pengaturan minimum. <br><br>  <b><i>Penghitung Objek</i></b> <br>  Jumlah objek kernel dari setiap jenis diatur oleh nilai simbol dari formulir <b>NUSE_SEMAPHORE_NUMBER</b> .  Untuk sebagian besar objek, nilai ini dapat bervariasi dari 0 hingga 15. Tugas adalah pengecualian, harus ada setidaknya satu.  Sinyal, pada kenyataannya, bukan objek independen, karena mereka terkait dengan tugas dan <b>dihidupkan</b> dengan <b>menetapkan NUSE_SIGNAL_SUPPOR</b> T ke <b>TRUE</b> . <br><br>  <b><i>Penggerak fungsi API</i></b> <br>  Setiap fungsi Nucleus SE API dapat diaktifkan secara terpisah dengan menetapkan simbol yang namanya cocok dengan nama fungsi (misalnya, <b>NUSE_PIPE_JAM</b> ) ke <b>TRUE</b> .  Ini mengarah ke pencantuman kode fungsi dalam aplikasi. <br><br>  <b><i>Pilihan dan pengaturan penjadwal</i></b> <br>  Nucleus SE mendukung empat jenis penjadwal, seperti yang dijelaskan dalam artikel sebelumnya.  Penjadwal yang digunakan diatur dengan menetapkan <b>NUSE_SCHEDULER_TYPE ke</b> salah satu nilai berikut: <b>NUSE_RUN_TO_COMPLETION_SCHEDULER</b> , <b>NUSE_TIME_SLICE_SCHEDULER</b> , <b>NUSE_ROUND_ROBIN_SCHEDULER</b> atau <b>NUSE_PRIORITY_SCHEDULER</b> . <br><br>  Anda dapat mengkonfigurasi parameter penjadwal lainnya: <br>  <b>NUSE_TIME_SLICE_TICKS</b> menunjukkan jumlah ticks per slot untuk penjadwal Time Slice.  Jika penjadwal lain digunakan, parameter ini harus ditetapkan ke 0. <br>  <b>NUSE_SCHEDULE_COUNT_SUPPORT</b> dapat disetel ke <b>TRUE</b> atau <b>FALSE</b> untuk mengaktifkan / menonaktifkan mekanisme penghitung penjadwal. <br>  <b>NUSE_SUSPEND_ENABLE</b> memungkinkan penguncian tugas (penangguhan) untuk banyak fungsi API.  Ini berarti bahwa panggilan ke fungsi seperti itu dapat menyebabkan penangguhan tugas panggilan hingga sumber daya dirilis.  Untuk memilih opsi ini, <b>NUSE_SUSPEND_ENABLE</b> juga harus disetel ke <b>TRUE</b> . <br><br>  <b><i>Pilihan lain</i></b> <br>  Beberapa parameter lain juga dapat diberi nilai <b>TRUE</b> atau <b>FALSE</b> untuk mengaktifkan / menonaktifkan fungsi kernel lainnya: <br>  <b>NUSE_API_PARAMETER_CHECKING</b> menambahkan kode verifikasi parameter panggilan fungsi API.  Biasa digunakan untuk debugging. <br>  <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> menetapkan status awal semua tugas sebagai <b>NUSE_READY</b> atau <b>NUSE_PURE_SUSPEND</b> .  Jika parameter ini dinonaktifkan, semua tugas akan memiliki status awal <b>NUSE_READY</b> . <br>  <b>NUSE_SYSTEM_TIME_SUPPORT</b> - dukungan untuk waktu sistem. <br>  <b>NUSE_INCLUDE_EVERYTHING</b> - parameter yang menambahkan jumlah fungsi maksimum ke konfigurasi Nucleus SE.  Ini mengarah ke aktivasi semua fungsi opsional dan setiap fungsi API dari objek yang dikonfigurasi.  Digunakan untuk dengan cepat membuat konfigurasi Nucleus SE untuk memverifikasi porting baru dari kode kernel. <br><br><h3>  Pengaturan nuse_config.c </h3><br>  Setelah menentukan konfigurasi kernel di <b>nuse_config.h,</b> perlu menginisialisasi berbagai struktur data yang disimpan dalam ROM.  Ini dilakukan dalam file <b>nuse_config.c</b> .  Definisi struktur data dikendalikan oleh kompilasi bersyarat, sehingga semua struktur terkandung dalam salinan file <b>nuse_config.c</b> default. <br><br>  <b><i>Data tugas</i></b> <br>  <b>Array NUSE_Task_Start_Address []</b> harus diinisialisasi dengan nilai alamat mulai dari setiap tugas.  Ini biasanya hanya daftar nama fungsi, tanpa tanda kurung.  Prototipe fungsi entri tugas juga harus terlihat.  Dalam file default, tugas dikonfigurasikan dengan nama <b>NUSE_Idle_Task ()</b> , ini dapat diubah ke tugas aplikasi. <br><br>  Jika Anda menggunakan penjadwal apa pun kecuali Jalankan ke Penyelesaian, setiap tugas memerlukan tumpukannya sendiri.  Untuk setiap tumpukan tugas, Anda harus membuat array dalam RAM.  Array ini harus bertipe <b>ADDR</b> , dan alamat masing-masing harus disimpan dalam <b>NUSE_Task_Stack_Base []</b> .  Sulit untuk memprediksi ukuran array, jadi lebih baik menggunakan pengukuran (lihat bagian "Debugging" nanti dalam artikel ini).  Ukuran setiap larik (yaitu jumlah kata pada tumpukan) harus disimpan dalam <b>NUSE_Task_Stack_Size []</b> . <br><br>  Jika suatu fungsi telah diaktifkan untuk menunjukkan status awal tugas (menggunakan parameter <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> ), <b>larik NUSE_Task_Initial_State []</b> harus diinisialisasi dengan status <b>NUSE_READY atau NUSE_PURE_SUSPEND</b> . <br><br>  <b><i>Data Pool Partisi</i></b> <br>  Jika setidaknya satu kumpulan partisi dikonfigurasi, sebuah array (tipe <b>U8</b> ) harus dibuat untuk masing-masingnya dalam ROM.  Ukuran array ini dihitung sebagai berikut: (jumlah partisi * (ukuran partisi + 1)).  Alamat bagian ini (yaitu, namanya) harus ditetapkan ke elemen <b>NUSE_Part__Pool_Data_Address [] yang</b> sesuai.  Untuk setiap kumpulan, jumlah partisi dan ukurannya masing-masing harus ditempatkan di <b>NUSE_Partition_Pool_Partition_Number []</b> dan <b>NUSE_Partition_Message_Size []</b> . <br><br>  <b><i>Data Antrian</i></b> <br>  Jika setidaknya satu antrian dikonfigurasi, maka array (dari jenis <b>ADDR</b> ) harus dibuat untuk masing-masing dalam RAM.  Ukuran array ini adalah jumlah elemen dalam setiap antrian.  Alamat array ini (yaitu, namanya) harus ditetapkan ke elemen <b>NUSE_Queue_Data [] yang</b> sesuai.  Ukuran setiap antrian harus ditetapkan untuk elemen <b>NUSE_Queue_Size [] yang</b> sesuai. <br><br>  <b><i>Data Link Data</i></b> <br>  Jika setidaknya satu saluran data dikonfigurasi, sebuah array (bertipe <b>U8</b> ) harus dibuat dalam RAM untuknya (atau untuk masing-masingnya).  Ukuran array ini dihitung sebagai berikut: (ukuran saluran * ukuran pesan di saluran).  Alamat array ini (yaitu, namanya) harus ditetapkan ke elemen <b>NUSE_Pipe_Data [] yang</b> sesuai.  Untuk setiap saluran, ukuran dan ukuran pesannya harus ditetapkan ke masing-masing elemen <b>NUSE_Pipe_Size []</b> dan <b>NUSE_Pipe_Message_Size [] yang sesuai</b> . <br><br>  <b><i>Data semaphore</i></b> <br>  Jika setidaknya satu semaphore dikonfigurasikan, array <b>NUSE_Semaphore_Initial_Value []</b> harus diinisialisasi dengan nilai awal hitung mundur. <br><br>  <b><i>Data Pengatur Waktu Aplikasi</i></b> <br>  Jika setidaknya satu timer dikonfigurasikan, array <b>NUSE_Timer_Initial_Time []</b> harus diinisialisasi dengan nilai awal dari penghitung.  Selain itu, <b>NUSE_Timer_Reschedule_Time []</b> harus diberi nilai mulai ulang.  Nilai-nilai timer ini akan digunakan setelah siklus timer pertama berakhir.  Jika nilai restart diatur ke 0, penghitung akan berhenti setelah satu siklus. <br><br>  Jika dukungan untuk mekanisme penyelesaian akun dikonfigurasikan (dengan mengatur <b>NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT</b> parameter ke <b>TRUE</b> ), dua array lagi harus dibuat.  Alamat mekanisme penyelesaian (hanya daftar nama fungsi, tanpa tanda kurung) harus ditempatkan di <b>NUSE_Timer_Expiration_Routine_Address []</b> .  Array <b>NUSE_Timer_Expiration_Routine_Parameter []</b> harus diinisialisasi dengan nilai-nilai parameter penyelesaian. <br><br><h2>  API yang mana? </h2><br>  Semua sistem operasi dalam satu bentuk atau lainnya memiliki API (antarmuka pemrograman aplikasi).  Nucleus SE tidak terkecuali, dan fungsi-fungsi yang membentuk API telah dijelaskan secara rinci dalam seri artikel ini. <br><br>  Mungkin tampak jelas bahwa ketika menulis aplikasi menggunakan Nucleus SE, Anda perlu menggunakan API seperti yang dijelaskan dalam artikel sebelumnya.  Namun, ini tidak selalu terjadi. <br><br>  Untuk sebagian besar pengguna, Nucleus SE API akan menjadi sesuatu yang baru, bahkan mungkin pengalaman pertama mereka menggunakan sistem operasi API.  Dan karena ini cukup sederhana, ini bisa menjadi pengantar yang bagus untuk topik tersebut.  Dalam hal ini, prosedurnya jelas. <br><br>  Untuk beberapa pengguna, API alternatif mungkin merupakan opsi yang lebih menarik.  Ada tiga situasi yang jelas di mana ini dimungkinkan. <br><ol><li>  Nucleus SE hanya bagian dari sistem yang menggunakan sistem operasi lain untuk komponen lain.  Oleh karena itu, portabilitas kode, dan, yang lebih penting, pengalaman menggunakan berbagai sistem operasi terlihat sangat menggoda. </li><li>  Pengguna memiliki pengalaman luas menggunakan API sistem operasi lain.  Menggunakan pengalaman ini juga sangat disarankan. </li><li>  Pengguna ingin menggunakan kembali kode yang ditulis untuk API sistem operasi lain.  Mengubah panggilan API dimungkinkan, tetapi menghabiskan waktu. </li></ol><br><br>  Karena kode sumber lengkap Nucleus SE tersedia untuk semua orang, tidak ada yang menghentikan Anda dari mengedit setiap fungsi API sehingga terlihat setara dengan sistem operasi lain.  Namun, itu akan memakan banyak waktu dan akan sangat tidak produktif.  Pendekatan yang lebih tepat adalah menulis "pembungkus".  Ada beberapa cara untuk melakukan ini, tetapi cara termudah adalah membuat file header ( <b>#include</b> ) yang berisi sekumpulan <b>#define</b> macro yang akan memetakan fungsi API pihak ketiga ke fungsi Nucleus SE API. <br><br>  Pembungkus yang mentransfer fungsi Nucleus RTOS API (sebagian) ke Nucleus SE didistribusikan dengan Nucleus SE.  Mungkin bermanfaat bagi pengembang yang berpengalaman menggunakan Nucleus RTOS, atau di mana di masa mendatang dimungkinkan untuk beralih ke RTOS ini.  Pembungkus ini juga bisa berfungsi sebagai contoh ketika mengembangkan hal serupa. <br><br><h2>  Aplikasi Debugging Nucleus SE </h2><br>  Menulis aplikasi tertanam menggunakan kernel multitasking adalah tugas yang kompleks.  Memastikan kode berfungsi dan mendeteksi kesalahan bisa menjadi tugas yang menakutkan.  Terlepas dari kenyataan bahwa ini hanya kode yang berjalan pada prosesor, eksekusi simultan dari beberapa tugas membuatnya agak sulit untuk fokus pada utas eksekusi spesifik.  Ini lebih rumit ketika beberapa tugas berbagi kode umum.  Yang terburuk, ketika dua tugas memiliki kode yang persis sama (tetapi bekerja dengan data yang berbeda).  Juga menyulitkan adalah penguraian struktur data yang digunakan untuk mengimplementasikan objek kernel untuk melihat informasi yang bermakna. <br><br>  Untuk men-debug aplikasi yang dibangun menggunakan Nucleus SE, tidak ada perpustakaan tambahan atau layanan lain yang diperlukan.  Semua kode kernel dapat dibaca oleh debugger.  Karena itu, semua informasi simbolis tersedia untuk dipelajari.  Saat bekerja dengan aplikasi Nucleus SE, alat debugging modern apa pun dapat digunakan. <br><br><h3>  Menggunakan debugger </h3><br>  Alat debugging yang dirancang khusus untuk sistem tertanam telah menjadi sangat kuat dalam 30 tahun yang telah ada.  Karakteristik utama dari aplikasi tertanam, dibandingkan dengan program desktop, adalah bahwa semua sistem tertanam berbeda (dan semua komputer pribadi sangat mirip satu sama lain).  Debugger tertanam yang baik harus fleksibel dan memiliki pengaturan yang cukup untuk mencocokkan berbagai sistem tertanam dan persyaratan pengguna.  Kustomisasi debugger dinyatakan dalam berbagai bentuk, tetapi biasanya ada kemungkinan membuat skrip.  Fitur inilah yang memungkinkan debugger bekerja dengan baik dengan aplikasi tingkat kernel.  Di bawah ini saya akan membahas beberapa kasus menggunakan debugger. <br><br>  Perlu dicatat bahwa biasanya debugger adalah kumpulan alat, bukan hanya satu program.  Debugger dapat memiliki berbagai mode operasi, yang membantu ketika mengembangkan kode pada sistem virtual atau pada perangkat keras nyata. <br><br><h3>  Breakpoint yang sensitif terhadap tugas </h3><br>  Jika program memiliki kode yang umum untuk beberapa tugas, penggunaan breakpoint konvensional selama proses debug rumit.  Kemungkinan besar, Anda memerlukan kode untuk berhenti hanya ketika breakpoint dicapai dalam konteks tugas tertentu yang sedang Anda debug.  Untuk melakukan ini, Anda memerlukan breakpoint yang akan mempertimbangkan tugas. <br><br>  Untungnya, kemampuan untuk membuat skrip pada debugger modern dan ketersediaan data karakter Nucleus SE membuat implementasi breakpoint spesifik tugas menjadi hal yang cukup sederhana.  Yang diperlukan hanyalah menulis skrip sederhana yang akan dikaitkan dengan breakpoint yang ingin Anda ajarkan untuk membedakan antara tugas.  Skrip ini akan mengambil parameter: indeks (ID) dari tugas yang Anda minati.  Script hanya akan membandingkan nilai ini dengan indeks tugas saat ini ( <i>NUSE_Task_Active</i> ).  Jika nilainya cocok, program berhenti.  Jika mereka berbeda, eksekusi berlanjut.  Perlu dicatat bahwa eksekusi skrip ini akan memengaruhi eksekusi aplikasi secara real time ( <i>catatan penerjemah: ini berarti bahwa eksekusi program akan melambat relatif terhadap operasi normalnya</i> ).  Namun, jika skrip tidak dalam satu lingkaran yang akan dieksekusi sangat sering, efek ini akan minimal. <br><br><h3>  Informasi Objek Kernel </h3><br>  Kebutuhan nyata untuk men-debug aplikasi Nucleus SE adalah kemampuan untuk mendapatkan informasi tentang objek kernel: apa karakteristik mereka dan apa status mereka saat ini.  Ini memungkinkan Anda mendapatkan jawaban atas pertanyaan seperti: "Berapa besar antrian ini dan berapa banyak pesan yang ada di dalamnya sekarang?" <br><br>  Ini dapat digunakan dengan menambahkan kode debug tambahan ke aplikasi Anda, yang akan menggunakan panggilan API "informatif" (seperti <b>NUSE_Queue_Information</b> ).  Tentu saja, ini berarti bahwa aplikasi Anda sekarang berisi kode tambahan, yang tidak akan diperlukan setelah implementasi aplikasi.  Menggunakan <b>#define</b> untuk menghidupkan dan mematikan kode ini menggunakan kompilasi bersyarat akan menjadi keputusan yang logis. <br><br>  Beberapa debugger dapat membuat panggilan fungsi yang ditargetkan, yaitu, langsung memanggil fungsi API untuk mengambil informasi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menghilangkan kebutuhan untuk kode tambahan, tetapi fungsi API ini harus dikonfigurasi untuk debugger untuk menggunakannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternatif, lebih fleksibel, tetapi kurang "non-penuaan" pendekatan adalah akses langsung ke struktur data objek kernel. </font><font style="vertical-align: inherit;">Kemungkinan besar, yang terbaik adalah melakukan ini menggunakan skrip debugger. </font><font style="vertical-align: inherit;">Dalam contoh kami, ukuran antrian dapat diperoleh dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Size []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan penggunaan saat ini dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Data []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Selain itu, pesan dalam antrian dapat ditampilkan menggunakan alamat area data antrian (dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Data []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nilai pengembalian panggilan API </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Banyak fungsi API mengembalikan nilai status yang menunjukkan seberapa sukses panggilan selesai. Akan bermanfaat untuk melacak nilai-nilai ini dan untuk menandai kasus yang tidak sama dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_SUCCESS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (yaitu, mereka memiliki nilai nol). Karena pelacakan ini hanya untuk debugging, kompilasi bersyarat cukup tepat. Definisi variabel global (katakanlah, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dapat dikompilasi secara kondisional (di bawah kendali simbol petunjuk #define). Kemudian, bagian dari definisi panggilan API, yaitu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status =</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , juga dapat dikompilasi secara kondisional. Misalnya, untuk keperluan debugging, panggilan yang biasanya terlihat seperti ini: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Mailbox_Send (mbox, msg, NUSE_SUSPSEND);</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan mengambil formulir berikut:</font></font><br><br> <b>NUSE_API_Call_Status = NUSE_Mailbox_Send(mbox, msg, NUSE_SUSPEND);</b> <br><br>    ,    API           ,    . ,     API,  API     . <br><br><h3>        </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Topik perlindungan stack overflow dibahas dalam artikel sebelumnya (# 31). Ada beberapa kemungkinan lain selama debugging. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Area memori tumpukan dapat diisi dengan nilai karakteristik: sesuatu yang lain daripada semua yang ada atau semua nol. Setelah itu, debugger dapat digunakan untuk memantau area memori dan berapa banyak nilai yang akan diubah, yang akan memungkinkan kita untuk memahami tingkat kepenuhan tumpukan. Jika semua area memori telah diubah, ini tidak berarti bahwa tumpukannya penuh, tetapi dapat berarti bahwa ukurannya hampir tidak cukup, yang berbahaya. Ini harus ditingkatkan dan pengujian dilanjutkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang dijelaskan dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel # 31</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ketika menerapkan diagnostik, area tambahan, "kata pelindung", dapat ditemukan di salah satu tepi area memori tumpukan. </font><font style="vertical-align: inherit;">Debugger dapat digunakan untuk melacak akses ke kata-kata ini, karena setiap upaya untuk menulis kepada mereka berarti meluap atau habisnya tumpukan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daftar Periksa Konfigurasi Nucleus SE </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena Nucleus SE dirancang sebagai sistem yang sangat fleksibel dan dapat disesuaikan untuk memenuhi persyaratan aplikasi, Nucleus SE membutuhkan sejumlah besar parameter yang dapat disesuaikan. </font><font style="vertical-align: inherit;">Itulah sebabnya seluruh artikel ini, pada kenyataannya, dikhususkan untuk konfigurasi Nucleus SE. </font><font style="vertical-align: inherit;">Untuk memastikan kami tidak melewatkan apa pun, berikut ini adalah daftar periksa semua langkah utama yang perlu Anda ikuti untuk membuat Aplikasi Tertanam Nucleus SE.</font></font><br><ol><li> <b> Nucleus SE.</b>   ,     Nucleus SE       ,        Nucleus SE     . </li><li> <b>  CPU/.</b>             . </li><li> <b>  .</b>     ,       ,    . </li><li> <b>  .</b>        .       .  ,     .      16 . </li><li> <b> .</b>     -   <b>main()</b> ? </li><li> <b> .</b>     4 ,       . </li><li> <b>   </b> ,     . </li><li> <b>    .</b> </li><li> <b>.</b>   ,     . </li><li> <b> .</b>    ,    . </li><li> <b>  .</b> ,      .     .  —  16   . </li><li> <b>  .</b>        ,   . </li><li> <b>  .</b>        ,    (,      ). </li><li> <b> API.</b>    API,   . </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel berikutnya (yang terakhir dalam seri ini) akan merangkum keseluruhan cerita dengan Nucleus SE, dan juga akan memberikan informasi yang akan membantu dalam menciptakan implementasi Nucleus SE dan penggunaannya. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentang Pengarang:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colin Walls telah bekerja di industri elektronik selama lebih dari tiga puluh tahun, mencurahkan sebagian besar waktunya untuk firmware. </font><font style="vertical-align: inherit;">Dia sekarang adalah seorang insinyur firmware di Mentor Embedded (sebuah divisi dari Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls sering berbicara di konferensi dan seminar, penulis berbagai artikel teknis dan dua buku tentang firmware. </font><font style="vertical-align: inherit;">Tinggal di Inggris. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> profesional </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Colin</font></a><font style="vertical-align: inherit;"> , email: colin_walls@mentor.com.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467763/">https://habr.com/ru/post/id467763/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467751/index.html">Bagaimana cara messenger terdesentralisasi di blockchain</a></li>
<li><a href="../id467753/index.html">Rekor dunia untuk transmisi data nirkabel: 40 Gb / s per 11 kilometer</a></li>
<li><a href="../id467755/index.html">Prion, kalsium, mikrobiota, hormon makanan, dan Alzheimer</a></li>
<li><a href="../id467759/index.html">Desain OS seperti Unix - Ruang Alamat Virtual (6)</a></li>
<li><a href="../id467761/index.html">Energi, panas, dan air bagian tiga: buka radio</a></li>
<li><a href="../id467767/index.html">Fasilitas lainnya untuk pengikut JSON-RPC</a></li>
<li><a href="../id467769/index.html">Pada sumber daya informasi federal tunggal yang mengandung informasi populasi</a></li>
<li><a href="../id467773/index.html">Sumber pada sumber daya yang tidak biasa dan melakukan kontak pertama</a></li>
<li><a href="../id467775/index.html">5 mitos tentang bisnis: mengapa klien salah dan bagaimana melampaui Apple</a></li>
<li><a href="../id467779/index.html">Tentang Godot, GLSL dan WebGL, shader yang digunakan dalam mini-game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>