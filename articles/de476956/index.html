<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µüèº üë©‚Äçüîß üí≤ Winkel ohne zone.js: maximale Leistung ü§≥üèæ üíÄ üë®‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Angular-Entwickler haben zone.js viel zu verdanken. Sie hilft zum Beispiel dabei, die Arbeit mit Angular auf magische Weise zu vereinfachen. In der Ta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Winkel ohne zone.js: maximale Leistung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/476956/">  Angular-Entwickler haben zone.js viel zu verdanken.  Sie hilft zum Beispiel dabei, die Arbeit mit Angular auf magische Weise zu vereinfachen.  In der Tat rendert Angular die entsprechenden Komponenten fast immer neu, wenn Sie nur eine Eigenschaft √§ndern m√ºssen und wir sie √§ndern, ohne an irgendetwas zu denken.  Infolgedessen enth√§lt das, was der Benutzer sieht, immer die neuesten Informationen.  Das ist einfach toll. <br><br>  Hier m√∂chte ich einige Aspekte untersuchen, wie die Verwendung des neuen Ivy-Compilers (der in Angular 9 erschien) die Ablehnung der Verwendung von zone.js erheblich erleichtern kann. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/476956/"><img src="https://habrastorage.org/webt/9m/ql/xa/9mqlxapag9joinziuleg8frnslm.jpeg"></a> <br><br>  Durch den Verzicht auf diese Bibliothek konnte ich die Leistung der unter hoher Last ausgef√ºhrten Angular-Anwendung erheblich steigern.  Gleichzeitig gelang es mir, die von mir ben√∂tigten Mechanismen mithilfe von TypeScript-Dekoratoren zu implementieren, was zu sehr geringen zus√§tzlichen Systemressourcen f√ºhrte. <br><br>  Beachten Sie, dass der in diesem Artikel beschriebene Ansatz zur Optimierung von Angular-Anwendungen nur m√∂glich ist, weil Angular Ivy und AOT standardm√§√üig aktiviert sind.  Dieser Artikel wurde zu Bildungszwecken verfasst und zielt nicht darauf ab, den darin vorgestellten Ansatz f√ºr die Entwicklung von Angular-Projekten zu f√∂rdern. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Warum m√ºssen Sie m√∂glicherweise Angular ohne zone.js verwenden?</font> </h2><br>  Bevor wir fortfahren, stellen wir eine wichtige Frage: ‚ÄûLohnt es sich, zone.js loszuwerden, da diese Bibliothek uns hilft, Vorlagen mit geringem Aufwand neu zu rendern?‚Äú  Nat√ºrlich ist diese Bibliothek sehr n√ºtzlich.  Aber wie immer muss man f√ºr alles bezahlen. <br><br>  Wenn f√ºr Ihre Anwendung bestimmte Leistungsanforderungen gelten, k√∂nnen Sie diese durch Deaktivieren von zone.js erf√ºllen.  Ein Beispiel f√ºr eine Anwendung, bei der die Leistung von entscheidender Bedeutung ist, ist ein Projekt, dessen Oberfl√§che sehr h√§ufig aktualisiert wird.  In meinem Fall erwies sich ein solches Projekt als Echtzeit-Handelsanwendung.  Sein Client-Teil empf√§ngt st√§ndig Nachrichten √ºber das WebSocket-Protokoll.  Die Daten aus diesen Nachrichten sollten so schnell wie m√∂glich angezeigt werden. <br><br><h2>  <font color="#3AC1EF">Entfernen Sie zone.js von Angular</font> </h2><br>  Angular kann sehr einfach zum Arbeiten ohne zone.js gebracht werden.  Dazu m√ºssen Sie zuerst den entsprechenden Importbefehl <code>polyfills.ts</code> oder l√∂schen, der sich in der Datei <code>polyfills.ts</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a4/f95/17e/7a4f9517eb4898e51240862c08e4faa9.png"></div><br>  <i><font color="#999999">Auskommentierter Befehl zum Importieren von zone.js</font></i> <br><br>  Weiter - Sie m√ºssen das Root-Modul mit den folgenden Optionen ausstatten: <br><br><pre> <code class="javascript hljs">platformBrowserDynamic()  .bootstrapModule(AppModule, {    <span class="hljs-attr"><span class="hljs-attr">ngZone</span></span>: <span class="hljs-string"><span class="hljs-string">'noop'</span></span>  })  .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err));</code> </pre> <br><h2>  <font color="#3AC1EF">Angular Ivy: Selbsterkennende √Ñnderungen mit …µdetectChanges und …µmarkDirty</font> </h2><br>  Bevor wir mit dem Erstellen eines TypeScript-Dekorators beginnen k√∂nnen, m√ºssen wir lernen, wie Sie mit Ivy den Prozess zum Erkennen von Komponenten√§nderungen, zum Verschmutzen und zum Umgehen von zone.js und DI aufrufen k√∂nnen. <br><br>  Jetzt stehen uns zwei zus√§tzliche Funktionen zur Verf√ºgung, die aus <code>@angular/core</code> exportiert werden.  Dies sind <code>…µdetectChanges</code> und <code>…µmarkDirty</code> .  Diese beiden Funktionen sind weiterhin f√ºr den internen Gebrauch bestimmt und instabil - das Symbol <code>…µ</code> befindet sich am Anfang ihres Namens. <br><br>  Schauen wir uns an, wie diese Funktionen verwendet werden. <br><br><h3>  <font color="#3AC1EF">‚ñç …µmarkDirty-Funktion</font> </h3><br>  Mit dieser Funktion k√∂nnen Sie eine Komponente als "verschmutzt" markieren, dh, sie muss neu gerendert werden.  Sie plant, den √Ñnderungserkennungsprozess zu starten, wenn die Komponente vor dem Aufrufen nicht als "verschmutzt" markiert war. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { …µmarkDirty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> markDirty } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    markDirty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç …µdetectChanges-Funktion</font> </h3><br>  Angular interne Dokumentation besagt, dass Sie aus Leistungsgr√ºnden <code>…µdetectChanges</code> nicht verwenden <code>…µdetectChanges</code> .  Stattdessen wird empfohlen, die <code>…µmarkDirty</code> functionmarkDirty zu verwenden.  Die Funktion <code>…µdetectChanges</code> ruft synchron den Prozess zum Erkennen von √Ñnderungen in einer Komponente und ihren Unterkomponenten auf. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { …µdetectChanges <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> detectChanges } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    detectChanges(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h2>  <font color="#3AC1EF">Automatische Erkennung von √Ñnderungen mit TypeScript Decorator</font> </h2><br>  Obwohl die von Angular bereitgestellten Funktionen die Benutzerfreundlichkeit der Entwicklung erh√∂hen, indem die DI herumlaufen gelassen wird, kann der Programmierer dennoch frustriert sein, dass er diese Funktionen importieren und selbst aufrufen muss, um den √Ñnderungserkennungsprozess zu starten. <br><br>  Um den automatischen Start der √Ñnderungserkennung zu vereinfachen, k√∂nnen Sie einen TypeScript-Dekorator schreiben, der dieses Problem unabh√§ngig l√∂st.  Nat√ºrlich gibt es hier einige Einschr√§nkungen, die wir unten diskutieren werden, aber in meinem Fall hat sich herausgestellt, dass dieser Ansatz genau das war, was ich brauchte. <br><br><h3>  <font color="#3AC1EF">‚ñçEinf√ºhrung des @observed Decorators</font> </h3><br>  Um √Ñnderungen mit m√∂glichst geringem Aufwand zu erkennen, erstellen wir einen Dekorateur, der auf drei Arten angewendet werden kann.  Es ist n√§mlich auf die folgenden Entit√§ten anwendbar: <br><br><ul><li>  Zu synchronen Methoden. </li><li>  Beobachtbare Objekte. </li><li>  Zu gew√∂hnlichen Gegenst√§nden. </li></ul><br>  Betrachten Sie ein paar kleine Beispiele.  Im folgenden Codefragment wenden wir den <code>@observed</code> Dekorator auf das <code>changeTitle</code> und auf die <code>changeTitle</code> Methode an: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{    title = <span class="hljs-string"><span class="hljs-string">''</span></span>;    @observed() state = {        <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>    };    @observed()    changeTitle(title: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    }    changeName(name: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.name = name;    } }</code> </pre> <br><ul><li>  Um nach √Ñnderungen am <code>state</code> suchen, verwenden wir ein Proxy-Objekt, das √Ñnderungen am Objekt abf√§ngt und die Prozedur zum Erkennen von √Ñnderungen aufruft. </li><li>  Wir √ºberschreiben die <code>changeTitle</code> Methode, indem wir eine Funktion anwenden, die diese Methode zuerst aufruft und dann den √Ñnderungserkennungsprozess startet. </li></ul><br>  Und hier ist ein Beispiel mit <code>BehaviorSubject</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{    @observed() show$ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);    toggle() {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.next(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.value);    } }</code> </pre> <br>  Bei beobachtbaren Objekten sieht die Verwendung eines Dekorateurs etwas komplizierter aus.  Sie m√ºssen das beobachtete Objekt abonnieren und die Komponente im Abonnement als "unsauber" markieren, aber Sie m√ºssen auch das Abonnement l√∂schen.  Zu diesem <code>ngOnInit</code> <code>ngOnDestroy</code> wir <code>ngOnInit</code> und <code>ngOnDestroy</code> zu, um sie sp√§ter zu abonnieren und zu bereinigen. <br><br><h3>  <font color="#3AC1EF">‚ñçErstellen eines Dekorateurs</font> </h3><br>  Hier ist die Unterschrift des Dekorateurs: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  </span></span></span><span class="hljs-function">) </span></span>{} }</code> </pre> <br>  Wie Sie sehen, ist der <code>descriptor</code> ein optionaler Parameter.  Dies liegt daran, dass der Dekorator sowohl auf Methoden als auch auf Eigenschaften angewendet werden muss.  Wenn der Parameter vorhanden ist, bedeutet dies, dass der Dekorator auf die Methode angewendet wird.  In diesem Fall machen wir das: <br><br><ul><li>  Speichern Sie die <code>descriptor.</code>  <code>value</code> . </li><li>  Wir definieren die Methode wie folgt neu: Rufen Sie die urspr√ºngliche Funktion auf und rufen <code>markDirty(this)</code> dann <code>markDirty(this)</code> auf, um den √Ñnderungserkennungsprozess zu starten.  So sieht es aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (descriptor) {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> original = descriptor.value; <span class="hljs-comment"><span class="hljs-comment">//     descriptor.value = function(...args: any[]) {    original.apply(this, args); //       markDirty(this);  }; } else {  //   }</span></span></code> </pre> </li></ul><br>  Als n√§chstes m√ºssen Sie pr√ºfen, mit welcher Art von Immobilie wir es zu tun haben.  Es kann ein beobachtbares Objekt oder ein gew√∂hnliches Objekt sein.  Hier werden wir eine andere interne Angular-API verwenden.  Es ist meines Erachtens nicht zur Verwendung in regul√§ren Anwendungen vorgesehen (sorry!). <br><br>  Es handelt sich um die <code>…µcmp</code> Eigenschaft, mit der auf die von Angular verarbeiteten Eigenschaften <code>…µcmp</code> , nachdem sie definiert wurden.  Wir k√∂nnen sie verwenden, um die Methoden der <code>onDestroy</code> <code>onInit</code> und <code>onDestroy</code> zu √ºberschreiben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getCmp = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function"> =&gt;</span></span> (type).…µcmp; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cmp = getCmp(target.constructor); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onInit = cmp.onInit || noop; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onDestroy = cmp.onDestroy || noop;</code> </pre> <br>  Um eine Eigenschaft als zu √ºberwachend zu kennzeichnen, verwenden wir <code>ReflectMetadata</code> und setzen ihren Wert auf <code>true</code> .  Als Ergebnis wissen wir, dass wir die Eigenschaft beim Initialisieren der Komponente beobachten m√ºssen: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.set(target, propertyKey, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Jetzt ist es Zeit, den <code>onInit</code> Hook zu √ºberschreiben und die Eigenschaften beim Erstellen der Komponenteninstanz zu √ºberpr√ºfen: <br><br><pre> <code class="javascript hljs">cmp.onInit = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  checkComponentProperties(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  onInit.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); };</code> </pre> <br>  Wir definieren die Funktion <code>checkComponentProperties</code> , die die Eigenschaften der Komponente <code>Reflect.set</code> sie nach dem zuvor mit <code>Reflect.set</code> festgelegten Wert <code>Reflect.set</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkComponentProperties = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> props = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(ctx);  props.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prop</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(target, prop);  }).filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    checkProperty.call(ctx, propertyKey);  }); };</code> </pre> <br>  Die <code>checkProperty</code> Funktion ist f√ºr die Dekoration einzelner Eigenschaften verantwortlich.  Zuerst pr√ºfen wir, ob es sich bei der Eigenschaft um ein Observable oder ein regul√§res Objekt handelt.  Wenn es sich um ein beobachtbares Objekt handelt, abonnieren wir es und f√ºgen das Abonnement der Liste der Abonnements hinzu, die in der Komponente f√ºr ihre internen Anforderungen gespeichert sind. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkProperty = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name: string</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[name] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Observable) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscriptions = getSubscriptions(ctx);    subscriptions.add(ctx[name].subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {      markDirty(ctx);    }));  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {    <span class="hljs-comment"><span class="hljs-comment">//    } };</span></span></code> </pre> <br>  Wenn es sich bei der Eigenschaft um ein <code>markDirty</code> Objekt handelt, konvertieren wir es in ein Proxy-Objekt und rufen in seiner <code>markDirty</code> auf: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handler = {  set(obj, prop, value) {    obj[prop] = value;    …µmarkDirty(ctx);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;  } }; ctx[name] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(ctx, handler);</code> </pre> <br>  Schlie√ülich m√ºssen Sie das Abonnement l√∂schen, nachdem Sie die Komponente zerst√∂rt haben: <br><br><pre> <code class="javascript hljs">cmp.onDestroy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[subscriptionsSymbol]) {    ctx[subscriptionsSymbol].unsubscribe();  }  onDestroy.call(ctx); };</code> </pre> <br>  Die M√∂glichkeiten dieses Dekorateurs k√∂nnen nicht als umfassend bezeichnet werden.  Sie decken nicht alle m√∂glichen Verwendungen ab, die in einer gro√üen Anwendung auftreten k√∂nnen.  Dies sind beispielsweise Aufrufe von Vorlagenfunktionen, die Observable-Objekte zur√ºckgeben.  Aber ich arbeite daran. <br><br>  Trotzdem reicht der obige Dekorateur f√ºr mein kleines Projekt.  Den vollst√§ndigen Code finden Sie am Ende des Materials. <br><br><h2>  <font color="#3AC1EF">Analyse der Ergebnisse der Anwendungsbeschleunigung</font> </h2><br>  Nachdem wir uns ein wenig mit den internen Mechanismen von Ivy befasst haben und erkl√§rt haben, wie man mit diesen Mechanismen einen Dekorateur erstellt, ist es an der Zeit zu testen, was wir in einer echten Anwendung haben. <br><br>  Um herauszufinden, wie sich zone.js auf die Leistung von Angular-Anwendungen <a href="https://github.com/gbuomprisco/cryptofolio">auswirkt</a> , habe ich mein <a href="https://github.com/gbuomprisco/cryptofolio">Cryptofolio-</a> Hobbyprojekt verwendet. <br><br>  Ich habe den Dekorator auf alle erforderlichen Links angewendet, die in den Vorlagen und in disabled zone.js verwendet werden.  Betrachten Sie beispielsweise die folgende Komponente: <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetPricerComponent</span></span></span><span class="hljs-class"> </span></span>{  @observed() price$: Observable&lt;string&gt;;  @observed() trend$: Observable&lt;Trend&gt;;   <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  In der Vorlage werden zwei Variablen verwendet: <code>price</code> (der Asset-Preis wird hier angezeigt) und <code>trend</code> (diese Variable kann Werte annehmen, die <code>stale</code> oder <code>down</code> und die Richtung der Preis√§nderung angeben).  Ich habe sie mit <code>@observed</code> dekoriert. <br><br><h3>  <font color="#3AC1EF">‚ñç Projektpaketgr√∂√üe</font> </h3><br>  Schauen wir uns zun√§chst an, wie stark sich die Gr√∂√üe des Projektb√ºndels verringert hat, w√§hrend zone.js entfernt wurde.  Unten sehen Sie das Ergebnis der Erstellung des Projekts mit zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/cb3/7e8/a0bcb37e870dfdcafa1c49a80aeaeb04.png"></div><br>  <i><font color="#999999">Ergebnis der Erstellung eines Projekts mit zone.js</font></i> <br><br>  Und hier ist die Versammlung ohne zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d5/6ae/adc/7d56aeadce675e6953e5e603b3594c2c.png"></div><br>  <i><font color="#999999">Das Ergebnis der Erstellung eines Projekts ohne zone.js</font></i> <br><br>  <code>polyfills-es2015.xxx.js</code> .  Wenn das Projekt zone.js verwendet, betr√§gt seine Gr√∂√üe ungef√§hr 35 KB.  Aber ohne zone.js - nur 130 Bytes. <br><br><h3>  <font color="#3AC1EF">‚ñçBooten</font> </h3><br>  Ich habe zwei Anwendungsm√∂glichkeiten mit Lighthouse untersucht.  Die Ergebnisse dieser Studie sind unten angegeben.  Es sollte beachtet werden, dass ich sie nicht zu ernst nehmen w√ºrde.  Tatsache ist, dass ich beim Versuch, die Durchschnittswerte zu ermitteln, signifikant unterschiedliche Ergebnisse erzielt habe, indem ich mehrere Messungen f√ºr dieselbe Anwendungsversion durchgef√ºhrt habe. <br><br>  M√∂glicherweise h√§ngt der Unterschied bei der Bewertung der beiden Anwendungsoptionen nur von der Gr√∂√üe der Bundles ab. <br><br>  Hier ist das Ergebnis f√ºr eine Anwendung, die zone.js verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfd/922/5f3/dfd9225f368de1f7c3e43d47bddbad16.png"></div><br>  <i><font color="#999999">Analyseergebnisse f√ºr eine Anwendung, die zone.js verwendet</font></i> <br><br>  Und hier ist, was nach der Analyse der Anwendung passiert ist, in der zone.js nicht verwendet wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/684/9ba/f416849ba2f210d1ed48345e607a3d8f.png"></div><br>  <i><font color="#999999">Analyseergebnisse f√ºr eine Anwendung, die zone.js nicht verwendet</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç Leistung</font> </h3><br>  Und jetzt kamen wir zu den interessantesten.  Dies ist die Leistung einer Anwendung, die unter Last ausgef√ºhrt wird.  Wir m√∂chten herausfinden, wie sich der Prozessor f√ºhlt, wenn die Anwendung mehrmals pro Sekunde Preisaktualisierungen f√ºr Hunderte von Assets anzeigt. <br><br>  Um die Anwendung zu laden, habe ich 100 Entit√§ten erstellt, die bedingte Daten zu Preisen bereitstellen, die sich alle 250 ms √§ndern.  Wenn der Preis steigt, wird er gr√ºn angezeigt.  Wenn reduziert - rot.  All dies k√∂nnte mein MacBook Pro ernsthaft belasten. <br><br>  Es ist anzumerken, dass ich bei der Arbeit im Finanzsektor an mehreren Anwendungen f√ºr die Hochfrequenz√ºbertragung von Datenfragmenten oft auf eine √§hnliche Situation gesto√üen bin. <br><br>  Um zu analysieren, wie verschiedene Versionen der Anwendung Prozessorressourcen verwenden, habe ich die Chrome-Entwicklertools verwendet. <br><br>  So sieht die Anwendung aus, die zone.js. verwendet <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbf/11b/56f/fbf11b56ffe060d5bcdc4680a0ddd347.gif"></div><br>  <i><font color="#999999">Systemlast, die von einer Anwendung erstellt wurde, die zone.js verwendet</font></i> <br><br>  Und so funktioniert eine Anwendung, in der zone.js nicht verwendet wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/657/240/8fb65724082e810619f061cb238c76da.gif"></div><br>  <i><font color="#999999">Systemlast, die von einer Anwendung erstellt wurde, die zone.js nicht verwendet</font></i> <br><br>  Wir analysieren diese Ergebnisse unter Ber√ºcksichtigung des Prozessorlastdiagramms (gelb): <br><br><ul><li>  Wie Sie sehen k√∂nnen, l√§dt eine Anwendung, die zone.js verwendet, den Prozessor st√§ndig um 70-100%!  Wenn Sie die Browser-Registerkarte f√ºr l√§ngere Zeit ge√∂ffnet halten und eine solche Last auf dem System erstellen, schl√§gt die darin ausgef√ºhrte Anwendung m√∂glicherweise fehl. </li><li>  Und die Version der Anwendung, in der zone.js nicht verwendet wird, erzeugt eine stabile Auslastung des Prozessors im Bereich von 30 bis 40%.  Gro√üartig! </li></ul><br>  Beachten Sie, dass diese Ergebnisse bei ge√∂ffnetem Chrome Developer Tools-Fenster erzielt wurden, wodurch auch das System belastet und die Anwendung verlangsamt wird. <br><br><h3>  <font color="#3AC1EF">‚ñç Lasterh√∂hung</font> </h3><br>  Ich habe versucht sicherzustellen, dass jedes Unternehmen, das f√ºr die Aktualisierung des Preises verantwortlich ist, zus√§tzlich zu dem, was es bereits produziert, jede Sekunde 4 weitere Updates herausgibt. <br><br>  Folgendes haben wir √ºber die Anwendung herausgefunden, in der zone.js nicht verwendet wird: <br><br><ul><li>  Diese Anwendung ist normalerweise mit der Last fertig geworden und beansprucht nun etwa 50% der Prozessorressourcen. </li><li>  Er schaffte es, den Prozessor genauso wie die Anwendung mit zone.js zu laden, nur wenn die Preise alle 10 ms aktualisiert wurden (neue Daten stammten wie zuvor von 100 Entit√§ten). </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Leistungsanalyse mit Angular Benchpress</font> </h3><br>  Die Performance-Analyse, die ich oben durchgef√ºhrt habe, kann nicht als besonders wissenschaftlich bezeichnet werden.  F√ºr eine eingehendere Untersuchung der Leistung verschiedener Frameworks w√ºrde ich die Verwendung <a href="https://krausest.github.io/js-framework-benchmark/current.html">dieses Benchmarks</a> empfehlen.  F√ºr Recherchen sollte Angular die √ºbliche Version dieses Frameworks und seine Version ohne zone.js ausw√§hlen. <br><br>  Ich habe, inspiriert von einigen Ideen dieses Benchmarks, ein <a href="https://github.com/Gbuomprisco/zoneless-angular">Projekt erstellt</a> , das umfangreiche Berechnungen durchf√ºhrt.  Ich habe seine Leistung mit <a href="https://github.com/angular/angular/tree/master/packages/benchpress">Angular Benchpress getestet</a> . <br><br>  Hier ist der Code der getesteten Komponente: <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{  public data = [];  @observed()  run(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  append(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  removeAll() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();  }  @observed()  remove(item) {    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, l = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length; i &lt; l; i++) {      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data[i].id === item.id) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.splice(i, <span class="hljs-number"><span class="hljs-number">1</span></span>);        <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;      }    }  }  trackById(item) {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item.id;  }  private clear() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = [];  }  private buildData(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = start + length;    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = start; n &lt;= end; n++) {      <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.push({        <span class="hljs-attr"><span class="hljs-attr">id</span></span>: n,        <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()      });    }  } }</code> </pre> <br>  Ich habe eine kleine Reihe von Benchmarks mit Protractor und Benchpress gestartet.  Die Operationen wurden eine festgelegte Anzahl von Malen durchgef√ºhrt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/167/a7b/5c2167a7bae21093e5e7cdc9f2482361.gif"></div><br>  <i><font color="#999999">Bankdr√ºcken in Aktion</font></i> <br><br><h4>  Ergebnisse </h4><br>  Hier finden Sie eine Auswahl der mit Benchpress erzielten Ergebnisse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5a/467/0f0/f5a4670f0af5b461a1f0fad2d7f982b3.png"></div><br>  <i><font color="#999999">Benchpress-Ergebnisse</font></i> <br><br>  Hier ist eine Erl√§uterung der in dieser Tabelle dargestellten Indikatoren: <br><br><ul><li>  <code>gcAmount</code> : gc-Betriebsvolumen (Speicherbereinigung), Kb. </li><li>  <code>gcTime</code> : gc Betriebszeit, ms. </li><li>  <code>majorGcTime</code> : Zeit der Hauptoperationen gc, ms. </li><li>  <code>pureScriptTime</code> : Skriptausf√ºhrungszeit in ms ohne gc-Operationen und Rendering. </li><li>  <code>renderTime</code> : Renderzeit, ms. </li><li>  <code>scriptTime</code> : Skriptausf√ºhrungszeit unter Ber√ºcksichtigung von gc-Operationen und Rendering. </li></ul><br>  Nun betrachten wir die Analyse der Leistung einiger Operationen in verschiedenen Anwendungsvarianten.  Gr√ºn zeigt die Ergebnisse einer Anwendung, die zone.js verwendet. Orange zeigt die Ergebnisse einer Anwendung ohne zone.js.  Bitte beachten Sie, dass hier nur die Renderzeit ausgewertet wird.  Wenn Sie an allen Testergebnissen interessiert sind, klicken Sie <a href="https://github.com/Gbuomprisco/zoneless-angular">hier</a> . <br><br><h4>  Test: 1000 Zeilen erstellen </h4><br>  Im ersten Test werden 1000 Zeilen erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/d48/745/944d48745c79b697bececc092c78c9be.png"></div><br>  <i><font color="#999999">Testergebnisse</font></i> <br><br><h4>  Test: Erstellen von 10.000 Zeilen </h4><br>  Je h√∂her die Auslastung der Anwendungen ist, desto gr√∂√üer ist auch der Unterschied in der Leistung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/971/8aa/7e19718aadeec04390f1f4b7fa408f89.png"></div><br>  <i><font color="#999999">Testergebnisse</font></i> <br><br><h4>  Test: 1000 Zeilen verbinden </h4><br>  In diesem Test werden 1000 Zeilen an 10.000 Zeilen angeh√§ngt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f3/682/d30/3f3682d3064b9158ef95146426d2638b.png"></div><br>  <i><font color="#999999">Testergebnisse</font></i> <br><br><h4>  Test: Entfernen von 10.000 Zeilen </h4><br>  Hier werden 10.000 Zeilen angelegt, die dann gel√∂scht werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f85/d5d/bb7/f85d5dbb78b094bd9bb9afccbce148e3.png"></div><br>  <i><font color="#999999">Testergebnisse</font></i> <br><br><h2>  <font color="#3AC1EF">TypeScript Decorator-Quellcode</font> </h2><br>  Unten finden Sie den Quellcode des hier beschriebenen TypeScript-Dekorators.  Diesen Code finden Sie auch <a href="">hier</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tslint:disable import { Observable, Subscription } from 'rxjs'; import { Type, …µComponentType as ComponentType, …µmarkDirty as markDirty } from '@angular/core'; interface ComponentDefinition {  onInit(): void;  onDestroy(): void; } const noop = () =&gt; { }; const getCmp = &lt;T&gt;(type: Function) =&gt; (type as any).…µcmp as ComponentDefinition; const subscriptionsSymbol = Symbol('__ng__subscriptions'); export function observed() {  return function(    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  ) {    if (descriptor) {      const original = descriptor.value;      descriptor.value = function(...args: any[]) {        original.apply(this, args);        markDirty(this);      };    } else {      const cmp = getCmp(target.constructor);      if (!cmp) {        throw new Error(`Property …µcmp is undefined`);      }      const onInit = cmp.onInit || noop;      const onDestroy = cmp.onDestroy || noop;      const getSubscriptions = (ctx) =&gt; {        if (ctx[subscriptionsSymbol]) {          return ctx[subscriptionsSymbol];        }        ctx[subscriptionsSymbol] = new Subscription();        return ctx[subscriptionsSymbol];      };      const checkProperty = function(name: string) {        const ctx = this;        if (ctx[name] instanceof Observable) {          const subscriptions = getSubscriptions(ctx);          subscriptions.add(ctx[name].subscribe(() =&gt; markDirty(ctx)));        } else {          const handler = {            set(obj: object, prop: string, value: unknown) {              obj[prop] = value;              markDirty(ctx);              return true;            }          };          ctx[name] = new Proxy(ctx, handler);        }      };      const checkComponentProperties = (ctx) =&gt; {        const props = Object.getOwnPropertyNames(ctx);        props.map((prop) =&gt; {          return Reflect.get(target, prop);        }).filter(Boolean).forEach(() =&gt; {          checkProperty.call(ctx, propertyKey);        });      };      cmp.onInit = function() {        const ctx = this;        onInit.call(ctx);        checkComponentProperties(ctx);      };      cmp.onDestroy = function() {        const ctx = this;        onDestroy.call(ctx);        if (ctx[subscriptionsSymbol]) {          ctx[subscriptionsSymbol].unsubscribe();        }      };      Reflect.set(target, propertyKey, true);    }  }; }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Obwohl ich hoffe, dass Ihnen meine Geschichte √ºber die Optimierung der Leistung von Angular-Projekten gefallen hat, hoffe ich, dass Sie nicht dazu veranlasst werden, zone.js schnell aus Ihrem Projekt zu entfernen.  Die hier beschriebene Strategie sollte der allerletzte Ausweg sein, auf den Sie zur√ºckgreifen k√∂nnen, um die Leistung Ihrer Angular-Anwendung zu steigern. <br><br>  Zun√§chst m√ºssen Sie Ans√§tze wie die OnPush-√Ñnderungserkennungsstrategie <code>trackBy</code> , <code>trackBy</code> anwenden, Komponenten deaktivieren, Code au√üerhalb von zone.js ausf√ºhren und zone.js-Ereignisse auf die schwarze Liste setzen (diese Liste von Optimierungsmethoden kann fortgesetzt werden).  Der hier gezeigte Ansatz ist ziemlich teuer, und ich bin mir nicht sicher, ob jeder bereit ist, einen so hohen Preis f√ºr die Leistung zu zahlen. <br><br>  Tats√§chlich ist die Entwicklung ohne zone.js m√∂glicherweise nicht die attraktivste Sache.  Vielleicht ist dies nicht nur f√ºr die Person, die an dem Projekt beteiligt ist, das unter seiner vollen Kontrolle steht.  Das hei√üt - es ist der Eigent√ºmer von Abh√§ngigkeiten und hat die F√§higkeit und Zeit, alles in die richtige Form zu bringen. <br><br>  Wenn sich herausstellt, dass Sie alles ausprobiert haben und glauben, dass der Engpass Ihres Projekts genau zone.js ist, sollten Sie m√∂glicherweise versuchen, Angular zu beschleunigen, indem Sie die √Ñnderungen unabh√§ngig voneinander erkennen. <br><br>  Ich hoffe, dass Sie in diesem Artikel sehen konnten, was Angular in Zukunft erwartet, wozu Ivy in der Lage ist und was mit zone.js getan werden kann, um die Anwendungsgeschwindigkeit zu maximieren. <br><br>  <b>Sehr geehrte Leser!</b>  Wie optimieren Sie Ihre Angular-Projekte, die maximale Leistung ben√∂tigen? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476956/">https://habr.com/ru/post/de476956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476938/index.html">Unzug√§nglicher Luxus von Intel: Core i9-9990XE mit 14 Kernen bei einer Frequenz von 5,0 GHz (2 Teile)</a></li>
<li><a href="../de476940/index.html">Semaphor auf C ++ - Ereignissen</a></li>
<li><a href="../de476944/index.html">Das Gehirn der Firma. Starten Sie</a></li>
<li><a href="../de476948/index.html">Quantenbahnen und womit sie essen</a></li>
<li><a href="../de476954/index.html">Arbeit ist kein Wolf, Teil 3. Anf√§nger - wachsen oder √ºberleben?</a></li>
<li><a href="../de476958/index.html">Omega Red + PS1 Emulator = Kojima Genius</a></li>
<li><a href="../de476970/index.html">EkbDotNet-Treffen Nr. 1 - Jekaterinburg tritt der DotNet.Ru-Community bei</a></li>
<li><a href="../de476972/index.html">Deno: Node.JS l√§uft die Zeit davon?</a></li>
<li><a href="../de476974/index.html">Lernen Sie Responsive Web Design in 5 Minuten</a></li>
<li><a href="../de476976/index.html">6 Redefehler bei Konferenzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>