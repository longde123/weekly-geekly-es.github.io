<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏼 👩‍🔧 💲 Winkel ohne zone.js: maximale Leistung 🤳🏾 💀 👨‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Angular-Entwickler haben zone.js viel zu verdanken. Sie hilft zum Beispiel dabei, die Arbeit mit Angular auf magische Weise zu vereinfachen. In der Ta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Winkel ohne zone.js: maximale Leistung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/476956/">  Angular-Entwickler haben zone.js viel zu verdanken.  Sie hilft zum Beispiel dabei, die Arbeit mit Angular auf magische Weise zu vereinfachen.  In der Tat rendert Angular die entsprechenden Komponenten fast immer neu, wenn Sie nur eine Eigenschaft ändern müssen und wir sie ändern, ohne an irgendetwas zu denken.  Infolgedessen enthält das, was der Benutzer sieht, immer die neuesten Informationen.  Das ist einfach toll. <br><br>  Hier möchte ich einige Aspekte untersuchen, wie die Verwendung des neuen Ivy-Compilers (der in Angular 9 erschien) die Ablehnung der Verwendung von zone.js erheblich erleichtern kann. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/476956/"><img src="https://habrastorage.org/webt/9m/ql/xa/9mqlxapag9joinziuleg8frnslm.jpeg"></a> <br><br>  Durch den Verzicht auf diese Bibliothek konnte ich die Leistung der unter hoher Last ausgeführten Angular-Anwendung erheblich steigern.  Gleichzeitig gelang es mir, die von mir benötigten Mechanismen mithilfe von TypeScript-Dekoratoren zu implementieren, was zu sehr geringen zusätzlichen Systemressourcen führte. <br><br>  Beachten Sie, dass der in diesem Artikel beschriebene Ansatz zur Optimierung von Angular-Anwendungen nur möglich ist, weil Angular Ivy und AOT standardmäßig aktiviert sind.  Dieser Artikel wurde zu Bildungszwecken verfasst und zielt nicht darauf ab, den darin vorgestellten Ansatz für die Entwicklung von Angular-Projekten zu fördern. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Warum müssen Sie möglicherweise Angular ohne zone.js verwenden?</font> </h2><br>  Bevor wir fortfahren, stellen wir eine wichtige Frage: „Lohnt es sich, zone.js loszuwerden, da diese Bibliothek uns hilft, Vorlagen mit geringem Aufwand neu zu rendern?“  Natürlich ist diese Bibliothek sehr nützlich.  Aber wie immer muss man für alles bezahlen. <br><br>  Wenn für Ihre Anwendung bestimmte Leistungsanforderungen gelten, können Sie diese durch Deaktivieren von zone.js erfüllen.  Ein Beispiel für eine Anwendung, bei der die Leistung von entscheidender Bedeutung ist, ist ein Projekt, dessen Oberfläche sehr häufig aktualisiert wird.  In meinem Fall erwies sich ein solches Projekt als Echtzeit-Handelsanwendung.  Sein Client-Teil empfängt ständig Nachrichten über das WebSocket-Protokoll.  Die Daten aus diesen Nachrichten sollten so schnell wie möglich angezeigt werden. <br><br><h2>  <font color="#3AC1EF">Entfernen Sie zone.js von Angular</font> </h2><br>  Angular kann sehr einfach zum Arbeiten ohne zone.js gebracht werden.  Dazu müssen Sie zuerst den entsprechenden Importbefehl <code>polyfills.ts</code> oder löschen, der sich in der Datei <code>polyfills.ts</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a4/f95/17e/7a4f9517eb4898e51240862c08e4faa9.png"></div><br>  <i><font color="#999999">Auskommentierter Befehl zum Importieren von zone.js</font></i> <br><br>  Weiter - Sie müssen das Root-Modul mit den folgenden Optionen ausstatten: <br><br><pre> <code class="javascript hljs">platformBrowserDynamic()  .bootstrapModule(AppModule, {    <span class="hljs-attr"><span class="hljs-attr">ngZone</span></span>: <span class="hljs-string"><span class="hljs-string">'noop'</span></span>  })  .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err));</code> </pre> <br><h2>  <font color="#3AC1EF">Angular Ivy: Selbsterkennende Änderungen mit ɵdetectChanges und ɵmarkDirty</font> </h2><br>  Bevor wir mit dem Erstellen eines TypeScript-Dekorators beginnen können, müssen wir lernen, wie Sie mit Ivy den Prozess zum Erkennen von Komponentenänderungen, zum Verschmutzen und zum Umgehen von zone.js und DI aufrufen können. <br><br>  Jetzt stehen uns zwei zusätzliche Funktionen zur Verfügung, die aus <code>@angular/core</code> exportiert werden.  Dies sind <code>ɵdetectChanges</code> und <code>ɵmarkDirty</code> .  Diese beiden Funktionen sind weiterhin für den internen Gebrauch bestimmt und instabil - das Symbol <code>ɵ</code> befindet sich am Anfang ihres Namens. <br><br>  Schauen wir uns an, wie diese Funktionen verwendet werden. <br><br><h3>  <font color="#3AC1EF">▍ ɵmarkDirty-Funktion</font> </h3><br>  Mit dieser Funktion können Sie eine Komponente als "verschmutzt" markieren, dh, sie muss neu gerendert werden.  Sie plant, den Änderungserkennungsprozess zu starten, wenn die Komponente vor dem Aufrufen nicht als "verschmutzt" markiert war. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ɵmarkDirty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> markDirty } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    markDirty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ ɵdetectChanges-Funktion</font> </h3><br>  Angular interne Dokumentation besagt, dass Sie aus Leistungsgründen <code>ɵdetectChanges</code> nicht verwenden <code>ɵdetectChanges</code> .  Stattdessen wird empfohlen, die <code>ɵmarkDirty</code> functionmarkDirty zu verwenden.  Die Funktion <code>ɵdetectChanges</code> ruft synchron den Prozess zum Erkennen von Änderungen in einer Komponente und ihren Unterkomponenten auf. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ɵdetectChanges <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> detectChanges } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    detectChanges(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h2>  <font color="#3AC1EF">Automatische Erkennung von Änderungen mit TypeScript Decorator</font> </h2><br>  Obwohl die von Angular bereitgestellten Funktionen die Benutzerfreundlichkeit der Entwicklung erhöhen, indem die DI herumlaufen gelassen wird, kann der Programmierer dennoch frustriert sein, dass er diese Funktionen importieren und selbst aufrufen muss, um den Änderungserkennungsprozess zu starten. <br><br>  Um den automatischen Start der Änderungserkennung zu vereinfachen, können Sie einen TypeScript-Dekorator schreiben, der dieses Problem unabhängig löst.  Natürlich gibt es hier einige Einschränkungen, die wir unten diskutieren werden, aber in meinem Fall hat sich herausgestellt, dass dieser Ansatz genau das war, was ich brauchte. <br><br><h3>  <font color="#3AC1EF">▍Einführung des @observed Decorators</font> </h3><br>  Um Änderungen mit möglichst geringem Aufwand zu erkennen, erstellen wir einen Dekorateur, der auf drei Arten angewendet werden kann.  Es ist nämlich auf die folgenden Entitäten anwendbar: <br><br><ul><li>  Zu synchronen Methoden. </li><li>  Beobachtbare Objekte. </li><li>  Zu gewöhnlichen Gegenständen. </li></ul><br>  Betrachten Sie ein paar kleine Beispiele.  Im folgenden Codefragment wenden wir den <code>@observed</code> Dekorator auf das <code>changeTitle</code> und auf die <code>changeTitle</code> Methode an: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{    title = <span class="hljs-string"><span class="hljs-string">''</span></span>;    @observed() state = {        <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>    };    @observed()    changeTitle(title: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    }    changeName(name: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.name = name;    } }</code> </pre> <br><ul><li>  Um nach Änderungen am <code>state</code> suchen, verwenden wir ein Proxy-Objekt, das Änderungen am Objekt abfängt und die Prozedur zum Erkennen von Änderungen aufruft. </li><li>  Wir überschreiben die <code>changeTitle</code> Methode, indem wir eine Funktion anwenden, die diese Methode zuerst aufruft und dann den Änderungserkennungsprozess startet. </li></ul><br>  Und hier ist ein Beispiel mit <code>BehaviorSubject</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{    @observed() show$ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);    toggle() {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.next(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.value);    } }</code> </pre> <br>  Bei beobachtbaren Objekten sieht die Verwendung eines Dekorateurs etwas komplizierter aus.  Sie müssen das beobachtete Objekt abonnieren und die Komponente im Abonnement als "unsauber" markieren, aber Sie müssen auch das Abonnement löschen.  Zu diesem <code>ngOnInit</code> <code>ngOnDestroy</code> wir <code>ngOnInit</code> und <code>ngOnDestroy</code> zu, um sie später zu abonnieren und zu bereinigen. <br><br><h3>  <font color="#3AC1EF">▍Erstellen eines Dekorateurs</font> </h3><br>  Hier ist die Unterschrift des Dekorateurs: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  </span></span></span><span class="hljs-function">) </span></span>{} }</code> </pre> <br>  Wie Sie sehen, ist der <code>descriptor</code> ein optionaler Parameter.  Dies liegt daran, dass der Dekorator sowohl auf Methoden als auch auf Eigenschaften angewendet werden muss.  Wenn der Parameter vorhanden ist, bedeutet dies, dass der Dekorator auf die Methode angewendet wird.  In diesem Fall machen wir das: <br><br><ul><li>  Speichern Sie die <code>descriptor.</code>  <code>value</code> . </li><li>  Wir definieren die Methode wie folgt neu: Rufen Sie die ursprüngliche Funktion auf und rufen <code>markDirty(this)</code> dann <code>markDirty(this)</code> auf, um den Änderungserkennungsprozess zu starten.  So sieht es aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (descriptor) {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> original = descriptor.value; <span class="hljs-comment"><span class="hljs-comment">//     descriptor.value = function(...args: any[]) {    original.apply(this, args); //       markDirty(this);  }; } else {  //   }</span></span></code> </pre> </li></ul><br>  Als nächstes müssen Sie prüfen, mit welcher Art von Immobilie wir es zu tun haben.  Es kann ein beobachtbares Objekt oder ein gewöhnliches Objekt sein.  Hier werden wir eine andere interne Angular-API verwenden.  Es ist meines Erachtens nicht zur Verwendung in regulären Anwendungen vorgesehen (sorry!). <br><br>  Es handelt sich um die <code>ɵcmp</code> Eigenschaft, mit der auf die von Angular verarbeiteten Eigenschaften <code>ɵcmp</code> , nachdem sie definiert wurden.  Wir können sie verwenden, um die Methoden der <code>onDestroy</code> <code>onInit</code> und <code>onDestroy</code> zu überschreiben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getCmp = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function"> =&gt;</span></span> (type).ɵcmp; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cmp = getCmp(target.constructor); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onInit = cmp.onInit || noop; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onDestroy = cmp.onDestroy || noop;</code> </pre> <br>  Um eine Eigenschaft als zu überwachend zu kennzeichnen, verwenden wir <code>ReflectMetadata</code> und setzen ihren Wert auf <code>true</code> .  Als Ergebnis wissen wir, dass wir die Eigenschaft beim Initialisieren der Komponente beobachten müssen: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.set(target, propertyKey, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Jetzt ist es Zeit, den <code>onInit</code> Hook zu überschreiben und die Eigenschaften beim Erstellen der Komponenteninstanz zu überprüfen: <br><br><pre> <code class="javascript hljs">cmp.onInit = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  checkComponentProperties(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  onInit.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); };</code> </pre> <br>  Wir definieren die Funktion <code>checkComponentProperties</code> , die die Eigenschaften der Komponente <code>Reflect.set</code> sie nach dem zuvor mit <code>Reflect.set</code> festgelegten Wert <code>Reflect.set</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkComponentProperties = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> props = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(ctx);  props.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prop</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(target, prop);  }).filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    checkProperty.call(ctx, propertyKey);  }); };</code> </pre> <br>  Die <code>checkProperty</code> Funktion ist für die Dekoration einzelner Eigenschaften verantwortlich.  Zuerst prüfen wir, ob es sich bei der Eigenschaft um ein Observable oder ein reguläres Objekt handelt.  Wenn es sich um ein beobachtbares Objekt handelt, abonnieren wir es und fügen das Abonnement der Liste der Abonnements hinzu, die in der Komponente für ihre internen Anforderungen gespeichert sind. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkProperty = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name: string</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[name] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Observable) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscriptions = getSubscriptions(ctx);    subscriptions.add(ctx[name].subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {      markDirty(ctx);    }));  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {    <span class="hljs-comment"><span class="hljs-comment">//    } };</span></span></code> </pre> <br>  Wenn es sich bei der Eigenschaft um ein <code>markDirty</code> Objekt handelt, konvertieren wir es in ein Proxy-Objekt und rufen in seiner <code>markDirty</code> auf: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handler = {  set(obj, prop, value) {    obj[prop] = value;    ɵmarkDirty(ctx);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;  } }; ctx[name] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(ctx, handler);</code> </pre> <br>  Schließlich müssen Sie das Abonnement löschen, nachdem Sie die Komponente zerstört haben: <br><br><pre> <code class="javascript hljs">cmp.onDestroy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[subscriptionsSymbol]) {    ctx[subscriptionsSymbol].unsubscribe();  }  onDestroy.call(ctx); };</code> </pre> <br>  Die Möglichkeiten dieses Dekorateurs können nicht als umfassend bezeichnet werden.  Sie decken nicht alle möglichen Verwendungen ab, die in einer großen Anwendung auftreten können.  Dies sind beispielsweise Aufrufe von Vorlagenfunktionen, die Observable-Objekte zurückgeben.  Aber ich arbeite daran. <br><br>  Trotzdem reicht der obige Dekorateur für mein kleines Projekt.  Den vollständigen Code finden Sie am Ende des Materials. <br><br><h2>  <font color="#3AC1EF">Analyse der Ergebnisse der Anwendungsbeschleunigung</font> </h2><br>  Nachdem wir uns ein wenig mit den internen Mechanismen von Ivy befasst haben und erklärt haben, wie man mit diesen Mechanismen einen Dekorateur erstellt, ist es an der Zeit zu testen, was wir in einer echten Anwendung haben. <br><br>  Um herauszufinden, wie sich zone.js auf die Leistung von Angular-Anwendungen <a href="https://github.com/gbuomprisco/cryptofolio">auswirkt</a> , habe ich mein <a href="https://github.com/gbuomprisco/cryptofolio">Cryptofolio-</a> Hobbyprojekt verwendet. <br><br>  Ich habe den Dekorator auf alle erforderlichen Links angewendet, die in den Vorlagen und in disabled zone.js verwendet werden.  Betrachten Sie beispielsweise die folgende Komponente: <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetPricerComponent</span></span></span><span class="hljs-class"> </span></span>{  @observed() price$: Observable&lt;string&gt;;  @observed() trend$: Observable&lt;Trend&gt;;   <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  In der Vorlage werden zwei Variablen verwendet: <code>price</code> (der Asset-Preis wird hier angezeigt) und <code>trend</code> (diese Variable kann Werte annehmen, die <code>stale</code> oder <code>down</code> und die Richtung der Preisänderung angeben).  Ich habe sie mit <code>@observed</code> dekoriert. <br><br><h3>  <font color="#3AC1EF">▍ Projektpaketgröße</font> </h3><br>  Schauen wir uns zunächst an, wie stark sich die Größe des Projektbündels verringert hat, während zone.js entfernt wurde.  Unten sehen Sie das Ergebnis der Erstellung des Projekts mit zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/cb3/7e8/a0bcb37e870dfdcafa1c49a80aeaeb04.png"></div><br>  <i><font color="#999999">Ergebnis der Erstellung eines Projekts mit zone.js</font></i> <br><br>  Und hier ist die Versammlung ohne zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d5/6ae/adc/7d56aeadce675e6953e5e603b3594c2c.png"></div><br>  <i><font color="#999999">Das Ergebnis der Erstellung eines Projekts ohne zone.js</font></i> <br><br>  <code>polyfills-es2015.xxx.js</code> .  Wenn das Projekt zone.js verwendet, beträgt seine Größe ungefähr 35 KB.  Aber ohne zone.js - nur 130 Bytes. <br><br><h3>  <font color="#3AC1EF">▍Booten</font> </h3><br>  Ich habe zwei Anwendungsmöglichkeiten mit Lighthouse untersucht.  Die Ergebnisse dieser Studie sind unten angegeben.  Es sollte beachtet werden, dass ich sie nicht zu ernst nehmen würde.  Tatsache ist, dass ich beim Versuch, die Durchschnittswerte zu ermitteln, signifikant unterschiedliche Ergebnisse erzielt habe, indem ich mehrere Messungen für dieselbe Anwendungsversion durchgeführt habe. <br><br>  Möglicherweise hängt der Unterschied bei der Bewertung der beiden Anwendungsoptionen nur von der Größe der Bundles ab. <br><br>  Hier ist das Ergebnis für eine Anwendung, die zone.js verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfd/922/5f3/dfd9225f368de1f7c3e43d47bddbad16.png"></div><br>  <i><font color="#999999">Analyseergebnisse für eine Anwendung, die zone.js verwendet</font></i> <br><br>  Und hier ist, was nach der Analyse der Anwendung passiert ist, in der zone.js nicht verwendet wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/684/9ba/f416849ba2f210d1ed48345e607a3d8f.png"></div><br>  <i><font color="#999999">Analyseergebnisse für eine Anwendung, die zone.js nicht verwendet</font></i> <br><br><h3>  <font color="#3AC1EF">▍ Leistung</font> </h3><br>  Und jetzt kamen wir zu den interessantesten.  Dies ist die Leistung einer Anwendung, die unter Last ausgeführt wird.  Wir möchten herausfinden, wie sich der Prozessor fühlt, wenn die Anwendung mehrmals pro Sekunde Preisaktualisierungen für Hunderte von Assets anzeigt. <br><br>  Um die Anwendung zu laden, habe ich 100 Entitäten erstellt, die bedingte Daten zu Preisen bereitstellen, die sich alle 250 ms ändern.  Wenn der Preis steigt, wird er grün angezeigt.  Wenn reduziert - rot.  All dies könnte mein MacBook Pro ernsthaft belasten. <br><br>  Es ist anzumerken, dass ich bei der Arbeit im Finanzsektor an mehreren Anwendungen für die Hochfrequenzübertragung von Datenfragmenten oft auf eine ähnliche Situation gestoßen bin. <br><br>  Um zu analysieren, wie verschiedene Versionen der Anwendung Prozessorressourcen verwenden, habe ich die Chrome-Entwicklertools verwendet. <br><br>  So sieht die Anwendung aus, die zone.js. verwendet <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbf/11b/56f/fbf11b56ffe060d5bcdc4680a0ddd347.gif"></div><br>  <i><font color="#999999">Systemlast, die von einer Anwendung erstellt wurde, die zone.js verwendet</font></i> <br><br>  Und so funktioniert eine Anwendung, in der zone.js nicht verwendet wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/657/240/8fb65724082e810619f061cb238c76da.gif"></div><br>  <i><font color="#999999">Systemlast, die von einer Anwendung erstellt wurde, die zone.js nicht verwendet</font></i> <br><br>  Wir analysieren diese Ergebnisse unter Berücksichtigung des Prozessorlastdiagramms (gelb): <br><br><ul><li>  Wie Sie sehen können, lädt eine Anwendung, die zone.js verwendet, den Prozessor ständig um 70-100%!  Wenn Sie die Browser-Registerkarte für längere Zeit geöffnet halten und eine solche Last auf dem System erstellen, schlägt die darin ausgeführte Anwendung möglicherweise fehl. </li><li>  Und die Version der Anwendung, in der zone.js nicht verwendet wird, erzeugt eine stabile Auslastung des Prozessors im Bereich von 30 bis 40%.  Großartig! </li></ul><br>  Beachten Sie, dass diese Ergebnisse bei geöffnetem Chrome Developer Tools-Fenster erzielt wurden, wodurch auch das System belastet und die Anwendung verlangsamt wird. <br><br><h3>  <font color="#3AC1EF">▍ Lasterhöhung</font> </h3><br>  Ich habe versucht sicherzustellen, dass jedes Unternehmen, das für die Aktualisierung des Preises verantwortlich ist, zusätzlich zu dem, was es bereits produziert, jede Sekunde 4 weitere Updates herausgibt. <br><br>  Folgendes haben wir über die Anwendung herausgefunden, in der zone.js nicht verwendet wird: <br><br><ul><li>  Diese Anwendung ist normalerweise mit der Last fertig geworden und beansprucht nun etwa 50% der Prozessorressourcen. </li><li>  Er schaffte es, den Prozessor genauso wie die Anwendung mit zone.js zu laden, nur wenn die Preise alle 10 ms aktualisiert wurden (neue Daten stammten wie zuvor von 100 Entitäten). </li></ul><br><h3>  <font color="#3AC1EF">▍ Leistungsanalyse mit Angular Benchpress</font> </h3><br>  Die Performance-Analyse, die ich oben durchgeführt habe, kann nicht als besonders wissenschaftlich bezeichnet werden.  Für eine eingehendere Untersuchung der Leistung verschiedener Frameworks würde ich die Verwendung <a href="https://krausest.github.io/js-framework-benchmark/current.html">dieses Benchmarks</a> empfehlen.  Für Recherchen sollte Angular die übliche Version dieses Frameworks und seine Version ohne zone.js auswählen. <br><br>  Ich habe, inspiriert von einigen Ideen dieses Benchmarks, ein <a href="https://github.com/Gbuomprisco/zoneless-angular">Projekt erstellt</a> , das umfangreiche Berechnungen durchführt.  Ich habe seine Leistung mit <a href="https://github.com/angular/angular/tree/master/packages/benchpress">Angular Benchpress getestet</a> . <br><br>  Hier ist der Code der getesteten Komponente: <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{  public data = [];  @observed()  run(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  append(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  removeAll() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();  }  @observed()  remove(item) {    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, l = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length; i &lt; l; i++) {      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data[i].id === item.id) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.splice(i, <span class="hljs-number"><span class="hljs-number">1</span></span>);        <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;      }    }  }  trackById(item) {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item.id;  }  private clear() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = [];  }  private buildData(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = start + length;    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = start; n &lt;= end; n++) {      <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.push({        <span class="hljs-attr"><span class="hljs-attr">id</span></span>: n,        <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()      });    }  } }</code> </pre> <br>  Ich habe eine kleine Reihe von Benchmarks mit Protractor und Benchpress gestartet.  Die Operationen wurden eine festgelegte Anzahl von Malen durchgeführt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/167/a7b/5c2167a7bae21093e5e7cdc9f2482361.gif"></div><br>  <i><font color="#999999">Bankdrücken in Aktion</font></i> <br><br><h4>  Ergebnisse </h4><br>  Hier finden Sie eine Auswahl der mit Benchpress erzielten Ergebnisse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5a/467/0f0/f5a4670f0af5b461a1f0fad2d7f982b3.png"></div><br>  <i><font color="#999999">Benchpress-Ergebnisse</font></i> <br><br>  Hier ist eine Erläuterung der in dieser Tabelle dargestellten Indikatoren: <br><br><ul><li>  <code>gcAmount</code> : gc-Betriebsvolumen (Speicherbereinigung), Kb. </li><li>  <code>gcTime</code> : gc Betriebszeit, ms. </li><li>  <code>majorGcTime</code> : Zeit der Hauptoperationen gc, ms. </li><li>  <code>pureScriptTime</code> : Skriptausführungszeit in ms ohne gc-Operationen und Rendering. </li><li>  <code>renderTime</code> : Renderzeit, ms. </li><li>  <code>scriptTime</code> : Skriptausführungszeit unter Berücksichtigung von gc-Operationen und Rendering. </li></ul><br>  Nun betrachten wir die Analyse der Leistung einiger Operationen in verschiedenen Anwendungsvarianten.  Grün zeigt die Ergebnisse einer Anwendung, die zone.js verwendet. Orange zeigt die Ergebnisse einer Anwendung ohne zone.js.  Bitte beachten Sie, dass hier nur die Renderzeit ausgewertet wird.  Wenn Sie an allen Testergebnissen interessiert sind, klicken Sie <a href="https://github.com/Gbuomprisco/zoneless-angular">hier</a> . <br><br><h4>  Test: 1000 Zeilen erstellen </h4><br>  Im ersten Test werden 1000 Zeilen erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/d48/745/944d48745c79b697bececc092c78c9be.png"></div><br>  <i><font color="#999999">Testergebnisse</font></i> <br><br><h4>  Test: Erstellen von 10.000 Zeilen </h4><br>  Je höher die Auslastung der Anwendungen ist, desto größer ist auch der Unterschied in der Leistung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/971/8aa/7e19718aadeec04390f1f4b7fa408f89.png"></div><br>  <i><font color="#999999">Testergebnisse</font></i> <br><br><h4>  Test: 1000 Zeilen verbinden </h4><br>  In diesem Test werden 1000 Zeilen an 10.000 Zeilen angehängt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f3/682/d30/3f3682d3064b9158ef95146426d2638b.png"></div><br>  <i><font color="#999999">Testergebnisse</font></i> <br><br><h4>  Test: Entfernen von 10.000 Zeilen </h4><br>  Hier werden 10.000 Zeilen angelegt, die dann gelöscht werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f85/d5d/bb7/f85d5dbb78b094bd9bb9afccbce148e3.png"></div><br>  <i><font color="#999999">Testergebnisse</font></i> <br><br><h2>  <font color="#3AC1EF">TypeScript Decorator-Quellcode</font> </h2><br>  Unten finden Sie den Quellcode des hier beschriebenen TypeScript-Dekorators.  Diesen Code finden Sie auch <a href="">hier</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tslint:disable import { Observable, Subscription } from 'rxjs'; import { Type, ɵComponentType as ComponentType, ɵmarkDirty as markDirty } from '@angular/core'; interface ComponentDefinition {  onInit(): void;  onDestroy(): void; } const noop = () =&gt; { }; const getCmp = &lt;T&gt;(type: Function) =&gt; (type as any).ɵcmp as ComponentDefinition; const subscriptionsSymbol = Symbol('__ng__subscriptions'); export function observed() {  return function(    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  ) {    if (descriptor) {      const original = descriptor.value;      descriptor.value = function(...args: any[]) {        original.apply(this, args);        markDirty(this);      };    } else {      const cmp = getCmp(target.constructor);      if (!cmp) {        throw new Error(`Property ɵcmp is undefined`);      }      const onInit = cmp.onInit || noop;      const onDestroy = cmp.onDestroy || noop;      const getSubscriptions = (ctx) =&gt; {        if (ctx[subscriptionsSymbol]) {          return ctx[subscriptionsSymbol];        }        ctx[subscriptionsSymbol] = new Subscription();        return ctx[subscriptionsSymbol];      };      const checkProperty = function(name: string) {        const ctx = this;        if (ctx[name] instanceof Observable) {          const subscriptions = getSubscriptions(ctx);          subscriptions.add(ctx[name].subscribe(() =&gt; markDirty(ctx)));        } else {          const handler = {            set(obj: object, prop: string, value: unknown) {              obj[prop] = value;              markDirty(ctx);              return true;            }          };          ctx[name] = new Proxy(ctx, handler);        }      };      const checkComponentProperties = (ctx) =&gt; {        const props = Object.getOwnPropertyNames(ctx);        props.map((prop) =&gt; {          return Reflect.get(target, prop);        }).filter(Boolean).forEach(() =&gt; {          checkProperty.call(ctx, propertyKey);        });      };      cmp.onInit = function() {        const ctx = this;        onInit.call(ctx);        checkComponentProperties(ctx);      };      cmp.onDestroy = function() {        const ctx = this;        onDestroy.call(ctx);        if (ctx[subscriptionsSymbol]) {          ctx[subscriptionsSymbol].unsubscribe();        }      };      Reflect.set(target, propertyKey, true);    }  }; }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Obwohl ich hoffe, dass Ihnen meine Geschichte über die Optimierung der Leistung von Angular-Projekten gefallen hat, hoffe ich, dass Sie nicht dazu veranlasst werden, zone.js schnell aus Ihrem Projekt zu entfernen.  Die hier beschriebene Strategie sollte der allerletzte Ausweg sein, auf den Sie zurückgreifen können, um die Leistung Ihrer Angular-Anwendung zu steigern. <br><br>  Zunächst müssen Sie Ansätze wie die OnPush-Änderungserkennungsstrategie <code>trackBy</code> , <code>trackBy</code> anwenden, Komponenten deaktivieren, Code außerhalb von zone.js ausführen und zone.js-Ereignisse auf die schwarze Liste setzen (diese Liste von Optimierungsmethoden kann fortgesetzt werden).  Der hier gezeigte Ansatz ist ziemlich teuer, und ich bin mir nicht sicher, ob jeder bereit ist, einen so hohen Preis für die Leistung zu zahlen. <br><br>  Tatsächlich ist die Entwicklung ohne zone.js möglicherweise nicht die attraktivste Sache.  Vielleicht ist dies nicht nur für die Person, die an dem Projekt beteiligt ist, das unter seiner vollen Kontrolle steht.  Das heißt - es ist der Eigentümer von Abhängigkeiten und hat die Fähigkeit und Zeit, alles in die richtige Form zu bringen. <br><br>  Wenn sich herausstellt, dass Sie alles ausprobiert haben und glauben, dass der Engpass Ihres Projekts genau zone.js ist, sollten Sie möglicherweise versuchen, Angular zu beschleunigen, indem Sie die Änderungen unabhängig voneinander erkennen. <br><br>  Ich hoffe, dass Sie in diesem Artikel sehen konnten, was Angular in Zukunft erwartet, wozu Ivy in der Lage ist und was mit zone.js getan werden kann, um die Anwendungsgeschwindigkeit zu maximieren. <br><br>  <b>Sehr geehrte Leser!</b>  Wie optimieren Sie Ihre Angular-Projekte, die maximale Leistung benötigen? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476956/">https://habr.com/ru/post/de476956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476938/index.html">Unzugänglicher Luxus von Intel: Core i9-9990XE mit 14 Kernen bei einer Frequenz von 5,0 GHz (2 Teile)</a></li>
<li><a href="../de476940/index.html">Semaphor auf C ++ - Ereignissen</a></li>
<li><a href="../de476944/index.html">Das Gehirn der Firma. Starten Sie</a></li>
<li><a href="../de476948/index.html">Quantenbahnen und womit sie essen</a></li>
<li><a href="../de476954/index.html">Arbeit ist kein Wolf, Teil 3. Anfänger - wachsen oder überleben?</a></li>
<li><a href="../de476958/index.html">Omega Red + PS1 Emulator = Kojima Genius</a></li>
<li><a href="../de476970/index.html">EkbDotNet-Treffen Nr. 1 - Jekaterinburg tritt der DotNet.Ru-Community bei</a></li>
<li><a href="../de476972/index.html">Deno: Node.JS läuft die Zeit davon?</a></li>
<li><a href="../de476974/index.html">Lernen Sie Responsive Web Design in 5 Minuten</a></li>
<li><a href="../de476976/index.html">6 Redefehler bei Konferenzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>