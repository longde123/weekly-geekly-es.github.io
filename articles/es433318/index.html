<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíú üì™ üì© garbage.collect () üë®üèª‚Äçüåæ ü•´ üïç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para ejecutar JavaScript, el navegador necesita un poco de memoria, pero en alg√∫n lugar necesita almacenar objetos, primitivas, funciones que se crean...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>garbage.collect ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433318/"> Para ejecutar JavaScript, el navegador necesita un poco de memoria, pero en alg√∫n lugar necesita almacenar objetos, primitivas, funciones que se crean para todas las acciones del usuario.  Por lo tanto, el navegador primero asigna la cantidad requerida de RAM, y cuando no se usan objetos, lo limpia de forma independiente. <br><br>  En teor√≠a, suena bien.  En la pr√°ctica, el usuario abre 20 pesta√±as de YouTube, redes sociales, lee algo, funciona, el navegador consume memoria, como Hummer H2 - gasolina.  El recolector de basura, como este monstruo con un trapeador, recorre toda la memoria y agrega confusi√≥n, todo se ralentiza y se bloquea. <br><br><img src="https://habrastorage.org/webt/uc/vx/ke/ucvxke3xzwiqngna7opkqwllmq4.jpeg"><br><br>  Para evitar que tales situaciones sucedan y que el rendimiento de nuestros sitios y aplicaciones no sufra, el desarrollador front-end debe saber c√≥mo la basura afecta a las aplicaciones, c√≥mo el navegador las recoge y optimiza el manejo de la memoria, y c√≥mo todo difiere de la dura realidad.  Este es solo el informe de <strong>Andrei Roenko ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">flapenguin</a> )</strong> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Frontend Conf 2018</a> . <br><br>  Usamos el recolector de basura (no en casa, en el desarrollo front-end) todos los d√≠as, pero realmente no pensamos en lo que es, lo que nos cuesta y las oportunidades y limitaciones que tiene. <br><br><blockquote>  Si la recolecci√≥n de basura realmente funcionara en JavaScript, la mayor√≠a de los m√≥dulos npm se eliminar√≠an inmediatamente despu√©s de la instalaci√≥n. <br></blockquote><br>  Pero aunque esto no sea as√≠, hablaremos de lo que es, de ensamblar objetos innecesarios. <br><br><a name="habracut"></a><iframe width="560" height="315" src="https://www.youtube.com/embed/tDbRVZqwxn4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre el orador</strong> : <strong>Andrei Roenko ha</strong> estado desarrollando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yandex.Map API</a> , ha estado en la interfaz durante seis a√±os, le encanta crear sus propias altas abstracciones y descender de otras personas al suelo. <br><br><h2>  ¬øPor qu√© necesitas recolecci√≥n de basura? <br></h2><br>  Considere el ejemplo de Yandex.Maps.  Yandex.Maps es un servicio enorme y complejo que utiliza muchos JS y casi todas las API de navegador existentes, excepto las multimedia, y el tiempo de sesi√≥n promedio es de 5-10 minutos.  La abundancia de JavaScript crea muchos objetos.  Arrastrar el mapa, agregar organizaciones, resultados de b√∫squeda y muchos otros eventos que ocurren cada segundo crea una avalancha de objetos.  Agregue a esto Reaccionar y los objetos se vuelven a√∫n m√°s. <br><br>  Sin embargo, los objetos JS ocupan solo 30‚Äì40 Mb en el mapa.  Para largas sesiones de Yandex.Maps y la asignaci√≥n constante de nuevos objetos, esto no es suficiente. <br><br><blockquote>  La raz√≥n del peque√±o volumen de objetos es que el recolector de basura los recopila con √©xito y la memoria se reutiliza. <br></blockquote><br>  Hoy hablaremos sobre la recolecci√≥n de basura desde cuatro lados: <br><br><ul><li>  <strong>Teor√≠a</strong>  Comencemos con ella para hablar el mismo idioma y entenderse. </li><li>  <strong>La dura realidad.</strong>  En √∫ltima instancia, la computadora ejecuta c√≥digo de m√°quina en el que no hay todas las abstracciones que nos son familiares.  Tratemos de descubrir c√≥mo funciona la recolecci√≥n de basura en un nivel bajo. </li><li>  <strong>Navegador de la realidad.</strong>  Veamos c√≥mo se implementa la recolecci√≥n de basura en los motores y navegadores modernos, y qu√© conclusiones podemos sacar de esto. </li><li>  <strong>Vida cotidiana</strong> : hablemos de la aplicaci√≥n pr√°ctica del conocimiento adquirido en la vida cotidiana. </li></ul><br>  Todas las declaraciones est√°n respaldadas con ejemplos de c√≥mo y c√≥mo no hacerlo. <br><br><h2>  ¬øPor qu√© saber todo esto? </h2><br>  La recolecci√≥n de basura es algo invisible para nosotros, sin embargo, sabiendo c√≥mo se organiza, usted: <br><br><ul><li>  Tenga una idea de la herramienta que est√° utilizando, que es √∫til en su trabajo. </li><li>  Comprenda d√≥nde optimizar las aplicaciones ya lanzadas y c√≥mo dise√±ar las futuras para que funcionen mejor y m√°s r√°pido. </li><li>  Sepa c√≥mo no cometer errores comunes y dejar de malgastar recursos en "optimizaciones" in√∫tiles y da√±inas. </li></ul><br><h2>  Teor√≠a <br></h2><br>  Joel Spolsky dijo una vez: <br><br><blockquote>  Todas las abstracciones no triviales tienen fugas. <br></blockquote><br>  El recolector de basura es una gran abstracci√≥n no trivial que se parchea desde todos los lados.  Afortunadamente, fluye muy raramente. <br><br>  Comencemos con una teor√≠a, pero sin definiciones aburridas.  Analicemos el trabajo del recopilador usando un c√≥digo simple como ejemplo: <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.Foo = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span> }; } work(name) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = <span class="hljs-string"><span class="hljs-string">'z'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xy, z); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } };</code> </pre> <br><ul><li>  Hay una <strong>clase</strong> en el c√≥digo. </li><li>  La clase tiene un <strong>constructor</strong> . </li><li>  <strong>El m√©todo de trabajo</strong> devuelve una funci√≥n relacionada. </li><li>  Dentro de la funci√≥n, se utilizan <strong>esta</strong> y un par de variables del cierre. </li></ul><br>  Veamos c√≥mo se comportar√° este c√≥digo si lo ejecutamos de esta manera: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-comment"><span class="hljs-comment">//C   window.worker = foo.work('Brendan Eich'); //     bind,   window.foo = null; //   window.Foo = null; //  ,   -  window.worker(); window.worker = null; //   ,  </span></span></code> </pre><br>  Analicemos el c√≥digo y sus componentes con m√°s detalle y comencemos con la clase. <br><br><h3>  Declaraci√≥n de clase <br></h3><br><img src="https://habrastorage.org/webt/nd/yq/ie/ndyqietonv9ggcg45mvfmwnsyae.png"><br><br>  Podemos suponer que las clases en ECMAScript 2015 son solo az√∫car sint√°ctica para funciones.  Todas las funciones tienen: <br><br><ul><li>  <strong>Funci√≥n. [[Prototipo]]</strong> es el prototipo real de la funci√≥n. </li><li>  <strong>Foo.prototype</strong> es un prototipo para objetos reci√©n creados. </li><li>  Foo.prototype tiene un enlace de regreso al constructor a trav√©s del campo del constructor.  Este es un objeto, por lo que hereda de <strong>Object.prototype</strong> . </li><li>  <strong>El m√©todo de trabajo es una</strong> funci√≥n separada para la que hay un enlace, similar al constructor, porque ambas son solo funciones.  Tambi√©n puede establecer un prototipo y llamarlo a trav√©s de nuevo, pero rara vez alguien usa este comportamiento. </li></ul><br>  Los prototipos ocupan mucho espacio en el circuito, as√≠ que recordemos que lo son, pero los eliminar√°n por simplicidad. <br><br><h3>  Crear un objeto de clase <br></h3><br><img src="https://habrastorage.org/webt/f_/ea/5u/f_ea5uuq01wygmqkdfbrj4a8oja.png"><br><br><ul><li>  Ponemos nuestra clase en la ventana, porque las clases no llegan all√≠ por defecto. </li><li>  Crea un objeto de clase. </li><li>  La creaci√≥n de un objeto expone autom√°ticamente el prototipo del objeto de clase en Foo.prototype.  Por lo tanto, cuando intente llamar al m√©todo de trabajo en un objeto, sabr√° qu√© tipo de trabajo es. </li><li>  Nuestro constructor crea el campo <em>x</em> en el objeto a partir del objeto con la cadena. </li></ul><br>  Esto es lo que sucedi√≥: <br><br><img src="https://habrastorage.org/webt/nb/xx/d1/nbxxd11pg7bmutfnn4bqh3_ooxs.png"><br><br>  El m√©todo devuelve una funci√≥n enlazada: este es un objeto "m√°gico" tan especial en JS, que consiste en un enlace esto y una funci√≥n que debe llamarse.  La funci√≥n relacionada tambi√©n tiene un prototipo y otro prototipo, pero estamos interesados ‚Äã‚Äãen el cierre.  Por especificaci√≥n, el cierre se almacena en el entorno.  Lo m√°s probable es que est√© m√°s familiarizado con la palabra √Åmbito, pero <strong>en las especificaciones el campo se llama Medio ambiente</strong> . <br><br><img src="https://habrastorage.org/webt/dv/zu/rn/dvzurne2uerkhr0vqxeahna5cum.png"><br><br>  The Environment almacena una referencia a LexicalEnvironment.  Este es un objeto complejo, m√°s complicado que en una diapositiva; almacena enlaces a todo lo que se puede acceder desde una funci√≥n.  Por ejemplo, ventana, Foo, nombre y z.  Tambi√©n almacena enlaces incluso a lo que no est√° utilizando expl√≠citamente.  Por ejemplo, puede usar eval y accidentalmente usar objetos no utilizados, pero JS no debe romperse. <br><br>  Entonces, construimos todos los objetos y ahora destruiremos todo. <br><br><h3>  Eliminar el enlace al objeto <br></h3><br>  Comencemos eliminando el enlace al objeto, este enlace en el diagrama est√° resaltado en rojo. <br><br><img src="https://habrastorage.org/webt/zp/g_/mf/zpg_mfnx7pgoc1q46ruedg5oeve.png"><br><br>  Eliminamos y no sucede nada, porque desde la <strong>ventana</strong> hasta el objeto hay una ruta a trav√©s de la <strong>funci√≥n de</strong> funci√≥n <strong>enlazada</strong> . <br><br><img src="https://habrastorage.org/webt/_w/lv/v6/_wlvv6dpon2qnjgaukobadopmas.png"><br><br>  Esto nos empuja a un error t√≠pico. <br><br><h3>  Error com√∫n: suscripci√≥n olvidada <br></h3><br><pre> <code class="javascript hljs">externalElement.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shouldDoSomethingOnClick) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething(); } })</code> </pre><br>  Ocurre cuando se suscribe: usando <strong>esto,</strong> expl√≠citamente a trav√©s de las funciones de enlace o flecha;  usa algo en el cierre.  Luego olvida darse de baja, y la vida √∫til de su objeto o lo que est√° en el circuito es igual a la vida √∫til de una suscripci√≥n.  Por ejemplo, si este es un elemento DOM que no toca, entonces es muy probable que sea el tiempo hasta el final de la vida de la p√°gina. <br><br>  Para resolver estos problemas: <br><br><ul><li>  Darse de baja </li><li>  Piense en la duraci√≥n de la suscripci√≥n y en qui√©n es el propietario. </li><li>  Si por alguna raz√≥n no puede darse de baja, anule los enlaces (lo que sea = nulo) o limpie todos los campos del objeto.  Si su objeto tiene fugas, ser√° peque√±o y no es una pena. </li><li>  Use WeakMap, tal vez esto ayude en algunas situaciones. </li></ul><br><h3>  Eliminar la referencia de clase <br></h3><br>  Siga adelante e intente eliminar el enlace rojo resaltado en la clase. <br><br><img src="https://habrastorage.org/webt/px/sm/yf/pxsmyfvo0utc5d1wh3rfrqcpmlc.png"><br><br>  Eliminamos el enlace y nada cambia para nosotros.  La raz√≥n es que la clase es accesible a trav√©s de BoundThis, en el que hay un enlace al prototipo, y en el prototipo hay un enlace de regreso al constructor. <br><br><h3>  <s>Error</s> t√≠pico de trabajo in√∫til <br></h3><br>  ¬øPor qu√© se necesitan todas estas demostraciones?  Porque hay una otra cara del problema cuando la gente toma el consejo de anular los enlaces demasiado literalmente y anular todo en general. <br><br><pre> <code class="javascript hljs">destroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._x = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._y = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  10 this._foobar = null }</span></span></code> </pre><br>  Este es un trabajo bastante in√∫til.  Si el objeto consta solo de referencias a otros objetos y no hay recursos all√≠, entonces no se necesita destroy ().  Es suficiente perder la referencia al objeto, y √©l morir√° solo. <br><br>  No hay un consejo universal.  Cuando sea necesario, anule, y cuando no, no anule.  La reducci√≥n a cero no es un error, sino simplemente un trabajo in√∫til. <br><br>  Adelante  Llame al m√©todo de funci√≥n enlazada y eliminar√° el enlace de [objeto Foo] a [objeto Objeto].  Esto conducir√° al hecho de que los objetos que se encuentran separados en un rect√°ngulo azul aparecen en el diagrama. <br><br><img src="https://habrastorage.org/webt/zl/ep/xc/zlepxcvklqpricdvth4gxnjp2ny.png"><br><br>  Estos objetos son basura JS.  El va genial.  Sin embargo, hay basura que no se puede recoger. <br><br><h3>  Basura que no va a <br></h3><br>  En muchas API de navegador, puede crear y destruir un objeto.  Si el objeto no se destruye, entonces ning√∫n recolector puede ensamblarlo. <br><br>  Objetos con funciones de creaci√≥n / eliminaci√≥n de pares: <br><br><ul><li>  createObjectURL (), revokeObjectURL (); </li><li>  WebGL: crear / eliminar Programa / Shader / Buffer / Texture / etc; </li><li>  ImageBitmap.close (); </li><li>  indexDb.close (). </li></ul><br>  Por ejemplo, si olvida eliminar ObjectURL de un video de 200 MB, entonces en la memoria estos 200 MB permanecer√°n hasta el final de la vida de la p√°gina e incluso m√°s, porque hay intercambio de datos entre las pesta√±as.  Del mismo modo en WebGL, indexDb y otras API de navegador con recursos similares. <br><br>  Afortunadamente, en nuestro ejemplo, el rect√°ngulo azul contiene solo objetos JavaScript, por lo que esto es solo basura que se puede eliminar. <br><br>  El siguiente paso es borrar el √∫ltimo enlace de izquierda a derecha.  Esta es una referencia al m√©todo que recibimos, una funci√≥n relacionada. <br><br><img src="https://habrastorage.org/webt/5g/k5/h9/5gk5h96gg6zpw4bi64mq1guopom.png"><br><br>  Despu√©s de su eliminaci√≥n, ¬øno tendremos enlaces a izquierda y derecha?  De hecho, todav√≠a hay enlaces desde el cierre. <br><br><img src="https://habrastorage.org/webt/hy/s0/vy/hys0vysevtslyjbht0gjngdaqaq.png"><br><br>  Es importante que no haya enlaces de izquierda a derecha, por lo tanto, todo excepto la ventana es basura y morir√°. <br><br>  <strong>Nota importante</strong> : hay referencias circulares en la basura, es decir, objetos que se refieren entre s√≠.  La presencia de dichos enlaces no afecta nada, porque el recolector de basura no recolecta objetos individuales, sino toda la basura. <br><br><img src="https://habrastorage.org/webt/hl/qq/4f/hlqq4fn3nlubl4aefqycqyi4v8u.png"><br><br>  Observamos los ejemplos y ahora, en un nivel intuitivo, entendemos qu√© es la basura, pero demos una definici√≥n completa del concepto. <br><br><blockquote>  La basura es todo lo que no es un objeto vivo. <br></blockquote><br>  Todo se hizo muy claro.  Pero, ¬øqu√© es un objeto vivo? <br><br>  <strong>Un objeto vivo es un objeto al que se puede llegar mediante enlaces desde el objeto ra√≠z.</strong> <br><br>  Aparecen dos conceptos nuevos: "seguir enlaces" y "objeto ra√≠z".  Un objeto ra√≠z que ya conocemos es window, as√≠ que comencemos con los enlaces. <br><br><h3>  ¬øQu√© significa seguir los enlaces? <br></h3><br>  Hay muchos objetos que est√°n relacionados entre s√≠ y se refieren entre s√≠.  Agitaremos a lo largo de ellos, comenzando con el objeto ra√≠z. <br><br>  Inicializamos el primer paso, y luego procedemos de acuerdo con el siguiente algoritmo: digamos que todo en la cresta de la ola son objetos vivos y vemos a qu√© se refieren. <br><br><img src="https://habrastorage.org/webt/qd/vc/gv/qdvcgvf0tjyk-i85yx9_yzivgs8.png"><br><br>  Inicializamos el primer paso.  Luego, actuaremos de acuerdo con el siguiente algoritmo: digamos que todo lo amarillo en la cresta de la ola son objetos vivos y veamos a qu√© se refieren. <br><br>  A lo que se refieren, haremos una nueva cresta de la ola: <br><br><img src="https://habrastorage.org/webt/k-/5p/bz/k-5pbzevhodbxxsj1ktayvgio34.png"><br><br>  Terminado y comenzar de nuevo: <br><br><ul><li>  Estamos reviviendo </li><li>  Vemos a qu√© se refieren. </li><li>  Crea una nueva cresta de ola, anima objetos. </li><li>  Vemos a qu√© se refieren. </li></ul><br><img src="https://habrastorage.org/webt/nd/bb/8d/ndbb8dwnwadhclwfucgkozu42ea.png"><br><br>  Al notar que una flecha apunta a un objeto ya vivo, simplemente no hacemos nada.  Adem√°s, seg√∫n el algoritmo, hasta que se agoten los objetos a recorrer.  Luego decimos que encontramos todos los objetos vivos, y todo lo dem√°s es basura. <br><br><img src="https://habrastorage.org/webt/pw/ms/6z/pwms6zisv2hasovzir04jtjna0k.png"><br><br>  Este proceso se llama <strong>marcado</strong> . <br><br><h3>  ¬øQu√© significa el objeto ra√≠z? <br></h3><br><br><ul><li>  Ventana </li><li>  Casi todas las API del navegador. </li><li>  Todos lo prometen. </li><li>  Todo lo que se pone en Microtask y Macrotask. </li><li>  Observadores de mutaciones, RAF, devoluciones de llamadas inactivas.  Todo lo que se puede alcanzar de lo que se encuentra en la RAF no se puede eliminar, porque si elimina el objeto que se utiliza en la RAF, entonces probablemente algo salga mal. </li></ul><br>  El ensamblaje puede ocurrir en cualquier momento.  Cada vez que aparecen llaves o funciones, se crea un nuevo objeto.  Puede que no haya suficiente memoria, y el recolector ir√° a buscar gratis: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, z</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = {}; <span class="hljs-comment"><span class="hljs-comment">// nomem, run gc D: // ‚Ä¶ } while (whatever()) bar(); }</span></span></code> </pre><br>  En este caso, los objetos ra√≠z ser√°n todo en la pila de llamadas.  Si, por ejemplo, se detiene en la l√≠nea con X y elimina a lo que se refiere Y, entonces su aplicaci√≥n se bloquear√°.  JS no nos permite tales frivolidades, por lo que no puede eliminar un objeto de Y. <br><br>  Si la parte anterior parec√≠a complicada, entonces ser√° a√∫n m√°s dif√≠cil. <br><br><h2>  Dura realidad <br></h2><br>  Hablemos del mundo de las m√°quinas en el que tratamos con hierro, con medios f√≠sicos. <br><br>  La memoria es una gran matriz en la que solo se encuentran los n√∫meros, por ejemplo: nueva Uint32Array (16 * 2 ** 30). <br><br>  Vamos a crear objetos en la memoria y agregarlos de izquierda a derecha.  Creamos uno, segundo, tercero, todos son de diferentes tama√±os.  Ponemos enlaces en el camino. <br><img src="https://habrastorage.org/webt/rg/ly/oy/rglyoyk5kjjz0re9ktp1m7r0dtg.png"><br><br>  En el s√©ptimo objeto, el lugar ha terminado, porque tenemos 2 casillas libres, pero necesitamos 5. <br><br>  ¬øQu√© se puede hacer aqu√≠?  La primera opci√≥n es bloquearse.  En el patio en 2018, todos tienen las √∫ltimas MacBooks y 16 GB de RAM.  ¬°No hay situaciones en las que no hay memoria! <br><br>  Sin embargo, dejar que las cosas sigan su curso es una mala idea, porque en la web esto lleva a una pantalla similar: <br><br><img src="https://habrastorage.org/webt/un/lw/gn/unlwgnwcw1-7p5xunjhvo2hfwzg.png"><br><br>  Este no es el comportamiento que queremos del programa, pero en general es v√°lido.  Hay una categor√≠a de coleccionistas llamada <strong>No-op</strong> . <br><br><h3>  Coleccionista sin operaciones <br></h3><br>  Pros: <br><br><ul><li>  El coleccionista es muy simple. </li><li>  Simplemente no hay recolecci√≥n de basura. </li><li>  No es necesario escribir ni pensar en la memoria. </li></ul><br>  Contras: <br><br><ul><li>  Todo cae para que nunca vuelva a subir. </li></ul><br>  Para el frontend, el recopilador no operativo es irrelevante, pero se usa en el backend.  Por ejemplo, al tener varios servidores detr√°s de los equilibradores, la aplicaci√≥n recibe 32 GB de RAM y luego se elimina por completo.  Es m√°s simple y el rendimiento solo se mejora simplemente reiniciando cuando la memoria se vuelve baja. <br><br>  En la web es imposible y hay que limpiarlo. <br><br><h3>  Buscar y eliminar basura <br></h3><br>  Comenzamos a limpiar con basura.  Ya sabemos c√≥mo hacerlo.  Basura: objetos C y F en el esquema anterior, porque no puede alcanzarlos a lo largo de las flechas desde el objeto ra√≠z. <br><br>  Tomamos esta basura, se la damos al amante de la basura y ya est√°. <br><br><img src="https://habrastorage.org/webt/g8/1l/s1/g81ls1ji6sco7buvbftj6xgr714.png"><br><br>  Despu√©s de la limpieza, el problema no se resuelve, ya que los agujeros permanecen en la memoria.  Tenga en cuenta que hay 7 casillas libres, pero 5 de ellas a√∫n no podemos asignarlas.  La fragmentaci√≥n ocurri√≥ y la asamblea termin√≥.  Tal algoritmo con agujeros se llama <strong>Mark y Sweep</strong> . <br><br><h3>  Marcar y barrer <br></h3><br>  Pros: <br><br><ul><li>  Un algoritmo muy simple.  Uno de los primeros que aprender√° si comienza a aprender sobre el recolector de basura. </li><li>  Funciona en proporci√≥n a la cantidad de basura, pero solo hace frente cuando hay poca basura. </li><li>  Si solo tienes objetos vivos, entonces √©l no pierde el tiempo y simplemente no hace nada. </li></ul><br>  Contras: <br><br><ul><li>  Se requiere una l√≥gica compleja para buscar espacio libre, porque cuando hay muchos agujeros en la memoria, debe probar un objeto en cada uno para comprender si encaja o no. </li><li>  Fragmentos de memoria.  Puede ocurrir una situaci√≥n en la que con 200 MB libres la memoria se divide en partes peque√±as y, como en el ejemplo anterior, no hay una parte s√≥lida de memoria para el objeto. </li></ul><br>  Estamos buscando otras ideas.  Si miras la imagen y piensas, lo primero es cambiar todo a la izquierda.  Luego, a la derecha, habr√° una pieza grande y libre, en la que nuestro objeto se ajustar√° con calma. <br><br>  Existe dicho algoritmo y se llama <strong>Mark y Compact</strong> . <br><br><h3>  Marca y compacto <br></h3><br>  Pros: <br><br><ul><li>  Desfragmentar la memoria. </li><li>  Funciona en proporci√≥n al n√∫mero de objetos vivos, lo que significa que puede usarse cuando pr√°cticamente no hay basura. </li></ul><br>  Contras: <br><br><ul><li>  Dif√≠cil en el trabajo y la implementaci√≥n. </li><li>  Mueve objetos.  Movimos el objeto, lo copiamos, ahora est√° en un lugar diferente y toda la operaci√≥n es bastante costosa. </li><li>  Requiere 2-3 pases en la memoria, dependiendo de la implementaci√≥n: el algoritmo es lento. </li></ul><br>  Aqu√≠ llegamos a otra idea. <br><br><h3>  La recolecci√≥n de basura no es gratuita. <br></h3><br>  En las API de alto rendimiento, como WebGL, WebAudio y WebGPU, que todav√≠a est√° en desarrollo, los objetos se crean y eliminan en fases separadas.  Estas especificaciones est√°n escritas para que la recolecci√≥n de basura no est√© en proceso.  Adem√°s, ni siquiera hay Promesa all√≠, sino pull (): solo pregunta a cada cuadro: "¬øPas√≥ algo o no?". <br><br><h3>  Semispace aka Lisp 2 <br></h3><br>  Hay otro coleccionista del que quiero hablar.  ¬øQu√© sucede si no libera memoria, sino que copia todos los objetos vivos en otro lugar? <br><br>  Intentemos copiar el objeto ra√≠z "tal cual", que se refiere a alguna parte. <br><br><img src="https://habrastorage.org/webt/oe/ck/uc/oeckucvn6dpbz9hgbg3ykkzmylm.png"><br><br>  Y luego todos los dem√°s. <br><br><img src="https://habrastorage.org/webt/rf/ds/9x/rfds9xc3v1tp6pvlpokawj8pkn0.png"><br><br>  No hay escombros ni agujeros en la memoria de arriba.  Todo parece estar bien, pero surgen dos problemas: <br><br><ul><li>  Objetos duplicados: tenemos dos objetos verdes y dos azules.  ¬øCu√°l usar? </li><li>  Los enlaces de objetos nuevos conducen a objetos antiguos y no entre s√≠. </li></ul><br>  Con los enlaces, todo se resuelve con la ayuda de una "magia" algor√≠tmica especial, y podemos hacer frente a la duplicaci√≥n de objetos eliminando todo lo siguiente. <br><img src="https://habrastorage.org/webt/cq/sr/ur/cqsrurkhqp_b01qsxjhzndggryg.png"><br><br>  Como resultado, tenemos espacio libre y solo objetos vivos en el orden normal anterior.  Este algoritmo se llama <strong>Semispace</strong> , <strong>Lisp 2,</strong> o simplemente el "recopilador de copias". <br><br>  Pros: <br><br><ul><li>  Desfragmentar la memoria. </li><li>  Simple </li><li>  Se puede combinar con una fase de derivaci√≥n. </li><li>  Funciona en proporci√≥n al n√∫mero de objetos vivos a lo largo del tiempo. </li><li>  Funciona bien cuando hay mucha basura.  Si tiene 2 GB de memoria y 3 objetos, omitir√° solo 3 objetos y los 2 GB restantes parecen haberse ido. </li></ul><br>  Contras: <br><br><ul><li>  Doble consumo de memoria.  Utiliza la memoria 2 veces m√°s de lo necesario. </li><li>  Mover objetos tampoco es una operaci√≥n muy barata. </li></ul><br><blockquote>  Nota: los recolectores de basura pueden mover objetos. <br></blockquote><br>  En la web, esto es irrelevante, pero en Node.js incluso mucho.  Si escribe la extensi√≥n en C ++, entonces el lenguaje no sabe todo esto, por lo que hay enlaces dobles llamados manejador y se ven as√≠: v8 :: Local &lt;v8 :: String&gt;. <br><br>  Por lo tanto, si va a escribir complementos para Node.js, la informaci√≥n ser√° √∫til. <br><br>  Resumimos los diferentes algoritmos con sus pros y contras en la tabla.  Tambi√©n tiene un algoritmo Eden, pero sobre eso m√°s tarde. <br><br><img src="https://habrastorage.org/webt/s9/zm/ec/s9zmecoite95yruxuvtafbzaimy.png"><br><br>  Realmente quiero un algoritmo sin contras, pero esto no es as√≠.  Por lo tanto, tomamos lo mejor de todos los mundos: utilizamos varios algoritmos al mismo tiempo.  En una pieza de memoria, recolectamos basura con un algoritmo y en otra con otro algoritmo. <br><br>  ¬øC√≥mo entender la efectividad del algoritmo en tal situaci√≥n? <br><br>  Podemos utilizar el conocimiento de los maridos inteligentes de los a√±os 60 que observaron todos los programas y se dieron cuenta: <br><br><blockquote>  Hip√≥tesis generacional d√©bil: la mayor√≠a de los objetos mueren j√≥venes. <br></blockquote><br>  Estos quer√≠an decir que todos los programas solo hacen que produzcan basura.  En un intento de usar el conocimiento, llegaremos a lo que se llama "ensamblaje por generaciones". <br><br><h3>  Asamblea generacional <br></h3><br>  Creamos dos memorias que no est√°n conectadas de ninguna manera: a la izquierda est√° Eden, y a la derecha est√°n Mark y Sweep lentos.  En el Ed√©n creamos objetos.  Muchos objetos <br><br><img src="https://habrastorage.org/webt/_y/rt/tc/_yrttco6brh1zyz4sqkiuk4wrjo.png"><br><br>  Cuando Eden dice que est√° lleno, comenzamos a recolectar basura.  Encontramos objetos vivos y los copiamos a otro coleccionista. <br><br><img src="https://habrastorage.org/webt/38/si/a5/38sia5sg1nhfx6elimcuitdpqok.png"><br><br>  El propio Ed√©n est√° completamente limpio, y podemos agregarle m√°s objetos. <br><br><img src="https://habrastorage.org/webt/pp/qc/3_/ppqc3_uk1okblort71qjndj7ije.png"><br><br>  Bas√°ndonos en la hip√≥tesis generacional, decidimos que los objetos c, g, i probablemente vivir√°n mucho tiempo, y podemos verificarlos con menos frecuencia.  Conociendo esta hip√≥tesis, puede escribir programas que enga√±en al coleccionista.  Esto se puede hacer, pero no te aconsejo, porque casi siempre dar√° lugar a efectos no deseados.  Si crea basura de larga duraci√≥n, el recolector comenzar√° a creer que no es necesario recolectarla. <br><br>  Un ejemplo cl√°sico de trampa es LRU-cache.  Un objeto permanece en el cach√© durante mucho tiempo, el recolector lo mira y cree que a√∫n no lo recoger√°, porque el objeto vivir√° durante mucho tiempo.  Luego, un nuevo objeto ingresa al cach√©, y uno grande y viejo es expulsado de √©l y ya no es posible ensamblar inmediatamente este gran objeto. <br><br>  C√≥mo recoger ahora lo sabemos.  Hable sobre cu√°ndo recolectar. <br><br><h3>  Cuando coleccionar? <br></h3><br>  La opci√≥n m√°s f√°cil es cuando <strong>simplemente detenemos todo</strong> , comenzamos la compilaci√≥n y luego comenzamos a trabajar de nuevo en JS. <br><br><img src="https://habrastorage.org/webt/e-/1n/od/e-1nodx10w_v6q7x5w7xi9xdfvk.png"><br><br>  En las computadoras modernas, m√°s de un hilo de ejecuci√≥n.  En la web, esto es familiar por parte de Web Workers.  ¬øPor qu√© no tomar y <strong>paralelizar el proceso de ensamblaje</strong> ?  Realizar varias operaciones peque√±as al mismo tiempo ser√° m√°s r√°pido que uno grande. <br><br><img src="https://habrastorage.org/webt/y6/yw/jh/y6ywjhxlis6qhu7kk5cumaruayu.png"><br><br>  Otra idea es hacer una instant√°nea del estado actual y <strong>construir en paralelo con JS</strong> . <br><br><img src="https://habrastorage.org/webt/lm/fd/3w/lmfd3w2kiyhtxlwvp1wtlges6ia.png"><br><br><blockquote>  Si esto le interesa, le aconsejo que lea: <br><br><ul><li>  El √∫nico y principal libro de montaje, Garbage Collection Handbook. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a> como un recurso universal. </li><li>  Sitio web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">memorymanagement.org.</a> </li><li>  Informes y art√≠culos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alexander Shepelev</a> .  Habla de Java, pero en t√©rminos de basura, Java y V8 funcionan m√°s o menos igual. </li></ul></blockquote><br><h2>  Realidad del navegador <br></h2><br>  Pasemos a c√≥mo los navegadores usan todo lo que hemos hablado. <br><br><h3>  Motores de IoT <br></h3><br>  Comencemos no con los navegadores, sino con los motores de Internet de las cosas: JerryScript y Duktape.  Utilizan los algoritmos Mark'n'sweep y Stop the world. <br><br>  Los motores IoT funcionan en microcontroladores, lo que significa que el lenguaje es lento;  segundo cuelga;  fragmentaci√≥n  y todo esto para una tetera con iluminaci√≥n :) <br><br>  Si escribes Internet of Things en JavaScript, ¬øcu√©ntanoslo en los comentarios?  hay algun punto <br><br>  Dejaremos los motores de IoT solos, estamos interesados ‚Äã‚Äãen: <br><br><ul><li>  V8. </li><li>  SpiderMonkey  De hecho, √©l no tiene un logotipo.  Logotipo casero :) </li><li>  JavaScriptCore utilizado por WebKit. </li><li>  ChakraCore que se usa en Edge. </li></ul><br><img src="https://habrastorage.org/webt/vw/0q/nj/vw0qnjkmktvnd2z0_dhrvkw4y_u.png"><br><br>  Todos los motores son aproximadamente iguales, por lo que hablaremos de V8, como el m√°s famoso. <br><br><h3>  V8 <br></h3><br><ul><li>  Casi todo el JavaScript del lado del servidor, porque es Node.js. </li><li>  Casi el 80% de JavaScript del lado del cliente. </li><li>  Los desarrolladores m√°s sociables, hay mucha informaci√≥n y buenos c√≥digos fuente que son m√°s f√°ciles de leer. </li></ul><br>  El V8 utiliza ensamblaje generacional. <br><img src="https://habrastorage.org/webt/u-/-7/r4/u--7r4ggek0kxgpscwhtzn8grfe.png"><br><br>  La √∫nica diferencia es que sol√≠amos tener dos coleccionistas, y ahora tres: <br><br><ul><li>  Se crea un objeto en el Ed√©n. </li><li>  En alg√∫n momento en el Ed√©n, hay demasiada basura y el objeto se transfiere al Semispace. </li><li>  El objeto es joven y cuando el recolector se da cuenta de que es demasiado viejo y aburrido, lo arroja a Mark and Sweep, en el que la recolecci√≥n de basura es extremadamente rara. </li></ul><br>  Puede ver claramente c√≥mo se ve en la <strong>traza de memoria</strong> . <br><br><img src="https://habrastorage.org/webt/c7/s1/av/c7s1avnfboc9c57khyjw5xqjybm.png"><br><br>  Se notan varias olas grandes con olas peque√±as.  Los peque√±os son conjuntos menores, y los grandes son los principales. <br><br>  El significado de nuestra existencia, de acuerdo con la hip√≥tesis generacional, es generar basura, por lo que el siguiente error es el miedo a crear basura. <br><br><blockquote>  La basura se puede crear cuando realmente es basura.   ,         ,     ,    . <br></blockquote><br><h4>  mark <br></h4><br>    V8     . <br><img src="https://habrastorage.org/webt/40/dg/j5/40dgj5iiquv7dsag0mndget4s30.png"><br><br>     Stop the world,        ,       JS,        . <br><br><h4>     ? <br></h4><br>  1  3%,    . <br><br>  3% = 1/33     GameDev.  GameDev 3%  1 ,    .   GameDev     . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pool = [<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bullet(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bullet(), <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFromPool</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bullet = pool.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> !x.inUse); bullet.isUse = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bullet; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnToPool</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bullet</span></span></span><span class="hljs-function">) </span></span>{ bullet.inUse = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Frame const bullet = getFromPool(); // ... returnToPool(bullet);</span></span></code> </pre><br>     , , 10 000        . <br><br>    ‚Äî    .          ,         .      ,     . <br><br><h3>   : Chromium <br></h3><br>      , ,  ,   Chromium. <br><br><pre> <code class="javascript hljs">&gt; performance.memory MemoryInfo { <span class="hljs-attr"><span class="hljs-attr">totalJSHeapSize</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span>, <span class="hljs-attr"><span class="hljs-attr">usedJSHeapSize</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span>, <span class="hljs-attr"><span class="hljs-attr">jsHeapSizeLimit</span></span>: <span class="hljs-number"><span class="hljs-number">2330000000</span></span> }</code> </pre><br>  Chromium  <strong>performance.memory</strong>   ,       ,      Chromium  . <br><br> <strong>:</strong> Chromium   2    JavaScript. <br><br>  ,           . <br><br><h3>   : Node <br></h3><br>  Node.js    <strong>process.memoryUsage</strong> ,      . <br><br><pre> <code class="javascript hljs">&gt; process.memoryUsage() { <span class="hljs-attr"><span class="hljs-attr">rss</span></span>: <span class="hljs-number"><span class="hljs-number">22839296</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapTotal</span></span>: <span class="hljs-number"><span class="hljs-number">10207232</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapUsed</span></span>: <span class="hljs-number"><span class="hljs-number">5967968</span></span>, <span class="hljs-attr"><span class="hljs-attr">external</span></span>: <span class="hljs-number"><span class="hljs-number">12829</span></span> }</code> </pre><br> ,  -         ,    .          .     . <br><br><h3>  <br></h3><br> <strong> </strong> ‚Äî    ,         .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proposal</a> ,      . <br><br>    Node.js,    c <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">node-weak</a>   , ,  . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cached = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakRef(myJson); <span class="hljs-comment"><span class="hljs-comment">// 2   let json = cached.deref(); if (!json) { json = await fetchAgain(); }</span></span></code> </pre><br>     , ,    -  JS.         ,      ,      ,    . <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  WebAssembly</a> ,    .   ,              ,     ,      . <br><br><blockquote>     :  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">v8.dev</a>    JS. <br></blockquote><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/v8/v8/tree/7.0.237/src/heap</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/servo/mozjs/blob/master/mozjs/js/src/gc/</a> </li><li> <a href="">github.com/WebKit/webkit/.../JavaScriptCore/heap/MarkedSpace.cpp</a> </li><li> <a href="">github.com/Microsoft/ChakraCore/.../HeapAllocator.cpp</a> </li><li> <a href="">github.com/svaarala/duktape/.../duk_heap_markandsweep.c</a> </li><li> <a href="">github.com/jerryscript-project/jerryscript/.../ecma-gc.c</a> </li></ul><br>        ? <br><br><h2>  <br></h2><br>    DevTools    : <strong>Performance</strong>  <strong>Memory</strong> .     Chromium,     ,   Firefox  Safari  . <br><br><h3>  Performance <br></h3><br>   Trace,   ¬´Memory¬ª    Performance,    JS     . <br><br><img src="https://habrastorage.org/webt/vm/8b/hn/vm8bhnnurkvza6cquinxa61ema8.png"><br><br>     JS      V8     ,   .     .  ,  GC    30   1200  JS,   1/40. <br><br><h3>  Memory <br></h3><br>          . <br><br><img src="https://habrastorage.org/webt/1i/cl/br/1iclbrk21tcz3lmj472ukb5jwqc.png"><br><br>    . <br><br><img src="https://habrastorage.org/webt/fy/6i/0v/fy6i0v3tu6yq2onfzuz7ma7moks.png"><br><br>     ,           .    , ,  ,  V8   ,      .     ,     . <br><br> , ,  Q (   compiled code) ‚Äî  React    .   ,   ? <br><br>    ,     ,             ,    . <br><br>     ,    . <br><br><img src="https://habrastorage.org/webt/-3/z_/si/-3z_si-wvtfdlbz87myro38qz1s.png"><br><br>     ,     ,   ,         .   ,    ‚Äî  4     .  ,  . <br><br><img src="https://habrastorage.org/webt/pr/un/bt/prunbtssbfjjsklugfzwp2mv778.png"><br><br>      React,       - :         . ,   JSX. <br><br>  Performance  Memory   ,   : <br><br><ul><li>  Chromium: about:tracing. </li><li>  Firefox: about:memory  about:performance,    . </li><li>   Node ‚Äî trace-gc, ‚Äîexpose-gc, require('trace_events').  trace_events    . </li></ul><br><h2>  Resumen <br></h2><br><ul><li>   ,    ,    ,   . </li><li>                . </li><li>    .   ,      ? </li><li>   ,       -        . </li><li>     SPA,     ,    1       ,   . </li><li>   ,       -   . </li></ul><br>    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">flapenguin.me</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  -</a>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">++</a> .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong></strong></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>YouTube-</strong> <br></a> . <br><br>     ,     2018 ,     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Frontend Conf</a> 2018. <br><br>     ,   :) <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433318/">https://habr.com/ru/post/es433318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433302/index.html">Primeros pasos para el √≥xido</a></li>
<li><a href="../es433304/index.html">Prueba de carga con langosta. Parte 3</a></li>
<li><a href="../es433306/index.html">Visual studio 2019</a></li>
<li><a href="../es433308/index.html">Transferencia de la configuraci√≥n de PBX al servicio 3CX PBX Express</a></li>
<li><a href="../es433316/index.html">Resumen del dise√±o: incorporaci√≥n, retroalimentaci√≥n, b√∫squeda de ideas y toma de decisiones.</a></li>
<li><a href="../es433320/index.html">Dise√±o de cuadr√≠cula como base de dise√±os modernos</a></li>
<li><a href="../es433322/index.html">API JSON: trabajamos de acuerdo con las especificaciones</a></li>
<li><a href="../es433324/index.html">Recolectando el paquete de sue√±os con Webpack</a></li>
<li><a href="../es433326/index.html">Calidad del c√≥digo</a></li>
<li><a href="../es433328/index.html">Mejor perder un d√≠a</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>