<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥üèø üîé ü§æ Stan Drapkin. Trampas de criptograf√≠a de alto nivel en .NET üë®üèΩ‚Äçüç≥ üë®‚Äç‚úàÔ∏è üë®‚Äçüë©‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stan Drapkin es un experto en seguridad y cumplimiento con m√°s de 16 a√±os de experiencia con .NET Framework (comenzando con .NET 1.0-beta en 2001). De...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Stan Drapkin. Trampas de criptograf√≠a de alto nivel en .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/428121/">  Stan Drapkin es un experto en seguridad y cumplimiento con m√°s de 16 a√±os de experiencia con .NET Framework (comenzando con .NET 1.0-beta en 2001).  Desafortunadamente, √©l mismo no escribe art√≠culos en ruso, por lo que acordamos con √©l publicar una traducci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su informe con DotNext Piter</a> .  ¬°Este informe <b>gan√≥ el primer lugar</b> en la conferencia! <br><br>  Criptograf√≠a sim√©trica, criptograf√≠a el√≠ptica moderna, asim√©trica, h√≠brida, de alto nivel, bajo nivel, corriente y moderna.  Cincuenta y seis minutos de video sobre criptograf√≠a, y mucho m√°s r√°pido, en forma de texto. <br><br><img src="https://habrastorage.org/webt/ye/8s/g0/ye8sg0kuwhgvtitnjxvwpehfnwc.png"><br><br>  Debajo del corte: videos, diapositivas y traducci√≥n.  ¬°Disfruta leyendo! <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZqGyV7Jshww" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Diapositivas</a> <br><br>  Mi nombre es Stan Drapkin, soy el director t√©cnico de una empresa especializada en seguridad de la informaci√≥n y cumplimiento normativo.  Adem√°s, soy el autor de varias bibliotecas de c√≥digo abierto, que son muy bien recibidas por la comunidad.  ¬øCu√°ntos oyeron hablar de <i>Inferno</i> ?  Esta biblioteca muestra el enfoque correcto de la criptograf√≠a en .NET, y <i>TinyORM</i> implementa micro-ORM para .NET.  Adem√°s, he escrito varios libros que pueden ser relevantes para el tema del art√≠culo de hoy.  Una de ellas, la edici√≥n de 2014, es "Security Driven .NET", la otra de 2017 es "Application Security in .NET, Succinctly". <br><br>  Primero, hablaremos sobre lo que yo llamo las cuatro etapas de la iluminaci√≥n criptogr√°fica.  Luego seguir√°n dos temas principales, en el primero hablaremos sobre criptograf√≠a sim√©trica, en el segundo, sobre asim√©trico e h√≠brido.  En la primera parte, comparamos la criptograf√≠a de alto y bajo nivel y echamos un vistazo a un ejemplo de criptograf√≠a de transmisi√≥n.  En la segunda parte, tendremos muchas "aventuras" con RSA, despu√©s de lo cual nos familiarizaremos con la criptograf√≠a el√≠ptica moderna. <br><br>  Entonces, ¬øc√≥mo son estas etapas de la iluminaci√≥n criptogr√°fica?  La primera etapa: "XOR es genial, mira, mam√°, ¬øc√≥mo puedo?"  Seguramente muchos de ustedes est√©n familiarizados con esta etapa y conozcan las maravillas de la funci√≥n XOR.  Pero, espero, la mayor parte de esta etapa ha crecido y se ha movido a la siguiente, es decir, aprendi√≥ a realizar el cifrado y descifrado utilizando AES (Advanced Encryption Standard), un algoritmo bien conocido y altamente considerado.  La mayor√≠a de los desarrolladores que no visitan DotNext est√°n en esta etapa.  Pero, dado que sigue DotNext y est√° familiarizado con los informes sobre los peligros de las API de bajo nivel, lo m√°s probable es que se encuentre en la siguiente etapa: "Hice todo (a) incorrectamente, necesito cambiar a API de alto nivel".  Bueno, para completar la imagen, tambi√©n mencionar√© la √∫ltima etapa: el entendimiento de que con la mejor soluci√≥n al problema, la criptograf√≠a puede no ser necesaria en absoluto.  Esta etapa es la m√°s dif√≠cil de alcanzar y hay pocas personas en ella.  Un ejemplo es Peter G. Neumann, quien dijo lo siguiente: "Si crees que la soluci√≥n a tu problema radica en la criptograf√≠a, entonces no entiendes cu√°l es exactamente tu problema". <br><br>  El hecho de que la criptograf√≠a de bajo nivel es peligrosa se ha discutido en muchos informes sobre .NET.  Puede consultar el informe de Vladimir Kochetkov en 2015, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Errores del sistema. Seguridad</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Criptograf√≠a"</a> .  Su idea principal es que en cada etapa de trabajo con API criptogr√°ficas de bajo nivel, sin saberlo, tomamos muchas decisiones, para muchas de las cuales simplemente no tenemos el conocimiento adecuado.  La conclusi√≥n principal es que, idealmente, se debe usar criptograf√≠a de alto nivel en lugar de criptograf√≠a de bajo nivel.  Esta es una conclusi√≥n maravillosa, pero nos lleva a otro problema: ¬øsabemos exactamente c√≥mo deber√≠a ser la criptograf√≠a de alto nivel?  Hablemos un poco al respecto. <br><br>  Defina los atributos de una API criptogr√°fica que <i>no sea de</i> alto nivel.  Para empezar, una API de este tipo no dar√° la impresi√≥n de ser nativa de .NET, sino que se ver√° como un shell de bajo nivel.  Adem√°s, dicha API ser√° f√°cil de usar incorrectamente, es decir,  No como deber√≠a.  Adem√°s, te obligar√° a generar muchas cosas extra√±as de bajo nivel: nonce, vectores de inicializaci√≥n y similares.  Dicha API lo obligar√° a tomar decisiones desagradables para las que quiz√°s no est√© preparado: elija algoritmos, modos de relleno, tama√±os de clave, nonce, etc.  Tampoco tendr√° la API correcta para la transmisi√≥n (API de transmisi√≥n): hablaremos sobre c√≥mo deber√≠a ser esta √∫ltima. <br><br>  En contraste, ¬øc√≥mo deber√≠a ser una API criptogr√°fica de alto nivel?  Creo que, en primer lugar, debe ser intuitivo y conciso tanto para el lector del c√≥digo como para el escritor.  Adem√°s, dicha API deber√≠a ser f√°cil de aprender y usar, y deber√≠a ser extremadamente dif√≠cil de aplicar de manera incorrecta.  Tambi√©n debe ser poderoso, es decir, debe permitirnos alcanzar nuestro objetivo con un poco de esfuerzo, una peque√±a cantidad de c√≥digo.  Finalmente, una API de este tipo no debe tener una larga lista de restricciones, precauciones, casos especiales, en general, debe haber un m√≠nimo de cosas que deben recordarse al trabajar con ella, en otras palabras, debe caracterizarse por un bajo nivel de interferencia (baja fricci√≥n), debe solo trabaja sin ninguna reserva. <br><br>  Habiendo tratado los requisitos para una API criptogr√°fica de alto nivel para .NET, ¬øc√≥mo podemos encontrarla ahora?  Puede probar solo google, pero eso ser√≠a demasiado primitivo: somos desarrolladores profesionales y este no es nuestro m√©todo.  Por lo tanto, estamos investigando este problema y probando varias alternativas.  Pero para esto necesitamos primero inventarnos la idea correcta de lo que es el cifrado autenticado, y para esto necesitamos entender los conceptos b√°sicos.  Son los siguientes: el texto sin formato P (texto sin formato), que convertiremos al texto cifrado C (texto cifrado) de la misma longitud utilizando alguna clave secreta K (clave).  Como puede ver, hasta ahora estamos trabajando con un esquema muy simple.  Adem√°s, tambi√©n tenemos una etiqueta de autenticaci√≥n T y nonce N. Un par√°metro importante es NÃÖ, es decir, reutilizar nonce con una clave.  Como muchos de ustedes probablemente saben, conduce a una violaci√≥n de la confidencialidad del texto, lo que obviamente es indeseable.  Otro concepto importante es AD (datos asociados), es decir, datos asociados.  Estos son datos opcionales que se autentican pero no participan en el cifrado y descifrado. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f9/41c/537/2f941c537ee2813920df009759b19e97.jpg"><br><br>  Habiendo entendido los conceptos b√°sicos, echemos un vistazo a las diversas opciones de bibliotecas criptogr√°ficas para .NET.  Comencemos con el an√°lisis de <i>Libsodium.NET.</i>  ¬øCu√°ntos de ustedes la conocen?  Como veo, algunos son familiares. <br><br><pre><code class="cs hljs">nonce = SecretAeadAes.GenerateNonce(); c = SecretAeadAes.Encrypt(p, nonce, key, ad); d = SecretAeadAes.Decrypt(c, nonce, key, ad);</code> </pre> <br>  <i>Aqu√≠ est√° el</i> c√≥digo C # con el que se realiza el cifrado con <i>Libsodium.NET</i> .  A primera vista, es bastante simple y conciso: en la primera l√≠nea, se genera nonce, que luego se usa en la segunda l√≠nea, donde tiene lugar el cifrado, y en la tercera, donde se descifra el texto.  Al parecer, ¬øqu√© dificultades podr√≠a haber?  Para empezar, Libsodium.NET ofrece no uno, sino tres m√©todos diferentes de cifrado sim√©trico: <br><br>  Tiempos <br><br><pre> <code class="cs hljs">nonce = SecretAeadAes.GenerateNonce(); c = SecretAeadAes.Encrypt(p, nonce, key, ad); d = SecretAeadAes.Decrypt(c, nonce, key, ad);</code> </pre><br>  Dos <br><br><pre> <code class="cs hljs">nonce = SecretAead.GenerateNonce(); c = SecretAead.Encrypt(p, nonce, key, ad); d = SecretAead.Decrypt(c, nonce, key. ad);</code> </pre><br>  Tres <br><br><pre> <code class="cs hljs">nonce = SecretBox.GenerateNonce(); c = SecretBox.Create(p, nonce, key); d = SecretBox.Open(c, nonce, key);</code> </pre><br>  Obviamente, surge la pregunta: ¬øcu√°l de ellos es mejor en su situaci√≥n espec√≠fica?  Para responderlo, debe entrar en estos m√©todos, que haremos ahora. <br><br>  El primer m√©todo, <code>SecretAeadAes</code> , utiliza AES-GCM con un nonce de 96 bits.  Es importante que tenga una lista bastante larga de restricciones.  Por ejemplo, al usarlo, no debe cifrar m√°s de 550 gigabytes con una clave, y no debe haber m√°s de 64 gigabytes en un mensaje con un m√°ximo de 2 <sup>32</sup> mensajes.  Adem√°s, la biblioteca no advierte acerca de estas restricciones, debe realizar un seguimiento usted mismo, lo que crea una carga adicional para usted como desarrollador. <br><br>  El segundo m√©todo, <code>SecretAead</code> , utiliza un conjunto de cifrado diferente, <code>ChaCha20/Poly1305</code> con un nonce significativamente m√°s peque√±o de 64 bits.  Una falta tan peque√±a hace que las colisiones sean extremadamente probables, y solo por esta raz√≥n, no debe usar este m√©todo, excepto en casos bastante raros y siempre que est√© muy versado en el tema. <br><br>  Finalmente, el tercer m√©todo, <code>SecretBox</code> .  Cabe se√±alar de inmediato que no hay datos asociados en los argumentos de esta API.  Si necesita cifrado autenticado con AD, este m√©todo no es adecuado para usted.  El algoritmo de cifrado utilizado aqu√≠ se llama <code>xSalsa20/Poly1305</code> , nonce es lo suficientemente grande: 192 bits.  Sin embargo, la falta de EA es una limitaci√≥n significativa. <br><br>  Cuando se usa <i>Libsodium.NET</i> , surgen algunas preguntas.  Por ejemplo, ¬øqu√© deber√≠amos hacer exactamente con el nonce generado por la primera l√≠nea de c√≥digo en los ejemplos anteriores?  La biblioteca no nos dice nada sobre esto, tenemos que resolverlo por nuestra cuenta.  Lo m√°s probable es que agreguemos manualmente este nonce al principio o al final del texto cifrado.  Adem√°s, podr√≠amos tener la impresi√≥n de que AD en los primeros dos m√©todos puede ser de cualquier longitud.  Pero, de hecho, la biblioteca admite AD no m√°s de 16 bytes de largo; despu√©s de todo, 16 bytes ser√°n suficientes para todos, ¬øverdad?  Sigamos adelante.  ¬øQu√© sucede con los errores de descifrado?  En esta biblioteca, se decidi√≥ en estos casos lanzar excepciones.  Si en su entorno durante el descifrado se puede violar la integridad de los datos, tendr√° muchas excepciones que deber√°n manejarse.  ¬øQu√© sucede si el tama√±o de su clave no es exactamente 32 bytes?  La biblioteca no nos dice nada sobre esto, estos son sus problemas que no le interesan.  Otro tema importante es la reutilizaci√≥n de las matrices de bytes para reducir la carga en el recolector de basura en escenarios intensivos.  Por ejemplo, en el c√≥digo vimos una matriz que nos devolvi√≥ el generador nonce.  Me gustar√≠a no crear un nuevo b√∫fer cada vez, sino reutilizar el existente.  Esto no es posible en esta biblioteca, una matriz de bytes se regenerar√° cada vez. <br><br>  Usando el esquema que ya hemos visto, intentaremos comparar varios algoritmos de <i>Libsodium.NET</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3c/6e3/d3c/b3c6e3d3ce4ef29723e2ac691c3fd4d4.jpg"><br><br>  El primer algoritmo, AES-GCM, utiliza una longitud de 96 bits (columna amarilla en la imagen).  Tiene menos de 128 bits, lo que crea algunas molestias, pero no demasiado significativas.  La siguiente columna es azul, este es el lugar ocupado por la etiqueta de autenticaci√≥n, con AES-GCM es de 16 bytes o 128 bits.  El segundo d√≠gito azul, entre par√©ntesis, significa la cantidad de entrop√≠a, o aleatoriedad, contenida en esta etiqueta, menos de 128 bits.  Cu√°nto menos: en este algoritmo depende de la cantidad de datos cifrados.  Cuanto m√°s encriptado, m√°s d√©bil es la etiqueta.  Esto solo deber√≠a generar dudas sobre este algoritmo, que solo aumentar√° si miramos la columna blanca.  Dice que las repeticiones (colisiones) de nonce conducir√°n a la falsificaci√≥n de todos los textos cifrados creados por la misma clave.  Si fuera de, por ejemplo, 100 de sus textos cifrados creados por una clave com√∫n en dos, hay una colisi√≥n nonce, este nonce conducir√° a una fuga interna de la clave de autenticaci√≥n y permitir√° que un atacante falsifique cualquier otro texto cifrado creado por esta clave.  Esta es una limitaci√≥n muy significativa. <br><br>  Pasemos al segundo m√©todo <i>Libsodium.NET</i> .  Como dije, aqu√≠ para nonce, se usa muy poco espacio, solo 64 bits.  La etiqueta ocupa 128 bits, pero contiene solo 106 bits de entrop√≠a o menos, en otras palabras, significativamente m√°s bajo que el nivel de seguridad de 128 bits, que en la mayor√≠a de los casos intentan alcanzar.  En cuanto a la falsificaci√≥n, la situaci√≥n aqu√≠ es ligeramente mejor que en el caso de AES-GCM.  La colisi√≥n de nonce conduce a la falsificaci√≥n de textos cifrados, pero solo para aquellos bloques en los que se produjeron colisiones.  En el ejemplo anterior, habr√≠amos falsificado 2 textos cifrados, no 100. <br><br>  Finalmente, en el caso del algoritmo xSalsa / Poly, tenemos un nonce muy grande de 192 bits, lo que hace que las colisiones sean extremadamente improbables.  El m√©todo de autenticaci√≥n es el mismo que en el m√©todo anterior, por lo que la etiqueta nuevamente toma 128 bits y tiene 106 bits de entrop√≠a o menos. <br><br>  Compare todas estas cifras con los indicadores correspondientes de la biblioteca <i>Inferno</i> .  En √©l, nonce ocupa un espacio colosal, 320 bits, lo que hace que las colisiones sean casi imposibles.  En cuanto a la etiqueta, todo es simple: ocupa exactamente 128 bits y tiene exactamente 128 bits de entrop√≠a, nada menos.  Este es un ejemplo de un enfoque confiable y seguro. <br><br>  Antes de conocer <i>Libsodium.NET</i> con m√°s detalle, debemos comprender su prop√≥sito; desafortunadamente, no todos los que usan esta biblioteca lo saben.  Para hacer esto, consulte su documentaci√≥n, que establece que <i>Libsodium.NET</i> es un contenedor C # para <i>libsodium</i> .  Este es otro proyecto de c√≥digo abierto, cuya documentaci√≥n dice que es una bifurcaci√≥n de <i>NaCl</i> con una API compatible.  Bueno, recurra a la documentaci√≥n de <i>NaCl</i> , otro proyecto de c√≥digo abierto.  En √©l, como objetivo, <i>NaCl se</i> postula para proporcionar todas las operaciones necesarias para crear herramientas criptogr√°ficas de alto nivel.  Es aqu√≠ donde est√° enterrado el perro: la tarea de <i>NaCl</i> y todos sus caparazones es proporcionar elementos de bajo nivel, a partir de los cuales alguien m√°s ya puede ensamblar API criptogr√°ficas de alto nivel.  Estas conchas en s√≠ mismas como bibliotecas de alto nivel no fueron concebidas.  De ah√≠ la moraleja: si necesita una API criptogr√°fica de alto nivel, necesita encontrar una biblioteca de alto nivel, en lugar de usar un contenedor de bajo nivel y pretender que est√° trabajando con una de alto nivel. <br><br>  Veamos c√≥mo funciona el cifrado en <i>Inferno</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/64f/367/fe7/64f367fe769bce5d8fa0482f8a301648.jpg"><br><br>  Aqu√≠ hay un c√≥digo de ejemplo en el cual, como en el caso de <i>Libsodium</i> , cada encriptaci√≥n y desencriptaci√≥n toma solo una l√≠nea.  Los argumentos son clave, texto y datos asociados opcionales.  Cabe se√±alar que no hay nonce, no hay necesidad de tomar decisiones, en caso de un error de descifrado, simplemente devuelve nulo, sin lanzar excepciones.  Dado que la creaci√≥n de excepciones aumenta significativamente la carga en el recolector de basura, su ausencia es muy importante para los scripts que procesan grandes flujos de datos.  Espero haber logrado convencerlo de que este enfoque es √≥ptimo. <br><br>  Por inter√©s, intentemos encriptar alguna cadena.  Este deber√≠a ser el escenario m√°s simple que todos puedan implementar.  Supongamos que solo tenemos dos valores de cadena diferentes posibles: "IZQUIERDA" y "DERECHA". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/88b/522/92b/88b52292b7ce52dc2a90302cbbbe1f36.jpg"><br><br>  En la imagen, puede ver el cifrado de estas l√≠neas usando <i>Inferno</i> (aunque para este ejemplo no importa qu√© biblioteca se use).  Ciframos dos l√≠neas con una clave y obtenemos dos textos cifrados, <code>c1</code> y <code>c2</code> .  ¬øEst√° todo correcto en este c√≥digo?  ¬øEst√° listo para la producci√≥n?  Alguien puede decir que el problema es posible de una manera corta, pero est√° lejos de ser el principal, por lo que asumiremos que la clave se usa de la misma manera y que tiene una longitud suficiente.  Quiero decir algo m√°s: con los enfoques criptogr√°ficos convencionales, <code>c1</code> en nuestro ejemplo ser√° m√°s corto que <code>c2</code> .  Esto se denomina fuga de longitud: en muchos casos, <code>c2</code> ser√° un byte m√°s largo que <code>c1</code> .  Esto puede permitir que un atacante entienda qu√© cadena est√° representada por este texto cifrado, "IZQUIERDA" o "DERECHA".  La forma m√°s f√°cil de resolver este problema es hacer que ambas l√≠neas tengan la misma longitud; por ejemplo, agregue un car√°cter al final de la l√≠nea "IZQUIERDA". <br><br>  A primera vista, la fuga de longitud se percibe como un problema un tanto exagerado que no se puede encontrar en aplicaciones reales.  Pero en enero de 2018, se public√≥ un art√≠culo en la revista Wired con un estudio realizado por la compa√±√≠a israel√≠ Checkmarx, bajo el t√≠tulo "La falta de encriptaci√≥n en Tinder permite a los extra√±os rastrear cuando deslizas la pantalla".  Relatar√© brevemente el contenido, pero primero una descripci√≥n aproximada de la funcionalidad de Tinder.  Tinder es una aplicaci√≥n que recibe una transmisi√≥n con fotos, y luego el usuario desliza la pantalla hacia la derecha o hacia la izquierda, dependiendo de si le gusta la foto o no.  Los investigadores descubrieron que aunque los comandos en s√≠ mismos estaban encriptados correctamente usando TLS y HTTPS, los datos para el comando correcto tomaron una cantidad diferente de bytes que los datos para el izquierdo.  Esto, por supuesto, es una vulnerabilidad, pero en s√≠ mismo no es demasiado significativo.  M√°s significativo para Tinder fue el hecho de que enviaron las transmisiones con fotos a trav√©s de HTTP regular, sin ning√∫n cifrado.  Por lo tanto, el atacante podr√≠a obtener acceso no solo a las reacciones de los usuarios a las fotos, sino tambi√©n a las fotos mismas.  Entonces, como puede ver, la fuga de longitud es un problema muy real. <br><br>  Ahora intentemos encriptar el archivo.  Inmediatamente debo decir que en el cifrado de archivos <i>Libsodium.NET</i> o, en t√©rminos m√°s generales, el cifrado de flujo no se implementa de manera predeterminada, debe hacerse all√≠ manualmente, lo cual, cr√©anme, es muy dif√≠cil de hacer correctamente.  En <i>Inferno</i> , las cosas est√°n mucho mejor con esto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f0/446/955/5f0446955f52e679e6dbeaacee2389b4.jpg"><br><br>  Arriba, puede ver un ejemplo tomado pr√°cticamente sin cambios de MSDN.  Es muy simple, aqu√≠ vemos una secuencia para el archivo de origen y otra para el archivo de destino, as√≠ como una secuencia de cifrado que convierte la primera en la segunda.  En este c√≥digo, <i>Inferno se</i> usa solo en una l√≠nea, en la que tiene lugar la conversi√≥n.  Entonces, ante nosotros hay una soluci√≥n simple y al mismo tiempo totalmente funcional y probada para el cifrado de flujo. <br><br>  Debe recordarse que al cifrar con la misma clave, tenemos un l√≠mite en la cantidad de mensajes.  Existen en <i>Inferno</i> , y en esta biblioteca est√°n claramente escritos en la pantalla.  Pero al mismo tiempo, son tan grandes en <i>Inferno</i> que en la pr√°ctica nunca los alcanzar√°s.  En <i>Libsodium.NET, las</i> restricciones son diferentes para diferentes algoritmos, pero en todos los casos son lo suficientemente bajas como para ser superadas.  Por lo tanto, debe verificar si se lograr√°n en cada escenario individual. <br><br>  Tambi√©n deber√≠amos hablar sobre la autenticaci√≥n de datos asociados, ya que este es un tema que a menudo no se trata.  Los AD pueden ser "d√©biles": esto significa que est√°n autenticados, pero no est√°n involucrados en el proceso de cifrado y descifrado.  Por el contrario, los AD "fuertes" alteran este proceso en s√≠.  La mayor√≠a de las bibliotecas de AD que conozco son d√©biles, mientras que <i>Inferno</i> usa el segundo enfoque, donde los AD se usan en el proceso de cifrado / descifrado en s√≠ ... <br><br>  Tambi√©n deber√≠a detenerse en qu√© nivel de seguridad deber√≠a esforzarse por la criptograf√≠a de alto nivel.  En resumen, mi respuesta es: cifrado de 256 bits con una etiqueta de autenticaci√≥n de 128 bits.  ¬øPor qu√© es una llave tan grande?  Hay muchas razones para esto, cada una de las cuales es importante en s√≠ misma, pero ahora me gustar√≠a que recuerde una cosa: debemos protegernos de posibles sesgos al generar claves criptogr√°ficas.  D√©jame explicarte qu√© se entiende por sesgo.  Para un generador de bits aleatorio sin sesgo, para cada bit, las probabilidades de aceptar el valor 0 o 1 son iguales.  Pero supongamos que en nuestro generador el bit tomar√° el valor 1 con una probabilidad del 56%, no del 50%.  A primera vista, este sesgo es peque√±o, pero de hecho es significativo: 25%.  Ahora intentemos calcular cu√°nta entrop√≠a obtenemos al generar un cierto n√∫mero de bits con nuestro generador. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3eb/f2e/df8/3ebf2edf8c049579b2e4218f9dff16b8.jpg"><br><br>  En la imagen puede ver la f√≥rmula por la cual se realizar√° este c√°lculo.  Es importante que solo contenga dos variables: el sesgo del que ya hemos hablado (sesgo) y el n√∫mero de bits creados por el generador.  Suponemos que el sesgo es del 25%; este es un caso bastante extremo, en la pr√°ctica lo m√°s probable es que no funcione en sistemas con un generador de n√∫meros aleatorios tan distorsionado.  De todos modos, con un 25% de sesgo y una clave de 128 bits, obtenemos solo 53 bits de entrop√≠a.  En primer lugar, es significativamente menor que 128 bits, que generalmente se esperan de un generador de n√∫meros aleatorios, y en segundo lugar, con las tecnolog√≠as modernas, dicha clave puede ser simplemente la fuerza bruta.  Pero si en lugar de la clave de 128 bits usamos 256 bits, obtenemos 106 bits de entrop√≠a.  Esto ya es bastante bueno, aunque menos de lo esperado 256. Con las tecnolog√≠as modernas, es casi imposible descifrar esa clave. <br><br>  Al final de la primera parte del informe resumir√© los resultados provisionales.  Recomiendo a todos que utilicen API criptogr√°ficas bien escritas.  Encuentre el que m√°s le convenga o env√≠e una petici√≥n a Microsoft para que le escriba.  Adem√°s, al elegir una API, debe prestar atenci√≥n a la disponibilidad de soporte para trabajar con subprocesos.  Por las razones ya explicadas, la longitud m√≠nima de la clave debe ser de 256 bits.  Finalmente, debe tenerse en cuenta que la criptograf√≠a de alto nivel, como cualquier otra, no es ideal.  Pueden ocurrir fugas, y en la mayor√≠a de los escenarios se deben tener en cuenta sus capacidades. <br><br>  Hablemos de criptograf√≠a asim√©trica o h√≠brida.  Har√© una pregunta capciosa: ¬øpuedes usar RSA en .NET?  No se apresure a responder afirmativamente, como muchos lo hacen. Primero, analicemos sus conocimientos en esta √°rea.  Las siguientes diapositivas ser√°n dise√±adas espec√≠ficamente para personas que ya est√°n familiarizadas con este tema.  Pero primero, echemos un vistazo a Wikipedia y recordemos qu√© es RSA exactamente en caso de que alguien haya olvidado o no haya utilizado este algoritmo durante mucho tiempo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fec/e71/6ba/fece716ba7a00668b4d955c37745e744.png"><br><br>  Supongamos que hay una Alice que, utilizando un generador de n√∫meros aleatorios, crea un par de claves que incluye una privada y una p√∫blica.  A continuaci√≥n, hay algunos Bob que quieren cifrar un mensaje para Alice: "¬°Hola, Alice!"  Usando su clave p√∫blica, genera un texto cifrado, que luego le env√≠a.  Ella descifra este texto cifrado utilizando la parte privada de su clave. <br><br>  Intentemos reproducir este escenario en la pr√°ctica. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/35d/021/627/35d021627d87f316a65b87bc4662aa05.jpg"><br><br>  Como puede ver arriba, creamos una instancia de RSA y encriptamos algo de texto.  Preste atenci√≥n de inmediato .NET nos obliga a elegir el modo de relleno.  Hay cinco de ellos, todos con nombres oscuros.  Si los probamos todos a su vez, descubriremos que los tres √∫ltimos simplemente lanzan una excepci√≥n y no funcionan.  Utilizaremos uno de los dos restantes: <code>OaepSHA1</code> .  Aqu√≠, la clave tendr√° un tama√±o de 1 kilobit, que es demasiado peque√±a para RSA, es pr√°cticamente una clave pirateada.  Por lo tanto, tenemos que establecer el tama√±o de la clave manualmente.  De la documentaci√≥n aprendemos que existe una propiedad especial <code>.KeySize</code> , que recibe o establece el tama√±o de la clave. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0e/e77/a12/e0ee77a12bcd866142463ee8440c9b28.jpg"><br><br>  A primera vista, esto es exactamente lo que necesitamos, as√≠ que escribimos: <code>rsa.KeySize = 3072</code> .  Pero si, guiados por una vaga sospecha, despu√©s de eso verificamos a qu√© tama√±o de clave es ahora igual, descubrimos que todav√≠a se necesita 1 kilobit.  No importa, verificaremos este par√°metro utilizando el <code>WriteLine(rsa.KeySize)</code> o <code>rsa.ExportParameters(false).Modulus.Length * 8</code> : en este √∫ltimo caso, el componente p√∫blico de la clave RSA se exporta, para esto necesitamos el argumento "false".  El m√≥dulo de esta clave es una matriz, que multiplicamos por 8 y obtenemos el tama√±o en bits, que nuevamente ser√° de 1 kilobit.  Como puede ver, este algoritmo a√∫n es demasiado temprano para enviarlo a producci√≥n. <br><br>  No perderemos el tiempo para descubrir por qu√© esta API no funciona, en su lugar, pruebe con otra implementaci√≥n RSA proporcionada por Microsoft en .NET 4.6, es decir, una completamente nueva.  Se llama <i>RSACng</i> , y <i>Cng</i> significa Criptograf√≠a de pr√≥xima generaci√≥n.  Genial, ¬øqui√©n no quiere trabajar con herramientas de pr√≥xima generaci√≥n?  Seguramente aqu√≠ encontraremos una soluci√≥n m√°gica a todos nuestros problemas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ed/1af/3fb/7ed1af3fbcd93422ff6648e2af791264.jpg"><br><br>  Solicitamos una instancia de RSACng, nuevamente establecemos el tama√±o de la clave en 3 kilobits, nuevamente verificamos el tama√±o de la clave a trav√©s de <code>WriteLine(rsa.KeySize)</code> y nuevamente descubrimos que el tama√±o de la clave sigue siendo de un kilobit.  Adem√°s, si solicitamos el tipo de objeto que gener√≥ la clave, como recordamos, solicitamos una instancia de RSACng, descubrimos que es RSACryptoServiceProvider.  Solo quiero compartir mi sensaci√≥n personal de desesperaci√≥n aqu√≠ y gritar: "¬øPor qu√©, Microsoft?" <br><br>  Despu√©s de un tormento y un tormento prolongados, descubrimos que, de hecho, debe usar el dise√±ador, no la f√°brica. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c20/5e7/be1/c205e7be1603914e310bfb703f25e157.jpg"><br><br>  Aqu√≠ el valor de tama√±o de clave predeterminado es 2048 bits, que ya es mucho mejor.  Lo que es a√∫n mejor: aqu√≠ finalmente logramos establecer el tama√±o de la clave en 3 kilobits.  Como dicen, logro desbloqueado. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perm√≠tame recordarle que todos nuestros esfuerzos hasta ahora se han reducido solo a la creaci√≥n de RSA, a√∫n no hemos comenzado el cifrado. Todav√≠a hay preguntas que primero debemos responder. Para empezar, ¬øen qu√© medida puede confiar en los tama√±os de clave predeterminados? La implementaci√≥n de la f√°brica RSA puede ser anulada </font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo tanto, puede cambiar sin su conocimiento (por ejemplo, un administrador del sistema puede cambiarla). Y esto significa que el tama√±o de clave predeterminado tambi√©n puede cambiar. Por lo tanto, nunca debe confiar en los valores proporcionados por defecto, el tama√±o de la clave siempre debe establecerse de forma independiente. A continuaci√≥n, ¬øqu√© tan buenos son los tama√±os de clave RSA predeterminados? Hay dos implementaciones de RSA en .NET, una basada </font></font><code>RSACryptoServiceProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la otra basada</font></font><code>RSACng</code> .      1 ,   .           Bitcoin (BCN).       ,      Bitcoin  ,      .     hashrate,           2 <sup>64</sup>   .   2 <sup>90</sup>   .   ,       ‚Äî      ,   .      ,   ,     ,   ,  2 <sup>70</sup>  (    BCN) ,   1-  RSA,  2 <sup>90</sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(un a√±o BCN) - para descifrar una clave de 2 kilobits. Ambos valores deber√≠an causarnos ansiedad: esto es lo que se puede lograr con las tecnolog√≠as existentes. Es por eso que le recomiendo que siempre configure el tama√±o de la clave usted mismo, y que tenga un tama√±o de al menos 3 kilobits, y si el rendimiento lo permite, entonces 4. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En .NET, no es tan f√°cil descubrir c√≥mo exportar claves p√∫blicas y privadas. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/836/078/4ea8360788f3ffdbb6a07dfe9c0587e0.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la parte superior de la diapositiva, ver√° dos instancias de la clave RSA, la primera de </font></font><code>RSACryptoServiceProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la segunda de</font></font><code>RSACng</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada 4 kilobits. El siguiente c√≥digo se utiliza para extraer las claves p√∫blicas y privadas de ambas instancias. Cabe se√±alar que ambas API son bastante diferentes entre s√≠: c√≥digo diferente, m√©todos diferentes, par√°metros diferentes. Adem√°s, si comparamos los tama√±os de las claves p√∫blicas de la primera y segunda copia, veremos que son comparables, aproximadamente medio kilobyte cada una. Pero la clave privada para la nueva implementaci√≥n de RSA es mucho m√°s peque√±a que la anterior. Es necesario tener esto en cuenta y observar la uniformidad, no interferir con estas dos API entre s√≠. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo lo que hemos hecho con RSA hasta ahora se ha reducido a tratar de obtener una copia que funcione; Ahora intenta encriptar algo. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c88/fb5/c3c/c88fb5c3ca4ee8a62b9b0bd2595291cf.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cree una matriz de bytes, que ser√° nuestro texto sin formato (</font></font><code>data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), y luego lo encriptaremos utilizando uno de esos modos de adici√≥n que no arroj√≥ una excepci√≥n. Pero esta vez tenemos una excepci√≥n. Esta es una excepci√≥n a un par√°metro no v√°lido; pero de que par√°metro estamos hablando? No tengo idea, y Microsoft, muy probablemente, tambi√©n. Si intentamos ejecutar el mismo m√©todo con otros modos de suplemento, en cada caso obtenemos la misma excepci√≥n. Entonces el punto no est√° en modo suplemento. Entonces el problema est√° en el c√≥digo fuente mismo. Es dif√≠cil decir qu√© le pasa, as√≠ que intentemos reducirlo a la mitad por si acaso. Esta vez, el cifrado es exitoso. Estamos perplejos</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQuiz√°s el punto es que usamos el suplemento SHA-1? SHA-1, como sabemos, ya no es una funci√≥n criptogr√°ficamente fuerte, por lo que nuestros auditores y el departamento de cumplimiento insisten en que nos deshagamos de ella. Reemplace </font></font><code>OaepSHA1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con </font></font><code>OaepSHA256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, al menos, tranquilizar√° a los auditores. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/29e/7ed/275/29e7ed275ae1eb8deea59683289b5b6b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero cuando intentamos cifrar, nuevamente tenemos la excepci√≥n del par√°metro incorrecto. Toda esta situaci√≥n es causada por el hecho de que la restricci√≥n en el tama√±o del texto que se puede transferir a la funci√≥n criptogr√°fica depende no solo del modo de suplemento, sino tambi√©n del tama√±o de la clave. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intentemos averiguar exactamente c√≥mo se ve esa f√≥rmula m√°gica, que determina la cantidad m√°xima de datos cifrados. Debe estar en el m√©todo</font></font><code>int GetMaxDataSizeForEnc(RSAEncryptionPadding pad)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que calcula este volumen, despu√©s de haber recibido el modo de suplemento en la entrada. La principal desventaja de este m√©todo es que no existe, lo invent√©. Estoy tratando de transmitir la idea de que incluso la informaci√≥n m√°s b√°sica que un desarrollador necesita para usar RSA correctamente no est√° disponible para nosotros. Gracias Microsoft.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estas son las razones por las cuales se debe evitar el RSA, incluso para la firma. Como espero haber logrado mostrar, las API para RSA en .NET son extremadamente insatisfactorias. Usted est√° obligado a tomar muchas decisiones con respecto al modo de suplemento, el tama√±o de los datos y similares, lo cual es indeseable. Adem√°s, para un nivel de seguridad de 128 bits, necesitar√° al menos una clave de 4 kilobytes muy voluminosa. Le dar√° una clave privada de kilobyte, una clave p√∫blica de medio kilobyte y una firma de medio kilobyte. Para muchos escenarios, tales valores pueden no ser deseables. Y si intenta alcanzar un nivel de seguridad de 256 bits, necesitar√° una clave enorme: 15360 bits. En RSA, usar tal clave es casi imposible. En mi computadora port√°til, una de esas claves se genera un minuto y medio.Adem√°s de esto, el RSA en un nivel fundamental, como algoritmo, implementa muy lentamente una firma, independientemente de la implementaci√≥n. ¬øPor qu√© la velocidad de la firma es importante para nosotros? Si usa TLS con certificados RSA, la firma se realiza en el servidor. Y nosotros, como desarrolladores, somos los m√°s afectados exactamente por lo que sucede en el servidor, somos responsables de ello, su rendimiento es importante para nosotros. En resumen, quiero recomendar una vez m√°s que no use RSA.Quiero recomendar nuevamente no usar RSA.Quiero recomendar nuevamente no usar RSA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, ¬øqu√© puede reemplazar el RSA? Me gustar√≠a presentarles las primitivas criptogr√°ficas el√≠pticas modernas. En primer lugar, debe tener en cuenta el ECDSA (Algoritmo de firma digital), que se puede usar en lugar de RSA para las firmas. En esta y las siguientes abreviaturas, EC es un prefijo gen√©rico que significa curva el√≠ptica ("el√≠ptica"). En securitydriven.net/inferno/#DSA Signatures, puede encontrar un c√≥digo ECDSA de muestra que, por cierto, es nativo de .NET. Otro algoritmo importante es ECIES (Esquema de cifrado integrado, "esquema de cifrado integrado el√≠ptico"). Este algoritmo puede realizar cifrado h√≠brido en lugar de RSA, es decir, donde genera una clave sim√©trica, cifra los datos con ella y luego cifra la clave en s√≠.El c√≥digo de muestra est√° disponible en securitydriven.net/inferno/#ECIES ejemplo. Finalmente, otro algoritmo muy importante es ECDH (intercambio de claves Diffie-Hellman, "intercambio de claves Diffie-Hellman"). Le permite crear claves para el cifrado sim√©trico entre dos partes con claves p√∫blicas conocidas. En algunas situaciones y m√©todos de uso, permite el secreto directo (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secreto hacia adelante</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). El enlace </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">securitydriven.net/inferno/#DHM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> clave del c√≥digo disponible muestra del intercambio.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resumir la conversaci√≥n sobre el cifrado asim√©trico. Siempre debe usar API de alto nivel que no lo obliguen a tomar decisiones para las que no est√° preparado. Tambi√©n recomendar√≠a dejar de usar RSA. Por supuesto, esto es m√°s f√°cil decirlo que hacerlo, ya que todos trabajamos con aplicaciones grandes ya creadas, que pueden no ser refactorizadas por completo. En este caso, al menos debe aprender a usar RSA correctamente. Adem√°s, le aconsejo que se familiarice con los modernos algoritmos criptogr√°ficos el√≠pticos (ECDSA, ECDH, ECIES). Finalmente, es importante que la criptograf√≠a de alto nivel no resuelva m√°gicamente todos los problemas, por lo que debe recordar los objetivos que persigue. Citar√© de StackOverflow, con lo cual estoy completamente de acuerdo: ‚ÄúLa criptograf√≠a por s√≠ sola no resuelve los problemas.El cifrado sim√©trico solo convierte la privacidad de los datos en un problema de administraci√≥n de claves ".</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dir√© algunas palabras sobre recursos que pueden serle √∫tiles. Existe una biblioteca </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SecurityDriven.Inferno de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alto nivel relativamente aceptable </font><font style="vertical-align: inherit;">con buena documentaci√≥n. Hay un libro maravilloso, Criptograf√≠a seria de Jean-Philippe Aumasson, Criptograf√≠a seria. Proporciona una visi√≥n general del estado actual de la criptograf√≠a, teniendo en cuenta las √∫ltimas innovaciones. Adem√°s, escrib√≠ el libro ya mencionado Application Security en .NET, sucintamente, que es de dominio p√∫blico. Tiene a√∫n m√°s informaci√≥n sobre trampas de seguridad .NET. Finalmente, Slideshare tiene una excelente presentaci√≥n de Vladimir Kochetkov, que describe los conceptos b√°sicos de la teor√≠a de seguridad de aplicaciones de una manera algo simplista pero muy s√≥lida y explica varias fuentes de peligros.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como conclusi√≥n, veamos algunos ejemplos adicionales que he preparado. Al principio, habl√© sobre la cuarta etapa de la iluminaci√≥n criptogr√°fica, en la que nos damos cuenta de que la mejor soluci√≥n puede no necesitar criptograf√≠a en absoluto. Veamos un ejemplo de tal soluci√≥n. Echemos un vistazo al cl√°sico mecanismo .NET: CSRF (falsificaci√≥n de solicitudes entre sitios, "falsificaci√≥n de solicitudes entre sitios"), dise√±ado para proteger contra una clase de ataques, incluida la falsificaci√≥n de solicitudes entre sitios. En este modelo, tenemos un agente de usuario, generalmente un navegador. Intenta establecer una conexi√≥n con el servidor enviando una solicitud GET. En respuesta, el servidor env√≠a un token CSRF, que est√° oculto en el campo HTML "oculto". Adem√°s, el mismo token se adjunta a la respuesta como una cookie, como un encabezado.El usuario procesa alg√∫n formulario y realiza una POST, que regresa al servidor con ambos tokens. El servidor comprueba, en primer lugar, si se enviaron ambos tokens y, en segundo lugar, si coinciden. Es esta comparaci√≥n de identidad la que permite al servidor protegerse de un atacante. Este es un mecanismo cl√°sico integrado en ASP.NET y ASP.NET Core. Mikhail Shcherbakov hizo un excelente informe en el que se investig√≥ en detalle el trabajo de CSRF.</font></font><br><br>     ,    CSRF  .   ,      ‚Äî     ,   ,  ,  .   .  ,  (injection)   ,    .    ‚Äî ,   AJAX,   ‚Äî        . ,   , ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a22/806/cae/a22806caea546a62b7a14d2af7583d48.jpg"><br><br>           ,   <i>‚Äî</i>   .  ,     ,          .     ,  . <br><br><blockquote>  .       DotNext.      DotNext 2018 Moscow ‚Äî   22-23  2018  - ¬´  ¬ª. <br><br> <b>  </b> .  ,  ,    .          !     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428121/">https://habr.com/ru/post/es428121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428111/index.html">Aritm√©tica de precisi√≥n arbitraria en Erlang</a></li>
<li><a href="../es428113/index.html">A la pregunta de las curvas de Bezier, la velocidad de Arduino y un sitio interesante, o c√≥mo pas√© el fin de semana</a></li>
<li><a href="../es428115/index.html">Desarrollo web para comercio electr√≥nico: 5 tendencias tecnol√≥gicas para 2019</a></li>
<li><a href="../es428117/index.html">Procesadores de tensor gratuitos de Google en la nube colaborativa</a></li>
<li><a href="../es428119/index.html">"Clase-campos-propuesta" o "¬øQu√© sali√≥ mal en tc39 commit"</a></li>
<li><a href="../es428123/index.html">Semana de la seguridad 41: buenas noticias</a></li>
<li><a href="../es428125/index.html">¬øQui√©nes son los an√°lisis de productos y por qu√© se necesitan en un equipo?</a></li>
<li><a href="../es428127/index.html">Cach√© de Nginx: todo nuevo - bien olvidado viejo</a></li>
<li><a href="../es428129/index.html">Simple l√≥gica difusa unida "de lo que era" para un motor de turbina de gas</a></li>
<li><a href="../es428131/index.html">Toda la verdad sobre RTOS. Art√≠culo # 17. Grupos de banderas de eventos: Introducci√≥n y servicios b√°sicos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>