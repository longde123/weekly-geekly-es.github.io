<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘µğŸ» ğŸ§‘ğŸ¾â€ğŸ¤â€ğŸ§‘ğŸ½ ğŸ™‹ğŸ¼ Aplikasi kari dan sebagian dalam C ++ 14 ğŸ ğŸ‘ğŸ½ ğŸ™ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini saya akan memberi tahu Anda tentang salah satu opsi currying dan aplikasi parsial fungsi di C ++ yang merupakan favorit pribadi saya....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplikasi kari dan sebagian dalam C ++ 14</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436488/"><p>  Pada artikel ini saya akan memberi tahu Anda tentang salah satu opsi currying dan aplikasi parsial fungsi di C ++ yang merupakan favorit pribadi saya.  Saya juga akan menunjukkan implementasi pilot saya sendiri untuk hal ini dan menjelaskan titik kari tanpa rumus matematika yang rumit, membuatnya sangat sederhana untuk Anda.  Kita juga akan melihat apa yang ada di bawah kap perpustakaan <a href="" title="kari.hpp">kari.hpp</a> yang akan kita gunakan untuk fungsi kari.  Bagaimanapun, ada banyak hal yang menarik di dalam, jadi selamat datang! </p><a name="habracut"></a><br><h2 id="currying">  Kari </h2><br><p>  Jadi, apa itu kari?  Saya kira itu adalah salah satu kata yang Anda dengar dari programmer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Haskell">Haskell</a> sepanjang waktu (setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Monad">monad</a> , tentu saja).  Pada dasarnya, definisi istilah ini cukup sederhana, sehingga pembaca yang telah menulis pada bahasa jenis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="ML">ML</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Haskell">Haskell</a> , atau yang tahu apa artinya dari tempat lain, merasa bebas untuk melewati bagian ini. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Kari">Currying</a> - adalah teknik mengubah fungsi yang mengambil argumen N menjadi satu fungsi, yang mengambil argumen tunggal dan mengembalikan fungsi argumen berikutnya, dan terus berjalan sampai kita mengembalikan fungsi argumen terakhir, yang akan mewakili hasil keseluruhan.  Saya pikir ini membantu jika saya menunjukkan kepada Anda contoh: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rhs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }</code> </pre> <br><p>  Di sini kita memiliki fungsi penambahan biner.  Dan bagaimana jika kita ingin mengubahnya menjadi fungsi variabel tunggal?  Ini sebenarnya sangat sederhana: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curried_sum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lhs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum2(lhs, rhs); }; }</code> </pre> <br><p>  Tidak, apa yang kita lakukan?  Kami mengambil nilai berdasarkan argumen tunggal yang disebut lambda yang pada gilirannya mengambil argumen kedua dan melakukan penambahan itu sendiri.  Sebagai hasilnya, kita dapat menerapkan fungsi <strong><code>curried_sum2</code></strong> ke argumen kita satu per satu: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// output: 42 std::cout &lt;&lt; sum2(40, 2) &lt;&lt; std::endl; std::cout &lt;&lt; curried_sum2(40)(2) &lt;&lt; std::endl;</span></span></code> </pre> <br><p>  Dan itu sebenarnya inti dari operasi kari.  Tentu saja, dimungkinkan untuk melakukannya dengan fungsi apa pun - ini akan bekerja dengan cara yang sama.  Kami akan mengembalikan fungsi curiga argumen N-1 setiap kali kami mengambil nilai dari argumen lain: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2 + v3; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curried_sum3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v2){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v3){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum3(v1, v2, v3); }; }; } <span class="hljs-comment"><span class="hljs-comment">// output: 42 std::cout &lt;&lt; sum3(38, 3, 1) &lt;&lt; std::endl; std::cout &lt;&lt; curried_sum3(38)(3)(1) &lt;&lt; std::endl;</span></span></code> </pre> <br><h2 id="partial-application">  Aplikasi sebagian </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Aplikasi sebagian">Aplikasi parsial</a> - adalah cara memanggil fungsi argumen N ketika mereka hanya mengambil sebagian dari argumen dan mengembalikan fungsi lain dari argumen yang tersisa. </p><br><p>  Dalam hal ini perlu dicatat bahwa dalam bahasa seperti Haskell proses ini bekerja secara otomatis, di belakang punggung seorang programmer.  Apa yang kami coba lakukan di sini adalah untuk melakukannya secara eksplisit, <strong><code>sum3</code></strong> untuk memanggil fungsi <strong><code>sum3</code></strong> kita seperti ini: <strong><code>sum3(38,3)(1)</code></strong> atau mungkin seperti ini: <strong><code>sum3(38)(3,1)</code></strong> .  Selain itu, jika satu fungsi mengembalikan fungsi lain yang telah dikerjakan, ia dapat juga dipanggil menggunakan daftar argumen fungsi pertama.  Mari kita lihat contohnya: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> kari::curry(boo, v1 + v2); } <span class="hljs-comment"><span class="hljs-comment">// output: 42 std::cout &lt;&lt; kari::curry(foo)(38,3,1) &lt;&lt; std::endl; std::cout &lt;&lt; kari::curry(foo)(38,3)(1) &lt;&lt; std::endl; std::cout &lt;&lt; kari::curry(foo)(38)(3,1) &lt;&lt; std::endl;</span></span></code> </pre> <br><p>  Kami sebenarnya memiliki sedikit <a href="" title="kari.hpp">kemajuan di</a> sini, menunjukkan contoh penggunaan <a href="" title="kari.hpp">kari.hpp</a> , jadi ya, itu yang terjadi. </p><br><h2 id="setting-the-goals">  Menetapkan tujuan </h2><br><p>  Sebelum kita menulis sesuatu, penting (atau diinginkan) untuk memahami apa yang ingin kita miliki pada akhirnya.  Dan kami ingin memiliki kesempatan untuk menjelajah dan menerapkan sebagian fungsi apa pun yang dapat dipanggil dalam C ++.  Yaitu: </p><br><ul><li>  lambdas (termasuk yang generik) </li><li>  objek fungsi (functors) </li><li>  fungsi dari arity apa pun (termasuk templat) </li><li>  fungsi variadik </li><li>  metode kelas </li></ul><br><p>  Fungsi variadik dapat digulung dengan menentukan jumlah argumen yang ingin kita gulir.  Interaksi standar dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="std :: bind">std :: bind</a> dan hasilnya juga diinginkan.  Dan tentu saja, kita membutuhkan kesempatan untuk menerapkan fungsi multi-variabel dan memanggil fungsi bersarang sehingga sepertinya kita telah bekerja dengan satu fungsi yang digulung. </p><br><p>  Dan kita tidak boleh melupakan kinerja juga.  Kita perlu meminimalkan biaya komputasi pembungkus, transfer argumen dan penyimpanannya.  Ini berarti kita harus memindahkan alih-alih menyalin, menyimpan hanya apa yang benar-benar kita butuhkan, dan mengembalikan (dengan menghapus lebih lanjut) data secepat mungkin. </p><br><h3 id="author-youve-been-trying-to-invent-stdbind-one-again">  Penulis, Anda sudah mencoba untuk menciptakan <strong><code>std::bind</code></strong> satu lagi! </h3><br><p>  Ya dan tidak.  <strong><code>std::bind</code></strong> tidak diragukan lagi adalah alat yang ampuh dan terbukti, dan saya tidak bermaksud untuk menulis pembunuh atau alternatifnya.  Ya, itu dapat digunakan untuk aplikasi sebagian currying dan eksplisit (dengan menentukan dengan tepat argumen apa yang kami terapkan, dan di mana, dan berapa banyak).  Tapi itu pasti itu bukan pendekatan yang paling nyaman, belum lagi itu tidak selalu berlaku karena kita harus mengetahui arity fungsi dan menulis binding spesifik tergantung pada itu.  Sebagai contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2 + v3 + v4; } <span class="hljs-comment"><span class="hljs-comment">// std::bind auto c0 = std::bind(foo, _1, _2, _3, _4); auto c1 = std::bind(c0, 15, _1, _2, _3); auto c2 = std::bind(c1, 20, 2, _1); auto rr = c2(5); std::cout &lt;&lt; rr &lt;&lt; std::endl; // output: 42 // kari.hpp auto c0 = kari::curry(foo); auto c1 = c0(15); auto c2 = c1(20, 2); auto rr = c2(5); std::cout &lt;&lt; rr &lt;&lt; std::endl; // output: 42</span></span></code> </pre> <br><h2 id="api">  API </h2><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> kari { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curryV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curryN</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_curried</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F &gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_curried_v = is_curried&lt;F&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... As &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(As&amp;&amp;... as)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; }; }</code> </pre> <br><hr><br><p> <strong><code>kari::curry(F&amp;&amp; f, Args&amp;&amp;... args)</code></strong> </p> <br><p>  Mengembalikan objek fungsi tipe <strong><code>curry_t</code></strong> (fungsi <strong><code>curry_t</code></strong> ) dengan argumen argumen opsional yang diterapkan atau dengan hasil penerapan argumen ke fungsi yang diberikan <strong><code>f</code></strong> (apakah fungsinya adalah nullary, atau argumen yang ditransfer cukup untuk menyebutnya). </p><br><p>  Jika parameter <strong><code>f</code></strong> berisi fungsi yang telah dikerjakan, ia mengembalikan salinannya dengan argumen yang diterapkan. </p><br><hr><br><p> <strong><code>kari::curryV(F&amp;&amp; f, Args&amp;&amp;... args)</code></strong> </p> <br><p>  Memungkinkan untuk menjelajah fungsi dengan sejumlah variabel argumen.  Setelah itu fungsi-fungsi ini dapat dipanggil menggunakan <strong><code>()</code></strong> operator tanpa argumen.  Sebagai contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c0 = kari::curryV(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>, <span class="hljs-string"><span class="hljs-string">"%d + %d = %d"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c1 = c0(<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c2 = c1(<span class="hljs-number"><span class="hljs-number">42</span></span>); c2(); <span class="hljs-comment"><span class="hljs-comment">// output: 37 + 5 = 42</span></span></code> </pre> <br><p>  Jika <strong><code>f</code></strong> parameter berisi fungsi yang telah digulung, ia mengembalikan salinannya dengan jenis aplikasi yang diubah untuk jumlah variabel variabel dengan argumen yang diterapkan <strong><code>args</code></strong> . </p><br><hr><br><p> <strong><code>kari::curryN(F&amp;&amp; f, Args&amp;&amp;... args)</code></strong> </p> <br><p>  Memungkinkan untuk menjelajah fungsi dengan jumlah variabel argumen dengan menentukan angka pasti <strong><code>N</code></strong> dari argumen yang ingin kita terapkan (kecuali yang diberikan dalam <strong><code>args</code></strong> ).  Sebagai contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">256</span></span>] = {<span class="hljs-string"><span class="hljs-string">'\0'</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = kari::curryN&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>, buffer, <span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-string"><span class="hljs-string">"%d + %d = %d"</span></span>); c(<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; buffer &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// output: 37 + 5 = 42</span></span></code> </pre> <br><p>  Jika parameter <strong><code>f</code></strong> berisi fungsi yang telah dikerjakan, ia mengembalikan salinannya dengan jenis aplikasi yang diubah untuk argumen N dengan argumen yang digunakan argumen. </p><br><hr><br><p> <strong><code>kari::is_curried&lt;F&gt;, kari::is_curried_v&lt;F&gt;</code></strong> </p> <br><p>  Beberapa struktur bantu untuk memeriksa apakah suatu fungsi telah dikerjakan.  Sebagai contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> l = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v1, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v2){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = curry(l); <span class="hljs-comment"><span class="hljs-comment">// output: is `l` curried? no std::cout &lt;&lt; "is `l` curried? " &lt;&lt; (is_curried&lt;decltype(l)&gt;::value ? "yes" : "no") &lt;&lt; std::endl; // output: is `c` curried? yes std::cout &lt;&lt; "is `c` curried? " &lt;&lt; (is_curried_v&lt;decltype(c)&gt; ? "yes" : "no") &lt;&lt; std::endl;</span></span></code> </pre> <br><hr><br><p> <strong><code>kari::curry_t::operator()(As&amp;&amp;... as)</code></strong> </p> <br><p>  Operator memungkinkan aplikasi fungsi kari penuh atau sebagian.  Mengembalikan fungsi kari argumen tersisa dari fungsi awal <strong><code>F</code></strong> , atau nilai fungsi ini diperoleh dengan penerapannya di tumpukan argumen lama dan argumen baru <strong><code>as</code></strong> .  Sebagai contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2 + v3 + v4; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c0 = kari::curry(foo); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c1 = c0(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-comment"><span class="hljs-comment">// partial application auto rr = c1(2, 5); // function call - foo(15,20,2,5) std::cout &lt;&lt; rr &lt;&lt; std::endl; // output: 42</span></span></code> </pre> <br><p>  Jika Anda memanggil fungsi <strong><code>curryV</code></strong> tanpa argumen menggunakan <strong><code>curryV</code></strong> atau <strong><code>curryN</code></strong> , itu akan dipanggil jika ada cukup argumen.  Jika tidak, itu akan mengembalikan fungsi yang diterapkan sebagian.  Sebagai contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c0 = kari::curryV(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>, <span class="hljs-string"><span class="hljs-string">"%d + %d = %d"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c1 = c0(<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c2 = c1(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// force call variadic function std::printf c2(); // output: 37 + 5 = 42</span></span></code> </pre> <br><h2 id="details-of-implementation">  Detail implementasi </h2><br><p>  Ketika memberi Anda detail implementasi, saya akan menggunakan C ++ 17 untuk menjaga agar teks artikelnya singkat dan menghindari penjelasan yang tidak perlu dan menumpuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="SFINAE">SFINAE</a> , serta contoh implementasi yang harus saya tambahkan dalam C ++ 14 standar.  Semua ini dapat Anda temukan di <a href="" title="kari.hpp">repositori</a> proyek, di mana Anda juga dapat menambahkannya ke favorit Anda :) </p><br><hr><br><p> <strong><code>make_curry(F&amp;&amp; f, std::tuple&lt;Args...&gt;&amp;&amp; args)</code></strong> </p> <br><p>  Fungsi bantu yang membuat objek fungsi <strong><code>curry_t</code></strong> atau menerapkan fungsi yang diberikan <strong><code>f</code></strong> ke argumen <strong><code>args</code></strong> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_curry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;Args...&gt;&amp;&amp; args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( N == </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_invocable_v&lt;F, Args...&gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt;(f), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(args)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">curry_t</span></span>&lt; N, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;F&gt;, Args... &gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt;(f), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(args)); } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_curry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_curry&lt;N&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt;(f), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple()); }</code> </pre> <br><p>  Sekarang, ada dua hal menarik tentang fungsi ini: </p><br><ul><li>  kami menerapkannya pada argumen hanya jika itu dapat diaktifkan untuk argumen ini dan aplikasi counter <strong><code>N</code></strong> adalah nol </li><li>  jika fungsi tidak dapat dipanggil, kami menganggap panggilan ini sebagai aplikasi parsial dan membuat objek fungsi <strong><code>curry_t</code></strong> berisi fungsi dan argumen </li></ul><br><hr><br><p> <strong><code>struct curry_t</code></strong> </p> <br><p>  Objek fungsi seharusnya menyimpan simpanan argumen dan fungsi yang akan kita panggil saat menerapkannya pada akhirnya.  Objek ini adalah apa yang akan kita panggil dan terapkan sebagian. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curry_t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(U&amp;&amp; u, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;Args...&gt;&amp;&amp; args)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;U&gt;(u))</span></span></span><span class="hljs-function"> , </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(args))</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: F f_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Args...&gt; args_; };</code> </pre> <br><p>  Ada sejumlah alasan mengapa kita menyimpan simpanan argumen <strong><code>args_</code></strong> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="std :: tuple">std :: tuple</a> : </p><br><p>  1) situasi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="std :: ref">std :: ref</a> ditangani secara otomatis untuk menyimpan referensi ketika kita perlu, secara default berdasarkan nilai <br>  2) aplikasi fungsi yang sesuai dengan argumennya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="std :: melamar">std :: apply</a> ) <br>  3) readymade, jadi Anda tidak harus menulisnya dari awal :) </p><br><p>  Kami telah menyimpan objek yang kami panggil dan fungsi <strong><code>f_</code></strong> berdasarkan nilainya juga, dan berhati-hati saat memilih jenis ketika membuat satu (saya akan memperluas masalah ini di bawah), atau memindahkan, atau menyalinnya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="referensi universal">referensi universal</a> di konstruktor. </p><br><p>  Parameter templat <strong><code>N</code></strong> bertindak sebagai penghitung aplikasi untuk fungsi variadik. </p><br><hr><br><p> <strong><code>curry_t::operator()(const As&amp;...)</code></strong> </p> <br><p>  Dan, tentu saja, hal yang membuat semuanya berfungsi - operator yang memanggil objek fungsi. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1 constexpr decltype(auto) operator()() &amp;&amp; { return detail::make_curry&lt;0&gt;( std::move(f_), std::move(args_)); } // 2 template &lt; typename A &gt; constexpr decltype(auto) operator()(A&amp;&amp; a) &amp;&amp; { return detail::make_curry&lt;(N &gt; 0 ? N - 1 : 0)&gt;( std::move(f_), std::tuple_cat( std::move(args_), std::make_tuple(std::forward&lt;A&gt;(a)))); } // 3 template &lt; typename A, typename... As &gt; constexpr decltype(auto) operator()(A&amp;&amp; a, As&amp;&amp;... as) &amp;&amp; { return std::move(*this)(std::forward&lt;A&gt;(a))(std::forward&lt;As&gt;(as)...); } // 4 template &lt; typename... As &gt; constexpr decltype(auto) operator()(As&amp;&amp;... as) const &amp; { auto self_copy = *this; return std::move(self_copy)(std::forward&lt;As&gt;(as)...); } }</span></span></code> </pre> <br><p>  Operator panggilan memiliki empat fungsi kelebihan beban. </p><br><ol><li><p>  Sebuah fungsi tanpa parameter yang memungkinkan untuk mulai menerapkan fungsi variadic (dibuat oleh <strong><code>curryV</code></strong> atau <strong><code>curryN</code></strong> ).  Di sini kita mengurangi penghitung aplikasi menjadi nol, sehingga memperjelas bahwa fungsi tersebut siap untuk diterapkan, dan kemudian kita memberikan semua yang diperlukan untuk fungsi <strong><code>make_curry</code></strong> . </p><br></li><li><p>  Fungsi argumen tunggal yang mengurangi penghitung aplikasi sebanyak 1 (jika tidak nol) dan menempatkan argumen baru kami di tumpukan argumen <strong><code>args_</code></strong> dan mentransfer semua ini ke <strong><code>make_curry</code></strong> . </p><br></li><li><p>  Fungsi variadik yang sebenarnya merupakan trik untuk aplikasi parsial berbagai argumen.  Apa yang dilakukannya adalah menerapkannya secara rekursif, satu per satu.  Sekarang, ada dua alasan mengapa mereka tidak dapat diterapkan sekaligus: </p><br><ul><li>  penghitung aplikasi dapat turun ke nol sebelum tidak ada argumen yang tersisa </li><li>  fungsi <strong><code>f_</code></strong> dapat dipanggil lebih awal dan mengembalikan fungsi curried lainnya, sehingga semua argumen selanjutnya akan ditujukan untuk itu </li></ul><br></li><li><p>  Fungsi terakhir bertindak sebagai jembatan antara memanggil <strong><code>curry_t</code></strong> menggunakan <em>lvalue</em> dan memanggil fungsi menggunakan <em>rvalue</em> . </p><br></li></ol><br><p>  Tag fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="ref-kualifikasi">ref-kualifikasi</a> membuat seluruh proses hampir ajaib.  Singkatnya, dengan bantuan mereka, kami mengetahui bahwa sebuah objek dipanggil menggunakan <em>rvalue</em> reference dan kami hanya bisa memindahkan argumen alih-alih menyalinnya di fungsi memanggil akhir <strong><code>make_curry</code></strong> .  Kalau tidak, kita harus menyalin argumen agar masih memiliki kesempatan untuk memanggil fungsi ini lagi, memastikan argumen masih ada. </p><br><h2 id="bonuses">  Bonus </h2><br><p>  Sebelum melanjutkan ke kesimpulan, saya ingin menunjukkan kepada Anda beberapa contoh gula sintaksis yang mereka miliki di <a href="" title="kari.hpp">kari.hpp</a> yang dapat dikualifikasikan sebagai bonus. </p><br><h3 id="operator-sections">  Bagian operator </h3><br><p>  Programmer yang sudah bekerja dengan Haskell harus terbiasa dengan bagian operator yang memungkinkan untuk memberikan deskripsi singkat tentang operator yang diterapkan.  Misalnya, struktur <strong><code>(*2)</code></strong> , menghasilkan fungsi argumen tunggal, mengembalikan hasil perkalian argumen ini dengan 2. Jadi, yang saya inginkan adalah mencoba menulis sesuatu seperti itu di C ++.  Tidak lebih cepat dikatakan daripada dilakukan! </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> kari::underscore; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::accumulate(v.begin(), v.end(), <span class="hljs-number"><span class="hljs-number">0</span></span>, _+_); <span class="hljs-comment"><span class="hljs-comment">// result: 15 std::transform(v.begin(), v.end(), v.begin(), _*2); // v = 2, 3, 6, 8, 10 std::transform(v.begin(), v.end(), v.begin(), -_); // v = -2,-3,-6,-8,-10</span></span></code> </pre> <br><h3 id="function-composition">  Komposisi fungsi </h3><br><p>  Dan tentu saja saya tidak akan menjadi gila jika saya belum mencoba menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Komposisi fungsi">komposisi fungsi</a> .  Sebagai operator komposisi saya memilih <strong><code>operator *</code></strong> sebagai yang terdekat (dengan melihatnya) dari semua simbol yang tersedia untuk tanda komposisi dalam matematika.  Saya menggunakannya untuk menerapkan fungsi yang dihasilkan untuk argumen juga.  Jadi, itulah yang saya dapat: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> kari::underscore; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; (_*2) * (_+2) * 4 &lt;&lt; std::endl; // output: 12 // 2 std::cout &lt;&lt; 4 * (_*2) * (_+2) &lt;&lt; std::endl; // output: 10</span></span></code> </pre> <br><ol><li>  komposisi fungsi <strong><code>(*2)</code></strong> dan <strong><code>(+2)</code></strong> diterapkan ke <strong><code>4</code></strong> . <strong><code>(4 + 2) * 2 = 12</code></strong> </li><li>  fungsi <strong><code>(*2)</code></strong> diterapkan ke <strong><code>4</code></strong> dan kemudian kami menerapkan <strong><code>(+2)</code></strong> untuk hasilnya. <strong><code>(4 * 2 + 2) = 10</code></strong> </li></ol><br><p>  Cara yang sama Anda dapat membangun komposisi yang cukup rumit dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Gaya pointfree">gaya pointfree</a> , tetapi ingatlah hanya programmer Haskell yang akan memahami ini :) </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// (. (+2)) (*2) $ 10 == 24 // haskell analog std::cout &lt;&lt; (_*(_+2))(_*2) * 10 &lt;&lt; std::endl; // output: 24 // ((+2) .) (*2) $ 10 == 22 // haskell analog std::cout &lt;&lt; ((_+2)*_)(_*2) * 10 &lt;&lt; std::endl; // output: 22</span></span></code> </pre> <br><h2 id="conclusion">  Kesimpulan </h2><br><p>  Saya pikir sudah cukup jelas sebelumnya bahwa tidak perlu menggunakan teknik ini dalam proyek nyata.  Tapi tetap saja, saya harus menyebutkan itu.  Lagipula, tujuan saya adalah membuktikan diri dan memeriksa standar C ++ yang baru.  Apakah saya dapat melakukan ini?  Dan akankah C ++?  Ya, saya kira, Anda baru saja melihat bahwa kami berdua telah melakukan itu.  Dan saya sangat berterima kasih kepada semua orang yang membaca semuanya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436488/">https://habr.com/ru/post/id436488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436476/index.html">Cloud untuk perusahaan asuransi</a></li>
<li><a href="../id436480/index.html">Saya membuat bot yang berkomunikasi dengan perekrut untuk saya, dan saya suka</a></li>
<li><a href="../id436482/index.html">Lanjutan Three.js: bahan shader dan pasca-pemrosesan</a></li>
<li><a href="../id436484/index.html">Di mana menemukan pengaturan DNS pada MacOS</a></li>
<li><a href="../id436486/index.html">Apa yang terjadi di pasar podcast audio</a></li>
<li><a href="../id436490/index.html">Motorola berencana untuk memperkenalkan inkarnasi Razr v3</a></li>
<li><a href="../id436492/index.html">Kami mencari pembicara di Mitap DIY ke-10 17 Februari 2019</a></li>
<li><a href="../id436494/index.html">Mengganti disk sambil mempertahankan penomoran yang tepat dalam CEPH</a></li>
<li><a href="../id436496/index.html">PVS-Studio untuk Java</a></li>
<li><a href="../id436498/index.html">Perangkat Lunak AG: Tidak Hanya ARIS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>