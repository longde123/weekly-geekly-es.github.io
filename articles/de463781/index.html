<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèæ ‚öôÔ∏è üë®‚Äçüíº Zen-isolierte Komponenten in der Android-Architektur üßìüèΩ üëâüèª üö∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Jahren haben wir bei Badoo begonnen, den MVI-Ansatz f√ºr die Android-Entwicklung zu verwenden. Es sollte eine komplexe Codebasis vereinfach...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zen-isolierte Komponenten in der Android-Architektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/463781/"><img src="https://habrastorage.org/webt/0f/iz/h0/0fizh0eukxdsz6kb0zxcjiw5878.jpeg"><br><br>  Vor einigen Jahren haben wir bei Badoo begonnen, den MVI-Ansatz f√ºr die Android-Entwicklung zu verwenden.  Es sollte eine komplexe Codebasis vereinfachen und das Problem falscher Zust√§nde vermeiden: In einfachen Szenarien ist es einfach, aber je komplexer das System ist, desto schwieriger ist es, es in der richtigen Form zu halten und desto leichter ist es, einen Fehler zu √ºbersehen. <br><br>  In Badoo sind alle Anwendungen asynchron - nicht nur aufgrund der umfangreichen Funktionalit√§t, die dem Benutzer √ºber die Benutzeroberfl√§che zur Verf√ºgung steht, sondern auch aufgrund der M√∂glichkeit, dass Einwegdaten vom Server gesendet werden.  Bei Verwendung des alten Ansatzes in unserem Chat-Modul stie√üen wir auf einige seltsame, schwer zu reproduzierende Fehler, f√ºr deren Beseitigung wir viel Zeit aufwenden mussten. <br><br>  Unser Kollege Zsolt Kocsi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Medium</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter</a> ) vom Londoner B√ºro erkl√§rte, wie wir mit MVI unabh√§ngige Komponenten erstellen, die einfach wiederzuverwenden sind, welche Vorteile wir erhalten und welche Nachteile wir bei diesem Ansatz festgestellt haben. <a name="habracut"></a><br><br>  Dies ist der dritte Artikel in einer Reihe von Artikeln √ºber die Badoo Android-Architektur.  Links zu den ersten beiden: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moderne MVI-Architektur basierend auf Kotlin</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufbau eines reaktiven Komponentensystems mit Kotlin</a> . <br></li></ol><br><h2>  Verweilen Sie nicht bei schlecht angeschlossenen Komponenten. </h2><br>  Eine schwache Konnektivit√§t wird als besser als stark angesehen.  Wenn Sie sich nur auf Schnittstellen und nicht auf bestimmte Implementierungen verlassen, ist es f√ºr Sie einfacher, Komponenten auszutauschen. Es ist einfacher, zu anderen Implementierungen zu wechseln, ohne den gr√∂√üten Teil des Codes neu zu schreiben, was das Einschlie√üen von Komponententests vereinfacht. <br><br>  Wir enden normalerweise hier und sagen, dass wir alles getan haben, was die Konnektivit√§t betrifft. <br><br>  Dieser Ansatz ist jedoch nicht optimal.  Angenommen, Sie haben eine Klasse A, die die Funktionen von drei anderen Klassen nutzen muss: B, C und D. Selbst wenn Sie √ºber Schnittstellen auf sie verweisen, wird Klasse A mit jeder dieser Klassen schwieriger: <br><br><ul><li>  Er kennt alle Methoden in allen Schnittstellen, ihre Namen und R√ºckgabetypen, auch wenn er sie nicht verwendet. <br></li><li>  Wenn Sie A testen, m√ºssen Sie mehr Mocks konfigurieren ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mock-Objekt</a> ). <br></li><li>  Es ist schwieriger, A wiederholt in anderen Kontexten zu verwenden, in denen wir B, C und D nicht haben oder nicht haben wollen. <br></li></ul><br>  Nat√ºrlich muss genau die Klasse A den daf√ºr erforderlichen Mindestsatz an Schnittstellen bestimmen (Prinzip der Schnittstellentrennung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SOLID</a> ).  In der Praxis mussten wir uns jedoch alle mit Situationen befassen, in denen der Einfachheit halber ein anderer Ansatz gew√§hlt wurde: Wir haben eine vorhandene Klasse verwendet, die einige Funktionen implementiert, alle √∂ffentlichen Methoden in die Schnittstelle extrahiert und diese Schnittstelle dann dort verwendet, wo die erw√§hnte Klasse ben√∂tigt wurde.  Das hei√üt, die Schnittstelle wurde nicht auf der Grundlage dessen verwendet, was diese Komponente ben√∂tigt, sondern auf der Grundlage dessen, was eine andere Komponente bieten kann. <br><br>  Mit diesem Ansatz verschlechtert sich die Situation im Laufe der Zeit.  Jedes Mal, wenn wir neue Funktionen hinzuf√ºgen, werden unsere Klassen in einem Netz neuer Schnittstellen verkn√ºpft, √ºber die sie Bescheid wissen m√ºssen.  Die Klassen werden immer gr√∂√üer und das Testen wird immer schwieriger. <br><br>  Wenn Sie sie in einem anderen Kontext verwenden m√ºssen, ist es daher fast unm√∂glich, sie ohne all dieses Gewirr, mit dem sie verbunden sind, zu verschieben, selbst √ºber Schnittstellen.  Sie k√∂nnen eine Analogie ziehen: Sie m√∂chten eine Banane verwenden, die sich in den H√§nden eines Affen befindet, der an einem Baum h√§ngt. Wenn Sie also die Banane beladen, erhalten Sie ein ganzes St√ºck des Dschungels.  Kurz gesagt, der √úbertragungsprozess nimmt viel Zeit in Anspruch, und bald fragen Sie sich, warum es in der Praxis so schwierig ist, den Code wiederzuverwenden. <br><br><h2>  Black-Box-Komponenten </h2><br>  Wenn die Komponente einfach und wiederverwendbar sein soll, m√ºssen wir dazu nicht zwei Dinge wissen: <br><br><ul><li>  dar√ºber, wo es sonst verwendet wird; <br></li><li>  √ºber andere Komponenten, die nicht mit der internen Implementierung zusammenh√§ngen. <br></li></ul><br>  Der Grund ist klar: Wenn Sie nichts √ºber die Au√üenwelt wissen, werden Sie nicht mit ihr verbunden sein. <br><br>  Was wir wirklich von der Komponente wollen: <br><br><ul><li>  Definieren Sie Ihre eigenen Eingabe- (Eingabe) und Ausgabedaten (Ausgabe). <br></li><li>  Denken Sie nicht dar√ºber nach, woher diese Daten stammen oder wohin sie gehen. <br></li><li>  Es muss autark sein, damit wir die interne Struktur der Komponente f√ºr ihre Verwendung nicht kennen m√ºssen. <br></li></ul><br>  Sie k√∂nnen die Komponente als Black Box oder integrierte Schaltung betrachten.  Sie hat Eingangs- und Ausgangskontakte.  Sie l√∂ten sie - und die Mikroschaltung wird Teil eines Systems, von dem sie nichts wei√ü. <br><br><img src="https://habrastorage.org/webt/ol/fy/04/olfy04qy7hmdfupiqifwqfx9jwa.jpeg"><br><br>  Bisher wurde angenommen, dass es sich um bidirektionale Datenstr√∂me handelt: Wenn Klasse A etwas ben√∂tigt, extrahiert sie eine Methode √ºber die Schnittstelle B und empf√§ngt das Ergebnis in Form des von der Funktion zur√ºckgegebenen Werts. <br><br><img src="https://habrastorage.org/webt/yb/1s/4k/yb1s4ksgh4k3adpupkm9bkiiem0.png"><br><br>  Aber dann wei√ü A √ºber B Bescheid und wir wollen dies vermeiden. <br><br>  Nat√ºrlich ist ein solches Schema f√ºr Implementierungsfunktionen auf niedriger Ebene sinnvoll.  Wenn wir jedoch eine wiederverwendbare Komponente ben√∂tigen, die wie eine in sich geschlossene Black Box funktioniert, m√ºssen wir sicherstellen, dass sie nichts √ºber externe Schnittstellen, Methodennamen oder R√ºckgabewerte wei√ü. <br><br><h2>  Wir gehen zur Unidirektionalit√§t √ºber </h2><br>  Aber ohne Schnittstellennamen und Methoden k√∂nnen wir nichts aufrufen!  Alles, was bleibt, ist die Verwendung eines unidirektionalen Datenstroms, in dem wir einfach Eingaben erhalten und Ausgaben generieren: <br><br><img src="https://habrastorage.org/webt/3p/zy/_m/3pzy_micni9yxdstnff6m3ilfxw.png"><br><br>  Auf den ersten Blick mag dies wie eine Einschr√§nkung aussehen, aber eine solche L√∂sung hat viele Vorteile, auf die weiter unten eingegangen wird. <br><br>  Aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel</a> wissen wir, dass Features (Feature) ihre eigenen Eingabedaten (Wish) und ihre eigenen Ausgabedaten (State) definieren.  Daher spielt es f√ºr sie keine Rolle, woher der Wunsch kommt oder wohin der Staat geht. <br><br><img src="https://habrastorage.org/webt/aw/wn/c0/awwnc0nkjkhiedmyxd00ovtdhrw.png"><br><br>  Das brauchen wir!  Features k√∂nnen √ºberall dort verwendet werden, wo Sie sie eingeben k√∂nnen, und mit der Ausgabe k√∂nnen Sie tun, was Sie wollen.  Und da Funktionen nicht direkt mit anderen Komponenten kommunizieren, handelt es sich um eigenst√§ndige und nicht verwandte Module. <br><br>  Nehmen Sie nun die Ansicht und gestalten Sie sie so, dass sie auch ein eigenst√§ndiges Modul ist. <br><br>  Erstens sollte die Ansicht so einfach wie m√∂glich sein, damit sie nur ihre internen Aufgaben ausf√ºhren kann. <br><br>  Welche Art von Aufgaben?  Es gibt zwei davon: <br><br><ul><li>  Rendern von ViewModel (Eingabe); <br></li><li>  Ausl√∂sen von ViewEvents abh√§ngig von Benutzeraktionen (Ausgabe). <br></li></ul><br>  Warum ViewModel verwenden?  Warum nicht direkt den Status des Features zeichnen? <br><br><ul><li>  Das (Nicht-) Anzeigen einer Funktion auf dem Bildschirm ist nicht Teil der Implementierung.  View sollte sich selbst rendern k√∂nnen, wenn die Daten aus mehreren Quellen stammen. <br></li><li>  Die Komplexit√§t des Status in der Ansicht muss nicht ber√ºcksichtigt werden.  Das ViewModel sollte nur die anzeigefertigen Informationen enthalten, die erforderlich sind, um es einfach zu halten. <br></li></ul><br>  View sollte sich auch nicht f√ºr Folgendes interessieren: <br><br><ul><li>  Woher kommen all diese ViewModels? <br></li><li>  Was passiert, wenn das ViewEvent ausgel√∂st wird? <br></li><li>  jede Gesch√§ftslogik; <br></li><li>  analytisches Tracking; <br></li><li>  Journaling <br></li><li>  andere Aufgaben. <br></li></ul><br>  All dies sind externe Aufgaben, und View sollte nicht mit ihnen verbunden sein.  Lassen Sie uns anhalten und die Einfachheit der Ansicht zusammenfassen: <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooView</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bgColor: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ButtonClicked : Event() <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextFocusChanged</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasFocus: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : Event() } }</code> </pre> <br>  Eine Android-Implementierung sollte: <br><br><ol><li>  Finden Sie Android-Ansichten anhand ihrer ID. <br></li><li>  Implementieren Sie die accept-Methode der Consumer-Schnittstelle, indem Sie den Wert im ViewModel festlegen. <br></li><li>  Stellen Sie Listener (ClickListener) so ein, dass sie mit der Benutzeroberfl√§che interagieren, um bestimmte Ereignisse zu generieren. <br></li></ol><br>  Ein Beispiel: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooViewImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@JvmOverloads</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( context: Context, attrs: AttributeSet? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, defStyle: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events: PublishRelay&lt;Event&gt; = PublishRelay.create&lt;Event&gt;() ) : LinearLayout(context, attrs, defStyle), FooView, <span class="hljs-comment"><span class="hljs-comment">// delegate implementing ObservableSource to our Relay ObservableSource&lt;Event&gt; by events { // 1. find the views private val title: TextView by lazy { findViewById&lt;TextView&gt;(R.id.title)} private val panel: ViewGroup by lazy { findViewById&lt;ViewGroup&gt;(R.id.panel)} private val button: Button by lazy { findViewById&lt;Button&gt;(R.id.button)} private val editText: EditText by lazy { findViewById&lt;EditText&gt;(R.id.editText)} // 2. set listeners to trigger Events override fun onFinishInflate() { super.onFinishInflate() button.setOnClickListener { events.accept(Event.ButtonClicked) } editText.setOnFocusChangeListener { _, hasFocus -&gt; events.accept(Event.TextFocusChanged(hasFocus)) } } // 3. render the ViewModel override fun accept(vm: ViewModel) { title.text = vm.title panel.setBackgroundColor(ContextCompat.getColor(context, vm.bgColor)) } }</span></span></code> </pre><br>  Wenn nicht auf Funktion und Ansicht beschr√§nkt, sieht jede andere Komponente mit diesem Ansatz folgenderma√üen aus: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericBlackBoxComponent</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Input</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Output</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  Jetzt ist alles klar mit dem Muster! <br><br><img src="https://habrastorage.org/webt/pt/pi/pb/ptpipbdlny1tekgwhhgnwu3pg2q.png"><br><br><h2>  Vereinigt euch, vereint euch, vereint euch! </h2><br>  Aber was ist, wenn wir unterschiedliche Komponenten haben und jede ihre eigene Eingabe und Ausgabe hat?  Wir werden sie verbinden! <br><br>  Gl√ºcklicherweise kann dies leicht mit Hilfe von Binder durchgef√ºhrt werden, was auch dazu beitr√§gt, den richtigen Bereich zu erstellen, wie wir aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten Artikel</a> wissen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// will automatically dispose of the created rx subscriptions when the lifecycle ends: val binder = Binder(lifecycle) // connect some observable sources to some consumers with element transformation: binder.bind(outputA to inputB using transformer1) binder.bind(outputB to inputA using transformer2)</span></span></code> </pre><br><h2>  Der erste Vorteil: einfach ohne √Ñnderungen zu erweitern </h2><br>  Durch die Verwendung nicht verwandter Komponenten in Form von Blackboxes, die nur vor√ºbergehend verbunden sind, k√∂nnen wir neue Funktionen hinzuf√ºgen, ohne vorhandene Komponenten zu √§ndern. <br><br>  Nehmen Sie ein einfaches Beispiel: <br><br><img src="https://habrastorage.org/webt/qz/py/4j/qzpy4jxjtbnceillcf05-jay_ym.png"><br><br>  Hier werden Features (F) und View (V) einfach miteinander verbunden. <br><br>  Die entsprechenden Bindungen sind: <br><br><pre> <code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer) bind(view to feature using uiEventToWishTransformer)</code> </pre> <br><br>  Angenommen, wir m√∂chten diesem System die Verfolgung einiger UI-Ereignisse hinzuf√ºgen. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AnalyticsTracker : Consumer&lt;AnalyticsTracker.Event&gt; { <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ProfileImageClicked: Event() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> EditButtonClicked : Event() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsTracker</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// TODO Implement actual tracking } }</span></span></code> </pre><br>  Die gute Nachricht ist, dass wir dies einfach tun k√∂nnen, indem wir den vorhandenen Ausgabeansichtskanal wiederverwenden: <br><br><img src="https://habrastorage.org/webt/en/sz/ld/enszldmuacqrd0e7wmumdm_duoi.png"><br><br>  Im Code sieht es so aus: <br><br><pre> <code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer) bind(view to feature using uiEventToWishTransformer) <span class="hljs-comment"><span class="hljs-comment">// +1 line, nothing else changed: bind(view to analyticsTracker using uiEventToAnalyticsEventTransformer)</span></span></code> </pre><br>  Neue Funktionen k√∂nnen mit nur einer zus√§tzlichen Bindungszeile hinzugef√ºgt werden.  Jetzt k√∂nnen wir nicht nur eine einzelne Codezeile nicht √§ndern, sondern wissen auch nicht, dass die Ausgabe zur L√∂sung eines neuen Problems verwendet wird. <br><br>  Jetzt f√§llt es uns nat√ºrlich leichter, zus√§tzliche Sorgen und unn√∂tig komplizierte Komponenten zu vermeiden.  Sie bleiben einfach.  Sie k√∂nnen dem System Funktionen hinzuf√ºgen, indem Sie einfach Komponenten mit vorhandenen verbinden. <br><br><h2>  Zweiter Vorteil: einfach wiederholt zu bedienen </h2><br>  Am Beispiel von Feature und Ansicht ist deutlich zu erkennen, dass wir mit nur einer Zeile mit Bindung eine neue Eingabequelle oder einen neuen Konsumenten von Ausgabedaten hinzuf√ºgen k√∂nnen.  Dies erleichtert die Wiederverwendung von Komponenten in verschiedenen Teilen der Anwendung erheblich. <br><br>  Dieser Ansatz ist jedoch nicht auf Klassen beschr√§nkt.  Diese Art der Verwendung von Schnittstellen erm√∂glicht es uns, in sich geschlossene reaktive Komponenten jeder Gr√∂√üe zu beschreiben. <br><br>  Indem wir uns auf bestimmte Eingabe- und Ausgabedaten beschr√§nken, m√ºssen wir nicht mehr wissen, wie alles unter der Haube funktioniert, und vermeiden daher leicht, versehentlich die Interna von Komponenten mit anderen Teilen des Systems zu verkn√ºpfen.  Und ohne Bindung k√∂nnen Sie Komponenten einfach und einfach wiederholt verwenden. <br><br>  Wir werden in einem der folgenden Artikel darauf zur√ºckkommen und Beispiele f√ºr die Verwendung dieser Technik zum Verbinden √ºbergeordneter Komponenten betrachten. <br><br><h2>  Erste Frage: Wo sollen die Bindungen platziert werden? </h2><br><ol><li>  W√§hlen Sie die Abstraktionsebene.  Abh√§ngig von der Architektur kann dies eine Aktivit√§t, ein Fragment oder ein ViewController sein.  Ich hoffe, Sie haben noch eine gewisse Abstraktionsebene in den Teilen, in denen es keine Benutzeroberfl√§che gibt.  Zum Beispiel in einigen Bereichen des DI-Kontextbaums. <br></li><li>  Erstellen Sie eine separate Klasse f√ºr die Bindung auf derselben Ebene wie dieser Teil der Benutzeroberfl√§che.  Wenn es sich um FooActivity, FooFragment oder FooViewController handelt, k√∂nnen Sie FooBindings daneben platzieren. <br></li><li>  Stellen Sie sicher, dass Sie FooBindings in dieselben Komponenteninstanzen einbetten, die Sie in der Aktivit√§t, im Fragment usw. verwenden. <br></li><li>  Verwenden Sie die Aktivit√§t oder den Fragmentlebenszyklus, um den Umfang der Bindungen zu bestimmen.  Wenn diese Schleife nicht an Android gebunden ist, k√∂nnen Sie Trigger manuell erstellen, z. B. beim Erstellen oder Zerst√∂ren eines DI-Bereichs.  Weitere Beispiele f√ºr den Umfang sind im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten Artikel beschrieben</a> . <br></li></ol><br><h3>  Zweite Frage: Testen </h3><br>  Da unsere Komponente nichts √ºber andere wei√ü, ben√∂tigen wir normalerweise keine Stubs.  Die Tests werden vereinfacht, um die korrekte Reaktion der Komponente auf die Eingabedaten zu √ºberpr√ºfen und die erwarteten Ergebnisse zu erzielen. <br><br>  Im Fall von Feature bedeutet dies: <br><br><ul><li>  die F√§higkeit zu testen, ob bestimmte Eingabedaten den erwarteten Zustand (Ausgabe) erzeugen. <br></li></ul><br>  Und im Fall von View: <br><br><ul><li>  Wir k√∂nnen testen, ob ein bestimmtes ViewModel (Eingabe) zum erwarteten Status der Benutzeroberfl√§che f√ºhrt. <br></li><li>  Wir k√∂nnen testen, ob die Simulation der Interaktion mit der Benutzeroberfl√§che zu einer Initialisierung im erwarteten ViewEvent (Ausgabe) f√ºhrt. <br></li></ul><br>  Nat√ºrlich verschwinden Wechselwirkungen zwischen Komponenten nicht auf magische Weise.  Wir haben diese Aufgaben gerade aus den Komponenten selbst extrahiert.  Sie m√ºssen noch getestet werden.  Aber wo? <br><br>  In unserem Fall sind Bindemittel f√ºr den Anschluss der Komponenten verantwortlich: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// this is wherever you put your bindings, depending on your architecture class BindingEnvironment( private val component1: Component1, private val component2: Component2 ) { fun createBindings(lifecycle: Lifecycle) { val binder = Binder(lifecycle) binder.bind(component1 to component2 using Transformer()) } }</span></span></code> </pre><br>  Unsere Tests sollten Folgendes best√§tigen: <br><br>  1. Transformatoren (Mapper). <br><br>  Einige Verbindungen haben Mapper, und Sie m√ºssen sicherstellen, dass sie Elemente korrekt konvertieren.  In den meisten F√§llen reicht hierf√ºr ein sehr einfacher Unit-Test aus, da die Mapper meist auch sehr einfach sind: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCase1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> transformer = Transformer() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testInput = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actualOutput = transformer.invoke(testInput) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expectedOutput = TODO() assertEquals(expectedOutput, actualOutput) }</code> </pre><br>  2. Kommunikation. <br><br>  Sie m√ºssen sicherstellen, dass die Verbindungen korrekt konfiguriert sind.  Was ist der Sinn der Arbeit einzelner Komponenten und Mapper, wenn aus irgendeinem Grund die Verbindung zwischen ihnen nicht hergestellt wurde?  All dies kann getestet werden, indem die Bindungsumgebung mit Stubs, Initialisierungsquellen eingerichtet und √ºberpr√ºft wird, ob die erwarteten Ergebnisse auf der Clientseite empfangen werden: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BindingEnvironmentTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component1: ObservableSource&lt;Component1.Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component2: Consumer&lt;Component2.Input&gt; <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindings: BindingEnvironment <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component1 = PublishRelay.create() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component2 = mock() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings = BindingEnvironment(component1, component2) } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testBindings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> simulatedOutputOnLeftSide = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expectedInputOnRightSide = TODO() component1.accept(simulatedOutputOnLeftSide) verify(component2).accept(expectedInputOnRightSide) } }</code> </pre><br>  Und obwohl Sie zum Testen ungef√§hr die gleiche Menge an Code schreiben m√ºssen wie bei anderen Ans√§tzen, erleichtern autarke Komponenten das Testen einzelner Teile, da die Aufgaben klar voneinander getrennt sind. <br><br><h2>  Denkanst√∂√üe </h2><br>  Obwohl die Beschreibung unseres Systems in Form eines Diagramms von Black Boxes f√ºr das allgemeine Verst√§ndnis gut ist, funktioniert dies nur, solange die Gr√∂√üe des Systems relativ klein ist. <br><br>  F√ºnf bis acht Bindungslinien sind akzeptabel.  Aber wenn man mehr verbunden hat, wird es ziemlich schwierig sein zu verstehen, was passiert: <br><br><img src="https://habrastorage.org/webt/x6/88/du/x688duddke2ejaf65ywgz60u4ic.png"><br><br><img src="https://habrastorage.org/webt/93/lm/wl/93lmwld0ldslgadh1kre2n2uvou.png"><br><br>  Wir wurden mit der Tatsache konfrontiert, dass mit zunehmender Anzahl von Links (es gab sogar mehr als im vorgestellten Codefragment) die Situation noch komplizierter wurde.  Der Grund lag nicht nur in der Anzahl der Zeilen - eine Art von Bindungen konnte f√ºr verschiedene Methoden gruppiert und extrahiert werden -, sondern auch darin, dass es immer schwieriger wurde, alles im Blick zu behalten.  Und das ist immer ein schlechtes Zeichen.  Befinden sich Dutzende verschiedener Komponenten auf derselben Ebene, k√∂nnen sich nicht alle m√∂glichen Wechselwirkungen vorstellen. <br><br>  Der Grund ist die Verwendung von Komponenten - Black Boxes oder etwas anderes? <br><br>  Wenn der von Ihnen beschriebene Bereich anfangs komplex ist, werden Sie durch keinen Ansatz vor dem genannten Problem bewahrt, bis Sie das System in kleinere Teile aufteilen.  Es wird auch ohne eine riesige Liste von Bindungen kompliziert sein, es wird einfach nicht so offensichtlich sein.  Dar√ºber hinaus ist es viel besser, wenn die Komplexit√§t explizit ausgedr√ºckt und nicht verborgen wird.  Es ist besser, eine wachsende Liste einzeiliger Verkn√ºpfungen zu sehen, die Sie daran erinnert, wie viele separate Komponenten Sie haben, als nicht √ºber die Links zu wissen, die in Klassen in verschiedenen Methodenaufrufen versteckt sind. <br><br>  Da die Komponenten selbst einfach sind (sie sind Black Boxes und zus√§tzliche Prozesse flie√üen nicht in sie ein), ist es einfacher, sie zu trennen, was bedeutet, dass dies ein Schritt in die richtige Richtung ist.  Wir haben die Schwierigkeit an einen Ort verschoben - auf die Liste der Bindungen, mit einem Blick k√∂nnen wir die allgemeine Situation bewerten und dar√ºber nachdenken, wie wir aus diesem Chaos herauskommen k√∂nnen. <br><br>  Die Suche nach einer L√∂sung hat viel Zeit in Anspruch genommen und dauert noch an.  Wir planen, in den folgenden Artikeln dar√ºber zu sprechen, wie dieses Problem gel√∂st werden kann.  Bleib in Kontakt! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463781/">https://habr.com/ru/post/de463781/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463769/index.html">Mitap Netologii ‚ÄûKarriere in der Datenwissenschaft: Vom Anf√§nger bis zur Mitte‚Äú</a></li>
<li><a href="../de463771/index.html">[Peter] Treffen von JUG.ru mit Sebastian Dashner - Machen Sie das Schreiben von Unternehmenstests angenehmer</a></li>
<li><a href="../de463773/index.html">Wie der Schutz von Kindern vor Informationen geregelt ist - und die bezaubernde Geschichte dar√ºber, woher sie zuerst kamen (18+)</a></li>
<li><a href="../de463775/index.html">Wer verwendet das SAML 2.0-Authentifizierungsprotokoll?</a></li>
<li><a href="../de463777/index.html">Powershell Host-Verf√ºgbarkeits√ºberwachung</a></li>
<li><a href="../de463785/index.html">√úbersicht der Terminalemulatoren</a></li>
<li><a href="../de463787/index.html">Die gro√üe alte √úberraschung von HP</a></li>
<li><a href="../de463789/index.html">Die Kraft der Generika in Swift. Teil 2</a></li>
<li><a href="../de463791/index.html">Eisengriff: Kinematik von Vogellandungen in Abh√§ngigkeit von Geometrie und Oberfl√§chentextur</a></li>
<li><a href="../de463795/index.html">Bedeutungsschattierungen in Englisch: Verwendung der Verben Empfehlen, Empfehlen, Vorschlagen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>