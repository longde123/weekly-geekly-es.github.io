<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤶🏽 👩🏿‍🚀 🎫 增量向量元素 😒 💃🏽 📴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在哪种情况下，如果std :: vector元素的类型为uint8_t或uint32_t，它们的增量会更快吗？ 

 为了不进行抽象推理，我们考虑两个特定的实现： 



void vector8_inc(std::vector<uint8_t>& v) { for (size_t i = 0; i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>增量向量元素</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/475636/"> 在哪种情况下，如果<i>std :: vector</i>元素的类型为<i>uint8_t</i>或<i>uint32_t，</i>它们的增量会更快吗？ <br><br> 为了不进行抽象推理，我们考虑两个特定的实现： <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector8_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector32_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } }</code> </pre> <a name="habracut"></a><br><h2> 让我们尝试猜测 </h2><br> 使用基准测试很容易回答这个问题，稍后我们会这样做，但是首先我们将尝试猜测（这被称为“基于基本原理的推理”-听起来更科学）。 <br><br> 首先，值得提出一个问题： <i>这些向量的大小是</i>多少？ <br><br> 好吧，让我们选择一些数字。 让每个中有20,000个元素。 <br><br> 此外，众所周知，我们将在Intel Skylake处理器上进行测试-我们将看到具有直接寻址功能的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8位</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">32位</a>操作数加法命令的特征。 事实证明，它们的主要指标是相同的：每个周期1个操作和每个内存访问4个周期的延迟（1）。 在这种情况下，延迟无关紧要，因为每个加法操作都是独立执行的，因此计算的速度是每个周期1个元素，前提是循环上的所有其余工作将并行执行。 <br><br> 您还可以注意到，对于使用<i>uint8_t</i>的版本，20,000个项目对应于20 KB的数据集，对于使用<i>uint32_t</i>的版本，对应于80 KB的<i>数据集</i> 。 在第一种情况下，它们理想地适合于现代基于x86的计算机的L1级缓存，而在第二种情况下-则不然。 事实证明，由于高效的缓存，8位版本会抢先一步吗？ <br><br> 最后，我们注意到我们的任务与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自动向量化</a>的经典情况非常相似：在具有已知迭代次数的循环中，对顺序位于内存中的元素执行算术运算。 在这种情况下，8位版本应该比32位版本具有巨大的优势，因为一个向量运算将处理四倍的元素，并且一般而言，英特尔处理器对单字节元素执行向量运算的速度与32位处理器相同。位元素。 <br><br> 好吧，别再抱怨了。 现在该轮到考试了。 <br><br><h2> 基准测试 </h2><br> 在具有不同优化级别的<i>gcc 8</i>和<i>clang 8编译器上</i> ，我得到了20,000个元素的向量的以下计时： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l_/6r/k7/l_6rk7tnbeguzjnreatqtggsopg.png"></div><br> 事实证明，除了<i>-O1</i>级别以外，使用<i>uint32_t</i>的版本比使用<i>uint8_t</i>的版本<i>要</i>快，并且在某些情况下是有意义的： <i>-O3</i>级别的gcc的5.4倍， <i>-O2</i>和<i>-的</i>两个级别的clang的准确度是8倍。 <i>O3</i> 。 是的，在具有标准优化设置的流行编译器中， <i>std :: vector</i>中32位整数的增量最多快8倍。 <br><br> 像往常一样，让我们​​看一下汇编程序清单，以希望它能阐明正在发生的事情。 <br><br> 这是gcc 8在<i>-O2</i>级别的清单，其中8位版本“仅”比32位版本（2）慢1.5倍： <br><br>  <b>8位：</b> <br><br><pre> <code class="cpp hljs">.L3: inc BYTE PTR [rdx+rax] mov rdx, QWORD PTR [rdi] inc rax mov rcx, QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>] sub rcx, rdx cmp rax, rcx jb .L3</code> </pre> <br>  <b>32位：</b> <br><pre> <code class="cpp hljs">.L9: inc DWORD PTR [rax] add rax, <span class="hljs-number"><span class="hljs-number">4</span></span> cmp rax, rdx jne .L9</code> </pre> <br>  32位版本的外观与未开发（3）循环中的预期完全相同：使用地址进行增量（4），然后使用三个循环控制命令： <i>add rax</i> ， <i>4-</i>归纳变量（5） <i>的</i>增量以及几个<i>cmp</i>和<i>jne</i>命令检查退出循环的条件以及条件跳转。 一切看起来都很不错-部署将补偿增加计数器和检查条件的成本，并且我们的代码几乎可以达到每个时钟周期1个元素的最大可能速度（6），但对于开源应用程序，它可以做到。 那么8位版本呢？ 除了带有该地址的<i>inc</i>命令之外，还执行了两个用于从内存中读取的附加命令以及<i>子</i>命令，这些命令从任何地方都不可取。 <br><br> 这是带有评论的清单： <br><br>  <b>8位：</b> <br><br><pre> <code class="cpp hljs">.L3: inc BYTE PTR [rdx+rax] ;    v[i] mov rdx, QWORD PTR [rdi] ;  v.begin inc rax ; i++ mov rcx, QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;  v.end sub rcx, rdx ; end - start (.. <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.size()) cmp rax, rcx ; i &lt; size() jb .L3 ; .   i &lt; size()</code> </pre> <br> 这里的<i>vector :: begin</i>和<i>vector :: end</i>是<i>std :: vector</i>的内部指针，它用来指示包含在为其选择的区域中的元素序列的开始和结束（7），这些值基本上是相同的它们用于实现<i>vector :: begin（）</i>和<i>vector :: end（）</i> （尽管它们的类型不同）。 事实证明，所有其他命令仅是<i>vector.size（）</i>计算的<i>结果</i> 。 看起来没什么异常吗？ 但是，毕竟，在32位版本中，当然也要计算<i>size（）</i> ，但是这些命令不在清单中。  <i>size（）</i>的计算仅发生一次-在循环之外。 <br><br> 那怎么了 简短的答案是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">指针别名</a> 。 我将在下面给出详细的答案。 <br><br><h2> 详细答案 </h2><br> 向量<i>v</i>通过引用传递给函数，实际上，它是一个掩码指针。 编译器必须转到向量的成员<i>v ::开始</i>和<i>v ::结束</i>以计算其大小<i>size（）</i> ，在我们的示例中， <i>size（）</i> <i>在</i>每次迭代时计算。 但是，编译器没有义务盲目地遵守源代码：它很可能带有在循环外调用<i>size（）</i>函数的结果，但前提是必须确定知道程序的语义<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不会改变</a> 。 从这个角度来看，循环中唯一有问题的地方是增量<i>v [i] ++</i> 。 记录发生在一个未知的地址。 这样的操作可以改变size（）的值吗？ <br><br> 如果记录发生在<i>std :: vector &lt;uint32_t&gt;中</i> （即通过<i>uint32_t *</i>指针），则否，它不能更改<i>size（）</i>值。 写入<i>uint32_t</i>类型的对象只能修改<i>uint32_t</i>类型的对象，并且计算<i>size（）</i>所涉及的指针具有不同的类型（8）。 <br><br> 但是，对于<i>uint8_t</i> ，至少在流行的编译器（9）上，答案是这样的：是的，理论上<b><i>size（）</i></b>的值<b>可能会更改</b> ，因为<i>uint8_t</i>是<i>unsigned char</i>的别名，并且<i>unsigned char</i> （和<i>char</i> ）类型的数组可以<i>任何其他类型的别名</i> 。 这意味着，根据编译器，写入<i>uint8_t指针</i>可以修改任何地址（10）处来源未知的内存的内容。 因此，假设每个增量操作<i>v [i] ++</i>都可以更改<i>size（）</i>值，因此在每次循环迭代时都必须重新计算它。 <br><br> 我们都知道，写入<i>std :: vector</i>指向的内存永远不会更改其自身的<i>size（）</i> ，因为这将意味着该向量本身已以某种方式分配在其自己的堆中，这实际上是不可能并且类似于鸡肉和鸡蛋的问题（11）。 但是不幸的是，编译器对此并不了解！ <br><br><h2> 其余的结果呢？ </h2><br> 好了，我们发现了为什么在<i>-O2</i>级别上使用<i>uint8_</i>的版本比在gcc上的<i>uint32_t</i>的版本要慢一些。 但是，为什么要解释在clang上或在<i>-O3</i>上具有相同gcc的巨大差异（最多8倍）？ <br><br> 一切都很简单：在<i>uint32_t</i>的情况下<i>，</i> clang可以执行循环自动矢量化： <br><br><pre> <code class="cpp hljs">.LBB1_6: ; =&gt;This Inner Loop Header: Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi] vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">32</span></span>] vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">64</span></span>] vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">96</span></span>] vpsubd ymm1, ymm1, ymm0 vpsubd ymm2, ymm2, ymm0 vpsubd ymm3, ymm3, ymm0 vpsubd ymm4, ymm4, ymm0 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi], ymm1 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">32</span></span>], ymm2 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">64</span></span>], ymm3 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">96</span></span>], ymm4 vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">128</span></span>] vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">160</span></span>] vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">192</span></span>] vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">224</span></span>] vpsubd ymm1, ymm1, ymm0 vpsubd ymm2, ymm2, ymm0 vpsubd ymm3, ymm3, ymm0 vpsubd ymm4, ymm4, ymm0 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">128</span></span>], ymm1 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">160</span></span>], ymm2 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">192</span></span>], ymm3 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">224</span></span>], ymm4 add rdi, <span class="hljs-number"><span class="hljs-number">64</span></span> add rsi, <span class="hljs-number"><span class="hljs-number">2</span></span> jne .LBB1_6</code> </pre> <br> 该周期被部署了8次，通常这是您可以获得的最大性能：L1缓存每个时钟周期一个向量（8个元素）（由于每个时钟周期限制一次写入操作（12），因此不再起作用）。 <br><br> 不对<i>uint8_t</i>执行<i>矢量化</i> ，因为它需要计算<i>size（）</i>来检查每次迭代的循环条件，因此会受到阻碍。 滞后的原因仍然相同，但是滞后本身要大得多。 <br><br> 最低的时间由自动矢量化解释：gcc仅在<i>-O3</i>级别应用它，而clang默认在<i>-O2</i>和<i>-O3</i>级别应用。  -cc级gcc编译器生成的代码比clang稍慢，因为它不会扩展自动向量化的循环。 <br><br><h2> 纠正情况 </h2><br> 我们发现了问题所在-我们该如何解决？ <br><br> 首先，让我们尝试一种无法使用的方法，即，我们将基于迭代器编写一个更加惯用的循环： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(); i != v.end(); ++i) { (*i)++; }</code> </pre> <br>  <i>gcc</i>在<i>-O2</i>级别生成的代码会比带有<i>size（）</i>的选项稍微好一点： <br><br><pre> <code class="cpp hljs">.L17: add BYTE PTR [rax], <span class="hljs-number"><span class="hljs-number">1</span></span> add rax, <span class="hljs-number"><span class="hljs-number">1</span></span> cmp QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>], rax jne .L17</code> </pre> <br> 两个额外的读取操作变成一个，因为<i>我</i>现在与向量的<i>结束</i>指针进行比较，而不是重新计算<i>size（）</i> ，从结束指针中减去向量的开始指针。 根据指令的数量，此代码被<i>uint32_t</i>追上了，因为额外的读取操作与比较操作合并了。 但是，问题并没有解决，自动向量化仍然不可用，因此<i>uint8_t</i>仍然远远落后于<i>uint32_t-</i>在提供自动向量化的水平上，gcc和clang都超过5倍。 <br><br> 让我们尝试其他事情。 我们不会再成功，或者，我们将找到<i>另一种</i>无效的方法。 <br><br> 在此版本中，我们仅在循环之前计算一次<i>size（）</i>并将结果放入局部变量中： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, s = v.size(); i &lt; s; i++) { v[i]++; }</code> </pre> <br> 好像在工作吗？ 问题是<i>size（）</i> ，现在我们命令编译器在循环开始时将<i>size（）</i>的结果提交给局部变量<i>s</i> ，正如您所知，局部变量不与其他数据相交。 实际上，我们做了编译器做不到的事情。 而且它将生成的代码实际上会更好（与原始代码相比）： <br><br><pre> <code class="cpp hljs">.L9: mov rdx, QWORD PTR [rdi] add BYTE PTR [rdx+rax], <span class="hljs-number"><span class="hljs-number">1</span></span> add rax, <span class="hljs-number"><span class="hljs-number">1</span></span> cmp rax, rcx jne .L9</code> </pre> <br> 只有一个额外的读取操作，没有<i>子</i>命令。 但是，如果额外的命令（ <i>rdx，QWORD PTR [rdi]</i> ）不参与大小计算，该怎么办？ 它从<i>v</i>读取<i>data（）</i>指针！ <br><br> 表达式<i>v [i]</i>被实现为<i>*（v.data（）+ i）</i> ，而由<i>data（）</i>返回的成员（实际上是一个常规的<i>begin</i>指针）与<i>size（）存在</i>相同的问题。 没错，我没有在原始版本中注意到此操作，因为它是“免费的”，因为它仍然必须执行才能计算出大小。 <br><br> 忍受多一点，我们几乎找到了解决方案。 您只需要从循环中删除对<i>std :: vector</i>内容的<i>所有</i>依赖关系即可。 最简单的方法是用迭代器修改我们的习惯用法： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(), e = v.end(); i != e; ++i) { (*i)++; }</code> </pre> <br> 现在一切都发生了巨大的变化（这里我们仅将版本与<i>uint8_t</i>进行比较-在一个版本中，我们将迭代器<i>末尾</i>保存<i>在</i>循环<i>之前的</i>局部变量中，在另一个版本中，否）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lp/pe/xj/lppexj0vgqumpzvblxctc7xkkoa.png"></div><br> 这个小小的变化使我们在自动矢量化水平上的速度提高了20倍。 此外，使用<i>uint8_t</i>的代码不仅赶上了使用<i>uint32_t</i>的代码-它像gcc <i>-O3</i>和clang <i>-O2</i>和<i>-O3一样</i> ，几乎完全超过了它四倍，这是我们一开始就依靠矢量化实现的：最后，正好超过四倍元素可以通过向量运算来处理，并且我们需要的带宽要少四倍-不管缓存级别如何（13）。 <br><br> 如果您读到这个地方，那您一定一直在对自己大喊： <br><br>  <i>但是，在C ++ 11中引入的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>带遍历for循环又</i></a>如何呢？</i> <br><br> 我赶紧取悦你：它有效！ 实际上，这是语法糖，后面带有迭代器的版本几乎以相同的形式隐藏，在此之前，我们在循环开始之前将<i>结束</i>指针固定在局部变量中。 所以他的速度是一样的。 <br><br> 如果我们突然决定回到古老的洞穴时代并编写一个类似于C的函数，那么这样的代码也将同样有效： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { a[i]++; } }</code> </pre> <br> 在这里，指向数组<i>a</i>的指针和<i>大小</i>变量按值传递给函数，因此，由于写入指针<i>a</i> （14）的结果，它们不能更改-就像局部变量一样。 该代码的性能与以前的选项相同。 <br><br> 最后，在可以使用此选项的编译器上，可以使用<i>__restrict</i> （15）声明向量： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector8_inc_restrict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; __restrict v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } }</code> </pre> <br>  <i>__restrict关键字</i>不是C ++标准的一部分，而是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自C99以来C</a>标准的一部分（作为<i>strict</i> ）。 如果在编译器中将其实现为C ++扩展，则很可能它将遵循C的语义。当然，C中没有链接，因此您可以在思维上用指向矢量的指针替换指向矢量的链接。 <br><br> 请注意，strict不具有传递<i>属性</i> ： <i>__restrict</i>说明符的操作（用于声明指向<i>std :: vector</i>的链接）仅适用于矢量本身的成员，而不适用于<i>v.data（）</i>引用的堆区域。 在我们的例子中，不需要更多，因为（就局部变量而言）足以使编译器确信，指向向量开头和结尾的术语本身不与任何东西相交。 但是，关于<i>limit</i>的子句仍然<i>有用</i> ，因为通过<i>v.data（）进行</i>写<i>操作</i>可能仍会由于别名而导致函数中的其他对象发生更改。 <br><br><h2> 失望的 </h2><br> 在这里，我们得出最后一个-非常令人失望的结论。 事实是，当向量在理论上可以干扰自身时，以上显示的所有解决方案仅适用于此特定情况。 解决方案是摆脱循环或隔离调用向量的<i>size（）</i>或<i>end（）的结果</i> ，而<i>不是</i>告诉编译器写入向量的数据不会影响其他数据。 随着功能的增长，此类代码将难以扩展。 <br><br> 别名问题还没有解决，写命令仍然可以“随处可见”-此函数中根本没有其他数据可以受到影响...。 一旦出现新代码，便会重复所有操作。 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个例子</a> 。 如果在小循环中写入<i>uint8_t</i>类型的元素数组，则必须与编译器战斗直到最后（16）。 <br><br><h2> 留言 </h2><br> 我将很高兴收到任何反馈。 我还没有评论系统（17），因此，像往常一样，我们将在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此线程上HackerNews上进行讨论</a> 。 <br><br><ol><li> 通过在此处访问内存，可以理解，依赖关系链通过了内存：在同一地址的写命令应该读取在那里最后写入的值，因此，此类操作是依赖的（实际上，如果记录足够，将使用加载重定向（STLF）经常）。 当访问内存时， <i>add</i>命令的依赖关系可能会以其他方式出现，例如，通过计算地址，但是对于我们而言，这是无关紧要的。 </li><li> 这里只显示一个小周期； 安装代码很简单，并且可以快速运行。 要查看完整清单， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请将代码上传到godbolt</a> 。 </li><li> 也许应该简称为“最小化”？ 尽管如此，gcc编译器即使在<i>-O2</i>和<i>-O3</i>级别也通常不会循环，除非在特殊情况下迭代次数很小并且<i>在编译阶段</i>是<i>已知的</i> 。 因此，与clang相比，gcc的测试结果更低，但可以节省很多代码大小。 您可以<i>通过</i>应用配置文件优化或打开<i>-funroll-loops</i>标志来<i>强制gcc展开循环</i> 。 </li><li> 实际上，gcc中的<i>inc DWORD PTR [rax]命令</i>是错过的优化：使用<i>add [rax]，1</i>命令几乎总是更好，因为它仅包含2个组合的微操作，而<i>inc</i>是3个。 在这种情况下，差异仅约为6％，但是如果稍微扩展一下循环以便仅重复记录操作，则差异会更大（进一步的扩展将不再起作用，因为我们将达到1的极限记录每个周期的操作，这不取决于微操作的总数）。 </li><li> 我将此变量称为<i>归纳</i>变量，而不仅仅是在源代码中称为<i>i</i> ，因为编译器将增量<i>i</i>的单位运算转换为<i>rax</i>寄存器中存储的指针的4字节增量，并因此纠正了循环条件。 循环以其原始形式处理向量的元素，并且在此转换之后，循环增加了指针/迭代器，这是<i>降低操作成本的</i>一种方法。 </li><li> 实际上，如果启用<i>-funroll-loops</i> ，则在gcc上，每个元素的速度为1.08小节，展开次数为<i>8倍</i> 。 但是即使带有该标志，他<i>也不会</i>扩展具有8位元素的版本的循环，因此速度的滞后将更加明显！ </li><li> 这些成员有一个<i>私有</i>修饰符，它们的名称取决于实现，但是在stdlibc ++中，它们并不像gcc那样真正地称为<i>start</i>和<i>finish</i> 。 它们分别称为<i>_Vector_base :: _ Vector_impl :: _ M_start</i>和<i>_Vector_base :: _ Vector_impl :: _ M_finish</i> ，即 输入<i>_Vector_impl</i>结构，该结构是<i>_Vector_base</i>类的<i>_M_impl</i> （也是唯一的一个） <i>成员</i> ，并且又是<i>std :: vector</i>的基类。 好吧，好吧！ 幸运的是，编译器可以轻松应对这一堆抽象。 </li><li> 该标准没有规定<i>std :: vector</i>成员的内部类型应该是什么，但是在libstdc ++库中，它们仅定义为<i>Alloc：指针</i> （其中<i>Alloc</i>是向量的分配器），对于默认的<i>std :: allocated对象，</i>它们将简单地定义为类型<i>T *的</i>指针 指向对象的常规指针-在这种情况下为<i>uint32_t *</i> 。 </li><li> 我进行此保留是有原因的。 有人怀疑<i>uint8_t</i>可能被视为<i>char</i> ， <i>signed char</i>和<i>unsigned char</i>以外的类型。 由于别名适用于<i>字符类型</i> ，因此从原则<i>上讲</i>这不适用于<i>uint8_t</i> ，其行为应类似于其他任何非字符类型。 但是，我所知的所有编译器都没有这样认为： <i>typedef</i> <i>uint8_t</i>都是<i>unsigned char</i>的别名，因此即使他们愿意使用它们，编译器也看不到它们之间的区别。 </li><li>  “未知来源”在这里仅是指编译器不知道内存内容指向何处或如何显示。 这包括传递给函数的任意指针，以及全局和静态变量。  , ,            ,  ,   ,     (    -     ). ,     <i>malloc</i>  <i>new</i> ,   <i></i>    ,      ,   ,        :  ,      ,       . ,       <i>malloc</i>  <i>new</i> . </li><li>  ,   <i>std::vector</i>  - <i></i> ? ,    <i>std::vector&lt;uint8_t&gt; a</i>     <i></i>  <i>a.data()</i>    <i>placement new</i>       <i>b</i> .   <i>std::swap(a, b)</i> ,       – ,  <i>b</i>      ?       ,     <i>b</i> .       :          -  (,       ),      ,       . </li><li>        8 , ..  32 .     ,   <i>std::vector</i>      . </li><li> -        4 :     ,        ,   – .       : 8-      L1,  32-        –   L2    ,      . </li><li>        ,  –  :        .      ,      ,    «». </li><li>        <i>v[i]</i> ,           . </li><li>     . ,   «» ,          <i>uint8_t</i> .      , ,       ,  <i>uint8_t</i> ,          . ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   clang,      gcc</a> ,     ,    <i>uint8_t</i> . -     <i>gcc</i>          ,   .     ,     , -     <i>__restrict</i> . </li><li>  -  ,       ,      (   Disqus),           (        ),    . </li></ol><br> <i>     .  : Travis Downs. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Incrementing vectors</a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN475636/">https://habr.com/ru/post/zh-CN475636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN475618/index.html">如何在本体网络上编写智能Python合同。 第2部分：存储API</a></li>
<li><a href="../zh-CN475622/index.html">在虚幻引擎4中扩展UObject</a></li>
<li><a href="../zh-CN475624/index.html">PHP-Watcher：简化长期应用程序开发的工具</a></li>
<li><a href="../zh-CN475626/index.html">自动测试可以代替一个人寻找漏洞：采访亚历山德拉·斯瓦蒂科娃（Alexandra Svatikova）</a></li>
<li><a href="../zh-CN475630/index.html">Knative-基于k8s的平台即服务，无服务器支持</a></li>
<li><a href="../zh-CN475640/index.html">如果要创建东西，请避免经理的日程安排。</a></li>
<li><a href="../zh-CN475642/index.html">PostgreSQL中仅堆元组机制</a></li>
<li><a href="../zh-CN475646/index.html">尤里·里亚巴采夫（Yuri Ryabtsev）：“第一次拦截弹道导弹的事件大约等于加加林的飞行”</a></li>
<li><a href="../zh-CN475652/index.html">我们如何在Aurora OS（Sailfish Mobile OS RUS）上开发移动应用程序</a></li>
<li><a href="../zh-CN475654/index.html">“头三个月，三个健康的男人害怕打开涡轮机”-阿列克谢·斯塔森科如何从头开始建造喷气背包</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>