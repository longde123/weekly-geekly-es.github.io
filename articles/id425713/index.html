<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔣 🛐 🈯️ Integrasi mesin HTML ke dalam aplikasi Windows asli - pilihan dan arsitektur 🎀 👩🏿‍✈️ 🛐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cara kami menerjemahkan berfungsi dengan HTML dalam 1C: Perusahaan dari Internet Explorer ke WebKit 

 Kemampuan untuk menampilkan HTML dalam bentuk 1...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Integrasi mesin HTML ke dalam aplikasi Windows asli - pilihan dan arsitektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/1c/blog/425713/">  <b>Cara kami menerjemahkan berfungsi dengan HTML dalam 1C: Perusahaan dari Internet Explorer ke WebKit</b> <br><br>  Kemampuan untuk menampilkan HTML dalam bentuk 1C muncul di platform 1C: Enterprise pada tahun 2003, versi 8.0.  Untuk bekerja dengan HTML, platform menggunakan mesin browser Internet Explorer (1C: Enterprise pada saat itu hanya bekerja di bawah Windows).  Mesin browser digunakan oleh platform untuk tujuan utilitarian.  Misalnya, untuk menulis dari awal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">elemen</a> lengkap untuk mengedit teks ala Word - dengan kemungkinan berbagai solusi warna dan font, menyisipkan gambar, dll.  - tugas yang sangat sulit.  Dan jika Anda menggunakan HTML untuk tujuan ini dan menggunakan mesin browser Internet sebagai alat tampilan, tugas ini sangat disederhanakan.  Juga, dengan bantuan mesin, sejumlah mekanisme lain (misalnya, menampilkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">informasi bantuan</a> ) dan elemen (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal</a> ) diimplementasikan. <br><br>  Nah, kemampuan pengembang aplikasi untuk menampilkan menggunakan desain khusus HTML dengan standar dunia sistem akuntansi kadang-kadang memungkinkan untuk membawa berbagai sorotan yang menyenangkan ke antarmuka aplikasi bisnis. <br><br>  Seiring berjalannya waktu, platform mulai mendukung Linux pertama, dan kemudian macOS.  Internet Explorer tidak cocok untuk bekerja dengan HTML di OS ini karena alasan yang jelas;  di Linux, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebKitGTK +</a> , dan pada macOs, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka</a> berbasis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kakao</a> .  Dengan demikian, kesatuan basis kode untuk sistem operasi yang berbeda (yang kami coba pertahankan untuk kode klien pada level 95%) dilanggar di area ini.  Nah, mesin IE saat ini telah menjadi sumber dari sejumlah masalah. <br><img src="https://habrastorage.org/webt/xo/c6/2k/xoc62k11ifqv9dfeunr279csd4q.png" alt="gambar"><br><a name="habracut"></a><br>  Masalahnya: <br><br><ul><li>  Mesin IE memiliki kode sumber tertutup - artinya: <br><ul><li>  Penyesuaian mesin yang fleksibel dengan kebutuhan platform tidak dimungkinkan </li><li>  Debugging dan pemahaman proses di dalam </li><li>  Tidak dapat memperbaiki bug dan kesalahan dengan memperbarui versi mesin </li></ul></li><li>  Mesin tidak cocok untuk pelaksanaan tugas pemrograman web modern </li><li>  Masalah Kinerja pada Mesin Lemah </li></ul><br>  Jadi, terjemahan bekerja dengan HTML dalam versi 1C: Enterprise untuk Windows dari mesin IE ke sesuatu yang lain sudah jelas.  Apa yang harus dipilih? <br><br>  Untuk memulai, kami merumuskan persyaratan untuk mesin: <br><br><ul><li>  Dukungan untuk teknologi pemrograman web modern </li><li> Sumber terbuka untuk kustomisasi mesin yang fleksibel dan memahami logikanya </li><li>  Kinerja tinggi pada komputer yang lebih lambat </li><li>  Diinginkan bahwa mesin membutuhkan sejumlah kecil perpustakaan pihak ketiga untuk bekerja </li></ul><br><h2>  Pemilihan mesin </h2><br>  Apa yang harus dipilih?  Kami mulai, tentu saja, dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebKit</a> , yang dengannya kami telah bekerja dalam versi platform untuk Linux dan macOS. <br><br>  WebKit dikembangkan di Apple pada awal 2000-an berdasarkan mesin open source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KHTML</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KJS</a> .  Berdasarkan WebKit, browser Safari dibuat, kemudian - Chrome (bahkan kemudian Chrome beralih dari WebKit ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blink</a> , yang lagi-lagi didasarkan pada kode WebCore dari WebKit). <br><br>  Kode sumber untuk WebKit adalah open source dan dilisensikan di bawah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LGPL</a> .  WebKit ditulis untuk macOS, ada beberapa port untuk Windows: <br><br><h3>  WebKit AppleWin </h3><br>  Ini adalah port yang disarankan pengembang WebKit membangun di bawah Windows secara default.  Itu dibuat oleh karyawan Apple di pertengahan hingga akhir 2000-an.  Ini menggunakan perpustakaan grafis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CoreGraphics</a> , yang merupakan versi sederhana dari perpustakaan untuk macOS, porting ke Windows.  Untuk menjalankan JavaScript, port menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaScriptCore</a> dengan API yang sama yang digunakan dalam implementasi platform untuk Linux.  Ini membuatnya menjadi kandidat utama untuk digunakan. <br><br><h3>  WebKit WinCairo </h3><br>  Port ini menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kairo</a> untuk grafik.  Untuk beberapa waktu, Apple telah secara aktif mengembangkan port ini sebagai analog dengan port AppleWin utama.  Keuntungan dari port ini adalah bahwa ia kurang bergantung pada pustaka spesifik-macOS yang dibutuhkan oleh CoreGraphics.  Selain itu, port menggunakan pustaka yang sama untuk grafik ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kairo</a> ) dengan mesin WebKitGTK +, yang kami gunakan dalam implementasi platform Linux, yang baik untuk menstandarisasi perilaku kode kami. <br><br><h3>  QtWebKit </h3><br>  Implementasi lain dari mesin WebKit untuk Windows, sekarang independen dari pengembang mesin itu sendiri.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Qt</a> adalah perpustakaan lintas platform populer dengan perpustakaan grafis QtGui sendiri.  Port ini juga menggunakan pustaka JavaScriptCore untuk menangani JavaScript, namun memiliki kekurangan: <br><br><ul><li>  Ketergantungan yang kuat pada komponen utama Qt, yang, jika digunakan dalam perangkat lunak pihak ketiga, harus dikirim bersama itu </li><li>  Satu set antarmuka yang berbeda untuk bekerja dengan komponen untuk rendering HTML dibandingkan dengan WebKitGTK dan logikanya sendiri untuk bekerja dengannya. </li></ul><br><h3>  WebKitGtk + untuk Windows </h3><br>  Kami telah menggunakan WebKitGtk + di versi Linux platform.  Tetapi opsi untuk menggunakannya di Windows dikesampingkan karena kerumitan perakitan, dokumentasi yang buruk dari proses ini dan kurangnya dukungan konstan untuk area pengembangan ini dari pengembang WebKitGTK +. <br><br><h3>  Chromium (Berkedip) </h3><br>  Mesin pertama dan satu-satunya non-WebKit, yang dianggap sebagai kandidat untuk memecahkan masalah.  Itu ditolak karena perbedaan besar dalam logika komponen untuk rendering HTML dibandingkan dengan WebKitGTK + dan perpustakaan lain untuk bekerja dengan JavaScript ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V8</a> ). <br><br><h3>  Apa yang harus dipilih? </h3><br>  Setelah penelitian, AppleWin dan WinCairo mencapai final. <br>  Untuk membuat pilihan akhir, kami mempelajari cara kerja WebKit. <br><br><h2>  Struktur Mesin WebKit </h2><br>  Biasanya, port WebKit yang berbeda berbeda dalam dua cara.  Yang pertama adalah implementasi langsung untuk OS tertentu menggunakan komponen spesifik OS.  Yang kedua adalah perpustakaan grafis.  Gambar di bawah ini menjelaskan perbedaan pengertian antara port WebKit ini.  Untuk Windows, pengembang WebKit menulis port pada perpustakaan CoreGraphics dan Kairo yang diadaptasi. <br><br><img src="https://habrastorage.org/webt/y5/m5/mo/y5m5moefn2yjpbt4ohq9iwqqqj4.png" alt="gambar"><br><br>  Model mesin yang disederhanakan: tiga mekanisme tradisional untuk memformat halaman web - HTML, JavaScript, dan CSS - diumpankan ke engine, dan ini membentuk serta menampilkan halaman darinya: <br><br><img src="https://habrastorage.org/webt/j4/2n/r5/j42nr5vmxoryxsbq-c_mxe9oots.png" alt="gambar"><br><br>  Mesinnya sendiri terdiri dari beberapa komponen: <br><br><ul><li>  WTF (Kerangka Templat Web, bukan apa yang mungkin Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pikirkan</a> ): di sini Anda menemukan implementasi struktur data Anda sendiri untuk berfungsinya mesin, serta bekerja dengan stream </li><li>  JavaScriptCore: komponen, seperti namanya, untuk bekerja dengan bahasa JavaScript </li><li>  WebCore: semua pekerjaan dengan parsing DOM, gaya, HTML dan XML ditulis di sini.  Semua "keajaiban" utama mesin dilakukan di sini. </li><li>  Platform: melakukan tindakan teknis untuk berinteraksi dengan jaringan, menempatkan data dalam database, mendekode gambar, bekerja dengan media </li><li>  WebKit dan WebKit2 API - menautkan semua komponen dan memberikan akses kepada mereka </li></ul><br><img src="https://habrastorage.org/webt/ao/zr/gp/aozrgpbezfy8ex2ufhbnrzqf68e.png" alt="gambar"><br>  Hubungan antara komponen WebKit dan fitur khusus OS ditunjukkan pada gambar di bawah ini.  Seperti yang Anda lihat, ada beberapa poin spesifik yang perlu diimplementasikan untuk setiap OS secara terpisah.  Meskipun JavaScriptCore memungkinkan Anda untuk menggunakan diri Anda sendiri di setiap port tanpa implementasi yang terpisah. <br><br><img src="https://habrastorage.org/webt/r7/hz/c8/r7hzc8sbq6bcn_qpltvdzpimugu.png" alt="gambar"><br><br><h3>  Bagaimana halaman web terbentuk </h3><br>  Dari jaringan, respons datang ke permintaan ke server dengan data untuk diunduh.  Loader meneruskan data ke parser, yang, berinteraksi dengan komponen untuk JavaScript, membentuk lembar DOM dan style.  Selanjutnya, data yang dihasilkan ditransfer ke pohon rendering dan ditampilkan dalam konteks grafis. <br><img src="https://habrastorage.org/webt/k-/id/dh/k-iddhrnyvvcw8yzacaigtetlai.png" alt="gambar"><br>  Halaman itu sendiri juga terdiri dari komponen individual.  Komponen WebCore mengimplementasikan kelas Halaman, yang memungkinkan akses ke seluruh halaman.  Halaman memiliki bingkai utama - MainFrame, bingkai selalu memiliki dokumen.  Bingkai utama dapat memiliki sejumlah bingkai lainnya, juga dengan dokumen di dalamnya.  Untuk setiap bingkai, beberapa peristiwa dibentuk secara terpisah, serta konteks grafik dan JavaScript tertentu. <br><br><img src="https://habrastorage.org/webt/zv/fo/9c/zvfo9cqiclfhckd1wmzpnnv4jx4.png" alt="gambar"><br><br>  Parser HTML sederhana berfungsi seperti ini.  Dari set byte yang diterima dari server, decoder menghasilkan satu set karakter untuk diuraikan.  Simbol dikonversi menjadi token atau token, yang biasanya berupa potongan kode elementer dengan meta-informasi tentang jenis teks itu, apakah itu bagian dari sintaksis bahasa atau konten.  Kemudian node dibentuk dari token untuk membangun pohon DOM.  Pembangun pohon dari set node membentuk model objek lengkap untuk dokumen halaman web. <br><br><img src="https://habrastorage.org/webt/iq/9q/b5/iq9qb5qwciws_d-rfzze2afuopw.png" alt="gambar"><br><br><h2>  Pilihan terakhir </h2><br><ul><li>  Applewin <ul><li>  Pro: <ul><li>  Diimplementasikan pada perpustakaan grafis yang berjalan di macOS - platform target utama untuk pengembang WebKit </li></ul></li><li>  Cons: <ul><li>  Kurangnya implementasi mekanisme pencetakan </li><li>  Sejumlah besar dependensi </li></ul></li></ul></li><li>  Wincairo <ul><li>  Pro: <ul><li>  Pustaka grafis yang sama (Kairo), seperti yang digunakan di port Linux platform 1C </li></ul></li><li>  Cons: <ul><li>  Penting untuk tugas kita yang tidak ditemukan </li></ul></li></ul></li></ul><br>  Mengalahkan WinCairo.  Untuk pengembangan, versi terbaru dari WebKit yang tersedia pada saat itu diambil - 605.1.11. <br><br><h2>  Implementasi </h2><br>  Meskipun mesin cukup baik ditutupi oleh unit test (sekitar 30.000 untuk semua komponen mesin, ditulis oleh penulis mesin), ada kesalahan dan kekurangan dalam implementasi untuk "non-core" OS (yaitu, untuk segala sesuatu yang bukan macOS).  Kesenjangan implementasi ini secara bertahap ditemukan ketika mesin dikembangkan dan diuji sebagai bagian dari platform 1C: Enterprise. <br><br><h3>  Unduh HTML melalui Drag &amp; Drop </h3><br>  Ketika menyeret teks ke dalam jendela, ditemukan bahwa jika teks yang diseret mengandung karakter non-ASCII, maka hieroglif dimasukkan ke dalam dokumen akhir.  Kesalahan muncul hanya dalam implementasi mesin Windows, karena bekerja dengan mekanisme OS-spesifik untuk menyeret dan menjatuhkan elemen.  Ternyata teks itu tidak diterjemahkan dari UNICODE ke UTF-16 sebelum diteruskan ke event handler insert. <br><br><h3>  Ubah Shift + Enter Perilaku Keyboard </h3><br>  Di sebagian besar editor teks (termasuk Microsoft Word), kombinasi ini menyisipkan jeda baris.  Perilaku standar WebKit adalah menyisipkan paragraf baru (seolah-olah cukup menekan Enter).  Kami mengubah mesin, membuat perilaku lebih akrab bagi pengguna. <br><br><h3>  Organisasi dari mekanisme Undo &amp; Redo. </h3><br>  WebKit menyediakan API untuk mengimplementasikan mekanismenya sendiri untuk membatalkan dan mengulangi tindakan pengguna.  Skemanya adalah sebagai berikut: ketika pengguna melakukan tindakan tertentu yang terpisah dari sudut pandang mesin (misalnya, beralih ke paragraf baru, memformat miring, menempel), WebKit menginformasikan pengembang tentang ini menggunakan API sehingga ia dapat mendaftarkan tindakan ini. <br><br>  Dalam proses pengujian mekanisme yang diterapkan, hal yang tidak menyenangkan ditemukan: mesin tidak melaporkan perubahan dalam struktur tabel.  Perintah untuk menambah dan menghapus sel dan mengubah atribut colSpan ditambahkan, yang menjadi bagian dari tindakan gabungan, seperti, misalnya, menambah / menghapus kolom atau baris dalam tabel.  Perintah gabungan seperti itu terdaftar dalam tumpukan &amp; redo tumpukan yang sama, dan bersama-sama dengan perintah dari mesin memastikan operasi mekanisme yang benar. <br><br><h3>  Tempel dari Excel </h3><br>  Mereka yang bekerja dengan clipboard Windows dan Excel mungkin tahu bahwa, pertama, ketika menyalin dari Excel ke HTML, format clipboard di fragmen yang disalin hanya berisi tag sel dan baris, tetapi bukan tag tabel itu sendiri, dan kedua, gaya dari dokumen Excel tidak ditransfer ke sel.  Karena itu, memasukkan, misalnya, tabel warna ke dalam elemen yang dapat diedit di Chrome terlihat seperti ini: <br><br>  Asli: <br><br><img src="https://habrastorage.org/webt/gp/qu/fd/gpqufdcqtefrrio5zechwq0ufus.png" alt="gambar"><br><br>  Di Chrome: <br><br><img src="https://habrastorage.org/webt/gf/6y/uu/gf6yuuqrxmu8il-7bgoeql7xtwy.png" alt="gambar"><br><br>  Kedua faktor ini tidak diperhitungkan oleh pengembang WebKit.  Keterbukaan kode mesin memungkinkan kami untuk memperbaiki mekanisme penyisipan, dan sekarang fragmen tabel yang disisipkan ke dalam bidang HTML Dokumen dekat dengan aslinya: <br><br><img src="https://habrastorage.org/webt/l8/pi/bo/l8piboap1-odjv6iwb2jd4zdhim.png" alt="gambar"><br><br><h3>  Pembuatan font miring </h3><br>  Jika Windows tidak memiliki versi italic dari font non-standar, sebagian besar editor teks dapat menghasilkan font seperti itu menggunakan versi regulernya.  Namun, WebKit tidak tahu bagaimana melakukan ini dan beberapa kali menyesatkan pengembang: bagaimana mungkin dalam kode HTML dokumen kami menempatkan teks dalam tag &lt;i&gt;, tetapi meskipun demikian teks tetap lurus.  Alasannya adalah bahwa mesin WebKit memilih font yang diinginkan di port WinCairo yang kami gunakan - jika tidak ada versi miring, mesin menggunakan versi reguler.  Perilaku ini telah digantikan oleh penggunaan huruf miring yang dihasilkan oleh perpustakaan grafis Kairo. <br><br><h3>  Kesalahan dalam mendekode gambar dan animasi </h3><br>  Kesalahan dalam perilaku mesin ketika bekerja dengan elemen grafis ditemukan.  Saat memuat beberapa gambar dalam format PNG, distorsi gambar diamati, dan terkadang tidak ada sama sekali.  Itu tidak mungkin untuk menemukan alasan untuk perilaku ini, karena kesalahan terjadi ketika decoding gambar di perut perpustakaan libpng. <br><br>  Secara empiris, ditemukan bahwa ketika menautkan pustaka libpng secara dinamis dan bukan statis, masalahnya diperbaiki.  By the way, dalam versi mesin saat ini, menghubungkan dilakukan dengan cara ini.  Diputuskan untuk melakukan hal yang sama. <br><br>  Masalah lain adalah mesin saat memuat animasi dalam format GIF.  Kesalahan itu direproduksi secara berkala saat memuat halaman dengan animasi seperti itu dan menyebabkan crash program.  Kesalahan ini disebabkan oleh kurangnya sinkronisasi ketika bekerja dengan buffer ke mana frame animasi berikutnya ditempatkan.  Masalahnya diselesaikan dengan alat sinkronisasi internal WebKit. <br><br><h3>  Dukungan ejaan </h3><br>  Dalam perakitan dengan Internet Explorer, di Windows versi 8 dan yang lebih baru, pemeriksaan ejaan dapat diaktifkan untuk bidang yang dapat diedit HTML.  Untuk melakukan ini, itu sudah cukup untuk atribut "periksa ejaan" sama dengan "true".  WebKit memiliki solusi berbeda untuk port yang berbeda: di Linux itu adalah perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Enchant</a> , di macOS ia memiliki mekanisme sendiri, akrab bagi semua pengguna produk Apple.  Tetapi untuk Windows tidak ada implementasi, tetapi API disediakan untuk solusinya sendiri.  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Pengecekan Ejaan Windows</a> , tersedia mulai dengan Windows 8, dan menerapkan mekanisme yang mirip dengan build dengan Internet Explorer.  Omong-omong, sekarang dalam dokumen yang diformat dalam asli 1C: Klien perusahaan fungsi ini juga berfungsi.  Sebelum versi 8.3.14, itu dinonaktifkan karena kinerja Internet Explorer yang buruk. <br><br><h3>  Dukungan Windows XP </h3><br>  Beberapa klien kami masih bekerja pada Windows XP, dan tidak akan memperbarui OS dalam waktu dekat.  Sedih bagi kita sebagai pengembang, tetapi benar.  Jadi - kita perlu mendukung mereka.  Dan di sini kami memiliki kejutan yang tidak menyenangkan: Pengembang WebKit selama sekitar satu tahun belum mendukung mesin di WinXP.  Upaya untuk membangun versi mesin dengan seperangkat alat bantu untuk WinXP tidak berhasil - pengembang WebKit menggunakan pustaka yang hanya tersedia dari Windows Vista dan yang lebih baru. <br><br>  Apa yang harus dilakukan  Pilihannya adalah sebagai berikut: <br><br><ol><li>  Tinggalkan implementasi WinXP dengan mesin Internet Explorer, dan gunakan WebKit di versi Windows yang lebih lama </li><li>  Ambil untuk pengembangan versi sebelumnya dari mesin WebKit, yang bekerja di WinXP, dan gunakan versi ini di semua OS </li><li>  Gunakan versi WebKit yang sesuai di WinXP, dan gunakan mesin terbaru di versi Windows yang lebih lama </li><li>  Port versi mesin saat ini ke WinXP sendiri dan gunakan di mana-mana </li></ol><br>  Pertanyaannya tidak sederhana.  Opsi pertama memungkinkan Anda untuk menggunakan versi terbaru dari mesin WebKit, tetapi akan memaksa Anda untuk mengembalikan implementasi yang lama dengan Internet Explorer.  Dalam solusi seperti itu, akan sulit untuk memastikan operasi bebas kesalahan dari program, dan kode itu sendiri akan sangat rumit.  Opsi kedua menyediakan perilaku yang sama pada semua OS Windows, namun, itu tidak akan memberi kita kesempatan untuk pengembangan - memperbarui mesin untuk memperbaiki kesalahan dan mendapatkan fitur-fitur baru dari pengembang mesin di versi yang lebih baru.  Opsi ketiga memungkinkan Anda untuk menggunakan versi mesin saat ini di versi Windows yang lebih lama, tetapi sangat mempersulit logika instalasi dan memastikan perilaku versi yang sama di semua OS.  Opsi keempat tampak lebih disukai daripada yang lain, tetapi tidak mungkin untuk memprediksi kompleksitas dan secara umum kemungkinan solusi seperti itu. <br><br>  Namun demikian, kami memutuskan untuk mengambil kesempatan dan mengimplementasikan opsi keempat, yang paling benar dari sudut pandang arsitektur (menggunakan kode sumber mesin tunggal pada semua versi Windows).  Versi ported dari WebKit bekerja secara berbeda di WinXP dan versi Windows yang lebih baru: <br><br><ul><li>  Saya harus meninggalkan alat-alat DirectX baru (d3d11) yang mendukung DirectX9 lama (d3d9) dan menyesuaikan file header-nya ke versi yang lebih muda dari SDK. </li><li>  Fungsi dari SDK baru, ketika dieksekusi pada versi Windows baru, dipanggil di alamat (diperoleh melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GetProcAddress</a> ). </li><li>  Untuk mentransfer data antar aliran di engine, WinXP menggunakan penyimpanan lokal Thread, dalam versi baru - Penyimpanan serat lokal. </li></ul><br><h2>  Ringkasan </h2><br>  Jadi, sekarang di 1C kami: Platform perusahaan mulai dari versi 8.3.14 (rilis - akhir 2018) HTML akan didukung di level tertinggi - HTML5, OpenGL, dll.  Baik kuantitas dan kualitas kismis yang dapat diambil dalam keputusan di platform kami hanya dibatasi oleh imajinasi pengembang.  Namun, tentu saja, sistem operasi klien - di WinXP, banyak roti HTML5 yang lezat tidak akan berfungsi, karena alasan yang jelas. <br><br>  Sekarang pada aplikasi Windows pada 1C: Platform perusahaan akan dapat menunjukkan ini: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zL6beG-cNEI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Tapi, menggunakan "barang" HTML dalam solusi aplikasi, jangan lupa akal sehat.  Menggunakan HTML sesuai dan direkomendasikan untuk tugas khusus (menampilkan bantuan, teknik, deskripsi produk, ...), tetapi tidak untuk mengimplementasikan tugas logika bisnis (input / output informasi terstruktur).  Untuk melakukan ini, Anda perlu menggunakan standar 1C: Mekanisme antarmuka perusahaan yang memberikan dukungan otomatis untuk hak akses, manajemen fungsionalitas, adaptasi ke faktor bentuk perangkat, dukungan untuk pengaturan pengguna dan pekerjaan banyak mekanisme lainnya, yang tanpanya kerja aplikasi bisnis yang penuh menjadi hampir mustahil. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425713/">https://habr.com/ru/post/id425713/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425703/index.html">Kafka di Wargaming: Blitz</a></li>
<li><a href="../id425705/index.html">Replikasi dari Percona Server untuk MySQL ke PostgreSQL menggunakan alat pg_chameleon</a></li>
<li><a href="../id425707/index.html">Sistem pemberitahuan dari konsol ke Telegram</a></li>
<li><a href="../id425709/index.html">Kami membuat memo untuk orang Cina yang datang kepadamu</a></li>
<li><a href="../id425711/index.html">Kerugian baris tidak cocok</a></li>
<li><a href="../id425715/index.html">Program pendidikan dalam bidang kimia: pembalikan asam dari sirkuit mikro (bagaimana mengekspos kristal rangkaian mikro untuk pemotretan selanjutnya)</a></li>
<li><a href="../id425717/index.html">Jaringan saraf untuk pengembang C ++</a></li>
<li><a href="../id425719/index.html">Seledri dalam proyek sibuk: sedikit latihan</a></li>
<li><a href="../id425723/index.html">Facebook secara aktif mengembangkan layanan untuk mencari pekerjaan dan merekrut karyawan di jejaring sosial</a></li>
<li><a href="../id425725/index.html">Case Nintendo Patents - Game Boy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>