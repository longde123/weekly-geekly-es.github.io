<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📃 👏🏻 🙈 编译器体系结构的简要概述 ㊗️ 🕐 ☄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大多数编译器具有以下架构： 



 在本文中，我将逐个要素详细剖析该体系结构。 
 我们可以说本文是对编译器主题的大量现有资源的补充。 它是一种自治资源，可让您了解编程语言的设计和实现基础。 

 本文的目标读者是对编译器工作的想法极为有限的人（最大程度是他们参与编译）。 但是，我希望读者能理解数...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>编译器体系结构的简要概述</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/451894/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ej/-i/slej-ivpokabgczeqdbgiafc0rw.jpeg"></div><br> 大多数编译器具有以下架构： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73e/ff7/c46/73eff7c467213f5de1b9134666f9e569.png"><br><br> 在本文中，我将逐个要素详细剖析该体系结构。 <br> 我们可以说本文是对编译器主题的大量现有资源的补充。 它是一种自治资源，可让您了解编程语言的设计和实现基础。 <br><br> 本文的目标读者是对编译器工作的想法极为有限的人（最大程度是他们参与编译）。 但是，我希望读者能理解数据结构和算法。 <br><br> 本文决不是专门针对具有数百万行代码的现代生产编译器的，不，这是一门简短的课程“傻瓜编译器”，有助于理解编译器是什么。 <br><a name="habracut"></a><br><h2> 引言 </h2><br> 我目前正在研究受Rust和Go启发的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Krug</a>系统语言。 在本文中，我将以克鲁格为例来说明我的想法。  Krug正在开发中，但已经在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">caasper</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">krug</a>存储库中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/krug-lang</a>上可用。 与通常的编译器体系结构相比，该语言不是很典型，后者在一定程度上激发了我写一篇文章的知识，但稍后会介绍更多。 <br><br> 我赶紧通知您，我绝对不是编译器专家！ 我没有博士学位，也没有接受任何正式的培训-我在业余时间自己研究了本文中描述的所有内容。 我还必须说，我不是在描述创建编译器的实际的，唯一的真实方法，而是要介绍适用于创建小型“玩具”编译器的基本方法。 <br><br><h2> 前端 </h2><br> 让我们回到上面的图：指向前端字段的左侧箭头是众所周知的并且喜欢的语言，例如C。前端看起来像这样：词法分析-&gt;解析器。 <br><br><h2> 词法分析 </h2><br> 当我开始研究编译器和语言设计时，被告知词法分析与标记化相同。 我们将使用此描述。 分析器以字符串或字符流的形式获取输入数据，并识别其中的模式，并将其切成标记。 <br><br> 对于编译器，它在输入处接收一个编写的程序。 从文件中将其读取为字符串，然后分析器标记其源代码。 <br><br><pre><code class="plaintext hljs">enum TokenType { Identifier, Number, }; struct Token { std::string Lexeme; TokenType type; // ... // It's also handy to store things in here // like the position of the token (start to end row:col) };</code> </pre> <br> 在以C形语言编写的此片段中，您可以看到包含上述词素的结构以及用于识别此令牌的TokenType。 <br><br> 注意：本文并不是有关使用示例创建语言的说明-但为了更好地理解，我将不时插入代码段。 <br><br> 分析器通常是最简单的编译器组件。 实际上，与其余拼图相比，整个前端非常简单。 尽管这在很大程度上取决于您的工作。 <br><br> 采取以下C代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello world!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br> 从文件读取它到一行并执行线性扫描后，您也许可以切片令牌。 我们以一种自然的方式识别标记-看到int是一个“单词”，而return语句中的0是一个“数字”。 词法分析器执行与我们相同的过程-稍后我们将更详细地检查此过程。 例如，分析数字： <br><br><pre> <code class="plaintext hljs">0xdeadbeef — HexNumber ( ) 1231234234 — WholeNumber ( ) 3.1412 — FloatingNumber (   ) 55.5555 — FloatingNumber (   ) 0b0001 — BinaryNumber ( )</code> </pre> <br> 定义单词可能很困难。 大多数语言将单词定义为字母和数字的序列，标识符通常应以字母或下划线开头。 例如： <br><br><pre> <code class="plaintext hljs">123foobar := 3 person-age := 5 fmt.Println(123foobar)</code> </pre> <br> 在Go中，此代码将不被认为是正确的，并将被解析为以下标记： <br><br><pre> <code class="plaintext hljs">Number(123), Identifier(foobar), Symbol(:=), Number(3) ...</code> </pre> <br> 遇到的大多数标识符如下所示： <br><br><pre> <code class="plaintext hljs">foo_bar __uint8_t fooBar123</code> </pre> <br> 分析人员将不得不解决其他问题，例如空格，多行和单行注释，标识符，数字，数字系统和数字格式（例如1_000_000）和编码（例如，支持UTF8而不是ASCII）。 <br><br> 如果您认为可以使用正则表达式-最好不要这样做。 从零开始编写分析器要容易得多，但是我强烈建议您从我们的国王和上帝罗布·派克那里阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这篇文章</a> 。 正则表达式不适用于我们的原因在其他许多文章中都有介绍，因此我将忽略这一点。 此外，编写分析器比早上5:24上传到regex101.com的冗长冗长的表达式折磨自己要有趣得多。 在我的第一种语言中，我使用了<code>split(str)</code>函数进行标记化-而且我走得很远。 <br><br><h2> 解析中 </h2><br> 解析比词法分析要复杂得多。 解析器和解析器生成器很多-游戏在这里以很大的方式开始。 <br><br> 编译器中的解析器通常以令牌形式获取输入并构建特定的树-抽象语法树或解析树。 从本质上讲，它们是相似的，但有一些区别。 <br><br> 这些阶段可以表示为功能： <br><br><pre> <code class="plaintext hljs">fn lex(string input) []Token {...} fn parse(tokens []Token) AST {...} let input = "int main() { return 0; }"; let tokens = lex(input); let parse_tree = parse(tokens); // ....</code> </pre> <br> 通常，编译器是由许多小的组件构成的，这些组件接受输入，更改输入或将它们转换为不同的输出。 这是功能语言非常适合创建编译器的原因之一。 其他原因是出色的基准测试和相当广泛的标准库。 有趣的事实： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rust</a>编译器的第一个实现是在Ocaml上。 <br><br> 我建议您将这些组件保持尽可能简单和自治-模块化将大大简化此过程。 我认为，软件开发的许多其他方面也可以这样说。 <br><br><h2> 树木 </h2><br><h4> 解析树 </h4><br> 这到底是什么？ 也称为解析树，此厚树用于可视化源程序。 它们包含有关输入程序的所有信息（或大部分信息），通常与您的语言语法中描述的信息相同。 每个树节点都将是尾随的或不可尾随的，例如NumberConstant或StringConstant。 <br><br><h4> 抽象语法树 </h4><br> 顾名思义，ASD是<i>抽象</i>语法树。 解析树包含有关您的程序的许多（通常是冗余的）信息，对于ASD，则不是必需的。  ASD不需要有关结构和语法的无用信息，这不会影响程序的语义。 <br><br> 假设您的树具有（（5 + 5）-3）+2这样的表达式。 在解析树中，您将完整地将其与括号，运算符和值5、5、3和2一起存储。但是，您可以简单地与ASD关联-我们只需要知道值，运算符及其顺序即可。 <br><br> 下图显示了表达式a + b / c的树。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98c/61a/cb3/98c61acb355e7887b53b5c37de0aa34f.png" width="400"></div><br>  ASD可以表示如下： <br><br><pre> <code class="plaintext hljs">interface Expression { ... }; struct UnaryExpression { Expression value; char op; }; struct BinaryExpression { Expression lhand, rhand; string op; // string because the op could be more than 1 char. }; interface Node { ... }; // or for something like a variable struct Variable : Node { Token identifier; Expression value; };</code> </pre> <br> 该视图非常有限，但是我希望您能看到节点的结构。 要进行解析，可以采用以下过程： <br><br><pre> <code class="plaintext hljs">Node parseNode() { Token current = consume(); switch (current.lexeme) { case "var": return parseVariableNode(); // ... } panic("unrecognized input!"); } Node n = parseNode(); if (n != null) { // append to some list of top level nodes? // or append to a block of nodes! }</code> </pre> <br> 我希望您能从高级语言构造入手，了解如何逐步进行其余节点的解析。 如何精确实现具有递归下降的解析器，您需要学习一下自己。 <br><br><h2> 文法 </h2><br> 从一组令牌中解析ADS可能很困难。 通常，您应该从语言语法入手。 本质上，语法决定语言的结构。 有几种用于定义可以描述（或解析）自身的语言的语言。 <br><br> 用于确定语言的语言的示例是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Backus-Naur</a> （RBNF）的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">扩展形式</a> 。 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BNF</a>的变体，带有较少的尖括号。 这是来自维基百科文章的RBNF示例： <br><br><pre> <code class="plaintext hljs">digit excluding zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ; digit = "0" | digit excluding zero ;</code> </pre> <br> 定义了生产规则：它们指示哪个终端模板是“非终端”的。 终端是字母的一部分，例如，上例中的if标记或0和1是终端。 非终结符是相反的，它们位于生产规则的左侧，可以将它们视为指向终端和非终结点组的变量或“命名指针”。 <br><br> 许多语言都有包含语法的规范。 例如，对于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Go</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rust</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">D。</a> <br><br><h2> 递归下降分析仪 </h2><br> 递归下降是许多解析方法中最简单的。 <br><br> 递归下降分析器-基于递归过程的下降。 编写解析器要容易得多，因为语法没有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">左递归</a> 。 在大多数“玩具”语言中，此技术足以解析。 尽管以前使用YACC，但GCC使用手写的降序解析器。 <br><br> 但是，解析这些语言可能会导致问题。 特别是C，其中 <br><br><pre> <code class="cpp hljs">foo * bar</code> </pre> <br> 可以解释为 <br><br><pre> <code class="plaintext hljs">int foo = 3; int bar = 4; foo * bar; // unused expression</code> </pre> <br> 或如何 <br><br><pre> <code class="plaintext hljs">typedef struct { int b; } foo; foo* bar; bar.b = 3;</code> </pre> <br>  Clang实现还使用递归下降分析器： <br><br>  <i>由于这是常规的C ++代码，因此递归下降使初学者更容易理解它。</i>  <i>它支持C / C ++所需的自定义规则和其他奇怪的东西，并帮助您轻松诊断和修复错误。</i> <br><br> 还值得关注其他方法： <br><br><ul><li> 递减LL，递归下降 </li><li> 升LR，移位，上升下降 </li></ul><br><h2> 解析器生成器 </h2><br> 另一个好方法。 当然，也有缺点-但这可以说是程序员在创建软件时所做的任何其他选择。 <br><br> 解析器生成器非常快地工作。 比起编写自己的分析仪并获得质量结果，使用它们要容易得多-尽管它们并不十分用户友好，并且并不总是显示错误消息。 另外，您将必须学习如何使用解析器生成器，并且在升级编译器时，可能必须解散解析器生成器。 <br><br> 解析器生成器的一个示例是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ANTLR</a> ，还有很多其他的。 <br><br> 我认为该工具适合那些不想花时间编写前端的人，并且更愿意编写编译器/解释器的中间和后端并分析任何内容的人。 <br><br><h2> 解析应用 </h2><br> 如果您仍然不了解自己。 甚至编译器前端（lex / parse）也可以用来解决其他问题： <br><br><ul><li> 语法高亮 </li><li> 用于渲染引擎的HTML / CSS解析 </li><li> 编译器：TypeScript，CoffeeScript </li><li> 连接器 </li><li> 正则表达式 </li><li> 界面数据分析 </li><li>  URL解析 </li><li> 格式工具，例如<i>gofmt</i> </li><li>  SQL解析等等。 </li></ul><br><h2> 中端 </h2><br> 语义分析！ 创建编译器时，语言语义分析是最困难的任务之一。 <br><br> 您需要确保所有输入程序都能正常工作。 在我的Krug语言中，还没有包括与语义分析有关的方面，如果没有它，将始终要求程序员编写正确的代码。 实际上，这是不可能的-我们总是编写，编译，有时运行，纠正错误。 这种螺旋是无止境的。 <br><br> 此外，如果不在适当的编译阶段分析语义的正确性，就不可能编译程序。 <br><br> 我曾经遇到一张有关前端，中端和后端百分比的图表。 然后看起来像 <br><br><pre> <code class="plaintext hljs">F: 20% M: 20%: B: 60%</code> </pre> <br> 今天就像 <br><br><pre> <code class="plaintext hljs">F: 5% M: 60% B: 35%</code> </pre> <br> 前端主要与生成器有关，在不具有语法二元性的无上下文语言中，它们可以很快完成-递归下降将在这里提供帮助。 <br><br> 借助LLVM技术，大多数优化工作都可以上载到框架中，从而提供了许多现成的优化方法。 <br><br> 下一步是语义分析，这是编译阶段的重要部分。 <br><br> 例如，在Rust中，借助其内存管理模型，编译器可充当强大的大型计算机，对入门表格执行各种类型的静态分析。 此任务的一部分是将输入数据转换成更方便的形式以进行分析。 <br><br> 因此，语义分析在编译器的体系结构中起着重要的作用，并且为您完成了各种准备工作，例如优化生成的程序集或读取ASD中的输入数据。 <br><br><h2> 语义通道 </h2><br> 在语义分析的过程中，大多数编译器对SDA或其他抽象形式的代码表达进行大量的“语义传递”。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a>提供有关.NET C＃编译器进行的大多数传递的详细信息。 <br><br> 我不会考虑每个段落，特别是因为它们会因语言而异，但是下面在Krug中介绍了几个步骤。 <br><br><h2> 顶级广告 </h2><br> 编译器将遍历模块中的所有“顶级”公告，并意识到它们的存在。 他不会深入探讨块-他只会声明哪些结构，功能等。 在一个或另一个模块中可用。 <br><br><h2> 名称/符号解析 </h2><br> 编译器将遍历函数中所有的代码块，等等。 并解决它们-即找到需要许可的字符。 这是一个常见的过程，正是从这里开始，在编译Go代码时通常<i>不会出现此类符号XYZ</i>错误。 <br><br> 执行此过程可能非常困难，尤其是在依赖关系图中存在循环依赖关系的情况下。 某些语言不允许使用这些语言，例如，如果您的其中一个软件包形成循环，Go会抛出错误，例如我的Krug语言。 循环依赖性可以被认为是不良体系结构的副作用。 <br><br> 可以通过在依赖关系图中修改DFS来确定循环，也可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tarjan算法</a> （由Krug完成）来定义（多个）循环。 <br><br><h2> 类型推断 </h2><br> 编译器将遍历所有变量并显示其类型。  Krug中的类型推断非常弱；它仅根据变量的值输出变量。 这绝不是一个奇怪的系统，就像您可以在Haskell这样的功能语言中找到的系统一样。 <br><br> 类型可以使用“统一”过程或“类型统一”来派生。 对于更简单的系统，可以使用非常简单的实现。 <br><br> 类型是在Krug中实现的，如下所示： <br><br><pre> <code class="plaintext hljs">interface Type {}; struct IntegerType : Type { int width; bool signed; }; struct FloatingType : Type { int width; }; struct ArrayType : Type { Type base_type; uint64 length; };</code> </pre> <br> 您还可以进行简单的类型推断，即在其中将类型分配给表达式节点，例如， <code>IntegerConstantNode</code>可以是IntegerType（64）类型。 然后，您可能会得到<code>unify(t1, t2)</code>函数，该函数将选择最宽的类型，该类型可用于推导更复杂的表达式的类型，例如二进制表达式。 因此，需要在左侧将变量分配给右侧的给定类型的值。 <br><br> 我曾经在Go上编写过一个简单的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类型转换</a> ，它成为Krug的原型实现。 <br><br><h2> 变异通行证 </h2><br> 默认情况下，Krug（如Rust）是一种不可变的语言，也就是说，除非另有说明，否则变量将保持不变： <br><br><pre> <code class="plaintext hljs">let x = 3; x = 4; // BAD! mut y = 5; y = 6; // OK!</code> </pre> <br> 编译器遍历所有块和函数，并检查其“变量正确”，即，我们不更改未遵循的内容，并且传递给某些函数的所有变量在需要时都是恒定的或可变的。 <br><br> 这是借助先前遍历中收集的符号信息来完成的。 基于语义传递结果的符号表包含令牌名称和变量可变性的符号。 它可能包含其他数据，例如，在C ++中，表可以存储有关符号是外部符号还是静态符号的信息。 <br><br><h2> 角色表 </h2><br> 字符表或“ stab”是用于查找程序中使用的字符的表。 为每个作用域创建一个表，并且所有表都包含有关特定作用域中存在的字符的信息。 <br><br> 此信息包括符号名称，类型，可变性的符号，外部通信的存在，静态存储器中的位置等属性。 <br><br><h3> 适用范围 </h3><br> 这是编程语言中的重要概念。 当然，您的语言并不一定要创建嵌套的作用域，所有内容都可以放在一个通用的命名空间中！ <br><br> 尽管表示范围对于编译器体系结构是一项有趣的任务，但是在大多数类似于C的语言中，范围的行为（或确实）类似于堆栈数据结构。 <br><br> 通常，我们创建和销毁作用域，并且它们通常用于管理名称，也就是说，它们使我们能够隐藏（隐藏）变量： <br><br><pre> <code class="plaintext hljs">{ // push scope let x = 3; { // push scope let x = 4; // OK! } // pop scope } // pop scope</code> </pre> <br> 可以用不同的方式表示： <br><br><pre> <code class="plaintext hljs">struct Scope { Scope* outer; SymbolTable symbols; }</code> </pre> <br> 有点小题外话，但我建议阅读有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">意大利面条堆栈的信息</a> 。 这是一种数据结构，用于在相对块的ASD节点中存储可见性区域。 <br><br><h2> 类型系统 </h2><br> 下面的许多部分可以分解为单独的文章，但在我看来，这个标题应该得到最大的支持。 如今，有关类型系统以及系统本身的变体的大量信息可用，许多副本都围绕这些信息而破裂。 我不会<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">深入探讨</a>这个主题，只留下与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Steve Klabnik</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">精彩文章的链接</a> 。 <br><br> 类型系统是使用编译器表示形式和对这些表示形式的分析在编译器中提供并在语义上定义的。 <br><br><h2> 拥有 </h2><br> 这个概念越来越多地用于编程中。 所有权和移动语义的原理已嵌入<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rust</a>语言中，我希望它们会以其他语言出现。  Rust执行许多不同类型的静态分析，这些分析检查输入是否满足有关内存的一组规则：谁拥有哪个内存，何时销毁内存以及对这些值或内存存在多少引用（或借用）。 <br><br>  Rust的优点在于，所有这些都是在编译期间在编译器内部完成的，因此程序员不必处理垃圾回收或链接计数。 所有这些语义都分配给类型系统，甚至可以在以完整二进制文件的形式呈现程序之前就可以提供所有这些语义。 <br><br> 我不能说这一切是如何进行的，但这都是Mozilla团队和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cyclone</a>项目参与者进行静态分析和出色研​​究的结果。 <br><br><h2> 控制流程图 </h2><br> 为了表示程序流，我们使用控制流图（CFG），其中包含程序执行可以遵循的所有路径。 在语义分析中使用它来排除代码的空闲部分，即程序执行期间将永远无法实现的块，函数甚至模块。 图形还可以用于识别不能中断的循环。 或搜索无法访问的代码，例如，当您调用“紧急事件”（称为紧急事件）或在循环中返回而循环外的代码不执行时。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据流分析</a>在编译器的语义阶段起着重要的作用，因此，我建议阅读有关您可以执行的分析类型，其工作方式以及优化工作的信息。 <br><br><h2> 后端 </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/330/914/1b9/3309141b9d53be1d9e5c8f77fb46d982.jpg"><br>  <i>我们的架构方案的最后一部分。</i> <br><br> 我们已经完成了生成可执行二进制文件的大部分工作。 这可以通过多种方式完成，我们将在下面讨论。 <br><br>        - ,   . ,     ,    «». <br><br><h2>     </h2><br>   ,           . ,    ,      .   ,   ,         ,    .        ,      . <br><br>   ,           .  ,   ++ — Cfront —     C. <br><br>    JavaScript.     TypeScript    ,     ,   ,              ,         . <br><br>    «» ,     ,             ,       ,    «  »  .        —   ,        ,     . <br><br><h2> LLVM </h2><br>          LLVM: Rust, Swift, C/C++ (clang), D, Haskell. <br><br>    « »,             ,      .     , LLVM      .   ,       .  ,   ,     , , 1, 4, 8  16-.       ,  ,   -    . <br><br><h2>  - </h2><br>      —     , —     ,      . <br><br> Go —    ,      LLVM (    ). Go     ,    Windows, Linux  MacOS. ,    Krug    -. <br><br>        .  ,     LLVM,     ,   ,        LLVM      ,     . <br><br>   ,        ,       ,        LLVM,      IR,    ,  , ,    (    ). <br><br>     .      ,         ,   ,       .       IR (    )  «»       fprintf   .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8cc</a> . <br><br><h2>   </h2><br>             .   — Java:  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JVM</a>        , , Kotlin. <br><br>     ,   Java   .         ,           .            ,       . <br>   , JVM   JIT       ,     JIT-,     . <br><br><h2>  </h2><br>     ,      !      ,     ,   .   -          ,   ,   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Godbolt</a> —  ,  ,             .       , ,     . <br><br>      ,         ,       (strip the debug symbols),  ,   GCC.     ,  -  . <br><br>            .       .    ,         .        production-. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>        rwmj ,    8  ,   80%     .        1971-!    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>  ,  Rust. <br><br><h2> IR </h2><br>   (intermediate representation, IR)  ,  .      ,        ,     . <br><br>   IR     .      ,  ,    ,    . <br><br>    IR,  «»,       IR   . , SSA — Static Single Assignment,   ,        . <br><br>  Go     IR   SSA. IR  LLVM   SSA,    . <br><br>  SSA   ,  ,   (constant propagation),     ( )  . <br><br><h2>   </h2><br>      ,  .  ,    ,   ,      ,    .         (  16  32),     ,      (spill to the stack). <br><br>   —             (   ).     ,     ,          . <br><br>     : <br><br><ul><li>   (graph colouring) —   (NP- ).      ,     (liveness ranges) . <br></li><li>   —       . <br></li></ul><br><h2>     </h2><br>     . ,       .   ,       ,         . <br><br><h2>   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Name Mangling</a> ) </h2><br>    -,            ,        .         ,   . <br><br><pre> <code class="plaintext hljs">fn main() int { let x = 0; { let x = 0; { let x = 0; } } return 0; }</code> </pre> <br> ,    (  -    :) )      ,      .        ,        . <br><br><h2>   </h2><br>   LLDB     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DWARF</a> .     LLVM   ,   DWARF         GNU-. ,     ,     ,   . <br><br><h2>    (Foreign Function Interface, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FFI</a> ) </h2><br>   libc   ,        ,      .       ,        ? <br><br><h2>  </h2><br>   —  .     ,      (  .s/.asm)?       ? ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jai</a>        .   ,     . <br><br><h2>    (CaaS) </h2><br>         API-.  ,       Krug-,         .  ,     ,      . <br><br> ,     , ,      .         ,     API-. <br><br>   production-   CaaS.    Microsofts Roslyn,       ,     .    , , ,      ,     API-,     , ,  Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RLS</a> . <br><br>    Krug —        —   Caasper  CaaS-. <br><br> Caasper      (,  ,  ),      , krug,    .   ,        ,      (bootstrap)   ,     . <br><br>   Krug   JavaScript,       Go*,  , ,   Krug. JavaScript     ,         yarn/npm. <br><br> <i>*      Go   ()  ,    JS.</i> <br><br>    Caasper  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> Github   Krug,    D    LLVM.       YouTube- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . <br><br>   Krug ()  <a href=""></a> . <br><br><h2> 有用的链接 </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jack Crenshaw</a> —        . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Crafting Interpreters</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  LLVM ( Go)</a> — ! <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PL/0</a> <br></li><li> The Dragon Book —  ,    . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8cc</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN451894/">https://habr.com/ru/post/zh-CN451894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN451878/index.html">将立体声视频实时流传输到VR眼镜（Oculus Go）</a></li>
<li><a href="../zh-CN451880/index.html">DevPRO'19：从Wrike展位观看</a></li>
<li><a href="../zh-CN451884/index.html">从事开发人员七年：我学到了什么</a></li>
<li><a href="../zh-CN451886/index.html">在测试中使用离散数学</a></li>
<li><a href="../zh-CN451890/index.html">在BIND中委派小于/ 24的反向子网区域。 如何运作</a></li>
<li><a href="../zh-CN451896/index.html">“牢不可破”的eyeDisk受虹膜扫描保护，但以明文形式传输密码</a></li>
<li><a href="../zh-CN451898/index.html">俄语创新</a></li>
<li><a href="../zh-CN451900/index.html">Facebook对浏览器API的第一项贡献</a></li>
<li><a href="../zh-CN451902/index.html">Microsoft Azure开发人员营地俄罗斯</a></li>
<li><a href="../zh-CN451904/index.html">有时候，更多就是更少。 当负载减少导致延迟增加时</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>