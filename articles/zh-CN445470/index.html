<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚫 👩‍👧‍👦 😐 DCF77：准确的时间信号传输系统如何工作？ 👸🏼 🙅🏼 🌏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha 

 可能有很多购买手表或气象站的人在包装上看到了无线电钟的徽标，甚至是原子钟。 这非常方便，因为将时钟放在桌子上就足够了，过一会儿它们会自动调整为准确的时间。 



 让我们看看它是如何工作的，并用Python编写一个解码器。 

 有不同的时间同步系统。 在欧洲最受欢迎的是德国的DCF...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DCF77：准确的时间信号传输系统如何工作？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445470/"> 哈Ha <br><br> 可能有很多购买手表或气象站的人在包装上看到了无线电钟的徽标，甚至是原子钟。 这非常方便，因为将时钟放在桌子上就足够了，过一会儿它们会自动调整为准确的时间。 <br><br><img src="https://habrastorage.org/webt/ev/vs/ia/evvsia3kcrvsnw_gxwoe_jen5r0.png"><br><br> 让我们看看它是如何工作的，并用Python编写一个解码器。 <br><a name="habracut"></a><br> 有不同的时间同步系统。 在欧洲最受欢迎的是德国的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DCF-77系统</a> ，日本有自己的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JJY</a>系统，美国有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WWVB</a>系统，依此类推。 此外，故事将是关于DCF77的故事，DCF77是最相关的并且可以在俄罗斯欧洲部分地区和邻国的某些地方接收（远东地区的居民可能有相反的看法，但是他们反过来可以接收和分析日本的信号;）。 <br><br> 下面写的所有内容都与DCF77有关。 <br><br><h2> 信号接收 </h2><br>  DCF77是一个长波站，工作频率为77.5KHz，并以调幅方式发送信号。 容量为50 kW的电站位于距法兰克福25公里的地方，其始建于1959年，1973年将日期信息添加到准确的时间。 频率为77KHz时的波长非常大，因此天线场的尺寸也非常合适（来自Wikipedia的照片）： <br><br><img src="https://habrastorage.org/webt/df/du/2l/dfdu2lbixopwvordolwij3w_ncs.png"><br><br> 有了这样的天线和电源输入，接收区域几乎覆盖了整个欧洲，白俄罗斯，乌克兰和俄罗斯的部分地区。 <br><br><img src="https://habrastorage.org/webt/my/xz/wu/myxzwuf8yjqunjcn5rah1f1oyry.png"><br><br> 每个人都可以录制信号。 为此，只需转到在线接收器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://websdr.ewi.utwente.nl:8901/</a> ，在此处选择76.5KHz的频率并进行USB调制。 这样的图片应该打开： <br><br><img src="https://habrastorage.org/webt/d4/yt/lc/d4ytlcfvkgf_7ea-vgytr-eljum.png"><br><br> 在那里，我们按下下载按钮，并记录了几分钟的片段。 当然，如果您有一个能够记录77.5KHz频率的“真实”接收器，则可以使用它。 <br><br> 当然，当我们通过Internet接收到准确时间的无线电信号时，我们将不会获得真正准确的时间-信号被延迟发送。 但是我们的目标仅仅是了解信号的结构；为此，Internet记录已绰绰有余。 当然，在现实生活中，会使用用于接收和解码的专用设备，下面将对其进行讨论。 <br><br> 因此，我们得到了记录，让我们开始处理它。 <br><br><h2> 信号解码 </h2><br> 使用Python下载文件并查看其结构： <br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> signal <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np sample_rate, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"dcf_websdr_2019-03-26T20_25_34Z_76.6kHz.wav"</span></span>) plt.plot(data[:<span class="hljs-number"><span class="hljs-number">100000</span></span>]) plt.show()</code> </pre> <br> 我们看到一个典型的幅度调制： <br><br><img src="https://habrastorage.org/webt/ls/ew/oz/lsewoz-zrzcjvpfcr4pbtnmbmva.png"><br><br> 为了简化解码，我们使用希尔伯特变换获取信号的包络： <br><br><pre> <code class="python hljs">analytic_signal = signal.hilbert(data) A = np.abs(analytic_signal) plt.plot(A[:<span class="hljs-number"><span class="hljs-number">100000</span></span>])</code> </pre> <br> 结果以放大视图显示： <br><br><img src="https://habrastorage.org/webt/ny/gn/ac/nygnacnm-kwcoba12j6vks-ixk0.png"><br><br> 我们使用低通滤波器消除干扰产生的辐射，同时计算平均值，稍后将便于解析。 <br><br><pre> <code class="python hljs">b, a = signal.butter(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">20.0</span></span>/sample_rate) zi = signal.lfilter_zi(b, a) A, _ = signal.lfilter(b, a, A, zi=zi*A[<span class="hljs-number"><span class="hljs-number">0</span></span>]) avg = (np.amax(A) + np.amin(A))/<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br> 结果（黄线）：几乎是矩形的信号，相当容易分析。 <br><br><img src="https://habrastorage.org/webt/fa/yp/wn/faypwn97babbqqgosvekm7eys90.png"><br><br><h2> 解析中 </h2><br> 首先，您需要获取位序列。 信号结构本身非常简单。 <br><br><img src="https://habrastorage.org/webt/hm/hy/s5/hmhys54d9zic5a6ltn7e32oyklg.png"><br><br> 脉冲分为第二间隔。 如果脉冲之间的距离为0.1 s（即脉冲本身的长度为0.9 s），则在位序列中添加“ 0”；如果距离为0.2 s（即长度为0.8 s），则添加“ 1”。 每分钟的结束由2s长的“长”脉冲指示，位序列重置为零，然后重新开始填充。 <br><br> 上面的代码很容易用Python编写。 <br><br><pre> <code class="python hljs">sig_start, sig_stop = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span> bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> pos &lt; cnt - <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A[pos] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> A[pos+<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: <span class="hljs-comment"><span class="hljs-comment"># Signal begin sig_start = pos if A[pos] &gt; avg and A[pos+1] &lt; avg: # Signal end sig_stop = pos diff = sig_stop - sig_start if diff &lt; 0.85*sample_rate: bits_str += "1" if diff &gt; 0.85*sample_rate and diff &lt; 1.25*sample_rate: bits_str += "0" if diff &gt; 1.5*sample_rate: print(bits_str) bits_str = "" pos += 1</span></span></code> </pre><br> 结果，我们得到了一些位序列，在我们的示例中，两分钟看起来像这样： <br><br> <code>0011110110111000001011000001010000100110010101100010011000 <br> 0001111100110110001010100001010000100110010101100010011000</code> <br> <br> 顺便说一句，有趣的是，信号中存在数据的“第二层”。 还使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">相位调制</a>对位序列进行编码。 从理论上讲，即使在信号减弱的情况下，这也应提供更稳定的解码。 <br><br> 我们的最后一步：获取实际数据。 比特每秒传输一次，因此我们只有59个比特，其中编码了很多信息： <br><br><img src="https://habrastorage.org/webt/e2/r1/le/e2r1le0xrrrgenjxxlpmwo5h3v0.png"><br><br> 这些位在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wikipedia</a>上进行了描述，并且非常好奇。 尽管已经计划将其用于预警系统<s>和民防</s>系统，但并未使用前15位。 位A1表示下一小时时钟将设置为夏令时。 位A2表示下一小时将增加一<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">秒钟</a> ，有时用于根据地球自转校正时间。 其余位编码小时，分钟和日期。 <br><br><img src="https://habrastorage.org/webt/fh/ti/oj/fhtiojtscjytfzu1rk4a_0yt4pw.png"><br><br> 对于那些想自己尝试的人，在扰流器下提供了用于解码的代码。 <br><br><div class="spoiler">  <b class="spoiler_title">源代码</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'0'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> bits[<span class="hljs-number"><span class="hljs-number">20</span></span>] != <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> minutes, hours, day_of_month, weekday, month, year = map(convert_block, (bits[<span class="hljs-number"><span class="hljs-number">21</span></span>:<span class="hljs-number"><span class="hljs-number">28</span></span>], bits[<span class="hljs-number"><span class="hljs-number">29</span></span>:<span class="hljs-number"><span class="hljs-number">35</span></span>], bits[<span class="hljs-number"><span class="hljs-number">36</span></span>:<span class="hljs-number"><span class="hljs-number">42</span></span>], bits[<span class="hljs-number"><span class="hljs-number">42</span></span>:<span class="hljs-number"><span class="hljs-number">45</span></span>], bits[<span class="hljs-number"><span class="hljs-number">45</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>], bits[<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">58</span></span>])) days = (<span class="hljs-string"><span class="hljs-string">'Sunday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Monday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Tuesday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Wednesday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Thursday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Friday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Saturday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sunday'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'{dow}, {dom:02}.{mon:02}.{y}, {h:02}:{m:02}'</span></span>.format(h=hours, m=minutes, dow=days[weekday], dom=day_of_month, mon=month, y=year)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert_ones</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(<span class="hljs-number"><span class="hljs-number">2</span></span>**i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, bit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(bits) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bit == <span class="hljs-string"><span class="hljs-string">'1'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert_tens</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>*convert_ones(bits) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right_parity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits, parity_bit)</span></span></span><span class="hljs-function">:</span></span> num_of_ones = sum(int(bit) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> bit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bits) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num_of_ones % <span class="hljs-number"><span class="hljs-number">2</span></span> == int(parity_bit) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits, parity=False)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> parity <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> right_parity(bits[:<span class="hljs-number"><span class="hljs-number">-1</span></span>], bits[<span class="hljs-number"><span class="hljs-number">-1</span></span>]): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> ones = bits[:<span class="hljs-number"><span class="hljs-number">4</span></span>] tens = bits[<span class="hljs-number"><span class="hljs-number">4</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> convert_tens(tens) + convert_ones(ones)</code> </pre><br></div></div><br> 运行该程序，我们将看到以下内容： <br><br> <code>0011110110111000001011000001010000100110010101100010011000 <br> Tuesday, 26.03.19, 21:41 <br> 0001111100110110001010100001010000100110010101100010011000 <br> Tuesday, 26.03.19, 21:42</code> <br> <br> 其实，这就是魔术。 这种系统的优点是解码非常简单，并且可以在任何最简单的微控制器上完成。 只需计算脉冲的长度，累积60位，然后在每分钟结束时我们便获得了准确的时间。 与其他时间同步方法（例如GPS或Internet禁止使用Internet ：）相比，这种无线电同步实际上不需要电-例如，普通的家庭气象站使用2节AA电池可工作约一年。 因此，即使是手表，也具有无线电同步功能，更不用说墙壁或街道站了。 <br><br>  DCF的便捷和简单吸引了自制产品的爱好者。 仅需10至20美元，您就可以从天线上购买一个现成的模块，该天线带有现成的接收器和TTL输出，可以连接到Arduino或其他控制器。 <br><br><img src="https://habrastorage.org/webt/po/ph/mk/pophmk5x_xmgb3dzozwu34sbxya.png"><br><br> 对于Arduino，已经编写了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现成的库</a> 。 但是，众所周知，无论您在微控制器上做什么，都会得到时钟或气象站。 使用这样的设备，只要您在接待区，就可以很容易地获得准确的时间。 好了，您可以在手表上悬挂“ Atomic Clock”字样，同时向所有需要它的人解释，该设备实际上是使用原子钟同步的。 <br><br> 那些愿意的人甚至可以通过安装带有无线电同步功能的新机制来升级旧祖母的手表： <br><br><img src="https://habrastorage.org/webt/om/5w/2k/om5w2k-nno2ueo5tpxk6pkrrpls.png"><br><br> 您可以在eBay上使用关键字“无线电遥控运动”找到一个。 <br><br> 最后，对于那些在这里阅读过文章的人来说，这是一个生活技巧。 即使在接下来的数千公里中没有一个无线电信号的发送器，这种信号也很容易独立产生。  Google Play有一个名为“ DCF77 Emulator”的程序，可将信号输出到耳机。 根据作者的说法，如果将耳机线缠在手表上，它们会捕获信号（我不知道是怎么回事，因为普通耳机不会给出77KHz信号，但是接收信号可能来自谐波）。 我的程序根本无法在Android 9上运行-根本没有声音（或者也许我听不到-毕竟是77KHz ：），但是也许有人会更幸运。 但是，有些人使自己成为了成熟的DCF信号发生器，可以在同一Arduino或ESP32上轻松实现： <br><br><img src="https://habrastorage.org/webt/vs/ye/jk/vsyejk6pr6mxfymg55fqscbzn1i.png"><br>  （来源<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">sgfantasytoys.wordpress.com/2015/05/13/synchronize-radio-control-watch-without-access</a> ） <br><br><h2> 结论 </h2><br> 事实证明，DCF系统确实非常简单和方便。 借助价格便宜的简单接收器，您可以随时随地在接收区获得准确的时间。 看起来，尽管数字化和“物联网”已经广泛使用，但在很长一段时间内仍将需要这种简单的解决方案。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN445470/">https://habr.com/ru/post/zh-CN445470/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN445458/index.html">电子艺界将与350名员工打交道，并“减少在俄罗斯的存在”</a></li>
<li><a href="../zh-CN445460/index.html">无配件互动</a></li>
<li><a href="../zh-CN445464/index.html">减少实验数据的样本量而不会丢失信息</a></li>
<li><a href="../zh-CN445466/index.html">祝贺Imagine Cup EMEA地区决赛冠军：来自英国的Finder团队！ 俄罗斯队排名第三</a></li>
<li><a href="../zh-CN445468/index.html">来自俄罗斯的团队在欧洲，非洲和中东的“想象杯”比赛中获得第三名</a></li>
<li><a href="../zh-CN445472/index.html">YouTube做出决定，审查制度！ 和往常一样，俄罗斯离不开</a></li>
<li><a href="../zh-CN445474/index.html">MODX Digest＃2.1（2019年3月11日至3月25日）</a></li>
<li><a href="../zh-CN445478/index.html">欧洲议会仍通过欧盟版权法修正案</a></li>
<li><a href="../zh-CN445480/index.html">有一头大象和一匹马的垫子。 三角形删除</a></li>
<li><a href="../zh-CN445482/index.html">6个用于Python编程的基本Python库</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>