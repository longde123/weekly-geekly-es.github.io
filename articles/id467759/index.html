<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßõüèª ü§æüèø üë® Desain OS seperti Unix - Ruang Alamat Virtual (6) üë∫ üë©üèø‚Äçü§ù‚Äçüë®üèº üß¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel sebelumnya, kami memeriksa dasar-dasar bekerja dalam mode yang dilindungi IA-32. Hari ini saatnya belajar cara bekerja dengan ruang alama...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desain OS seperti Unix - Ruang Alamat Virtual (6)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467759/">  Pada artikel sebelumnya, kami memeriksa dasar-dasar bekerja dalam mode yang dilindungi IA-32.  Hari ini saatnya belajar cara bekerja dengan ruang alamat virtual. <br><a name="habracut"></a><br><h4>  Daftar isi </h4><br>  Membangun sistem (make, gcc, gas).  Boot awal (multiboot).  Luncurkan (qemu).  Pustaka C (strcpy, memcpy, strext). <br><br>  Pustaka C (sprintf, strcpy, strcmp, strtok, va_list ...).  Membangun perpustakaan dalam mode kernel dan mode aplikasi pengguna. <br><br>  Log sistem kernel.  Memori video  Output ke terminal (kprintf, kpanic, kassert). <br>  Memori dinamis, tumpukan (kmalloc, kfree). <br><br>  Organisasi memori dan penanganan interupsi (GDT, IDT, PIC, syscall).  Pengecualian <br>  <b>Memori virtual (direktori halaman dan tabel halaman).</b> <br><br>  Proses  Perencana  Multitasking.  Panggilan sistem (bunuh, keluar, ps). <br><br>  Sistem file kernel (initrd), elf, dan internalnya.  Panggilan sistem (exec). <br><br>  Driver perangkat karakter.  Panggilan sistem (ioctl, fopen, fread, fwrite).  Pustaka C (fopen, fclose, fprintf, fscanf). <br><br>  Shell sebagai program lengkap untuk kernel. <br><br>  Mode perlindungan pengguna (ring3).  Segmen Status Tugas (tss). <br><br><h4>  Memori virtual </h4><br>  Memori virtual diperlukan agar setiap proses dapat diisolasi dari yang lain, mis.  tidak bisa menghentikannya.  Jika tidak ada memori virtual, kita harus memuat file elf di alamat berbeda di memori setiap kali.  Tapi seperti yang Anda tahu, file yang dapat dieksekusi dapat berisi tautan ke alamat tertentu (absolut).  Karena itu, ketika mengompilasi elf, sudah diketahui alamat apa yang akan dimuat di memori (lihat skrip linker).  Karenanya, kami tidak dapat memuat dua file elf tanpa memori virtual.  Tetapi bahkan dengan memori virtual dihidupkan, ada perpustakaan dinamis (seperti .so) yang dapat memuat di alamat apa pun.  Mereka dapat diunduh di alamat mana pun karena fakta bahwa mereka memiliki bagian relokasi.  Di bagian ini, semua tempat di mana pengalamatan absolut digunakan terdaftar, dan kernel, ketika memuat file elf seperti itu, harus memperbaiki alamat ini dengan pena, mis.  tambahkan kepada mereka perbedaan antara alamat unduhan yang nyata dan yang diinginkan. <br><br>  Kami akan mempertimbangkan bekerja dengan 4 halaman kilobyte.  Dalam situasi ini, kita dapat mengatasi RAM hingga 4 megabita.  Cukup bagi kami.  Peta alamat akan terlihat seperti ini: <br><br>  <i>0-1 mb</i> : jangan disentuh. <br>  <i>1-2 mb</i> : kode dan data kernel. <br>  <i>2-3 mb</i> : banyak kernel. <br>  <i>3-4 mb</i> : halaman khusus file elf diunggah. <br><br>  Alamat linear (diperoleh dari model datar) saat paging halaman diaktifkan tidak sama dengan yang fisik.  Sebaliknya, alamat dibagi dengan offset (bit rendah), indeks entri dalam tabel halaman, dan indeks direktori halaman (bit tinggi).  Setiap proses akan memiliki direktori halaman sendiri dan, karenanya, tabel halaman.  Inilah yang memungkinkan Anda untuk mengatur ruang alamat virtual. <br><br>  Entri direktori halaman terlihat seperti ini: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page_directory_entry_t</span></span></span><span class="hljs-class"> {</span></span> u8 present : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 read_write : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 user_supervisor : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 write_through : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 cache_disabled : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 accessed : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 zero : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 page_size : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 ignored : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 available : <span class="hljs-number"><span class="hljs-number">3</span></span>; u32 page_table_addr : <span class="hljs-number"><span class="hljs-number">20</span></span>; } attribute(packed);</code> </pre> <br>  Elemen tabel halaman terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page_table_entry_t</span></span></span><span class="hljs-class"> {</span></span> u8 present : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 read_write : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 user_supervisor : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 write_through : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 cache_disabled : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 accessed : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 dirty : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 zero : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 global : <span class="hljs-number"><span class="hljs-number">1</span></span>; u8 available : <span class="hljs-number"><span class="hljs-number">3</span></span>; u32 page_phys_addr : <span class="hljs-number"><span class="hljs-number">20</span></span>; } attribute(packed);</code> </pre> <br>  Untuk kernel, kami akan menggambarkan direktori halaman dan tabel halaman sebagai variabel statis.  Benar, ada persyaratan bahwa mereka harus diluruskan di perbatasan halaman. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> struct page_directory_entry_t kpage_directory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aligned(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4096</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page_table_entry_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kpage_table</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MMU_PAGE_TABLE_ENTRIES_COUNT</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aligned</span></span></span><span class="hljs-class">(4096));</span></span></code> </pre> <br>  Kami akan pergi dengan cara sederhana dan membuat seluruh ruang alamat fisik dapat diakses oleh kernel.  Level privilege dari halaman kernel haruslah seorang supervisor sehingga tidak ada yang naik ke dalamnya.  Proses ringan yang harus dijalankan dalam mode kernel akan berbagi ruang alamat yang sama dengan kernel.  Dengan proses ini, kita akan memiliki antrian eksekusi yang tertunda untuk menangani interupsi yang tertunda.  Tetapi lebih banyak tentang itu dalam pelajaran tentang driver perangkat karakter.  Kami belum menyadari multitasking sebelum mempertimbangkan topik ini. <br><br>  Buat direktori halaman kernel dan tabel halaman yang sesuai.  Ketika kernel diinisialisasi, itu akan aktif. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - init kernel page directory * Here assumed each entry addresses 4Kb */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mmu_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;kpage_directory, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">page_directory_entry_t</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/* set kernel page directory */</span></span> kpage_directory.zero = <span class="hljs-number"><span class="hljs-number">1</span></span>; kpage_directory.accessed = <span class="hljs-number"><span class="hljs-number">0</span></span>; kpage_directory.available = <span class="hljs-number"><span class="hljs-number">0</span></span>; kpage_directory.cache_disabled = <span class="hljs-number"><span class="hljs-number">0</span></span>; kpage_directory.ignored = <span class="hljs-number"><span class="hljs-number">0</span></span>; kpage_directory.page_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 4KB */</span></span> kpage_directory.present = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* kernel pages always in memory */</span></span> kpage_directory.read_write = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* read &amp; write */</span></span> kpage_directory.user_supervisor = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* kernel mode pages */</span></span> kpage_directory.write_through = <span class="hljs-number"><span class="hljs-number">1</span></span>; kpage_directory.page_table_addr = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)kpage_table &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* set kernel table */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MMU_PAGE_TABLE_ENTRIES_COUNT; ++i) { kpage_table[i].zero = <span class="hljs-number"><span class="hljs-number">0</span></span>; kpage_table[i].accessed = <span class="hljs-number"><span class="hljs-number">0</span></span>; kpage_table[i].available = <span class="hljs-number"><span class="hljs-number">0</span></span>; kpage_table[i].cache_disabled = <span class="hljs-number"><span class="hljs-number">0</span></span>; kpage_table[i].dirty = <span class="hljs-number"><span class="hljs-number">0</span></span>; kpage_table[i].global = <span class="hljs-number"><span class="hljs-number">1</span></span>; kpage_table[i].present = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* kernel pages always in memory */</span></span> kpage_table[i].read_write = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* read &amp; write */</span></span> kpage_table[i].user_supervisor = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* kernel mode pages */</span></span> kpage_table[i].write_through = <span class="hljs-number"><span class="hljs-number">1</span></span>; kpage_table[i].page_phys_addr = (i * <span class="hljs-number"><span class="hljs-number">4096</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* assume 4Kb pages */</span></span> } }</code> </pre> <br>  Saat kami mengunggah file elf, kami perlu membuat direktori halaman untuk proses pengguna.  Anda dapat melakukan ini dengan fungsi berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - Create user page directory */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> struct page_directory_entry_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mmu_create_user_page_directory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">page_table_entry_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* page_table)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page_directory_entry_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">upage_dir</span></span></span><span class="hljs-class">;</span></span> upage_dir = malloc_a(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">page_directory_entry_t</span></span>), <span class="hljs-number"><span class="hljs-number">4096</span></span>); upage_dir-&gt;zero = <span class="hljs-number"><span class="hljs-number">1</span></span>; upage_dir-&gt;accessed = <span class="hljs-number"><span class="hljs-number">0</span></span>; upage_dir-&gt;available = <span class="hljs-number"><span class="hljs-number">0</span></span>; upage_dir-&gt;cache_disabled = <span class="hljs-number"><span class="hljs-number">0</span></span>; upage_dir-&gt;ignored = <span class="hljs-number"><span class="hljs-number">0</span></span>; upage_dir-&gt;page_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 4KB */</span></span> upage_dir-&gt;present = <span class="hljs-number"><span class="hljs-number">1</span></span>; upage_dir-&gt;read_write = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* read &amp; write */</span></span> upage_dir-&gt;user_supervisor = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* user mode pages */</span></span> upage_dir-&gt;write_through = <span class="hljs-number"><span class="hljs-number">1</span></span>; upage_dir-&gt;page_table_addr = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)page_table &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* assume 4Kb pages */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> upage_dir; }</code> </pre> <br>  Secara default, tabel halaman proses akan berisi halaman kernel dan entri kosong untuk halaman proses selanjutnya, mis.  catatan dengan bendera yang sekarang dihapus dan alamat halaman fisik di 0. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - Create user page table */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> struct page_table_entry_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mmu_create_user_page_table</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page_table_entry_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">upage_table</span></span></span><span class="hljs-class">;</span></span> upage_table = malloc_a(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">page_table_entry_t</span></span>) * MMU_PAGE_TABLE_ENTRIES_COUNT, <span class="hljs-number"><span class="hljs-number">4096</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* share kernel pages */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(upage_table, kpage_table, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">page_table_entry_t</span></span>) * MMU_KERNEL_PAGES_COUNT); <span class="hljs-comment"><span class="hljs-comment">/* fill user pages */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = MMU_KERNEL_PAGES_COUNT; i &lt; MMU_PAGE_TABLE_ENTRIES_COUNT; ++i) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page_table_entry_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">current</span></span></span><span class="hljs-class">;</span></span> current = upage_table + i; current-&gt;zero = <span class="hljs-number"><span class="hljs-number">0</span></span>; current-&gt;accessed = <span class="hljs-number"><span class="hljs-number">0</span></span>; current-&gt;available = <span class="hljs-number"><span class="hljs-number">0</span></span>; current-&gt;cache_disabled = <span class="hljs-number"><span class="hljs-number">0</span></span>; current-&gt;dirty = <span class="hljs-number"><span class="hljs-number">0</span></span>; current-&gt;global = <span class="hljs-number"><span class="hljs-number">1</span></span>; current-&gt;present = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* not present as so as there is no user pages yet */</span></span> current-&gt;read_write = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* read &amp; write */</span></span> current-&gt;user_supervisor = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* user mode page */</span></span> current-&gt;write_through = <span class="hljs-number"><span class="hljs-number">1</span></span>; current-&gt;page_phys_addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* page is not present */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> upage_table; }</code> </pre> <br>  Kita perlu belajar cara menambahkan halaman fisik baru ke tabel halaman proses, karena tidak akan ada secara default.  Kita akan membutuhkan ini ketika memuat file elf ke dalam memori, ketika kita memuat segmen yang dijelaskan dalam header program.  Fungsi ini akan membantu kami dalam hal ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - Occupy user page */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mmu_occupy_user_page</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">page_table_entry_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* upage_table, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* phys_addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = MMU_KERNEL_PAGES_COUNT; i &lt; MMU_PAGE_TABLE_ENTRIES_COUNT; ++i) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page_table_entry_t</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">current</span></span></span><span class="hljs-class">;</span></span> current = upage_table + i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current-&gt;present) { <span class="hljs-comment"><span class="hljs-comment">/* page is buzy */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } current-&gt;zero = <span class="hljs-number"><span class="hljs-number">0</span></span>; current-&gt;accessed = <span class="hljs-number"><span class="hljs-number">0</span></span>; current-&gt;available = <span class="hljs-number"><span class="hljs-number">0</span></span>; current-&gt;cache_disabled = <span class="hljs-number"><span class="hljs-number">0</span></span>; current-&gt;dirty = <span class="hljs-number"><span class="hljs-number">0</span></span>; current-&gt;global = <span class="hljs-number"><span class="hljs-number">1</span></span>; current-&gt;present = <span class="hljs-number"><span class="hljs-number">1</span></span>; current-&gt;read_write = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* read &amp; write */</span></span> current-&gt;user_supervisor = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* user mode page */</span></span> current-&gt;write_through = <span class="hljs-number"><span class="hljs-number">1</span></span>; current-&gt;page_phys_addr = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)phys_addr &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* assume 4Kb pages */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Mode paging dihidupkan dan dimatikan sedikit dalam register flag prosesor. <br><br><pre> <code class="plaintext hljs">/* * Enable paging * void asm_enable_paging(void *page_directory) */ asm_enable_paging: mov 4(%esp),%eax # page_directory mov %eax,%cr3 mov %cr0,%eax or $0x80000001,%eax # set PE &amp; PG bits mov %eax,%cr0 ret /* * Disable paging * void asm_disable_paging() */ asm_disable_paging: mov %eax,%cr3 mov %cr0,%eax xor $0x80000000,%eax # unset PG bit mov %eax,%cr0 ret</code> </pre> <br>  Setelah kita belajar cara membuat ruang alamat proses, kita perlu mengelola halaman fisik, yang mana sibuk dan mana yang bebas.  Ada mekanisme bitmap untuk ini, satu bit per halaman.  Kami tidak akan menjelaskan halaman hingga 3 megabyte, karena mereka milik kernel dan selalu sibuk.  Kami mulai memilih halaman pengguna dari 3 hingga 4 megabita. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> u32 bitmap[MM_BITMAP_SIZE];</code> </pre> <br><br>  Halaman fisik dialokasikan dan dialokasikan menurut fungsi-fungsi berikut.  Bahkan, kami cukup menemukan bit yang diinginkan di peta di alamat fisik halaman dan sebaliknya.  Ketidaknyamanannya adalah kami memiliki ukuran sel memori terbatas, jadi Anda harus menggunakan dua koordinat: nomor byte dan nomor bit. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Api - allocate pages */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mm_phys_alloc_pages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u_int count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* find free pages */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MM_DYNAMIC_PAGES_COUNT; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_found = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; count; ++j) { is_found = is_found &amp;&amp; !mm_get_bit(i + j); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_found) { <span class="hljs-comment"><span class="hljs-comment">/* occupy */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; count; ++j) { assert(!mm_get_bit(i + j)); mm_set_bit(i + j); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)mm_get_addr(i); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } <span class="hljs-comment"><span class="hljs-comment">/* * Api - free page */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mm_phys_free_pages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ptr, u_int count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> address = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)ptr; assert(address &gt;= MM_AREA_START); assert(address % MM_PAGE_SIZE == <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* find page */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MM_DYNAMIC_PAGES_COUNT; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> addr = mm_get_addr(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (addr == address) { <span class="hljs-comment"><span class="hljs-comment">/* free pages */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; count; ++j) { assert(mm_get_bit(i + j)); mm_clear_bit(i + j); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Ini cukup untuk memperkenalkan dukungan penuh untuk memori virtual di kernel Anda. <br><br><h4>  Referensi </h4><br>  Detail dan penjelasan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial video</a> . <br><br>  Kode sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di repositori git</a> (Anda memerlukan cabang lesson6). <br><br><h4>  Referensi </h4><br>  1. James Molloy.  Gulung mainan Anda sendiri UNIX-clone OS. <br>  2. Gigi.  Assembler untuk DOS, Windows, Unix <br>  3. Kalashnikov.  Assembler mudah! <br>  4. Tanenbaum.  Sistem operasi.  Implementasi dan pengembangan. <br>  5. Robert Love.  Kernel Linux  Deskripsi proses pengembangan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467759/">https://habr.com/ru/post/id467759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467747/index.html">Tes psikologis: cara mendapatkan dari psikolog bersertifikat ke tester</a></li>
<li><a href="../id467749/index.html">GCP: Parsing Google Cloud Platform Computing Stack</a></li>
<li><a href="../id467751/index.html">Bagaimana cara messenger terdesentralisasi di blockchain</a></li>
<li><a href="../id467753/index.html">Rekor dunia untuk transmisi data nirkabel: 40 Gb / s per 11 kilometer</a></li>
<li><a href="../id467755/index.html">Prion, kalsium, mikrobiota, hormon makanan, dan Alzheimer</a></li>
<li><a href="../id467761/index.html">Energi, panas, dan air bagian tiga: buka radio</a></li>
<li><a href="../id467763/index.html">Seluruh kebenaran tentang RTOS. Artikel # 33. Menggunakan Sistem Operasi Real-Time Nucleus SE</a></li>
<li><a href="../id467767/index.html">Fasilitas lainnya untuk pengikut JSON-RPC</a></li>
<li><a href="../id467769/index.html">Pada sumber daya informasi federal tunggal yang mengandung informasi populasi</a></li>
<li><a href="../id467773/index.html">Sumber pada sumber daya yang tidak biasa dan melakukan kontak pertama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>