<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏼 👩🏻‍💼 🙌🏼 JVM TI：如何为虚拟机制作插件 🤰🏾 🌌 🐜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您想向JVM添加一些有用的功能吗？ 从理论上讲，每个开发人员都可以为OpenJDK做出贡献，但是，实际上，从侧面来讲，对HotSpot进行的任何不重要的更改都不是很受欢迎，即使当前发行周期缩短了，JDK用户也可能需要数年才能看到您的功能。 

 但是，在某些情况下，甚至无需触及其代码即可扩展虚拟机的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JVM TI：如何为虚拟机制作插件</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/458812/"><img src="https://habrastorage.org/webt/dk/iw/hm/dkiwhmwayxse8--tbyxqszp0xeg.jpeg"><br><br> 您想向JVM添加一些有用的功能吗？ 从理论上讲，每个开发人员都可以为OpenJDK做出贡献，但是，实际上，从侧面来讲，对HotSpot进行的任何不重要的更改都不是很受欢迎，即使当前发行周期缩短了，JDK用户也可能需要数年才能看到您的功能。 <br><br> 但是，在某些情况下，甚至无需触及其代码即可扩展虚拟机的功能。  JVM工具接口（与JVM交互的标准API）会有所帮助。 <br><br> 在本文中，我将通过具体示例展示如何使用它，告诉Java 9和11中发生了什么变化，并诚实地警告遇到的困难（破坏者：我必须处理C ++）。 <br><br> 我还谈到了有关JPoint的材料。 如果您喜欢视频，则可以观看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视频</a>报告。 <br><a name="habracut"></a><br><h2> 参赛作品 </h2><br> 我担任首席工程师的社交网络Odnoklassniki几乎完全用Java编写。 但是今天，我将告诉您另一部分，而这并不完全是Java。 <br><br> 如您所知，Java开发人员中最受欢迎的问题是NullPointerException。 有一次，我在门户网站上值班时，还遇到了NPE的生产环境。 该错误伴随着这样的堆栈跟踪： <br><br><img src="https://habrastorage.org/webt/j6/lb/4t/j6lb4tmh3wmmti8tebobo7znwsu.jpeg"><br><br> 当然，在堆栈跟踪中，您可以跟踪异常发生的位置，直到代码中的特定行。 只是在这种情况下，它并没有让我感觉好些，因为在这里NPE可以满足很多地方： <br><br><img src="https://habrastorage.org/webt/xt/kt/pq/xtktpq4cozo4xvjvllvgtk9cibe.jpeg"><br><br> 如果JVM准确建议此错误的位置，例如这样，那将是很好的： <br> <code>java.lang.NullPointerException: Called 'getUsers()' method on null object</code> <br> <br> 但是，不幸的是，NPE现在不包含任何此类内容。 尽管他们一直在要求这样做，但至少在Java 1.4中已经提出： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这个错误</a>已经存在16年了。 定期地，关于此主题的错误越来越多，但始终将其关闭为“无法修复”： <br><br><img src="https://habrastorage.org/webt/5l/tc/xg/5ltcxgloqnkiiudcadczatl6_ne.jpeg"><br><br> 这并非在所有地方都发生。  SAP的Volker Simonis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讲述</a>了他们如何长期在SAP JVM中实现此功能，并多次提供了帮助。 另一位SAP员工再次<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提交了</a> OpenJDK中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>错误，并自愿实施与SAP JVM中类似的机制。 而且，瞧，这次错误没有关闭-该功能有可能进入JDK 14。 <br><br> 但是JDK 14何时发布，何时切换到它？ 如果您现在想调查问题该怎么办？ <br><br> 当然，您可以维护OpenJDK的分支。  NPE报告功能本身并不复杂，我们可以很好地实现它。 但是同时，将存在支持您自己的装配的所有问题。 一次实现该功能，然后将其作为插件简单地连接到任何版本的JVM，将是很棒的。 这确实有可能！  JVM有一个特殊的API（最初是为各种调试器和分析器开发的）：JVM Tool Interface。 <br><br> 最重要的是，此API是标准的。 他有一个严格的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">规范</a> ，并且在按照它实现功能时，可以确保它可以在JVM的新版本中使用。 <br><br> 要使用此接口，您需要编写一个小型（或大型，取决于您的任务）程序。 本机的：通常是用C或C ++编写的。 标准JDK <code>jdk/include/jvmti.h</code>具有要<code>jdk/include/jvmti.h</code>的<code>jdk/include/jvmti.h</code>头文件。 <br><br> 程序被编译到动态库中，并在JVM启动期间通过<code>-agentpath</code>参数连接。 重要的是不要将其与另一个类似的参数<code>-javaagent</code>混淆。 实际上，Java代理是JVM TI代理的特例。 此外，在本文中，单词“代理”下的确切含义是本地代理。 <br><br><h2> 从哪里开始 </h2><br> 让我们在实践中看看如何编写最简单的JVM TI代理，一种“ hello world”。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;jvmti.h&gt; #include &lt;stdio.h&gt; JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* vm, char* options, void* reserved) { jvmtiEnv* jvmti; vm-&gt;GetEnv((void**) &amp;jvmti, JVMTI_VERSION_1_0); char* vm_name = NULL; jvmti-&gt;GetSystemProperty("java.vm.name", &amp;vm_name); printf("Agent loaded. JVM name = %s\n", vm_name); fflush(stdout); return 0; }</span></span></span></span></code> </pre><br> 第一行包含相同的头文件。 接下来是需要在代理中实现的主要功能： <code>Agent_OnLoad()</code> 。 代理启动时，虚拟机本身会调用它，并将指针传递给<code>JavaVM*</code>对象。 <br><br> 使用它，您可以获得一个指向JVM TI环境的指针： <code>jvmtiEnv*</code> 。 并且通过它，已经调用了JVM TI函数。 例如，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GetSystemProperty</a>读取系统属性的值。 <br><br> 如果现在运行此“ hello world”，并将已编译的dll文件传递给<code>-agentpath</code> ，则在Java程序开始运行之前，控制台中将显示由代理打印的行： <br><br><img src="https://habrastorage.org/webt/rl/cq/eu/rlcqeul7gpb8mahabl0ehgckro8.png"><br><br><h2> 浓缩NPE </h2><br> 由于hello world不是最有趣的示例，因此让我们回到我们的例外情况。 补充NPE报告的完整代理代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在GitHub上</a> 。 <br><br> 如果我想让虚拟机将所有异常通知我们，这就是<code>Agent_OnLoad()</code>样子： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jint JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Agent_OnLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JavaVM* vm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* options, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* reserved)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiEnv* jvmti; vm-&gt;GetEnv((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) &amp;jvmti, JVMTI_VERSION_1_0); jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities); jvmtiEventCallbacks callbacks = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; callbacks.Exception = ExceptionCallback; jvmti-&gt;SetEventCallbacks(&amp;callbacks, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(callbacks)); jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br> 首先，我请JVM TI提供相应的功能（can_generate_exception_events）。 我们将分别讨论功能。 <br><br> 下一步是订阅Exception事件。 每当JVM抛出异常（无论是否捕获到<code>ExceptionCallback()</code>都会调用我们的<code>ExceptionCallback()</code>函数。 <br><br> 最后一步是调用<code>SetEventNotificationMode()</code>以启用通知传递。 <br><br><div class="spoiler">  <b class="spoiler_title">在ExceptionCallback中，JVM传递了处理异常所需的一切。</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExceptionCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jvmtiEnv* jvmti, JNIEnv* env, jthread thread, jmethodID method, jlocation location, jobject exception, jmethodID catch_method, jlocation catch_location)</span></span></span><span class="hljs-function"> </span></span>{ jclass NullPointerException = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/NullPointerException"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env-&gt;IsInstanceOf(exception, NullPointerException)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } jclass Throwable = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/Throwable"</span></span>); jfieldID detailMessage = env-&gt;GetFieldID(Throwable, <span class="hljs-string"><span class="hljs-string">"detailMessage"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ljava/lang/String;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (env-&gt;GetObjectField(exception, detailMessage) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buf, <span class="hljs-string"><span class="hljs-string">"at location %id"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) location); env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); }</code> </pre><br></div></div><br> 这里既有引发异常的线程对象（线程），发生异常的位置（方法，位置），也有异常的对象（异常），甚至是代码中捕获此异常的位置（catch_method，catch_location）。 <br><br> 重要的是：在此回调中，除了指向JVM TI环境的指针外，还传递了JNI环境（env）。 这意味着我们可以使用其中的所有JNI函数。 也就是说，JVM TI和JNI完美地共存，彼此互补。 <br><br> 在我的代理中，我同时使用。 特别是，通过JNI，我检查我的异常是否为<code>NullPointerException</code>类型，然后将错误消息替换<code>detailMessage</code>字段。 <br><br> 由于JVM本身向我们传递了位置-发生异常的字节码索引，因此我只是将此位置放在消息中： <br><br><img src="https://habrastorage.org/webt/ix/h8/pc/ixh8pcrtxcg4rcdwwlg83_gfuam.png"><br><br> 数字66表示发生此异常的字节码索引。 但是，手动分析字节码很沉闷：您需要反编译类文件，查找第66条指令，尝试了解它在做什么……如果我们的代理本人可以显示出更易于理解的内容，那就太好了。 <br><br> 但是，在这种情况下，JVM TI可以满足您的所有需求。 的确，您必须请求JVM TI的其他功能：获取字节码和常量池方法。 <br><br><pre> <code class="cpp hljs">jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_bytecodes = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_constant_pool = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities);</code> </pre><br> 现在，我将扩展ExceptionCallback：通过JVM TI函数<code>GetBytecodes()</code>我将获得方法的主体，以通过位置索引检查其中的内容。 接下来是一个大的开关字节码指令：如果这是对数组的访问，则将出现一条错误消息，如果对字段的访问是另一条消息，如果方法调用是第三个，依此类推。 <br><br><div class="spoiler">  <b class="spoiler_title">ExceptionCallback代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs">jint bytecode_count; u1* bytecodes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetBytecodes(method, &amp;bytecode_count, &amp;bytecodes) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; location &lt; bytecode_count) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* message = get_exception_message(bytecodes[location]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ... env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); } } jvmti-&gt;Deallocate(bytecodes);</code> </pre><br></div></div><br> 它仅用于替换字段或方法的名称。 您可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">常量池中</a>获取它，这要归功于JVM TI。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetConstantPool(holder, &amp;cpool_count, &amp;cpool_bytes, &amp;cpool) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strdup(<span class="hljs-string"><span class="hljs-string">"&lt;unknown&gt;"</span></span>); }</code> </pre><br> 接下来是一些魔术，但实际上并没有什么棘手的问题，仅根据类文件格式<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">规范，</a>我们分析常量池，然后从该行中分离出线（即方法的名称）。 <br><br><div class="spoiler">  <b class="spoiler_title">恒定池分析</b> <div class="spoiler_text"><pre> <code class="cpp hljs">u1* ref = get_cpool_at(cpool, get_u2(bytecodes + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// CONSTANT_Fieldref u1* name_and_type = get_cpool_at(cpool, get_u2(ref + 3)); // CONSTANT_NameAndType u1* name = get_cpool_at(cpool, get_u2(name_and_type + 1)); // CONSTANT_Utf8 size_t name_length = get_u2(name + 1); char* result = (char*) malloc(name_length + 1); memcpy(result, name + 3, name_length); result[name_length] = 0;</span></span></code> </pre><br></div></div><br> 另一个重要点：某些JVM TI函数（例如<code>GetConstantPool()</code>或<code>GetBytecodes()</code>在本机内存中分配特定的结构，在完成使用该结构时需要将其释放。 <br><br><pre> <code class="cpp hljs">jvmti-&gt;Deallocate(cpool);</code> </pre><br> 使用我们的扩展代理运行源程序，这是对该异常的完全不同的描述：它报告我们在null对象上调用了longValue（）方法。 <br><br><img src="https://habrastorage.org/webt/8d/ge/-d/8dge-d_mtmqpdesbk6vm4nwolna.png"><br><br><h2> 其他应用 </h2><br> 一般来说，开发人员通常希望以自己的方式处理异常。 例如，如果发生<code>StackOverflowError</code> ，则自动重启JVM。 <br><br> 可以理解这种需求，因为<code>StackOverflowError</code>与<code>OutOfMemoryError</code>是相同的致命错误，发生后，就不再可能保证程序的正确运行。 或者，例如，有时为了分析问题，我想在发生异常时接收线程转储或堆转储。 <br><br><img src="https://habrastorage.org/webt/hh/8b/zy/hh8bzys2bji12vte4g_fsmlfaky.jpeg"><br><br> 公平地说，IBM JDK开箱即用。 但是现在我们已经知道，使用JVM TI代理，您可以在HotSpot中实现相同的操作。 订阅异常回调并分析异常就足够了。 但是如何从我们的代理中删除线程转储或堆转储？  JVM TI具有此情况所需的一切： <br><br><img src="https://habrastorage.org/webt/yp/jj/5o/ypjj5o9xn9m7tmhdzmh-z8bo2tk.jpeg"><br><br> 实现绕过堆并创建转储的整个机制不是很方便。 但是，我将分享如何使其变得更容易，更快的秘密。 是的，它不再包含在标准JVM TI中，而是Hotspot的私有扩展。 <br><br> 您需要从HotSpot源连接头文件<a href="">jmm.h</a>并调用<code>JVM_GetManagement()</code>函数： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmm.h"</span></span></span><span class="hljs-meta"> JNIEXPORT void* JNICALL JVM_GetManagement(jint version); void JNICALL ExceptionCallback(jvmtiEnv* jvmti, JNIEnv* env, ...) { JmmInterface* jmm = (JmmInterface*) JVM_GetManagement(JMM_VERSION_1_0); jmm-&gt;DumpHeap0(env, env-&gt;NewStringUTF(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dump.hprof"</span></span></span><span class="hljs-meta">), JNI_FALSE); }</span></span></code> </pre><br> 它将返回一个指向HotSpot管理接口的指针，该接口在单个调用中将生成一个堆转储或线程转储。 该示例的完整代码可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我</a>对Stack Overflow的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">回答中</a>找到。 <br><br> 自然地，您不仅可以处理异常，还可以处理与JVM操作相关的许多其他事件：启动/停止线程，加载类，垃圾回收，编译方法，输入/退出方法，甚至访问或修改Java对象的特定字段。 <br><br> 我有另一个<a href="">vmtrace</a>代理的示例，该代理订阅许多标准的JVM TI事件并记录它们。 如果使用此代理运行一个简单的程序，我将获得详细的日志，完成后将带有时间戳： <br><br><img src="https://habrastorage.org/webt/wu/he/ci/wuhecifrgrrkleshnnkqx6hd9ew.jpeg"><br><br> 如您所见，要简单地打印hello world，将加载数百个类，生成并编译数十个方法。 很清楚为什么Java需要这么长时间才能运行。 关于一切的一切花费了超过200毫秒的时间。 <br><br><h2>  JVM TI可以做什么 </h2><br> 除了事件处理之外，JVM TI还具有许多其他功能。 它们可以分为两组。 <br><br> 一个是强制性的，任何支持JVM TI的JVM都必须实现。 这些包括分析方法，字段，流的操作，向类路径添加新类的能力，等等​​。 <br><br> 有一些可选功能需要初步功能要求。 不需要JVM支持所有它们，但是HotSpot完全实现了整个规范。 可选功能分为两个子组：只能在JVM开始时连接的子组（例如，设置断点或分析局部变量的能力），以及可以随时连接的子组（尤其是字节码或常量池），上面使用）。 <br><br><img src="https://habrastorage.org/webt/ee/9e/oo/ee9eooqcrrdowlrc1rvqmfuhjs0.jpeg"><br><br> 您可能会注意到，功能列表与调试器的功能非常相似。 实际上，Java调试器不过是JVM TI代理的特例，该代理利用了所有这些功能并要求所有功能。 <br><br> 将功能分为可以随时启用的功能和仅在引导时启用的功能是有意完成的。 并非所有功能都是免费的，有些会带来额外的开销。 <br><br> 如果使用该功能所带来的直接开销一切都清楚了，那么即使您不使用该功能，也会出现不那么明显的间接开销，而只是通过功能，您便声明将来会需要它。 这是因为虚拟机可以不同地编译代码或向运行时添加其他检查。 <br><br> 例如，已经考虑的订阅异常的能力（can_generate_exception_events）导致所有抛出异常的过程都会缓慢进行。 原则上，这并不是那么可怕，因为在一个好的Java程序中，异常是很少见的事情。 <br><br> 具有局部变量的情况稍微更糟。 对于can_access_local_variables（它允许您随时获取局部变量的值），您需要禁用一些重要的优化。 尤其是，Escape Analysis完全停止工作，这可能会产生明显的开销：根据应用程序，开销为5-10％。 <br><br> 因此得出结论：如果在打开调试代理的情况下运行Java，甚至没有使用它，应用程序的运行速度就会变慢。 无论如何，在生产中包含调试代理并不是一个好主意。 <br><br> 例如，设置断点或跟踪方法的所有输入/输出等许多功能会带来更严重的开销。 特别是，某些JVM TI事件（FieldAccess，MethodEntry / Exit）仅在解释器中起作用。 <br><br><h2> 一种作用剂好，两种作用剂好 </h2><br> 您只需指定几个<code>-agentpath</code>参数即可将多个代理连接到单个进程。 每个人都有自己的JVM TI环境。 这意味着每个人都可以订阅自己的功能并独立拦截事件。 <br><br> 并且如果两个代理订阅了Breakpoint事件，并且在一个方法中设置了一个断点，那么当执行此方法时，第二个代理会接收该事件吗？ <br><br> 实际上，这种情况不会发生（至少在HotSpot JVM中）。 因为在某些给定时间只有某些代理可以拥有一些功能。 这些尤其包括breakpoint_events。 因此，如果第二个代理请求相同的功能，它将收到一个错误响应。 <br><br> 这是一个重要的结论：即使您正在HotSpot上运行并且知道所有功能都可用，代理也应始终检查功能请求的结果。  JVM TI规范没有提及专有功能，但是HotSpot具有这样的实现功能。 <br><br> 诚然，代理隔离并非总是完美的。 在开发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">async-profiler的过程中，</a>我遇到了这个问题：当我们有两个代理并且一个请求生成方法编译事件时，所有代理都会收到这些事件。 当然，我提交了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bug</a> ，但是您应该记住，您的代理中可能会发生意料之外的事件。 <br><br><h2> 在常规程序中的用法 </h2><br> 对于调试器和分析器，JVM TI似乎是非常具体的事情，但它也可以在常规Java程序中使用。 考虑一个例子。 <br><br> 当一切都是异步的时，反应式编程范式现在很普遍，但是这种范式存在问题。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(GOOD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(BAD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ good(); bad(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">200</span></span>); } }</code> </pre><br> 我运行两个仅在参数上有所不同的异步任务。 如果出现问题，则会引发异常： <br><br><img src="https://habrastorage.org/webt/ds/me/wx/dsmewxe5rd4lzgq8fgjxn42zh0e.png"><br><br> 从堆栈跟踪中，完全不清楚这些任务中的哪一个导致了问题。 因为异常发生在一个完全不同的线程中，所以我们没有上下文。 如何理解在哪个任务中？ <br><br> 作为解决方案之一，您可以将有关创建位置的信息添加到异步任务的构造函数中： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg = arg; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location = getLocation(); }</code> </pre><br> 也就是说，记住位置-代码中的特定位置，一直到调用构造函数的那一行。 并在例外情况下承诺： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = Integer.parseInt(arg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { System.err.println(<span class="hljs-string"><span class="hljs-string">"ParseTask failed at "</span></span> + location); e.printStackTrace(); }</code> </pre><br> 现在，当发生异常时，我们将看到这发生在TaskRunner（创建带有BAD参数的任务的行）的第14行： <br><br><img src="https://habrastorage.org/webt/v-/tq/0q/v-tq0qa-bnlkakz8dnzxhrjfqvo.png"><br><br> 但是如何在调用构造函数的代码中获得位置呢？ 在Java 9之前，唯一合法的方法是执行此操作：获取堆栈跟踪，跳过一些不相关的帧，然后在堆栈上稍低一些的位置调用我们的代码。 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackTraceElement caller = Thread.currentThread().getStackTrace()[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> caller.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + caller.getLineNumber(); }</code> </pre><br> 但是有一个问题。 获取完整的StackTrace相当缓慢。 我有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一份</a>专门的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告</a> 。 <br><br> 如果这种情况很少发生，那将不是什么大问题。 但是，例如，我们有一个Web服务-接受HTTP请求的前端。 这是一个很棒的应用程序，包含数百万行代码。 为了捕获渲染错误，我们使用了类似的机制：在渲染组件中，我们记住了它们的创建位置。 我们有数百万个这样的组件，因此获取所有堆栈跟踪信息需要花费很长的时间才能启动应用程序，而不仅仅是一分钟。 因此，此功能以前在生产中已禁用，尽管为了分析问题在生产中是必需的。 <br><br>  Java 9引入了一种绕过流堆栈的新方法：StackWalker，它通过Stream API可以按需延迟执行所有这些操作。 也就是说，我们可以跳过正确的帧数，而只获得我们感兴趣的帧数。 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StackWalker.getInstance().walk(s -&gt; { StackWalker.StackFrame frame = s.skip(<span class="hljs-number"><span class="hljs-number">3</span></span>).findFirst().get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> frame.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + frame.getLineNumber(); }); }</code> </pre><br> 它比获取完整的堆栈跟踪要好一些，但幅度不大或什至很多倍。 在我们的例子中，结果快了大约一半半： <br><br><img src="https://habrastorage.org/webt/v8/bz/rk/v8bzrkf8szriwvghilzvhrddtzo.jpeg"><br><br> 最不理想的StackWalker实现存在一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已知问题</a> ，很可能甚至会在JDK 13中得到解决。但是，再次，我们现在应该在Java 8中做什么，因为Java 8中StackWalker甚至都不慢？ <br><br>  JVM TI再次进行了救援。 有一个<code>GetStackTrace()</code>函数<code>GetStackTrace()</code>您的所有需求：从指定的帧开始，获取给定长度的堆栈跟踪的片段，仅执行其他操作。 <br><br><pre> <code class="cpp hljs">GetStackTrace(jthread thread, jint start_depth, jint max_frame_count, jvmtiFrameInfo* frame_buffer, jint* count_ptr)</code> </pre><br> 只剩下一个问题：如何从我们的Java程序中调用JVM TI函数？ 就像任何其他本机方法一样：使用<code>System.loadLibrary()</code>加载本机库，我们的方法的JNI实现将在该库中。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackFrame</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.loadLibrary(<span class="hljs-string"><span class="hljs-string">"stackframe"</span></span>); } }</code> </pre><br> 不仅可以从Agent_OnLoad（）中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">获得</a>指向JVM TI环境的指针，而且还可以在程序运行时<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">获得其</a>指针，并可以通过普通的本机JNI方法继续使用它： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jstring JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_StackFrame_getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JNIEnv* env, jclass unused, jint depth)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiFrameInfo frame; jint count; jvmti-&gt;GetStackTrace(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, depth, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;frame, &amp;count);</code> </pre><br>               : <br><br><img src="https://habrastorage.org/webt/ia/-u/au/ia-uauyvrmwlvh84rh84rqqwu1s.jpeg"><br><br> ,    JDK   :    -  .          -. ,   ,      ,   JDK.   JDK 8u112,  JVM TI-,    (GetMethodName, GetMethodDeclaringClass   ),   . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ,  ,    :   JVM TI-   ,   ,         -.     ,         C++,    <a href="">jvmtiEnter.xsl</a> . <br><br>  :    HotSpot       XSLT-.       HotSpot. <br><br>     ?       ,   .  ,   - jmethodID  ,      .      ,      . <br><br><h2>   </h2><br>    ,  JVM TI     Java-     ,  <code>System.loadLibrary</code> . <br><br>  ,   ,    JVM TI-  <code>-agentpath</code>   JVM. <br><br>     :   (dynamic attach). <br><br>   ?          ,      - ,       ,    JVM TI-    . <br><br>   JDK 9,           jcmd: <br><br><pre> <code class="bash hljs">jcmd &lt;pid&gt; JVMTI.agent_load /path/to/agent.so [arguments]</code> </pre><br>      JDK     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">jattach</a> . , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">async-profiler</a>      ,   -  JVM-,    jattach. <br><br>    JVM TI-    , ,  <code>Agent_OnLoad()</code> ,    <code>Agent_OnAttach()</code> .  :  <code>Agent_OnAttach()</code>    capabilities,       . <br><br>  ,           ,   <code>Agent_OnAttach()</code>   . <br><br>   .     IntelliJ IDEA:    Java-, ,          - . <br><br>  process ID  IDEA,   jattach     JVM TI- patcher.dll: <br> <code>jattach 8648 load patcher.dll true</code> <br> <br>          : <br><br><img src="https://habrastorage.org/webt/rv/j7/wm/rvj7wmnfdbo26tjkcsqaix96k74.png"><br><br>    ?   Java-   ( <code>javax.swing.AbstractButton</code> )    JNI  <code>setBackground()</code> .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . <br><br><h2>    Java 9 </h2><br> JVM TI   , ,    ,     API,     .      Java 9. <br><br>  , Java 9     ,   .  ,    «» JDK,       . <br><br> ,  JDK     Direct ByteBuffer.    API: <br><br><img src="https://habrastorage.org/webt/wj/qb/ue/wjqbuel-1g3j1qis_bihg0lpn_8.jpeg"><br><br> ,  Cassandra    ,          MappedByteBuffer,      ,  JVM  . <br><br>          JDK 9,  IllegalAccessError: <br><br><img src="https://habrastorage.org/webt/co/z-/49/coz-496tvv3ogo7kw44viuqtpwq.jpeg"><br><br>      Reflection:      . <br><br> ,  Java       Linux.   -        <code>java.io.FileDescriptor</code>       JNI    -  .  ,     JDK 9,     : <br><br><img src="https://habrastorage.org/webt/he/xc/6p/hexc6pnrkv0ehoablvlfy11imt0.jpeg"><br><br> ,   JVM,           .      ,   . ,    Cassandra  Java 11,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> : <br><br><pre> <code class="plaintext hljs">--add-exports java.base/jdk.internal.misc=ALL-UNNAMED --add-exports java.base/jdk.internal.ref=ALL-UNNAMED --add-exports java.base/sun.nio.ch=ALL-UNNAMED --add-exports java.management.rmi/com.sun.jmx.remote.internal.rmi=ALL-UNNAMED --add-exports java.rmi/sun.rmi.registry=ALL-UNNAMED --add-exports java.rmi/sun.rmi.server=ALL-UNNAMED --add-exports java.sql/java.sql=ALL-UNNAMED --add-opens java.base/java.lang.module=ALL-UNNAMED --add-opens java.base/jdk.internal.loader=ALL-UNNAMED --add-opens java.base/jdk.internal.ref=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.math=ALL-UNNAMED --add-opens java.base/jdk.internal.module=ALL-UNNAMED --add-opens java.base/jdk.internal.util.jar=ALL-UNNAMED --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED</code> </pre><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> JVM TI    : <br><br><ul><li> GetAllModules </li><li> AddModuleExports </li><li> AddModuleOpens </li><li>  . . </li></ul><br>    ,    :    JVM,    ,    ,      . <br><br>      Direct ByteBuffer: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ ByteBuffer buf = ByteBuffer.allocateDirect(<span class="hljs-number"><span class="hljs-number">1024</span></span>); ((sun.nio.ch.DirectBuffer) buf).cleaner().clean(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Buffer cleaned"</span></span>); }</code> </pre><br>     ,   IllegalAccessError.     agentpath    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">antimodule</a> ,     .     . <br><br><h2>    Java 11 </h2><br>     Java 11.   ,   !     :    <code>SampledObjectAlloc</code> ,    ,      . <br><br>  callback   ,     : ,  ,   ,  , .   <code>SetHeapSampingInterval</code>   ,      . <br><br><img src="https://habrastorage.org/webt/5f/e1/8_/5fe18_nwt5i-zbm4e-vyn4roavm.jpeg"><br><br>   ?         ,    ,     .        Java Flight Recorder. <br><br>     ,     ,     ,  , . <br><br>           Thread Local Allocation Buffer   .      TLAB   ,   .        ,     . <br><br><img src="https://habrastorage.org/webt/v0/lm/di/v0lmdimdyk8uvasl3z9gkjlrfqe.jpeg"><br><br>     ,     TLAB,    .          JVM runtime   . <br><br>   ,        ,       —     5%. <br><br>  ,    ,    JDK 7,    Flight Recorder.    API     async-profiler.  ,   JDK 11,  API  ,   JVM TI,      .  , YourKit   .     API,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ,    . <br><br>         . ,   ,    , , . <br><br><img src="https://habrastorage.org/webt/qi/t1/lw/qit1lwwqv3p7vxhhl-fbcfh5bos.jpeg"><br><br><h2> 结论 </h2><br> JVM TI —      . <br><br> ,     ++,     JVM         .  ,  JVM TI        . <br><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> GitHub</a> . ,    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458812/">https://habr.com/ru/post/zh-CN458812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458798/index.html">营养机器人或我想如何从健身教练那里拿面包</a></li>
<li><a href="../zh-CN458800/index.html">深度学习。 联合学习</a></li>
<li><a href="../zh-CN458804/index.html">机器学习和人工智能文摘</a></li>
<li><a href="../zh-CN458808/index.html">哈伯死后报告：报纸下跌</a></li>
<li><a href="../zh-CN458810/index.html">美国将Corel和Parallels出售给KKR投资集团</a></li>
<li><a href="../zh-CN458814/index.html">为需求未定的产品启动网站</a></li>
<li><a href="../zh-CN458818/index.html">杰出的同时代人</a></li>
<li><a href="../zh-CN458820/index.html">关于在Minecraft平台上实施著名流派的问题</a></li>
<li><a href="../zh-CN458826/index.html">如何清除旧商品，使它们在有机商品中急剧增长：六个月的流量增加了104％</a></li>
<li><a href="../zh-CN458828/index.html">为什么，为什么以及何时使用ValueTask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>