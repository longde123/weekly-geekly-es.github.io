<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíª üè´ üéÜ FFmpeg DXVA2 Hardware-Dekodierungspraxis ‚ö±Ô∏è üë®üèø üë©üèø‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Dieser Artikel ist eine Fortsetzung meines FFmpeg-Artikels, der mit Visual Studio beginnt. Hier kommen wir zur Hardware-Decodierung des FULL HD...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FFmpeg DXVA2 Hardware-Dekodierungspraxis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461735/">  Hallo!  Dieser Artikel ist eine Fortsetzung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meines FFmpeg-Artikels, der mit Visual Studio beginnt.</a>  Hier kommen wir zur Hardware-Decodierung des FULL HD RTSP-Streams.  Ich werde im Voraus sagen, dass sogar der Intel ATOM Z8350 diese Aufgabe problemlos bew√§ltigen kann. <br><br>  <b>Aufgabe:</b> Hardware-Decodierung und Aufzeichnung von bis zu 4 Frames im RAM f√ºr die anschlie√üende Parallelverarbeitung (vier Prozessorkerne) von einer RTSP h.264 IP-Kamera.  Ich zeige die verarbeiteten Frames mit den WinAPI-Funktionen an.  Als Ergebnis erhalten wir ein Hochgeschwindigkeitssystem f√ºr die Computerverarbeitung des RTSP-Streams im Parallelmodus.  Als N√§chstes k√∂nnen Sie die <b>Computer-Vision-</b> Algorithmen f√ºr die Verarbeitung von <b>Echtzeit-</b> Frames verbinden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/bc/j2/wdbcj2te4ze6ezmd1_ap8lhxtv4.png" alt="Bild"></div><br><h4>  Eintrag </h4><br>  Warum brauche ich Hardware-Dekodierung?  Sie m√∂chten Echtzeitvideos mit einem schwachen und billigen Prozessor dekodieren oder den Prozessor so weit wie m√∂glich entladen, dann ist es Zeit, sich mit der Hardware-Dekodierung vertraut zu machen. <br><br>  <b>DirectX Video Acceleration</b> (DXVA) ist eine API zur Verwendung der Hardwarebeschleunigung zur Beschleunigung der Videoverarbeitung mit GPUs.  Mit DXVA 2.0 k√∂nnen Sie mehr Vorg√§nge auf die GPU umleiten, einschlie√ülich Videoerfassungs- und Videoverarbeitungsvorg√§nge. <br><a name="habracut"></a><br>  Nachdem ich den vorherigen Artikel geschrieben hatte, wurden mir einige Fragen gestellt: "Warum wird FFmpeg verwendet?"  Ich werde mit den Problemen beginnen.  Die Hauptschwierigkeit der Hardware-Decodierung besteht darin, den decodierten Rahmen in den RAM zu schreiben.  F√ºr Full HD sind dies 1920 x 1080 x 3 = 6.220.800 Byte.  Selbst unter Ber√ºcksichtigung der Tatsache, dass der Frame im NV12-Format gespeichert ist, sind dies auch viele 1920 x 1080 x 1,5 = 3 110 400 Bytes.  Das √úberschreiben von 75 MB pro Sekunde ist eine ernsthafte Aufgabe f√ºr jeden Prozessor.  Um dieses Problem zu l√∂sen, hat Intel SSE 4-Befehle hinzugef√ºgt, mit denen Sie Daten ohne Prozessor neu schreiben k√∂nnen.  Leider haben dies nicht alle Bibliotheken implementiert.  Ich habe folgende Bibliotheken getestet: <br><br><ol><li>  Ffmpeg </li><li>  VLC </li><li>  Opencv </li></ol><br>  <b>VLC</b> - funktioniert mit IP-Kameras durch Hardware-Decodierung (sehr geringe Prozessorlast). Ein primitiver RTSP-Stream-Player kann in nur 10 Codezeilen erstellt werden, aber das Empfangen decodierter Frames im RAM ben√∂tigt zu viel Prozessorzeit. <br><br>  <b>OpenCV</b> - RTSP verwendet FFmpeg, um mit dem Stream zu arbeiten, daher wurde beschlossen, ohne Zwischenh√§ndler zu arbeiten, d. H.  Verwenden Sie die FFmpeg-Bibliothek.  Dar√ºber hinaus wird FFmpeg, das standardm√§√üig installiert ist, in OpenCV ohne Hardware-Dekodierung erstellt. <br><br>  <b>FFmpeg</b> - zeigte gute, meiner Meinung nach Ergebnisse, es funktioniert stabil.  Der einzige Nachteil ist, dass die Arbeit mit WEB-Kameras f√ºr Version X86 (X64 scheint Ihnen das Arbeiten zu erm√∂glichen) unter Windows nicht implementiert ist. <br><br><h2>  Hardware-Videodecodierung ist einfach </h2><br>  Tats√§chlich ist die Hardware-Dekodierung mit der FFmpeg-Bibliothek nicht komplizierter als mit Software.  Die Projekteinstellungen sind die gleichen wie f√ºr die Software-Implementierung, das Blockschaltbild blieb unver√§ndert. <br><br>  Sie k√∂nnen eine Liste der von FFmpeg unterst√ºtzten Hardware-Dekodierungsmethoden anzeigen. <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">" %s"</span></span>, av_hwdevice_get_type_name(type));</code> </pre> <br>  Als erstes m√ºssen wir FFmpeg mitteilen, mit welchem ‚Äã‚ÄãHardware-Decoder Sie das Video decodieren m√∂chten.  In meinem Fall l√§sst Windows 10 + Intel Atom Z8350 nur DXVA2: <br><br><pre> <code class="cpp hljs">type = av_hwdevice_find_type_by_name(<span class="hljs-string"><span class="hljs-string">"dxva2"</span></span>);</code> </pre> <br>  Sie k√∂nnen CUDA, D3D11VA, QSV oder VAAPI (nur Linux) als Hardware-Decoder ausw√§hlen.  Dementsprechend sollten Sie √ºber diese Hardwarel√∂sung verf√ºgen und FFmpeg sollte mit seiner Unterst√ºtzung erstellt werden. <br><cut></cut><br>  √ñffnen Sie den Videostream: <br><br><pre> <code class="cpp hljs">avformat_open_input(&amp;input_ctx, filename, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>;</code> </pre> <br>  Wir erhalten Informationen √ºber den Videostream: <br><br><pre> <code class="cpp hljs">av_find_best_stream(input_ctx, AVMEDIA_TYPE_VIDEO, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, &amp;decoder, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Speicher zuweisen: <br><br><pre> <code class="cpp hljs">frame = av_frame_alloc(); <span class="hljs-comment"><span class="hljs-comment">//       sw_frame = av_frame_alloc(); //       </span></span></code> </pre> <br>  Diese Funktion √ºberschreibt die decodierte Datei im RAM: <br><br><pre> <code class="cpp hljs">av_hwframe_transfer_data(sw_frame, frame, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h3>  Ein bisschen √ºber das NV12-Format </h3><br>  Wir haben also einen Frame in der sw_frame-Struktur.  Der empfangene Frame wird im NV12-Format gespeichert.  Dieses Format wurde von Microsoft erfunden.  Sie k√∂nnen Pixelinformationen in 12 Bit speichern.  Wobei 8 Bit die Intensit√§t ist und 4 Bit die Farbe beschreiben (oder besser gesagt, die Farbe wird sofort f√ºr 4 benachbarte 2 √ó 2 Pixel beschrieben).  Dar√ºber hinaus wird sw_frame.data [0] - die Intensit√§t und in sw_frame.data [1] - die Farbe gespeichert.  Um von NV-12 nach RGB zu konvertieren, k√∂nnen Sie die folgende Funktion verwenden: <br><cut></cut><br><div class="spoiler">  <b class="spoiler_title">C ++ - √úbersetzung von NV12 nach RGB</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * f1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * f2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iFrame)</span></span></span><span class="hljs-function"> </span></span>{ FILE *pFile; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> szFilename[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, i, j; <span class="hljs-comment"><span class="hljs-comment">// char buff[1920 * 1080 * 3]; uint8_t *buff = new uint8_t(1920*3*2); int u=0, v=0, y=0; // Open file sprintf(szFilename, "frame%d.ppm", iFrame); pFile = fopen(szFilename, "wb"); if (pFile == NULL) return; //    fprintf(pFile, "P6\n%d %d\n255\n", 1920, 1080); for (j = 0; j &lt; 1080 / 2; j++) { for (i = 0; i &lt; 1920; i +=2) { // 1  rgb y = *(f1 + j * 1920 * 2 + i); v = *(f2 + j * 1920 + i) - 128; u = *(f2 + j * 1920 + i + 1) - 128; x = round(y + 1.370705 * v); if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; // if (j &gt; 34) printf("%i, ",(j * 1920 * 2 + i) * 3); buff[i * 3 + 2] = x; x = round(y - 0.698001 * v - 0.337633 * u); if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[i * 3 + 1] = x; x = round(y + 1.732446 * u); if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[i * 3] = x; // 2  rgb y = *(f1 + j * 1920 * 2 + i + 1); x = y + 1.370705 * v; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[i * 3 + 5] = x; x = y - 0.698001 * v - 0.337633 * u; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[i * 3 + 4] = x; x = y + 1.732446 * u; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[i * 3 + 3] = x; // 3  rgb y = *(f1 + j * 1920 * 2 + 1920 + i); x = y + 1.370705 * v; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[(1920 + i) * 3 + 2] = x; x = y - 0.698001 * v - 0.337633 * u; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[(1920 + i) * 3 + 1] = x; x = y + 1.732446 * u; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[(1920 + i) * 3 + 0] = x; // 4  rgb y = *(f1 + j * 1920 * 2 + 1920 + i + 1); x = y + 1.370705 * v; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[(1920 + i) * 3 + 5] = x; x = y - 0.698001 * v - 0.337633 * u; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[(1920 + i) * 3 + 4] = x; x = y + 1.732446 * u; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[(1920 + i) * 3 + 3] = x; // printf("%i, ", i); } // for i fwrite(buff, 1, 1920 * 3 * 2, pFile); printf("\n %i\n", j); } // for j // printf("Save4\n"); // Write pixel data // fwrite(buff, 1, 1920*1080*3, pFile); // Close file printf("close\n"); fclose(pFile); printf("exit\n"); delete buff; // return; }</span></span></code> </pre><br></div></div><br>  Obwohl Sie mit NV12 arbeiten, k√∂nnen Sie die Implementierung von Verfahren wie Unsch√§rfe, Retinex und das Abrufen von Bildern in Graustufen beschleunigen (indem Sie einfach die Farbe verwerfen).  Bei meinen Aufgaben √ºbersetze ich das NV12-Format nicht in RGB, da dies zus√§tzliche Zeit in Anspruch nimmt. <br><br>  Und so haben wir gelernt, wie man Videodateien in Hardware dekodiert und in einem Fenster anzeigt.  Wir haben uns im NV12-Format kennengelernt und erfahren, wie man es in vertrautes RGB konvertiert. <br><br><h3>  DLL-Hardware-Dekodierung </h3><br>  FFmpeg gibt Frames nach 40 ms aus (bei 25 Frames pro Sekunde).  Die Verarbeitung eines Full HD-Frames dauert in der Regel erheblich l√§nger.  Dies erfordert Multithreading, um die Last aller 4 Prozessorkerne zu maximieren.  In der Praxis starte ich 6 Threads einmal und entferne sie nicht mehr, was die Arbeit erheblich vereinfacht und die Zuverl√§ssigkeit des Programms erh√∂ht.  Das Betriebsschema ist in Fig. 2 gezeigt.  1 <br><br><img src="https://habrastorage.org/webt/zy/pd/27/zypd27dsdmasmsc6g2yeyy3u8iu.png" alt="Bild"><br>  <i>Abb. 1 Schema zum Erstellen eines Multithread-Programms mit FFmpeg</i> <br><br>  Ich habe meinen Decoder als <b>* .dll</b> (FFmpegD.DLL) geschrieben, um ihn in meine Projekte aufzunehmen.  Auf diese Weise k√∂nnen Sie den Code des Projekts reduzieren, wodurch das Verst√§ndnis des Codes verbessert und in eine beliebige Programmiersprache aufgenommen wird, bis hin zu Assembler (verifiziert :)).  Damit schreiben wir unseren RTSP-Stream-Player von der IP-Kamera. <br><br>  Um mit einer DLL zu arbeiten, m√ºssen Sie einen Zeiger auf ein int [13] -Array, einen HANDLE eines neuen Frame-Ankunftsereignisses, einen HANDLE zum Starten der Verarbeitung eines neuen Datenpakets von der Kamera und ein Array-Zeichen der Kamera √ºbergeben. <br><br>  Die Array-Struktur ist in Tabelle 1 angegeben. <br><br><img src="https://habrastorage.org/webt/ds/g7/mq/dsg7mqh4ioarsp5mi9uio98k-yi.png" alt="Bild"><br><br>  Vor dem Anruf m√ºssen Sie die Rahmennummern 1-4 zur√ºcksetzen. <br><br>  Die DLL f√ºhrt alle erforderlichen Schritte aus, um FFmpeg zu initialisieren, und zeichnet Zeiger und Rahmennummern auf.  Nachdem es das Ereignis "New Frame Arrival" gesetzt hat.  Es ist nur erforderlich, die eingehenden Frames zu verarbeiten und 0 anstelle der Frame-Nummer zu schreiben (dies bedeutet, dass der Frame verarbeitet wurde und nicht mehr verwendet wird). <br><br>  Unten finden Sie einen Beispiel-Player mit Quellcode.  Das Beispiel ist ShowDib3 Charles Petzold. <br><br>  ‚Üí <a href="">Mit dem Projekt archivieren</a> <br>  ‚Üí <a href="">FFmpegD.dll-Archiv</a> <br><br>  <b>ERGEBNISSE:</b> FFmpeg-Hardware-Bewegungsmelder dekodiert sogar auf Intel Atom Z8350 h264 Full HD in Echtzeit mit bis zu 20% Prozessorlast mit angeschlossenem Bewegungsmelder. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2I1hL9g8LqY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Beispiel f√ºr den Betrieb des Bewegungsmelders unter Intel ATOM Z8350.</i>  <i>Die ersten 30 Sekunden sind die Berechnung des Hintergrunds.</i>  <i>Danach arbeitet der Bewegungsmelder nach der Methode des Subtrahierens des Hintergrunds.</i> <br><br>  <b>PS</b> Sie k√∂nnen auch Videodateien dekodieren (komprimiert h.264) !!! <br><br>  Referenzen: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verschiedene n√ºtzliche Informationen zu FFmpeg</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zur Verwendung der verschiedenen von FFmpeg bereitgestellten Bibliotheken</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu Formaten und zur Konvertierung in RGB</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461735/">https://habr.com/ru/post/de461735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461725/index.html">DataGrip 2019.2: Verbindungsmanagement, Datensuche, Filterung in der Navigation</a></li>
<li><a href="../de461727/index.html">Cisco Small Business Solutions: Ein gutes Netzwerk ist nicht unbedingt teuer</a></li>
<li><a href="../de461729/index.html">Verwenden von Jailbreaking zum Extrahieren von Daten: Risiken und Konsequenzen</a></li>
<li><a href="../de461731/index.html">DPKI: Beseitigung der Nachteile einer zentralisierten PKI durch Blockchain</a></li>
<li><a href="../de461733/index.html">Englisch lernen: 9 amerikanische Redewendungen</a></li>
<li><a href="../de461737/index.html">Wir sammeln die Umgebung f√ºr modernes TDD auf JavaScript + VS-Code</a></li>
<li><a href="../de461739/index.html">Backend United 4: Okroshka. Vorf√§lle</a></li>
<li><a href="../de461741/index.html">Hierarchisches Clustering kategorialer Daten in R.</a></li>
<li><a href="../de461743/index.html">Sicherheitswoche 31: VLC-Sicherheitsl√ºcke und defektes Telefon</a></li>
<li><a href="../de461745/index.html">DeviceLock DLP: Preise des russischen Schwarzmarktes f√ºr das Durchbrechen personenbezogener Daten (plus eine Antwort auf die Antwort der Tinkoff Bank)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>