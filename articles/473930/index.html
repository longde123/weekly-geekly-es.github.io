<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßúüèº üëï üñ•Ô∏è HTTP / 3: rompiendo los cimientos y un mundo nuevo y valiente üèáüèª üë©üèæ‚Äçü§ù‚Äçüë©üèΩ üìê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por m√°s de 20 a√±os, hemos estado viendo p√°ginas web usando el protocolo HTTP. La mayor√≠a de los usuarios no piensan en absoluto sobre qu√© es y c√≥mo fu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>HTTP / 3: rompiendo los cimientos y un mundo nuevo y valiente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/473930/">  Por m√°s de 20 a√±os, hemos estado viendo p√°ginas web usando el protocolo HTTP.  La mayor√≠a de los usuarios no piensan en absoluto sobre qu√© es y c√≥mo funciona.  Otros saben que en alg√∫n lugar bajo HTTP hay TLS, y debajo hay TCP, bajo el cual IP, etc.  Y el tercero, los herejes, creen que TCP es el siglo pasado, quieren algo m√°s r√°pido, m√°s confiable y m√°s seguro.  Pero en sus intentos de inventar un nuevo protocolo ideal, volvieron a las tecnolog√≠as de los a√±os 80 y est√°n tratando de construir su nuevo mundo valiente sobre ellos. <br><img src="https://habrastorage.org/webt/fg/dx/5l/fgdx5lvjrdjflaapjav9z0xwpyk.jpeg"><br><a name="habracut"></a><br><h2>  Un poco de historia: HTTP / 1.1 </h2><br>  En 1997, el protocolo de intercambio de texto HTTP versi√≥n 1.1 gan√≥ su RFC.  En ese momento, los navegadores utilizaron el protocolo durante varios a√±os, y el nuevo est√°ndar dur√≥ otros quince.  El protocolo funcion√≥ solo sobre una base de solicitud-respuesta y estaba destinado principalmente a transmitir informaci√≥n textual. <br><br>  HTTP fue dise√±ado para funcionar sobre el protocolo TCP, lo que garantiza la entrega confiable de paquetes al destino.  TCP se basa en establecer y mantener una conexi√≥n confiable entre puntos finales y segmentar el tr√°fico.  Los segmentos tienen su propio n√∫mero de secuencia y suma de verificaci√≥n.  Si de repente uno de los segmentos no viene o viene con la suma de verificaci√≥n incorrecta, la transmisi√≥n se detendr√° hasta que se restablezca el segmento perdido. <br><br>  En HTTP / 1.0, la conexi√≥n TCP se cerr√≥ despu√©s de cada solicitud.  Fue extremadamente derrochador desde  Establecer una conexi√≥n TCP (3-Way-Handshake) no es un proceso r√°pido.  HTTP / 1.1 introdujo el mecanismo keep-alive, que le permite reutilizar una √∫nica conexi√≥n para m√∫ltiples solicitudes.  Sin embargo, dado que puede convertirse f√°cilmente en un cuello de botella, se permiten m√∫ltiples conexiones TCP / IP al mismo host en diferentes implementaciones HTTP / 1.1.  Por ejemplo, en Chrome y en versiones recientes de Firefox, se permiten hasta seis conexiones. <br><img src="https://habrastorage.org/webt/jg/89/qj/jg89qjf71ebwzitjnv4uwke3oua.png"><br>  Tambi√©n se supon√≠a que el cifrado se dejaba a otros protocolos, y para esto, el protocolo TLS se us√≥ a trav√©s de TCP, que proteg√≠a de manera confiable los datos, pero aument√≥ a√∫n m√°s el tiempo requerido para establecer una conexi√≥n.  Como resultado, el proceso de apret√≥n de manos comenz√≥ a verse as√≠: <br><img src="https://habrastorage.org/webt/2b/nb/qw/2bnbqw9jz94njlrds7e6l-omzmw.png"><br>  <i>Ilustraci√≥n de Cloudflare</i> <br><br>  Por lo tanto, HTTP / 1.1 tuvo una serie de problemas: <br><br><ul><li>  Configuraci√≥n de conexi√≥n lenta. </li><li>  Se utiliza una conexi√≥n TCP para una solicitud, lo que significa que el resto de las solicitudes deben encontrar otra conexi√≥n o esperar hasta que la solicitud actual la libere. </li><li>  Solo se admite el modelo de extracci√≥n.  No hay nada en el est√°ndar sobre server-push. </li><li>  Los encabezados se transmiten en texto. </li></ul><br>  Si el empuje del servidor se implementa de alguna manera usando el protocolo WebSocket, entonces el resto de los problemas tuvieron que ser tratados de manera m√°s radical. <br><br><h2>  Un poco de modernidad: HTTP / 2 </h2><br>  En 2012, el trabajo sobre el protocolo SPDY (pronunciado "velocidad") comenz√≥ en las entra√±as de Google.  El protocolo fue dise√±ado para resolver los problemas b√°sicos de HTTP / 1.1 y al mismo tiempo ten√≠a que mantener la compatibilidad con versiones anteriores.  En 2015, el grupo de trabajo IETF introdujo la especificaci√≥n HTTP / 2 basada en el protocolo SPDY.  Estas son las diferencias en HTTP / 2: <br><br><ul><li>  Serializaci√≥n binaria. </li><li>  Multiplexar m√∫ltiples solicitudes HTTP en una sola conexi√≥n TCP. </li><li>  Servidor-empuje fuera de la caja (sin WebSocket). </li></ul><br>  El protocolo fue un gran paso adelante.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://">Supera</a> ampliamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://">a la primera versi√≥n</a> y no requiere la creaci√≥n de varias conexiones TCP: todas las solicitudes a un host se multiplexan en una.  Es decir, en una conexi√≥n hay varias llamadas secuencias, cada una de las cuales tiene su propia ID.  El bono es un servidor en caja. <br><br>  Sin embargo, la multiplicaci√≥n conduce a otro problema fundamental.  Imagine que ejecutamos asincr√≥nicamente 5 solicitudes a un servidor.  Cuando se utiliza HTTP / 2, todas estas solicitudes se ejecutar√°n dentro de la misma conexi√≥n TCP, lo que significa que si uno de los segmentos de cualquier solicitud se pierde o llega incorrectamente, la transmisi√≥n de todas las solicitudes y respuestas se detendr√° hasta que se restablezca el segmento perdido.  Obviamente, cuanto peor es la calidad de la conexi√≥n, m√°s lento funciona HTTP / 2.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://">Seg√∫n Daniel Stenberg</a> , en una situaci√≥n en la que los paquetes perdidos representan el 2% de todos, HTTP / 1.1 en un navegador funciona mejor que HTTP / 2 debido al hecho de que abre 6 conexiones, y no una. <br><br>  Este problema se llama "bloqueo de cabecera de l√≠nea" y, desafortunadamente, no es posible resolverlo usando TCP. <br><img src="https://habrastorage.org/webt/nu/zn/ry/nuznryxm_rxuyjadhx2kjyhbluc.png"><br>  <i>Ilustraci√≥n de Daniel Steinberg</i> <br><br>  Como resultado, los desarrolladores del est√°ndar HTTP / 2 hicieron un gran trabajo e hicieron casi todo lo que se pod√≠a hacer a nivel de aplicaci√≥n del modelo OSI.  Es hora de bajar al nivel de transporte e inventar un nuevo protocolo de transporte. <br><br><h2>  Necesitamos un nuevo protocolo: UDP vs TCP </h2><br>  R√°pidamente se hizo evidente que introducir un protocolo de capa de transporte completamente nuevo es una tarea sin soluci√≥n en las realidades de hoy.  El hecho es que las gl√°ndulas o cajas intermedias (enrutadores, cortafuegos, servidores NAT ...) conocen el nivel de transporte, y ense√±arles algo nuevo es una tarea extremadamente dif√≠cil.  Adem√°s, el soporte para los protocolos de transporte est√° conectado al n√∫cleo de los sistemas operativos, y los n√∫cleos tambi√©n cambian no tan voluntariamente. <br><br>  Y aqu√≠ uno podr√≠a darse por vencido y decir "Nosotros, por supuesto, inventaremos un nuevo HTTP / 3 con preferencia y cortesanas, pero se implementar√° en 10-15 a√±os (despu√©s de este tiempo, la mayor√≠a de las gl√°ndulas ser√°n reemplazadas)", pero hay una m√°s, no la mayor√≠a opci√≥n obvia: usar el protocolo UDP.  S√≠, s√≠, el mismo protocolo seg√∫n el cual lanzamos archivos en una LAN a fines de los noventa y principios de cero.  Casi todas las piezas de hierro de hoy en d√≠a saben c√≥mo trabajar con √©l. <br><br>  ¬øCu√°les son las ventajas de UDP sobre TCP?  En primer lugar, no tenemos una sesi√≥n de nivel de transporte que el hierro conozca.  Esto nos permite determinar la sesi√≥n en los puntos finales nosotros mismos y resolver los conflictos que surjan all√≠.  Es decir, no estamos limitados a una o varias sesiones (como en TCP), pero podemos crearlas todo lo que necesitemos.  En segundo lugar, la transmisi√≥n de datos a trav√©s de UDP es m√°s r√°pida que a trav√©s de TCP.  Por lo tanto, en teor√≠a, podemos superar el l√≠mite de velocidad actual alcanzado en HTTP / 2. <br><br>  Sin embargo, UDP no garantiza una transmisi√≥n de datos confiable.  De hecho, simplemente enviamos paquetes, con la esperanza de que se reciban en el otro extremo.  No recibi√≥?  Bueno, no hubo suerte ... Esto fue suficiente para transmitir video para adultos, pero para cosas m√°s serias necesitas confiabilidad, lo que significa que tienes que enrollar algo m√°s sobre UDP. <br><br>  Al igual que con HTTP / 2, el trabajo para crear un nuevo protocolo comenz√≥ en Google en 2012, es decir, aproximadamente al mismo tiempo que el inicio del trabajo en SPDY.  En 2013, Jim Roskind present√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el protocolo QUIC (Quick UDP Internet Connections) al</a> p√∫blico en general, y ya en 2015 se introdujo Internet Draft para estandarizar el IETF.  Ya en ese momento, el protocolo desarrollado por Roskind en Google era muy diferente del est√°ndar, por lo que la versi√≥n de Google se llamaba gQUIC. <br><br><h4>  ¬øQu√© es QUIC? </h4><br>  Primero, como ya se mencion√≥, este es un contenedor sobre UDP.  La conexi√≥n QUIC se eleva por encima de UDP, en la que, por analog√≠a con HTTP / 2, pueden existir varias secuencias.  Estas secuencias solo existen en los puntos finales y se sirven de forma independiente.  Si la p√©rdida de paquetes se produjo en una secuencia, no afectar√° a las dem√°s de ninguna manera. <br><img src="https://habrastorage.org/webt/91/ml/el/91mlel1x2cca1jpzdkmqgyhenog.png"><br>  <i>Ilustraci√≥n de Daniel Steinberg</i> <br><br>  En segundo lugar, el cifrado ahora se implementa no en un nivel separado, sino que se incluye en el protocolo.  Esto le permite establecer una conexi√≥n e intercambiar claves p√∫blicas en un √∫nico protocolo de enlace, y tambi√©n le permite utilizar el complicado mecanismo de protocolo de enlace 0-RTT y, en general, evitar retrasos en el intercambio de manos.  Adem√°s, los paquetes de datos individuales ahora se pueden cifrar.  Esto le permite no esperar la finalizaci√≥n de la recepci√≥n de datos de la transmisi√≥n, sino descifrar los paquetes recibidos de forma independiente.  Este modo de operaci√≥n no era posible en absoluto en TCP, porque  TLS y TCP funcionaban independientemente el uno del otro, y TLS no pod√≠a saber en qu√© partes se cortar√≠an los datos TCP.  Y, por lo tanto, no pude preparar mis segmentos para que encajen en los segmentos TCP uno a uno y puedan descifrarse de forma independiente.  Todas estas mejoras permiten que QUIC reduzca la latencia en comparaci√≥n con TCP. <br><img src="https://habrastorage.org/webt/cf/nn/m3/cfnnm3uoherao-9oczolm2h7vxk.png"><br>  En tercer lugar, el concepto de transmisiones f√°ciles le permite desvincular la conexi√≥n de la direcci√≥n IP del cliente.  Esto es importante, por ejemplo, cuando un cliente cambia de un punto de acceso Wi-Fi a otro, cambiando su IP.  En este caso, cuando se usa TCP, se produce un largo proceso durante el cual las conexiones TCP existentes se caen en el tiempo de espera y se crean nuevas conexiones desde la nueva IP.  En el caso de QUIC, el cliente simplemente contin√∫a enviando paquetes desde la nueva IP al servidor con la ID de flujo anterior.  Porque  Stream ID ahora es √∫nico y no se reutiliza, el servidor comprende que el cliente ha cambiado la direcci√≥n IP, env√≠a los paquetes perdidos y contin√∫a la comunicaci√≥n a la nueva direcci√≥n. <br><br>  Cuarto, QUIC se implementa a nivel de aplicaci√≥n, no en el sistema operativo.  Esto, por un lado, permite cambios m√°s r√°pidos en el protocolo, ya que  Para obtener una actualizaci√≥n, simplemente actualice la biblioteca, en lugar de esperar una nueva versi√≥n del sistema operativo.  Por otro lado, esto conduce a un fuerte aumento en el consumo del procesador. <br><br>  Y finalmente, los titulares.  La compresi√≥n de encabezado solo se refiere a puntos que difieren en QUIC y gQUIC.  No veo ninguna raz√≥n para dedicar mucho tiempo a esto, solo puedo decir que en la versi√≥n presentada para la estandarizaci√≥n, la compresi√≥n del encabezado se hizo lo m√°s similar posible a la compresi√≥n del encabezado en HTTP / 2.  M√°s detalles se pueden leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h4>  ¬øCu√°nto m√°s r√°pido es? </h4><br>  Esta es una pregunta dif√≠cil.  El hecho es que si bien no tenemos un est√°ndar, no hay nada especial para medir.  Quiz√°s las √∫nicas estad√≠sticas que tenemos son las estad√≠sticas de Google, que ha estado usando gQUIC desde 2013 y en 2016 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">inform√≥ al IETF</a> que alrededor del 90% del tr√°fico que va a sus servidores desde el navegador Chrome ahora usa QUIC.  En la misma presentaci√≥n, informan que a trav√©s de gQUIC, las p√°ginas se cargan aproximadamente un 5% m√°s r√°pido, y la transmisi√≥n de video tiene un 30% menos de congelaciones en comparaci√≥n con TCP. <br><br>  En 2017, un grupo de investigadores dirigido por Arash Molavi Kakhki public√≥ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gran trabajo</a> sobre el estudio del rendimiento de gQUIC en comparaci√≥n con TCP. <br>  El estudio revel√≥ varias debilidades de gQUIC, como la inestabilidad en la mezcla de paquetes de red, la injusticia en la capacidad del canal y la transferencia m√°s lenta de objetos peque√±os (hasta 10 kb).  Sin embargo, este √∫ltimo puede compensarse por usar el 0-RTT.  En todos los dem√°s casos investigados, gQUIC mostr√≥ un aumento en la velocidad en comparaci√≥n con TCP.  Es dif√≠cil hablar de n√∫meros espec√≠ficos.  Es mejor leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el estudio en s√≠</a> o una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">breve publicaci√≥n</a> . <br><br>  Aqu√≠ hay que decir que estos datos son espec√≠ficamente sobre gQUIC, y son irrelevantes para el est√°ndar que se est√° desarrollando.  Qu√© suceder√° con QUIC: hasta ahora, el misterio est√° detr√°s de siete sellos, pero existe la esperanza de que las debilidades identificadas por gQUIC se tengan en cuenta y se corrijan. <br><br><h2>  Un peque√±o futuro: ¬øqu√© pasa con HTTP / 3? </h2><br>  Y aqu√≠ todo est√° claro: la API no cambiar√° de ninguna manera.  Todo permanecer√° exactamente igual que en HTTP / 2.  Bueno, si la API sigue siendo la misma, la transici√≥n a HTTP / 3 deber√° decidirse utilizando la √∫ltima versi√≥n de la biblioteca que admite el transporte a trav√©s de QUIC en el back-end.  Es cierto que durante mucho tiempo todav√≠a tiene que mantener el respaldo de las versiones anteriores de HTTP, porque  Internet ahora no est√° listo para un cambio completo a UDP. <br><br><h4>  Quien ya esta apoyando </h4><br>  Aqu√≠ hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lista de</a> implementaciones QUIC existentes.  A pesar de la falta de un est√°ndar, la lista no es mala. <br><br>  Actualmente, ning√∫n navegador admite QUIC en la versi√≥n.  Recientemente hubo informaci√≥n de que Chrome inclu√≠a soporte HTTP / 3, pero hasta ahora solo en Canarias. <br><br>  De los backends, HTTP / 3 solo es compatible con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Caddy</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://blog.cloudflare.com/">Cloudflare</a> , pero hasta ahora de forma experimental.  NGINX <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anunci√≥</a> a fines de la primavera de 2019 que hab√≠an comenzado a trabajar en el soporte HTTP / 3, pero a√∫n no lo hab√≠an completado. <br><br><h4>  Cuales son los problemas </h4><br>  Vivimos en el mundo real, donde ni una sola gran tecnolog√≠a puede llegar a las masas sin encontrar resistencia, y QUIC no es una excepci√≥n. <br><br>  Lo que es m√°s importante, debe explicar de alguna manera al navegador que "https: //" ya no es un hecho que conduce al puerto TCP 443.  Puede que no haya TCP en absoluto.  Para hacer esto, use el encabezado Alt-Svc.  Permite que el navegador sea informado de que este sitio web tambi√©n est√° disponible en dicho protocolo en tal direcci√≥n.  En teor√≠a, esto deber√≠a funcionar como un reloj, pero en la pr√°ctica, nos topamos con el hecho de que UDP puede, por ejemplo, deshabilitarse en el firewall para evitar ataques DDoS. <br><br>  Pero incluso si UDP no est√° prohibido, el cliente puede estar detr√°s de un enrutador NAT que est√° configurado para mantener una sesi√≥n TCP por direcci√≥n IP, como  usamos UDP, en el que no hay sesi√≥n de hardware, NAT no mantendr√° la conexi√≥n y la sesi√≥n QUIC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">siempre finalizar√°</a> . <br><br>  Todos estos problemas est√°n relacionados con el hecho de que UDP no se utiliz√≥ anteriormente para transmitir contenido de Internet, y los fabricantes de hardware no podr√≠an haber previsto que esto suceder√≠a alguna vez.  Del mismo modo, los administradores a√∫n no entienden c√≥mo configurar adecuadamente sus redes para QUIC.  Esta situaci√≥n cambiar√° lentamente y, en cualquier caso, dichos cambios tomar√°n menos tiempo que la introducci√≥n de un nuevo protocolo de capa de transporte. <br><br>  Adem√°s, como ya se describi√≥, QUIC aumenta en gran medida la utilizaci√≥n del procesador.  Daniel Stenberg <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">calific√≥ el</a> crecimiento en el procesador hasta tres veces. <br><br><h4>  Cuando viene HTTP / 3 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quieren adoptar el</a> est√°ndar para mayo de 2020, pero dado que los documentos programados para julio de 2019 permanecen sin terminar, podemos decir que la fecha probablemente se posponga. <br><br>  Bueno, Google ha estado utilizando su implementaci√≥n de gQUIC desde 2013.  Si observa la solicitud HTTP que se env√≠a al motor de b√∫squeda de Google, puede ver esto: <br><img src="https://habrastorage.org/webt/51/ck/e2/51cke2t4uepw6hbasyq9oqhvjtc.png"><br><br><h2>  Conclusiones </h2><br>  QUIC ahora parece una tecnolog√≠a bastante cruda, pero muy prometedora.  Teniendo en cuenta que en los √∫ltimos 20 a√±os, todas las optimizaciones de los protocolos de la capa de transporte relacionadas principalmente con TCP, QUIC, que en la mayor√≠a de los casos gana en rendimiento, ahora se ven extremadamente bien. <br><br>  Sin embargo, todav√≠a hay problemas sin resolver que deben abordarse en los pr√≥ximos a√±os.  El proceso puede retrasarse debido al hecho de que el hardware est√° involucrado, lo que a nadie le gusta actualizar, pero sin embargo, todos los problemas parecen bastante solucionables, y tarde o temprano todos tendremos HTTP / 3. <br><br>  ¬°El futuro no est√° lejos! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/473930/">https://habr.com/ru/post/473930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../473916/index.html">Historias del centro de datos: historias de terror de Halloween sobre motores di√©sel, diplomacia y tornillos autorroscantes en el calentador</a></li>
<li><a href="../473918/index.html">Internet viajando en Rusia: velocidad y oportunidad</a></li>
<li><a href="../473922/index.html">Conferencia de Selectel Networking Academy</a></li>
<li><a href="../473924/index.html">No solo SMS y token: autenticaci√≥n multifactor basada en el servicio de autenticaci√≥n SafeNet</a></li>
<li><a href="../473928/index.html">Extinci√≥n de archivos de computadora</a></li>
<li><a href="../473932/index.html">¬øC√≥mo funciona una IA de juegos h√≠bridos y cu√°les son sus ventajas?</a></li>
<li><a href="../473936/index.html">Rendimiento de audio interactivo: una nueva era de juegos de asistente de voz</a></li>
<li><a href="../473938/index.html">Almacene universalmente la configuraci√≥n de las aplicaciones a trav√©s de IConfiguration</a></li>
<li><a href="../473940/index.html">Prueba de resistencia: nanomec√°nica de n√°car c√°scara noble pinna</a></li>
<li><a href="../473944/index.html">Consejos del creador de RimWorld: distorsiones cognitivas al predecir un fan√°tico del juego</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>