<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍✈️ 🎦 🧑🏿‍🤝‍🧑🏾 Optlib 遗传优化算法在Rust中的实现 🛷 🔋 🤞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文介绍了optlib库，该库旨在解决Rust语言中的全局优化问题。 在撰写本文时，该库实现了一种遗传算法，用于查找函数的全局最小值。 optlib库未绑定到用于优化功能的特定输入类型。 而且，库的构建方式使得在使用遗传算法时，可以轻松更改遗传算法的杂交，变异，选择和其他阶段的算法。 实际上，遗传算...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optlib 遗传优化算法在Rust中的实现</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448870/"> 本文介绍了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib</a>库，该库旨在解决Rust语言中的全局优化问题。 在撰写本文时，该库实现了一种遗传算法，用于查找函数的全局最小值。  optlib库未绑定到用于优化功能的特定输入类型。 而且，库的构建方式使得在使用遗传算法时，可以轻松更改遗传算法的杂交，变异，选择和其他阶段的算法。 实际上，遗传算法就像是从立方体组装而成的。 <br><a name="habracut"></a><br><h2> 全局优化问题 </h2><br> 通常将优化问题表述如下。 <br><blockquote> 对于某些给定的函数<i>f</i> （ <i>x</i> ），在<i>x</i>的所有可能值中<i>，</i>找到一个值x'，以使<i>f</i> （x'）取最小值（或最大值）。 而且， <i>x</i>可以属于各种集合-自然数，实数，复数，向量或矩阵。 <br></blockquote><p> 函数<i>f</i> （ <i>x</i> ）的极值表示点<i>x'</i> ，函数<i>f</i> （ <i>x</i> ）的导数等于零。 </p><br><br><p> 有很多算法可以保证找到函数的极值，这是在给定起点<i>x</i> <sub>0</sub>附近的局部最小值或最大值。 这样的算法包括例如梯度下降算法。 但是，实际上，通常需要找到在给定的<i>x</i>范围内<i>，</i>除一个全局极值之外，还有许多局部极值的函数的全局最小值（或最大值）。 </p><br><br><p> 梯度算法无法解决此类功能的优化问题，因为它们的解收敛于起始点附近的最近极值。 对于发现全局最大值或最小值的问题，使用所谓的全局优化算法。 这些算法不能保证找到全局极值，因为 是概率算法，但别无选择，只能针对特定任务尝试使用不同的算法，看看哪种算法更好地应对优化，最好在最短的时间内以最大的概率找到全局极值。 </p><br><br><p> 遗传算法是最著名（且难以实现）的算法之一。 </p><br><br><h2> 遗传算法的一般方案 </h2><br><p> 遗传算法的思想逐渐产生，并在1960年代末-1970年代初形成。 在约翰·霍兰德（John Holland）的著作《自然和人工系统的适应》（1975）发行后，遗传算法得到了强大的发展。 </p><br><br><p> 遗传算法基于对大量世代中的个体群体进行建模。 在遗传算法的过程中，出现了具有最佳参数的新个体，而最不成功的个体死亡。 为了确定起见，以下是遗传算法中使用的术语。 </p><br><br><ul><li> 个体是可能值集合中<i>x的</i>一个值，以及给定点<i>x</i>的目标函数的值。 </li><li> 染色体<i>-x</i>的值。 </li><li> 染色体-如果<i>x</i>是向量，则<i>x</i> <sub>i</sub>的值。 </li><li> 适应度函数（适应度函数，目标函数）是优化函数<i>f</i> （ <i>x</i> ）。 </li><li> 人口是个人的集合。 </li><li> 生成-遗传算法的迭代次数。 </li></ul><br> 每个人代表所有可能解的集合中<i>x的</i>一个值。 针对<i>x的</i>每个值计算优化函数的值（为简便起见，在将来，我们假设我们正在寻找函数的最小值）。 我们假设目标函数的重要性越小，该解决方案越好。 <br><br><p> 遗传算法被用于许多领域。 例如，它们可用于选择神经网络中的权重。 许多CAD系统使用遗传算法来优化设备参数以满足指定要求。 同样，可以使用全局优化算法来选择板上的导体和元件的位置。 </p><br><br><p> 遗传算法的结构图如下图所示： </p><br><br><img src="https://habrastorage.org/webt/2a/pc/gn/2apcgn79bihonbdav31jksafp7o.png"><br><p> 我们将更详细地考虑算法的每个阶段。 </p><br><br><h3> 创建初始种群 </h3><br><p> 该算法的第一阶段是创建初始种群，即创建许多具有不同<i>x</i>染色体值的个体。 通常，初始种群是由具有随机染色体值的个体创建的，同时试图确保种群中的染色体值相对均匀地覆盖整个解决方案搜索区域，除非对全局极值可能位于的位置做出任何假设。 </p><br><br><p> 您可以创建染色体，以使<i>x</i>的初始值通过给定步骤均匀分布在整个搜索区域中，而不是随机地分布染色体，这取决于在此算法阶段将创建多少个人。 </p><br><br><p> 在此阶段创建的个体越多，该算法找到正确解的可能性就越大，并且随着初始种群数量的增加，通常，遗传算法需要进行的迭代次数（世代数）减少。 但是，随着人口规模的增加，需要在算法的后续阶段增加目标函数的计算量以及其他遗传运算的性能。 即，随着人口规模的增加，一代的计算时间增加。 </p><br><br><p> 原则上，在遗传算法的整个工作过程中，种群的大小不必保持恒定，通常随着世代数量的增加，种群的大小可以减小，因为 随着时间的流逝，越来越多的人将被放置在更接近所需解决方案的位置。 但是，通常人口规模保持大致恒定。 </p><br><br><h3> 选择个体进行杂交 </h3><br><p> 创建种群后，有必要确定哪些个体将参与杂交操作（请参阅下一段）。 此阶段有多种算法。 它们中最简单的方法是将每个个体进行杂交，但是在下一步中，您将不得不执行过多的杂交操作并计算目标函数的值。 </p><br><br><p> 最好给与更多成功染色体（具有最低目标功能值）的个体交配的机会，以及那些目标功能更多（更差）的个体丧失交配后代的能力。 </p><br><br><p> 因此，在此阶段，您需要创建成对的个人（如果更多的个人可以参与到交叉中，则不必是成对的），将在下一阶段对其进行交叉操作。 </p><br><br><p> 在这里您还可以应用各种算法。 例如，随机创建对。 或者，您可以按目标函数的值按升序对个人进行排序，并创建更靠近已排序列表开头的个人对（例如，来自列表前半部分，列表前三分之一的个人等）。这种方法不好，因为花费时间排序个人。 </p><br><br><p> 经常使用比赛方法。 当随机选择几个人担任每个交叉申请者的角色时，其中目标函数值最高的那个人将被发送到将来的一对。 即使在这里，也可以引入随机性元素，使目标函数值最差的个人“击败”目标函数值最好的个人的机会很小。 这样一来，您可以维持更多的异质种群，从而保护其免于退化，即 从所有个体具有近似相等的染色体值的情况出发，这相当于将算法拖延到一个极端，可能不是全局的。 </p><br><br><p> 此操作的结果将是要穿越的伙伴的列表。 </p><br><br><h3> 杂种 </h3><br><p> 杂交是一种遗传操作，可以创造具有新染色体值的新个体。 根据父母的染色体创建新的染色体。 大多数情况下，在与一组伴侣交配的过程中，会创造一个女儿，但从理论上讲，可以创造更多的孩子。 </p><br><br><p> 交叉算法也可以以各种方式实现。 如果染色体类型是个数，那么最简单的方法就是创建一个新染色体，作为父母染色体的算术平均值或几何平均值。 对于许多任务来说这已经足够了，但是最常见的是使用其他基于位运算的算法。 </p><br><br><p> 按位交叉的工作方式使子染色体由一个父体的一部分位和另一父体的一部分位组成，如下图所示： </p><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/a_/s0/e6/a_s0e6d5orwkqcg178jvwrgt5lu.png"></div><br><p> 父分割点通常是随机选择的。 不必创建两个带有这种十字架的孩子，通常仅限于其中一个。 </p><br><br><p> 如果亲本染色体的分裂点为1，则这种杂交称为单点。 但是，当将亲本染色体分为几个部分时，也可以使用多点拆分，如下图所示： </p><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gb/4a/nz/gb4anzf79xadavqdwai0f2_pfwk.png"></div><br><p> 在这种情况下，子染色体的更多组合是可能的。 </p><br><br><p> 如果染色体是浮点数，则可以将上述所有方法应用于它们，但是它们并不是非常有效。 例如，如前所述，如果将浮点数一点一点地相交，则许多相交操作将创建子染色体，该子染色体仅在最远的小数位处与父染色体之一不同。 使用双精度浮点数时，情况尤其恶化。 </p><br><br><p> 为了解决此问题，有必要回顾一下，按照IEEE 754标准的浮点数存储为三个整数：S（一位），M和N，根据它们计算出的浮点数为x =（-1） <sup>S</sup> × M× <sup>2N。</sup> 交叉浮点数的一种方法是，首先将数字划分为整数的分量S，M，N，然后对数字M和N进行上述按位交叉运算，然后选择其中一个的符号S父母，并从获得的值中做出一个女儿染色体。 </p><br><br><p> 在许多问题中，一个人没有一条，而是几条染色体，甚至可以是不同的类型（整数和浮点数）。 然后，还有更多选择可以穿越这些染色体。 例如，当创建一个女儿个体时，您可以穿越父母的所有染色体，或者可以完全改变父母之一的某些染色体而无需进行任何更改。 </p><br><br><h3> 变异 </h3><br><p> 突变是遗传算法的重要阶段，支持单个染色体的多样性，因此减少了解决方案将迅速收敛到某个局部最小值而不是全局最小值的机会。 突变是刚刚通过杂交而产生的个体染色体的随机变化。 </p><br><br><p> 通常，不会将突变的可能性设置得很高，以使该突变不会干扰算法的收敛，否则会破坏具有成功染色体的个体。 </p><br><br><p> 除了杂交之外，可以使用不同的算法进行突变。 例如，您可以用一个随机值替换一个或多个染色体。 但最常见的是，当染色体（或几个染色体）中的一个或几个位反转时，会使用按位突变，如下图所示。 </p><br><br><p> 一位突变： </p><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zf/jn/nc/zfjnncbsnqtpdolvp5ifoj1g_wk.png"></div><br><p> 几位突变： </p><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0c/tt/86/0ctt862zbpu46rdiujt0tfekgti.png"></div><br><p> 突变的位数可以是预定义的，也可以是随机变量。 </p><br><br><p> 作为突变的结果，个体可能会变得更加成功和不那么成功，但是此操作可以使成功的染色体具有一组零和那些父母个体不必以非零概率出现的染色体。 </p><br><br><h3> 选拔 </h3><br><p> 由于杂交和随后的突变，出现了新个体。 如果没有选择阶段，那么个体数量将成倍增长，这将为每一代新一代人口提供越来越多的RAM和处理时间。 因此，在出现新个体之后，有必要清除最不成功个体的群体。 这是在选择阶段发生的事情。 </p><br><br><p> 选择算法也可以不同。 通常，首先将染色体不在解决方案搜索的给定间隔内的个体丢弃。 </p><br><br><p> 然后，您可以丢弃尽可能多的最不成功的人，以维持恒定的人口规模。 也可以应用各种概率选择标准，例如，选择一个人的概率可能取决于目标函数的值。 </p><br><br><h3> 算法结束条件 </h3><br><p> 与遗传算法的其他阶段一样，有几种准则可以终止算法。 </p><br><br><p> 结束算法的最简单标准是在给定的迭代（生成）次数后终止算法。 但是必须谨慎使用该标准，因为遗传算法具有概率性，并且算法的不同开始可以以不同的速度收敛。 通常，如果算法在大量迭代过程中找不到解决方案，则将迭代次数终止准则用作附加准则。 因此，必须将足够大的数字设置为迭代次数的阈值。 </p><br><br><p> 另一个停止标准是，如果对于给定的迭代次数没有出现新的最佳解决方案，则该算法将被中断。 这意味着该算法已找到全局极值或卡在局部极值中。 </p><br><br><p> 当所有个体的染色体具有相同的含义时，也存在不利的情况。 这就是所谓的简并人口。 在这种情况下，最有可能的是，算法陷入了一个极端，不一定是全局的。 只有成功的突变才能使种群摆脱这种状态，但由于通常将突变的可能性确定为很小，而且与突变将创造出更成功的个体的事实相距甚远，因此种群退化的情况通常被视为阻止遗传算法的借口。 为了检查该标准，有必要比较所有个体的染色体，它们之间是否存在差异，如果没有差异，则停止算法。 </p><br><br><p> 在某些问题中，没有必要找到一个全局最小值，而是找到一个好的解决方案，即目标函数的值小于给定值的解决方案。 在这种情况下，如果在下一次迭代中找到的解满足此标准，则可以提前停止算法。 </p><br><br><h2>  optlib </h2><br><p>  Optlib是用于Rust语言的库，旨在优化功能。 在编写这些行时，库中仅实现了遗传算法，但将来计划通过向其添加新的优化算法来扩展该库。  Optlib完全用Rust编写。 </p><br><br><p>  Optlib是根据MIT许可分发的开源库。 </p><br><br><ul><li>  github上的页面-https: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/Jenyay/rust-optimization</a> </li><li> 在crates.io上的页面-https://crates.io/crates/optlib </li><li> 文档-https: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//docs.rs/optlib</a> </li></ul><br><h2>  optlib ::基因 </h2><br><p> 从遗传算法的描述可以看出，算法的许多阶段可以用不同的方式实现，选择它们，以便对于给定的目标函数，算法可以在最短的时间内收敛到正确的解。 </p><br><br><p>  <i>optlib ::遗传</i>模块的设计方式使得可以“从多维数据集”组装遗传算法。 在创建遗传算法将在其中进行工作的结构实例时，您需要指定将使用哪些算法来创建种群，选择配对对象，杂交，变异，选择以及使用什么标准来中断算法。 </p><br><br><p> 该库已经具有用于遗传算法各个阶段的最常用算法，但是您可以创建自己的类型来实现相应的算法。 </p><br><br><p> 在文库中，染色体是小数（即小数）向量的情况。 当函数<i>f</i> （ <b>x</b> ）最小时，其中<b>x</b>是浮点数（ <i>f32</i>或<i>f64</i> ）的向量。 </p><br><br><h3> 使用optlib :: Genetic的优化示例 </h3><br><p> 在我们开始详细描述遗传模块之前，请考虑一个示例以最小化Schwefel函数。 此多维函数的计算公式如下： </p><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>F</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mtext mathcolor=&quot;red&quot;>\&amp;#x7C97;</mtext><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x4F53;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x7B26;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x53F7;</mo></mrow><mi>x</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow><mo>=</mo><mn>418.9829</mn><mi>N</mi><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>N</mi></mrow></msubsup><msub><mi>x</mi><mi>i</mi></msub><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>i</mi><mi>n</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>q</mi><mi>r</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><msub><mi>x</mi><mi>i</mi></msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="58.432ex" height="3.021ex" viewBox="0 -883.9 25158.2 1300.8" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-46" x="0" y="0"></use><g transform="translate(749,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><g fill="red" stroke="red" transform="translate(1579,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">粗</text></g></g><g transform="translate(2909,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">体</text></g><g transform="translate(3739,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">符</text></g><g transform="translate(4569,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">号</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-78" x="5399" y="0"></use><g transform="translate(5972,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-3D" x="7080" y="0"></use><g transform="translate(8136,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-34"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-31" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-38" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-2E" x="1501" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-39" x="1780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-38" x="2280" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-32" x="2781" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-39" x="3281" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-4E" x="11918" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-2212" x="13029" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-73" x="14279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-75" x="14749" y="0"></use><g transform="translate(15321,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-4E" x="1242" y="488"></use><g transform="translate(878,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-31" x="1124" y="0"></use></g></g><g transform="translate(17449,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-69" x="809" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-73" x="18615" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-69" x="19085" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-6E" x="19430" y="0"></use><g transform="translate(20031,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-73" x="21111" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-71" x="21580" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-72" x="22041" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-74" x="22492" y="0"></use><g transform="translate(22854,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-7C" x="0" y="0"></use><g transform="translate(278,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-69" x="809" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-7C" x="1195" y="0"></use></g><g transform="translate(24328,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>F</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mtext mathcolor="red">\粗</mtext><mrow class="MJX-TeXAtom-ORD"><mo>体</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>符</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>号</mo></mrow><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow><mo>=</mo><mn>418.9829</mn><mi>N</mi><mo>−</mo><mtext>&nbsp;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>N</mi></mrow></msubsup><msub><mi>x</mi><mi>i</mi></msub><mtext>&nbsp;</mtext><mi>s</mi><mi>i</mi><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mtext>&nbsp;</mtext><mi>s</mi><mi>q</mi><mi>r</mi><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><msub><mi>x</mi><mi>i</mi></msub><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow></mrow><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> F（\粗体符号x）= 418.9829N-\ sum_ {i = 1} ^ {N} x_i \ sin（\ sqrt {| x_i |}）</script></p><br><br><p> 在-500 &lt;= x <sub>i</sub> &lt;= 500范围内的最小Schweffel函数位于点<b>x'</b> ，其中对于i = 1，2，...，N，所有x <sub>i</sub> = 420.9687，该点的函数值为f（ <b>x'</b> ） = 0。 </p><br><br><p> 如果<i>N</i> = 2，则此函数的三维图像如下： </p><br><br><img src="https://habrastorage.org/webt/i-/9j/-l/i-9j-lbw3quinfb-hswtqyvwem4.png"><br><br><p> 如果我们构建此功能的水平线，则更容易看到极端： </p><br><br><img src="https://habrastorage.org/webt/fo/dz/k7/fodzk76xyejftkxvixvtuhkxcpe.png"><br><br><p> 以下示例显示了如何使用遗传模块查找最小Schweffel函数。 您可以在examples / generic-schwefel文件夹的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源代码</a>中找到此示例。 </p><br><br><pre><code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//!    . //! //! y = f(x),  x = (x0, x1, ..., xi,... xn). //!      x' = (420.9687, 420.9687, ...) //!      xi - [-500.0; 500.0]. //! f(x') = 0 //! //! #  //! * ` ` -   . y = f(x). //! * `` -    , x = (x0, x1, x2, ..., xn). //! * `` -   x    . //! * `` -  . //! * `` -    . use optlib::genetic; use optlib::genetic::creation; use optlib::genetic::cross; use optlib::genetic::goal; use optlib::genetic::logging; use optlib::genetic::mutation; use optlib::genetic::pairing; use optlib::genetic::pre_birth; use optlib::genetic::selection; use optlib::genetic::stopchecker; use optlib::testfunctions; use optlib::Optimizer; ///    type Gene = f32; ///   type Chromosomes = Vec&lt;Gene&gt;; fn main() { //   //  .  xi     [-500.0; 500.0] let minval: Gene = -500.0; let maxval: Gene = 500.0; //      let population_size = 500; //   xi  . //  15-   let chromo_count = 15; let intervals = vec![(minval, maxval); chromo_count]; //      ( ) //      optlib::testfunctions let goal = goal::GoalFromFunction::new(testfunctions::schwefel); //       . // RandomCreator       . let creator = creation::vec_float::RandomCreator::new(population_size, intervals.clone()); //        //     . let partners_count = 2; let families_count = population_size / 2; let rounds_count = 5; let pairing = pairing::Tournament::new(partners_count, families_count, rounds_count); //   //      , //   -     let single_cross = cross::FloatCrossExp::new(); let cross = cross::VecCrossAllGenes::new(Box::new(single_cross)); //    //    (     ). let mutation_probability = 15.0; let mutation_gene_count = 3; let single_mutation = mutation::BitwiseMutation::new(mutation_gene_count); let mutation = mutation::VecMutation::new(mutation_probability, Box::new(single_mutation)); // .       , //     . let pre_births: Vec&lt;Box&lt;genetic::PreBirth&lt;Chromosomes&gt;&gt;&gt; = vec![Box::new( pre_birth::vec_float::CheckChromoInterval::new(intervals.clone()), )]; //    //   ,       1e-4 //   3000  (). let stop_checker = stopchecker::CompositeAny::new(vec![ Box::new(stopchecker::Threshold::new(1e-4)), Box::new(stopchecker::MaxIterations::new(3000)), ]); //    .  -   . //        NaN  Inf. //    ,     . let selections: Vec&lt;Box&lt;dyn genetic::Selection&lt;Chromosomes&gt;&gt;&gt; = vec![ Box::new(selection::KillFitnessNaN::new()), Box::new(selection::LimitPopulation::new(population_size)), ]; //     . //       , //       . let loggers: Vec&lt;Box&lt;genetic::Logger&lt;Chromosomes&gt;&gt;&gt; = vec![ Box::new(logging::StdoutResultOnlyLogger::new(15)), Box::new(logging::TimeStdoutLogger::new()), ]; //     let mut optimizer = genetic::GeneticOptimizer::new( Box::new(goal), Box::new(stop_checker), Box::new(creator), Box::new(pairing), Box::new(cross), Box::new(mutation), selections, pre_births, loggers, ); //    optimizer.find_min(); }</span></span></code> </pre> <br><p> 可以通过运行命令从源根目录运行此示例 </p><br><br><pre> <code class="bash hljs">cargo run --bin genetic-schwefel --release</code> </pre> <br><p> 结果应如下所示： </p><br><br><pre> <code class="plaintext hljs">Solution: 420.962615966796875 420.940093994140625 420.995391845703125 420.968505859375000 420.950866699218750 421.003784179687500 421.001281738281250 421.300537109375000 421.001708984375000 421.012603759765625 420.880493164062500 420.925079345703125 420.967559814453125 420.999237060546875 421.011505126953125 Goal: 0.015625000000000 Iterations count: 3000 Time elapsed: 2617 ms</code> </pre> <br><p> 大部分示例代码都涉及遗传算法各个阶段的特征对象的创建。 正如本文开头所写，遗传算法的每个阶段都可以通过各种方式实现。 要使用optlib ::基因模块，您需要创建特征对象，以一种或另一种方式实现每个步骤。 然后将所有这些对象转移到GeneticOptimizer结构的构造函数中，在该构造函数中实现遗传算法。 </p><br><br><p>  GeneticOptimizer结构的find_min（）方法开始执行遗传算法。 </p><br><br><h3> 基本类型和对象 </h3><br><h4>  optlib模块的基本特征 </h4><br><p> 开发optlib库的目的是在将来添加新的优化算法，以便程序可以轻松地从一种优化算法切换到另一种优化算法，因此optlib模块包含<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Optimizer</a>特性，其中包括一种方法- find_min（），在执行时运行优化算法。 这里的类型T是对象的类型，它是解搜索空间中的一个点。 例如，在上面的示例中，这是Vec &lt;Gene&gt;（其中Gene是f32的别名）。 也就是说，这种类型的对象被馈送到目标函数的输入。 </p><br><br><p> 在optlib模块中声明了Optimizer特性，如下所示： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Optimizer</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_min</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;(&amp;T, <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>)&gt;; }</code> </pre><br><p>  optim_ trait的find_min（）方法应该返回Option &lt;（＆T，f64）&gt;类型的对象，其中返回的元组中的＆T是找到的解决方案，f64是找到的解决方案的目标函数的值。 如果算法找不到解决方案，则find_min（）函数应返回None。 </p><br><br><p> 由于许多随机优化算法都使用所谓的代理（就遗传算法而言，代理是一个个体），因此optlib模块还包含带有单个get_agents（）方法的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AlgorithmWithAgents</a>特性，该方法应返回代理向量。 </p><br><br><p> 反过来，代理是一种实现optlib- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Agent的</a>另一个特征的结构。 </p><br><br><p> 特质AlgorithmWithAgents和Agent在optlib模块中声明如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlgorithmWithAgents</span></span></span></span>&lt;T&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Agent</span></span></span></span>: Agent&lt;T&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_agents</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;Self::Agent&gt;; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Agent</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_parameter</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;T; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_goal</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>; }</code> </pre> <br><p> 对于AlgorithmWithAgents和Agent，类型T的含义与对于Optimizer的含义相同，即，它是为其计算目标函数的值的对象的类型。 </p><br><br><h4>  GeneticOptimizer结构-遗传算法实现 </h4><br><br><p> 这两种类型都是针对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GeneticOptimizer</a>结构实现的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Optimizer</a>和AlgorithmWithAgents。 </p><br><br><p> 遗传算法的每个阶段都由其自己的类型表示，可以从头开始实现，也可以使用内部可用的optlib ::基因实现之一。 对于遗传算法的每个阶段，在optlib ::遗传模块内部都有一个带有辅助结构和功能的子模块，这些子模块实现了遗传算法各阶段中最常用的算法。 关于这些模块将在下面讨论。 在这些子模块中的某些子模块中，还有一个vec_float子模块，用于实现从浮点数（f32或f64）的向量计算目标函数时的算法步骤。 </p><br><br><p>  GeneticOptimizer结构的构造函数声明如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>&gt; GeneticOptimizer&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>( goal: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Goal&lt;T&gt;&gt;, stop_checker: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn StopChecker&lt;T&gt;&gt;, creator: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Creator&lt;T&gt;&gt;, pairing: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Pairing&lt;T&gt;&gt;, cross: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Cross&lt;T&gt;&gt;, mutation: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Mutation&lt;T&gt;&gt;, selections: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Selection&lt;T&gt;&gt;&gt;, pre_births: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn PreBirth&lt;T&gt;&gt;&gt;, loggers: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Logger&lt;T&gt;&gt;&gt;, ) -&gt; GeneticOptimizer&lt;T&gt; { ... } ... }</code> </pre><br><p>  GeneticOptimizer的构造函数接受许多类型的对象，这些对象会影响遗传算法的每个阶段以及结果的输出： </p><br><br><ul><li> 目标：框&lt;dyn目标&lt;T &gt;&gt;-目标函数； </li><li>  stop_checker：框&lt;dyn StopChecker &lt;T &gt;&gt;-停止条件； </li><li> 创建者：Box &lt;dyn Creator &lt;T &gt;&gt;-创建初始人口； </li><li> 配对：Box &lt;dyn Pairing &lt;T &gt;&gt;-选择交配伙伴的算法； </li><li>  cross：Box &lt;dyn Cross &lt;T &gt;&gt;-穿越算法; </li><li> 变异：Box &lt;dyn变异&lt;T &gt;&gt;-变异算法; </li><li> 选择：Vec &lt;Box &lt;dyn Selection &lt;T&gt; &gt;&gt;-选择算法的向量； </li><li>  pre_births：Vec &lt;Box &lt;dyn PreBirth &lt;T&gt; &gt;&gt;-一种在创建个体之前销毁不成功染色体的算法的载体； </li><li> 记录器：Vec &lt;Box &lt;dyn Logger &lt;T&gt; &gt;&gt;-对象的向量，保留遗传算法的日志。 </li></ul><br> 要运行该算法，必须执行Optimizer特性的find_min（）方法。 另外，GeneticOptimizer结构具有next_iterations（）方法，可在find_min（）方法完成后用于继续计算。 <br><br><p> 有时在停止算法后，更改算法参数或使用的方法很有用。 可以使用GeneticOptimizer结构的以下方法完成此操作：replace_pairing（），replace_cross（），replace_mutation（），replace_pre_birth（），replace_selection（），replace_stop_checker（）。 这些方法使您可以替换在创建GeneticOptimizer结构时传递给它的特征对象。 </p><br><br><p> 遗传算法的主要类型将在以下各节中讨论。 </p><br><br><h4> 目标特质-目标功能 </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目标</a>特征在optlib ::遗传模块中声明如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Goal</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, chromosomes: &amp;T) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>; }</code> </pre><br><p>  get（）方法应返回给定染色体的目标函数的值。 </p><br><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib :: Genetic ::目标</a>模块内部，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GoalFromFunction</a>结构，该结构实现了Goal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特性</a> 。 对于此结构，有一个采用函数的构造函数，这是目标函数。 也就是说，使用此结构，您可以从常规函数创建目标类型对象。 </p><br><br><h4> 创作者特征-创建初始人口 </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创造者特​​征</a>描述了初始种群的“创造者”。 此特征声明如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Creator</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;T&gt;; }</code> </pre><br><p>  create（）方法应返回染色体向量，并以此为基础创建初始种群。 </p><br><br><p> 对于优化多个浮点数的函数的情况， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib :: Genetic :: Creator :: Vec_float模块</a>具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RandomCreator &lt;G&gt;</a>结构，用于以随机方式创建染色体的初始分布。 </p><br><br><p> 在下文中，类型&lt;G&gt;是染色体载体中一个染色体的类型（有时使用术语“基因”代替术语“染色体”）。 如果染色体是Vec &lt;f32&gt;或Vec &lt;f64&gt;类型，则&lt;G&gt;基本上表示f32或f64类型。 </p><br><br><p>  RandomCreator &lt;G&gt;的结构声明如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RandomCreator</span></span></span></span>&lt;G: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span> + NumCast + <span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>&gt; { ... }</code> </pre><br><p> 这里的NumCast是来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">num</a> crate的类型。 此类型允许您使用from（）方法从其他数字类型创建类型。 </p><br><br><p> 要创建RandomCreator &lt;G&gt;结构，您需要使用new（）函数，该函数声明如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(population_size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, intervals: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(G, G)&gt;) -&gt; RandomCreator&lt;G&gt; { ... }</code> </pre><br><p> 在这里，种群大小是种群的大小（要创建的染色体组的数量），间隔是两个元素的元组的向量-染色体组中相应染色体（基因）的最小值和最大值，此向量的大小决定了该染色体组中包含多少个染色体每个人。 </p><br><br><p> 在上面的示例中，Schweffel函数针对f32类型的15个变量进行了优化。 每个变量必须在[-500;  500]。 也就是说，要创建总体，间隔向量必须包含15个元组（-500.0f32、500.0f32）。 </p><br><br><h4> 类型配对-选择配对伙伴 </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">配对特征</a>用于选择要杂交的个体。 此特征声明如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pairing</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_pairs</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, population: &amp;Population&lt;T&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;&gt;; }</code> </pre><br><p>  get_pairs（）方法使用一个指向“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">人口”</a>结构的指针，该结构包含<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">人口</a>中的所有个体，通过该结构，您还可以找出人口中最好和最差的个体。 </p><br><br><p> 配对get_pairs（）方法应返回一个向量，该向量包含存储将要杂交的个体的索引的向量。 根据交叉算法（将在下一节中讨论），两个或更多个人可以交叉。 </p><br><br><p> 例如，如果具有索引0和10、5、2、6和3的个体被交叉，则get_pairs（）方法应返回向量vec！[Vec！[0，10]，vec！[5，2]，vec！[ 6，3]]。 </p><br><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib ::遗传::配对模块</a>包含两个结构，可实现各种伙伴选择算法。 </p><br><br><p> 对于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RandomPairing</a>结构，配对类型的实现方式是随机选择伙伴进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交配</a> 。 </p><br><br><p> 对于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">锦标赛</a>结构，配对特征以使用锦标赛方法的方式实现。 锦标赛方法意味着将要参加十字架的每个人都必须击败另一个人（获胜个人的目标函数的值必须较小）。 如果锦标赛方法使用一轮，则意味着随机选择了两个人，并且这两个人中目标函数值较低的一个人进入了未来的“家庭”。 如果使用多个回合，则以这种方式获胜的个人应与几个随机的个人获胜。 </p><br><br><p>  Tournament结构的构造函数声明如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(partners_count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, families_count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, rounds_count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; Tournament { ... }</code> </pre><br><p> 在这里： </p><br><br><ul><li>  partners_count-穿越所需的个人人数； </li><li>  family_count-“家庭”数，即 将产生后代的个体的集合； </li><li>  rounds_count-比赛中的回合数。 </li></ul><br> 作为对锦标赛方法的进一步修改，您可以使用随机数生成器，以很小的机会击败目标函数值最差的个人，即 为了使获胜概率受目标函数值的影响，并且两个竞争对手之间的差异越大，获胜最佳个人的机会就越大，并且在目标函数值几乎相等的情况下，一个人获胜的可能性将接近50％。 <br><br><h4> 交叉类型 </h4><br><p> 个体的“家庭”形成后，为了杂交，您需要杂交他们的染色体才能使孩子拥有新的染色体。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cross</a>阶段由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cross</a>类型表示，声明如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cross</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cross</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, parents: &amp;[&amp;T]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;T&gt;; }</code> </pre><br><p>  cross（）方法跨一组父母。 该方法接受父母参数（来自对父母（而不是个人本身）染色体的切片），并应返回新染色体的向量。 父母的大小取决于使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">配对特征</a>选择<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">配对对象</a>的算法，该算法已在上一节中进行了描述。 通常使用一种算法，该算法基于两个亲本的染色体创建新的染色体，然后亲本的大小将等于两个。 </p><br><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib :: Genetic :: cross</a>模块包含使用不同的cross算法实现Cross类型的结构。 </p><br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VecCrossAllGenes-</a>一种用于跨染色体的结构，当每个人都有一组染色体时-这是一个向量。  VecCrossAllGenes构造函数接受Cross对象类型，该类型将应用于父染色体向量的所有元素。 在这种情况下，亲本染色体载体的大小必须相同。 上面的示例使用VecCrossAllGenes结构，因为使用的个体中的染色体是Vec &lt;f32&gt;类型。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CrossMean</a>是一种以两个数相交的结构，以作为子染色体，将有一个作为母体染色体的算术平均值计算出的数字。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FloatCrossGeometricMean</a>是一个以两个数相交的结构，以作为子染色体，将有一个作为母染色体的几何平均值计算出的数。 应该有浮点数作为染色体。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CrossBitwise-</a>两个数字的按位单点交叉。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FloatCrossExp-浮点数的</a>按位单点交叉。 尾数与父母参展商相互交叉。 孩子从一位父母那里收到了手势。 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib :: Genetic :: cross</a>模块<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">还</a>包含用于对不同类型的数字（整数和浮点数）进行按位交叉的函数。 <br><br><h4> 类型突变-突变 </h4><br><p> 杂交后，有必要对获得的孩子进行突变，以保持染色体的多样性，并且种群没有滑落到简并状态。 对于人群，特质<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">是突变的</a> ，声明如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutation</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutation</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, chromosomes: &amp;T) -&gt; T; }</code> </pre><br><p> 突变性状的唯一mutation（）方法引用了一条染色体，并且应该返回一个可能发生了改变的染色体。 通常，建立突变的可能性很小，例如百分之几，因此仍然保留了在亲本的基础上获得的染色体，从而提高了种群。 </p><br><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib :: Genetic ::突变</a>模块中已经实现了一些突变算法。 </p><br><br><p> 例如，此模块包含<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VecMutation</a>结构，该结构与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VecCrossAllGenes</a>结构类似，即 如果染色体是向量，则VecMutation接受Mutation对象类型，并以给定的概率将其应用于向量的所有元素，从而创建具有突变基因（染色体向量的元素）的新向量。 </p><br><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib :: genetic :: mutation</a>模块<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">还</a>包含一个实现了Mutation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特性</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BitwiseMutation</a>结构。 这种结构可以反转染色体中给定数目的随机位数。 建议将此结构与VecMutation结构一起使用。 </p><br><br><h4> 出生前特征-预选 </h4><br><p> 杂交和变异后，通常会发生选择阶段，最失败的个体将被摧毁。 但是，在optlib ::遗传库中实施遗传算法时，在选择步骤之前，还有另一个步骤可以丢弃不成功的染色体。 添加此步骤的原因是，针对个人的目标函数的计算通常会花费大量时间，并且如果染色体未落入已知搜索间隔，则无需进行计算。 例如，在上面的示例中，染色体不落在段[-500;  500]。 </p><br><br><p> 要执行此类预过滤，必须使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PreBirth特质</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特质</a>声明如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreBirth</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pre_birth</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, population: &amp;Population&lt;T&gt;, new_chromosomes: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;T&gt;); }</code> </pre><br><p>  PreBirth性状的唯一preBirth（）方法是对上述<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">种群</a>结构的引用，也是对new_chromosomes染色体向量的可变引用。 这是突变步骤后获得的染色体载体。  pre_birth（）方法的实现应从该向量中删除显然不适合该问题条件的那些染色体。 </p><br><br><p> 对于优化浮点数矢量的功能的情况， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib :: Genetic :: pre_birth :: vec_float模块</a>包含<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CheckChromoInterval</a>结构，该结构旨在删除染色体（如果它们是浮点数矢量）以及该矢量的某些元素不属于指定的时间间隔。 </p><br><br><p>  CheckChromoInterval结构的构造函数如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(intervals: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(G, G)&gt;) -&gt; CheckChromoInterval&lt;G&gt; { ... }</code> </pre><br><p> 在这里，构造函数采用具有两个元素的元组向量-染色体中每个元素的最小值和最大值。 因此，间隔向量的大小必须与个体的染色体向量的大小一致。 在上面的示例中，使用15个元组（-500.0f32、500.0f32）的向量作为间隔。 </p><br><br><h4> 选择选择-选择 </h4><br><p> 初步选择染色体后，将创建个体并将其放置在种群中（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">种群</a>结构）。 在为每个人创建个人的过程中，将计算目标函数的值。 在选择阶段，一定数量的个体必须被销毁，以使种群不会无限期地增长。 为此，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">选择</a>特征，其声明如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Selection</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kill</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, population: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Population&lt;T&gt;); }</code> </pre><br><p> 在kill（）方法中实现Selection特质的对象必须为需要销毁的种群中的每个个体调用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Individual</a>结构（个体）的kill（）方法。 </p><br><br><p> 要绕过人口中的所有个人，可以使用返回人口结构的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IterMut（）</a>方法的迭代器。 </p><br><br><p> 由于通常必须应用几个选择条件，因此在创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GeneticOptimizer</a>结构时，构造函数接受选择类型对象的向量。 </p><br><br><p> 与遗传算法的其他阶段一样， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib :: Genetic ::选择</a>模块已经提供了选择阶段的几种实现。 </p><br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">KillFitnessNaN-</a>销毁目标函数值为NaN或Inf的个人。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LimitPopulation-</a>销毁这么多最坏的个体，使人口规模不超过给定规模。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib ::遗传::选择:: vec_float :: CheckChromoInterval-</a>如果优化了浮点数向量的功能，则会破坏其染色体值不适合给定间隔的个体。 该结构的工作方式与遗传算法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前一阶段</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib :: Genetic :: pre_birth :: vec_floatCheckChromoInterval结构</a>相似。 </li></ul><br><h4>  StopChecker特性-停止条件 </h4><br><p> 在选择阶段之后，您需要检查是否应该停止遗传算法。 如上所述，在此阶段，您还可以使用各种停止算法。 对于算法的中断，对象负责实现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StopChecker特性</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特性</a>声明如下： </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StopChecker</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">can_stop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, population: &amp;Population&lt;T&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>; }</code> </pre><br><p> 如果可以停止算法，则can_stop（）方法应返回true，否则该方法应返回false。 </p><br><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib :: Genetic :: Stopchecker模块</a>包含几个具有基本停止条件的结构，以及两个用于从其他条件创建组合的结构： </p><br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MaxIterations-</a>按世代号中断标准。 遗传算法将在给定数量的迭代（生成）后停止。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GoalNotChange-</a>中断标准，如果对于给定的迭代次数找不到新的解决方案，则算法应根据该标准停止运行。 换句话说，如果对于给定的世代数，没有更多的成功个体出现。 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阈值</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -一种停止标准，如果当前最佳解决方案的目标函数的值小于指定的阈值，则遗传算法将被中断。</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CompositeAll</a> —  ,        (    - StopChecker).     ,  <b></b>   - ,     . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CompositeAny</a> —  ,        (    - StopChecker).     ,  <b>  </b>   - ,     . </li></ul><br><h4>  Logger —    </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Logger</a>      ,      ,          ,    .  Logger   : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">///       fn start(&amp;mut self, _population: &amp;Population&lt;T&gt;) {} ///     , ///           fn resume(&amp;mut self, _population: &amp;Population&lt;T&gt;) {} ///         /// (    ) fn next_iteration(&amp;mut self, _population: &amp;Population&lt;T&gt;) {} ///      fn finish(&amp;mut self, _population: &amp;Population&lt;T&gt;) {} }</span></span></code> </pre><br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib::genetic::logging</a>   ,   Logger: </p><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StdoutResultOnlyLogger</a> —         ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VerboseStdoutLogger</a> —                  . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TimeStdoutLogger</a> —        ,   . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为最后一个参数，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeneticOptimizer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构的构造</font><font style="vertical-align: inherit;">函数接受Logger </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">特征</font></a><font style="vertical-align: inherit;"> -objects的向量，这使您可以灵活地配置程序的输出。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 测试优化算法的功能 </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schweffel函数 </font></font></h3><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了测试优化算法，发明了许多具有许多局部极值的功能。</font><font style="vertical-align: inherit;">模块</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">optlib :: testfunctions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含几个功能，其可以被测试的算法。</font><font style="vertical-align: inherit;">在撰写本文时，optlib :: testfunctions模块仅包含两个函数。</font></font></p><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些功能之一是Schweffel函数，该函数在本文的开头就进行了介绍。</font><font style="vertical-align: inherit;">再一次，我记得该函数编写如下：</font></font></p><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>F</mi><mo stretchy=&quot;false&quot;>(</mo><mi mathvariant=&quot;bold-italic&quot;>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>418.9829</mn><mi>N</mi><mo>&amp;#x2212;</mo><munderover><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>N</mi></mrow></munderover><msub><mi>x</mi><mi>i</mi></msub><mi>sin</mi><mo>&amp;#x2061;</mo><mo stretchy=&quot;false&quot;>(</mo><msqrt><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><msub><mi>x</mi><mi>i</mi></msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow></msqrt><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="38.539ex" height="7.238ex" viewBox="0 -1817.6 16592.9 3116.4" role="img" focusable="false" style="vertical-align: -3.017ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-46" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-28" x="749" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHBI-78" x="1139" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-29" x="1798" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-3D" x="2465" y="0"></use><g transform="translate(3522,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-34"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-31" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-38" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-2E" x="1501" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-39" x="1780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-38" x="2280" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-32" x="2781" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-39" x="3281" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-4E" x="7304" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-2212" x="8414" y="0"></use><g transform="translate(9415,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJSZ2-2211" x="0" y="0"></use><g transform="translate(147,-1090)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-31" x="1124" y="0"></use></g><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-4E" x="577" y="1627"></use></g><g transform="translate(11026,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-69" x="809" y="-213"></use></g><g transform="translate(12110,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-73"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-69" x="394" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-6E" x="673" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-28" x="13339" y="0"></use><g transform="translate(13729,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJSZ2-221A" x="0" y="-24"></use><rect stroke="none" width="1473" height="60" x="1000" y="1067"></rect><g transform="translate(1000,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-7C" x="0" y="0"></use><g transform="translate(278,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-69" x="809" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-7C" x="1195" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-29" x="16203" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>F</mi><mo stretchy="false">(</mo><mi mathvariant="bold-italic">x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>418.9829</mn><mi>N</mi><mo>−</mo><munderover><mo>∑</mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>N</mi></mrow></munderover><msub><mi>x</mi><mi>i</mi></msub><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><msqrt><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><msub><mi>x</mi><mi>i</mi></msub><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow></msqrt><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2">F(\boldsymbol x) = 418.9829N - \sum_{i=1}^{N}x_i \sin (\sqrt{|x_i|})</script></p><br><br><p>         x' = (420.9687, 420.9687, ...).       . </p><br><br><p>   optlib::testfunctions    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">schwefel</a> .      N . </p><br><br><h3>   </h3><br><p>       ,     ,        ,        ,      . </p><br><br><p>     : </p><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>F</mi><mo stretchy=&quot;false&quot;>(</mo><mi mathvariant=&quot;bold-italic&quot;>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><munderover><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>N</mi></mrow></munderover><mo stretchy=&quot;false&quot;>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>&amp;#x2212;</mo><mi>n</mi><msup><mo stretchy=&quot;false&quot;>)</mo><mn>2</mn></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="20.763ex" height="7.238ex" viewBox="0 -1817.6 8939.7 3116.4" role="img" focusable="false" style="vertical-align: -3.017ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-46" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-28" x="749" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHBI-78" x="1139" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-29" x="1798" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-3D" x="2465" y="0"></use><g transform="translate(3522,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJSZ2-2211" x="0" y="0"></use><g transform="translate(147,-1090)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-31" x="1124" y="0"></use></g><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-4E" x="577" y="1627"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-28" x="4966" y="0"></use><g transform="translate(5356,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-69" x="809" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-2212" x="6495" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMATHI-6E" x="7495" y="0"></use><g transform="translate(8096,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/448870/&amp;usg=ALkJrhiP3jCnuzhoI3200QfShl2DYJVaSw#MJMAIN-32" x="550" y="583"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>F</mi><mo stretchy="false">(</mo><mi mathvariant="bold-italic">x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>N</mi></mrow></munderover><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>n</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3">F(\boldsymbol x) = \sum_{i=1}^{N} (x_i - n)^2</script></p><br><br><p>        x' = (1.0, 2.0,… N).       . </p><br><br><p>   optlib::testfunctions    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">paraboloid</a> . </p><br><br><h2> 结论 </h2><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib</a>     ,        .             ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">optlib::genetic</a> ),          ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> ,     . </p><br><br><p>       optlib::genetic.                 .           ,   ,         ,        ,       . </p><br><br><p>        ,          .       ,          ( ,       ..) </p><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 此外，计划添加新的分析功能（除Schweffel函数外）以测试优化算法。 </font></font></p><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我再次回忆起与optlib库相关的链接： </font></font></p><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github上的页面-https: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//github.com/Jenyay/rust-optimization</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">页面上crates.io - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://crates.io/crates/optlib</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文档-https: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//docs.rs/optlib</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我期待您的评论，补充和评论。 </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN448870/">https://habr.com/ru/post/zh-CN448870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN448856/index.html">Torfon-匿名电话的移动应用程序</a></li>
<li><a href="../zh-CN448858/index.html">停止为此使用Ngrx /特效</a></li>
<li><a href="../zh-CN448860/index.html">Android Studio 3.4发行说明（2019年4月）</a></li>
<li><a href="../zh-CN448866/index.html">从成对（相对）汇率到绝对汇率的转换的详细信息。 错误处理</a></li>
<li><a href="../zh-CN448868/index.html">＃295移动开发人员的有趣材料摘要（4月15日至21日）</a></li>
<li><a href="../zh-CN448872/index.html">对讲产品翻译书</a></li>
<li><a href="../zh-CN448874/index.html">什么是黑色PR以及如何抵抗它</a></li>
<li><a href="../zh-CN448878/index.html">如何在与Agile合作时不浪费客户的1000万预算</a></li>
<li><a href="../zh-CN448880/index.html">PHP文摘154（2019年4月9日至21日）</a></li>
<li><a href="../zh-CN448882/index.html">权力游戏中的英语口音</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>