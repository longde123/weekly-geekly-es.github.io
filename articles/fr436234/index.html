<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ⓜ️ 👋🏼 🌼 Analyseurs applicatifs Haskell 🤷🏾 🧚🏿 👩🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La motivation 


 Lorsque j'ai commencé à apprendre Haskell, j'étais très ennuyé par l'utilisation généralisée d'abstractions complexes au lieu de sol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyseurs applicatifs Haskell</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436234/"><p><img src="https://habrastorage.org/webt/tq/9u/iw/tq9uiw8d_nbb1bbwrfdg1euyvci.png"></p><br><h1 id="motivaciya">  La motivation </h1><br><p>  Lorsque j'ai commencé à apprendre Haskell, j'étais très ennuyé par l'utilisation généralisée d'abstractions complexes au lieu de solutions spécifiques.  Il m'a semblé qu'il vaut bien mieux de toujours suivre le principe KISS et d'écrire des bicyclettes en utilisant des constructions de langage élémentaire que de comprendre toutes ces classes de types afin d'écrire une construction soi-disant pratique quelque part. </p><br><p>  Je n'avais pas un bon exemple où les efforts consacrés au développement du "matériel" porteraient leurs fruits.  Pour moi, l'un des exemples les plus réussis était les analyseurs.  Maintenant, j'en parle souvent quand ils me demandent quelles tâches courantes vous pouvez magnifiquement utiliser Haskell. </p><br><p> Je veux proposer aux débutants de suivre cette voie et de créer une petite base de fonctions à partir de zéro pour une implémentation pratique des analyseurs, puis de l'utiliser pour écrire leur propre analyseur, dont le code répétera littéralement la grammaire utilisée pour l'analyse. </p><br><p>  J'espère que cela aide quelqu'un à surmonter la peur des abstractions et à lui apprendre à les utiliser <em>correctement</em> (oui, je pense toujours qu'il est parfois plus efficace d'écrire un vélo). </p><a name="habracut"></a><br><p>  Je n'ai aucun but et désir de faire un cours Haskell à partir d'un article, donc je suppose que le lecteur est familier avec la syntaxe et les programmes simples développés indépendamment.  Au cas où, je parlerai brièvement des classes de types avant de passer à la description de l'implémentation. </p><br><p>  Pour ceux qui n'ont jamais écrit à Haskell, mais qui veulent comprendre ce qui se passe ici, je vous recommande de consulter d'abord la page correspondante sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Learn X dans Y minutes</a> .  En tant qu'excellent livre en russe pour les débutants, je conseille <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"A propos d'Haskell en tant</a> qu'être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">humain" de</a> Denis Shevchenko. </p><br><p>  J'essaierai d'utiliser les constructions de langage les plus simples que les débutants peuvent comprendre.  À la fin de l'article, un lien est donné au référentiel source, où dans certaines parties du code une entrée plus pratique et plus courte est utilisée, ce qui peut être moins clair à première vue. </p><br><p>  Et oui, messieurs Haskellistes, beaucoup de choses sont expliquées très simplement et maladroitement, pour des cas spéciaux, pas très abstraitement, sans utiliser des termes de la théorie des catégories et d'autres mots effrayants.  Je suis heureux que vous les connaissiez et bien sûr, ils les maîtrisent facilement.  Je les connais aussi, mais je ne pense pas qu'il soit nécessaire de vider une telle quantité d'informations dans ce contexte sur des lecteurs non préparés. </p><br><h1 id="klassy-tipov">  Classes de type </h1><br><p>  Les classes de type Haskell n'ont rien à voir avec les classes en C ++ et autres langages orientés objet.  Si nous établissons une analogie avec la POO, les classes de types ressemblent davantage à une surcharge de méthodes et de fonctions. </p><br><p> Les classes déterminent quelles actions peuvent être effectuées avec des objets des types qui composent la classe.  Par exemple, tous les nombres peuvent être comparés pour l'égalité, mais tout peut être ordonné à l'exception des nombres complexes, et en général, les fonctions ne peuvent pas du tout être comparées.  La classe de types qui peut être comparée est appelée <code>Eq</code> , ordonnée - <code>Ord</code> (les types n'ont pas besoin d'être numériques).  Ce qui peut être imprimé en traduisant en chaîne appartient à la classe <code>Show</code> , il a la classe <code>Read</code> "opposée", qui détermine comment convertir les chaînes en objets du type souhaité. </p><br><p>  Pour un ensemble de classes de type standard (telles que <code>Eq</code> , <code>Show</code> , <code>Read</code> ...), vous pouvez demander au compilateur d'implémenter la fonctionnalité souhaitée de manière standard, en utilisant le mot clé <code>deriving</code> après avoir déterminé le type: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Vous pouvez définir vos propres classes de types: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint :: a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre> <br><p>  Ici, <code>PrettyPrint</code> est le nom de la classe, <code>a</code> est une variable de type.  Le mot-clé <code>where</code> est suivi d'une liste des méthodes dites de classe, c'est-à-dire  fonctions qui peuvent être appliquées aux objets de type de cette classe. </p><br><p>  Afin d'indiquer l'appartenance d'un type de données à une classe, la construction suivante est utilisée: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint (<span class="hljs-type"><span class="hljs-type">Point</span></span> xy) = <span class="hljs-string"><span class="hljs-string">"("</span></span> ++ show x ++ <span class="hljs-string"><span class="hljs-string">", "</span></span> ++ show y ++ <span class="hljs-string"><span class="hljs-string">")"</span></span></code> </pre> <br><p>  Le langage vous permet de spécifier des restrictions sur les classes de type auxquelles les arguments de fonction doivent se rapporter: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">showVsPretty</span></span> :: (<span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> a) =&gt; a -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>) showVsPretty x = (show x, pPrint x)</code> </pre> <br><p>  Pour chaque appel de fonction, le compilateur vérifie si ces exigences de type sont remplies et, en cas d'échec, affiche une erreur (cela se produit bien sûr au stade de la compilation). </p><br><pre> <code class="haskell hljs">&gt;&gt;&gt; showVsPretty (<span class="hljs-type"><span class="hljs-type">Point</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-string"><span class="hljs-string">"Point {xCoord = 2.0, yCoord = 3.0}"</span></span>,<span class="hljs-string"><span class="hljs-string">"(2.0, 3.0)"</span></span>) &gt;&gt;&gt; showVsPretty <span class="hljs-string"><span class="hljs-string">"str"</span></span> error: <span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> for (<span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> [<span class="hljs-type"><span class="hljs-type">Char</span></span>]) arising from a use <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> 'showVsPretty'</code> </pre> <br><h1 id="realizaciya">  Implémentation </h1><br><p>  L'analyseur reçoit une chaîne d'entrée qu'il doit analyser selon des règles prédéfinies et obtenir la valeur du type dont nous avons besoin (par exemple, un entier).  Dans ce cas, la ligne d'entrée peut ne pas se terminer et le reste servira d'entrée pour une analyse plus approfondie.  De plus, notre analyseur sera généralement non déterministe, c'est-à-dire  renverra plusieurs résultats d'analyse possibles sous forme de liste. </p><br><p>  Un tuple de deux éléments <code>(String, a)</code> convient pour décrire un résultat de l'opération de l'analyseur, où <code>a</code> est une variable de type qui peut désigner n'importe quel type d'utilisateur. </p><br><p>  Puisque l'analyseur analyse la chaîne selon certaines règles, nous la décrivons comme une fonction qui prend une chaîne en entrée et renvoie une liste de résultats: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unParser</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; [(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)] }</span></span></code> </pre> <br><p>  Nous considérerons que l'analyse est réussie si la liste des résultats se compose d'un élément et que la chaîne d'entrée a été complètement traitée.  Nous implémentons une fonction d'assistance qui essaie d'analyser de manière unique la chaîne entière: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parseString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a parseString s (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (ps) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [(<span class="hljs-string"><span class="hljs-string">""</span></span>, val)] -&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> val _ -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre> <br><h2 id="prosteyshie-parsery">  Analyseurs simples </h2><br><p>  Nous implémentons plusieurs analyseurs simples, qui seront ensuite utiles pour créer des combinaisons plus complexes. </p><br><p>  Nous commençons par analyser un seul caractère qui doit satisfaire un prédicat.  Si la chaîne d'entrée est vide, le résultat du travail est une liste vide.  Sinon, nous vérifions la valeur du prédicat sur le premier caractère de la chaîne.  Si <code>True</code> renvoyé, le résultat de l'analyse est ce caractère;  renvoyez-le avec le reste de la chaîne.  Sinon, l'analyse échoue également. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">predP</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> predP p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f <span class="hljs-string"><span class="hljs-string">""</span></span> = [] f (c : cs) | pc = [(cs, c)] | otherwise = []</code> </pre> <br><p>  Nous pouvons maintenant écrire un analyseur qui prend un caractère spécifique au début de la ligne.  Pour ce faire, utilisez le <code>predP</code> juste écrit et passez-le comme argument une fonction qui compare son argument avec le caractère dont nous avons besoin: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">charP</span></span> :: <span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> charP char = predP (\c -&gt; c == char)</code> </pre> <br><p>  Le cas le plus simple suivant: un analyseur qui accepte uniquement une certaine chaîne dans son ensemble.  <code>stringP</code> .  La fonction à l'intérieur de l'analyseur compare la ligne d'entrée avec celle souhaitée et, si les lignes sont égales, renvoie une liste d'un élément: une paire de lignes vides (il ne reste plus rien à l'entrée) et l'original.  Sinon, l'analyse a échoué et une liste vide de résultats est renvoyée. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">stringP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> stringP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs' | s == s' = [(<span class="hljs-string"><span class="hljs-string">""</span></span>, s)] | otherwise = []</code> </pre> <br><p>  Très souvent, vous devez ignorer les caractères qui ont une certaine propriété pendant qu'ils vont au début de la ligne (par exemple, les espaces blancs).  De plus, le résultat de l'analyse n'est pas important pour nous et ne sera pas utile à l'avenir.  Nous écrivons une fonction de <code>skip</code> qui saute les caractères initiaux de la chaîne tandis que la vraie valeur du prédicat est préservée.  Comme résultat d'analyse, nous utilisons un tuple vide. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skip</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skip p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(dropWhile ps, ())])</code> </pre> <br><p>  Les deux analyseurs suivants sont très similaires l'un à l'autre.  Les deux vérifient le préfixe de la ligne d'entrée, seul le premier en cas de succès renvoie ce préfixe et le second renvoie un tuple vide, c'est-à-dire  vous permet de sauter une ligne arbitraire au début de l'entrée.  L'implémentation utilise la fonction <code>isPrefixOf</code> définie dans le module <code>Data.List</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">prefixP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> prefixP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, s)] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> [] skipString :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, ())] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> []</code> </pre> <br><p>  Un peu plus tard, nous envisagerons une implémentation plus simple de cette dernière fonction et nous débarrasserons de la duplication de code. </p><br><h2 id="parser-kak-funktor">  Analyseur en tant que foncteur </h2><br><p>  Nous pouvons distinguer toute une classe de types de conteneurs pour lesquels les conditions suivantes sont vraies: si vous savez comment convertir des objets à l'intérieur d'un conteneur, vous pouvez convertir les conteneurs eux-mêmes.  L'exemple le plus simple est une liste en tant que conteneur et une fonction de <code>map</code> , qui est disponible dans presque toutes les langues de haut niveau.  En effet, vous pouvez parcourir tous les éléments d'une liste de type <code>[a]</code> , appliquer <code>a -&gt; b</code> à chacun, et obtenir une liste de type <code>[b]</code> . </p><br><p>  Cette classe de type s'appelle <code>Functor</code> ; la classe a une méthode <code>fmap</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  Supposons que nous savons déjà comment analyser des chaînes en objets d'un certain type <code>a</code> et, en outre, nous savons comment convertir des objets de type <code>a</code> en objets de type <code>b</code> .  Est-il possible de dire qu'il existe alors un analyseur pour les objets de type <code>b</code> ? </p><br><p>  S'il est exprimé sous la forme d'une fonction, il aura alors le type suivant: </p><br><pre> <code class="haskell hljs">(a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  Ce type coïncide avec le type de la fonction <code>fmap</code> , essayons donc de faire de l'analyseur un foncteur.  Créons un analyseur de valeurs de type <code>b</code> partir de zéro, qui appellera d'abord le premier analyseur (nous en avons déjà un), puis appliquera la fonction aux résultats de son analyse. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b fmap f (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> p2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p2 :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] p2 s = convert (p1 s) convert :: [(<span class="hljs-type"><span class="hljs-type">String</span></span>, a)] -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] convert results = map (\(s, val) -&gt; (s, f val)) results</code> </pre> <br><p>  La fonction <code>fmap</code> a un synonyme d'infixe pratique: <code>fmap fx == f &lt;$&gt; x</code> . </p><br><p>  Si nous utilisons une fonction comme argument pour <code>fmap</code> qui remplace simplement son premier argument par une nouvelle valeur, nous obtenons une autre opération utile qui est déjà implémentée pour tous les foncteurs même en deux copies (elles ne diffèrent que dans l'ordre des arguments): </p><br><pre> <code class="plaintext hljs">(&lt;$) :: Functor f =&gt; a -&gt; fb -&gt; fa ($&gt;) :: Functor f =&gt; fa -&gt; b -&gt; fb</code> </pre> <br><p>  Vous vous souvenez de l'analyseur qui saute une ligne spécifique ( <code>skipString</code> )?  Vous pouvez maintenant l'implémenter comme suit: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skipString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = () &lt;$ prefixP s</code> </pre> <br><h2 id="kombinacii-parserov">  Combinaisons d'analyseurs </h2><br><p>  Dans Haskell, toutes les fonctions sont curry par défaut et sont partiellement utilisables.  Cela signifie qu'une fonction de <code>n</code> arguments est en fait une fonction d'un argument, renvoyant une fonction de <code>n-1</code> arguments: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">cons</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons = (:) cons1 :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons1 = cons <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">--  cons  </span></span></code> </pre> <br><p>  Nous appliquons une fonction de trois arguments à une valeur à l'intérieur de l'analyseur en utilisant <code>fmap</code> .  Les types seront les suivants: </p><br><pre> <code class="plaintext hljs">f :: c -&gt; a -&gt; b p :: Parser c (fmap fp) :: Parser (a -&gt; b)</code> </pre> <br><p>  L'analyseur de fonction s'est avéré?!  Bien sûr, une situation est possible lorsque la représentation de la fonction est vraiment dans la ligne d'entrée, mais je voudrais pouvoir utiliser cette fonction, ou plutôt combiner les <code>Parser (a -&gt; b)</code> et <code>Parser a</code> pour obtenir l' <code>Parser b</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  Le type de cette fonction est très similaire au type <code>fmap</code> , seule la fonction elle-même qui doit être appliquée est également dans le conteneur.  Cela donne une compréhension intuitive de ce à quoi devrait ressembler l'implémentation de la fonction <code>applyP</code> : récupérer la fonction à partir du conteneur (à la suite de l'application du premier analyseur), obtenir les valeurs auxquelles la fonction doit s'appliquer (résultat de l'application du deuxième analyseur), et "empaqueter" les valeurs converties à l'aide de cette fonction. dans le conteneur (créer un nouvel analyseur).  Dans l'implémentation, nous utiliserons la compréhension de liste: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b applyP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs = [ (sx, fx) | (sf, f) &lt;- p1 s, <span class="hljs-comment"><span class="hljs-comment">-- p1     (sx, x) &lt;- p2 sf] -- p2   ,    </span></span></code> </pre> <br><p>  Il existe une classe <code>Applicative</code> qui a une méthode avec le même prototype.  La deuxième méthode de la classe est appelée <code>pure</code> et est utilisée pour «envelopper» ou «soulever» ( <em>soulever</em> ) une valeur, y compris une valeur fonctionnelle.  Dans le cas de l'implémentation de l'analyseur, la fonction <code>pure</code> ajoute son argument au résultat de l'analyseur, sans changer la chaîne d'entrée. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pure :: a -&gt; fa (&lt;*&gt;) :: f (a -&gt; b) -&gt; fa -&gt; fb <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Applicative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> pure x = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(s, x)]) pf &lt;*&gt; px = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [ (sx, fx) | (sf, f) &lt;- unParser pf $ s, (sx, x) &lt;- unParser px $ sf])</code> </pre> <br><p>  La fonction <code>applyP</code> est le <code>&lt;*&gt;</code> de la classe <code>Applicative</code> .  Les types appartenant à cette classe sont appelés foncteurs applicatifs. </p><br><p>  Pour les foncteurs applicatifs, deux fonctions auxiliaires sont implémentées qui nous seront utiles: </p><br><pre> <code class="haskell hljs">(*&gt;) :: fa -&gt; fb -&gt; fb (&lt;*) :: fa -&gt; fb -&gt; fa</code> </pre> <br><p>  Ces fonctions effectuent deux actions consécutives et renvoient le résultat d'une seule d'entre elles.  Pour les analyseurs, ils peuvent être utilisés, par exemple, pour ignorer les espaces de tête avant d'analyser une partie d'une chaîne qui porte une charge sémantique. </p><br><p>  En combinant <code>&lt;$&gt;</code> et <code>&lt;*&gt;</code> , vous pouvez créer des conceptions très pratiques.  Considérez le type de données suivant: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStructType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStruct</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type1</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field2</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type2</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field3</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type3</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Le constructeur de valeurs <code>MyStruct</code> est également une fonction, dans ce cas, il est de type <code>Type1 -&gt; Type2 -&gt; Type3 -&gt; MyStructType</code> .  Vous pouvez travailler avec le constructeur comme avec n'importe quelle autre fonction.  Supposons que des analyseurs ont déjà été écrits pour les types de champs de structure: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parser1</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type1</span></span> parser2 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type2</span></span> parser3 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type3</span></span></code> </pre> <br><p>  En utilisant la fonction <code>fmap</code> , vous pouvez appliquer partiellement <code>MyStruct</code> au premier de ces analyseurs: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct'</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct' = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1</code> </pre> <br><p>  Essayons d'appliquer la fonction qui est maintenant "à l'intérieur" de l'analyseur.  Pour ce faire, vous devez déjà utiliser <code>&lt;*&gt;</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct''</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct'' = parserStruct' &lt;*&gt; parser2 parserStruct :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = parserStruct'' &lt;*&gt; parser3</code> </pre> <br><p>  En conséquence, nous avons obtenu un analyseur pour toute la structure (bien sûr, nous utilisons ici l'hypothèse que dans la ligne d'origine, les représentations de ses champs sont alignées).  La même chose peut être faite sur une seule ligne: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1 &lt;*&gt; parser2 &lt;*&gt; parser3</code> </pre> <br><p>  De telles constructions seront souvent rencontrées dans les cas d'utilisation. </p><br><p>  Supposons maintenant que nous essayons d'écrire un analyseur qui analyse des expressions arithmétiques simples dans lesquelles des entiers et des identificateurs peuvent être présents en tant qu'opérandes.  Créons pour eux un type d' <code>Operand</code> distinct: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operand</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IntOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IdentOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span></span></code> </pre> <br><p>  Si nous savons déjà comment analyser des entiers et des identifiants (par exemple, comme en C), alors nous avons besoin d' <em>un</em> analyseur pour les opérandes qui peuvent analyser l'un ou l'autre.  Cet analyseur est une alternative aux deux autres, nous avons donc besoin d'une fonction qui peut combiner des analyseurs afin que les résultats de leur travail soient combinés.  Le résultat de l'analyseur est une liste, et la combinaison des listes est leur concaténation.  Nous implémentons la fonction <code>altP</code> combinant deux analyseurs: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">altP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a altP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; p1 s ++ p2 s)</code> </pre> <br><p>  Ensuite, l'analyseur d'opérande peut être implémenté à l'aide de cette fonction (ici, on suppose que <code>parserInt</code> et <code>parserIdent</code> déjà décrits quelque part: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserOperand</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Operand</span></span> parserOperand = altP parserIntOp parserIdentOp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> parserIntOp = <span class="hljs-type"><span class="hljs-type">IntOp</span></span> &lt;$&gt; parserInt parserIdentOp = <span class="hljs-type"><span class="hljs-type">IdentOp</span></span> &lt;$&gt; parserIdent</code> </pre> <br><p>  Bien sûr, pour les alternatives, nous avons déjà trouvé une classe distincte, qui s'appelle <code>Alternative</code> .  Il a une autre méthode, <code>empty</code> , qui décrit l'élément neutre pour l'opération alternative.  Dans notre cas, c'est un analyseur qui n'analyse jamais rien, c'est-à-dire  renvoie toujours une liste de résultats vide.  Pour l'analyseur, l'implémentation des méthodes de la classe <code>Alternative</code> ressemble à ceci: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alternative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> empty :: fa (&lt;|&gt;) :: fa -&gt; fa -&gt; fa <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Alternative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> empty = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (const []) px &lt;|&gt; py = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; unParser px s ++ unParser py s)</code> </pre> <br><p>  L'opération <code>&lt;|&gt;</code> est la fonction <code>altP</code> uniquement en notation infixe, ce qui est plus pratique à utiliser en combinant plusieurs analyseurs dans une rangée. </p><br><p>  Pour tous les types de cette classe, deux fonctions sont implémentées, <code>some</code> et <code>many</code> type <code>fa -&gt; f [a]</code> .  Chacun d'eux peut s'exprimer à travers l'autre: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">some</span></span> v = (:) &lt;$&gt; v &lt;*&gt; many v many v = some v &lt;|&gt; pure []</code> </pre> <br><p>  En termes d'analyseurs, ces fonctions vous permettent d'analyser des séquences de données si vous savez comment analyser un seul élément de données.  Dans le cas de l'utilisation de <code>some</code> séquence doit être non vide. </p><br><h1 id="primer-ispolzovaniya">  Exemple d'utilisation </h1><br><p>  Nous sommes maintenant prêts à écrire votre propre analyseur, par exemple, pour des expressions arithmétiques simples avec la grammaire suivante: </p><br><pre> <code class="plaintext hljs"> expr ::= constExpr | binOpExpr | negExpr const ::= int int ::= digit{digit} digit ::= '0' | ... | '9' binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binOp ::= '+' | '*' negExpr ::= '-' expr</code> </pre> <br><p>  L'expression se compose de constantes entières, du moins unaire et de deux opérations binaires d'infixe: addition et multiplication.  Des crochets sont requis autour d'une expression avec une opération binaire, le symbole d'opération est séparé des opérandes par exactement un espace, les espaces de début et de fin ne sont pas autorisés. </p><br><p>  Exemples d'écriture d'expression correcte: </p><br><pre> <code class="plaintext hljs">"123" "-(10 + 42)" "(1 + ((2 + 3) * (4 + 5)))"</code> </pre> <br><p>  Exemples d'entrées incorrectes: </p><br><pre> <code class="plaintext hljs">" 666 " "2 + 3" "(10 * 10)"</code> </pre> <br><p>  Nous déclarons les types de données nécessaires (l'expression elle-même et l'opération binaire): </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConstExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinaryExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NegateExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mul</span></span></span></span></code> </pre> <br><p>  Vous pouvez commencer l'analyse!  L'expression elle-même se compose de trois alternatives.  Nous écrivons donc: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- expr ::= constExpr | binOpExpr | negExpr exprParser :: Parser Expr exprParser = constParser &lt;|&gt; binParser &lt;|&gt; negParser</span></span></code> </pre> <br><p>  Une constante est un entier positif.  Dans notre type de données, il est "encapsulé" dans le constructeur, nous ne pouvons donc pas utiliser directement l'analyseur pour un entier, mais nous pouvons utiliser <code>fmap</code> pour obtenir la valeur du type souhaité. </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- const ::= int constParser :: Parser Expr constParser = ConstExpr &lt;$&gt; intParser</span></span></code> </pre> <br><p>  Un entier, selon la grammaire, est représenté comme une séquence de nombres non vide.  Pour analyser un chiffre, nous utilisons la fonction auxiliaire <code>predP</code> et le prédicat <code>isDigit</code> du module <code>Data.Char</code> .  Maintenant, pour construire un analyseur pour analyser une séquence de nombres, nous utilisons la fonction <code>some</code> (pas <code>many</code> , car il doit y avoir au moins un chiffre).  Le résultat d'un tel analyseur renvoie une liste de toutes les options d'analyse possibles, en commençant par l'enregistrement le plus long.  Par exemple, si la chaîne d'entrée est «123ab», la liste des résultats sera la suivante: <code>[("ab", "123"), ("3ab", "12"), ("23ab", "1")]</code> .  Nous devons analyser la plus longue séquence de chiffres et la convertir en type <code>Int</code> .  La mise en œuvre entière est la suivante: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- int ::= digit{digit} -- digit ::= '0' | ... | '9' intParser :: Parser Int intParser = Parser $ \s -&gt; let res = unParser (some digitParser) s in case res of [] -&gt; [] ((rest, i) : xs) -&gt; [(rest, read i)] where digitParser = predP isDigit</span></span></code> </pre> <br><p>  La prochaine façon d'écrire une expression consiste à utiliser une opération binaire.  Selon la grammaire, la parenthèse ouvrante doit d'abord comprendre la parenthèse ouvrante, le premier opérande, l'espace, le symbole d'opération, un autre espace, le deuxième opérande et la parenthèse fermante.  Pour analyser des caractères individuels (crochets et espaces), nous utilisons la fonction <code>charP</code> .  Les opérandes sont des expressions, et il existe déjà un analyseur ( <code>exprParser</code> ) pour les analyser.  Pour analyser le symbole d'opération binaire, nous décrivons l'analyseur auxiliaire juste en dessous.  Il reste à combiner parfaitement cet ensemble d'analyseurs.  Il devrait y avoir des crochets au début et à la fin de l'expression: vous devez vérifier cela, mais jetez le résultat lui-même.  Pour ce faire, utilisez <code>*&gt;</code> et <code>&lt;*</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">binParser</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Expr</span></span> binParser = charP '(' *&gt; ??? &lt;* charP ')'</code> </pre> <br><p>  Entre ces analyseurs pour les parenthèses, une expression doit être construite à l'aide du constructeur <code>BinaryExpr</code> et des analyseurs pour l'expression et l'opération.  N'oubliez pas les espaces autour du symbole d'opération, en utilisant la même méthode que pour les crochets.  Cette partie est la suivante: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">BinaryExpr</span></span> &lt;$&gt; exprParser <span class="hljs-comment"><span class="hljs-comment">--   &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') -- ,   &lt;*&gt; exprParser --  </span></span></code> </pre> <br><p>  Nous substituons cette expression au lieu de points d'interrogation: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binParser :: Parser Expr binParser = charP '(' *&gt; (BinaryExpr &lt;$&gt; exprParser &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') &lt;*&gt; exprParser ) &lt;* charP ')'</span></span></code> </pre> <br><p>  Une opération binaire est soit un caractère <code>+</code> qui analyse la valeur <code>Add</code> , soit <code>*</code> qui analyse le <code>Mul</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOp ::= '+' | '*' binOpParser :: Parser Operator binOpParser = plusParser &lt;|&gt; multParser where plusParser = charP '+' $&gt; Add multParser = charP '*' $&gt; Mul</span></span></code> </pre> <br><p>  Reste la partie la plus simple de la grammaire, la négation de l'expression.  Avec un symbole <code>-</code> faisons la même chose qu'avec les crochets et les espaces.  Ensuite, appliquez le constructeur <code>NegateExpr</code> au résultat de l'analyse récursive: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- negExpr ::= '-' expr negParser = charP '-' *&gt; (NegateExpr &lt;$&gt; exprParser)</span></span></code> </pre> <br><p>  Ainsi, toutes les parties de l'analyseur sont implémentées.  Le code ressemble beaucoup à une grammaire et coïncide complètement avec lui dans sa structure. </p><br><p>  Le code source est disponible sur GitLab: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://gitlab.com/fierce-katie/applicative-parsers-demo</a> . </p><br><p>  Là, il est plus facile d'évaluer son volume et son degré d'expressivité, car il y a beaucoup moins de commentaires.  Vous pouvez compiler le projet avec l'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stack</a> et exécuter l'interpréteur primitif à l'aide de l'analyseur que nous avons écrit: </p><br><pre> <code class="plaintext hljs">$ stack build $ stack exec demo-parser</code> </pre> <br><p>  Pour ceux qui veulent pratiquer davantage par eux-mêmes, je peux conseiller ce qui suit: </p><br><ul><li>  La grammaire peut être améliorée de toutes les manières, par exemple, pour autoriser les espaces de début et de fin, ajouter de nouvelles opérations, etc. </li><li>  L'analyseur traduit la chaîne en représentation interne de l'expression.  Cette expression peut être calculée et l'interpréteur converti de sorte qu'il n'imprime pas le résultat de l'analyse, mais le résultat du calcul. </li><li>  Explorez les possibilités des <code>attoparsec</code> <code>parsec</code> , <code>attoparsec</code> , <code>applicative-parsec</code> et <code>optparse-applicative</code> et essayez de les utiliser. </li></ul><br><p>  Merci de votre attention! </p><br><h1 id="poleznye-materialy">  Matériaux utiles </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apprenez Haskell en Y minutes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Denis Shevchenko.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"A propos d'Haskell en tant qu'être humain"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bibliothèque Parsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bibliothèque Attoparsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bibliothèque applicative-parsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bibliothèque applicative Optparse</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436234/">https://habr.com/ru/post/fr436234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436224/index.html">Nous écrivons notre langage de programmation, partie 4: Représentation des structures et des classes, génération d'allocateurs</a></li>
<li><a href="../fr436226/index.html">Guide et aide-mémoire pour Wireshark</a></li>
<li><a href="../fr436228/index.html">Développement d'une équipe pour interroger les données de la base de données</a></li>
<li><a href="../fr436230/index.html">Comment prendre le contrôle de votre infrastructure réseau. Chapitre Trois Sécurité du réseau. Deuxième partie</a></li>
<li><a href="../fr436232/index.html">Stratégie de télépathie</a></li>
<li><a href="../fr436236/index.html">Nous utilisons la science des données pour déterminer le cycle de vie d'un client</a></li>
<li><a href="../fr436238/index.html">Authentification dans Kubernetes avec GitHub OAuth et Dex</a></li>
<li><a href="../fr436240/index.html">Automation VS Chaos</a></li>
<li><a href="../fr436242/index.html">YOLO et autres méthodologies lâches</a></li>
<li><a href="../fr436244/index.html">Le nouveau cerveau du professeur Lawrence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>