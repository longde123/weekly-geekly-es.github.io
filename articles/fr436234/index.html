<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ìÇÔ∏è üëãüèº üåº Analyseurs applicatifs Haskell ü§∑üèæ üßöüèø üë©üèø‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La motivation 


 Lorsque j'ai commenc√© √† apprendre Haskell, j'√©tais tr√®s ennuy√© par l'utilisation g√©n√©ralis√©e d'abstractions complexes au lieu de sol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyseurs applicatifs Haskell</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436234/"><p><img src="https://habrastorage.org/webt/tq/9u/iw/tq9uiw8d_nbb1bbwrfdg1euyvci.png"></p><br><h1 id="motivaciya">  La motivation </h1><br><p>  Lorsque j'ai commenc√© √† apprendre Haskell, j'√©tais tr√®s ennuy√© par l'utilisation g√©n√©ralis√©e d'abstractions complexes au lieu de solutions sp√©cifiques.  Il m'a sembl√© qu'il vaut bien mieux de toujours suivre le principe KISS et d'√©crire des bicyclettes en utilisant des constructions de langage √©l√©mentaire que de comprendre toutes ces classes de types afin d'√©crire une construction soi-disant pratique quelque part. </p><br><p>  Je n'avais pas un bon exemple o√π les efforts consacr√©s au d√©veloppement du "mat√©riel" porteraient leurs fruits.  Pour moi, l'un des exemples les plus r√©ussis √©tait les analyseurs.  Maintenant, j'en parle souvent quand ils me demandent quelles t√¢ches courantes vous pouvez magnifiquement utiliser Haskell. </p><br><p> Je veux proposer aux d√©butants de suivre cette voie et de cr√©er une petite base de fonctions √† partir de z√©ro pour une impl√©mentation pratique des analyseurs, puis de l'utiliser pour √©crire leur propre analyseur, dont le code r√©p√©tera litt√©ralement la grammaire utilis√©e pour l'analyse. </p><br><p>  J'esp√®re que cela aide quelqu'un √† surmonter la peur des abstractions et √† lui apprendre √† les utiliser <em>correctement</em> (oui, je pense toujours qu'il est parfois plus efficace d'√©crire un v√©lo). </p><a name="habracut"></a><br><p>  Je n'ai aucun but et d√©sir de faire un cours Haskell √† partir d'un article, donc je suppose que le lecteur est familier avec la syntaxe et les programmes simples d√©velopp√©s ind√©pendamment.  Au cas o√π, je parlerai bri√®vement des classes de types avant de passer √† la description de l'impl√©mentation. </p><br><p>  Pour ceux qui n'ont jamais √©crit √† Haskell, mais qui veulent comprendre ce qui se passe ici, je vous recommande de consulter d'abord la page correspondante sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Learn X dans Y minutes</a> .  En tant qu'excellent livre en russe pour les d√©butants, je conseille <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"A propos d'Haskell en tant</a> qu'√™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">humain" de</a> Denis Shevchenko. </p><br><p>  J'essaierai d'utiliser les constructions de langage les plus simples que les d√©butants peuvent comprendre.  √Ä la fin de l'article, un lien est donn√© au r√©f√©rentiel source, o√π dans certaines parties du code une entr√©e plus pratique et plus courte est utilis√©e, ce qui peut √™tre moins clair √† premi√®re vue. </p><br><p>  Et oui, messieurs Haskellistes, beaucoup de choses sont expliqu√©es tr√®s simplement et maladroitement, pour des cas sp√©ciaux, pas tr√®s abstraitement, sans utiliser des termes de la th√©orie des cat√©gories et d'autres mots effrayants.  Je suis heureux que vous les connaissiez et bien s√ªr, ils les ma√Ætrisent facilement.  Je les connais aussi, mais je ne pense pas qu'il soit n√©cessaire de vider une telle quantit√© d'informations dans ce contexte sur des lecteurs non pr√©par√©s. </p><br><h1 id="klassy-tipov">  Classes de type </h1><br><p>  Les classes de type Haskell n'ont rien √† voir avec les classes en C ++ et autres langages orient√©s objet.  Si nous √©tablissons une analogie avec la POO, les classes de types ressemblent davantage √† une surcharge de m√©thodes et de fonctions. </p><br><p> Les classes d√©terminent quelles actions peuvent √™tre effectu√©es avec des objets des types qui composent la classe.  Par exemple, tous les nombres peuvent √™tre compar√©s pour l'√©galit√©, mais tout peut √™tre ordonn√© √† l'exception des nombres complexes, et en g√©n√©ral, les fonctions ne peuvent pas du tout √™tre compar√©es.  La classe de types qui peut √™tre compar√©e est appel√©e <code>Eq</code> , ordonn√©e - <code>Ord</code> (les types n'ont pas besoin d'√™tre num√©riques).  Ce qui peut √™tre imprim√© en traduisant en cha√Æne appartient √† la classe <code>Show</code> , il a la classe <code>Read</code> "oppos√©e", qui d√©termine comment convertir les cha√Ænes en objets du type souhait√©. </p><br><p>  Pour un ensemble de classes de type standard (telles que <code>Eq</code> , <code>Show</code> , <code>Read</code> ...), vous pouvez demander au compilateur d'impl√©menter la fonctionnalit√© souhait√©e de mani√®re standard, en utilisant le mot cl√© <code>deriving</code> apr√®s avoir d√©termin√© le type: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Vous pouvez d√©finir vos propres classes de types: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint :: a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre> <br><p>  Ici, <code>PrettyPrint</code> est le nom de la classe, <code>a</code> est une variable de type.  Le mot-cl√© <code>where</code> est suivi d'une liste des m√©thodes dites de classe, c'est-√†-dire  fonctions qui peuvent √™tre appliqu√©es aux objets de type de cette classe. </p><br><p>  Afin d'indiquer l'appartenance d'un type de donn√©es √† une classe, la construction suivante est utilis√©e: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint (<span class="hljs-type"><span class="hljs-type">Point</span></span> xy) = <span class="hljs-string"><span class="hljs-string">"("</span></span> ++ show x ++ <span class="hljs-string"><span class="hljs-string">", "</span></span> ++ show y ++ <span class="hljs-string"><span class="hljs-string">")"</span></span></code> </pre> <br><p>  Le langage vous permet de sp√©cifier des restrictions sur les classes de type auxquelles les arguments de fonction doivent se rapporter: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">showVsPretty</span></span> :: (<span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> a) =&gt; a -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>) showVsPretty x = (show x, pPrint x)</code> </pre> <br><p>  Pour chaque appel de fonction, le compilateur v√©rifie si ces exigences de type sont remplies et, en cas d'√©chec, affiche une erreur (cela se produit bien s√ªr au stade de la compilation). </p><br><pre> <code class="haskell hljs">&gt;&gt;&gt; showVsPretty (<span class="hljs-type"><span class="hljs-type">Point</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-string"><span class="hljs-string">"Point {xCoord = 2.0, yCoord = 3.0}"</span></span>,<span class="hljs-string"><span class="hljs-string">"(2.0, 3.0)"</span></span>) &gt;&gt;&gt; showVsPretty <span class="hljs-string"><span class="hljs-string">"str"</span></span> error: <span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> for (<span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> [<span class="hljs-type"><span class="hljs-type">Char</span></span>]) arising from a use <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> 'showVsPretty'</code> </pre> <br><h1 id="realizaciya">  Impl√©mentation </h1><br><p>  L'analyseur re√ßoit une cha√Æne d'entr√©e qu'il doit analyser selon des r√®gles pr√©d√©finies et obtenir la valeur du type dont nous avons besoin (par exemple, un entier).  Dans ce cas, la ligne d'entr√©e peut ne pas se terminer et le reste servira d'entr√©e pour une analyse plus approfondie.  De plus, notre analyseur sera g√©n√©ralement non d√©terministe, c'est-√†-dire  renverra plusieurs r√©sultats d'analyse possibles sous forme de liste. </p><br><p>  Un tuple de deux √©l√©ments <code>(String, a)</code> convient pour d√©crire un r√©sultat de l'op√©ration de l'analyseur, o√π <code>a</code> est une variable de type qui peut d√©signer n'importe quel type d'utilisateur. </p><br><p>  Puisque l'analyseur analyse la cha√Æne selon certaines r√®gles, nous la d√©crivons comme une fonction qui prend une cha√Æne en entr√©e et renvoie une liste de r√©sultats: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unParser</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; [(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)] }</span></span></code> </pre> <br><p>  Nous consid√©rerons que l'analyse est r√©ussie si la liste des r√©sultats se compose d'un √©l√©ment et que la cha√Æne d'entr√©e a √©t√© compl√®tement trait√©e.  Nous impl√©mentons une fonction d'assistance qui essaie d'analyser de mani√®re unique la cha√Æne enti√®re: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parseString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a parseString s (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (ps) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [(<span class="hljs-string"><span class="hljs-string">""</span></span>, val)] -&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> val _ -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre> <br><h2 id="prosteyshie-parsery">  Analyseurs simples </h2><br><p>  Nous impl√©mentons plusieurs analyseurs simples, qui seront ensuite utiles pour cr√©er des combinaisons plus complexes. </p><br><p>  Nous commen√ßons par analyser un seul caract√®re qui doit satisfaire un pr√©dicat.  Si la cha√Æne d'entr√©e est vide, le r√©sultat du travail est une liste vide.  Sinon, nous v√©rifions la valeur du pr√©dicat sur le premier caract√®re de la cha√Æne.  Si <code>True</code> renvoy√©, le r√©sultat de l'analyse est ce caract√®re;  renvoyez-le avec le reste de la cha√Æne.  Sinon, l'analyse √©choue √©galement. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">predP</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> predP p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f <span class="hljs-string"><span class="hljs-string">""</span></span> = [] f (c : cs) | pc = [(cs, c)] | otherwise = []</code> </pre> <br><p>  Nous pouvons maintenant √©crire un analyseur qui prend un caract√®re sp√©cifique au d√©but de la ligne.  Pour ce faire, utilisez le <code>predP</code> juste √©crit et passez-le comme argument une fonction qui compare son argument avec le caract√®re dont nous avons besoin: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">charP</span></span> :: <span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> charP char = predP (\c -&gt; c == char)</code> </pre> <br><p>  Le cas le plus simple suivant: un analyseur qui accepte uniquement une certaine cha√Æne dans son ensemble.  <code>stringP</code> .  La fonction √† l'int√©rieur de l'analyseur compare la ligne d'entr√©e avec celle souhait√©e et, si les lignes sont √©gales, renvoie une liste d'un √©l√©ment: une paire de lignes vides (il ne reste plus rien √† l'entr√©e) et l'original.  Sinon, l'analyse a √©chou√© et une liste vide de r√©sultats est renvoy√©e. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">stringP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> stringP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs' | s == s' = [(<span class="hljs-string"><span class="hljs-string">""</span></span>, s)] | otherwise = []</code> </pre> <br><p>  Tr√®s souvent, vous devez ignorer les caract√®res qui ont une certaine propri√©t√© pendant qu'ils vont au d√©but de la ligne (par exemple, les espaces blancs).  De plus, le r√©sultat de l'analyse n'est pas important pour nous et ne sera pas utile √† l'avenir.  Nous √©crivons une fonction de <code>skip</code> qui saute les caract√®res initiaux de la cha√Æne tandis que la vraie valeur du pr√©dicat est pr√©serv√©e.  Comme r√©sultat d'analyse, nous utilisons un tuple vide. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skip</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skip p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(dropWhile ps, ())])</code> </pre> <br><p>  Les deux analyseurs suivants sont tr√®s similaires l'un √† l'autre.  Les deux v√©rifient le pr√©fixe de la ligne d'entr√©e, seul le premier en cas de succ√®s renvoie ce pr√©fixe et le second renvoie un tuple vide, c'est-√†-dire  vous permet de sauter une ligne arbitraire au d√©but de l'entr√©e.  L'impl√©mentation utilise la fonction <code>isPrefixOf</code> d√©finie dans le module <code>Data.List</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">prefixP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> prefixP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, s)] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> [] skipString :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, ())] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> []</code> </pre> <br><p>  Un peu plus tard, nous envisagerons une impl√©mentation plus simple de cette derni√®re fonction et nous d√©barrasserons de la duplication de code. </p><br><h2 id="parser-kak-funktor">  Analyseur en tant que foncteur </h2><br><p>  Nous pouvons distinguer toute une classe de types de conteneurs pour lesquels les conditions suivantes sont vraies: si vous savez comment convertir des objets √† l'int√©rieur d'un conteneur, vous pouvez convertir les conteneurs eux-m√™mes.  L'exemple le plus simple est une liste en tant que conteneur et une fonction de <code>map</code> , qui est disponible dans presque toutes les langues de haut niveau.  En effet, vous pouvez parcourir tous les √©l√©ments d'une liste de type <code>[a]</code> , appliquer <code>a -&gt; b</code> √† chacun, et obtenir une liste de type <code>[b]</code> . </p><br><p>  Cette classe de type s'appelle <code>Functor</code> ; la classe a une m√©thode <code>fmap</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  Supposons que nous savons d√©j√† comment analyser des cha√Ænes en objets d'un certain type <code>a</code> et, en outre, nous savons comment convertir des objets de type <code>a</code> en objets de type <code>b</code> .  Est-il possible de dire qu'il existe alors un analyseur pour les objets de type <code>b</code> ? </p><br><p>  S'il est exprim√© sous la forme d'une fonction, il aura alors le type suivant: </p><br><pre> <code class="haskell hljs">(a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  Ce type co√Øncide avec le type de la fonction <code>fmap</code> , essayons donc de faire de l'analyseur un foncteur.  Cr√©ons un analyseur de valeurs de type <code>b</code> partir de z√©ro, qui appellera d'abord le premier analyseur (nous en avons d√©j√† un), puis appliquera la fonction aux r√©sultats de son analyse. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b fmap f (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> p2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p2 :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] p2 s = convert (p1 s) convert :: [(<span class="hljs-type"><span class="hljs-type">String</span></span>, a)] -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] convert results = map (\(s, val) -&gt; (s, f val)) results</code> </pre> <br><p>  La fonction <code>fmap</code> a un synonyme d'infixe pratique: <code>fmap fx == f &lt;$&gt; x</code> . </p><br><p>  Si nous utilisons une fonction comme argument pour <code>fmap</code> qui remplace simplement son premier argument par une nouvelle valeur, nous obtenons une autre op√©ration utile qui est d√©j√† impl√©ment√©e pour tous les foncteurs m√™me en deux copies (elles ne diff√®rent que dans l'ordre des arguments): </p><br><pre> <code class="plaintext hljs">(&lt;$) :: Functor f =&gt; a -&gt; fb -&gt; fa ($&gt;) :: Functor f =&gt; fa -&gt; b -&gt; fb</code> </pre> <br><p>  Vous vous souvenez de l'analyseur qui saute une ligne sp√©cifique ( <code>skipString</code> )?  Vous pouvez maintenant l'impl√©menter comme suit: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skipString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = () &lt;$ prefixP s</code> </pre> <br><h2 id="kombinacii-parserov">  Combinaisons d'analyseurs </h2><br><p>  Dans Haskell, toutes les fonctions sont curry par d√©faut et sont partiellement utilisables.  Cela signifie qu'une fonction de <code>n</code> arguments est en fait une fonction d'un argument, renvoyant une fonction de <code>n-1</code> arguments: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">cons</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons = (:) cons1 :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons1 = cons <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">--  cons  </span></span></code> </pre> <br><p>  Nous appliquons une fonction de trois arguments √† une valeur √† l'int√©rieur de l'analyseur en utilisant <code>fmap</code> .  Les types seront les suivants: </p><br><pre> <code class="plaintext hljs">f :: c -&gt; a -&gt; b p :: Parser c (fmap fp) :: Parser (a -&gt; b)</code> </pre> <br><p>  L'analyseur de fonction s'est av√©r√©?!  Bien s√ªr, une situation est possible lorsque la repr√©sentation de la fonction est vraiment dans la ligne d'entr√©e, mais je voudrais pouvoir utiliser cette fonction, ou plut√¥t combiner les <code>Parser (a -&gt; b)</code> et <code>Parser a</code> pour obtenir l' <code>Parser b</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  Le type de cette fonction est tr√®s similaire au type <code>fmap</code> , seule la fonction elle-m√™me qui doit √™tre appliqu√©e est √©galement dans le conteneur.  Cela donne une compr√©hension intuitive de ce √† quoi devrait ressembler l'impl√©mentation de la fonction <code>applyP</code> : r√©cup√©rer la fonction √† partir du conteneur (√† la suite de l'application du premier analyseur), obtenir les valeurs auxquelles la fonction doit s'appliquer (r√©sultat de l'application du deuxi√®me analyseur), et "empaqueter" les valeurs converties √† l'aide de cette fonction. dans le conteneur (cr√©er un nouvel analyseur).  Dans l'impl√©mentation, nous utiliserons la compr√©hension de liste: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b applyP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs = [ (sx, fx) | (sf, f) &lt;- p1 s, <span class="hljs-comment"><span class="hljs-comment">-- p1     (sx, x) &lt;- p2 sf] -- p2   ,    </span></span></code> </pre> <br><p>  Il existe une classe <code>Applicative</code> qui a une m√©thode avec le m√™me prototype.  La deuxi√®me m√©thode de la classe est appel√©e <code>pure</code> et est utilis√©e pour ¬´envelopper¬ª ou ¬´soulever¬ª ( <em>soulever</em> ) une valeur, y compris une valeur fonctionnelle.  Dans le cas de l'impl√©mentation de l'analyseur, la fonction <code>pure</code> ajoute son argument au r√©sultat de l'analyseur, sans changer la cha√Æne d'entr√©e. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pure :: a -&gt; fa (&lt;*&gt;) :: f (a -&gt; b) -&gt; fa -&gt; fb <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Applicative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> pure x = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(s, x)]) pf &lt;*&gt; px = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [ (sx, fx) | (sf, f) &lt;- unParser pf $ s, (sx, x) &lt;- unParser px $ sf])</code> </pre> <br><p>  La fonction <code>applyP</code> est le <code>&lt;*&gt;</code> de la classe <code>Applicative</code> .  Les types appartenant √† cette classe sont appel√©s foncteurs applicatifs. </p><br><p>  Pour les foncteurs applicatifs, deux fonctions auxiliaires sont impl√©ment√©es qui nous seront utiles: </p><br><pre> <code class="haskell hljs">(*&gt;) :: fa -&gt; fb -&gt; fb (&lt;*) :: fa -&gt; fb -&gt; fa</code> </pre> <br><p>  Ces fonctions effectuent deux actions cons√©cutives et renvoient le r√©sultat d'une seule d'entre elles.  Pour les analyseurs, ils peuvent √™tre utilis√©s, par exemple, pour ignorer les espaces de t√™te avant d'analyser une partie d'une cha√Æne qui porte une charge s√©mantique. </p><br><p>  En combinant <code>&lt;$&gt;</code> et <code>&lt;*&gt;</code> , vous pouvez cr√©er des conceptions tr√®s pratiques.  Consid√©rez le type de donn√©es suivant: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStructType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStruct</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type1</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field2</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type2</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field3</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type3</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Le constructeur de valeurs <code>MyStruct</code> est √©galement une fonction, dans ce cas, il est de type <code>Type1 -&gt; Type2 -&gt; Type3 -&gt; MyStructType</code> .  Vous pouvez travailler avec le constructeur comme avec n'importe quelle autre fonction.  Supposons que des analyseurs ont d√©j√† √©t√© √©crits pour les types de champs de structure: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parser1</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type1</span></span> parser2 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type2</span></span> parser3 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type3</span></span></code> </pre> <br><p>  En utilisant la fonction <code>fmap</code> , vous pouvez appliquer partiellement <code>MyStruct</code> au premier de ces analyseurs: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct'</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct' = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1</code> </pre> <br><p>  Essayons d'appliquer la fonction qui est maintenant "√† l'int√©rieur" de l'analyseur.  Pour ce faire, vous devez d√©j√† utiliser <code>&lt;*&gt;</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct''</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct'' = parserStruct' &lt;*&gt; parser2 parserStruct :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = parserStruct'' &lt;*&gt; parser3</code> </pre> <br><p>  En cons√©quence, nous avons obtenu un analyseur pour toute la structure (bien s√ªr, nous utilisons ici l'hypoth√®se que dans la ligne d'origine, les repr√©sentations de ses champs sont align√©es).  La m√™me chose peut √™tre faite sur une seule ligne: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1 &lt;*&gt; parser2 &lt;*&gt; parser3</code> </pre> <br><p>  De telles constructions seront souvent rencontr√©es dans les cas d'utilisation. </p><br><p>  Supposons maintenant que nous essayons d'√©crire un analyseur qui analyse des expressions arithm√©tiques simples dans lesquelles des entiers et des identificateurs peuvent √™tre pr√©sents en tant qu'op√©randes.  Cr√©ons pour eux un type d' <code>Operand</code> distinct: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operand</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IntOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IdentOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span></span></code> </pre> <br><p>  Si nous savons d√©j√† comment analyser des entiers et des identifiants (par exemple, comme en C), alors nous avons besoin d' <em>un</em> analyseur pour les op√©randes qui peuvent analyser l'un ou l'autre.  Cet analyseur est une alternative aux deux autres, nous avons donc besoin d'une fonction qui peut combiner des analyseurs afin que les r√©sultats de leur travail soient combin√©s.  Le r√©sultat de l'analyseur est une liste, et la combinaison des listes est leur concat√©nation.  Nous impl√©mentons la fonction <code>altP</code> combinant deux analyseurs: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">altP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a altP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; p1 s ++ p2 s)</code> </pre> <br><p>  Ensuite, l'analyseur d'op√©rande peut √™tre impl√©ment√© √† l'aide de cette fonction (ici, on suppose que <code>parserInt</code> et <code>parserIdent</code> d√©j√† d√©crits quelque part: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserOperand</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Operand</span></span> parserOperand = altP parserIntOp parserIdentOp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> parserIntOp = <span class="hljs-type"><span class="hljs-type">IntOp</span></span> &lt;$&gt; parserInt parserIdentOp = <span class="hljs-type"><span class="hljs-type">IdentOp</span></span> &lt;$&gt; parserIdent</code> </pre> <br><p>  Bien s√ªr, pour les alternatives, nous avons d√©j√† trouv√© une classe distincte, qui s'appelle <code>Alternative</code> .  Il a une autre m√©thode, <code>empty</code> , qui d√©crit l'√©l√©ment neutre pour l'op√©ration alternative.  Dans notre cas, c'est un analyseur qui n'analyse jamais rien, c'est-√†-dire  renvoie toujours une liste de r√©sultats vide.  Pour l'analyseur, l'impl√©mentation des m√©thodes de la classe <code>Alternative</code> ressemble √† ceci: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alternative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> empty :: fa (&lt;|&gt;) :: fa -&gt; fa -&gt; fa <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Alternative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> empty = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (const []) px &lt;|&gt; py = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; unParser px s ++ unParser py s)</code> </pre> <br><p>  L'op√©ration <code>&lt;|&gt;</code> est la fonction <code>altP</code> uniquement en notation infixe, ce qui est plus pratique √† utiliser en combinant plusieurs analyseurs dans une rang√©e. </p><br><p>  Pour tous les types de cette classe, deux fonctions sont impl√©ment√©es, <code>some</code> et <code>many</code> type <code>fa -&gt; f [a]</code> .  Chacun d'eux peut s'exprimer √† travers l'autre: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">some</span></span> v = (:) &lt;$&gt; v &lt;*&gt; many v many v = some v &lt;|&gt; pure []</code> </pre> <br><p>  En termes d'analyseurs, ces fonctions vous permettent d'analyser des s√©quences de donn√©es si vous savez comment analyser un seul √©l√©ment de donn√©es.  Dans le cas de l'utilisation de <code>some</code> s√©quence doit √™tre non vide. </p><br><h1 id="primer-ispolzovaniya">  Exemple d'utilisation </h1><br><p>  Nous sommes maintenant pr√™ts √† √©crire votre propre analyseur, par exemple, pour des expressions arithm√©tiques simples avec la grammaire suivante: </p><br><pre> <code class="plaintext hljs"> expr ::= constExpr | binOpExpr | negExpr const ::= int int ::= digit{digit} digit ::= '0' | ... | '9' binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binOp ::= '+' | '*' negExpr ::= '-' expr</code> </pre> <br><p>  L'expression se compose de constantes enti√®res, du moins unaire et de deux op√©rations binaires d'infixe: addition et multiplication.  Des crochets sont requis autour d'une expression avec une op√©ration binaire, le symbole d'op√©ration est s√©par√© des op√©randes par exactement un espace, les espaces de d√©but et de fin ne sont pas autoris√©s. </p><br><p>  Exemples d'√©criture d'expression correcte: </p><br><pre> <code class="plaintext hljs">"123" "-(10 + 42)" "(1 + ((2 + 3) * (4 + 5)))"</code> </pre> <br><p>  Exemples d'entr√©es incorrectes: </p><br><pre> <code class="plaintext hljs">" 666 " "2 + 3" "(10 * 10)"</code> </pre> <br><p>  Nous d√©clarons les types de donn√©es n√©cessaires (l'expression elle-m√™me et l'op√©ration binaire): </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConstExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinaryExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NegateExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mul</span></span></span></span></code> </pre> <br><p>  Vous pouvez commencer l'analyse!  L'expression elle-m√™me se compose de trois alternatives.  Nous √©crivons donc: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- expr ::= constExpr | binOpExpr | negExpr exprParser :: Parser Expr exprParser = constParser &lt;|&gt; binParser &lt;|&gt; negParser</span></span></code> </pre> <br><p>  Une constante est un entier positif.  Dans notre type de donn√©es, il est "encapsul√©" dans le constructeur, nous ne pouvons donc pas utiliser directement l'analyseur pour un entier, mais nous pouvons utiliser <code>fmap</code> pour obtenir la valeur du type souhait√©. </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- const ::= int constParser :: Parser Expr constParser = ConstExpr &lt;$&gt; intParser</span></span></code> </pre> <br><p>  Un entier, selon la grammaire, est repr√©sent√© comme une s√©quence de nombres non vide.  Pour analyser un chiffre, nous utilisons la fonction auxiliaire <code>predP</code> et le pr√©dicat <code>isDigit</code> du module <code>Data.Char</code> .  Maintenant, pour construire un analyseur pour analyser une s√©quence de nombres, nous utilisons la fonction <code>some</code> (pas <code>many</code> , car il doit y avoir au moins un chiffre).  Le r√©sultat d'un tel analyseur renvoie une liste de toutes les options d'analyse possibles, en commen√ßant par l'enregistrement le plus long.  Par exemple, si la cha√Æne d'entr√©e est ¬´123ab¬ª, la liste des r√©sultats sera la suivante: <code>[("ab", "123"), ("3ab", "12"), ("23ab", "1")]</code> .  Nous devons analyser la plus longue s√©quence de chiffres et la convertir en type <code>Int</code> .  La mise en ≈ìuvre enti√®re est la suivante: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- int ::= digit{digit} -- digit ::= '0' | ... | '9' intParser :: Parser Int intParser = Parser $ \s -&gt; let res = unParser (some digitParser) s in case res of [] -&gt; [] ((rest, i) : xs) -&gt; [(rest, read i)] where digitParser = predP isDigit</span></span></code> </pre> <br><p>  La prochaine fa√ßon d'√©crire une expression consiste √† utiliser une op√©ration binaire.  Selon la grammaire, la parenth√®se ouvrante doit d'abord comprendre la parenth√®se ouvrante, le premier op√©rande, l'espace, le symbole d'op√©ration, un autre espace, le deuxi√®me op√©rande et la parenth√®se fermante.  Pour analyser des caract√®res individuels (crochets et espaces), nous utilisons la fonction <code>charP</code> .  Les op√©randes sont des expressions, et il existe d√©j√† un analyseur ( <code>exprParser</code> ) pour les analyser.  Pour analyser le symbole d'op√©ration binaire, nous d√©crivons l'analyseur auxiliaire juste en dessous.  Il reste √† combiner parfaitement cet ensemble d'analyseurs.  Il devrait y avoir des crochets au d√©but et √† la fin de l'expression: vous devez v√©rifier cela, mais jetez le r√©sultat lui-m√™me.  Pour ce faire, utilisez <code>*&gt;</code> et <code>&lt;*</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">binParser</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Expr</span></span> binParser = charP '(' *&gt; ??? &lt;* charP ')'</code> </pre> <br><p>  Entre ces analyseurs pour les parenth√®ses, une expression doit √™tre construite √† l'aide du constructeur <code>BinaryExpr</code> et des analyseurs pour l'expression et l'op√©ration.  N'oubliez pas les espaces autour du symbole d'op√©ration, en utilisant la m√™me m√©thode que pour les crochets.  Cette partie est la suivante: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">BinaryExpr</span></span> &lt;$&gt; exprParser <span class="hljs-comment"><span class="hljs-comment">--   &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') -- ,   &lt;*&gt; exprParser --  </span></span></code> </pre> <br><p>  Nous substituons cette expression au lieu de points d'interrogation: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binParser :: Parser Expr binParser = charP '(' *&gt; (BinaryExpr &lt;$&gt; exprParser &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') &lt;*&gt; exprParser ) &lt;* charP ')'</span></span></code> </pre> <br><p>  Une op√©ration binaire est soit un caract√®re <code>+</code> qui analyse la valeur <code>Add</code> , soit <code>*</code> qui analyse le <code>Mul</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOp ::= '+' | '*' binOpParser :: Parser Operator binOpParser = plusParser &lt;|&gt; multParser where plusParser = charP '+' $&gt; Add multParser = charP '*' $&gt; Mul</span></span></code> </pre> <br><p>  Reste la partie la plus simple de la grammaire, la n√©gation de l'expression.  Avec un symbole <code>-</code> faisons la m√™me chose qu'avec les crochets et les espaces.  Ensuite, appliquez le constructeur <code>NegateExpr</code> au r√©sultat de l'analyse r√©cursive: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- negExpr ::= '-' expr negParser = charP '-' *&gt; (NegateExpr &lt;$&gt; exprParser)</span></span></code> </pre> <br><p>  Ainsi, toutes les parties de l'analyseur sont impl√©ment√©es.  Le code ressemble beaucoup √† une grammaire et co√Øncide compl√®tement avec lui dans sa structure. </p><br><p>  Le code source est disponible sur GitLab: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://gitlab.com/fierce-katie/applicative-parsers-demo</a> . </p><br><p>  L√†, il est plus facile d'√©valuer son volume et son degr√© d'expressivit√©, car il y a beaucoup moins de commentaires.  Vous pouvez compiler le projet avec l'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stack</a> et ex√©cuter l'interpr√©teur primitif √† l'aide de l'analyseur que nous avons √©crit: </p><br><pre> <code class="plaintext hljs">$ stack build $ stack exec demo-parser</code> </pre> <br><p>  Pour ceux qui veulent pratiquer davantage par eux-m√™mes, je peux conseiller ce qui suit: </p><br><ul><li>  La grammaire peut √™tre am√©lior√©e de toutes les mani√®res, par exemple, pour autoriser les espaces de d√©but et de fin, ajouter de nouvelles op√©rations, etc. </li><li>  L'analyseur traduit la cha√Æne en repr√©sentation interne de l'expression.  Cette expression peut √™tre calcul√©e et l'interpr√©teur converti de sorte qu'il n'imprime pas le r√©sultat de l'analyse, mais le r√©sultat du calcul. </li><li>  Explorez les possibilit√©s des <code>attoparsec</code> <code>parsec</code> , <code>attoparsec</code> , <code>applicative-parsec</code> et <code>optparse-applicative</code> et essayez de les utiliser. </li></ul><br><p>  Merci de votre attention! </p><br><h1 id="poleznye-materialy">  Mat√©riaux utiles </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apprenez Haskell en Y minutes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Denis Shevchenko.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"A propos d'Haskell en tant qu'√™tre humain"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Biblioth√®que Parsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Biblioth√®que Attoparsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Biblioth√®que applicative-parsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Biblioth√®que applicative Optparse</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436234/">https://habr.com/ru/post/fr436234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436224/index.html">Nous √©crivons notre langage de programmation, partie 4: Repr√©sentation des structures et des classes, g√©n√©ration d'allocateurs</a></li>
<li><a href="../fr436226/index.html">Guide et aide-m√©moire pour Wireshark</a></li>
<li><a href="../fr436228/index.html">D√©veloppement d'une √©quipe pour interroger les donn√©es de la base de donn√©es</a></li>
<li><a href="../fr436230/index.html">Comment prendre le contr√¥le de votre infrastructure r√©seau. Chapitre Trois S√©curit√© du r√©seau. Deuxi√®me partie</a></li>
<li><a href="../fr436232/index.html">Strat√©gie de t√©l√©pathie</a></li>
<li><a href="../fr436236/index.html">Nous utilisons la science des donn√©es pour d√©terminer le cycle de vie d'un client</a></li>
<li><a href="../fr436238/index.html">Authentification dans Kubernetes avec GitHub OAuth et Dex</a></li>
<li><a href="../fr436240/index.html">Automation VS Chaos</a></li>
<li><a href="../fr436242/index.html">YOLO et autres m√©thodologies l√¢ches</a></li>
<li><a href="../fr436244/index.html">Le nouveau cerveau du professeur Lawrence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>