<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöò üëê üçô Generaci√≥n de se√±al PWM multifase en TMS320F28027 üôÜüèæ üöØ üßñüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√ârase una vez  en una lejana galaxia lejana  Escrib√≠ un breve art√≠culo sobre el controlador Piccolo especializado de Texas Instruments, que est√° dise√±...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generaci√≥n de se√±al PWM multifase en TMS320F28027</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457548/"><p>  √ârase una vez <del>  en una lejana galaxia lejana </del>  Escrib√≠ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">breve art√≠culo</a> sobre el controlador Piccolo especializado de Texas Instruments, que est√° dise√±ado para controlar convertidores de potencia y unidades el√©ctricas.  Estos controladores son herramientas de desarrollo muy poderosas en muchas tareas y quer√≠a escribir algo m√°s sobre ellos ... simple y √∫til. </p><br><p>  Recientemente, me intrig√≥ desarrollar un controlador para el control del motor y, en consecuencia, se form√≥ un tema para el art√≠culo: hoy hablar√© sobre el proceso de formaci√≥n de un PWM trif√°sico para el control del motor, as√≠ como explicar√© las diferencias beneficiosas entre TMS320F28 y otros controladores como STM32F334, STM32G484, XMC4200 y otros. </p><br><p>  Como soporte, usar√© el controlador en desarrollo, por desgracia, no puedo hablar sobre la parte de hierro en detalle.  Sin embargo, si digo que el controlador se basa en el paquete TMS320F28027 + DRV8353RSRGZT, entonces puede ver los datos del controlador y ver el concepto general de circuitos + hay una depuraci√≥n en esta piedra y el dise√±o de referencia est√° abierto. </p><br><p><img src="https://habrastorage.org/webt/bu/ps/ur/bupsur6y9nfobnpa53zqjrfodmo.jpeg" alt="Controlador BLDC"></p><br><p>  En principio, en el mismo tipo de circuito es posible controlar motores BLDC que "consumen" niveles de voltaje y trif√°sicos ordinarios, que ya desean una salida sinusoidal.  Mostrar√© ambas opciones, como  El camino hacia el seno reside en la formaci√≥n de niveles de voltaje. </p><br><p><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="Oscilograma n√∫mero 1"></p><a name="habracut"></a><br><h1 id="nemnogo-o-zheleze">  Un poco sobre hierro </h1><br><p>  La parte de potencia del controlador ideol√≥gicamente consiste en 3 convertidores de medio puente, probablemente todos los chastotniks y controladores para controlar los motores BLDC en todos los helic√≥pteros est√°n hechos de manera similar: </p><br><p><img src="https://habrastorage.org/webt/fm/kd/3t/fmkd3tequjgg3gapytg5bvupwfw.png" alt="Puente trif√°sico"></p><br><p>  Una diferencia: no tengo un rectificador de entrada, porque  El controlador est√° alimentado inicialmente por un voltaje constante.  La fuente de alimentaci√≥n en mi caso es un conjunto de bater√≠as de iones de litio en forma de celdas 18650. El controlador DRV8353RSRGZT usado puede controlar solo 3 medios puentes de potencia, tambi√©n en la versi√≥n usada de la piedra tambi√©n hay amplificadores operacionales incorporados para trabajar con derivaciones como sensores de corriente, incorporados dc / dc, que puede digerir hasta 70 ... 80V y todo esto est√° configurado de manera muy flexible a trav√©s de SPI.  Por ejemplo, es muy conveniente poder ajustar la corriente de pulso m√°xima del control del transistor. </p><br><p>  Tambi√©n en esta serie hay controladores con un conjunto diferente de funciones, por ejemplo, hay con control anal√≥gico, no SPI o sin CC / CC incorporado y sin amplificador operacional.  Por el precio no son muy diferentes y tom√© el m√°s "audaz" como probablemente ya entendiste.  Todo esto se ve muy hermoso, pero me acerqu√© fr√≠volamente al dise√±o del enlace del controlador y obtuve 2 problemas importantes.  De hecho, solo hay un problema: este es un fuerte sobrecalentamiento: </p><br><p><img src="https://habrastorage.org/webt/hh/ud/hh/hhudhh5jk3tpwowsivbvjjar66e.jpeg" alt="C√°mara termogr√°fica"></p><br><p>  Pero este problema fue causado por 2 razones.  En realidad, la esencia del problema es el sobrecalentamiento del propio controlador.  En el termograma, el controlador se carga con una corriente de 5A (para √©l est√° casi inactivo) y nada m√°s que el controlador y el MK se calientan un poco.  Los transistores ni siquiera son visibles, tienen una temperatura de PCB, a 5 A hay pocas p√©rdidas de calor. </p><br><ul><li>  <strong>Error no 1</strong> <br>  Un amigo m√≠o me pidi√≥ que, sinceramente, hubiera pensado en esto como un √∫ltimo recurso: dc / dc est√° integrado en el controlador, que recibe una entrada de 15 ... 50V y proporciona 3.3V para alimentar el MK, la l√≥gica, los comparadores y los amplificadores operacionales.  Parece que mis proyectos tienen microcircuitos LM5008 y LM5017 en forma de microcircuitos separados y reduje tranquilamente 60V a 3.3V sin un calentamiento notable a una corriente de 100-150 mA, pero todo result√≥ ser m√°s complicado: la eficiencia general del convertidor result√≥ ser de aproximadamente 65-70% a una corriente 300 mA!  El hecho es que el convertidor en s√≠ puede dar 3.3V, pero la eficiencia ser√° escasa, es √≥ptimo configurar el voltaje de salida 10-12-15V.  Cuando la salida era de 12V 100 mA, mi controlador dej√≥ de calentarse pr√°cticamente y la eficiencia alcanz√≥ un agradable 88%.  <strong>La soluci√≥n al problema</strong> es bajar la entrada de 15 ... 50V a 12V con el dc / dc incorporado, y luego bajarlo de 12V a 3.3V con un dc / dc externo ya barato. </li></ul><br><br><ul><li>  <strong>Error no 2</strong> <br>  El segundo error es m√°s obvio y lo primero que pequ√© en √©l como pude.  El hecho es que para los chips en el paquete QFN, el calor principal se elimina a trav√©s del "vientre", por lo general se asienta en el GND y, a trav√©s de varias v√≠as, se aferra al suelo y todo el calor va all√≠ con calma.  Inicialmente, no tom√© en cuenta la escasa eficiencia de la CC / CC incorporada con una gran diferencia de voltaje, por lo que no me molest√≥ que la ca√≠da t√©rmica ("vientre") se aferrara a un pol√≠gono GND continuo en la capa interna, en la capa externa no ten√≠a cobre debajo del vientre como un pol√≠gono GND  Como resultado, result√≥ que ~ 0.5 W de calor se libera en el chip, y se disipa en la capa interna de la placa, es decir, la eficiencia es muy pobre.  <strong>La soluci√≥n al problema</strong> es que necesita hacer un terreno de prueba de tierra en la capa externa (capa inferior) y no hacer esto: </li></ul><br><p><img src="https://habrastorage.org/webt/xj/hr/0g/xjhr0galowhdsrtub50fwouwj_s.png" alt="Placa de circuito"></p><br><p>  Como resultado, en la segunda revisi√≥n del hierro, se corrigieron estos errores: se agreg√≥ un convertidor de CC / CC externo de 12-3.3V y el pol√≠gono GND se rellen√≥ adicionalmente en la capa inferior y se coloc√≥ la almohadilla de chip en √©l + se conserv√≥ el pol√≠gono de tierra s√≥lido interno.  Despu√©s de tales mejoras, la temperatura en funcionamiento continuo disminuy√≥ de +82 a +43 <sup>o</sup> C: </p><br><p><img src="https://habrastorage.org/webt/_p/t9/qf/_pt9qfhtiicqqdj-kuo_ssg2zsm.png" alt="Termograma"></p><br><p>  Como puede ver, debido a la reducci√≥n de las p√©rdidas, la temperatura ha disminuido significativamente en las mismas condiciones, as√≠ como el calor ahora se distribuye de manera m√°s uniforme en el √°rea del tablero y no sobrecalienta ni el controlador ni el microcontrolador.  En principio, todo era hierro, no pas√≥ nada m√°s interesante y funcion√≥ de manera estable.  Como resultado, pueden recomendar el uso del controlador <strong>DRV8353</strong> . </p><br><h1 id="realizaciya-apparatnogo-sdviga-faz-na-120suposup">  Implementaci√≥n de un cambio de fase de hardware de 120 <sup>o</sup> </h1><br><p>  Una caracter√≠stica de la red trif√°sica es que la corriente en las fases no es s√≠ncrona, sino que se desplaza 120 <sup>o en</sup> relaci√≥n con la vecina.  ¬øQu√© es este cambio de fase de 120 <sup>o</sup> en general?  En t√©rminos simples, este es un cambio del punto de inicio de la generaci√≥n en 1/3 del per√≠odo.  Desde el punto de vista matem√°tico, el per√≠odo de se√±al es <em>2œÄ</em> , lo que significa que la segunda se√±al debe moverse 2œÄ / 3, y la tercera 4œÄ / 3.  Desde un punto de vista electr√≥nico, el per√≠odo se establece por el per√≠odo de cuenta regresiva de nuestro temporizador.  Por ejemplo, cuando se registra a 60 MHz, queremos obtener un PWM con una frecuencia de 50 kHz, lo que significa que el temporizador ser√° de 0 a 1200 (60 000 000 Hz / 50 000 Hz = 1200).  Ahora, para obtener 3 fases con un desplazamiento de 120 <sup>o,</sup> no necesitamos tocar la primera fase, agregar +400 al valor actual para la segunda fase, agregar +800 a la fase actual. </p><br><p>  Si usamos microcontroladores en el n√∫cleo de la corteza, entonces podemos implementar el cambio ya sea escribiendo una f√≥rmula matem√°tica o usando la sincronizaci√≥n de eventos.  Siempre fue sorprendente para m√≠ por qu√© ST, NXP y otros no solo registraron d√≥nde se escribir√≠a el valor del cambio.  Afortunadamente, TI hizo esto en su TMS320F28xxx, para configurar el cambio, ¬°solo escriba un registro!  No voy a decirte por qu√© la soluci√≥n de software no es √≥ptima, solo dir√© que considera las f√≥rmulas MK no muy r√°pidamente.  El pro con sincronizaci√≥n de eventos ya es m√°s adecuado y en stm har√≠a exactamente eso, pero esta opci√≥n no permite cambiar el valor de fase sobre la marcha, es decir, para alg√∫n puente de fase desplazada nuevamente solo queda la versi√≥n del software.  ¬øEs la ventaja de la capacidad de controlar el hardware de fase?  Depende de usted decidir, mi tarea es decirle que es posible.  Para m√≠, esta es una ventaja obvia cuando hablamos de controlar un variador el√©ctrico o inversores de voltaje con una salida trif√°sica. </p><br><p>  Ahora configuremos la generaci√≥n de se√±ales PWM en forma de 3 pares complementarios con tiempo muerto y cambio de fase.  Hasta ahora sin un seno.  Usar√© los siguientes pares: EPWM1A + EPWM1B, EPWM2A + EPWM2B y EPWM4A + EPWM4B.  Estas son las se√±ales que van del microcontrolador al controlador. </p><br><ul><li>  <strong>Paso 1</strong> <br>  Es necesario configurar el multiplexor GPIO con la ayuda del registro <em>GPAMUX</em> para trabajar con PWM y apagar los <em>pull-ups de la</em> salida a la fuente de alimentaci√≥n, de modo que en el momento del encendido no haya log.1 en todas las patas y las teclas no se abran.  La protecci√≥n actual ciertamente ahorrar√°, pero es mejor no hacerlo.  Tambi√©n vale la pena recordar que para acceder a los registros de configuraci√≥n, debe obtenerlo con el comando <em>EALLOW</em> y luego volver a activar la protecci√≥n de sobrescritura con el comando <em>EDIS</em> . </li></ul><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitGPIOforPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPAPUD.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Disable pull-up on GPIO0 (EPWM1A) GpioCtrlRegs.GPAPUD.bit.GPIO1 = 1; // Disable pull-up on GPIO1 (EPWM1B) GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1; // Configure GPIO0 as EPWM1A GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 1; // Configure GPIO1 as EPWM1B GpioCtrlRegs.GPAPUD.bit.GPIO2 = 1; // Disable pull-up on GPIO2 (EPWM2A) GpioCtrlRegs.GPAPUD.bit.GPIO3 = 1; // Disable pull-up on GPIO3 (EPWM2B) GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1; // Configure GPIO2 as EPWM2A GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1; // Configure GPIO3 as EPWM2B GpioCtrlRegs.GPAPUD.bit.GPIO6 = 1; // Disable pull-up on GPIO6 (EPWM4A) GpioCtrlRegs.GPAPUD.bit.GPIO7 = 1; // Disable pull-up on GPIO7 (EPWM4B) GpioCtrlRegs.GPAMUX1.bit.GPIO6 = 1; // Configure GPIO6 as EPWM4A GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 1; // Configure GPIO7 as EPWM4B EDIS; }</span></span></code> </pre> <br><ul><li>  <strong>Paso 2</strong> <br>  Configure la generaci√≥n de se√±al PWM.  Es necesario obtener una frecuencia de 50 kHz y un desplazamiento de fase de 120 <sup>o</sup> .  En este caso, utilizo el PWM habitual, porque en este controlador tambi√©n hay HRPWM, es importante recordar esto.  El m√≥dulo PWM est√° sincronizado a la frecuencia central, es decir, 60 MHz, mostr√© c√≥mo configurar la frecuencia PLL en el primer art√≠culo sobre TMS320, no lo repetir√©, pero al final del art√≠culo habr√° un archivo con el c√≥digo y ser√° posible mirar all√≠. </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// EPWM Module 1 config EPwm1Regs.TBPRD = 600; // Set priod EPwm1Regs.TBPHS.half.TBPHS = 0; // Set phase EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; // Symmetrical mode EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE; // Master enable EPwm1Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_CTR_ZERO; // Sync down-stream module EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm1Regs.AQCTLA.bit.CAU = AQ_SET; EPwm1Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm1Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // enable dead-time module EPwm1Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // Active Hi complementary EPwm1Regs.DBFED = 20; // dead-time on 20 tick EPwm1Regs.DBRED = 20; // dead-time off 20 tick // EPWM Module 2 config EPwm2Regs.TBPRD = 600; EPwm2Regs.TBPHS.half.TBPHS = 400; // Set phase = 400/1200 * 360 = 120 deg EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm2Regs.TBCTL.bit.PHSEN = TB_ENABLE; // Slave enable EPwm2Regs.TBCTL.bit.PHSDIR = TB_DOWN; // Count DOWN on sync (=120 deg) EPwm2Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm2Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // sync flow-through EPwm2Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm2Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm2Regs.AQCTLA.bit.CAU = AQ_SET; EPwm2Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm2Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm2Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm2Regs.DBFED = 20; EPwm2Regs.DBRED = 20; // EPWM Module 4 config EPwm4Regs.TBPRD = 600; EPwm4Regs.TBPHS.half.TBPHS = 400; EPwm4Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm4Regs.TBCTL.bit.PHSEN = TB_ENABLE; EPwm4Regs.TBCTL.bit.PHSDIR = TB_UP; EPwm4Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm4Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; EPwm4Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm4Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm4Regs.AQCTLA.bit.CAU = AQ_SET; EPwm4Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm4Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm4Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm4Regs.DBFED = 20; EPwm4Regs.DBRED = 20; }</span></span></code> </pre> <br><p>  Ahora, un poco m√°s de detalle ... en el registro <em>TBPRD</em> , escriba el per√≠odo, o mejor dicho, "per√≠odo / 2", porque  el temporizador se cuenta en ambas direcciones, resulta que el per√≠odo 600 corresponde a la frecuencia de la se√±al PWM de salida de 50 kHz en el modo de par complementario.  En el registro <em>TBPHS</em> escribimos el valor de fase por el cual necesitamos cambiar, en este caso 400 de 600, que corresponde a 2œÄ / 3.  Vale la pena se√±alar que no estamos moviendo la primera fase, por lo que para √©l el turno es 0, para la segunda fase el turno es 400, respectivamente, pero para la tercera fase parecer√≠a l√≥gico escribir 800, pero 800 de 600 de alguna manera en realidad no ... por lo tanto, escriben el cambio no en relaci√≥n con la primera fase, sino en relaci√≥n con la anterior, es decir, la segunda.  Como resultado, obtenemos que en la tercera fase escribimos 400 y esto corresponde a 2œÄ / 3 entre las fases 2 y 3, y dado que la segunda ya est√° desplazada, entonces entre las fases 1 y 3 habr√° "2œÄ / 3 + 2œÄ / 3 = 4œÄ / 3 "y desde el punto de vista de la electr√≥nica, todo parece l√≥gico. </p><br><p>  Para que las fases comprendan qui√©n se est√° moviendo en relaci√≥n con qui√©n, se necesita un jefe, por lo que EPWM1 ‚Äã‚Äãse establece utilizando el bit <em>PHSEN</em> en modo maestro y EPWM2 y EPWM4, respectivamente, como esclavos.  Usando los bits <em>SYNCOSEL</em> , <em>tambi√©n se</em> establece el "punto" de <em>sincronizaci√≥n</em> , es decir, desde d√≥nde leer el cambio.  EPWM1 ‚Äã‚Äãest√° sincronizado con el inicio del temporizador, es decir, con per√≠odo cero, y EPWM2 y EPWM4 ya est√°n sincronizados con respecto al borde de la se√±al del canal anterior: el canal anterior para EPWM2 es EPWM1, y para EPWM4 es EPWM2. </p><br><p>  Ahora queda activar pares complementarios y establecer la duraci√≥n del tiempo muerto.  Usando los bits <em>POLSEL</em> , establecemos un PWM no inverso, es decir, al alcanzar el valor establecido del comparador (referencia), se genera un registro en la salida.  1. En <em>OUT_MODE</em> establecemos la generaci√≥n de tiempo muerto tanto en el borde como en la ca√≠da de la se√±al.  En consecuencia, en los registros <em>DBFED</em> y <em>DBRED</em> escriben la duraci√≥n del tiempo muerto en ticks. </p><br><ul><li>  <strong>Paso 3</strong> <br>  Ahora queda por escribir el valor del factor de trabajo en el registro <em>CMPA</em> correspondiente a cada canal y puede observar el resultado. </li></ul><br><pre> <code class="cpp hljs"> EPwm1Regs.CMPA.half.CMPA = <span class="hljs-number"><span class="hljs-number">300</span></span>; <span class="hljs-comment"><span class="hljs-comment">// duty for output EPWM1A EPwm2Regs.CMPA.half.CMPA = 300; // duty for output EPWM2A EPwm4Regs.CMPA.half.CMPA = 300; // duty for output EPWM4A</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/sl/wy/6b/slwy6b5zoivfrdpbzlf9vpbsmms.png" alt="PWM trif√°sico"></p><br><p>  Voila!  Las sondas de osciloscopio est√°n conectadas a la salida del controlador.  El canal amarillo es nuestro EPWM1, es decir, el maestro.  El canal azul es EPWM2 y se desplaza 2œÄ / 3 (o 400 muestras) en relaci√≥n con el canal amarillo, y el canal verde se desplaza otras 400 muestras.  As√≠ obtenemos 3 fases, donde cada fase se desplaza por 120 <sup>o</sup> . </p><br><p>  Ahora transfiramos las sondas de osciloscopio desde la salida del puente de alimentaci√≥n a las se√±ales de control que salen del microcontrolador y verifiquemos el tiempo muerto dentro del par complementario: </p><br><p><img src="https://habrastorage.org/webt/cd/aj/k7/cdajk7vfo9vs5d1yzvbuvtggy00.png" alt="Oscilograma n√∫mero 2"></p><br><p>  Como puede ver, el tiempo muerto establecido corresponde al real.  La duraci√≥n de una muestra es <em>1 / 60,000,000 Hz = 16.6 ns</em> y obtenemos 20 muestras, lo que equivale al tiempo muerto 20.6 <em>16</em> ns = 332 ns, * que es aproximadamente lo que se observa en el oscilograma. </p><br><p>  En realidad, donde esto puede ser √∫til, en la forma en que est√° ahora.  La opci√≥n m√°s obvia son los convertidores de CC / CC multif√°sicos, para aquellos interesados ‚Äã‚Äãen googlear el <strong>convertidor de CC / CC intercalado</strong> .  Esta es una soluci√≥n t√©cnica extremadamente interesante que puede reducir significativamente el tama√±o de las inductancias de potencia, reducir la capacitancia de salida de los condensadores y tambi√©n aumentar la eficiencia.  En un TMS320F28027 simple, puede implementar un convertidor de 4 fases y todo esto se implementar√° de manera muy simple en el c√≥digo y solo en el hardware. </p><br><h1 id="generiruem-trehfaznoe-peremennoe-napryazhenie">  Generamos una tensi√≥n alterna trif√°sica. </h1><br><p>  En muchos problemas, no ser√° suficiente obtener valores discretos de 0 o VCC en la salida; se necesita una onda sinusoidal.  Tengo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un art√≠culo</a> que habla sobre la formaci√≥n de un voltaje alterno monof√°sico y el m√©todo "tabular" se usa all√≠, es decir, los valores para la onda sinusoidal se calcularon inicialmente.  En principio, esto tambi√©n se puede hacer para una fase trif√°sica, pero quiero mostrar una opci√≥n alternativa, a saber, el c√°lculo del valor del derecho en tiempo real o sobre la marcha. </p><br><p>  Hay una caracter√≠stica  La frecuencia PWM en este caso tambi√©n es de 50 kHz y el cambio de fase se establece entre los per√≠odos de esta se√±al.  En consecuencia, cuando modulamos una sinusoide con una frecuencia de 50 Hz, el cambio de fase del hardware se "perder√°", todav√≠a estar√° presente entre los PWM, pero no dentro de la sinusoide, por lo que deber√° realizarse un software.  La trigonometr√≠a es algo pesado para TMS320F28027, pero no est√° muy ocupado conmigo, as√≠ que d√©jelo contar.  Si tiene una tarea que requiere muchos c√°lculos, entonces necesita un controlador con TMU y FPU, por ejemplo, TMS320F280049, que puede convertir las matem√°ticas mucho m√°s r√°pido. </p><br><p>  Para cargar los valores de servicio en el PWM, necesitamos un temporizador, cuyo per√≠odo establecer√° la frecuencia de muestreo.  Necesito un per√≠odo de 20 ms (1 / 50Hz = 20 ms) y tomar√© el n√∫mero de pasos en una sinusoide, digamos 20, como resultado, se debe generar una interrupci√≥n con una frecuencia de 0.02 s / 20 = 0.001 ms = 1 kHz y en esta interrupci√≥n escribir√© el valor en el PWM .  Para simplificar, tomar√© un temporizador <em>CPU0</em> normal y lo configurar√©: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitTimer0ForGenerator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; PieVectTable.TINT0 = &amp;cpu_timer0_isr; EDIS; InitCpuTimers(); ConfigCpuTimer(&amp;CpuTimer0, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); CpuTimer0Regs.TCR.bit.TIE = <span class="hljs-number"><span class="hljs-number">1</span></span>; CpuTimer0Regs.TCR.bit.TSS = <span class="hljs-number"><span class="hljs-number">0</span></span>; IER |= M_INT1; PieCtrlRegs.PIEIER1.bit.INTx7 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Enable TINT0 in the PIE: Group 1 interrupt 7 EINT; // Enable Global interrupt INTM ERTM; // Enable Global real-time interrupt DBGM } __interrupt void cpu_timer0_isr (void) { CpuTimer0.InterruptCount++; /* *   -  . ... */ PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre> <br><p>  Las <em>funciones</em> <em>InitCpuTimers</em> y <em>ConfigCpuTimer son</em> est√°ndar, todos los ajustes est√°n en ellas, solo necesitamos transferir la frecuencia central (60 MHz) y el per√≠odo de conteo en microsegundos (1000 Œºs = 1 ms), que es equivalente a 1 kHz, y lo necesit√°bamos.  Entonces, ¬ød√≥nde en la funci√≥n de configuraci√≥n habilitamos las interrupciones y pasamos la direcci√≥n del controlador de nuestra interrupci√≥n, donde todo suceder√°? </p><br><p>  Ahora es necesario "inventar" la f√≥rmula sinusoidal de nuevo, para esto necesita conocimiento de trigonometr√≠a escolar y eso es todo.  Y entonces ... tenemos una funci√≥n <strong><em>y = sin (x)</em></strong> tracemos esta funci√≥n: </p><br><p><img src="https://habrastorage.org/webt/hi/bx/ey/hibxeyajv_h7l7t-mqkbkfrq6-s.png" alt="y = sin (x)"></p><br><p>  Como puede ver en el gr√°fico, la amplitud de y var√≠a de -1 a 1, pero queremos de 0 a 1, porque  con una amplitud m√≠nima tenemos 0V, y con un m√°ximo (equivalente a 1) tenemos + VCC.  Para "dibujar" -1 ... + 1 necesitamos nutrici√≥n bipolar, pero no lo es.  Necesita cambiar el gr√°fico en una direcci√≥n positiva.  Si lo levantamos, pasar√° de 0 a +2, y solo podremos subir a +1.  ¬°Entonces necesitas dividir por 2 y solo algo!  Comencemos simplemente dividiendo y trazando para <strong><em>y = (sin (x) / 2):</em></strong> </p><br><p><img src="https://habrastorage.org/webt/t_/n0/iw/t_n0iw1fym8aboggaxk1my7r4um.png" alt="y = (sin (x) / 2)"></p><br><p>  Si!  Ahora el gr√°fico tiene un rango de -0.5 a +0.5, es decir, la amplitud es 1. Ya es mejor, pero a√∫n no hemos eliminado los valores negativos, as√≠ que simplemente cambiemos el gr√°fico a 0.5, para esto solo necesitamos agregar este valor al resultado y obtener la f√≥rmula <strong><em>y = 0.5 + (sin (x) / 2)</em></strong> y trace el gr√°fico para esta funci√≥n: </p><br><p><img src="https://habrastorage.org/webt/df/vu/ez/dfvuez1lks2uhg0cp3tkhie9cdq.png" alt="y = 0.5 + (sin (x) / 2)"></p><br><p>  Ahora todo se ha vuelto absolutamente perfecto: la sinusoide tiene una amplitud de 0 a 1, los valores negativos est√°n ausentes.  La f√≥rmula <strong><em>y = 0.5 + (sin (x) / 2)</em></strong> describe la primera fase, ahora es necesario agregar un cambio de fase para obtener las fases 2 y 3. Para hacer esto, reste 2œÄ / 3 y 4œÄ / 3 de <em>x,</em> respectivamente, y obtenga las f√≥rmulas para el resto fases <strong><em>y = 0.5 + (sin (x-2œÄ / 3) / 2)</em></strong> e <strong><em>y = 0.5 + (sin (x-4œÄ / 3) / 2).</em></strong>  Construimos 3 gr√°ficos y vemos si parece la verdad: </p><br><p><img src="https://habrastorage.org/webt/hj/kp/n9/hjkpn93-37r_rclbrevchhdzf_m.png" alt="3 fases"></p><br><p>  No esta mal!  La imagen es similar a lo que generalmente se pinta en los libros de texto de ingenier√≠a el√©ctrica cuando hablan de una red trif√°sica o motores as√≠ncronos.  Por cierto, 2.0943 es 2œÄ / 3, y 4.1866 es 4œÄ / 3, respectivamente, solo los cont√© de inmediato y aparecen en mi c√≥digo.  Total tenemos 3 ecuaciones: </p><br><ul><li>  Fase A - <strong><em>y = 0.5 + (sin (x) / 2)</em></strong> </li><li>  Fase B - <strong><em>y = 0.5 + (sin (x-2œÄ / 3) / 2)</em></strong> </li><li>  Fase C - <strong><em>y = 0.5 + (sin (x-4œÄ / 3) / 2)</em></strong> </li></ul><br><p>  Por parte de las matem√°ticas, todo parece ser simple y claro, pero ahora debe adaptarse a las realidades de los microcontroladores.  Nuestra onda sinusoidal no es anal√≥gica, pero tiene "pasos", es decir, es discreta, porque en mi caso solo podemos establecer voltaje o 0V o + 15V (VCC).  Anteriormente, escrib√≠ que tendr√≠a 20 pasos, por lo que durante 1 per√≠odo tendr√© 20 c√°lculos. </p><br><p>  Primero, decidamos qu√© sustituir por <em>x</em> .  El per√≠odo de nuestra sinusoide es <em>2œÄ</em> , lo que significa que el paso de muestreo ser√° <em>2œÄ / 20</em> .  En consecuencia, la sinusoide constar√° de 20 puntos, como si estuvi√©ramos construyendo un gr√°fico sobre los puntos, y aproxim√°ndolos entre ellos.  Como resultado, el valor en el primer paso ser√° <strong><em>sin (2œÄ * (1/20),</em></strong> en el segundo paso <strong><em>sin (2œÄ * (2/20)),</em></strong> en el tercer paso * <strong>sin (2œÄ <em>(3/20))</em></strong> y as√≠ sucesivamente, cuando Si llega a <em>20/20</em> , esto significar√° el final del per√≠odo y ser√° necesario comenzar a contar nuevamente. Seg√∫n los datos recibidos, corrijamos las f√≥rmulas: </p><br><ul><li>  Fase A - <strong><em>y = 0.5 + (sin (2œÄ * (n / N)) / 2)</em></strong> </li><li>  Fase B - <strong><em>y = 0.5 + (sin (2œÄ * (n / N) -2œÄ / 3) / 2)</em></strong> </li><li>  Fase C - <strong><em>y = 0.5 + (sin (2œÄ * (n / N) -4œÄ / 3) / 2)</em></strong> </li></ul><br><p>  Ahora, ahora consideramos el valor del seno en cada punto espec√≠fico del gr√°fico.  En consecuencia, <strong>n</strong> es el paso actual, <strong>N</strong> es el paso total (20).  Despu√©s de estas f√≥rmulas, obtenemos un valor de 0 a 1, pero en realidad no estamos operando con una amplitud abstracta.  La amplitud en nuestro caso depende del ciclo de trabajo, porque  el deber var√≠a de 0 a 600 (de la configuraci√≥n PWM), luego 0 es 0 y 1 es equivalente a 600. En base a esto, volvamos a calcularlo en una f√≥rmula real para obtener el valor que se cargar√° en el <em>registro</em> CMPA <em>PWM</em> : </p><br><ul><li>  Fase A - <strong><em>deber1 = A <em>(0.5 + (sin (2œÄ</em> (n / N)) / 2))</em></strong> </li><li>  Fase B - <strong><em>deber2 = A <em>(0.5 + (sin (2œÄ</em> (n / N) -2œÄ / 3) / 2))</em></strong> </li><li>  Fase C - <strong><em>deber 4 = A <em>(0.5 + (sin (2œÄ</em> (n / N) -4œÄ / 3) / 2))</em></strong> </li></ul><br><p>  En consecuencia, <strong>A</strong> es el valor m√°ximo de la amplitud, es decir, 600, <strong>n</strong> es el paso actual, <strong>N</strong> es el n√∫mero total de pasos (20).  Los valores de <strong><em>duty1, duty2, duty4</em></strong> son los valores reales convertidos del factor de deber, que se carga en el <em>CMPA.</em>  Ahora escribamos el c√≥digo para el controlador de interrupciones actualizado y declaremos todas las variables necesarias: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> activeStep = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> amplitude = <span class="hljs-number"><span class="hljs-number">600.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> allStep = <span class="hljs-number"><span class="hljs-number">20.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pi = <span class="hljs-number"><span class="hljs-number">3.1415</span></span>; <span class="hljs-comment"><span class="hljs-comment">// œÄ const float piTwo = 6.2831; // 2œÄ const float phaseShifted120deg = 2.0943; // 2œÄ/3 const float phaseShifted240deg = 4.1866; // 4œÄ/3 __interrupt void cpu_timer0_isr (void) { if (activeStep &gt;= allStep) {activeStep = 0;} activeStep++; EPwm1Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep)) / 2)))); EPwm2Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted120deg) / 2)))); EPwm4Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted240deg) / 2)))); PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre><br><p>  El c√≥digo, como puede ver, es el m√°s simple, si comprende lo que se requer√≠a hacer y las matem√°ticas simples en el problema a resolver.  Cada vez que se llama a la interrupci√≥n, incrementamos la variable <em>activeStep</em> , que contiene el n√∫mero de paso, cambia de 0 a 20 y luego se restablece.  Resulta que en un per√≠odo realizamos 20 pasos y 20 c√°lculos para cada fase.  Para no contar <em>2œÄ / 3</em> y <em>4œÄ / 3</em> en la f√≥rmula todo el tiempo, los cont√© de inmediato para usarlos como constantes. </p><br><p>  Los c√°lculos resultaron m√≠nimos, para este MK no es absolutamente nada.  Si lo desea, el n√∫mero de puntos se puede aumentar significativamente, por ejemplo, hasta 200. Todo depende de la tarea.  El cambio de la frecuencia PWM se produce al cambiar la frecuencia de la llamada de interrupci√≥n y el n√∫mero de pasos.  Tambi√©n puede cambiar la <em>amplitud</em> variable y cambiar el voltaje en la salida del convertidor de potencia. </p><br><p>  Despu√©s de descargar el c√≥digo al microcontrolador, obtendr√° la imagen correspondiente: </p><br><p><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="Oscilograma n√∫mero 1"></p><br><p>  Si estira el gr√°fico a lo largo de <em>Y</em> , es mejor ver los defectos de la se√±al.  Esto es una consecuencia del peque√±o n√∫mero de pasos de muestreo; se aplica una regla condicional: cuantos <strong>m√°s puntos, m√°s bella es la se√±al.</strong> </p><br><p><img src="https://habrastorage.org/webt/wh/4d/du/wh4dduwnbyshscey7rlmzs6s1mw.png" alt="Oscilograma n√∫mero 3"></p><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p>  Hoy habl√© sobre el proceso de formaci√≥n de cambio de fase en sistemas multif√°sicos, en principio, no hay nada complicado, especialmente cuando se usa TMS320F28.  El resto depende de los algoritmos, en principio, en Internet, hay muchos art√≠culos donde el control de masticaci√≥n y los motores sin escobillas, y as√≠ncronos y todo tipo de otros, solo puede cambiar la l√≥gica. </p><br><p>  Espero que este material sea √∫til y no particularmente aburrido de leer.  Como siempre, se adjunta la fuente: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Archivo con el proyecto para Code Composer Studio</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457548/">https://habr.com/ru/post/457548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457534/index.html">Versiones certificadas: el rastrillo que elegimos</a></li>
<li><a href="../457538/index.html">¬øC√≥mo puedo usar m√°quinas virtuales Yandex.Cloud interrumpidas y ahorrar para resolver problemas a gran escala?</a></li>
<li><a href="../457540/index.html">Intel Optane DC Persistent Memory, un a√±o despu√©s</a></li>
<li><a href="../457542/index.html">Hackear y proteger unidades de cifrado LUKS</a></li>
<li><a href="../457546/index.html">Demo Day: por qu√© es todo y c√≥mo hacerlo UPD + Broadcast</a></li>
<li><a href="../457550/index.html">De qu√© debe protegerse la industria digital</a></li>
<li><a href="../457552/index.html">Escaladores en Zafasadia. C√≥mo funcionan los promalps en la torre del Centro Lakhta</a></li>
<li><a href="../457558/index.html">An√°lisis de vulnerabilidad de EvilParcel</a></li>
<li><a href="../457560/index.html">Acciones Tokenizadas: C√≥mo convertirse en un inversor Gett antes de ir a la OPV</a></li>
<li><a href="../457562/index.html">Ivideon Counter 3D: qui√©n, c√≥mo y por qu√© contar visitantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>