<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🌾 👩🏽‍🤝‍👩🏼 👩🏽‍⚕️ Apache Ignite + Apache Spark数据框架：更加有趣 👇🏾 🎅🏿 🌄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我叫Nikolai Izhikov，我在开源解决方案开发团队的Sberbank Technologies工作。 用Java进行15年商业开发的背后。 我是Apache Ignite提交者和Apache Kafka的贡献者。 

 在猫的下面，您将找到有关Apache Ignite Meet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Ignite + Apache Spark数据框架：更加有趣</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/427297/"> 哈Ha！ 我叫Nikolai Izhikov，我在开源解决方案开发团队的Sberbank Technologies工作。 用Java进行15年商业开发的背后。 我是Apache Ignite提交者和Apache Kafka的贡献者。 <br><br> 在猫的下面，您将找到有关Apache Ignite Meetup的报告的视频和文本版本，内容涉及如何将Apache Ignite与Apache Spark结合使用以及我们为此实现了哪些功能。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f42/5f3/df5/f425f3df59ff99d03d4a3e6aff3b2655.png"><br><a name="habracut"></a><br><h2>  Apache Spark可以做什么 </h2><br> 什么是Apache Spark？ 此产品使您可以快速执行分布式计算和分析查询。 基本上，Apache Spark是用Scala编写的。 <br><br>  Apache Spark具有丰富的API，可用于连接到各种存储系统或接收数据。 该产品的功能之一是通用的类似SQL的查询引擎，用于从各种来源接收数据。 如果您有多种信息来源，则希望将它们组合起来并获得一些结果，那么Apache Spark是您所需要的。 <br><br>  Spark提供的关键抽象之一是Data Frame，DataSet。 就关系数据库而言，这是一个表，它是一种以结构化方式提供数据的源。 每列的结构，类型，名称等是已知的。 可以从各种来源创建数据框。 示例包括json文件，关系数据库，各种hadoop系统和Apache Ignite。 <br><br>  Spark支持SQL查询中的联接。 您可以合并来自各种来源的数据并获得结果，执行分析查询。 此外，还有一个用于保存数据的API。 完成查询并进行研究后，Spark可以将结果保存到支持此功能的接收器中，从而解决数据处理问题。 <br><br><h2> 我们实现了将Apache Spark与Apache Ignite集成的哪些功能 </h2><br><ol><li> 从Apache Ignite SQL表读取数据。 </li><li> 将数据写入Apache Ignite SQL表。 </li><li>  IgniteSparkSession中的IgniteCatalog-使用所有现有的Ignite SQL表而无需“手动”注册的能力。 </li><li>  SQL优化-在Ignite中执行SQL语句的能力。 </li></ol><br>  Apache Spark可以从Apache Ignite SQL表读取数据，并以这种表的形式写入数据。  Spark中形成的任何DataFrame都可以另存为Apache Ignite SQL表。 <br><br>  Apache Ignite允许您在Spark Session中使用所有现有的Ignite SQL表，而无需“手工”注册-使用标准SparkSession扩展-IgniteSparkSession中的IgniteCatalog。 <br><br> 在这里，您需要更深入地了解Spark设备。 就常规数据库而言，目录是元信息存储的地方：哪些表可用，表中有哪些列，等等。 当请求到达时，从目录中提取元信息，并且SQL引擎对表和数据进行处理。 默认情况下，在Spark中，所有读取表（无关紧要，来自关系数据库Ignite和Hadoop）都必须在会话中手动注册。 结果，您就有机会在这些表上进行SQL查询。  Spark发现了有关它们的信息。 <br><br> 要使用我们上传到Ignite的数据，我们需要注册表。 但是，我们无需手动注册每个表，而是实现了自动访问所有Ignite表的功能。 <br><br> 这里有什么功能？ 由于某些原因，我不知道，Spark中的目录是一个内部API，即 局外人无法来创建自己的目录实现。 而且，由于Spark来自Hadoop，因此仅支持Hive。 并且您必须用手注册其他所有内容。 用户经常问您如何解决此问题并立即进行SQL查询。 我实现了一个目录，该目录使您无需注册〜和sms〜即可浏览和访问Ignite表，并最初在Spark社区中提出了此补丁，我收到了答复：由于某些内部原因，这种补丁并不有趣。 而且他们没有给出内部API。 <br><br> 现在，Ignite目录是使用Spark内部API实现的有趣功能。 要使用此目录，我们有自己的会话实现，这是通常的SparkSession，您可以在其中执行请求，处理数据。 区别在于我们将ExternalCatalog集成到其中以用于Ignite表以及IgniteOptimization，这将在下面进行描述。 <br><br>  <b>SQL优化</b> -在Ignite中执行SQL语句的能力。 默认情况下，在执行联接，分组，聚合计算和其他复杂的SQL查询时，Spark会逐行读取数据。 数据源唯一能做的就是有效地过滤掉行。 <br><br> 如果使用联接或分组，Spark将使用指定的过滤器将表中的所有数据拉入其内存中的工作器中，然后将它们分组或执行其他SQL操作。 在Ignite的情况下，这不是最佳选择，因为Ignite本身具有分布式体系结构，并且了解其中存储的数据。 因此，Ignite本身可以有效地计算聚合并进行分组。 此外，可能会有很多数据，要对它们进行分组，您将需要减去所有数据，并在Spark中提升所有数据，这是非常昂贵的。 <br><br>  Spark提供了一个API，您可以使用该API更改SQL查询的初始计划，执行优化并将可在此处执行的SQL查询部分转发到Ignite。 就速度和内存消耗而言，这将是有效的，因为我们不会使用它来提取将立即分组的数据。 <br><br><h2> 如何运作 </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/b28/1df/0ef/b281df0ef5f2ea2a08f73267ef7f5edb.png"><br><br> 我们有一个Ignite群集-这是图片的下半部分。 没有Zookeeper，因为只有五个节点。 有火花工作程序，每个工作程序内部都会引发Ignite客户端节点。 通过它，我们可以发出请求并读取数据，并与集群进行交互。 此外，客户端节点将在IgniteSparkSession内部上升，以使目录正常工作。 <br><br><h2> 点燃数据框 </h2><br> 我们来看代码：如何从SQL表读取数据？ 就Spark而言，一切都非常简单和良好：我们说我们要计算一些数据，并指定格式-这是一个一定的常数。 此外，我们有几个选项-客户端节点配置文件的路径，该路径在读取数据时开始。 我们指出我们要读取的表，并告诉Spark加载。 我们获得了数据，我们可以用它做我们想做的事情。 <br><br><pre><code class="scala hljs">spark.read .format(<span class="hljs-type"><span class="hljs-type">FORMAT_IGNITE</span></span>) .option(<span class="hljs-type"><span class="hljs-type">OPTION_CONFIG_FILE</span></span>, <span class="hljs-type"><span class="hljs-type">TEST_CONFIG_FILE</span></span>) .option(<span class="hljs-type"><span class="hljs-type">OPTION_TABLE</span></span>, <span class="hljs-string"><span class="hljs-string">"person"</span></span>) .load()</code> </pre> <br> 生成数据后-可以选择从Ignite或从任何来源生成数据-通过指定格式和相应的表，我们可以轻松地保存所有内容。 我们命令Spark编写，我们指定一种格式。 在配置中，我们规定了要连接到哪个集群。 指定我们要保存的表。 此外，我们可以规定实用程序选项-指定在此表上创建的主键。 如果数据只是在不创建表的情况下发生故障，则不需要此参数。 最后，单击保存，数据被写入。 <br><br><pre> <code class="scala hljs">tbl.write. format(<span class="hljs-type"><span class="hljs-type">FORMAT_IGNITE</span></span>). option(<span class="hljs-type"><span class="hljs-type">OPTION_CONFIG_FILE</span></span>, <span class="hljs-type"><span class="hljs-type">CFG_PATH</span></span>). option(<span class="hljs-type"><span class="hljs-type">OPTION_TABLE</span></span>, tableName). option(<span class="hljs-type"><span class="hljs-type">OPTION_CREATE_TABLE_PRIMARY_KEY_FIELDS</span></span>, pk). save</code> </pre><br> 现在，让我们看看它是如何工作的。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b35/41a/b86/b3541ab86eca15cd240765bf15907979.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LoadDataExample.scala</a> <br><br> 这个显而易见的应用程序将首先演示记录功能。 例如，我选择了足球比赛的数据，并从知名资源下载了统计数据。 它包含有关比赛的信息：联赛，比赛，球员，球队，球员属性，球队属性-描述欧洲国家（英格兰，法国，西班牙等）联赛中足球比赛的数据。 <br><br> 我想将它们上传到Ignite。 我们创建一个Spark会话，指定向导的地址，并通过传递参数来调用这些表的加载。 该示例使用Scala，而不是Java，因为Scala不太冗长，因此更好。 <br><br> 我们传输文件名，将其读取，表明它是多行的，这是一个标准的json文件。 然后我们用Ignite编写。 文件的结构无处可描述-Spark本身确定了我们拥有的数据以及它们的结构。 如果一切顺利，则会创建一个表，其中包含所需数据类型的所有必要字段。 这就是我们可以在Ignite中加载所有内容的方式。 <br><br> 加载数据后，我们可以在Ignite中查看并立即使用它。 举一个简单的例子，一个查询让您知道哪个队比赛次数最多。 我们有两列：hometeam和awayteam，主机和来宾。 我们选择，分组，计数，求和并结合命令上的数据-输入命令的名称。  Ta-dam-以及我们从Ignite中获得的json-chiks中的数据。 我们看到了图卢兹的巴黎圣日耳曼-我们有很多关于法国队的数据。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a4/202/52b/8a420252be6fb8df3a9083d7411911a9.png"><br><br> 我们总结一下。 现在，我们已经将数据从源json文件上载到Ignite，而且速度很快。 从大数据的角度来看，这也许不是太大，但对于本地计算机而言却不错。 表模式以其原始形式从json文件中获取。 表已创建，列名称已从源文件复制，主键已创建。  ID无处不在，主键是ID。 这些数据进入Ignite，我们可以使用它。 <br><br><h2>  IgniteSparkSession和IgniteCatalog </h2><br> 让我们看看它是如何工作的。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/654/24a/4ee/65424a4eeda4a4c2c6cce7038e13d1a9.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CatalogExample.scala</a> <br><br> 您可以用一种非常简单的方式访问和查询所有数据。 在上一个示例中，我们开始了标准的spark会话。 而且那里没有Ignite的特殊性-除了必须放置带有正确数据源的jar-通过公共API完全标准地工作。 但是，如果您想自动访问Ignite表，则可以使用我们的扩展名。 不同之处在于，我们编写了IgniteSparkSession而不是SparkSession。 <br><br> 一旦创建IgniteSparkSession对象，您就会在目录中看到所有刚刚加载到Ignite中的表。 您可以看到他们的图表和所有信息。  Spark已经了解Ignite拥有的表，您可以轻松获取所有数据。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dec/f1b/a0c/decf1ba0c5db2e0d84e50a0e88b6c192.png"><br><br><h2> 点火优化 </h2><br> 当您使用JOIN在Ignite中进行复杂查询时，Spark首先提取数据，然后才对它们进行分组。 为了优化流程，我们提供了IgniteOptimization功能-它优化了Spark查询计划，并允许您转发可在Ignite内部的Ignite内部执行的请求部分。 我们会根据特定要求显示优化。 <br><br><pre> <code class="sql hljs">SQL Query: <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>   city_id,   <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>   person p <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> city_id <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br> 我们满足要求。 我们有一个人表-一些员工，人。 每个员工都知道他所居住城市的ID。 我们想知道每个城市有多少人。 我们过滤-一个人居住的城市。 这是Spark构建的初始计划： <br><br><pre> <code class="scala hljs">== <span class="hljs-type"><span class="hljs-type">Analyzed</span></span> <span class="hljs-type"><span class="hljs-type">Logical</span></span> <span class="hljs-type"><span class="hljs-type">Plan</span></span> == city_id: bigint, count(<span class="hljs-number"><span class="hljs-number">1</span></span>): bigint <span class="hljs-type"><span class="hljs-type">Project</span></span> [city_id#<span class="hljs-number"><span class="hljs-number">19</span></span>L, count(<span class="hljs-number"><span class="hljs-number">1</span></span>)#<span class="hljs-number"><span class="hljs-number">52</span></span>L] +- <span class="hljs-type"><span class="hljs-type">Filter</span></span> (count(<span class="hljs-number"><span class="hljs-number">1</span></span>)#<span class="hljs-number"><span class="hljs-number">54</span></span>L &gt; cast(<span class="hljs-number"><span class="hljs-number">1</span></span> as bigint))  +- <span class="hljs-type"><span class="hljs-type">Aggregate</span></span> [city_id#<span class="hljs-number"><span class="hljs-number">19</span></span>L], [city_id#<span class="hljs-number"><span class="hljs-number">19</span></span>L, count(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-type"><span class="hljs-type">AS</span></span> count(<span class="hljs-number"><span class="hljs-number">1</span></span>)#<span class="hljs-number"><span class="hljs-number">52</span></span>L, count(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-type"><span class="hljs-type">AS</span></span> count(<span class="hljs-number"><span class="hljs-number">1</span></span>)#<span class="hljs-number"><span class="hljs-number">54</span></span>L] +- <span class="hljs-type"><span class="hljs-type">SubqueryAlias</span></span> p    +- <span class="hljs-type"><span class="hljs-type">SubqueryAlias</span></span> person       +- <span class="hljs-type"><span class="hljs-type">Relation</span></span>[<span class="hljs-type"><span class="hljs-type">NAME</span></span>#<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-type"><span class="hljs-type">BIRTH_DATE</span></span>#<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-type"><span class="hljs-type">IS_RESIDENT</span></span>#<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-type"><span class="hljs-type">SALARY</span></span>#<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-type"><span class="hljs-type">PENSION</span></span>#<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-type"><span class="hljs-type">ACCOUNT</span></span>#<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-type"><span class="hljs-type">AGE</span></span>#<span class="hljs-number"><span class="hljs-number">17</span></span>,<span class="hljs-type"><span class="hljs-type">ID</span></span>#<span class="hljs-number"><span class="hljs-number">18</span></span>L,<span class="hljs-type"><span class="hljs-type">CITY_ID</span></span>#<span class="hljs-number"><span class="hljs-number">19</span></span>L]         <span class="hljs-type"><span class="hljs-type">IgniteSQLRelation</span></span>[table=<span class="hljs-type"><span class="hljs-type">PERSON</span></span>]</code> </pre><br> 关系只是一个点燃表。 没有过滤器-我们只是通过群集中的网络从Person表中抽取所有数据。 然后，Spark根据请求聚合所有这些内容，并返回请求的结果。 <br><br> 显而易见，所有带有过滤器和聚合的子树都可以在Ignite中执行。 这比从Spark中潜在的大表中提取所有数据要有效得多-这就是我们的IgniteOptimization功能所做的。 在分析和优化树之后，我们得到以下计划： <br><br><pre> <code class="scala hljs">== <span class="hljs-type"><span class="hljs-type">Optimized</span></span> <span class="hljs-type"><span class="hljs-type">Logical</span></span> <span class="hljs-type"><span class="hljs-type">Plan</span></span> == <span class="hljs-type"><span class="hljs-type">Relation</span></span>[<span class="hljs-type"><span class="hljs-type">CITY_ID</span></span>#<span class="hljs-number"><span class="hljs-number">19</span></span>L,<span class="hljs-type"><span class="hljs-type">COUNT</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)#<span class="hljs-number"><span class="hljs-number">52</span></span>L]   <span class="hljs-type"><span class="hljs-type">IgniteSQLAccumulatorRelation</span></span>(     columns=[<span class="hljs-type"><span class="hljs-type">CITY_ID</span></span>, <span class="hljs-type"><span class="hljs-type">COUNT</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)], qry=<span class="hljs-type"><span class="hljs-type">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">CITY_ID</span></span>, <span class="hljs-type"><span class="hljs-type">COUNT</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-type"><span class="hljs-type">FROM</span></span> <span class="hljs-type"><span class="hljs-type">PERSON</span></span> <span class="hljs-type"><span class="hljs-type">GROUP</span></span> <span class="hljs-type"><span class="hljs-type">BY</span></span> city_id <span class="hljs-type"><span class="hljs-type">HAVING</span></span> count(<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br> 结果，由于我们优化了整个树，因此我们只有一种关系。 在内部，您已经可以看到Ignite将发送与原始请求足够接近的请求。 <br><br> 假设我们要连接不同的数据源：例如，我们有一个来自Ignite的DataFrame，第二个来自json，第三个又来自Ignite，第四个是某种关系数据库。 在这种情况下，将仅在计划中优化子树。 我们优化我们可以做的事情，将其放入Ignite中，Spark会完成其余工作。 因此，我们可以提高速度。 <br><br>  JOIN的另一个示例： <br><br><pre> <code class="sql hljs">SQL Query - <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jt1.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> id1, jt1.val1, jt2.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> id2, jt2.val2 <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> jt1 <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> jt2 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> jt1.val1 = jt2.val2</code> </pre><br> 我们有两个表。 我们按值排列在一起，然后从中选择所有值-ID，值。  Spark提供了这样的计划： <br><br><pre> <code class="scala hljs">== <span class="hljs-type"><span class="hljs-type">Analyzed</span></span> <span class="hljs-type"><span class="hljs-type">Logical</span></span> <span class="hljs-type"><span class="hljs-type">Plan</span></span> == id1: bigint, val1: string, id2: bigint, val2: string <span class="hljs-type"><span class="hljs-type">Project</span></span> [id#<span class="hljs-number"><span class="hljs-number">4</span></span>L <span class="hljs-type"><span class="hljs-type">AS</span></span> id1#<span class="hljs-number"><span class="hljs-number">84</span></span>L, val1#<span class="hljs-number"><span class="hljs-number">3</span></span>, id#<span class="hljs-number"><span class="hljs-number">6</span></span>L <span class="hljs-type"><span class="hljs-type">AS</span></span> id2#<span class="hljs-number"><span class="hljs-number">85</span></span>L, val2#<span class="hljs-number"><span class="hljs-number">5</span></span>] +- <span class="hljs-type"><span class="hljs-type">Join</span></span> <span class="hljs-type"><span class="hljs-type">Inner</span></span>, (val1#<span class="hljs-number"><span class="hljs-number">3</span></span> = val2#<span class="hljs-number"><span class="hljs-number">5</span></span>) :- <span class="hljs-type"><span class="hljs-type">SubqueryAlias</span></span> jt1 : +- <span class="hljs-type"><span class="hljs-type">Relation</span></span>[<span class="hljs-type"><span class="hljs-type">VAL1</span></span>#<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-type"><span class="hljs-type">ID</span></span>#<span class="hljs-number"><span class="hljs-number">4</span></span>L] <span class="hljs-type"><span class="hljs-type">IgniteSQLRelation</span></span>[table=<span class="hljs-type"><span class="hljs-type">JT1</span></span>] +- <span class="hljs-type"><span class="hljs-type">SubqueryAlias</span></span> jt2    +- <span class="hljs-type"><span class="hljs-type">Relation</span></span>[<span class="hljs-type"><span class="hljs-type">VAL2</span></span>#<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-type"><span class="hljs-type">ID</span></span>#<span class="hljs-number"><span class="hljs-number">6</span></span>L] <span class="hljs-type"><span class="hljs-type">IgniteSQLRelation</span></span>[table=<span class="hljs-type"><span class="hljs-type">JT2</span></span>]</code> </pre> <br> 我们看到他将从一个表中提取所有数据，从第二个表中提取所有数据，将它们加入自己的内部并给出结果。 经过处理和优化后，我们得到了与Ignite完全相同的请求，该请求在此相对较快地执行。 <br><br><pre> <code class="scala hljs">== <span class="hljs-type"><span class="hljs-type">Optimized</span></span> <span class="hljs-type"><span class="hljs-type">Logical</span></span> <span class="hljs-type"><span class="hljs-type">Plan</span></span> == <span class="hljs-type"><span class="hljs-type">Relation</span></span>[<span class="hljs-type"><span class="hljs-type">ID</span></span>#<span class="hljs-number"><span class="hljs-number">84</span></span>L,<span class="hljs-type"><span class="hljs-type">VAL1</span></span>#<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-type"><span class="hljs-type">ID</span></span>#<span class="hljs-number"><span class="hljs-number">85</span></span>L,<span class="hljs-type"><span class="hljs-type">VAL2</span></span>#<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-type"><span class="hljs-type">IgniteSQLAccumulatorRelation</span></span>(columns=[<span class="hljs-type"><span class="hljs-type">ID</span></span>, <span class="hljs-type"><span class="hljs-type">VAL1</span></span>, <span class="hljs-type"><span class="hljs-type">ID</span></span>, <span class="hljs-type"><span class="hljs-type">VAL2</span></span>], qry= <span class="hljs-type"><span class="hljs-type">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">JT1</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> <span class="hljs-type"><span class="hljs-type">AS</span></span> id1, <span class="hljs-type"><span class="hljs-type">JT1</span></span>.<span class="hljs-type"><span class="hljs-type">VAL1</span></span>, <span class="hljs-type"><span class="hljs-type">JT2</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> <span class="hljs-type"><span class="hljs-type">AS</span></span> id2, <span class="hljs-type"><span class="hljs-type">JT2</span></span>.<span class="hljs-type"><span class="hljs-type">VAL2</span></span> <span class="hljs-type"><span class="hljs-type">FROM</span></span> <span class="hljs-type"><span class="hljs-type">JT1</span></span> <span class="hljs-type"><span class="hljs-type">JOIN</span></span> <span class="hljs-type"><span class="hljs-type">JT2</span></span> <span class="hljs-type"><span class="hljs-type">ON</span></span> <span class="hljs-type"><span class="hljs-type">JT1</span></span>.val1 = <span class="hljs-type"><span class="hljs-type">JT2</span></span>.val2 <span class="hljs-type"><span class="hljs-type">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">JT1</span></span>.val1 <span class="hljs-type"><span class="hljs-type">IS</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> <span class="hljs-type"><span class="hljs-type">NULL</span></span> <span class="hljs-type"><span class="hljs-type">AND</span></span> <span class="hljs-type"><span class="hljs-type">JT2</span></span>.val2 <span class="hljs-type"><span class="hljs-type">IS</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> <span class="hljs-type"><span class="hljs-type">NULL</span></span>)</code> </pre> <br> 我会给你看一个例子。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba4/39a/493/ba439a493e76dd573966cad413c07650.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OptimizationExample.scala</a> <br><br> 我们正在创建一个IgniteSpark会话，其中所有的优化功能已经自动包含在内。 这里的要求是这样的：找到评分最高的球员并显示他们的名字。 在播放器表中，其属性和数据。 我们正在加入，过滤垃圾数据并显示评分最高的玩家。 让我们看看优化后得到了什么样的计划，并显示了此查询的结果。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/c51/9ab/c7dc519abdfa6b3b1d7a8396ef9725b3.png"><br><br> 我们开始。 我们看到了熟悉的姓氏：梅西，布冯，罗纳尔多等。 顺便说一句，有些人出于某种原因以两种身份相遇-梅西和罗纳尔多。 足球爱好者可能会发现陌生的球员出现在名单上很奇怪。 这些是守门员，是具有很高特征的球员-在其他球员的背景下。 现在我们来看一下已执行的查询计划。 在Spark中，几乎什么也没做，也就是说，我们再次将整个请求发送给了Ignite。 <br><br><h2>  Apache Ignite开发 </h2><br> 我们的项目是一个开源产品，因此我们总是对开发人员的补丁和反馈感到满意。 非常欢迎您的帮助，反馈和补丁。 我们在等他们。  Ignite社区中90％的人说俄语。 例如，对我而言，直到我开始从事Apache Ignite的开发工作之前，对英语的最佳了解并不是一种威慑力。 在开发者列表上用俄语写作几乎是不值得的，但是即使您写错了内容，他们也会为您提供帮助。 <br><br> 这种集成可以改进什么？ 如果您有这样的愿望，我该如何帮助？ 在下面列出。 星号表示复杂性。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de4/d43/ed0/de4d43ed01894ce6b02865ad9f6aef5d.png"><br> 要测试优化，您需要使用复杂的查询编写测试。 上面，我显示了一些明显的问题。 很明显，如果您编写了很多分组和很多联接，那么某些事情可能会失败。 这是一个非常简单的任务-快来做。 如果我们根据测试结果发现任何错误，则需要对其进行修复。 那里会更难。 <br><br> 另一个清晰有趣的任务是将Spark与瘦客户端集成。 它最初可以指定一些IP地址集，并且足以加入Ignite群集，这在与外部系统集成的情况下非常方便。 如果您突然想加入解决此问题的方法，我将亲自提供帮助。 <br><br> 如果您想加入Apache Ignite社区，这里有一些有用的链接： <br><br><ul><li>  <i>从这里开始-https: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://yu">//ignite.apache.org/community/resources.html</a></i> <br></li><li>  <i>来源在这里<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-https://github.com/apache/ignite/</a></i> <br></li><li>  <i>码头在这里-https: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//apacheignite.readme.io/docs</a></i> <br></li><li>  <i>此处的错误-https: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//issues.apache.org/jira/browse/IGNITE</a></i> <br></li><li>  <i>您可以在这里写-dev @ ignite.apache.org，user @ ignite.apache.org</i> <br></li></ul><br> 我们有一个响应式开发人员列表，将为您提供帮助。 距离理想还很遥远，但是与其他项目相比，它确实很活跃。 <br><br>  <i>如果您知道Java或C ++，那么您正在寻找工作并且想要开发开源代码（Apache Ignite，Apache Kafka，Tarantool等），请在此处编写：join-open-source@sberbank.ru。</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CzbAweNKEVY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN427297/">https://habr.com/ru/post/zh-CN427297/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN427285/index.html">关于数字电路基础的学校：新西伯利亚-好，克拉斯诺亚尔斯克-准备</a></li>
<li><a href="../zh-CN427289/index.html">阿美创新的3D地质建模，测井和技术</a></li>
<li><a href="../zh-CN427291/index.html">最小化ASP.NET Web窗体，可单击的div和定期服务器轮询中的流量</a></li>
<li><a href="../zh-CN427293/index.html">JavaScript设计模式</a></li>
<li><a href="../zh-CN427295/index.html">JavaScript库函数</a></li>
<li><a href="../zh-CN427299/index.html">让我们收集其他东西吗？ 1号“月球舰队”的构造师3</a></li>
<li><a href="../zh-CN427301/index.html">GitHub崩溃的数据库</a></li>
<li><a href="../zh-CN427303/index.html">放慢Windows第2部分：创建进程</a></li>
<li><a href="../zh-CN427307/index.html">Java后端测试实践+放心</a></li>
<li><a href="../zh-CN427309/index.html">事实证明，PVS-Studio比三个半程序员更专心</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>