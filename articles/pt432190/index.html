<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòó üç¢ üéûÔ∏è Previs√£o de f√≠sica do lado do cliente no Unity üî¨ üë®üèø‚Äçüåæ üîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 
 Criei uma demonstra√ß√£o mostrando como implementar a previs√£o do lado do cliente do movimento f√≠sico de um jogador no Unity - GitHub . 

 1. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Previs√£o de f√≠sica do lado do cliente no Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432190/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a59/4f5/561/a594f5561a9452567464c512df8171e5.jpg" alt="imagem"></div><br><h3>  TL; DR </h3><br>  Criei uma demonstra√ß√£o mostrando como implementar a previs√£o do lado do cliente do movimento f√≠sico de um jogador no Unity - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br><h3>  1. Introdu√ß√£o </h3><br>  No in√≠cio de 2012, escrevi um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">post</a> sobre como implementar previs√µes no lado do cliente do movimento f√≠sico de um jogador no Unity.  Gra√ßas a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Physics.Simulate (),</a> essa solu√ß√£o desajeitada que eu descrevi n√£o √© mais necess√°ria.  O post antigo ainda √© um dos mais populares no meu blog, mas para o Unity moderno essas informa√ß√µes j√° est√£o incorretas.  Portanto, estou lan√ßando a vers√£o 2018. <br><br><h3>  O que h√° no lado do cliente? </h3><br>  Em jogos multiplayer competitivos, a trapa√ßa deve ser evitada sempre que poss√≠vel.  Geralmente, isso significa que um modelo de rede com um servidor autorit√°rio √© usado: os clientes enviam as informa√ß√µes inseridas ao servidor e o servidor transforma essas informa√ß√µes no movimento de um jogador e, em seguida, envia uma captura instant√¢nea do status do jogador para o cliente.  Nesse caso, h√° um atraso entre pressionar a tecla e exibir o resultado, o que √© inaceit√°vel para jogos ativos.  A previs√£o no lado do cliente √© uma t√©cnica muito popular que oculta o atraso, prevendo qual ser√° o movimento resultante e mostrando imediatamente ao jogador.  Quando o cliente recebe os resultados do servidor, ele os compara com o que o cliente previu e, se eles diferirem, a previs√£o foi incorreta e precisa ser corrigida. <br><a name="habracut"></a><br>  Os instant√¢neos recebidos do servidor sempre v√™m do passado com rela√ß√£o ao estado previsto do cliente (por exemplo, se a transfer√™ncia de dados do cliente para o servidor e o retorno demorar 150 ms, cada instant√¢neo ser√° atrasado em pelo menos 150 ms).  Como resultado disso, quando o cliente precisa corrigir a previs√£o incorreta, ele deve reverter para esse ponto no passado e reproduzir todas as informa√ß√µes inseridas na lacuna para retornar ao local em que est√°.  Se o movimento do jogador no jogo for baseado em f√≠sica, ent√£o Physics.Simulate () ser√° necess√°rio para simular v√°rios ciclos em um quadro.  Se apenas Controladores de Personagens (ou c√°psula lan√ßada, etc.) forem usados ‚Äã‚Äãao mover o jogador, voc√™ poder√° ficar sem o Physics.Simulate () - e presumo que o desempenho ser√° melhor. <br><br>  Usarei o Unity para recriar uma demonstra√ß√£o de rede chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Zen of Networked Physics de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Glenn Fiedler</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">", da</a> qual desfruto h√° muito tempo.  O jogador tem um cubo f√≠sico no qual ele pode exercer for√ßa, empurrando-o para dentro da cena.  A demonstra√ß√£o simula v√°rias condi√ß√µes de rede, incluindo atraso e perda de pacotes. <br><br><h3>  Come√ßando a trabalhar </h3><br>  A primeira coisa a fazer √© desativar a simula√ß√£o autom√°tica de f√≠sica.  Embora Physics.Simulate () nos permita dizer ao sistema f√≠sico quando iniciar a simula√ß√£o, por padr√£o, ele executa a simula√ß√£o automaticamente com base em um delta de tempo fixo do projeto.  Portanto, vamos desativ√°-lo em <strong>Editar-&gt; Configura√ß√µes do projeto-&gt; F√≠sica</strong> , desmarcando a caixa " <strong>Simula√ß√£o autom√°tica</strong> ". <br><br>  Para come√ßar, criaremos uma implementa√ß√£o simples de usu√°rio √∫nico.  A entrada √© amostrada (w, a, s, d para movimento e espa√ßo para pular), e tudo se resume √†s for√ßas simples aplicadas ao Rigidbody usando AddForce (). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Logic</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject player; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer &gt;= Time.fixedDeltaTime) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer -= Time.fixedDeltaTime; Inputs inputs; inputs.up = Input.GetKey(KeyCode.W); inputs.down = Input.GetKey(KeyCode.S); inputs.left = Input.GetKey(KeyCode.A); inputs.right = Input.GetKey(KeyCode.D); inputs.jump = Input.GetKey(KeyCode.Space); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); } } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BbC-MQX08KE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>O jogador se move enquanto a rede n√£o est√° em uso</i> <br><br><h3>  Enviando entrada para o servidor </h3><br>  Agora precisamos enviar a entrada para o servidor, que tamb√©m executar√° esse c√≥digo de movimento, far√° uma captura instant√¢nea do estado do cubo e a enviar√° de volta ao cliente. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } }</span></span></code> </pre> <br>  Nada de especial aqui at√© agora, a √∫nica coisa que quero prestar aten√ß√£o √© adicionar a vari√°vel tick_number.  √â necess√°rio que, quando o servidor enviar instant√¢neos do estado do cubo de volta ao cliente, possamos descobrir qual tato do cliente corresponde a esse estado, para que possamos comparar esse estado com o cliente previsto (que adicionaremos mais adiante). <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// server private void Update() { while (this.HasAvailableInputMessages()) { InputMessage input_msg = this.GetInputMessage(); Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); this.AddForcesToPlayer(rigidbody, input_msg.inputs); Physics.Simulate(Time.fixedDeltaTime); StateMessage state_msg; state_msg.position = rigidbody.position; state_msg.rotation = rigidbody.rotation; state_msg.velocity = rigidbody.velocity; state_msg.angular_velocity = rigidbody.angularVelocity; state_msg.tick_number = input_msg.tick_number + 1; this.SendToClient(state_msg); } }</span></span></code> </pre> <br>  Tudo √© simples - o servidor aguarda as mensagens de entrada, quando recebe, simula um ciclo de rel√≥gio.  Em seguida, ele tira uma captura instant√¢nea do estado resultante do cubo e o envia de volta ao cliente.  Voc√™ pode observar que tick_number na mensagem de status √© um n√∫mero maior que tick_number na mensagem de entrada.  Isso √© feito porque √© pessoalmente intuitivamente mais conveniente para mim pensar no "estado do jogador no tato 100" como o "estado do jogador no <strong>in√≠cio do</strong> tato 100".  Portanto, o estado do jogador na medida 100 em combina√ß√£o com a entrada do jogador na medida 100 cria um novo estado para o jogador na medida 101. <br><br><h1>  Estado <sub>n</sub> + Entrada <sub>n</sub> = Estado <sub>n + 1</sub> </h1><br>  N√£o estou dizendo que voc√™ deve seguir da mesma maneira, o principal √© a const√¢ncia da abordagem. <br><br>  Tamb√©m deve ser dito que eu n√£o <em>envio</em> essas mensagens atrav√©s de um soquete real, mas imit√°-las gravando-as na fila, simulando o atraso e a perda de pacotes.  A cena cont√©m dois cubos f√≠sicos - um para o cliente e outro para o servidor.  Ao atualizar o cubo do cliente, desabilito o GameObject do cubo do servidor e vice-versa. <br><br>  No entanto, n√£o simulo a devolu√ß√£o da rede e a entrega de pacotes na ordem errada, e √© por isso que assumo que cada mensagem de entrada recebida √© mais recente que a anterior.  Essa imita√ß√£o √© necess√°ria para simplesmente executar o "cliente" e o "servidor" em uma inst√¢ncia do Unity, para que possamos combinar cubos de servidor e cliente em uma cena. <br><br>  Voc√™ tamb√©m pode observar que, se a mensagem de entrada for descartada e n√£o chegar ao servidor, o servidor simula menos ciclos de rel√≥gio que o cliente e, portanto, criar√° um estado diferente.  Isso √© verdade, mas mesmo se simul√°ssemos essas omiss√µes, a entrada ainda poderia estar incorreta, o que tamb√©m levaria a um estado diferente.  Lidaremos com esse problema mais tarde. <br><br>  Tamb√©m deve ser adicionado que neste exemplo h√° apenas um cliente, o que simplifica o trabalho.  Se tiv√©ssemos v√°rios clientes, precisar√≠amos de a) ao ligar para Physics.Simulate () para verificar se apenas o cubo de um jogador est√° ativado no servidor ou b) se o servidor recebeu entrada de v√°rios cubos, simule-os todos juntos. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OUwWzUxZao0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Atraso 75 ms (150 ms ida e volta)</i> <i><br></i>  <i>0% de pacotes perdidos</i> <i><br></i>  <i>Cubo amarelo - jogador servidor</i> <i><br></i>  <i>Cubo azul - o √∫ltimo instant√¢neo recebido pelo cliente</i> <br><br>  Tudo parece bom at√© agora, mas fui um pouco seletivo com o que gravei no v√≠deo para esconder um problema bastante s√©rio. <br><br><h3>  Falha na determina√ß√£o </h3><br>  D√™ uma olhada agora no seguinte: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7jbKgyUwnd4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Ai ...</i> <br><br>  Este v√≠deo foi gravado sem perder pacotes, no entanto, as simula√ß√µes ainda variam com a mesma entrada exata.  N√£o entendo muito bem por que isso acontece - o PhysX deve ser bastante determin√≠stico, por isso acho impressionante que as simula√ß√µes frequentemente divergam.  Isso pode ser devido ao fato de eu ativar e desativar constantemente os cubos GameObject, ou seja, √© poss√≠vel que o problema diminua ao usar duas inst√¢ncias diferentes do Unity.  Pode ser um erro, se voc√™ o vir no c√≥digo do GitHub, informe-me. <br><br>  Seja como for, previs√µes incorretas s√£o um fato essencial na previs√£o do lado do cliente, ent√£o vamos lidar com elas. <br><br><h3>  Posso retroceder? </h3><br>  O processo √© bastante simples - quando o cliente prev√™ movimento, ele salva um buffer de status (posi√ß√£o e rota√ß√£o) e entrada.  Depois de receber uma mensagem de status do servidor, ele compara o estado recebido com o estado previsto do buffer.  Se eles diferirem por um valor muito grande, redefinimos o estado do cubo do cliente no passado e simulamos novamente todas as medidas intermedi√°rias. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private ClientState[] client_state_buffer = new ClientState[1024]; private Inputs[] client_input_buffer = new Inputs[1024]; private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); uint buffer_slot = this.tick_number % 1024; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = rigidbody.position; this.client_state_buffer[buffer_slot].rotation = rigidbody.rotation; this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } while (this.HasAvailableStateMessage()) { StateMessage state_msg = this.GetStateMessage(); uint buffer_slot = state_msg.tick_number % c_client_buffer_size; Vector3 position_error = state_msg.position - this.client_state_buffer[buffer_slot].position; if (position_error.sqrMagnitude &gt; 0.0000001f) { // rewind &amp; replay Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } } } }</span></span></code> </pre> <br>  Os dados de entrada e status do buffer s√£o armazenados em um buffer circular muito simples, onde o identificador da medida √© usado como um √≠ndice.  E escolhi o valor de 64 Hz para a frequ√™ncia de clock da f√≠sica, ou seja, um buffer de 1024 elementos nos d√° espa√ßo por 16 segundos, e isso √© muito mais do que precisamos. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_ZBOSycfANA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>A corre√ß√£o est√° ativada!</i> <br><br><h3>  Transfer√™ncia de entrada redundante </h3><br>  As mensagens de entrada geralmente s√£o muito pequenas - os bot√µes pressionados podem ser combinados em um campo de bits que leva apenas alguns bytes.  Ainda existe um n√∫mero de medida em nossa mensagem, ocupando 4 bytes, mas podemos compact√°-los facilmente usando um valor de 8 bits com um carry (talvez o intervalo de 0 a 255 seja muito pequeno, podemos estar seguros e aument√°-lo para 9 ou 10 bits).  Seja como for, essas mensagens s√£o bem pequenas e isso significa que podemos enviar muitos dados de entrada em cada mensagem (caso os dados de entrada anteriores tenham sido perdidos).  A que dist√¢ncia devemos voltar?  Bem, o cliente sabe o n√∫mero da medida da √∫ltima mensagem de status que recebeu do servidor, portanto, n√£o faz sentido voltar mais al√©m dessa medida.  Tamb√©m precisamos impor um limite √† quantidade de dados de entrada redundantes enviados pelo cliente.  N√£o fiz isso na minha demonstra√ß√£o, mas ela deve ser implementada no c√≥digo finalizado. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableStateMessage()) { StateMessage state_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStateMessage(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick = state_msg.tick_number;</code> </pre> <br>  Essa √© uma altera√ß√£o simples, o cliente simplesmente grava o n√∫mero da medida da √∫ltima mensagem de status recebida. <br><br><pre> <code class="cs hljs">Inputs inputs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SampleInputs(); InputMessage input_msg; input_msg.start_tick_number = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; input_msg.inputs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Inputs&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> tick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; tick &lt;= <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick_number; ++tick) { input_msg.inputs.Add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_input_buffer[tick % <span class="hljs-number"><span class="hljs-number">1024</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SendToServer(input_msg);</code> </pre> <br>  A mensagem de entrada enviada pelo cliente agora cont√©m uma lista de dados de entrada, n√£o apenas um item.  A pe√ßa com o n√∫mero da medida obt√©m um novo valor - agora esse √© o n√∫mero da medida da primeira entrada nesta lista. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableInputMessages()) { InputMessage input_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetInputMessage(); <span class="hljs-comment"><span class="hljs-comment">// message contains an array of inputs, calculate what tick the final one is uint max_tick = input_msg.start_tick_number + (uint)input_msg.inputs.Count - 1; // if that tick is greater than or equal to the current tick we're on, then it // has inputs which are new if (max_tick &gt;= server_tick_number) { // there may be some inputs in the array that we've already had, // so figure out where to start uint start_i = server_tick_number &gt; input_msg.start_tick_number ? (server_tick_number - input_msg.start_tick_number) : 0; // run through all relevant inputs, and step player forward Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); for (int i = (int)start_i; i &lt; input_msg.inputs.Count; ++i) { this.AddForcesToPlayer(rigidbody, input_msg.inputs[i]); Physics.Simulate(Time.fixedDeltaTime); } server_tick_number = max_tick + 1; } }</span></span></code> </pre> <br>  Quando o servidor recebe uma mensagem de entrada, ele sabe o n√∫mero da medida da primeira entrada e a quantidade de dados de entrada na mensagem.  Portanto, ele pode calcular a medida da √∫ltima entrada na mensagem.  Se essa √∫ltima medida for maior ou igual ao n√∫mero da medida do servidor, ele saber√° que a mensagem cont√©m pelo menos uma entrada que o servidor ainda n√£o viu.  Nesse caso, simula todos os novos dados de entrada. <br><br>  Voc√™ deve ter notado que, <em>se</em> limitarmos a quantidade de dados de entrada redundantes na mensagem de entrada, com um n√∫mero suficientemente grande de mensagens de entrada perdidas, teremos uma lacuna de simula√ß√£o entre o servidor e o cliente.  Ou seja, o servidor pode simular a medida 100, enviar uma mensagem de status para iniciar a medida 101 e receber uma mensagem de entrada come√ßando na medida 105. No c√≥digo acima, o servidor passar√° para 105, n√£o tentar√° simular medidas intermedi√°rias com base nos dados de entrada conhecidos mais recentes.  Se voc√™ precisa, depende da sua decis√£o e qual deve ser o jogo.  Pessoalmente, n√£o for√ßaria o servidor a especular e mover o player no mapa devido ao mau estado da rede.  Eu acredito que √© melhor deixar o player no lugar at√© que a conex√£o seja restaurada. <br><br>  Na demonstra√ß√£o ‚ÄúZen of Physics em Rede‚Äù, h√° uma fun√ß√£o para enviar ‚Äúmovimentos importantes‚Äù pelo cliente, ou seja, ele envia dados de entrada redundantes apenas quando diferem da entrada transmitida anteriormente.  Isso pode ser chamado de compacta√ß√£o delta de entrada e, com ela, voc√™ pode reduzir ainda mais o tamanho das mensagens de entrada.  Mas at√© agora n√£o o fiz, porque nesta demonstra√ß√£o n√£o h√° otimiza√ß√£o do carregamento da rede. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XWUsdlNUG5Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Antes de enviar dados de entrada redundantes: quando 25% dos pacotes s√£o perdidos, o movimento do cubo √© lento e se contrai, e continua sendo jogado de volta.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ETFdFAB3s9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Ap√≥s o envio de dados de entrada redundantes: com uma perda de 25% dos pacotes, ainda h√° uma corre√ß√£o de espasmos, mas os cubos se movem a uma velocidade aceit√°vel.</i> <br><br><h3>  Frequ√™ncia Vari√°vel de Instant√¢neo </h3><br>  Nesta demonstra√ß√£o, a frequ√™ncia com que o servidor envia capturas instant√¢neas para o cliente varia.  Com uma frequ√™ncia reduzida, o cliente precisar√° de mais tempo para receber a corre√ß√£o do servidor.  Portanto, quando o cliente est√° errado na previs√£o, antes de receber uma mensagem de status, ele pode se desviar ainda mais, o que levar√° a uma corre√ß√£o mais percept√≠vel.  Com uma alta frequ√™ncia de instant√¢neos, a perda de pacotes √© muito menos importante, portanto, o cliente n√£o precisa esperar muito tempo para o pr√≥ximo instant√¢neo ser recebido. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ukyFYNfvyDQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Frequ√™ncia de instant√¢neo 64 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yQdriQIUnkU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Frequ√™ncia de instant√¢neo 16 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RJPah4ucpF0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Frequ√™ncia de instant√¢neo 2 Hz</i> <br><br>  Obviamente, quanto maior a frequ√™ncia de snapshots, melhor, ent√£o voc√™ deve envi√°-los o mais r√°pido poss√≠vel.  Mas isso tamb√©m depende da quantidade de tr√°fego adicional, seu custo, a disponibilidade de servidores dedicados, os custos de computa√ß√£o dos servidores e assim por diante. <br><br><h3>  Corre√ß√£o de suaviza√ß√£o </h3><br>  Criamos previs√µes incorretas e obtemos corre√ß√µes bruscas com mais frequ√™ncia do que gostar√≠amos.  Sem acesso adequado √† integra√ß√£o do Unity / PhysX, dificilmente posso depurar essas previs√µes incorretas.  Eu j√° disse isso antes, mas repito mais uma vez - se voc√™ encontrar algo relacionado √† f√≠sica, no qual eu esteja errado, me avise. <br><br>  Eu contornei a solu√ß√£o para esse problema, encobrindo as rachaduras com uma boa e velha suaviza√ß√£o!  Quando ocorre uma corre√ß√£o, o cliente simplesmente suaviza a posi√ß√£o e a rota√ß√£o do player na dire√ß√£o do estado correto para v√°rios quadros.  O pr√≥prio cubo f√≠sico √© corrigido instantaneamente (√© invis√≠vel), mas temos um segundo cubo apenas para exibi√ß√£o, que permite suaviza√ß√£o. <br><br><pre> <code class="cs hljs">Vector3 position_error = state_msg.position - predicted_state.position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotation_error = <span class="hljs-number"><span class="hljs-number">1.f</span></span> - Quaternion.Dot(state_msg.rotation, predicted_state.rotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position_error.sqrMagnitude &gt; <span class="hljs-number"><span class="hljs-number">0.0000001f</span></span> || rotation_error &gt; <span class="hljs-number"><span class="hljs-number">0.00001f</span></span>) { Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); <span class="hljs-comment"><span class="hljs-comment">// capture the current predicted pos for smoothing Vector3 prev_pos = player_rigidbody.position + this.client_pos_error; Quaternion prev_rot = player_rigidbody.rotation * this.client_rot_error; // rewind &amp; replay player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } // if more than 2ms apart, just snap if ((prev_pos - player_rigidbody.position).sqrMagnitude &gt;= 4.0f) { this.client_pos_error = Vector3.zero; this.client_rot_error = Quaternion.identity; } else { this.client_pos_error = prev_pos - player_rigidbody.position; this.client_rot_error = Quaternion.Inverse(player_rigidbody.rotation) * prev_rot; } }</span></span></code> </pre> <br>  Quando ocorre uma previs√£o incorreta, o cliente rastreia a diferen√ßa de posi√ß√£o / rota√ß√£o ap√≥s a corre√ß√£o.  Se a dist√¢ncia total da corre√ß√£o da posi√ß√£o for superior a 2 metros, o cubo simplesmente se mover√° rapidamente - a suaviza√ß√£o ainda pareceria ruim, portanto, pelo menos, retorne ao estado correto o mais r√°pido poss√≠vel. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error *= <span class="hljs-number"><span class="hljs-number">0.9f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error = Quaternion.Slerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error, Quaternion.identity, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.position = player_rigidbody.position + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.rotation = player_rigidbody.rotation * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error;</code> </pre> <br>  Em cada quadro, o cliente executa lerp / slerp em 10% para a posi√ß√£o / rota√ß√£o correta. Essa √© uma abordagem padr√£o da lei de pot√™ncia para calcular a m√©dia de movimento.  Depende da taxa de quadros, mas para os fins de nossa demonstra√ß√£o, isso √© suficiente. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AQ3bMh0OQig" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Atraso de 250 ms</i> <i><br></i>  <i>Perdeu 10% dos pacotes</i> <i><br></i>  <i>Sem suaviza√ß√£o, a corre√ß√£o √© muito percept√≠vel</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2jhg8OJdqXY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Atraso de 250 ms</i> <i><br></i>  <i>Perdeu 10% dos pacotes</i> <i><br></i>  <i>Com a suaviza√ß√£o, a corre√ß√£o √© muito mais dif√≠cil de perceber.</i> <br><br>  O resultado final funciona muito bem, quero criar uma vers√£o que realmente envie pacotes, em vez de imit√°-los.  Mas pelo menos essa √© uma prova de conceito para um sistema de previs√£o do lado do cliente com objetos f√≠sicos reais no Unity sem a necessidade de plug-ins f√≠sicos e similares. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt432190/">https://habr.com/ru/post/pt432190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt432180/index.html">Como impulsionar sua carreira atrav√©s do GitHub</a></li>
<li><a href="../pt432182/index.html">Recolhemos correio sem sms e registo</a></li>
<li><a href="../pt432184/index.html">Identidades de problemas entre testadores</a></li>
<li><a href="../pt432186/index.html">Usando STP para criar canais p2p</a></li>
<li><a href="../pt432188/index.html">Hackers do APT28 atacaram caixas de e-mail de centenas de funcion√°rios do minist√©rio tcheco</a></li>
<li><a href="../pt432192/index.html">4 sinais de que voc√™ n√£o est√° pronto para implementar uma solu√ß√£o de gerenciamento de projetos</a></li>
<li><a href="../pt432196/index.html">Sobre a composi√ß√£o da fun√ß√£o em JavaScript</a></li>
<li><a href="../pt432198/index.html">Delivery Manager - um novo papel no mundo √°gil</a></li>
<li><a href="../pt432200/index.html">Como Ivan investigou a convers√£o de estandes</a></li>
<li><a href="../pt432202/index.html">Gerando tipos de personagem em tempo real (ou maluco com Rust)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>