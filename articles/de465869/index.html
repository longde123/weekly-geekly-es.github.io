<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÖæÔ∏è üñêÔ∏è üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø Konvertieren polygonaler Modelle in Grenzdarstellung: Algorithmus- und Codebeispiele ü§òüèø üíä üôÖüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den meisten Konstruktionssystemen (CAD) ist die Hauptdarstellung des simulierten Objekts die Grenzdarstellung der Geometrie oder B-rep (Grenzdarste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konvertieren polygonaler Modelle in Grenzdarstellung: Algorithmus- und Codebeispiele</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465869/">  In den meisten Konstruktionssystemen (CAD) ist die Hauptdarstellung des simulierten Objekts die Grenzdarstellung der Geometrie oder B-rep (Grenzdarstellung).  CAD-Benutzer m√ºssen sich jedoch zunehmend mit Polygonmodellen auseinandersetzen, die beispielsweise durch 3D-Scannen erhalten oder aus Online-Katalogen ausgeliehen wurden. <br>  Damit sie f√ºr weitere Arbeiten geeignet sind, m√ºssen Sie das Polygonnetz in ein B-Rep-Modell konvertieren.  Und das ist gar nicht so einfach. <br>  Wir haben die Softwarekomponente C3D B-Shaper entwickelt, die in das Designsystem integriert ist und polygonale Modelle in eine Grenzdarstellung konvertiert.  In diesem Beitrag zeigen wir den Konvertierungsalgorithmus und Implementierungsbeispiele in C ++. <br><br><img src="https://habrastorage.org/webt/df/p5/gz/dfp5gzfpczrbjte9f0gy-e-i0x0.png" alt="Bild"><br><a name="habracut"></a><br><br>  Was ist das Hauptproblem von polygonalen Modellen in Bezug auf CAD?  Herk√∂mmliche Werkzeuge k√∂nnen nicht auf sie angewendet werden - um Boolesche Operationen auszuf√ºhren, Fasen und Verrundungen zu konstruieren, Projektionen und Schnitte zu erhalten.  Wenn die Verwendung des B-rep-Modells zum Erstellen seiner polygonalen Darstellung recht einfach ist (dies erfolgt mithilfe der Triangulation), ist die inverse Transformation viel schwieriger.  Es treten eine Reihe von Problemen auf - die Erkennung von Oberfl√§chen verschiedener Typen (einschlie√ülich Freiformfl√§chen), das Vorhandensein von Rauschen, die beispielsweise f√ºr 3D-Scanergebnisse charakteristisch sind. <br><br>  Im neuen SDK haben wir einen dreistufigen Mechanismus zur Umwandlung des polygonalen Modells in B-rep implementiert: Segmentierung, Oberfl√§chenrekonstruktion, Konstruktion des B-rep-Modells.  Im Allgemeinen wird angenommen, dass der Prozess iterativ ist: Wenn der Benutzer aus irgendeinem Grund mit dem Ergebnis nicht zufrieden ist, kann er die erforderlichen Korrektur√§nderungen in den Phasen der Segmentierung und Rekonstruktion von Oberfl√§chen vornehmen. <br><br><img src="https://habrastorage.org/webt/pq/me/vz/pqmevzxv9fib3_wju48vzznszci.png" alt="Bild"><br>  <i>Das Schema zum Konvertieren einer polygonalen Darstellung in eine Grenze</i> <br><br>  Bevor der Konvertierungsprozess in B-rep eingeleitet wird, muss in einigen F√§llen die Qualit√§t des urspr√ºnglichen Polygonnetzes verbessert werden: Koordinieren Sie die Richtungen der Normalen an benachbarten Polygonen, beseitigen Sie ‚ÄûL√∂cher‚Äú und wenden Sie Gl√§ttungsalgorithmen an, wenn im urspr√ºnglichen Netz Rauschen vorhanden ist. <br><br><h1>  <font color="#00B2FF">Polygonsegmentierung</font> </h1><br>  In der ersten Phase wird der anf√§ngliche Satz von Netzpolygonen in Teilmengen (Segmente) klassifiziert.  Informationen √ºber die Normalen an den Eckpunkten des Netzes erm√∂glichen eine Segmentierung erster Ordnung und stellen dadurch die anf√§ngliche Netzaufteilung sicher sowie die Klassifizierung flacher oder stark gekr√ºmmter Bereiche. <br><br>  Die anf√§ngliche Vernetzung basiert auf der Definition von sogenannten "scharfen" Kanten - solchen Kanten zwischen zwei dreieckigen Polygonen, deren Winkel zwischen den durchschnittlichen Normalen einen bestimmten vorbestimmten Wert √ºberschreitet. <br><br>  Die Segmentierung zweiter Ordnung analysiert das Gitter gem√§√ü seinen Hauptkr√ºmmungen, was eine ausreichende Grundlage f√ºr die Klassifizierung von Elementarfl√§chen bietet.  Bei der Berechnung der Kr√ºmmungen an den Eckpunkten des Gitters verwendeten wir die Ergebnisse von Mayer (Mark Meyer, Mathieu Desbrun, Peter Schroder und Alan H. Barr, Operatoren f√ºr diskrete Differentialgeometrie f√ºr dreieckige 2-Mannigfaltigkeiten, Visualisierung und Mathematik III, 2003), um das diskrete Differential zu bestimmen Operator f√ºr triangulierte Bereiche: F√ºr jeden Scheitelpunkt des urspr√ºnglichen Netzes betrachten wir eine Reihe benachbarter Scheitelpunkte, die einem bestimmten Scheitelpunkt durch eine Kante zugeordnet sind.  Dann wird ein diskreter Operator <i>K</i> f√ºr einen gegebenen Scheitelpunkt berechnet, auf dessen Grundlage die durchschnittliche Normal-, durchschnittliche <i>K <sub>H -</sub></i> und Gau√üsche <i>K <sub>G</sub></i> -Kr√ºmmung am Scheitelpunkt des Gitters bestimmt werden. <br><br><img src="https://habrastorage.org/webt/rz/ni/kf/rznikfmo-7jumijuvqo4pjgmurs.png" alt="Bild"><br>  <i>Zur Definition eines diskreten Differentialoperators f√ºr triangulierte Dom√§nen</i> <br><br>  Somit wird der Kr√ºmmungstensor f√ºr jeden Scheitelpunkt des Gitters berechnet, dessen Eigenwerte die gew√ºnschten Hauptkr√ºmmungen <i>K <sub>1</sub></i> und <i>K <sub>2 sind</sub></i> , und die Eigenvektoren sind die Hauptrichtungen der Kr√ºmmungs√§nderung. <br><br>  Als n√§chstes werden die Maschenscheitelpunkte gem√§√ü den darin berechneten Werten der Hauptkr√ºmmungen <i>K <sub>1</sub></i> und <i>K <sub>2</sub></i> klassifiziert.  Der Scheitelpunktklassifizierungsalgorithmus basiert auf dem k-Mittelwert-Verfahren, d. H. Auf der Minimierung der gesamten quadratischen Abweichung von Clusterpunkten von den Zentren dieser Cluster.  Infolgedessen ist am Ausgang des Algorithmus jeder Scheitelpunkt des Gitters einem bestimmten Cluster zugeordnet <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>i</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.569ex" height="2.057ex" viewBox="0 -780.1 1106 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/465869/&amp;usg=ALkJrhir6p_Br_5eYkGtjKrmctyfwuwYbg#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/465869/&amp;usg=ALkJrhir6p_Br_5eYkGtjKrmctyfwuwYbg#MJMATHI-69" x="760" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>i</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> Ci </script>  und ein Paar von Kr√ºmmungen (Cluster-Zentrum) (L. Guillaume, "Curvature Tensor Based Triangle Mesh Segmentation with Boundary Rectification", Proceedings Computer Graphics International (CGI), 2004). <br><br><img src="https://habrastorage.org/webt/rr/sf/zg/rrsfzgnpnkdjbk6tkaj2huigmno.png" alt="Bild"><br>  <i>Klassifizierung der Eckpunkte eines Polygonnetzes im Kr√ºmmungsraum</i> <br><br>  Nach dem Klassifizieren der Eckpunkte des Polygonnetzes m√ºssen die Polygone klassifiziert werden.  Zu Beginn dieses Vorgangs wird ein dreieckiges Polygon ausgew√§hlt, f√ºr das die Kr√ºmmung als vollst√§ndig definiert betrachtet werden kann (alle drei Eckpunkte geh√∂ren zu einem Cluster oder zwei Eckpunkte liegen auf einer scharfen Kante).  Dieses Polygon wird als neues Segment deklariert, und die rekursive Prozedur zum Erweitern des Segments beginnt damit: F√ºr jedes dreieckige Polygon werden die angrenzenden Polygone ber√ºcksichtigt, sofern die Kante zwischen ihnen nicht ‚Äûscharf‚Äú ist. <br><br>  Wenn der Scheitelpunkt eines benachbarten Polygons gegen√ºber der gemeinsamen Kante auf einer scharfen Kante liegt oder zum selben Cluster geh√∂rt, wird dieses Polygon dem Segment hinzugef√ºgt.  Der Vorgang wird wiederholt, bis alle Polygone dieses Rasters angezeigt werden.  So sieht der implementierte Netzsegmentierungsmechanismus aus. <br><br><img src="https://habrastorage.org/webt/dm/19/to/dm19tosiw5tu-_p97ufs380khyy.png" alt="Bild"><br>  <i>Segmentierungsmechanismus f√ºr Polygonnetze</i> <br><br>  Am Ende des Segmentbildungsvorgangs wird ein spezieller Algorithmus zum Zusammenf√ºgen benachbarter Segmente durchgef√ºhrt, um eine √ºberm√§√üige Segmentierung des betreffenden Netzes zu vermeiden. <br><br><h1>  <font color="#00B2FF">Oberfl√§chenerkennung</font> </h1><br>  In der zweiten Stufe muss jedem der Segmente eine bestimmte Oberfl√§che zugeordnet werden, die sich ihrer Form mit einer bestimmten Genauigkeit ann√§hert.  Zun√§chst bestimmen die Werte der Hauptkr√ºmmungen f√ºr ein bestimmtes Segment die M√∂glichkeit, die Form eines Segments durch eine Elementarfl√§che zu beschreiben: <br><ul><li>  Ebene: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = 0 </li><li>  Kugel: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = <i>K</i> &gt; 0 </li><li>  Zylinder: <i>k <sub>1</sub></i> = <i>K</i> &gt; 0, <i>k <sub>2</sub></i> = 0 </li><li>  Kegel: <i>k <sub>1</sub></i> ‚àà [ <i>a</i> , <i>b</i> ], <i>k <sub>2</sub></i> = 0 </li><li>  Torus: <i>k <sub>1</sub></i> = <i>K</i> , <i>k <sub>2</sub></i> ‚àà [ <i>a</i> , <i>b</i> ] </li></ul><br><br>  Wenn keine der Elementarfl√§chen zur Beschreibung eines Segments geeignet ist, versucht der Algorithmus, die Extrusions- oder Rotationsfl√§che zu erkennen.  Wenn es letztendlich nicht m√∂glich war, eine analytische Oberfl√§che zur Beschreibung der Form des Segments auszuw√§hlen, wird eine NURBS-Oberfl√§che daf√ºr erstellt. <br><br>  Elementare Oberfl√§chen werden mithilfe von Methoden zum Anpassen einfacher geometrischer Objekte an eine Reihe von Punkten erstellt.  Um den Kreis und die Kugel anzupassen, wird die Methode der kleinsten Quadrate verwendet, um die Ebene anzupassen - die Hauptkomponentenmethode.  Jede rekonstruierte Oberfl√§che wird auf √úbereinstimmung mit einem Segment f√ºr eine gegebene Erkennungsgenauigkeit √ºberpr√ºft. <br><br>  Aus Gr√ºnden der Klarheit haben wir die erkannten Oberfl√§chen in verschiedenen Farben lackiert: Ebenen - blau, Zylinder - rot, Kugeln - gr√ºn, Kegel - gelb, tori - lila. <br><br><img src="https://habrastorage.org/webt/az/z_/jh/azz_jhkz6xkn0ffe8z95dhrfzum.png" alt="Bild"><br>  <i>Originales Polygonnetz (links) und segmentiertes Netz (rechts) mit auf Segmenten erkannten Fl√§chen</i> <br><br><h1>  <font color="#00B2FF">Erstellen eines B-rep-Modells</font> </h1><br>  Die letzte Stufe der Transformation ist die Konstruktion eines B-rep-Modells basierend auf der Segmentierung der erkannten Oberfl√§chen.  Bei diesem Ansatz wird ein Graph benachbarter Regionen auf der Basis segmentierter Regionen erstellt, der die Topologie des Modells widerspiegelt und als Grundlage f√ºr die Erstellung des endg√ºltigen B-rep-Modells dient. <br><br>  Im Gegensatz zu den vorherigen Konvertierungsstufen erfolgt die B-Rep-Montage in einem vollautomatischen Modus: Die Schnittlinien benachbarter rekonstruierter Oberfl√§chen werden gefunden, die Kanten der Fl√§chen werden darauf aufgebaut, die Fl√§chen selbst und schlie√ülich wird die B-Rep-Schale zusammengebaut. <br><br><img src="https://habrastorage.org/webt/om/i7/zw/omi7zwcrrc3qzdvyfkvzphvsyra.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/is/zt/nw/isztnwvohh4t9nzgj4pusg9awek.png" alt="Bild"><br>  <i>Originales Polygonnetz (links) und B-Rep-Modell (rechts)</i> <br><br>  Es ist jedoch nicht immer m√∂glich, eine topologisch korrekte Schale zu konstruieren.  Nehmen wir als Beispiel f√ºr eine solche Situation an, dass wir w√§hrend der Rekonstruktion von Oberfl√§chen zwei Oberfl√§chen haben - einen Zylinder und eine Ebene, und ihre Position im Raum nahe an der Tangente liegt.  Aufgrund von Fehlern bei der Rekonstruktion der Oberfl√§chen ihrer Schnittpunkte gibt es m√∂glicherweise √ºberhaupt keine.  In solchen F√§llen kann die Schale mit einigen Fehlern aufgebaut sein, die der Benutzer durch ordnungsgem√§√ües Anpassen der Oberfl√§chenparameter beheben kann. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PQ3z2Rjdpdc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h1>  <font color="#00B2FF">Arten von polygonalen Modellen und die Wahl des Konvertierungsmodus</font> </h1><br>  Heute gibt es in der polygonalen Darstellung mehrere Hauptquellen f√ºr Modelle: <br><ul><li>  Online-Kataloge, Datenbanken von 3D-Modellen im Polygonformat (STL, VRML, OBJ), z. B. 3D Warehouse, Cults 3D usw. </li><li>  3D-Scan-Ergebnisse </li><li>  Ergebnisse der topologischen Modelloptimierung durch CAE-Algorithmen. </li></ul><br><br>  Polygonale Modelle aus diesen Quellen k√∂nnen in zwei Gruppen unterteilt werden: Das erste umfasst Modelle, die Triangulationen von B-rep-Objekten sind, und das zweite - alle anderen.  Die charakteristischen Unterschiede der ersten Gruppe sind das Fehlen von Rauschen im Polygonnetz und das √úberwiegen analytisch definierter Oberfl√§chen.  Daher erfolgt die Umstellung auf die B-rep-Modelle aus der ersten Gruppe entweder im vollautomatischen Modus oder mit minimalem Benutzereingriff. <br><br>  Polygonale Gitter der Modelle der zweiten Gruppe implizieren eine dichtere interaktive Interaktion mit dem Benutzer.  Aus diesem Grund haben wir im C3D B-Shaper zun√§chst zwei Betriebsarten festgelegt - vollautomatisch und interaktiv. <br><br>  Die Wahl eines bestimmten Modus h√§ngt auch vom Zweck der Transformation ab: In einigen F√§llen kann die topologische Konnektivit√§t der Elemente der resultierenden Schale sowie deren Richtigkeit vernachl√§ssigt werden.  Ein solcher Ansatz ist beispielsweise akzeptabel, um das Rendern in einer BIM-Anwendung zu optimieren, wenn der Benutzer dem aktuellen Modell des Raums beliebige Innenelemente hinzuf√ºgen kann.  Andererseits ist es f√ºr Reverse Engineering-Aufgaben erforderlich, die genaueste Kopie des Originalmodells zu erhalten, um beispielsweise die Ausrichtung der Zylinder mit einer bestimmten Genauigkeit beizubehalten, die tangentiale Position eines Oberfl√§chenpaares sicherzustellen und infolgedessen die korrekte Topologie des Modells zu erhalten. In diesem Fall k√∂nnen Sie nicht ohne Benutzereingriff auskommen Konvertierungsprozess. <br><br>  Die automatische Konvertierungsschnittstelle C3D B-Shaper wird durch die folgenden Funktionen dargestellt, die das Eingaberaster und die Konvertierungseinstellungen als Eingabe akzeptieren: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertMeshToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbMesh &amp; mesh, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertCollectionToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbCollection &amp; collection, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>;</code> </pre> <br><br>  Die Konvertierungseinstellungen umfassen den Erkennungsgenauigkeitswert, d.h.  der maximal zul√§ssige Abstand der Eckpunkte des Polygonnetzes innerhalb der Grenzen dieses Segments zur erkannten Oberfl√§che.  Diese Genauigkeit kann absolut oder relativ sein: Bei Verwendung der relativen Genauigkeit wird die Abweichung der Fl√§chen des K√∂rpers vom Raster in Bezug auf die Gr√∂√üe des Modells √ºberpr√ºft. <br><br>  Der Benutzer hat auch die M√∂glichkeit, den Erkennungsmodus zu wechseln, wodurch Sie die Oberfl√§chentypen w√§hrend der Rekonstruktion steuern k√∂nnen. <br>  Die MbMeshProcessor-Klassenschnittstelle bietet erweiterte Funktionen zum Verwalten von Segmentierungs- und Oberfl√§chenerkennungsprozessen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MbMeshProcessor</span></span></span><span class="hljs-class"> {</span></span> .. <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ‚Äú‚Äù . void SetUseMeshSmoothing( bool useSmoothing ); //   . const MbCollection &amp; GetSegmentedMesh(); MbResultType SegmentMesh( bool createSurfaces = true ); void ResetSegmentation(); void UniteSegments( size_t firstSegmentIdx, size_t secondSegmentIdx ); MbResultType SegmentMeshBySeparators( const std::vector&lt;std::vector&lt;uint&gt;&gt; &amp; sep ); //   . void FitSurfaceToSegment( size_t idxSegment ); void FitSurfaceToSegment( size_t idxSegment, MbeSpaceType surfaceType ); const MbSurface * GetSegmentSurface( size_t idxSegment ) const; //  B-rep . MbResultType CreateBRepShell( MbFaceShell *&amp; pShell ); .. }</span></span></code> </pre> <br><br>  Um beispielsweise die Ergebnisse der automatischen Segmentierung zu korrigieren, werden Werkzeuge zum Kombinieren, Trennen usw. von Segmenten bereitgestellt.  Der Benutzer kann eine Oberfl√§che eines bestimmten Typs in ein Segment eingeben sowie Parameter f√ºr eine bereits erkannte Oberfl√§che √§ndern. <br><br><h1>  <font color="#00B2FF">Was passiert jetzt?</font> </h1><br>  Im Juli haben wir die erste Version der Komponente ver√∂ffentlicht und entwickeln sie nun in mehreren Bereichen weiter: automatische Segmentierungsalgorithmen, Werkzeuge zur Segmentierungsbearbeitung, Erstellen von Freiformfl√§chen (NURBS) basierend auf einem Segment, Verbesserung der Verarbeitungsqualit√§t von B-Rep-Shells. <br><br>  Interessierte Entwickler k√∂nnen den C3D B-Shaper testen.  Die Komponente wird auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anfrage</a> auf unserer Website drei Monate lang kostenlos zur Verf√ºgung gestellt. <br><br> <a href=""><img src="https://habrastorage.org/webt/k8/za/vg/k8zavgo-xihodwssql3y-aqlmam.jpeg"></a>  Autor - Andrey Tumanin, Ph.D., Mathematiker-Programmierer von C3D Labs </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465869/">https://habr.com/ru/post/de465869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465857/index.html">Anti-Googler: Webbenutzer unternehmen radikale Schritte, um ihre Daten zu sch√ºtzen</a></li>
<li><a href="../de465859/index.html">Nachhaltige neuronale maschinelle √úbersetzung</a></li>
<li><a href="../de465861/index.html">Vertrauliche "Wolke". Wir suchen nach einer Alternative zu offenen L√∂sungen</a></li>
<li><a href="../de465863/index.html">Kurz gesagt, wie man MIDI f√ºr das Web verwendet</a></li>
<li><a href="../de465867/index.html">Wir programmieren die Kassiererin neu und drucken darauf Keanu Reeves</a></li>
<li><a href="../de465873/index.html">Das Problem, das Sie l√∂sen, ist wichtiger als der Code, den Sie schreiben</a></li>
<li><a href="../de465877/index.html">Informationssicherheit aus der Cloud: Funktionsweise der Unified Cybersecurity Services-Plattform</a></li>
<li><a href="../de465879/index.html">Und was ist mit Krippen?</a></li>
<li><a href="../de465885/index.html">Wie werde ich ein f√ºhrender Scrum Master und rocke das Team?</a></li>
<li><a href="../de465889/index.html">Wie wir Energieeffizienz betrieben haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>