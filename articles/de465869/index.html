<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🅾️ 🖐️ 🏴󠁧󠁢󠁳󠁣󠁴󠁿 Konvertieren polygonaler Modelle in Grenzdarstellung: Algorithmus- und Codebeispiele 🤘🏿 💊 🙅🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den meisten Konstruktionssystemen (CAD) ist die Hauptdarstellung des simulierten Objekts die Grenzdarstellung der Geometrie oder B-rep (Grenzdarste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konvertieren polygonaler Modelle in Grenzdarstellung: Algorithmus- und Codebeispiele</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465869/">  In den meisten Konstruktionssystemen (CAD) ist die Hauptdarstellung des simulierten Objekts die Grenzdarstellung der Geometrie oder B-rep (Grenzdarstellung).  CAD-Benutzer müssen sich jedoch zunehmend mit Polygonmodellen auseinandersetzen, die beispielsweise durch 3D-Scannen erhalten oder aus Online-Katalogen ausgeliehen wurden. <br>  Damit sie für weitere Arbeiten geeignet sind, müssen Sie das Polygonnetz in ein B-Rep-Modell konvertieren.  Und das ist gar nicht so einfach. <br>  Wir haben die Softwarekomponente C3D B-Shaper entwickelt, die in das Designsystem integriert ist und polygonale Modelle in eine Grenzdarstellung konvertiert.  In diesem Beitrag zeigen wir den Konvertierungsalgorithmus und Implementierungsbeispiele in C ++. <br><br><img src="https://habrastorage.org/webt/df/p5/gz/dfp5gzfpczrbjte9f0gy-e-i0x0.png" alt="Bild"><br><a name="habracut"></a><br><br>  Was ist das Hauptproblem von polygonalen Modellen in Bezug auf CAD?  Herkömmliche Werkzeuge können nicht auf sie angewendet werden - um Boolesche Operationen auszuführen, Fasen und Verrundungen zu konstruieren, Projektionen und Schnitte zu erhalten.  Wenn die Verwendung des B-rep-Modells zum Erstellen seiner polygonalen Darstellung recht einfach ist (dies erfolgt mithilfe der Triangulation), ist die inverse Transformation viel schwieriger.  Es treten eine Reihe von Problemen auf - die Erkennung von Oberflächen verschiedener Typen (einschließlich Freiformflächen), das Vorhandensein von Rauschen, die beispielsweise für 3D-Scanergebnisse charakteristisch sind. <br><br>  Im neuen SDK haben wir einen dreistufigen Mechanismus zur Umwandlung des polygonalen Modells in B-rep implementiert: Segmentierung, Oberflächenrekonstruktion, Konstruktion des B-rep-Modells.  Im Allgemeinen wird angenommen, dass der Prozess iterativ ist: Wenn der Benutzer aus irgendeinem Grund mit dem Ergebnis nicht zufrieden ist, kann er die erforderlichen Korrekturänderungen in den Phasen der Segmentierung und Rekonstruktion von Oberflächen vornehmen. <br><br><img src="https://habrastorage.org/webt/pq/me/vz/pqmevzxv9fib3_wju48vzznszci.png" alt="Bild"><br>  <i>Das Schema zum Konvertieren einer polygonalen Darstellung in eine Grenze</i> <br><br>  Bevor der Konvertierungsprozess in B-rep eingeleitet wird, muss in einigen Fällen die Qualität des ursprünglichen Polygonnetzes verbessert werden: Koordinieren Sie die Richtungen der Normalen an benachbarten Polygonen, beseitigen Sie „Löcher“ und wenden Sie Glättungsalgorithmen an, wenn im ursprünglichen Netz Rauschen vorhanden ist. <br><br><h1>  <font color="#00B2FF">Polygonsegmentierung</font> </h1><br>  In der ersten Phase wird der anfängliche Satz von Netzpolygonen in Teilmengen (Segmente) klassifiziert.  Informationen über die Normalen an den Eckpunkten des Netzes ermöglichen eine Segmentierung erster Ordnung und stellen dadurch die anfängliche Netzaufteilung sicher sowie die Klassifizierung flacher oder stark gekrümmter Bereiche. <br><br>  Die anfängliche Vernetzung basiert auf der Definition von sogenannten "scharfen" Kanten - solchen Kanten zwischen zwei dreieckigen Polygonen, deren Winkel zwischen den durchschnittlichen Normalen einen bestimmten vorbestimmten Wert überschreitet. <br><br>  Die Segmentierung zweiter Ordnung analysiert das Gitter gemäß seinen Hauptkrümmungen, was eine ausreichende Grundlage für die Klassifizierung von Elementarflächen bietet.  Bei der Berechnung der Krümmungen an den Eckpunkten des Gitters verwendeten wir die Ergebnisse von Mayer (Mark Meyer, Mathieu Desbrun, Peter Schroder und Alan H. Barr, Operatoren für diskrete Differentialgeometrie für dreieckige 2-Mannigfaltigkeiten, Visualisierung und Mathematik III, 2003), um das diskrete Differential zu bestimmen Operator für triangulierte Bereiche: Für jeden Scheitelpunkt des ursprünglichen Netzes betrachten wir eine Reihe benachbarter Scheitelpunkte, die einem bestimmten Scheitelpunkt durch eine Kante zugeordnet sind.  Dann wird ein diskreter Operator <i>K</i> für einen gegebenen Scheitelpunkt berechnet, auf dessen Grundlage die durchschnittliche Normal-, durchschnittliche <i>K <sub>H -</sub></i> und Gaußsche <i>K <sub>G</sub></i> -Krümmung am Scheitelpunkt des Gitters bestimmt werden. <br><br><img src="https://habrastorage.org/webt/rz/ni/kf/rznikfmo-7jumijuvqo4pjgmurs.png" alt="Bild"><br>  <i>Zur Definition eines diskreten Differentialoperators für triangulierte Domänen</i> <br><br>  Somit wird der Krümmungstensor für jeden Scheitelpunkt des Gitters berechnet, dessen Eigenwerte die gewünschten Hauptkrümmungen <i>K <sub>1</sub></i> und <i>K <sub>2 sind</sub></i> , und die Eigenvektoren sind die Hauptrichtungen der Krümmungsänderung. <br><br>  Als nächstes werden die Maschenscheitelpunkte gemäß den darin berechneten Werten der Hauptkrümmungen <i>K <sub>1</sub></i> und <i>K <sub>2</sub></i> klassifiziert.  Der Scheitelpunktklassifizierungsalgorithmus basiert auf dem k-Mittelwert-Verfahren, d. H. Auf der Minimierung der gesamten quadratischen Abweichung von Clusterpunkten von den Zentren dieser Cluster.  Infolgedessen ist am Ausgang des Algorithmus jeder Scheitelpunkt des Gitters einem bestimmten Cluster zugeordnet <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>i</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.569ex" height="2.057ex" viewBox="0 -780.1 1106 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/465869/&amp;usg=ALkJrhir6p_Br_5eYkGtjKrmctyfwuwYbg#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/465869/&amp;usg=ALkJrhir6p_Br_5eYkGtjKrmctyfwuwYbg#MJMATHI-69" x="760" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>i</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> Ci </script>  und ein Paar von Krümmungen (Cluster-Zentrum) (L. Guillaume, "Curvature Tensor Based Triangle Mesh Segmentation with Boundary Rectification", Proceedings Computer Graphics International (CGI), 2004). <br><br><img src="https://habrastorage.org/webt/rr/sf/zg/rrsfzgnpnkdjbk6tkaj2huigmno.png" alt="Bild"><br>  <i>Klassifizierung der Eckpunkte eines Polygonnetzes im Krümmungsraum</i> <br><br>  Nach dem Klassifizieren der Eckpunkte des Polygonnetzes müssen die Polygone klassifiziert werden.  Zu Beginn dieses Vorgangs wird ein dreieckiges Polygon ausgewählt, für das die Krümmung als vollständig definiert betrachtet werden kann (alle drei Eckpunkte gehören zu einem Cluster oder zwei Eckpunkte liegen auf einer scharfen Kante).  Dieses Polygon wird als neues Segment deklariert, und die rekursive Prozedur zum Erweitern des Segments beginnt damit: Für jedes dreieckige Polygon werden die angrenzenden Polygone berücksichtigt, sofern die Kante zwischen ihnen nicht „scharf“ ist. <br><br>  Wenn der Scheitelpunkt eines benachbarten Polygons gegenüber der gemeinsamen Kante auf einer scharfen Kante liegt oder zum selben Cluster gehört, wird dieses Polygon dem Segment hinzugefügt.  Der Vorgang wird wiederholt, bis alle Polygone dieses Rasters angezeigt werden.  So sieht der implementierte Netzsegmentierungsmechanismus aus. <br><br><img src="https://habrastorage.org/webt/dm/19/to/dm19tosiw5tu-_p97ufs380khyy.png" alt="Bild"><br>  <i>Segmentierungsmechanismus für Polygonnetze</i> <br><br>  Am Ende des Segmentbildungsvorgangs wird ein spezieller Algorithmus zum Zusammenfügen benachbarter Segmente durchgeführt, um eine übermäßige Segmentierung des betreffenden Netzes zu vermeiden. <br><br><h1>  <font color="#00B2FF">Oberflächenerkennung</font> </h1><br>  In der zweiten Stufe muss jedem der Segmente eine bestimmte Oberfläche zugeordnet werden, die sich ihrer Form mit einer bestimmten Genauigkeit annähert.  Zunächst bestimmen die Werte der Hauptkrümmungen für ein bestimmtes Segment die Möglichkeit, die Form eines Segments durch eine Elementarfläche zu beschreiben: <br><ul><li>  Ebene: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = 0 </li><li>  Kugel: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = <i>K</i> &gt; 0 </li><li>  Zylinder: <i>k <sub>1</sub></i> = <i>K</i> &gt; 0, <i>k <sub>2</sub></i> = 0 </li><li>  Kegel: <i>k <sub>1</sub></i> ∈ [ <i>a</i> , <i>b</i> ], <i>k <sub>2</sub></i> = 0 </li><li>  Torus: <i>k <sub>1</sub></i> = <i>K</i> , <i>k <sub>2</sub></i> ∈ [ <i>a</i> , <i>b</i> ] </li></ul><br><br>  Wenn keine der Elementarflächen zur Beschreibung eines Segments geeignet ist, versucht der Algorithmus, die Extrusions- oder Rotationsfläche zu erkennen.  Wenn es letztendlich nicht möglich war, eine analytische Oberfläche zur Beschreibung der Form des Segments auszuwählen, wird eine NURBS-Oberfläche dafür erstellt. <br><br>  Elementare Oberflächen werden mithilfe von Methoden zum Anpassen einfacher geometrischer Objekte an eine Reihe von Punkten erstellt.  Um den Kreis und die Kugel anzupassen, wird die Methode der kleinsten Quadrate verwendet, um die Ebene anzupassen - die Hauptkomponentenmethode.  Jede rekonstruierte Oberfläche wird auf Übereinstimmung mit einem Segment für eine gegebene Erkennungsgenauigkeit überprüft. <br><br>  Aus Gründen der Klarheit haben wir die erkannten Oberflächen in verschiedenen Farben lackiert: Ebenen - blau, Zylinder - rot, Kugeln - grün, Kegel - gelb, tori - lila. <br><br><img src="https://habrastorage.org/webt/az/z_/jh/azz_jhkz6xkn0ffe8z95dhrfzum.png" alt="Bild"><br>  <i>Originales Polygonnetz (links) und segmentiertes Netz (rechts) mit auf Segmenten erkannten Flächen</i> <br><br><h1>  <font color="#00B2FF">Erstellen eines B-rep-Modells</font> </h1><br>  Die letzte Stufe der Transformation ist die Konstruktion eines B-rep-Modells basierend auf der Segmentierung der erkannten Oberflächen.  Bei diesem Ansatz wird ein Graph benachbarter Regionen auf der Basis segmentierter Regionen erstellt, der die Topologie des Modells widerspiegelt und als Grundlage für die Erstellung des endgültigen B-rep-Modells dient. <br><br>  Im Gegensatz zu den vorherigen Konvertierungsstufen erfolgt die B-Rep-Montage in einem vollautomatischen Modus: Die Schnittlinien benachbarter rekonstruierter Oberflächen werden gefunden, die Kanten der Flächen werden darauf aufgebaut, die Flächen selbst und schließlich wird die B-Rep-Schale zusammengebaut. <br><br><img src="https://habrastorage.org/webt/om/i7/zw/omi7zwcrrc3qzdvyfkvzphvsyra.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/is/zt/nw/isztnwvohh4t9nzgj4pusg9awek.png" alt="Bild"><br>  <i>Originales Polygonnetz (links) und B-Rep-Modell (rechts)</i> <br><br>  Es ist jedoch nicht immer möglich, eine topologisch korrekte Schale zu konstruieren.  Nehmen wir als Beispiel für eine solche Situation an, dass wir während der Rekonstruktion von Oberflächen zwei Oberflächen haben - einen Zylinder und eine Ebene, und ihre Position im Raum nahe an der Tangente liegt.  Aufgrund von Fehlern bei der Rekonstruktion der Oberflächen ihrer Schnittpunkte gibt es möglicherweise überhaupt keine.  In solchen Fällen kann die Schale mit einigen Fehlern aufgebaut sein, die der Benutzer durch ordnungsgemäßes Anpassen der Oberflächenparameter beheben kann. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PQ3z2Rjdpdc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h1>  <font color="#00B2FF">Arten von polygonalen Modellen und die Wahl des Konvertierungsmodus</font> </h1><br>  Heute gibt es in der polygonalen Darstellung mehrere Hauptquellen für Modelle: <br><ul><li>  Online-Kataloge, Datenbanken von 3D-Modellen im Polygonformat (STL, VRML, OBJ), z. B. 3D Warehouse, Cults 3D usw. </li><li>  3D-Scan-Ergebnisse </li><li>  Ergebnisse der topologischen Modelloptimierung durch CAE-Algorithmen. </li></ul><br><br>  Polygonale Modelle aus diesen Quellen können in zwei Gruppen unterteilt werden: Das erste umfasst Modelle, die Triangulationen von B-rep-Objekten sind, und das zweite - alle anderen.  Die charakteristischen Unterschiede der ersten Gruppe sind das Fehlen von Rauschen im Polygonnetz und das Überwiegen analytisch definierter Oberflächen.  Daher erfolgt die Umstellung auf die B-rep-Modelle aus der ersten Gruppe entweder im vollautomatischen Modus oder mit minimalem Benutzereingriff. <br><br>  Polygonale Gitter der Modelle der zweiten Gruppe implizieren eine dichtere interaktive Interaktion mit dem Benutzer.  Aus diesem Grund haben wir im C3D B-Shaper zunächst zwei Betriebsarten festgelegt - vollautomatisch und interaktiv. <br><br>  Die Wahl eines bestimmten Modus hängt auch vom Zweck der Transformation ab: In einigen Fällen kann die topologische Konnektivität der Elemente der resultierenden Schale sowie deren Richtigkeit vernachlässigt werden.  Ein solcher Ansatz ist beispielsweise akzeptabel, um das Rendern in einer BIM-Anwendung zu optimieren, wenn der Benutzer dem aktuellen Modell des Raums beliebige Innenelemente hinzufügen kann.  Andererseits ist es für Reverse Engineering-Aufgaben erforderlich, die genaueste Kopie des Originalmodells zu erhalten, um beispielsweise die Ausrichtung der Zylinder mit einer bestimmten Genauigkeit beizubehalten, die tangentiale Position eines Oberflächenpaares sicherzustellen und infolgedessen die korrekte Topologie des Modells zu erhalten. In diesem Fall können Sie nicht ohne Benutzereingriff auskommen Konvertierungsprozess. <br><br>  Die automatische Konvertierungsschnittstelle C3D B-Shaper wird durch die folgenden Funktionen dargestellt, die das Eingaberaster und die Konvertierungseinstellungen als Eingabe akzeptieren: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertMeshToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbMesh &amp; mesh, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertCollectionToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbCollection &amp; collection, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>;</code> </pre> <br><br>  Die Konvertierungseinstellungen umfassen den Erkennungsgenauigkeitswert, d.h.  der maximal zulässige Abstand der Eckpunkte des Polygonnetzes innerhalb der Grenzen dieses Segments zur erkannten Oberfläche.  Diese Genauigkeit kann absolut oder relativ sein: Bei Verwendung der relativen Genauigkeit wird die Abweichung der Flächen des Körpers vom Raster in Bezug auf die Größe des Modells überprüft. <br><br>  Der Benutzer hat auch die Möglichkeit, den Erkennungsmodus zu wechseln, wodurch Sie die Oberflächentypen während der Rekonstruktion steuern können. <br>  Die MbMeshProcessor-Klassenschnittstelle bietet erweiterte Funktionen zum Verwalten von Segmentierungs- und Oberflächenerkennungsprozessen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MbMeshProcessor</span></span></span><span class="hljs-class"> {</span></span> .. <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// “” . void SetUseMeshSmoothing( bool useSmoothing ); //   . const MbCollection &amp; GetSegmentedMesh(); MbResultType SegmentMesh( bool createSurfaces = true ); void ResetSegmentation(); void UniteSegments( size_t firstSegmentIdx, size_t secondSegmentIdx ); MbResultType SegmentMeshBySeparators( const std::vector&lt;std::vector&lt;uint&gt;&gt; &amp; sep ); //   . void FitSurfaceToSegment( size_t idxSegment ); void FitSurfaceToSegment( size_t idxSegment, MbeSpaceType surfaceType ); const MbSurface * GetSegmentSurface( size_t idxSegment ) const; //  B-rep . MbResultType CreateBRepShell( MbFaceShell *&amp; pShell ); .. }</span></span></code> </pre> <br><br>  Um beispielsweise die Ergebnisse der automatischen Segmentierung zu korrigieren, werden Werkzeuge zum Kombinieren, Trennen usw. von Segmenten bereitgestellt.  Der Benutzer kann eine Oberfläche eines bestimmten Typs in ein Segment eingeben sowie Parameter für eine bereits erkannte Oberfläche ändern. <br><br><h1>  <font color="#00B2FF">Was passiert jetzt?</font> </h1><br>  Im Juli haben wir die erste Version der Komponente veröffentlicht und entwickeln sie nun in mehreren Bereichen weiter: automatische Segmentierungsalgorithmen, Werkzeuge zur Segmentierungsbearbeitung, Erstellen von Freiformflächen (NURBS) basierend auf einem Segment, Verbesserung der Verarbeitungsqualität von B-Rep-Shells. <br><br>  Interessierte Entwickler können den C3D B-Shaper testen.  Die Komponente wird auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anfrage</a> auf unserer Website drei Monate lang kostenlos zur Verfügung gestellt. <br><br> <a href=""><img src="https://habrastorage.org/webt/k8/za/vg/k8zavgo-xihodwssql3y-aqlmam.jpeg"></a>  Autor - Andrey Tumanin, Ph.D., Mathematiker-Programmierer von C3D Labs </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465869/">https://habr.com/ru/post/de465869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465857/index.html">Anti-Googler: Webbenutzer unternehmen radikale Schritte, um ihre Daten zu schützen</a></li>
<li><a href="../de465859/index.html">Nachhaltige neuronale maschinelle Übersetzung</a></li>
<li><a href="../de465861/index.html">Vertrauliche "Wolke". Wir suchen nach einer Alternative zu offenen Lösungen</a></li>
<li><a href="../de465863/index.html">Kurz gesagt, wie man MIDI für das Web verwendet</a></li>
<li><a href="../de465867/index.html">Wir programmieren die Kassiererin neu und drucken darauf Keanu Reeves</a></li>
<li><a href="../de465873/index.html">Das Problem, das Sie lösen, ist wichtiger als der Code, den Sie schreiben</a></li>
<li><a href="../de465877/index.html">Informationssicherheit aus der Cloud: Funktionsweise der Unified Cybersecurity Services-Plattform</a></li>
<li><a href="../de465879/index.html">Und was ist mit Krippen?</a></li>
<li><a href="../de465885/index.html">Wie werde ich ein führender Scrum Master und rocke das Team?</a></li>
<li><a href="../de465889/index.html">Wie wir Energieeffizienz betrieben haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>