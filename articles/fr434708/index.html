<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😬 🖐🏻 ⬜️ HL 2018. Résumé du rapport «Rendez les mots de passe géniaux à nouveau! Comment vaincre la force brute et ne rien laisser aux pirates » 👩🏿‍🤝‍👨🏾 ✔️ 👩🏻‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je m'appelle Akhmadeev Rinat, je suis Sr. Développeur PHP. 


 Je vous présente le résumé du rapport Rendez les mots de passe géniaux à...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>HL 2018. Résumé du rapport «Rendez les mots de passe géniaux à nouveau! Comment vaincre la force brute et ne rien laisser aux pirates »</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434708/"><p><img src="https://habrastorage.org/webt/ey/xs/qh/eyxsqh1i0z7s2_fexslxgbdi-fy.png" alt="Les mots de passe sont comme des sous-vêtements"></p><br><p>  Bonjour, Habr!  Je m'appelle Akhmadeev Rinat, je suis Sr.  Développeur PHP. </p><br><p>  Je vous présente le résumé du rapport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendez les mots de passe géniaux à nouveau!</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment vaincre bruteforce et laisser les pirates avec rien</a> d'Alexey Ermishkin de Virgil Security avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HighLoad ++ 2018</a> . </p><br><p>  Quand je suis allé au rapport, j'étais pessimiste.  Mais depuis  Puisque c'est Virgil Security, j'ai quand même décidé d'y aller.  Au début, le rapport semblait vraiment du capitaine, et j'ai même commencé à perdre tout intérêt, mais ensuite, comme il s'est avéré, j'ai même découvert plusieurs nouvelles approches de protection par mot de passe qui sont différentes du hachage de sel habituel. </p><br><p>  Le rapport examine les moyens de protéger les mots de passe des hachages vers des approches plus modernes, telles que le mot de passe Facebook, Oignon, Sphinx et Pythia.  À la toute fin, les nouveaux services de chiffrement renforcé par mot de passe (PHE) sont introduits. </p><br><p>  J'ai tellement aimé le rapport que j'ai préparé un recueil.  Je recommande à chacun de se familiariser. </p><a name="habracut"></a><br><p>  Alexey Ermishkin a partagé les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diapositives</a> et le rapport vidéo dans les commentaires: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y1MQyl13ssc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="konspekt">  Résumé </h2><br><h3 id="vstuplenie">  Entrée </h3><br><p><img src="https://habrastorage.org/webt/wd/sg/tu/wdsgtu8tz1yjoswesm2sjy7gs0k.png" alt="Slide 0. Rendez les mots de passe superbes"></p><br><p>  Bonjour à tous, bonjour à tous!  Je suis heureux de vous voir tous à la Conférence Highload.  Je m'appelle Alexey Ermishkin, je travaille pour Virgil Security. </p><br><p><img src="https://habrastorage.org/webt/p_/dm/2o/p_dm2o99hyouir1mw0qn1nq_k0s.png" alt="Virgilsecurity"></p><br><p>  Nous sommes engagés dans le développement de divers produits cryptographiques pour les développeurs individuels et les entreprises.  Nous nous concentrons sur des solutions de bout en bout, c'est lorsque vous n'avez pas besoin de faire confiance au service pour effectuer des actions telles que le transfert de données, l'authentification, etc.  Nos SDK sont ouverts et accessibles à tous. </p><br><p><img src="https://habrastorage.org/webt/mt/_q/ey/mt_qeyv-o-f8tcltewqjz5bdxze.png" alt="Diapositive 7. Performance, commodité, sécurité"></p><br><p>  Les mots de passe sont depuis longtemps utilisés comme moyen d'authentification, comme moyen de se rendre quelque part.  C'était bien avant l'apparition des ordinateurs.  Mais avec l'avènement des ordinateurs, avec l'avènement des systèmes informatiques, les gens n'ont pas abandonné l'habitude d'utiliser des mots de passe.  Cela est devenu un très gros problème pour les développeurs, car ils se sont heurtés à la difficulté de rendre les systèmes à la fois pratiques, rapides et sécurisés.  Très souvent, lorsque deux de ces aspects essaient de bien faire, le troisième ne fonctionne pas très bien.  Si vous rendez le système productif et sécurisé, cela peut être gênant, etc. </p><br><p><img src="https://habrastorage.org/webt/yf/vy/8n/yfvy8nslfegffzdm8ldboycqpvc.png" alt="Diapositive 8. De quoi nous protégeons-nous?"></p><br><p>  Alors, de quoi allons-nous parler aujourd'hui? </p><br><p>  Je vais parler de la protection contre les attaques hors ligne.  Lorsque des mots de passe entrent dans vos bases de données, l'utilisateur ne les contrôle pas.  Si votre base de données est piratée, elle fuit quelque part, puis les pirates peuvent tout faire avec.  Même si vous avez en quelque sorte protégé les mots de passe, ils peuvent commencer à les trier et ils n'ont besoin d'interagir avec personne pour cela, ils ont déjà tout pour cela.  De plus, les utilisateurs n'arrêtent pas d'utiliser des mots de passe faibles.  Les politiques de mot de passe sont bien sûr utiles, mais pas toujours pratiques, c'est-à-dire  même lorsque les gens entrent, cela semble être un mot de passe fort, la politique dit toujours que vous devez ajouter une lettre ou un chiffre, alors pour eux, ce n'est pas pratique.  Il est également évident que le problème est la nécessité de comparer ce que l'utilisateur a entré avec ce que vous avez dans la base de données.  Comment le faire en toute sécurité?  Eh bien, n'oublions pas qu'à l'intérieur de l'entreprise, il y a aussi des gens qui ne sont pas complètement sympathiques et qui voudraient aussi s'en protéger. </p><br><h3 id="heshi">  Hashs </h3><br><p><img src="https://habrastorage.org/webt/-w/aj/lj/-wajlj6zqzv9v52a1tm-jyykii0.png" alt="Slide 9. Quel est le problème avec les mots de passe?"></p><br><p>  En principe, pourquoi les mots de passe sont-ils un sujet si douloureux, pourquoi vaut-il la peine de travailler avec eux plus soigneusement?  Le problème est que le mot de passe a une petite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">entropie</a> .  Qu'est-ce que l'entropie?  Il s'agit de la quantité d'informations contenues dans les données, c'est-à-dire  par exemple, dans le mot Highload, 8 lettres correspondent à 8 octets, mais si l'on compte l'entropie, ce ne sera pas 64 bits comme le mot entier, mais moins de 30 bits.  Aujourd'hui, quand ils parlent de briser le mot de passe, ils disent qu'il est possible de casser des mots de passe avec entropie en un tel temps ni plus ni moins que de bits.  C'est-à-dire  même le nombre même de mots de passe n'est pas pris en compte. </p><br><p><img src="https://habrastorage.org/webt/2u/ry/lh/2urylhxlc1vap1pdvcq8wqubgai.png" alt="Diapositive 10.1. Hashs"></p><br><p>  Comment les gens ont-ils commencé à utiliser la sécurité par mot de passe?  La première chose qui m'est venue à l'esprit était d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des hachages cryptographiques</a> unidirectionnels. </p><br><p><img src="https://habrastorage.org/webt/ny/ng/3e/nyng3eb-ukqoj_siqeyekl-m6ys.png" alt="Diapositive 10.2. Hashs"></p><br><p>  Leur caractéristique remarquable est qu'ils ne peuvent pas être refusés.  C'est-à-dire  Si vous avez transféré des informations sur ce hachage, reçu une valeur en sortie, vous ne pouvez pas récupérer ces informations à partir de cette valeur.  Mais, malheureusement, ils sont calculés très rapidement.  Par exemple, un cluster moderne de 4 cartes graphiques NVidia peut traiter plusieurs milliards de mots de passe par seconde.  C'est-à-dire  si l'entropie de votre mot de passe est inférieure à 40 bits, un cluster de 4 cartes vidéo le récupérera en une minute, voire moins. </p><br><h3 id="raduzhnye-tablicy">  Tables arc-en-ciel </h3><br><p><img src="https://habrastorage.org/webt/rw/bd/ku/rwbdku7uc7nlyovcvlp7fh19zbk.png" alt="Diapositive 11.1. Tables arc-en-ciel"></p><br><p>  De plus, chaque hachage délicat a sa propre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">table arc-en-ciel</a> .  Quelle est cette table et comment sont-elles fabriquées? </p><br><p><img src="https://habrastorage.org/webt/m_/sj/yy/m_sjyylroq0g4wcqjj8stum8yq4.png" alt="Diapositive 11.2. Tables arc-en-ciel"></p><br><p>  C'est-à-dire  ils prennent les mots de passe et les combinaisons de caractères les plus populaires qui peuvent tenir sur le disque dur, considèrent les hachages pour eux et les mettent sur un peu plus de stockage pour plusieurs téraoctets.  Lorsqu'il existe une sorte de hachage, vous ne pouvez pas le calculer, mais trouvez-le très rapidement à partir de ces tableaux et comparez-le avec le mot de passe qui a été calculé précédemment.  C'est-à-dire  Les avantages des tables sont qu'elles fonctionnent très rapidement, mais vous avez besoin de beaucoup d'espace pour les stocker.  Néanmoins, il existe des tableaux pour les hachages les plus populaires sur Internet, ils peuvent être téléchargés, voire achetés. </p><br><p>  <em>Note de l'auteur du synopsis: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipedia</a> n'est pas d'accord avec le locuteur: "Rainbow table est une version spéciale des tables de recherche pour inverser les fonctions de hachage cryptographiques en utilisant le mécanisme d'un compromis raisonnable entre le temps de recherche dans la table et la mémoire occupée."</em>  <em>C'est-à-dire</em>  <em>il ne stocke pas les hachages des mots de passe les plus populaires qui tiendront sur le disque, mais simplement les hachages de certains mots de passe, le reste est calculé sur la base de ceux qui existent - il y a plusieurs mots de passe par enregistrement dans le tableau.</em> </p><br><h3 id="sol">  Du sel </h3><br><p><img src="https://habrastorage.org/webt/nx/cx/l3/nxcxl3ijlwytnvaumlbt9zlnjdo.png" alt="Diapositive 12.1. Du sel"></p><br><p>  Mais là encore, chaque table arc-en-ciel a son propre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sel</a> .  Qu'est-ce que le sel?  Il s'agit d'un ensemble aléatoire d'octets, qui est ajouté au mot de passe.  Il est stocké dans une table quelque part près du hachage et protège des tables arc-en-ciel. </p><br><p><img src="https://habrastorage.org/webt/xl/z1/_j/xlz1_j7oasnp6wpvijtlbmpw5n8.png" alt="Diapositive 12.2. Du sel"></p><br><p>  C'est-à-dire  les personnes qui mettent la main sur une base avec des hachages salés devront toujours calculer ces hachages.  Mais le problème est que ces hachages sont calculés très rapidement et le sel n'aide pas beaucoup ici. </p><br><h3 id="kak-zamedlit-perebor">  Comment ralentir la recherche? </h3><br><p><img src="https://habrastorage.org/webt/tb/vh/of/tbvhoftqtm7hlvgibwwvafv9cl4.png" alt="Diapositive 13.1. Comment ralentir la recherche?"></p><br><p>  Une solution naturelle pourrait être de ralentir le tri du hachage d'une manière ou d'une autre.  Comment cela peut-il se faire? </p><br><p><img src="https://habrastorage.org/webt/6j/9c/x0/6j9cx0nof6w-dzgbc3b6nx5qw-8.png" alt="Diapositive 13.2. Comment ralentir la recherche?"></p><br><p>  L'approche la plus naïve consiste à prendre une sorte de fonction de hachage, par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sha256,</a> et à la calculer de manière itérative, c'est-à-dire  calculer le hachage, à partir de ce hachage, le hachage à nouveau, etc.  Vous pouvez le faire plusieurs milliers voire plusieurs millions de fois.  Le problème est que si vous écrivez une telle implémentation vous-même, elle sera très probablement plus lente que l'implémentation de personnes professionnellement impliquées dans la recherche de mots de passe. </p><br><p><img src="https://habrastorage.org/webt/nj/f3/hr/njf3hrodtzqbbu5w3purv-vsm6u.png" alt="Diapositive 14. Fonctions de hachage de mot de passe"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SCrypt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bcrypt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Argon2</a> </p><br><p>  Et par conséquent, les cryptographes ont proposé plusieurs fonctions spécialement conçues pour ralentir la recherche de mot de passe - ils utilisent une grande quantité de mémoire et toutes les instructions de processeur modernes possibles.  Si le mot de passe protégé par une telle fonction tombe entre les mains des attaquants, ils devront alors utiliser du matériel très puissant. </p><br><p><img src="https://habrastorage.org/webt/-e/ed/gw/-eedgw4f2c-6q3khy9pywdotzwa.png" alt="Diapositive 15. Argon2"></p><br><p>  Par exemple, la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Argon2</a> la plus moderne fonctionne comme suit: dans le diagramme, vous pouvez voir qu'il y a beaucoup de blocs de mémoire différents à travers lesquels le hachage est exécuté.  Il le fait de différentes manières aller-retour, la mémoire est utilisée de manière très intensive, toute la mémoire est utilisée.  Il est assez difficile d'optimiser une telle fonction (vitesse de recherche). </p><br><p><img src="https://habrastorage.org/webt/eu/gn/u2/eugnu2x_t3tsbyfzqmyesuwlmse.png" alt="Diapositive 16. Fonctions de hachage de mot de passe"></p><br><p>  Mais ces approches ont aussi leurs inconvénients.  Ces fonctions sont ralenties spécialement, mais elles sont spécialement lentes non seulement pour les attaquants, elles le seront également spécialement pour vous.  Ils chargeront votre fer.  Ces fonctions sont personnalisables, c'est-à-dire  vous pouvez choisir la quantité de mémoire qui sera utilisée pour calculer le hachage d'un mot de passe unique, jusqu'à plusieurs gigaoctets, combien de passages sur cette mémoire.  Si vous réglez ces paramètres très sérieusement, votre propre matériel en souffrira et si beaucoup de personnes se connectent au système, il vous suffit d'allouer des ressources assez importantes pour la protection par mot de passe et les mots de passe simples, eh bien, des mots de passe très simples peuvent toujours être récupérés . </p><br><h3 id="facebooks-password-onion">  Mot de passe de Facebook Oignon </h3><br><p><img src="https://habrastorage.org/webt/jg/ij/6k/jgij6ksfudwqixuwbidyqos8g_y.png" alt="Slide 17. Et ne pouvez-vous pas charger le backend?"></p><br><p>  Les gens y ont réfléchi et ont posé la question: est-il possible d'obtenir les mêmes propriétés sans charger le backend, sans charger leurs propres serveurs? </p><br><p><img src="https://habrastorage.org/webt/3t/bt/i5/3tbti5mfy7-5smkvkfpkzyw8cq0.png" alt="Slide 18. Mot de passe de Facebook Oignon"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Facebook a été l'</a> un des pionniers dans ce domaine.  Ces lignes que vous voyez sont les étapes historiques de Facebook, comment elles protégeaient les mots de passe, au début ce n'étaient que des mots de passe, puis elles ont pris l'ancienne fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">md5</a> , qui a été fissurée pendant longtemps, puis elles y ont ajouté du sel et ont pris le hash <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sha1</a> , et puis c'est arrivé chose intéressante, ils ont apporté le calcul de la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hmac</a> (c'est un hachage avec une clé) au service distant. </p><br><p><img src="https://habrastorage.org/webt/at/hg/59/athg59eofneynp9pmmn1ffzdbg8.png" alt="Diapositive 19. Facebook"></p><br><p>  Comment ça marche?  Il y a un backend, il y a un service à distance.  Il existe une sorte de clé secrète sur ce service.  Une personne entre dans le backend, entre son mot de passe.  Ce mot de passe est mélangé avec le sel qui se trouve dans la base de données, exécuté via un hachage et envoyé au service.  Le service prend sa clé privée, calcule la fonction hmac et la renvoie entièrement.  Sur le backend, il est placé dans la base. </p><br><p><img src="https://habrastorage.org/webt/nj/hw/ac/njhwackeuo-kschvhkkvaxstmky.png" alt="Diapositive 20. Facebook"></p><br><p>  Qu'est-ce que ça donne?  Si Facebook a une base de données d'utilisateurs, cela ne vaut pas la peine d'y trier les mots de passe, car ils n'ont pas de clé secrète distante.  Mais le problème avec l'approche de Facebook est que si quelque chose arrive à leur clé privée distante, ils auront de gros problèmes.  Ils ne peuvent rien y faire car ils utilisent des hachages, ils utilisent hmac.  Ils n'ont aucun moyen de résoudre cette situation de manière à ce que les utilisateurs ne remarquent rien et cela se retrouvera dans un coin. </p><br><h3 id="sphinx">  Sphinx </h3><br><p><img src="https://habrastorage.org/webt/_t/kq/nd/_tkqnduhchzryj-sgjt-kqytyo0.png" alt="Diapo 21. Est-ce mieux?"></p><br><p>  Les cryptographes ont regardé le tout.  Ils ont aimé l'idée d'utiliser des services à distance et ont décidé de réfléchir: est-il possible de faire encore mieux?  Est-il possible de créer un système similaire, mais sans les inconvénients dont Facebook l'a doté? </p><br><p><img src="https://habrastorage.org/webt/hh/04/o5/hh04o5poadnr-d4diswhuaferuq.png" alt="Diapositive 22. Le mot de passe est-il un nombre?"></p><br><p> Et ils ont décidé d'aborder ce problème comme suit: que faire si le mot de passe ou le hachage de mot de passe est représenté sous forme de nombre?  Si nous avons le mot <code>passw0rd</code> , il se compose de 8 octets.  Dans presque tous les langages de programmation, il existe des types entiers de huit octets, c'est-à-dire  En principe, c'est la même chose.  C'est-à-dire  8 octets, le mot <code>passw0rd</code> et nous pouvons le représenter comme un nombre décimal régulier.  Qu'est-ce que cela nous donne?  Cela nous donne une liberté d'action complètement différente.  Nous pouvons ajouter des mots de passe ou des hachages, les multiplier, les transformer en d'autres nombres.  Nous pouvons effectuer de véritables opérations mathématiques sérieuses avec eux. </p><br><p><img src="https://habrastorage.org/webt/6h/3d/wm/6h3dwmeitk9jftagy1hszcqbmgo.png" alt="Diapositive 23.1. Sphinx - gestionnaire de mots de passe"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sphinx</a> est l'un des premiers systèmes à utiliser cette technologie.  Elle est apparue il y a quelques années.  Il s'agit d'un gestionnaire de mots de passe déterministe.  Il existe de nombreux programmes différents tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">keepass</a> , où vous avez un mot de passe principal et pour chaque site, il en génère un au hasard.  Mais il y a aussi des choses déterministes où vous entrez votre mot de passe principal, le site auquel vous souhaitez accéder et il y calcule quelque chose et émet un mot de passe unique pour chaque site.  Mais il est clair que si ce mot de passe principal va quelque part, tous les mots de passe de vos sites seront définitivement compromis. </p><br><p><img src="https://habrastorage.org/webt/qs/9j/0z/qs9j0z8enfk9_j_p53msuqcxufu.png" alt="Diapositive 23.2. Sphinx - gestionnaire de mots de passe"></p><br><p>  Comment Sphinx a-t-il abordé ce problème?  Il prend le mot de passe principal, il prend le domaine auquel vous souhaitez vous connecter, exécute le tout via un hachage et le transforme en un nombre.  Mais en fait, la cryptographie elliptique y est utilisée, pour plus de simplicité j'expliquerai tout cela sur des nombres ordinaires avec des mathématiques ordinaires.  Il le transforme en nombre (appelons-le <code>a</code> ) et que fait-il ensuite? </p><br><p><img src="https://habrastorage.org/webt/wx/ba/hk/wxbahkcpmzzmwsaxj1_abbdwrpq.png" alt="Slide 24. Sphinx - le &quot;gestionnaire&quot; des mots de passe, déguisez-vous!"></p><br><p>  Une chose absolument merveilleuse, chaque fois que nous pouvons générer un grand nombre aléatoire <code>r</code> .  Si nous élevons le nombre <code>a</code> à la puissance de <code>r</code> , et quelque temps plus tard, nous élevons ce nombre à la puissance inverse du nombre <code>r</code> , alors nous obtenons le même nombre <code>a</code> , non?  C'est-à-dire  nous pouvons masquer quelque chose depuis le début, puis le démasquer. </p><br><p><img src="https://habrastorage.org/webt/pu/yp/5t/puyp5t7x6yprlu_xyybj4z8llna.png" alt="Diapositive 25.1. Sphinx - gestionnaire de mots de passe"></p><br><p>  Et que fait le sphinx?  Encore une fois, il y a un utilisateur, il y a un service à distance.  Un numéro masqué est envoyé à ce service distant.  Sur le service distant, il existe une clé privée <code>b</code> .  Que fait-il?  Il multiplie le nombre envoyé <code>a^r</code> par sa clé secrète <code>b</code> et le renvoie.  ( <em>Note de l'auteur du recueil: sur la diapositive, le nombre envoyé n'est pas multiplié par la clé privée, mais est élevé au degré de la clé privée, mais l'essentiel est</em> ).  Étant donné que le nombre <code>r</code> différent à chaque fois, le service distant ne peut rien dire sur le mot de passe et le domaine masqués, c'est-à-dire  chaque fois qu'il voit des nombres aléatoires différents.  Et il multiplie simplement par sa clé privée <code>b</code> et renvoie. </p><br><p><img src="https://habrastorage.org/webt/gs/nm/bx/gsnmbxvngd2m2ziqnuqo-mdtney.png" alt="Diapositive 25.2. Sphinx - gestionnaire de mots de passe"></p><br><p>  L'utilisateur démasque ce que le serveur lui a envoyé et il obtient un numéro - son mot de passe principal avec le domaine multiplié par la clé secrète du serveur <code>a^b</code> .  Il s'avère qu'il ne connaît pas la clé secrète du serveur, le serveur ne sait pas ce que l'utilisateur lui a envoyé, mais au final, il obtient également une sorte de numéro déterministe.  Chaque fois que vous exécutez ce protocole, le déguisement sera différent, mais le résultat sera toujours le même et ce résultat peut ensuite être reconverti en une sorte de mot de passe et utilisé pour accéder à divers sites. </p><br><p><img src="https://habrastorage.org/webt/7v/zd/hv/7vzdhvrksyvyg_awii2rkvphdgy.png" alt="Slide 26. Sphinx - le &quot;gestionnaire&quot; des mots de passe"></p><br><p>  Une technologie vraiment merveilleuse.  Tout d'abord, vous pouvez générer des mots de passe volumineux, c'est-à-dire  il protège de la casse.  Deuxièmement, si un pirate accède à plusieurs mots de passe, il ne pourra rien dire des autres, car  ils sont générés indépendamment les uns des autres.  Troisièmement, si le mot de passe de l'utilisateur disparaît quelque part, cela ne donnera rien non plus, car les pirates n'auront pas de clé secrète.  Quatrièmement, cela fonctionne très rapidement, car  aucun grand hachage itératif n'est nécessaire ici, c'est-à-dire  littéralement 2-3 multiplications sont effectuées et tout fonctionne instantanément. </p><br><p>  Mais ce système a ses inconvénients.  Le serveur avec lequel l'utilisateur parle ne sait rien de lui.  Il reçoit simplement des nombres aléatoires en entrée, les multiplie par quelque chose et les renvoie.  Le client ne sait rien non plus sur le serveur, il envoie quelque chose quelque part, reçoit le résultat, cela fonctionne - bien.  Mais si quelque chose arrive au service, l'utilisateur ne pourra rien en dire, il n'a pas d'informations à ce sujet.  La clé secrète ne peut pas non plus être modifiée, rien ne peut être fait avec. </p><br><h3 id="pythia">  Pythia </h3><br><p><img src="https://habrastorage.org/webt/cp/kt/3z/cpkt3zvvpwx7svjbydprtntli5i.png" alt="Diapo 27. Cela pourrait-il être mieux?"></p><br><p>  Cela pourrait-il être mieux? </p><br><p><img src="https://habrastorage.org/webt/ot/jg/ms/otjgmsc63aic6zb8mpod01tn9jy.png" alt="Slide 28. DE BOUT EN BOUT!"></p><br><p>  Les cryptographes ont examiné ce système et ont pensé, est-il possible d'améliorer le système et de le compléter avec des propriétés qui nous permettraient de dire qu'il est conforme aux principes de bout en bout?  C'est-à-dire  le client peut communiquer avec le serveur, mais en même temps, il peut également l'authentifier et lui faire confiance dans une certaine mesure. </p><br><p><img src="https://habrastorage.org/webt/gv/2o/p8/gv2op8fshghvw1rvt0dnqnqwxnw.png" alt="Diapositive 29.1. Pythia"></p><br><p>  Et ils ont trouvé un protocole appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pythia</a> . </p><br><p><img src="https://habrastorage.org/webt/kq/wd/in/kqwdin-__0xxfcerqmva6s2vewo.png" alt="Diapositive 29.2. Pythia"></p><br><p>  Il a été réalisé par le merveilleux homme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Adam Everspaugh</a> avec ses collègues.  Qu'est-ce qui le rend unique?  Premièrement, le service sait qui entre le mot de passe, c'est-à-dire  l'ID utilisateur est transmis au serveur après le mot de passe.  Il peut s'agir d'une boîte d'identification aléatoire située à côté, ou simplement d'un nom d'utilisateur.  Peu importe.  Mais le service le sait.  Mais le serveur n'en sait pas seulement un peu, il peut prouver strictement mathématiquement que c'est bien lui. </p><br><p><img src="https://habrastorage.org/webt/pf/lo/zf/pflozf9qji8nzq_nhpswlqd-3xa.png" alt="Diapositive 30.1. Pythia"></p><br><p>  Comment ça marche?  Il y a un backend (une sorte de service web, un site) et il y a un service Pythia.  Que fait le backend et que fait le service?  Il existe une clé privée <code>k</code> sur le service, mais il transfère également sa clé publique au backend.  Le backend de service envoie non seulement le numéro masqué <code>a^r</code> , comme dans le protocole Sphinx, mais envoie également une sorte d'identifiant d'utilisateur ( <code>UserID</code> ).  Le service multiplie l'ID utilisateur et le mot de passe par sa clé privée et le résultat <code>(UserID, a)^(r*k)</code> envoie le backend.  Il renvoie également une certaine <code>Proof</code> , qui peut être utilisée par le backend pour vérifier que le serveur n'a pas été piraté, qu'il répond comme il se doit. </p><br><p><img src="https://habrastorage.org/webt/re/qr/x2/reqrx276lka5gxfal99x0_l9esy.png" alt="Diapositive 30.2. Pythia"></p><br><p>  Ensuite, il y a un démasquage et le nombre <code>y</code> qui en résulte est mis dans une base de données.  Dans la base de données, nous avons non seulement un hachage, mais un nombre, un point d'une courbe elliptique. </p><br><p><img src="https://habrastorage.org/webt/xx/qc/jt/xxqcjtbljojosjg0ssvhptf3oj0.png" alt="Diapositive 31. Pythie"></p><br><p>  Il y a quelques points intéressants ici: </p><br><ul><li>  La possibilité pour le serveur de combiner l'ID utilisateur et le mot de passe en un seul numéro.  C'est ce qu'on appelle une opération bilinéaire ou appariement bilinéaire.  Il s'agit d'un calcul relativement nouveau, qui a récemment commencé à être utilisé.  Elle a toutes les propriétés des nouveaux mathématiciens en ce que 30 ans ne se sont pas écoulés pour que tout le monde soit convaincu que tout est normal avec ça. </li><li>  Mais la <code>Proof</code> qui envoie le service est une technologie assez ancienne.  C'est ce qu'on appelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le protocole Schnorr</a> .  La génération de clé publique est la multiplication d'un point de base par une clé secrète.  Le protocole Schnorr prouve que la clé secrète utilisée pour générer la clé publique a été utilisée pour multiplier le mot de passe de l'utilisateur par le même numéro.  Ce protocole existe depuis longtemps, il est beaucoup utilisé où et il vous permet de le prouver.  C'est ce qu'on appelle la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">preuve à l'épreuve du zéro</a> - le serveur n'affiche pas sa clé publique, mais il dit que l'opération que j'ai effectuée a été effectuée par cette clé privée, ce que nous avions initialement convenu. </li></ul><br><p><img src="https://habrastorage.org/webt/jz/pg/lo/jzpglodcswcwxprayrpud8semws.png" alt="Diapositive 32.1. Avantages de la Pythie"></p><br><p>  Quels sont les avantages de ce système? </p><br><p><img src="https://habrastorage.org/webt/xn/dg/zg/xndgzgr-to_dgnypnwarbyxengg.png" alt="Diapositive 32.2. Avantages de la Pythie"></p><br><p>  Et elle n'en a pas beaucoup. </p><br><ul><li>  Le système ne charge pas le backend.  Parce que le backend fait tout, il transforme le mot de passe en nombre, le déguise, l'envoie, puis démasque également le résultat. </li><li>  Si une base de données avec de tels numéros vous est volée, le tri des mots de passe n'a également aucun sens sans clé privée. </li><li>  Le service Pythia peut bloquer les tentatives de force brute, ce qui signifie que le backend n'a pas à le faire en principe.  S'il voit que sous le même ID utilisateur, ils essaient d'effectuer cette opération de transformation plusieurs fois, il peut simplement le couper et le bloquer à la limite de débit. </li><li>  Grâce à un déguisement, le service ne sait rien du mot de passe.  Chaque fois qu'un nouveau numéro aléatoire lui est envoyé.  Seul l'identifiant utilisateur reste constant. </li><li>  Grâce à ZKP (Zero-knowledge proof), le backend sait toujours que c'est le service même qu'il avait contacté une fois. </li><li>  Si vous avez une base de données avec des hachages et du sel par exemple, vous pouvez migrer vers une telle solution de manière transparente pour les utilisateurs.  Ils peuvent même ne rien remarquer.  Au lieu du mot de passe de l'utilisateur, vous prenez son hachage, le conduisez en Pythia et à l'avenir utilisez simplement ce protocole, obtenez le nombre <code>y</code> , remettez-le dans votre base de données.  Le hachage peut ensuite être supprimé.  Chaque fois qu'un utilisateur se connecte à votre système, ce protocole sera exécuté, un certain nombre sera obtenu en conséquence, que vous comparerez avec ce qui est dans la base de données.  Le système d'authentification lui-même restera inchangé, car  les utilisateurs se connecteront plus tôt et se connecteront, avec les mêmes mots de passe, même les plus faibles.  Dans ce cas, le système sera beaucoup plus sécurisé. </li></ul><br><p><img src="https://habrastorage.org/webt/2i/63/ja/2i63jae0xiucsx-dqailxoaqiuw.png" alt="Diapositive 33.1. Ce n'est pas tout"></p><br><p>  Mais ce ne sont pas tous les goodies. </p><br><p><img src="https://habrastorage.org/webt/oa/dy/h9/oadyh9nurjtlv5qdbgo8f2xfcui.png" alt="Diapositive 33.2. Ce n'est pas tout"></p><br><p>  L'une des principales caractéristiques est que même si le service Pythia est piraté, il est possible de générer une nouvelle clé privée.  Dans notre base de données, un nombre est stocké, pas un hachage.  Si nous représentons l'ancienne clé comme le nombre <code>k</code> et la nouvelle comme le nombre <code>k'</code> , alors nous pouvons calculer un nombre appelé jeton de mise à jour.  Pour ce faire, nous multiplions le nouveau nombre par le nombre inverse de l'ancien.  Et avec ce jeton de mise à jour, vous pouvez parcourir la base de données pour chaque utilisateur et multiplier ce nombre <code>y</code> par le jeton de mise à jour.  Une fois cette opération effectuée, votre système continue de fonctionner avec la nouvelle clé privée du service distant.  Tout se passe instantanément.  Si une catastrophe survient, votre base de données avec des mots de passe vous est volée, vous libérez un jeton de mise à jour d'un simple clic et le fait que des pirates vous ont volé devient instantanément inutile.  Vous parcourez simplement tous les enregistrements en arrière-plan, les mettez à jour et ils fonctionnent avec la nouvelle clé secrète pour vous.  Les utilisateurs ne remarquent généralement rien.  C'est-à-dire  La mise à jour transparente et l'invalidation instantanée de la base de données de mots de passe sont quelques-unes des principales fonctionnalités innovantes de ce système. </p><br><p><img src="https://habrastorage.org/webt/uu/cb/_z/uucb_z0ikld1bufittz0asq5m84.png" alt="Diapositive 34.1. Bonus"></p><br><p>  Mais ce n'est pas tout. </p><br><p><img src="https://habrastorage.org/webt/vr/jo/3k/vrjo3kpwbw1xuzdr6wklxmwkrgw.png" alt="Diapositive 34.2. Bonus"></p><br><p>  Le nombre qui se trouve dans la base est grand <code>y</code> , il est fondamentalement grand et semble assez pseudo-aléatoire, c'est-à-dire  c'est si facile de ne pas le ramasser.  Si nous transférons les fonctionnalités que nous avons sur le backend, par exemple, sur les appareils clients, sur les téléphones, nous pouvons utiliser ce <code>y</code> pour générer des clés.  Nous avons appelé cette chose BrainKey.  Cela signifie que l'utilisateur entre le mot de passe quelque part sur le téléphone, le déguise également et l'envoie au service distant.  Le service lui renvoie un certain nombre <code>y</code> puis vous pouvez utiliser ce <code>y</code> pour générer des clés asymétriques.  Ainsi, l'utilisateur de son mot de passe peut obtenir une paire de clés.  Ceci est utilisé dans toutes sortes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BrainWallets</a> .  C'est lorsque vous entrez le mot de passe et que le portefeuille Bitcoin est généré pour cela.  Mais cette application n'est pas limitée aux crypto-monnaies, c'est une signature numérique, des sauvegardes et la récupération de compte, c'est-à-dire  partout où la cryptographie asymétrique est utilisée, où des clés asymétriques sont nécessaires.  Tout cela peut être utilisé, mais en même temps une paire de clés, et elles peuvent, selon les besoins, être générées autant que vous le souhaitez.  Ils dépendent donc tous du mot de passe de l'utilisateur, ce qui est très pratique. </p><br><p><img src="https://habrastorage.org/webt/sy/cw/nl/sycwnl1rpbmtpsc_0ddxi3fjlx0.png" alt="Diapositive 35.1. Contre?"></p><br><p>  Dans un baril de miel, ce n'est pas sans une mouche dans la pommade. </p><br><p><img src="https://habrastorage.org/webt/wx/jw/an/wxjwanacuusmfnb_ptce1peh_cg.png" alt="Diapositive 35.2. Contre?"></p><br><p>  Et les caractéristiques de cette technologie sont qu'elle est très nouvelle.  Il utilise une courbe elliptique, qui est destinée aux opérations bilinéaires ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BLS12-381</a> ).  Les mathématiques elles-mêmes existent depuis un certain temps, mais cette courbe particulière, qui est notamment utilisée dans notre implémentation, n'est utilisée que dans <nobr>ZCash</nobr> sauf nous.  En conséquence, les bibliothèques qui utilisent ce nouveau calcul peuvent être comptées sur les doigts d'une main.  Pour mettre cela en état de production, vous devez consacrer un certain temps et des efforts.  Néanmoins, l'industrie ne reste pas immobile et tous ces inconvénients sont temporaires.  En raison des deux premières propriétés, la vitesse de ces opérations bilinéaires n'est pas très cohérente avec les mathématiques modernes, elliptiques en particulier, que nous utilisons tous maintenant, lorsque nous utilisons le protocole TLS, lorsque nous utilisons certains sites.  Il s'agit de plusieurs centaines d'opérations sur un service sur un cœur.  En fait, cela ne nous a pas arrêtés et au printemps, nous avons implémenté ce protocole, l'avons publié en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">production</a> et traduit tous nos enregistrements, les avons protégés à l'aide de ce protocole.  En principe, nous sommes satisfaits des performances de nos tâches en cours, si nécessaire, nous lèverons un autre nœud avec le service Pythia et, en principe, vous pouvez déjà jouer avec tout cela. </p><br><h3 id="phe">  PHE </h3><br><p><img src="https://habrastorage.org/webt/hv/1e/1l/hv1e1lslzyk31hgsw2fu5sffk_o.png" alt="Diapo 36. Est-ce encore mieux?"></p><br><p>  Mais nous nous sommes demandé si nous pouvions faire encore mieux?  Est-il possible d'obtenir les propriétés que Pythia fournit en utilisant les mathématiques d'hier?  Pas demain, pas aujourd'hui, mais même hier, qui est utilisé depuis de nombreuses années. </p><br><p><img src="https://habrastorage.org/webt/6r/rn/0x/6rrn0xaorj5qjkyuk2hhamqaqyk.png" alt="Diapositive 37.1. Services de cryptage renforcés par mot de passe (PHE)"></p><br><p>  Et littéralement en juillet de cette année, les scientifiques ont publié un nouveau protocole appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Simple Password-Hardened Encryption Services,</a> ou PHE pour faire court. </p><br><p><img src="https://habrastorage.org/webt/hx/o5/zv/hxo5zveu2y75lmqm-t3pqknaq0e.png" alt="Diapositive 37.2. Services de cryptage renforcés par mot de passe (PHE)"></p><br><p>  Voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Russell Lai</a> , un scientifique européen. </p><br><p>  Quel est l'avantage de ce service?  Premièrement, il utilise la courbe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P-256</a> standard, qui est utilisée partout, dans tous les navigateurs, produits, partout la courbe par défaut, qui existe depuis de nombreuses années.  Deuxièmement, cette chose fonctionne environ 10 fois plus rapidement que Pythia et utilise des primitives standard.  C'est un peu difficile, mais vous pouvez l'implémenter de vos propres mains sans utiliser de bibliothèques obscures.  Vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenSSL</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bouncy Castle</a> , n'importe quoi. </p><br><p><img src="https://habrastorage.org/webt/el/f0/ho/elf0hoawmvsekav9jgvkqxp0_ju.png" alt="Diapositive 38. Services de cryptage renforcés par mot de passe (PHE)"></p><br><p>  Mais cela fonctionne un peu différemment.  Encore une fois, il y a un backend, il y a un service PHE.  Le backend a une clé publique, le service a une clé privée <code>y</code> .  Contrairement à Pythia, le processus d'enregistrement et le processus de vérification du mot de passe sont un peu différents.  Lorsqu'un nouvel utilisateur arrive sur le service et souhaite s'enregistrer, que fait le backend?  Dès le début, il a demandé au service PHE, veuillez me donner quelques données que je peux utiliser pour m'inscrire, une sorte de fiche d'inscription.  Le service dit OK et répond au backend avec les choses suivantes.  Il génère un sel aléatoire de 32 octets ( <code>sNonce</code> ).  Sur la base de ce sel et de sa clé privée y, il génère deux nombres, appelons-les <code>C0</code> et <code>C1</code> .  Il génère également des preuves ( <code>Proof</code> ) que ces deux nombres ou 2 points ont été générés précisément à l'aide de sa clé privée <code>y</code> , en utilisant le protocole Schnorr (comme dans les protocoles précédents).  Le backend vérifie la <code>Proof</code> .  Il n'y a pas encore de mot de passe ici.  Que fait le backend?  Pour sa part, il possède également sa propre clé privée cliente <code>x</code> et, ayant reçu le mot de passe de l'utilisateur, il fait à peu près la même chose que le service, n'y ajoute que le mot de passe.  Il prend au hasard <code>cNonce</code> (sel client aléatoire), un mot de passe, et génère à nouveau 2 nombres <code>HC0</code> et <code>HC1</code> .  Pourquoi 2?  Parce que le premier <code>HC0</code> utilisé pour l'authentification, et le deuxième numéro <code>HC1</code> mélange un certain nombre aléatoire <code>M</code> multiplié par la clé privée <code>x</code> ( <code>MC</code> ).  Le nombre <code>M</code> est également de 32 octets et peut ensuite être utilisé pour crypter les données utilisateur (nous avons les services de cryptage) ( <em>note de l'auteur de la note: la clé de cryptage dans ce cas sera <code>MC</code></em> ).  Le numéro <code>MC</code> ne sera disponible sous forme de clé qu'après que l'utilisateur aura entré le mot de passe correct.  Il s'avère qu'au stade de l'enregistrement, vous pouvez générer non seulement un enregistrement d'autorisation, mais également une clé de cryptage, unique pour chaque utilisateur, avec laquelle vous pouvez crypter son profil, certaines données et autre chose.  Ensuite, le backend additionne simplement ce que le service a envoyé et ce qu'il a fait - additionne ces points et obtient <code>T0</code> et <code>T1</code> .  Dans le premier cas, il en additionne deux ( <code>C0 + HC0</code> ) et dans le second trois ( <code>C1 + HC1 + MC</code> ).  Et il met les sels de base 2 ( <code>sNonce</code> , <code>cNonce</code> ), à l'aide desquels ces nombres ont été obtenus et 2 nombres ( <code>T0</code> et <code>T1</code> ), qui se sont révélés à la suite de la somme. </p><br><p><img src="https://habrastorage.org/webt/ly/9d/fj/ly9dfjao1laxszgo9okoovsvzjy.png" alt="Slide 39. Connexion PHE"></p><br><p>  Par conséquent, le processus d'authentification de l'utilisateur se produit dans l'ordre inverse.  L'utilisateur entre son mot de passe sur le backend.  Le backend calcule <code>HC0</code> et de ce qu'il a dans la base de données, soustrait <code>HC0</code> de <code>T0</code> et envoie le <code>C0</code> résultant au service avec le sel du serveur.  Le service, connaissant le sel du serveur, calcule le même point en lui-même et regarde, il coïncide avec s'il a envoyé un backend ou non, s'il correspond, alors le mot de passe est correct et vous pouvez y répondre avec le deuxième nombre <code>C1</code> , qu'il soustraira avec <code>HC1</code> du nombre <code>T1</code> et obtenez la clé de cryptage.  Ainsi, le mot de passe du service PHE ne disparaît même pas.  Il ne quitte même pas le backend.  Il se présente sous la forme de quelques points multipliés par la clé privée du backend.  Il n'existe même pas en tant que tel, mais en même temps, le service à distance peut tirer une conclusion stricte quant à savoir si ce mot de passe est correct ou non, et prouver par là qu'il a effectué tous les calculs à l'aide de sa clé privée <code>y</code> . </p><br><p><img src="https://habrastorage.org/webt/bi/7-/op/bi7-opjxk_7cwvgb4lm4wkwgtbi.png" alt="Diapositive 40.1. Caractéristiques PHE"></p><br><p>  Quelles sont les fonctionnalités de ce système? </p><br><p><img src="https://habrastorage.org/webt/2t/ar/rm/2tarrmmsr5j4sgk5zlrtcsu1eyc.png" alt="Diapositive 40.2. Caractéristiques PHE"></p><br><p>  Le mot de passe, comme je l'ai dit, ne quitte pas le backend.  Mais contrairement à Pythia, vous avez besoin d'une clé privée sur le backend.  Eh bien, nous avons besoin et avons besoin, économisons quelque part.  PHE possède toutes les fonctions de base de Pythia: </p><br><ul><li>  Vous pouvez également émettre un jeton de mise à jour si quelque chose vous arrive avec la clé privée; </li><li>  Vous pouvez également parcourir toute la base de données, mettre à jour et tout sera comme il était; </li><li>  protection contre les fouilles; </li><li>  le service ne sait rien du mot de passe; </li><li>   (Pythia , ,  ,    ,  PHE ); </li><li>     . </li></ul><br><p><img src="https://habrastorage.org/webt/vq/_m/yr/vq_myrj2venkvtkjqaij3ujapd4.png" alt=" 41. ..."></p><br><p>      ... </p><br><p><img src="https://habrastorage.org/webt/hp/s9/_t/hps9_tr6ha4ysxt6szxsdhseuoe.png" alt=" 42. passw0rd.io"></p><br><p> …      .      .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">passw0rd.io</a>  .    password  ,    18-        ,    ,    zero trust, ..    .     , , ..  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Let's encrypt</a> .  ,   .    CLI     ,   .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2 SDK</a> ,  GO  .Net,     . </p><br><p><img src="https://habrastorage.org/webt/ey/xs/qh/eyxsqh1i0z7s2_fexslxgbdi-fy.png" alt=" 43. Passwords are like underwear"></p><br><p>           : </p><br><ol><li>    . </li><li>      . </li><li>     . </li></ol><br><p><img src="https://habrastorage.org/webt/d4/nh/d4/d4nhd4nzbnhgfq21j-8yqs1ps0m.png" alt=" 44. "></p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VirgilSecurity.com</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@VirgilSecurity</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub.com/VirgilSecurity</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NoiseSocket.com</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">passw0rd.io</a> </li></ul><br><p>     ,             . </p><br><h3 id="voprosy"> ? </h3><br><p> <strong> 37. ?</strong> </p><br><p><img src="https://habrastorage.org/webt/z_/t0/05/z_t005mcdxnznvcinnqsg-z750a.png" alt=" 45. ?"></p><br><p>     . </p><br><p> Q: ,    !   .     ,      Pythia       update token,        ?        private key  .         update token?  Ou pas? <br> A: , update token-     . <br> Q:    .      -        update token-,       Private key         ? <br> A: ,    update token-,     ,  - ,   ,  ,    update token.     , ..   . <br> Q: , ,    ,   . <br> A: ..     . </p><br><p> Q: ,   ,     ,     -   Pythia  -    ,       ,     ,   ? <br> A:  . <br> Q:      ? <br> A: ,      Pythia   .  C'est-à-dire     ,        . <br> Q: ( )  bcrypt      ? <br> A: ,      ,   ,      . </p><br><p> Q:  ,    .      ?  , … <br> A: password   <br> Q: password  ?  Feu!  Généralement. <br> A: 123456   ,        12345, 123456. <br> Q: .    Pythia  ,  PHE   . <br> A:    ,           . <br> Q: .   .         ?  production   ? <br> A:  . !   Pythia. <br> Q:   Pythia,    , ? <br> A:  . <br> Q:   ,  ? <br> A:   . <br> Q: , , ! <br> A:     SDK,     . </p><br><p> Q: ,  ,  ,     , ..   -  ,     ?    ?    ? <br> A: ,    ,    , ..       PHE,    ,    5   2 ,   2   5  .    ,     .    PHE ( ,    ),    ,     10 ,    . <br> Q: ..      - ,      -  ?   ? <br> A:   .     rate limiting,   ,                . <br> Q: ..             , ? <br> A: . </p><br><p> Q: . , ..       Pythia      (),          , ? ? <br> A: ,    ,     . <br> Q:  ,   update   ? <br> A: ,    Pythia  ,         ,  -     -  ,   ,        ,     ) </p><br><p> A: ?   !   .     , ,   PHE,   , . </p><br><h2 id="vyvody">  Conclusions </h2><br><p>      PHE (    )          + —    (  ,   ,  )      (     ).   PHE      ,                   . </p><br><p>         : </p><br><ul><li>       ( <strong></strong> )   ; </li><li>              (      ). </li></ul><br><p>  ,         . </p><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Scratch</a>   Virgil Security  ,    ,      ! </p><br><p>      (  )? </p><br><p> <strong>UPD</strong> :   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Scratch</a> .          .     ,     .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434708/">https://habr.com/ru/post/fr434708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434698/index.html">Pessimisme à propos du multithreading</a></li>
<li><a href="../fr434700/index.html">Avantages de suivre les guides de style lors du développement d'applications angulaires</a></li>
<li><a href="../fr434702/index.html">Pourquoi le SSD moderne me plante</a></li>
<li><a href="../fr434704/index.html">Raisons de la baisse du coût du trafic mobile en Russie et prévisions pour 2019</a></li>
<li><a href="../fr434706/index.html">UDB. Qu'est-ce que c'est? Partie 3. FIFAP Datapath</a></li>
<li><a href="../fr434710/index.html">Blog RUVDS sur Habr: trois ans</a></li>
<li><a href="../fr434712/index.html">Troisième test de Turing en russe</a></li>
<li><a href="../fr434714/index.html">Synchronisation des demandes client au printemps</a></li>
<li><a href="../fr434716/index.html">Passer au centre de données: préparation</a></li>
<li><a href="../fr434718/index.html">Deux ans plus tard, la prise casque me manque toujours</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>