<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∏üèª üòÇ üöù Guia de solu√ß√£o de problemas visuais para Kubernetes üë≤üèæ üôè üöå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota perev. : Este artigo faz parte dos materiais dispon√≠veis gratuitamente no projeto learnk8s , que ensina como trabalhar com empresas Kubernetes e ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia de solu√ß√£o de problemas visuais para Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/484954/">  <i><b>Nota</b></i>  <i><b>perev.</b></i>  <i>: Este artigo faz parte dos materiais dispon√≠veis gratuitamente no projeto <a href="https://learnk8s.io/">learnk8s</a> , que ensina como trabalhar com empresas Kubernetes e administradores individuais.</i>  <i>Nele, Daniele Polencic, gerente de projetos, compartilha uma instru√ß√£o clara sobre as etapas a serem seguidas em caso de problemas gerais para aplicativos em execu√ß√£o no cluster K8s.</i> <br><br><img src="https://habrastorage.org/webt/ch/5u/xa/ch5uxanj-3ivwqu88swqyoi6bsu.png"><br><br>  TL; DR: aqui est√° um diagrama que ajudar√° voc√™ a depurar a implanta√ß√£o no Kubernetes: <a name="habracut"></a><br><br> <a href=""><img src="https://habrastorage.org/webt/4r/qp/si/4rqpsie8dnplkqxahaqntpi2ssw.png"></a> <br><br>  <i>Fluxograma para localizar e corrigir erros em um cluster.</i>  <i>No original (em ingl√™s), est√° dispon√≠vel em <a href="https://learnk8s.io/a/troubleshooting-kubernetes.pdf">PDF</a> e <a href="">como imagem</a> .</i> <br><br>  Ao implantar um aplicativo no Kubernetes, voc√™ geralmente precisa definir tr√™s componentes: <br><br><ul><li>  <b>Implanta√ß√£o</b> √© uma receita para criar c√≥pias de um aplicativo chamado pods; </li><li>  <b>Servi√ßo</b> - um balanceador de carga interno que distribui o tr√°fego entre os pods; </li><li>  <b>Ingresso</b> - uma descri√ß√£o de como o tr√°fego fluir√° do mundo externo para o Servi√ßo. </li></ul><br>  Aqui est√° um breve resumo gr√°fico: <br><br>  1) No Kubernetes, os aplicativos recebem tr√°fego do mundo externo atrav√©s de duas camadas de balanceadores de carga: interno e externo. <br><br><img src="https://habrastorage.org/webt/3v/cy/z9/3vcyz9a-2ciiqbh9he7idgvo7uy.png"><br><br>  2) O balanceador interno √© chamado Servi√ßo, o externo - Ingresso. <br><br><img src="https://habrastorage.org/webt/23/mn/zc/23mnzcfo_b3niccdivn4bc4vzei.png"><br><br>  3) A implanta√ß√£o cria pods e os monitora (eles n√£o s√£o criados manualmente). <br><br><img src="https://habrastorage.org/webt/4j/c2/h9/4jc2h9pgzbxmkon4ewkbeuf0vhc.png"><br><br>  Suponha que voc√™ queira implantar um aplicativo simples no <i>Hello World</i> .  A configura√ß√£o do YAML ter√° a seguinte apar√™ncia: <br><br><pre><code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment # &lt;&lt;&lt; metadata: name: my-deployment labels: track: canary spec: selector: matchLabels: any-name: my-app template: metadata: labels: any-name: my-app spec: containers: - name: cont1 image: learnk8s/app:1.0.0 ports: - containerPort: 8080 --- apiVersion: v1 kind: Service # &lt;&lt;&lt; metadata: name: my-service spec: ports: - port: 80 targetPort: 8080 selector: name: app --- apiVersion: networking.k8s.io/v1beta1 kind: Ingress # &lt;&lt;&lt; metadata: name: my-ingress spec: rules: - http: paths: - backend: serviceName: app servicePort: 80 path: /</code> </pre> <br>  A defini√ß√£o √© bastante longa e √© f√°cil ficar confuso sobre como os componentes est√£o relacionados. <br><br>  Por exemplo: <br><br><ul><li>  Quando voc√™ deve usar a porta 80 e quando - 8080? </li><li>  Devo criar uma nova porta para cada servi√ßo para que eles n√£o entrem em conflito? </li><li>  Os nomes dos r√≥tulos s√£o importantes?  Eles deveriam ser os mesmos em todos os lugares? </li></ul><br>  Antes de focar na depura√ß√£o, lembremos como os tr√™s componentes est√£o relacionados entre si.  Vamos come√ßar com implanta√ß√£o e servi√ßo. <br><br><h2>  Implanta√ß√£o de Conex√£o'a e Servi√ßo'a </h2><br>  Voc√™ ficar√° surpreso, mas as implanta√ß√µes e o servi√ßo n√£o est√£o conectados de forma alguma.  Em vez disso, o Servi√ßo aponta diretamente para os Pods ignorando a Implanta√ß√£o. <br><br>  Portanto, estamos interessados ‚Äã‚Äãem saber como os Pods e os servi√ßos est√£o relacionados entre si.  Tr√™s coisas para lembrar: <br><br><ol><li>  Um <code>selector</code> servi√ßo deve corresponder a pelo menos um r√≥tulo de Pod. </li><li>  <code>targetPort</code> deve corresponder ao <code>containerPort</code> cont√™iner dentro do Pod. </li><li>  <code>port</code> Service pode ser qualquer coisa.  Servi√ßos diferentes podem usar a mesma porta porque possuem endere√ßos IP diferentes. </li></ol><br>  O diagrama a seguir representa todos os itens acima em forma gr√°fica: <br><br>  1) Imagine que o servi√ßo direcione o tr√°fego para um determinado pod: <br><br><img src="https://habrastorage.org/webt/2a/e5/8f/2ae58fcgoi7aifmcr5rl_0bseym.png"><br><br>  2) Ao criar um pod, voc√™ deve especificar <code>containerPort</code> para cada container nos pods: <br><br><img src="https://habrastorage.org/webt/xc/fa/ow/xcfaowomhbtqhebhodgzhzrkupc.png"><br><br>  3) Ao criar o servi√ßo, voc√™ deve especificar <code>port</code> e <code>targetPort</code> .  <i>Mas qual deles est√° se conectando ao cont√™iner?</i> <br><br><img src="https://habrastorage.org/webt/vg/wj/nd/vgwjnde0xyzdblwamomfxjaxb40.png"><br><br>  4) Via <code>targetPort</code> .  Deve corresponder a <code>containerPort</code> . <br><br><img src="https://habrastorage.org/webt/q4/yx/qn/q4yxqnkxxilupalikahmqqp09x8.png"><br><br>  5) Digamos que a porta 3000 esteja aberta no cont√™iner e, em seguida, o valor <code>targetPort</code> deve ser o mesmo. <br><br><img src="https://habrastorage.org/webt/cq/tj/-s/cqtj-srznih70qh7bxs3w_l7bis.png"><br><br>  No arquivo YAML, os r√≥tulos e as <code>ports</code> / <code>targetPort</code> devem corresponder: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: my-deployment labels: track: canary spec: selector: matchLabels: any-name: my-app template: metadata: labels: # &lt;&lt;&lt; any-name: my-app # &lt;&lt;&lt; spec: containers: - name: cont1 image: learnk8s/app:1.0.0 ports: - containerPort: 8080 # &lt;&lt;&lt; --- apiVersion: v1 kind: Service metadata: name: my-service spec: ports: - port: 80 targetPort: 8080 # &lt;&lt;&lt; selector: # &lt;&lt;&lt; any-name: my-app # &lt;&lt;&lt;</code> </pre> <br>  <i>E a <code>track: canary</code> na parte superior da se√ß√£o Implanta√ß√£o?</i>  <i>Deve corresponder?</i> <br><br>  Este r√≥tulo refere-se √† implanta√ß√£o e n√£o √© usado pelo servi√ßo para rotear o tr√°fego.  Em outras palavras, ele pode ser exclu√≠do ou atribu√≠do a um valor diferente. <br><br>  <i>E o seletor <code>matchLabels</code> ?</i> <br><br>  <b>Sempre deve corresponder aos r√≥tulos do Pod</b> , pois √© usado pelo Deployment para rastrear os pods. <br><br>  <i>Suponha que voc√™ tenha feito as edi√ß√µes corretas.</i>  <i>Como verific√°-los?</i> <br><br>  Voc√™ pode verificar o r√≥tulo do pod com o seguinte comando: <br><br><pre> <code class="bash hljs">kubectl get pods --show-labels</code> </pre> <br>  Ou, se os pods pertencerem a v√°rios aplicativos: <br><br><pre> <code class="bash hljs">kubectl get pods --selector any-name=my-app --show-labels</code> </pre> <br>  Onde <code>any-name=my-app</code> √© o r√≥tulo <code>any-name: my-app</code> . <br><br>  <i>H√° alguma dificuldade?</i> <br><br>  Voc√™ pode se conectar ao pod!  Para fazer isso, use o comando <code>port-forward</code> no kubectl.  Ele permite que voc√™ se conecte ao servi√ßo e verifique a conex√£o. <br><br><pre> <code class="bash hljs">kubectl port-forward service/&lt;service name&gt; 3000:80</code> </pre> <br>  Aqui: <br><br><ul><li>  <code>service/&lt;service name&gt;</code> - nome do servi√ßo;  no nosso caso, √© o <code>my-service</code> ; </li><li>  3000 - a porta que voc√™ deseja abrir no computador; </li><li>  80 - porta especificada no campo de <code>port</code> do servi√ßo. </li></ul><br>  Se voc√™ conseguiu estabelecer uma conex√£o, as configura√ß√µes est√£o corretas. <br><br>  Se a conex√£o n√£o p√¥de ser estabelecida, h√° um problema com os r√≥tulos ou as portas n√£o coincidem. <br><br><h2>  Conex√£o de servi√ßo e ingresso </h2><br>  A pr√≥xima etapa no fornecimento de acesso ao aplicativo est√° relacionada √† configura√ß√£o do Ingress.  O Ingress deve saber como encontrar o servi√ßo, encontrar os pods e direcionar o tr√°fego para eles.  O Ingress localiza o servi√ßo desejado por nome e porta aberta. <br><br>  Na descri√ß√£o do Ingress e Service, dois par√¢metros devem corresponder: <br><br><ol><li>  <code>servicePort</code> no Ingress deve corresponder ao par√¢metro <code>port</code> no Service; </li><li>  <code>serviceName</code> no Ingress deve corresponder ao campo de <code>name</code> no Service. </li></ol><br>  O diagrama a seguir resume a conex√£o de portas: <br><br>  1) Como voc√™ j√° sabe, o Servi√ßo escuta em uma determinada <code>port</code> : <br><br><img src="https://habrastorage.org/webt/9q/t0/fz/9qt0fzsyme9mnrd4ki07ezamnkg.png"><br><br>  2) O Ingress possui um par√¢metro chamado <code>servicePort</code> : <br><br><img src="https://habrastorage.org/webt/rn/du/yw/rnduyw4xvfmpjmhup8fy9ao2d1a.png"><br><br>  3) Este par√¢metro ( <code>servicePort</code> ) deve sempre corresponder √† <code>port</code> na defini√ß√£o de servi√ßo: <br><br><img src="https://habrastorage.org/webt/1d/ap/ty/1daptyulxphnbb2dt6uben-lnzk.png"><br><br>  4) Se a porta 80 for especificada em Servi√ßo, <code>servicePort</code> tamb√©m dever√° ser 80: <br><br><img src="https://habrastorage.org/webt/nc/mi/dl/ncmidlxiegmtmhtozaxxqhznaya.png"><br><br>  Na pr√°tica, voc√™ precisa prestar aten√ß√£o √†s seguintes linhas: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: my-service # &lt;&lt;&lt; spec: ports: - port: 80 # &lt;&lt;&lt; targetPort: 8080 selector: any-name: my-app --- apiVersion: networking.k8s.io/v1beta1 kind: Ingress metadata: name: my-ingress spec: rules: - http: paths: - backend: serviceName: my-service # &lt;&lt;&lt; servicePort: 80 # &lt;&lt;&lt; path: /</code> </pre> <br>  <i>Como verificar se o Ingress est√° funcionando?</i> <br><br>  Voc√™ pode usar o m√©todo com o <code>kubectl port-forward</code> , mas em vez do servi√ßo, voc√™ precisa se conectar ao controlador do Ingress. <br><br>  Primeiro, voc√™ precisa descobrir o nome do pod com o controlador do Ingress: <br><br><pre> <code class="bash hljs">kubectl get pods --all-namespaces NAMESPACE NAME READY STATUS kube-system coredns-5644d7b6d9-jn7cq 1/1 Running kube-system etcd-minikube 1/1 Running kube-system kube-apiserver-minikube 1/1 Running kube-system kube-controller-manager-minikube 1/1 Running kube-system kube-proxy-zvf2h 1/1 Running kube-system kube-scheduler-minikube 1/1 Running kube-system nginx-ingress-controller-6fc5bcc 1/1 Running</code> </pre> <br>  Localize o pod de entrada (ele pode se referir a um espa√ßo para nome diferente) e execute o comando de <code>describe</code> para descobrir os n√∫meros de porta: <br><br><pre> <code class="bash hljs">kubectl describe pod nginx-ingress-controller-6fc5bcc \ --namespace kube-system \ | grep Ports Ports: 80/TCP, 443/TCP, 18080/TCP</code> </pre> <br>  Por fim, conecte-se ao pod: <br><br><pre> <code class="bash hljs">kubectl port-forward nginx-ingress-controller-6fc5bcc 3000:80 --namespace kube-system</code> </pre> <br>  Agora, toda vez que voc√™ enviar uma solicita√ß√£o para a porta 3000 no computador, ela ser√° redirecionada para a porta 80 do pod com o controlador do Ingress.  Acessando <a href="http://localhost:3000/">http: // localhost: 3000</a> , voc√™ ver√° a p√°gina criada pelo aplicativo. <br><br><h2>  Resumo da porta </h2><br>  Vamos lembrar novamente quais portas e etiquetas devem corresponder: <br><br><ol><li>  O seletor na defini√ß√£o de Servi√ßo deve corresponder ao r√≥tulo do pod; </li><li>  <code>targetPort</code> na defini√ß√£o de Servi√ßo deve corresponder ao <code>containerPort</code> container dentro do pod; </li><li>  <code>port</code> na defini√ß√£o de servi√ßo pode ser qualquer coisa.  Servi√ßos diferentes podem usar a mesma porta porque possuem endere√ßos IP diferentes; </li><li>  <code>servicePort</code> Ingress deve corresponder √† <code>port</code> na defini√ß√£o de Servi√ßo; </li><li>  O nome do servi√ßo deve corresponder ao campo <code>serviceName</code> no Ingress. </li></ol><br>  Infelizmente, n√£o basta saber como estruturar corretamente sua configura√ß√£o YAML. <br><br>  <i>O que acontece quando algo d√° errado?</i> <br><br>  Talvez o pod n√£o inicie ou trava. <br><br><h2>  3 etapas para solucionar falhas de aplicativos no Kubernetes </h2><br>  Antes de depurar uma implanta√ß√£o, voc√™ precisa entender bem como o Kubernetes funciona. <br><br>  Como existem tr√™s componentes em cada aplicativo baixado para o K8s, eles devem ser depurados em uma determinada ordem, come√ßando da parte inferior. <br><br><ol><li>  Primeiro voc√™ precisa ter certeza de que os pods est√£o funcionando, ent√£o ... </li><li>  Verifique se o servi√ßo entrega tr√°fego aos pods e, em seguida, ... </li><li>  Verifique se o Ingress est√° configurado corretamente. </li></ol><br>  Apresenta√ß√£o visual: <br><br>  1) Inicie a busca de problemas deve estar na parte inferior.  Primeiro verifique se os pods t√™m status <code>Ready</code> e <code>Running</code> : <br><br><img src="https://habrastorage.org/webt/f-/lc/iz/f-lcizmfav5sb1sc7hvu8samwes.png"><br><br>  2) Se os pods estiverem <code>Ready</code> , voc√™ deve descobrir se o servi√ßo distribui o tr√°fego entre os pods: <br><br><img src="https://habrastorage.org/webt/yg/we/bu/ygwebumu8ga9lmd7krineuw38mq.png"><br><br>  3) Finalmente, voc√™ precisa analisar a conex√£o entre o servi√ßo e o Ingress: <br><br><img src="https://habrastorage.org/webt/y7/ze/uz/y7zeuzkhzgsdzcjmng2ei4fjrxg.png"><br><br><h2>  1. Diagn√≥stico de pods </h2><br>  Na maioria dos casos, o problema est√° no pod.  Verifique se os pods est√£o <code>Ready</code> e em <code>Running</code> .  Voc√™ pode verificar isso usando o comando: <br><br><pre> <code class="bash hljs">kubectl get pods NAME READY STATUS RESTARTS AGE app1 0/1 ImagePullBackOff 0 47h app2 0/1 Error 0 47h app3-76f9fcd46b-xbv4k 1/1 Running 1 47h</code> </pre> <br>  Na sa√≠da do comando acima, o √∫ltimo pod est√° listado como Em <code>Running</code> e <code>Ready</code> , mas para os outros dois, n√£o. <br><br>  <i>Como entender o que deu errado?</i> <br><br>  Existem quatro comandos √∫teis para diagnosticar pods: <br><br><ol><li>  <code>kubectl logs &lt; pod'&gt;</code> permite extrair logs de cont√™ineres no pod; </li><li>  <code>kubectl describe pod &lt; pod'&gt;</code> permite visualizar uma lista de eventos associados ao pod; </li><li>  <code>kubectl get pod &lt; pod'&gt;</code> permite que voc√™ obtenha a configura√ß√£o YAML do <code>kubectl get pod &lt; pod'&gt;</code> armazenado no Kubernetes; </li><li>  <code>kubectl exec -ti &lt; pod'&gt; bash</code> permite executar um shell de comando interativo em um dos cont√™ineres do pod </li></ol><br>  <i>Qual escolher?</i> <br><br>  O fato √© que n√£o h√° equipe universal.  Uma combina√ß√£o destes deve ser usada. <br><br><h3>  Problemas comuns no pod </h3><br>  Existem dois tipos principais de erros de pod: erros de inicializa√ß√£o e erros de tempo de execu√ß√£o. <br><br>  Erros de inicializa√ß√£o: <br><br><ul><li> <code>ImagePullBackoff</code> </li> <li> <code>ImageInspectError</code> </li> <li> <code>ErrImagePull</code> </li> <li> <code>ErrImageNeverPull</code> </li> <li> <code>RegistryUnavailable</code> </li> <li> <code>InvalidImageName</code> </li> </ul><br>  Erros de tempo de execu√ß√£o: <br><br><ul><li> <code>CrashLoopBackOff</code> </li> <li> <code>RunContainerError</code> </li> <li> <code>KillContainerError</code> </li> <li> <code>VerifyNonRootError</code> </li> <li> <code>RunInitContainerError</code> </li> <li> <code>CreatePodSandboxError</code> </li> <li> <code>ConfigPodSandboxError</code> </li> <li> <code>KillPodSandboxError</code> </li> <li> <code>SetupNetworkError</code> </li> <li> <code>TeardownNetworkError</code> </li> </ul><br>  Alguns erros s√£o mais comuns que outros.  Aqui est√£o alguns erros comuns e como corrigi-los. <br><br><h4>  ImagePullBackOff </h4><br>  Este erro aparece quando o Kubernetes n√£o pode obter uma imagem para um dos cont√™ineres de pod.  Aqui est√£o os tr√™s motivos mais comuns para isso: <br><br><ol><li>  O nome da imagem est√° especificado incorretamente - por exemplo, voc√™ cometeu um erro ou a imagem n√£o existe; </li><li>  Uma tag inexistente para a imagem √© especificada; </li><li>  A imagem √© armazenada em um registro privado e o Kubernetes n√£o tem autoridade para acess√°-la. </li></ol><br>  As duas primeiras raz√µes s√£o f√°ceis de eliminar - basta corrigir o nome e a etiqueta da imagem.  No caso deste √∫ltimo, voc√™ deve inserir as credenciais para o registro privado em Segredo e adicionar links a ele em pods.  A documenta√ß√£o do Kubernetes <a href="https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/">tem um exemplo</a> de como isso pode ser feito. <br><br><h4>  CrashLoopBackOff </h4><br>  O Kubenetes lan√ßar√° um erro CrashLoopBackOff se o cont√™iner n√£o puder iniciar.  Isso geralmente acontece quando: <br><br><ol><li>  H√° um erro no aplicativo que impede que ele seja iniciado; </li><li>  O cont√™iner est√° <a href="https://stackoverflow.com/questions/41604499/my-kubernetes-pods-keep-crashing-with-crashloopbackoff-but-i-cant-find-any-lo">configurado incorretamente</a> ; </li><li>  O teste de vida falhou muitas vezes. </li></ol><br>  Voc√™ deve tentar acessar os logs do cont√™iner para descobrir o motivo de sua falha.  Se o acesso aos logs for dif√≠cil, porque o cont√™iner √© reiniciado muito rapidamente, voc√™ pode usar o seguinte comando: <br><br><pre> <code class="bash hljs">kubectl logs &lt;pod-name&gt; --previous</code> </pre> <br>  Ele exibe mensagens de erro de uma reencarna√ß√£o anterior do cont√™iner. <br><br><h4>  RunContainerError </h4><br>  Este erro ocorre quando o cont√™iner falha ao iniciar.  Corresponde ao momento anterior ao lan√ßamento do aplicativo.  Geralmente, sua causa √© a configura√ß√£o incorreta, por exemplo: <br><br><ul><li>  Tentativa de montar um volume inexistente, como ConfigMap ou Secrets; </li><li>  tente montar um volume somente leitura como leitura e grava√ß√£o. </li></ul><br>  O <code>kubectl describe pod &lt;pod-name&gt;</code> √© adequado para analisar esses erros. <br><br><h3>  Pods pendentes </h3><br>  Ap√≥s a cria√ß√£o, o pod permanece no estado <code>Pending</code> . <br><br>  <i>Por que isso est√° acontecendo?</i> <br><br>  Aqui est√£o os poss√≠veis motivos (suponho que o agendador esteja funcionando bem): <br><br><ol><li>  O cluster n√£o possui recursos suficientes, como poder de processamento e mem√≥ria, para executar o pod. </li><li>  O objeto <code>ResourceQuota</code> √© instalado no espa√ßo para nome correspondente e a cria√ß√£o de um pod far√° com que o espa√ßo para nome ultrapasse a cota. </li><li>  O pod est√° vinculado a Pending <code>PersistentVolumeClaim</code> . </li></ol><br>  Nesse caso, √© recomend√°vel usar o comando <code>kubectl describe</code> e verificar a se√ß√£o <code>Events</code> : <br><br><pre> <code class="bash hljs">kubectl describe pod &lt;pod name&gt;</code> </pre> <br>  No caso de erros relacionados ao <code>ResourceQuotas</code> , √© recomend√°vel visualizar os logs do cluster usando o comando <br><br><pre> <code class="bash hljs">kubectl get events --sort-by=.metadata.creationTimestamp</code> </pre> <br><h3>  Pods n√£o prontos </h3><br>  Se o pod estiver listado como Em <code>Running</code> , mas n√£o estiver no estado <code>Ready</code> , a <i>sonda de</i> prontid√£o n√£o <i>ter√°</i> √™xito. <br><br>  Quando isso acontece, o pod n√£o se conecta ao servi√ßo e o tr√°fego n√£o flui para ele.  O teste de prontid√£o falhou devido a problemas de aplicativo.  Nesse caso, para encontrar o erro, voc√™ precisa analisar a se√ß√£o <code>Events</code> na sa√≠da do comando <code>kubectl describe</code> . <br><br><h2>  2. Diagn√≥stico de servi√ßos </h2><br>  Se os pods estiverem listados como Em <code>Running</code> e <code>Ready</code> , mas ainda n√£o houver resposta do aplicativo, verifique as configura√ß√µes do servi√ßo. <br><br>  Os servi√ßos est√£o envolvidos no roteamento de tr√°fego para os pods, dependendo de seus r√≥tulos.  Portanto, a primeira coisa a fazer √© verificar quantos pods funcionam com o servi√ßo.  Para fazer isso, voc√™ pode verificar os pontos de extremidade no servi√ßo: <br><br><pre> <code class="bash hljs">kubectl describe service &lt;service-name&gt; | grep Endpoints</code> </pre> <br>  O ponto de extremidade √© um par de valores no formato <code>&lt;IP-:&gt;</code> e pelo menos um desses pares deve estar presente na sa√≠da (ou seja, pelo menos um pod funciona com o servi√ßo). <br><br>  Se a se√ß√£o <code>Endpoins</code> vazia, duas op√ß√µes ser√£o poss√≠veis: <br><br><ol><li>  n√£o h√° pods com o r√≥tulo correto (dica: verifique se o espa√ßo para nome est√° selecionado corretamente); </li><li>  H√° um erro nas etiquetas de servi√ßo no seletor. </li></ol><br>  Se voc√™ vir uma lista de pontos de extremidade, mas ainda n√£o conseguir acessar o aplicativo, o prov√°vel culpado √© o erro no <code>targetPort</code> na descri√ß√£o do servi√ßo. <br><br>  <i>Como verificar a capacidade de manuten√ß√£o do servi√ßo?</i> <br><br>  Independentemente do tipo de servi√ßo, voc√™ pode usar o <code>kubectl port-forward</code> para se conectar a ele: <br><br><pre> <code class="bash hljs">kubectl port-forward service/&lt;service-name&gt; 3000:80</code> </pre> <br>  Aqui: <br><br><ul><li>  <code>&lt;service-name&gt;</code> - o nome do servi√ßo; </li><li>  3000 - a porta que voc√™ abre no computador; </li><li>  80 - porta no lado do servi√ßo. </li></ul><br><h2>  3. Diagn√≥stico do ingresso </h2><br>  Se voc√™ ler este lugar, ent√£o: <br><br><ul><li>  os pods est√£o listados como <code>Running</code> and <code>Ready</code> ; </li><li>  o servi√ßo distribui com sucesso o tr√°fego entre os pods. </li></ul><br>  No entanto, voc√™ ainda n√£o pode "alcan√ßar" o aplicativo. <br><br>  Isso significa que, muito provavelmente, o controlador do Ingress est√° configurado incorretamente.  Como o controlador do Ingress √© um componente de terceiros no cluster, existem v√°rios m√©todos de depura√ß√£o, dependendo do seu tipo. <br><br>  Mas antes de recorrer a ferramentas especiais para configurar o Ingress, voc√™ pode fazer algo muito simples.  O Ingress usa <code>serviceName</code> e <code>servicePort</code> para se conectar ao servi√ßo.  Voc√™ deve verificar se eles est√£o configurados corretamente.  Voc√™ pode fazer isso usando o comando: <br><br><pre> <code class="bash hljs">kubectl describe ingress &lt;ingress-name&gt;</code> </pre> <br>  Se a coluna <code>Backend</code> - <code>Backend</code> estiver vazia, h√° uma grande chance de um erro de configura√ß√£o.  Se os back-end estiverem instalados, mas ainda n√£o houver acesso ao aplicativo, o problema poder√° estar relacionado a: <br><br><ul><li>  Configura√ß√µes de acessibilidade do ingresso da Internet p√∫blica; </li><li>  configura√ß√µes de acessibilidade de cluster da Internet p√∫blica. </li></ul><br>  Voc√™ pode identificar problemas de infraestrutura conectando-se diretamente ao pod do Ingress.  Para fazer isso, primeiro encontre o pod do controlador do Ingress (ele pode estar em um espa√ßo para nome diferente): <br><br><pre> <code class="bash hljs">kubectl get pods --all-namespaces NAMESPACE NAME READY STATUS kube-system coredns-5644d7b6d9-jn7cq 1/1 Running kube-system etcd-minikube 1/1 Running kube-system kube-apiserver-minikube 1/1 Running kube-system kube-controller-manager-minikube 1/1 Running kube-system kube-proxy-zvf2h 1/1 Running kube-system kube-scheduler-minikube 1/1 Running kube-system nginx-ingress-controller-6fc5bcc 1/1 Running</code> </pre> <br>  Use o comando de <code>describe</code> para definir a porta: <br><br><pre> <code class="bash hljs">kubectl describe pod nginx-ingress-controller-6fc5bcc --namespace kube-system \ | grep Ports</code> </pre> <br>  Por fim, conecte-se ao pod: <br><br><pre> <code class="bash hljs">kubectl port-forward nginx-ingress-controller-6fc5bcc 3000:80 --namespace kube-system</code> </pre> <br>  Agora, todos os pedidos da porta 3000 no computador ser√£o redirecionados para o pod da porta 80. <br><br>  <i>Isso funciona agora?</i> <br><br><ul><li>  Nesse caso, o problema est√° na infraestrutura.  √â necess√°rio descobrir exatamente como o tr√°fego √© roteado para o cluster. </li><li>  Caso contr√°rio, o problema est√° no controlador do Ingress. </li></ul><br>  Se voc√™ n√£o conseguir que o controlador do Ingress funcione, ser√° necess√°rio depur√°-lo. <br><br>  Existem muitas variedades de controladores do Ingress.  Os mais populares s√£o Nginx, HAProxy, Traefik etc. <i>(para obter mais informa√ß√µes sobre solu√ß√µes existentes, consulte <a href="https://habr.com/ru/company/flant/blog/447180/">nossa revis√£o</a> - aprox. Transl.) Voc√™</i> deve usar o guia de solu√ß√£o de problemas na documenta√ß√£o do controlador correspondente.  Como o <a href="https://github.com/kubernetes/ingress-nginx">Ingress Nginx</a> √© o controlador de ingresso mais popular, inclu√≠mos algumas dicas sobre como resolver problemas relacionados neste artigo. <br><br><h3>  Depurando um controlador Nginx do Ingress </h3><br><br>  O projeto Ingress-nginx possui um <a href="https://kubernetes.github.io/ingress-nginx/kubectl-plugin/">plugin</a> oficial <a href="https://kubernetes.github.io/ingress-nginx/kubectl-plugin/">para o kubectl</a> .  O <code>kubectl ingress-nginx</code> pode ser usado para: <br><br><ul><li>  an√°lise de logs, backends, certificados, etc; </li><li>  conex√£o com o Ingress; </li><li>  estudando a configura√ß√£o atual. </li></ul><br>  As tr√™s equipes a seguir o ajudar√£o com isso: <br><br><ul><li>  <code>kubectl ingress-nginx lint</code> - verifica o <code>nginx.conf</code> ; </li><li>  <code>kubectl ingress-nginx backend</code> - examina o back-end (semelhante ao <code>kubectl describe ingress &lt;ingress-name&gt;</code> ); </li><li>  <code>kubectl ingress-nginx logs</code> - verifica os logs. </li></ul><br>  Observe que, em alguns casos, pode ser necess√°rio especificar o espa√ßo para nome correto para o controlador Ingress usando o <code>--namespace &lt;name&gt;</code> . <br><br><h2>  Sum√°rio </h2><br>  Diagnosticar o Kubernetes pode ser uma tarefa assustadora, se voc√™ n√£o sabe por onde come√ßar.  O problema sempre deve ser abordado de acordo com o princ√≠pio de baixo para cima: comece com pods e depois v√° para o servi√ßo e o Ingress.  Os m√©todos de depura√ß√£o descritos no artigo podem ser aplicados a outros objetos, como: <br><br><ul><li>  Jobs ociosos e CronJobs; </li><li>  StatefulSets e DaemonSets. </li></ul><br>  Agrade√ßo a <a href="https://github.com/errge">Gergely Risko</a> , <a href="https://medium.com/%40weibeld">Daniel Weibel</a> e <a href="https://www.linkedin.com/in/charles-christyraj-0bab8a36/">Charles Christyraj</a> pelos valiosos coment√°rios e adi√ß√µes. <br><br><h2>  PS do tradutor </h2><br>  Leia tamb√©m em nosso blog: <br><br><ul><li>  ‚Äú <a href="https://habr.com/ru/company/flant/blog/436112/">Plugin Kubectl-debug para depura√ß√£o nos pods do Kubernetes</a> ‚Äù; </li><li>  ‚Äú <a href="https://habr.com/ru/company/flant/blog/443458/">6 erros divertidos do sistema na opera√ß√£o do Kubernetes [e sua solu√ß√£o]</a> ‚Äù; </li><li>  ‚Äú <a href="https://habr.com/ru/company/flant/blog/462707/">Ferramentas para desenvolvedores de aplicativos em execu√ß√£o no Kubernetes</a> ‚Äù; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/471892/">6 hist√≥rias pr√°ticas da nossa vida cotidiana no SRE</a> ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484954/">https://habr.com/ru/post/pt484954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484936/index.html">Conhecimento e compet√™ncias da equipe: encontre, veja, bombeie</a></li>
<li><a href="../pt484944/index.html">O que eu estou no ACID ou n√£o nos conv√©m</a></li>
<li><a href="../pt484946/index.html">Modelagem GPR</a></li>
<li><a href="../pt484948/index.html">NEC lan√ßou um cabo submarino com um recorde de 20 pares de fibras √≥pticas</a></li>
<li><a href="../pt484952/index.html">Substituindo Redux por Observables e React Hooks</a></li>
<li><a href="../pt484964/index.html">Configurando o balanceamento de carga no InfoWatch Traffic Monitor</a></li>
<li><a href="../pt484966/index.html">Modelo pronto para teste usando o Spring</a></li>
<li><a href="../pt484968/index.html">WPF DataGrid. Lutar por modelo</a></li>
<li><a href="../pt484972/index.html">Lan√ßamento do Wine 5.0</a></li>
<li><a href="../pt484974/index.html">Telhas Wang para simula√ß√£o de m√°quina de Turing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>