<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏿 🐘 👌🏼 Prise en charge de la file d'attente Hangfire 👨‍✈️ 🤞🏿 👩🏾‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hangfire est une bibliothèque pour .net (core), qui permet l'exécution asynchrone de certains codes sur le principe du "feu et oublie". Un exemple d'u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prise en charge de la file d'attente Hangfire</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434364/"><p>  Hangfire est une bibliothèque pour .net (core), qui permet l'exécution asynchrone de certains codes sur le principe du "feu et oublie".  Un exemple d'un tel code peut être l'envoi d'e-mails, le traitement vidéo, la synchronisation avec un autre système, etc.  En plus de "tirer et oublier", il existe un support pour les tâches différées, ainsi que les tâches planifiées au format Cron. </p><br><p>  Actuellement, il existe de nombreuses bibliothèques de ce type.  Voici quelques-uns des avantages de Hangfire: </p><br><ul><li>  Configuration simple, API pratique </li><li>  Fiabilité  Hangfire garantit que la tâche créée sera exécutée au moins une fois </li><li>  Capacité à effectuer des tâches en parallèle et d'excellentes performances </li><li>  Extensibilité (ici, nous allons l'utiliser ci-dessous) </li><li>  Documentation assez complète et compréhensible </li><li>  Tableau de bord sur lequel vous pouvez voir toutes les statistiques sur les tâches </li></ul><br><p>  Je n'entrerai pas dans trop de détails, car il existe de nombreux bons articles sur Hangfire et comment l'utiliser.  Dans cet article, je vais expliquer comment utiliser la prise en charge de plusieurs files d'attente (ou pools de tâches), comment corriger la fonctionnalité de nouvelle tentative standard et faire en sorte que chaque file d'attente ait une configuration individuelle. </p><a name="habracut"></a><br><h3 id="suschestvuyuschaya-podderzhka-psevdo-ocheredey">  Prise en charge existante des (pseudo) files d'attente </h3><br><p>  Remarque importante: dans le titre, j'ai utilisé le terme pseudo-file d'attente car Hangfire ne garantit pas que les tâches seront exécutées dans un ordre spécifique.  C'est-à-dire  le principe du «premier entré, premier sorti» ne s'applique pas et nous ne nous y fierons pas.  De plus, l'auteur de la bibliothèque recommande de rendre les tâches idempotentes, c'est-à-dire  stable contre l'exécution multiple imprévue.  De plus, je n'utiliserai que le mot "queue", car  Hangfire utilise le terme "file d'attente". </p><br><p>  Hangfire a un support simple de file d'attente.  Bien qu'il n'offre pas la flexibilité des systèmes Message Queue tels que rabbitMQ ou Azure Service Bus, il est souvent suffisant pour résoudre un large éventail de tâches. </p><br><p>  Chaque tâche a la propriété "Queue", c'est-à-dire le nom de la file d'attente dans laquelle elle doit être exécutée.  Par défaut, la tâche est envoyée à la file d'attente avec le nom "default", sauf indication contraire.  La prise en charge de plusieurs files d'attente est nécessaire afin de gérer séparément l'exécution de tâches de différents types.  Par exemple, nous pouvons souhaiter que les tâches de traitement vidéo tombent dans la file d'attente "video_queue" et envoient des e-mails à la file d'attente "email_queue".  Ainsi, nous sommes en mesure d'effectuer indépendamment ces deux types de tâches.  Si nous voulons déplacer le traitement vidéo vers un serveur dédié, nous pouvons facilement le faire en exécutant un serveur Hangfire séparé en tant qu'application console qui traitera la file d'attente "video_queue". </p><br><h3 id="pereydem-k-praktike">  Passons à la pratique </h3><br><p>  La configuration du serveur Hangfire dans le noyau asp.net est la suivante: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.UseHangfireServer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BackgroundJobServerOptions { WorkerCount = <span class="hljs-number"><span class="hljs-number">2</span></span>, Queues = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">"email_queue"</span></span>, <span class="hljs-string"><span class="hljs-string">"video_queue"</span></span> } }); }</code> </pre> <br><h3 id="problema-1---zadachi-pri-povtore-popadayut-v-ochered-default">  Problème 1 - Les tâches de relecture tombent dans la file d'attente par défaut </h3><br><p>  Comme je l'ai mentionné ci-dessus, il y a une file d'attente par défaut dans Hangfire appelée "par défaut".  Si une tâche placée dans la file d'attente, par exemple, "video_queue", a échoué et doit être réessayée, elle sera à nouveau envoyée dans la file d'attente "par défaut" et non "video_queue" et, par conséquent, notre tâche ne sera pas exécutée du tout l'instance du serveur Hangfire que nous aimerions, le cas échéant.  Ce comportement a été établi par moi expérimentalement et est probablement un bogue dans Hangfire lui-même. </p><br><h4 id="job-filters">  Filtres de travail </h4><br><p>  Hangfire nous offre la possibilité d'étendre la fonctionnalité à l'aide de filtres dits ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">filtres de travaux</a> ), qui sont similaires en principe aux filtres d'actions dans ASP.NET MVC.  Le fait est que la logique interne de Hangfire est implémentée comme une machine d'état.  Il s'agit d'un moteur qui transfère séquentiellement les tâches du pool d'un état à un autre (par exemple, créé -&gt; mis en file d'attente -&gt; traitement -&gt; réussi), et les filtres nous permettent "d'intercepter" la tâche qui est exécutée à chaque fois que son état change et de la manipuler.  Un filtre est implémenté en tant qu'attribut qui peut être appliqué à une seule méthode, classe ou globalement. </p><br><h4 id="job-parameters">  Paramètres du travail </h4><br><p>  L'objet ElectStateContext est transmis en tant qu'argument à la méthode de filtrage.  Cet objet contient des informations complètes sur la tâche en cours.  Entre autres choses, il a les méthodes GetJobParameter &lt;&gt; (...) et SettJobParameter &lt;&gt; (...).  Les paramètres de travail vous permettent d'enregistrer des informations relatives à une tâche dans une base de données.  C'est dans les paramètres du travail que le nom de la file d'attente à laquelle la tâche a été envoyée à l'origine est stocké, mais pour une raison quelconque, ces informations sont ignorées lors d'une répétition ultérieure. </p><br><h3 id="reshenie">  Solution </h3><br><p>  Nous avons donc une tâche qui s'est terminée par erreur et doit être envoyée pour être réexécutée dans la file d'attente de droite (dans la même qui lui a été affectée au moment de la création initiale).  La répétition d'une tâche qui s'est terminée avec une erreur est une transition de l'état "échoué" à l'état "mis en file d'attente".  Pour résoudre le problème, créez un filtre qui, lorsque la tâche entrera dans l'état "en file d'attente", vérifiera dans quelle file d'attente la tâche a été envoyée initialement et mettra le paramètre "QueueName" dans la valeur souhaitée: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireUseCorrectQueueFilter</span></span> : <span class="hljs-title"><span class="hljs-title">JobFilterAttribute</span></span>, <span class="hljs-title"><span class="hljs-title">IElectStateFilter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStateElection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElectStateContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.CandidateState <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> EnqueuedState enqueuedState) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queueName = context.GetJobParameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"QueueName"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(queueName)) { context.SetJobParameter(<span class="hljs-string"><span class="hljs-string">"QueueName"</span></span>, enqueuedState.Queue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { enqueuedState.Queue = queueName; } } } }</code> </pre> <br><p>  Afin d'appliquer le filtre par défaut à toutes les tâches (c'est-à-dire globalement), ajoutez le code suivant à notre configuration: </p><br><pre> <code class="cs hljs">GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireUseCorrectQueueFilter { Order = <span class="hljs-number"><span class="hljs-number">1</span></span> });</code> </pre> <br><p>  Un autre petit inconvénient est que la collection GlobalJobFilters contient par défaut une instance de la classe AutomaticRetryAttribute.  Il s'agit d'un filtre standard chargé de réexécuter les tâches ayant échoué.  Il envoie également la tâche à la file d'attente "par défaut", ignorant la file d'attente d'origine.  Pour que notre vélo roule, vous devez retirer ce filtre de la collection et laisser notre filtre prendre la responsabilité des tâches répétées.  Par conséquent, le code de configuration ressemblera à ceci: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultRetryFilter = GlobalJobFilters.Filters .FirstOrDefault(f =&gt; f.Instance <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> AutomaticRetryAttribute); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (defaultRetryFilter != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; defaultRetryFilter.Instance != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { GlobalJobFilters.Filters.Remove(defaultRetryFilter.Instance); } GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireUseCorrectQueueFilter { Order = <span class="hljs-number"><span class="hljs-number">1</span></span> });</code> </pre> <br><p>  Il convient de noter que AutomaticRetryAttribute implémente la logique d'augmenter automatiquement l'intervalle entre les tentatives (l'intervalle augmente à chaque tentative suivante), et en supprimant AutomaticRetryAttribute de la collection GlobalJobFilters, nous abandonnons cette fonctionnalité (voir la mise en œuvre de la méthode <a href="">ScheduleAgainLater</a> ) </p><br><p>  Ainsi, nous avons réalisé que nos tâches peuvent être effectuées dans différentes files d'attente, ce qui nous permet de gérer indépendamment leur exécution, y compris le traitement de différentes files d'attente sur différentes machines.  Seulement maintenant, nous ne savons pas combien de fois et à quel intervalle nos tâches seront répétées en cas d'erreur, car nous avons supprimé AutomaticRetryAttribute de la collection de filtres. </p><br><h3 id="problema-2---individualnye-nastroyki-dlya-kazhdoy-ocheredi">  Problème 2 - Paramètres individuels pour chaque file d'attente </h3><br><p>  Nous voulons pouvoir configurer l'intervalle et le nombre de répétitions séparément pour chaque file d'attente, et aussi, si pour une file d'attente nous n'avons pas spécifié de valeurs explicitement, nous voulons que les valeurs par défaut soient appliquées.  Pour ce faire, nous implémentons un autre filtre et l'appelons <code>HangfireRetryJobFilter</code> . </p><br><p>  Idéalement, le code de configuration devrait ressembler à ceci: </p><br><pre> <code class="cs hljs">GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireRetryJobFilter { Order = <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-string"><span class="hljs-string">"email_queue"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { DelayInSeconds = <span class="hljs-number"><span class="hljs-number">120</span></span>, RetryAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span> }, [<span class="hljs-string"><span class="hljs-string">"video_queue"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { DelayInSeconds = <span class="hljs-number"><span class="hljs-number">60</span></span>, RetryAttempts = <span class="hljs-number"><span class="hljs-number">5</span></span> } });</code> </pre> <br><h3 id="reshenie-1">  Solution </h3><br><p>  Pour ce faire, ajoutez d'abord la classe <code>HangfireQueueSettings</code> , qui servira de conteneur pour nos paramètres. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireQueueSettings</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RetryAttempts { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DelayInSeconds { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  Ensuite, nous ajoutons l'implémentation du filtre lui-même qui, lorsque les tâches sont répétées après une erreur, appliquera les paramètres en fonction de la configuration de la file d'attente et surveillera le nombre de tentatives: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireRetryJobFilter</span></span> : <span class="hljs-title"><span class="hljs-title">JobFilterAttribute</span></span>, <span class="hljs-title"><span class="hljs-title">IElectStateFilter</span></span>, <span class="hljs-title"><span class="hljs-title">IApplyStateFilter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HangfireQueueSettings _defaultQueueSettings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { RetryAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span>, DelayInSeconds = <span class="hljs-number"><span class="hljs-number">10</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, HangfireQueueSettings&gt; _settings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, HangfireQueueSettings&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HangfireQueueSettings <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> queueName] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _settings.TryGetValue(queueName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> HangfireQueueSettings queueSettings) ? queueSettings : _defaultQueueSettings; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _settings[queueName] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStateElection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElectStateContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(context.CandidateState <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> FailedState failedState)) { <span class="hljs-comment"><span class="hljs-comment">// This filter accepts only failed job state. return; } var retryAttempt = context.GetJobParameter&lt;int&gt;("RetryCount") + 1; var queueName = context.GetJobParameter&lt;string&gt;("QueueName"); if (retryAttempt &lt;= this[queueName].RetryAttempts) { ScheduleAgainLater(context, retryAttempt, failedState, queueName); } else { TransitionToDeleted(context, failedState, queueName); } } public void OnStateApplied( ApplyStateContext context, IWriteOnlyTransaction transaction) { if (context.NewState is ScheduledState &amp;&amp; context.NewState.Reason != null &amp;&amp; context.NewState.Reason.StartsWith("Retry attempt")) { transaction.AddToSet("retries", context.BackgroundJob.Id); } } public void OnStateUnapplied( ApplyStateContext context, IWriteOnlyTransaction transaction) { if (context.OldStateName == ScheduledState.StateName) { transaction.RemoveFromSet("retries", context.BackgroundJob.Id); } } private void ScheduleAgainLater( ElectStateContext context, int retryAttempt, FailedState failedState, string queueName) { context.SetJobParameter("RetryCount", retryAttempt); var delay = TimeSpan.FromSeconds(this[queueName].DelayInSeconds); const int maxMessageLength = 50; var exceptionMessage = failedState.Exception.Message.Length &gt; maxMessageLength ? failedState.Exception.Message.Substring(0, maxMessageLength - 1) + "…" : failedState.Exception.Message; // If attempt number is less than max attempts, we should // schedule the job to run again later. var reason = $"Retry attempt {retryAttempt} of {this[queueName].RetryAttempts}: {exceptionMessage}"; context.CandidateState = delay == TimeSpan.Zero ? (IState)new EnqueuedState { Reason = reason } : new ScheduledState(delay) { Reason = reason }; } private void TransitionToDeleted( ElectStateContext context, FailedState failedState, string queueName) { context.CandidateState = new DeletedState { Reason = this[queueName].RetryAttempts &gt; 0 ? "Exceeded the maximum number of retry attempts." : "Retries were disabled for this job." }; } }</span></span></code> </pre> <br><blockquote>  Remarque sur le code: lors de l'implémentation de la classe <code>HangfireRetryJobFilter</code> , la classe <code>AutomaticRetryAttribute</code> de <code>HangfireRetryJobFilter</code> été prise comme base, par conséquent, l'implémentation de certaines méthodes coïncide partiellement avec les méthodes correspondantes de cette classe. </blockquote><br><h3 id="problema-3---kak-otpravit-zadachu-na-vypolnenie-v-konkretnuyu-ochered">  Problème 3 - Comment envoyer une tâche à une file d'attente spécifique? </h3><br><p>  J'ai réussi à trouver deux façons d'affecter la tâche à la file d'attente: documentée et - non. </p><br><p>  <strong>1ère méthode</strong> - accrochez l'attribut correspondant à la méthode </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Queue(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"video_queue"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } BackgroundJob.Enqueue(() =&gt; SomeMethod());</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://docs.hangfire.io/en/latest/background-processing/configuring-queues.html</a> </p><br><p>  <strong>2ème méthode</strong> (non documentée) - utilisez la classe <code>BackgroundJobClient</code> </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BackgroundJobClient(); client.Create(() =&gt; MyMethod(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnqueuedState(<span class="hljs-string"><span class="hljs-string">"video_queue"</span></span>));</code> </pre> <br><p>  L'avantage de la deuxième méthode est qu'elle ne crée pas de dépendances inutiles sur Hangfire et vous permet de décider pendant quel processus la tâche doit aller.  Malheureusement, dans la documentation officielle, je n'ai trouvé aucune mention de la classe <code>BackgroundJobClient</code> et comment l'appliquer.  J'ai utilisé la deuxième méthode dans ma solution, elle est donc testée en pratique. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Dans cet article, nous avons utilisé la prise en charge de plusieurs files d'attente dans Hangfire pour séparer le traitement de différents types de tâches.  Nous avons implémenté notre mécanisme pour répéter les tâches terminées sans succès avec la possibilité d'une configuration individuelle pour chaque file d'attente, élargissant les fonctionnalités de Hangfire à l'aide des filtres de travaux, et avons également appris comment envoyer des tâches pour exécution à la file d'attente souhaitée. </p><br><p>  J'espère que cet article sera utile à quelqu'un.  Je me ferai un plaisir de commenter. </p><br><h3 id="poleznye-ssylki">  Liens utiles </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation Hangfire</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source de Hangfire</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scott Hanselman - Comment exécuter des tâches d'arrière-plan dans ASP.NET</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434364/">https://habr.com/ru/post/fr434364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434354/index.html">Création d'un modèle de reconnaissance faciale à l'aide du deep learning en Python</a></li>
<li><a href="../fr434356/index.html">Python Stiller avec e-mail</a></li>
<li><a href="../fr434358/index.html">Substitution d'importation de systèmes d'exploitation. Comment puis-je voir le système d'exploitation national</a></li>
<li><a href="../fr434360/index.html">Discussion expliquée sur la programmation asynchrone en Javascript</a></li>
<li><a href="../fr434362/index.html">PAS prévu pour 2019</a></li>
<li><a href="../fr434368/index.html">Apprentissage automatique pour trouver des erreurs dans le code: comment j'ai effectué un stage chez JetBrains Research</a></li>
<li><a href="../fr434370/index.html">Un autre conquérant de l'ombre à Phaser, ou l'utilisation de vélos</a></li>
<li><a href="../fr434374/index.html">Vérification de RBAC dans Kubernetes</a></li>
<li><a href="../fr434380/index.html">Bases de l'injection de dépendance</a></li>
<li><a href="../fr434382/index.html">Portage d'Alpine Linux vers RISC-V</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>