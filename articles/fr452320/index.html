<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëó ü§´ üç∂ MVCC-6. Le nettoyage üë®üèª‚Äçüç≥ ü§∂üèº ‚òπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons commenc√© par des probl√®mes li√©s √† l' isolement , avons fait une digression sur l' organisation des donn√©es √† un bas niveau , puis avons par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-6. Le nettoyage</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452320/">  Nous avons commenc√© par des probl√®mes li√©s √† l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isolement</a> , avons fait une digression sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">organisation des donn√©es √† un bas niveau</a> , puis avons parl√© en d√©tail des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">versions de ligne</a> et de la fa√ßon dont les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instantan√©s</a> sont obtenus √† partir des versions. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La derni√®re fois,</a> nous avons parl√© des mises √† jour HOT et du nettoyage sur la page, et aujourd'hui nous allons jeter un ≈ìil au c√©l√®bre nettoyage ordinaire, l' <em>aspirateur vulgaris</em> .  Oui, tant de choses ont d√©j√† √©t√© √©crites √† son sujet qu'il est peu probable que je dise quelque chose de nouveau, mais l'exhaustivit√© de l'image n√©cessite un sacrifice.  Soyez patient. <br><br><h1>  Nettoyage normal (aspirateur) </h1><br><h2>  Que fait le nettoyage </h2><br>  Le nettoyage intra-page est rapide, mais ne lib√®re qu'une fraction de l'espace.  Il fonctionne dans la m√™me page tabulaire et n'affecte pas les index. <br><br>  Le nettoyage principal ¬´normal¬ª est effectu√© par la commande VACUUM et nous l'appellerons simplement nettoyage (et nous parlerons de l'autonettoyage s√©par√©ment). <br><br>  Ainsi, le nettoyage traite compl√®tement la table.  Il nettoie non seulement les versions inutiles des cha√Ænes, mais √©galement les r√©f√©rences √† celles-ci de tous les index. <br><br>  Le traitement se d√©roule en parall√®le avec d'autres activit√©s du syst√®me.  Dans ce cas, la table et les index peuvent √™tre utilis√©s de la mani√®re habituelle √† la fois pour la lecture et pour la modification (cependant, l'ex√©cution simultan√©e de commandes telles que CREATE INDEX, ALTER TABLE et quelques autres sera impossible). <br><br>  Seules les pages dans lesquelles une certaine activit√© s'est produite sont affich√©es dans le tableau.  Pour cela, une carte de visibilit√© est utilis√©e (je vous rappelle que les pages contenant uniquement des versions de lignes assez anciennes qui sont garanties d'√™tre visibles dans tous les instantan√©s de donn√©es y sont marqu√©es).  Seules les pages non marqu√©es sur la carte sont trait√©es, tandis que la carte elle-m√™me est mise √† jour. <br><br>  Dans le processus, la carte d'espace libre est mise √† jour pour refl√©ter l'espace libre qui appara√Æt dans les pages. <br><a name="habracut"></a><br>  Comme d'habitude, cr√©ez un tableau: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> vac_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> vac(s); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre> <br>  En utilisant le param√®tre <em>autovacuum_enabled,</em> nous d√©sactivons le nettoyage automatique.  Nous en reparlerons la prochaine fois, mais pour l'instant - pour les exp√©rimentations - il est important pour nous de g√©rer le nettoyage manuellement. <br><br>  Il existe maintenant trois versions de la ligne dans le tableau, et chacune est li√©e √† partir d'un index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 4000 (c) | 4001 (c) | | | (0,2) (0,2) | normal | 4001 (c) | 4002 | | | (0,3) (0,3) | normal | 4002 | 0 (a) | | | (0,3) (3 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) (3 rows)</code> </pre><br>  Apr√®s le nettoyage, les versions "mortes" disparaissent et il n'y en a qu'une, pertinente.  Et l'index a √©galement un lien √† gauche: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4002 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br>  Veuillez noter que les deux premiers pointeurs ont re√ßu le statut inutilis√© et non mort, comme ce serait le cas avec le nettoyage intra-page. <br><br><h2>  Et encore une fois sur l'horizon des transactions </h2><br>  Comment PostgreSQL d√©termine-t-il quelles versions de lignes peuvent √™tre consid√©r√©es comme ¬´mortes¬ª?  Nous avons d√©j√† envisag√© le concept d'un horizon de transaction lorsque nous avons parl√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'</a> instantan√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">donn√©es</a> , mais c'est un sujet tellement important que ce n'est pas un p√©ch√© de le r√©p√©ter. <br><br>  Reprenons l'exp√©rience pr√©c√©dente. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Mais avant de mettre √† jour la ligne √† nouveau, laissez une autre transaction commencer (mais pas se terminer).  Dans notre exemple, cela fonctionnera au niveau de lecture valid√©e, mais devrait obtenir un vrai num√©ro de transaction (non virtuel).  Par exemple, il peut changer ou m√™me simplement verrouiller certaines lignes dans n'importe quelle table, pas n√©cessairement dans vac: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><pre> <code class="plaintext hljs">| s | ----- | FOO | BAR | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre><br>  Il y a trois lignes dans le tableau et trois liens dans l'index.  Que se passe-t-il apr√®s le nettoyage? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | normal | 4005 (c) | 4007 (c) | | | (0,3) (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,3) (2 rows)</code> </pre><br>  Il reste deux versions de la ligne dans le tableau: le nettoyage a d√©cid√© que la version (0.2) ne pouvait pas encore √™tre supprim√©e.  La raison, bien s√ªr, est dans l'horizon des transactions de la base de donn√©es, qui dans notre exemple est d√©termin√© par une transaction incompl√®te: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| backend_xmin | -------------- | 4006 | (1 row)</code> </pre><br>  Vous pouvez demander un nettoyage pour parler de ce qui se passe: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: index "vac_s" now contains 2 row versions in 2 pages DETAIL: 0 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 0 removable, 2 nonremovable row versions in 1 out of 1 pages DETAIL: 1 dead row versions cannot be removed yet, oldest xmin: 4006 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Veuillez noter: <br><br><ul><li>  2 versions de ligne non amovibles - 2 versions ont √©t√© trouv√©es dans le tableau qui ne peuvent pas √™tre supprim√©es, </li><li>  1 versions de ligne morte ne peuvent pas encore √™tre supprim√©es - dont 1 ¬´mort¬ª, </li><li>  le xmin le plus ancien montre l'horizon actuel. </li></ul><br>  Nous r√©p√©tons une fois de plus la conclusion: la pr√©sence de transactions de longue dur√©e dans la base de donn√©es (non termin√©es ou tr√®s longues) peut conduire √† l'expansion des tables (gonfl√©es), quelle que soit la fr√©quence du nettoyage.  Par cons√©quent, dans PostgreSQL, les charges de travail OLTP et OLAP sont mal combin√©es dans une seule base de donn√©es: les rapports qui s'ex√©cutent pendant des heures ne permettront pas d'effacer les tables fr√©quemment mises √† jour √† temps.  Une solution possible serait de cr√©er une r√©plique de ¬´rapport¬ª distincte. <br><br>  Apr√®s l'ach√®vement d'une transaction ouverte, l'horizon change et la situation est corrig√©e: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: scanned index "vac_s" to remove 1 row versions DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: "vac": removed 1 row versions in 1 pages DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: index "vac_s" now contains 1 row versions in 2 pages DETAIL: 1 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 1 removable, 1 nonremovable row versions in 1 out of 1 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4008 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Maintenant, la page n'a que la derni√®re version actuelle de la ligne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><br>  Il n'y a √©galement qu'une seule entr√©e dans l'index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br><h2>  Que se passe-t-il √† l'int√©rieur </h2><br>  Le nettoyage doit traiter √† la fois la table et les index en m√™me temps et de mani√®re √† ne pas bloquer le fonctionnement des autres processus.  Comment fait-elle? <br><br>  Tout commence par <strong>un scan de table</strong> (en tenant compte de la carte de visibilit√©, comme d√©j√† indiqu√©).  Dans les pages lues, les versions inutiles des cha√Ænes sont d√©termin√©es et leurs identificateurs (tid) sont √©crits dans un tableau sp√©cial.  La baie est situ√©e dans la m√©moire locale du processus de nettoyage;  un fragment de taille <em>maintenance_work_mem lui</em> est allou√©.  La valeur par d√©faut de ce param√®tre est 64 Mo.  Notez que cette m√©moire est allou√©e imm√©diatement dans son int√©gralit√©, et pas au besoin.  Vrai, si la table est petite, alors le fragment est allou√© moins. <br><br>  Ensuite, l'une des deux choses: soit nous atteindrons la fin de la table, soit la m√©moire allou√©e au tableau se terminera.  Dans l'un ou l'autre des deux cas, <strong>la phase de nettoyage d'index</strong> commence.  Pour ce faire, <em>chacun</em> des index cr√©√©s sur la table est <em>enti√®rement analys√©</em> √† la recherche d'enregistrements faisant r√©f√©rence aux versions stock√©es des lignes.  Les enregistrements trouv√©s sont effac√©s des pages d'index. <br><br>  √Ä ce stade, nous obtenons l'image suivante: dans les index, il n'y a plus de liens vers des versions inutiles de lignes, mais ils existent toujours dans la table.  Cela ne contredit rien: lors de l'ex√©cution d'une requ√™te, soit nous n'atteignons pas du tout les versions mortes des lignes (avec acc√®s √† l'index), soit nous les marquons lors de la v√©rification de la visibilit√© (lors de l'analyse d'une table). <br><br>  Apr√®s cela, <strong>la phase de nettoyage de la table</strong> commence.  Le tableau est √† nouveau analys√© pour lire les pages n√©cessaires, pour en supprimer les versions stock√©es des lignes et pour lib√©rer les pointeurs.  Nous pouvons le faire car il n'y a plus de liens √† partir des index. <br><br>  Si le tableau n'a pas √©t√© compl√®tement lu lors de la premi√®re passe, le tableau est effac√© et tout est r√©p√©t√© depuis l'endroit o√π nous nous sommes arr√™t√©s. <br><br>  De cette fa√ßon: <br><br><ul><li>  la table est toujours scann√©e deux fois; </li><li>  si tant de versions de lignes sont supprim√©es lors du nettoyage que toutes ne peuvent pas tenir dans la m√©moire <em>maintenance_work_mem</em> , tous les index seront analys√©s compl√®tement autant de fois que n√©cessaire. </li></ul><br>  Sur les grandes tables, cela peut prendre un temps consid√©rable et cr√©er une charge importante sur le syst√®me.  Bien s√ªr, les demandes ne seront pas bloqu√©es, mais les E / S "suppl√©mentaires" sont √©galement d√©sagr√©ables. <br><br>  Pour acc√©l√©rer le processus, il est judicieux soit d'appeler au nettoyage plus souvent (afin que pas un tr√®s grand nombre de versions de lignes soient effac√©es √† chaque fois), soit d'allouer plus de m√©moire. <br><br>  Je note entre parenth√®ses qu'√† partir de la version 11, PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut ignorer les analyses d'index</a> si ce n'est pas absolument n√©cessaire.  Cela devrait faciliter la vie des propri√©taires de grandes tables dans lesquelles des lignes sont uniquement ajout√©es (mais pas modifi√©es). <br><br><h2>  Suivi </h2><br>  Comment comprendre que le nettoyage ne r√©siste pas au travail en un seul passage? <br><br>  Nous avons d√©j√† vu la premi√®re m√©thode: vous pouvez appeler la commande VACUUM avec VERBOSE.  Ensuite, des informations sur les phases du travail seront affich√©es sur la console. <br><br>  Deuxi√®mement, √† partir de la version 9.6, il y a une vue pg_stat_progress_vacuum, qui contient √©galement toutes les informations n√©cessaires. <br><br>  (Il existe une troisi√®me m√©thode - pour afficher des informations dans le journal des messages, mais cela ne fonctionne que pour le nettoyage automatique, qui sera discut√© la prochaine fois.) <br><br>  Nous allons ins√©rer plus de lignes dans le tableau afin que le nettoyage prenne un temps consid√©rable, et nous les mettrons √† jour afin qu'il y ait quelque chose √† voir avec le nettoyage. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  R√©duisez la taille de la m√©moire allou√©e au tableau d'identificateurs: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'1MB'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Nous commen√ßons le nettoyage et, pendant que cela fonctionne, nous allons passer plusieurs fois √† la vue pg_stat_progress_vacuum: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 2908 | heap_blks_vacuumed | 0 | index_vacuum_count | 0 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 5816 | heap_blks_vacuumed | 2907 | index_vacuum_count | 1 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br>  Ici, nous voyons en particulier: <br><br><ul><li>  nom de la phase actuelle (phase) - nous avons parl√© de trois phases principales, mais en g√©n√©ral il y en a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus</a> ; </li><li>  nombre total de pages de table (heap_blks_total); </li><li>  le nombre de pages analys√©es (heap_blks_scanned); </li><li>  le nombre de pages d√©j√† effac√©es (heap_blks_vacuumed); </li><li>  le nombre de passes par index (index_vacuum_count). </li></ul><br>  La progression globale est d√©termin√©e par le rapport de heap_blks_vacuumed √† heap_blks_total, mais gardez √† l'esprit que cette valeur ne change pas en douceur, mais ¬´saccad√©e¬ª en raison des analyses d'index.  Cependant, l'attention principale doit √™tre accord√©e au nombre de cycles de nettoyage - une valeur sup√©rieure √† 1 signifie que la m√©moire allou√©e n'√©tait pas suffisante pour terminer le nettoyage en une seule passe. <br><br>  La sortie de la commande VACUUM VERBOSE, termin√©e √† ce moment, affichera la vue d'ensemble: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac"</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.50 s, system: 0.07 s, elapsed: 1.36 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.02 s, system: 0.02 s, elapsed: 0.13 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.26 s, system: 0.07 s, elapsed: 0.81 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.10 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 151040 row versions DETAIL: CPU: user: 0.13 s, system: 0.04 s, elapsed: 0.47 s INFO: "vac": removed 151040 row versions in 2518 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.08 s</code> </pre><pre> <code class="plaintext hljs">INFO: index "vac_s" now contains 500000 row versions in 17821 pages DETAIL: 500000 index row versions were removed. 8778 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 500000 removable, 500000 nonremovable row versions in 16667 out of 16667 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4011 There were 0 unused item pointers. 0 pages are entirely empty. CPU: user: 1.10 s, system: 0.37 s, elapsed: 3.71 s. VACUUM</code> </pre><br>  Ici, vous pouvez voir qu'au total, il y a eu trois passages dans les indices, chacun ayant effac√© 174 480 pointeurs vers des versions mortes de cha√Ænes.  D'o√π vient ce chiffre?  Un lien (tid) prend 6 octets, et 1024 * 1024/6 = 174762 est le nombre que nous voyons dans pg_stat_progress_vacuum.max_dead_tuples.  En fait, il peut √™tre utilis√© un peu moins: il est garanti qu'√† la lecture de la page suivante, tous les pointeurs vers les versions "mortes" tiendront exactement en m√©moire. <br><br><h2>  Analyse </h2><br>  L'analyse, ou, en d'autres termes, la collecte d'informations statistiques pour le planificateur de requ√™tes, n'est pas formellement li√©e au nettoyage.  N√©anmoins, nous pouvons effectuer l'analyse non seulement avec l'√©quipe ANALYZE, mais √©galement combiner le nettoyage avec l'analyse: VACUUM ANALYZE.  Dans ce cas, le nettoyage est d'abord effectu√©, puis l'analyse - aucune √©conomie ne se produit. <br><br>  Mais, comme nous le verrons plus loin, le nettoyage automatique et l'analyse automatique sont effectu√©s en un seul processus et sont g√©r√©s de mani√®re similaire. <br><br><h1>  Nettoyage complet (vide plein) </h1><br>  Comme nous l'avons vu, le nettoyage conventionnel lib√®re plus d'espace que le nettoyage intra-page, mais m√™me cela ne r√©sout pas toujours compl√®tement le probl√®me. <br><br>  Si, pour une raison quelconque, la taille de la table ou de l'index a consid√©rablement augment√©, un nettoyage r√©gulier lib√©rera de l'espace √† l'int√©rieur des pages existantes: ils contiendront des ¬´trous¬ª, qui seront ensuite utilis√©s pour ins√©rer de nouvelles versions de lignes.  Mais le nombre de pages ne changera pas et, par cons√©quent, du point de vue du syst√®me d'exploitation, les fichiers occuperont exactement la m√™me quantit√© d'espace qu'ils occupaient avant le nettoyage.  Et c'est mauvais parce que: <br><br><ul><li>  l'analyse compl√®te d'une table (ou d'un index) ralentit; </li><li>  un cache tampon plus important peut √™tre n√©cessaire (car les pages sont stock√©es et la densit√© des informations utiles diminue); </li><li>  un niveau ¬´suppl√©mentaire¬ª peut appara√Ætre dans l'arborescence d'index, ce qui ralentira l'acc√®s √† l'index; </li><li>  les fichiers prennent de l'espace disque suppl√©mentaire et des sauvegardes. </li></ul><br>  (La seule exception est les pages compl√®tement nettoy√©es √† la fin du fichier - ces pages ¬´mordent¬ª le fichier et reviennent au syst√®me d'exploitation.) <br><br>  Si la part des informations utiles dans les fichiers tombe en dessous d'une limite raisonnable, l'administrateur peut effectuer un nettoyage complet de la table.  Dans le m√™me temps, la table et tous ses index sont enti√®rement reconstruits √† partir de z√©ro, et les donn√©es sont compress√©es aussi compactement que possible (bien s√ªr, en tenant compte du param√®tre fillfactor).  Lors de la reconstruction, PostgreSQL reconstruit s√©quentiellement la table d'abord, puis chacun de ses index.  De nouveaux fichiers sont cr√©√©s pour chaque objet et √† la fin de la reconstruction, les anciens fichiers sont supprim√©s.  Veuillez noter que dans le processus de travail sur le disque, il faudra de l'espace suppl√©mentaire. <br><br>  Pour illustrer, ins√©rez √† nouveau un certain nombre de lignes dans le tableau: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>);</code> </pre><br>  Comment √©valuer la densit√© de l'information?  Pour ce faire, il est pratique d'utiliser l'extension sp√©ciale: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgstattuple; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- table_len | 68272128 tuple_count | 500000 tuple_len | 64500000 tuple_percent | 94.47 dead_tuple_count | 0 dead_tuple_len | 0 dead_tuple_percent | 0 free_space | 38776 free_percent | 0.06</code> </pre><br>  La fonction lit l'ensemble du tableau et affiche des statistiques sur la quantit√© d'espace quelles donn√©es sont occup√©es dans les fichiers.  La principale information qui nous int√©resse maintenant est le champ tuple_percent: le pourcentage occup√© par les donn√©es utiles.  Il est inf√©rieur √† 100 en raison de la surcharge in√©vitable d'informations de service √† l'int√©rieur de la page, mais n√©anmoins assez √©lev√©. <br><br>  Pour l'index, d'autres informations sont affich√©es, mais le champ avg_leaf_density a la m√™me signification: le pourcentage d'informations utiles (en pages feuilles). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- version | 3 tree_level | 3 index_size | 72802304 root_block_no | 2722 internal_pages | 241 leaf_pages | 8645 empty_pages | 0 deleted_pages | 0 avg_leaf_density | 83.77 leaf_fragmentation | 64.25</code> </pre><br>  Et voici la taille de la table et de l'index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Supprimez maintenant 90% de toutes les lignes.  Nous s√©lectionnons les lignes √† supprimer de mani√®re al√©atoire, de sorte que dans chaque page avec une probabilit√© √©lev√©e, au moins une ligne reste: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 450189</code> </pre><br>  Quelle taille auront les objets apr√®s un nettoyage normal? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Nous constatons que la taille n'a pas chang√©: un nettoyage r√©gulier ne peut en aucun cas r√©duire la taille des fichiers.  Bien que la densit√© de l'information ait √©videmment diminu√© d'environ 10 fois: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 9.41 | 9.73 (1 row)</code> </pre><br>  V√©rifiez maintenant ce qui se passe apr√®s un nettoyage complet.  Voici les fichiers utilis√©s par la table et les index maintenant: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57392 | base/41493/57393 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57404 | base/41493/57407 (1 row)</code> </pre><br>  Maintenant, les fichiers sont remplac√©s par de nouveaux.  La taille du tableau et de l'index a consid√©rablement diminu√© et la densit√© des informations a donc augment√©: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 6648 kB | 6480 kB (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 94.39 | 91.08 (1 row)</code> </pre><br>  Veuillez noter que la densit√© des informations dans l'index a m√™me augment√© par rapport √† l'original.  La recr√©ation d'un index (arbre B) √† partir des donn√©es disponibles est plus rentable que l'insertion de donn√©es dans un index existant ligne par ligne. <br><br>  Les fonctions d'extension <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pgstattuple que</a> nous avons utilis√©es lisent l'int√©gralit√© du tableau.  Si le tableau est grand, cela n'est pas pratique, et il y a donc une fonction pgstattuple_approx, qui saute les pages marqu√©es dans la carte de visibilit√© et affiche des nombres approximatifs. <br><br>  Une m√©thode encore plus rapide, mais encore moins pr√©cise, consiste √† estimer le rapport entre le volume de donn√©es et la taille du fichier dans le r√©pertoire syst√®me.  Les options pour de telles requ√™tes peuvent √™tre trouv√©es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le wiki</a> . <br><br>  Un nettoyage complet ne n√©cessite pas d'utilisation r√©guli√®re, car il bloque compl√®tement tout travail avec la table (y compris l'interrogation) pendant toute la dur√©e de son travail.  Il est clair que sur un syst√®me utilis√© activement, cela peut √™tre inacceptable.  Les verrous seront consid√©r√©s s√©par√©ment, mais pour l'instant, nous nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">limiterons</a> √† mentionner l'extension <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pg_repack</a> , qui ne verrouille la table que pendant une courte p√©riode √† la fin du travail. <br><br><h2>  √âquipes similaires </h2><br>  Il existe plusieurs commandes qui reconstruisent √©galement compl√®tement les tables et les index, ce qui est similaire √† un nettoyage complet.  Tous bloquent compl√®tement le travail avec la table, tous suppriment les anciens fichiers de donn√©es et en cr√©ent de nouveaux. <br><br>  La commande CLUSTER est similaire en tout √† VACUUM FULL, mais organise en outre physiquement la version des cha√Ænes selon l'un des index disponibles.  Cela permet au planificateur d'utiliser plus efficacement l'acc√®s √† l'index dans certains cas.  Cependant, il faut comprendre que le clustering n'est pas pris en charge: avec les modifications ult√©rieures de la table, l'ordre physique des versions de ligne sera viol√©. <br><br>  La commande REINDEX reconstruit un seul index sur une table.  En fait, VACUUM FULL et CLUSTER utilisent cette commande pour reconstruire les index. <br><br>  La commande TRUNCATE fonctionne logiquement de la m√™me mani√®re que DELETE - elle supprime toutes les lignes de table.  Mais DELETE, comme d√©j√† discut√©, marque uniquement la version des lignes comme supprim√©e, ce qui n√©cessite un nettoyage suppl√©mentaire.  TRUNCATE cr√©e juste un nouveau fichier propre.  En r√®gle g√©n√©rale, cela fonctionne plus rapidement, mais gardez √† l'esprit que TRUNCATE bloquera compl√®tement le travail avec la table pendant toute la dur√©e jusqu'√† la fin de la transaction. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452320/">https://habr.com/ru/post/fr452320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452310/index.html">Configuration de canaux de vente en r√©seau pour les gadgets DO-RA</a></li>
<li><a href="../fr452312/index.html">Les t√©l√©coms britanniques verseront aux abonn√©s une compensation pour les d√©connexions</a></li>
<li><a href="../fr452314/index.html">La conception des niveaux et du gameplay roguelike sur l'exemple de Cogmind</a></li>
<li><a href="../fr452316/index.html">La mission Chang'e-4 - les r√©sultats du cinqui√®me jour lunaire: probl√®mes avec le rover Yutu-2 et une nouvelle d√©couverte scientifique</a></li>
<li><a href="../fr452318/index.html">Utilisation de Firebase comme stockage d'images pour une application Android</a></li>
<li><a href="../fr452322/index.html">De l'√©picentre de Google Cloud Next '19: notes de terrain du PDG</a></li>
<li><a href="../fr452328/index.html">Matryoshka C Syst√®me de langage de programme en couches</a></li>
<li><a href="../fr452330/index.html">Comment mener une planification trimestrielle distribu√©e sans papier et ne pas la g√¢cher?</a></li>
<li><a href="../fr452332/index.html">Il est difficile d'√™tre un mainteneur de projet Open Source</a></li>
<li><a href="../fr452334/index.html">Comment se d√©guiser sur Internet: comparer le serveur et les procurations r√©sidentes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>