<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¨ üöø üéÆ Limite de 32 K para dados na ROM dos microcontroladores AVR üìÇ üöè üåÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O que poderia ser pior do que muletas? Somente muletas incompletamente documentadas. 





 Aqui est√° uma captura de tela do mais recente ambiente de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Limite de 32 K para dados na ROM dos microcontroladores AVR</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436904/"><p>  O que poderia ser pior do que muletas?  Somente muletas incompletamente documentadas. </p><br><p><img src="https://habrastorage.org/webt/cg/o9/jm/cgo9jmcqnhx5xev3pyizgfemlw4.png" alt="imagem"></p><br><p>  Aqui est√° uma captura de tela do mais recente ambiente de desenvolvimento integrado oficial para microcontroladores AVR de 8 bits, Atmel Studio 7, a linguagem de programa√ß√£o C.  Como voc√™ pode ver na coluna Valor, a vari√°vel my_array cont√©m o n√∫mero 0x8089.  Em outras palavras, a matriz my_array est√° localizada na mem√≥ria, come√ßando no endere√ßo 0x8089. </p><br><p>  Ao mesmo tempo, a coluna Tipo fornece informa√ß√µes um pouco diferentes: my_array √© uma matriz de 4 elementos do tipo int16_t localizados na ROM (isso √© indicado pela palavra prog, ao contr√°rio dos dados da RAM), come√ßando no endere√ßo 0x18089.  Pare, mas, afinal, 0x8089! = 0x18089.  Qual √© o endere√ßo real da matriz? </p><a name="habracut"></a><br><h2 id="yazyk-si-i-garvardskaya-arhitektura">  Linguagem C e arquitetura Harvard </h2><br><p>  Os microcontroladores AVR de 8 bits fabricados anteriormente pela Atmel, e agora Microchip, s√£o populares, principalmente pelo fato de serem a base do Arduino, constru√≠do na arquitetura de Harvard, ou seja, o c√≥digo e os dados est√£o localizados em diferentes espa√ßos de endere√ßo.  A documenta√ß√£o oficial cont√©m exemplos de c√≥digo em dois idiomas: assembler e C.  Anteriormente, o fabricante oferecia um ambiente de desenvolvimento integrado gratuito que suporta apenas o montador.  Mas e aqueles que gostariam de programar em C, ou mesmo C ++?  Havia solu√ß√µes pagas, por exemplo, IAR AVR e CodeVisionAVR.  Pessoalmente, nunca o usei, porque quando comecei a programar o AVR em 2008, j√° havia o WinAVR gratuito com capacidade de integra√ß√£o com o AVR Studio 4, e ele √© simplesmente inclu√≠do no atual Atmel Studio 7. </p><br><p>  O projeto WinAVR √© ‚Äã‚Äãbaseado no compilador GNU GCC, desenvolvido para a arquitetura von Neumann, que implica um espa√ßo de endere√ßo √∫nico para c√≥digo e dados.  Ao adaptar o GCC ao AVR, a seguinte muleta foi aplicada: os endere√ßos 0 a 0x007fffff s√£o alocados para o c√≥digo (ROM, flash) e 0x00800100 para 0x0080ffff para dados (RAM, SRAM).  Havia todos os tipos de truques, por exemplo, endere√ßos de 0x00800000 a 0x008000ff representados registros que podem ser acessados ‚Äã‚Äãpelos mesmos c√≥digos de opera√ß√£o que a RAM.  Em princ√≠pio, se voc√™ √© um programador simples, como um arduino iniciante, e n√£o um hacker, misturando assembler e C / C ++ no mesmo firmware, n√£o precisa saber tudo isso. </p><br><p>  Al√©m do compilador, o WinAVR inclui v√°rias bibliotecas (parte da biblioteca C padr√£o e m√≥dulos espec√≠ficos do AVR) na forma do projeto AVR Libc.  A vers√£o mais recente, 2.0.0, foi lan√ßada h√° quase tr√™s anos, e a documenta√ß√£o est√° dispon√≠vel n√£o apenas no site do projeto, mas tamb√©m no site do fabricante do microcontrolador.  Existem tamb√©m tradu√ß√µes russas n√£o oficiais. </p><br><h2 id="dannye-v-adresnom-prostranstve-koda">  Dados no espa√ßo de endere√ßo do c√≥digo </h2><br><p>  √Äs vezes, em um microcontrolador, voc√™ precisa colocar n√£o apenas muitos, mas muitos dados: tanto que eles simplesmente n√£o se encaixam na RAM.  Al√©m disso, esses dados s√£o imut√°veis, conhecidos no momento do firmware.  Por exemplo, uma imagem raster, uma melodia ou algum tipo de mesa.  Ao mesmo tempo, o c√≥digo geralmente ocupa apenas uma pequena fra√ß√£o da ROM dispon√≠vel.  Ent√£o, por que n√£o usar o espa√ßo restante para dados?  F√°cil!  A documenta√ß√£o do avr-libc 2.0.0 abrange um cap√≠tulo inteiro de 5 dados no espa√ßo do programa.  Se voc√™ omitir a parte das linhas, tudo ser√° extremamente simples.  Considere um exemplo.  Para RAM, escrevemos assim: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> array2d[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">3</span></span>] = {...}; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> element = array2d[i][j];</code> </pre> <br><p>  E para ROM como este: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/pgmspace.h&gt; const unsigned char array2d[2][3] PROGMEM = {...}; unsigned char element = pgm_read_byte(&amp;(array2d[i][j]));</span></span></span></span></code> </pre> <br><p>  √â t√£o simples que essa tecnologia foi coberta repetidamente, mesmo no RuNet. </p><br><h2 id="tak-v-chyom-zhe-problema">  Ent√£o qual √© o problema? </h2><br><p>  Lembre-se da afirma√ß√£o de que 640 KB √© suficiente para todos?  Lembra como voc√™ mudou da arquitetura de 16 bits para 32 bits e de 32 bits para 64 bits?  Como o Windows 98 funcionou de maneira inst√°vel em mais de 512 MB de RAM enquanto foi projetado para 2 GB?  Voc√™ j√° atualizou o BIOS para que a placa-m√£e funcione com discos r√≠gidos maiores que 8 GB?  Lembre-se dos jumpers em 80 GB de discos r√≠gidos, reduzindo o volume para 32 GB? </p><br><p>  O primeiro problema me ultrapassou quando tentei criar uma matriz de pelo menos 32 KB na ROM.  Por que na ROM, e n√£o na RAM?  Como atualmente, os AVRs de 8 bits com mais de 32 KB de RAM simplesmente n√£o existem.  E com mais de 256 B - existem.  √â provavelmente por isso que os criadores do compilador escolheram 16 b (2 B) para ponteiros na RAM (e ao mesmo tempo para o tipo int), que podem ser encontrados na leitura do par√°grafo Tipos de dados localizado no cap√≠tulo 11.14. Quais registros s√£o usados ‚Äã‚Äãpelo compilador C?  Documenta√ß√£o do AVR Libc.  Ah, e n√£o √≠amos hackear, mas aqui est√£o os registros ... Mas voltando ao conjunto.  Acontece que voc√™ n√£o pode criar um objeto maior que 32.767 B (2 ^ (16 - 1) - 1 B).  N√£o sei por que era necess√°rio tornar significativo o comprimento do objeto, mas isso √© um fato: nenhum objeto, mesmo uma matriz multidimensional, pode ter um comprimento de 32.768 B ou mais.  Um pouco como uma limita√ß√£o no espa√ßo de endere√ßo de aplicativos de 32 bits (4 GB) em um sistema operacional de 64 bits, n√£o √©? </p><br><p>  At√© onde eu sei, esse problema n√£o tem solu√ß√£o.  Se voc√™ deseja colocar um objeto com um comprimento de 32.768 na ROM, divida-o em objetos menores. </p><br><p>  Voltamos ao par√°grafo Tipos de dados: ponteiros s√£o 16 bits.  Aplicamos esse conhecimento ao cap√≠tulo 5 de Dados no espa√ßo do programa.  N√£o, a teoria √© indispens√°vel, √© necess√°ria pr√°tica.  Eu escrevi um programa de teste, lancei um depurador (infelizmente, software, n√£o hardware) e vi que a fun√ß√£o <code>pgm_read_byte</code> capaz de retornar apenas dados cujos endere√ßos cabem em 16 bits (64 KB; obrigado, n√£o 15).  Em seguida, ocorre um estouro, a parte antiga √© descartada.  √â l√≥gico, j√° que os ponteiros s√£o de 16 bits.  Mas surgem duas perguntas: por que isso n√£o est√° escrito no Cap√≠tulo 5 (uma pergunta ret√≥rica, mas foi ele quem me levou a escrever este artigo) e como superar o limite de ROM de 64 KB sem mudar para o assembler. </p><br><p>  Felizmente, al√©m do Cap√≠tulo 5, h√° outra Refer√™ncia de arquivo pgmspace.h 25.18, da qual aprendemos que a fam√≠lia de fun√ß√µes <code>pgm_read_*</code> √© apenas uma <code>pgm_read_*_near</code> para <code>pgm_read_*_near</code> , que aceita endere√ßos de 16 bits, e tamb√©m existe <code>pgm_read_*_far</code> , e voc√™ pode enviar Endere√ßo de 32 bits  Eureka! </p><br><p>  N√≥s escrevemos o c√≥digo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> element = pgm_read_byte_far(&amp;(array2d[i][j]));</code> </pre> <br><p>  Compila, mas n√£o funciona como gostar√≠amos (se array2d estiver localizado ap√≥s 32 KB).  Porque  Sim, porque a opera√ß√£o <code>&amp;</code> retorna um n√∫mero assinado de 16 bits!  √â engra√ßado que a <code>pgm_read_*_near</code> aceite endere√ßos n√£o assinados de 16 bits, ou seja, ele pode trabalhar com 64 KB de dados e a opera√ß√£o <code>&amp;</code> √© √∫til apenas para 32 KB. </p><br><p>  Vamos seguir em frente.  O que temos no pgmspace.h al√©m do <code>pgm_read_*</code> ?  A fun√ß√£o <code>pgm_get_far_address(var)</code> , que j√° possui meia p√°gina de descri√ß√£o, e substitui a opera√ß√£o <code>&amp;</code> . </p><br><p>  Provavelmente certo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> element = pgm_read_byte_far(pgm_get_far_address(array2d[i][j]));</code> </pre> <br><p>  Erro de compila√ß√£o.  Lemos a descri√ß√£o: 'var' deve ser resolvido no momento da vincula√ß√£o como um s√≠mbolo existente, ou seja, um nome de vari√°vel de tipo simples, um nome de matriz (n√£o um elemento indexado da matriz, se o √≠ndice for uma constante, o compilador n√£o reclama, mas falha ao obter o endere√ßo se a otimiza√ß√£o estiver ativada), um nome de estrutura ou um nome de campo de estrutura, um identificador de fun√ß√£o, um identificador definido por vinculador, ... </p><br><p>  Colocamos outra muleta: passamos de √≠ndices de matriz para aritm√©tica de ponteiro: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> element = pgm_read_byte_far(pgm_get_far_address(array2d) + i*<span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) + j*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>));</code> </pre> <br><p>  Agora tudo funciona. </p><br><h2 id="vyvody">  Conclus√µes </h2><br><p>  Se voc√™ escreve em C / C ++ para microcontroladores AVR de 8 bits usando o compilador GCC e armazena os dados na ROM, ent√£o: </p><br><ul><li>  com um tamanho de ROM n√£o superior a 32 KB, voc√™ n√£o ter√° problemas lendo apenas os dados do Cap√≠tulo 5 no espa√ßo de programa; </li><li>  para ROMs maiores que 32 KB, voc√™ deve usar a fam√≠lia de fun√ß√µes <code>pgm_read_*_far</code> , a fun√ß√£o <code>pgm_get_far_address</code> vez de <code>&amp;</code> , aritm√©tica do ponteiro em vez dos √≠ndices da matriz, e o tamanho de qualquer objeto n√£o pode exceder 32.767 B. </li></ul><br><h2 id="ssylki">  Refer√™ncias </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Microchip</a> - AVR Microcontroller Maker e IDE Atmel Studio Developer </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P√°gina inicial do AVR Libc</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AVR</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Curso de treinamento.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Programa√ß√£o C.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhar com mem√≥ria, endere√ßos e ponteiros</a> - DI HALT n√£o mencionou grandes endere√ßos em princ√≠pio, mas em algum lugar nos coment√°rios que eles escreveram sobre <code>pgm_get_far_address</code> , mas a amostra foi quebrada </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436904/">https://habr.com/ru/post/pt436904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436890/index.html">Tutorial Reagir Parte 10: Workshop sobre como trabalhar com propriedades e estilo de componentes</a></li>
<li><a href="../pt436892/index.html">Tutorial React Parte 11: Forma√ß√£o din√¢mica de marca√ß√£o e o m√©todo Map Array</a></li>
<li><a href="../pt436894/index.html">Rastejando o apocalipse de TI. Novos servi√ßos em nuvem deixar√£o alguns engenheiros desempregados</a></li>
<li><a href="../pt436896/index.html">docker-pretty-ps - finalmente um docker leg√≠vel ps</a></li>
<li><a href="../pt436900/index.html">FunTech ML-meetup</a></li>
<li><a href="../pt436908/index.html">6 maneiras de ocultar dados em um aplicativo Android</a></li>
<li><a href="../pt436910/index.html">Dicas para criar fluxos de trabalho personalizados no GitLab CI</a></li>
<li><a href="../pt436912/index.html">Tend√™ncias de CRM de 2019: divertido de ler, perigoso de acreditar</a></li>
<li><a href="../pt436914/index.html">Problemas de crescimento de inicializa√ß√£o - Monitoramento</a></li>
<li><a href="../pt436916/index.html">VShard - escala horizontal em Tarantool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>