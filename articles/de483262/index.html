<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèø ü§ï ‚ôêÔ∏è Istio Circuit Breaker: Unterbrochene Beh√§lter trennen üçá üÜó üö®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Ferien sind vorbei und wir kehren mit unserem zweiten Beitrag in der Istio Service Mesh Serie zur√ºck. 



 Das heutige Thema ist Leistungsschalter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Istio Circuit Breaker: Unterbrochene Beh√§lter trennen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/483262/">  Die Ferien sind vorbei und wir kehren mit unserem zweiten Beitrag in der Istio Service Mesh Serie zur√ºck. <br><br><img src="https://habrastorage.org/webt/vb/9o/rl/vb9orlnb9lwiilx0aknfy1ikqs0.png" width="100%"><br><br>  Das heutige Thema ist Leistungsschalter, was auf Russisch als elektrotechnisch √ºbersetzt "Leistungsschalter", in der gemeinsamen Sprache "Leistungsschalter" bedeutet.  Nur in Istio trennt diese Maschine keine kurzgeschlossenen oder √ºberlasteten Stromkreise, sondern fehlerhafte Beh√§lter. <br><a name="habracut"></a><br><h3>  Wie es im Idealfall funktionieren sollte </h3><br>  Wenn Microservices beispielsweise von Kubernetes als Teil der OpenShift-Plattform verwaltet werden, werden sie je nach Auslastung automatisch vergr√∂√üert und verkleinert.  Da Microservices in Pods arbeiten, kann es an einem Endpunkt mehrere Instanzen von containerisierten Microservices geben, und Kubernetes leitet Anforderungen weiter und verteilt die Last zwischen ihnen.  Und im Idealfall sollte das alles perfekt funktionieren. <br><br>  Wir erinnern uns, dass Microservices klein und kurzlebig sind.  Die Verg√§nglichkeit, die hier die Einfachheit der Entstehung und des Verschwindens bedeutet, wird oft untersch√§tzt.  Die Geburt und der Tod der n√§chsten Instanz von Microservice im Pod werden erwartet, OpenShift und Kubernetes machen das gut und alles funktioniert gro√üartig - aber auch in der Theorie. <br><br><h3>  Wie funktioniert das wirklich? </h3><br>  Stellen Sie sich nun vor, dass eine bestimmte Instanz des Mikrodienstes, dh der Container, unbrauchbar geworden ist: Entweder reagiert er nicht (Fehler 503) oder, was unangenehmer ist, reagiert er, aber zu langsam.  Mit anderen Worten, es wird stummgeschaltet oder es wird nicht auf Anforderungen geantwortet, es wird jedoch nicht automatisch aus dem Pool entfernt.  Was ist in diesem Fall zu tun?  Nochmal versuchen?  Entfernen Sie es aus dem Routing-Schema?  Und was bedeutet "zu langsam" - wie viel ist es in Zahlen und wer bestimmt sie?  Vielleicht gib ihm einfach eine Pause und versuche es sp√§ter?  Wenn ja, wie viel sp√§ter? <br><br><h3>  Was ist Pool Ejection in Istio </h3><br>  Und hier kommt Istio mit seinen Leistungsschaltern zur Hilfe, die vor√ºbergehend fehlerhafte Container aus dem Pool der Routing- und Lastausgleichsressourcen entfernen und das Pool-Ejection-Verfahren implementieren. <br><br>  Mithilfe einer Ausrei√üererkennungsstrategie erkennt Istio Pod-Kurven, die aus der allgemeinen Reihe entfernt wurden, und entfernt sie f√ºr einen bestimmten Zeitraum aus dem Ressourcenpool, dem so genannten ‚ÄûSchlaffenster‚Äú. <br><br>  Um zu zeigen, wie dies in Kubernetes auf der OpenShift-Plattform funktioniert, beginnen wir mit einem Screenshot der normalerweise funktionierenden Microservices aus dem Beispiel im <a href="https://github.com/redhat-developer-demos/istio-tutorial">Red Hat Developer Demos-</a> Repository.  Hier haben wir zwei Pods, v1 und v2, in denen jeweils ein Container funktioniert.  Wenn die Routing-Regeln von Istio nicht verwendet werden, wendet Kubernetes standardm√§√üig ein gleichm√§√üig ausgeglichenes Round-Robin-Routing an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bh/b0/dr/bhb0drqlbvo9j0ataogejcgpwue.png"></div><br><h3>  Bereit f√ºr einen Absturz </h3><br>  Vor dem Pool Ejection m√ºssen Sie eine Istio-Routing-Regel erstellen.  Angenommen, wir m√∂chten Anfragen in Bezug auf 50/50 auf mehrere Pods verteilen.  Au√üerdem werden wir die Anzahl der v2-Container von eins auf zwei erh√∂hen: <br><br><pre><code class="plaintext hljs">oc scale deployment recommendation-v2 --replicas=2 -n tutorial</code> </pre> <br>  Nun definieren wir eine Routing-Regel, damit der Datenverkehr im Verh√§ltnis 50/50 auf die Pods verteilt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w2/51/pz/w251pzvoaokm49bpul5ehfwsewm.png"></div><br>  Und hier ist das Ergebnis dieser Regel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/22/ww/wy22wwbkg2vync-id4jbhv22ftk.png"></div><br>  Es ist m√∂glich zu bem√§ngeln, dass auf diesem Bildschirm nicht 50/50, sondern 14: 9 angezeigt wird, aber mit der Zeit wird sich die Situation verbessern. <br><br><h3>  Wir arrangieren einen Fehler </h3><br>  Und jetzt deaktivieren wir einen der beiden Container der Version 2, sodass wir einen fehlerfreien Container der Version 1, einen fehlerfreien Container der Version 2 und einen fehlerhaften Container der Version 2 haben: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/or/0x/w1/or0xw1jvinlrjkmz3lnttvdh0zo.png"></div><br><h3>  Beheben Sie den Absturz </h3><br>  Wir haben also einen fehlerhaften Beh√§lter und es ist Zeit f√ºr den Poolauswurf.  Mit einer sehr einfachen Konfiguration schlie√üen wir diesen fehlerhaften Container f√ºr 15 Sekunden von Routing-Schemata aus, in der Erwartung, dass er in einen fehlerfreien Zustand zur√ºckkehrt (entweder wird er neu gestartet oder die Leistung wird wiederhergestellt).  So sieht diese Konfiguration aus und die Ergebnisse ihrer Arbeit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xz/6u/7e/xz6u7emeucpeqn6ozq7rnsibtxy.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yk/m6/3t/ykm63tdppq-qphkyhikilfcwkai.png"></div><br>  Wie Sie sehen, wird der ausgefallene Container v2 beim Weiterleiten von Anforderungen nicht mehr verwendet, da er aus dem Pool entfernt wurde.  Nach 15 Sekunden kehrt es automatisch zum Pool zur√ºck.  Eigentlich haben wir nur gezeigt, wie Pool Ejection funktioniert. <br><br><h3>  Fangen Sie an, Architektur zu bauen </h3><br>  In Kombination mit den √úberwachungsfunktionen von Istio k√∂nnen Sie mit der Erstellung eines Frameworks f√ºr das automatische Ersetzen fehlerhafter Container beginnen, um Ausfallzeiten und Abst√ºrze zu reduzieren oder sogar zu vermeiden. <br><br>  Die NASA hat ein hochkar√§tiges Motto - Failure Is Not a Option, verfasst von Flugdirektor <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B0%25D0%25BD%25D1%2586,_%25D0%2594%25D0%25B6%25D0%25B8%25D0%25BD">Gene Krantz</a> .  Es kann ins Russische √ºbersetzt werden als "Niederlage ist keine Option", und der Punkt hier ist, dass alles so gemacht werden kann, dass es mit gen√ºgend Willen funktioniert.  Im wirklichen Leben passieren Fehler jedoch nicht nur, sie sind √ºberall und in allem unvermeidlich.  Und wie geht man bei Microservices damit um?  Unserer Meinung nach ist es besser, sich nicht auf Willenskraft zu verlassen, sondern auf die F√§higkeiten von Containern, <a href="https://developers.redhat.com/topics/kubernetes/">Kubernetes</a> , <a href="https://developers.redhat.com/products/openshift/overview/">Red Hat OpenShift</a> und <a href="https://developers.redhat.com/topics/service-mesh/">Istio</a> . <br><br>  Istio setzt, wie wir oben geschrieben haben, das Konzept der Leistungsschalter um, das sich in der physischen Welt bew√§hrt hat.  Und genau wie ein Automat einen problematischen Teil eines Stromkreises trennt der Software-Leistungsschalter in Istio die Verbindung zwischen dem Anforderungsfluss und dem Problemcontainer, wenn am Endpunkt etwas nicht stimmt, z. B. wenn der Server abst√ºrzt oder langsamer wird. <br><br>  Dar√ºber hinaus treten im zweiten Fall nur weitere Probleme auf, da die Bremsen eines Containers nicht nur eine Kaskade von Verz√∂gerungen beim Zugriff auf die Dienste verursachen und infolgedessen die Leistung des gesamten Systems verringern, sondern auch wiederholte Anforderungen an den bereits langsam laufenden Dienst verursachen, was die Situation nur versch√§rft . <br><br><h3>  Leistungsschalter in der Theorie </h3><br>  Leistungsschalter ist ein Proxy, der den Fluss von Anforderungen an den Endpunkt steuert.  Wenn dieser Punkt nicht mehr funktioniert oder je nach Einstellung langsamer wird, trennt sich der Proxy vom Container.  Der Datenverkehr wird dann auf andere Container umgeleitet, und zwar nur aufgrund des Lastenausgleichs.  Die Verbindung bleibt f√ºr ein bestimmtes Schlaffenster (z. B. zwei Minuten) offen (offen) und wird dann als halb offen (halb offen) betrachtet.  Der Versuch, die n√§chste Anforderung zu senden, bestimmt den weiteren Kommunikationsstatus.  Wenn mit dem Dienst alles in Ordnung ist, kehrt die Verbindung in den Betriebszustand zur√ºck und wird wieder geschlossen.  Wenn mit dem Dienst immer noch etwas nicht stimmt, wird die Verbindung ge√∂ffnet und das Schlaffenster wird wieder aktiviert.  So sieht das vereinfachte Leistungsschalter-Zustandsdiagramm aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qg/0g/z4/qg0gz47wjymiayq4bgshfsrceyy.png"></div><br>  Hierbei ist zu beachten, dass dies alles sozusagen auf der Ebene der Systemarchitektur geschieht.  Daher m√ºssen Sie Ihren Anwendungen irgendwann das Arbeiten mit dem Leistungsschalter beibringen, z. B. als Antwort einen Standardwert bereitstellen oder, falls m√∂glich, die Existenz des Dienstes ignorieren.  Hierf√ºr wird ein Schottmuster verwendet, das jedoch den Rahmen dieses Artikels sprengt. <br><br><h3>  Leistungsschalter in der Praxis </h3><br>  Zum Beispiel werden wir auf OpenShift zwei Versionen unseres Microsoft-Empfehlungsdienstes starten.  Version 1 wird gut funktionieren, aber in Version 2 werden wir eine Verz√∂gerung einbauen, um die Bremsen auf dem Server zu simulieren.  Verwenden Sie das <a href="https://github.com/JoeDog/siege">Belagerungstool</a> , um die Ergebnisse anzuzeigen: <br><br><pre> <code class="plaintext hljs">siege -r 2 -c 20 -v customer-tutorial.$(minishift ip).nip.io</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kn/qa/e_/knqae_n13cpibc7tc9lk7fc5lqq.png"></div><br>  Alles scheint zu funktionieren, aber zu welchem ‚Äã‚ÄãPreis?  Auf den ersten Blick haben wir eine Verf√ºgbarkeit von 100%, aber schauen Sie genauer hin - die maximale Transaktionsdauer betr√§gt 12 Sekunden.  Dies ist eindeutig ein Engpass und muss gestickt werden. <br><br>  Dazu verwenden wir Istio, um den Zugriff auf langsame Container zu verhindern.  So sieht die entsprechende Konfiguration mit dem Leistungsschalter aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eh/ld/f4/ehldf4gh5qxkwqckn3naufhfs2a.png"></div><br>  Die letzte Zeile mit dem Parameter httpMaxRequestsPerConnection gibt an, dass die Verbindung mit ge√∂ffnet werden soll, wenn versucht wird, eine weitere - die zweite - Verbindung zus√§tzlich zu der vorhandenen zu erstellen.  Da unser Container einen Bremsdienst imitiert, treten solche Situationen in regelm√§√üigen Abst√§nden auf, und Istio gibt einen 503-Fehler zur√ºck. Die Belagerung zeigt Folgendes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/9h/g5/vv9hg56bzoliqjb6tay19as6mn0.png"></div><br><h3>  OK, wir haben Leistungsschalter, was kommt als n√§chstes? </h3><br>  Deshalb haben wir ein automatisches Herunterfahren implementiert, ohne den Quellcode der Dienste selbst zu ber√ºhren.  Mithilfe des oben beschriebenen Verfahrens zum Ausschalten des Leistungsschalters und des Pools k√∂nnen wir die Bremsbeh√§lter aus dem Ressourcenpool entfernen, bis sie wieder normal sind, und ihren Status mit einer bestimmten H√§ufigkeit √ºberpr√ºfen - in unserem Beispiel sind dies zwei Minuten (Parameter sleepWindow). <br><br>  Beachten Sie, dass die F√§higkeit der Anwendung, auf Fehler 503 zu reagieren, immer noch auf der Ebene ihres Quellcodes festgelegt ist.  Es gibt viele Strategien f√ºr die Arbeit mit Leistungsschaltern, die je nach Situation angewendet werden. <br><br>  <b>Im n√§chsten Beitrag werden wir</b> uns mit Tracing und Monitoring befassen, die bereits integriert sind oder leicht zu Istio hinzugef√ºgt werden k√∂nnen, sowie mit dem absichtlichen Einf√ºgen von Fehlern in das System. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483262/">https://habr.com/ru/post/de483262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483252/index.html">Jugendlicher Maximalismus und Widerspruchsgeist bei Jugendlichen aus neurologischer Sicht</a></li>
<li><a href="../de483254/index.html">Hinter den Kulissen eines Stack Overflow Moderator's Life</a></li>
<li><a href="../de483256/index.html">Eine Zusammenstellung unterhaltsamer statistischer Fakten # 3</a></li>
<li><a href="../de483258/index.html">Low-Code-Plattformen: ein Allheilmittel oder eine riskante Wette?</a></li>
<li><a href="../de483260/index.html">Treffen von Entscheidungen und Priorisieren von Aufgaben beim Erstellen eines Produkts</a></li>
<li><a href="../de483264/index.html">Dijkstra: Der gr√∂√üte Sieg des Westens im Kalten Krieg √ºber die UdSSR war der √úbergang zu IBM - Mythos gescheitert</a></li>
<li><a href="../de483266/index.html">Finanzielle Unabh√§ngigkeit. Was hat sich im Laufe des Jahres ver√§ndert?</a></li>
<li><a href="../de483268/index.html">Das Buch "Mode, Glaube, Phantasie und die neue Physik des Universums"</a></li>
<li><a href="../de483270/index.html">Die Entwicklung von HighLoad-Anwendungen am Beispiel eines regionalen Portals √∂ffentlicher Dienste</a></li>
<li><a href="../de483272/index.html">Der Weg vom Gastronomiebetrieb zum IT-Unternehmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>