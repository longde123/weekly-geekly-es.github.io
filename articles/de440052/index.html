<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇ üôèüèΩ üòó Statische BIOS / UEFI-Analyse oder Abrufen eines Abh√§ngigkeitsdiagramms üë≥ üññ ü§∏üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄûIch habe gestern das Schmieden beendet, 
 Ich habe zwei Pl√§ne ausgetrickst ... " 
 ... VS Vysotsky Lied ... 
 Vor fast 3 Jahren (Anfang 2016) erschie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Statische BIOS / UEFI-Analyse oder Abrufen eines Abh√§ngigkeitsdiagramms</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440052/"><table><tbody><tr><td width="480"><img src="https://habrastorage.org/webt/bh/jy/lo/bhjylo0e06sv0b9flvjqzb4e62u.png" width="480"></td><td align="right">  <i>‚ÄûIch habe gestern das Schmieden beendet,</i> <i><br></i>  <i>Ich habe zwei Pl√§ne ausgetrickst ... "</i> <i><br></i>  <i>... VS Vysotsky Lied ...</i> </td></tr></tbody></table><br>  Vor fast 3 Jahren (Anfang 2016) erschien der Wunsch eines Benutzers zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thema</a> des UEFITool-Projekts auf GitHub: ein ‚ÄûAbh√§ngigkeitsdiagramm‚Äú f√ºr ausf√ºhrbare Module zu erstellen, die in BIOS / UEFI enthalten sind. <br><br>  Sogar eine kleine Diskussion folgte, wodurch klar wurde, dass diese Aufgabe keineswegs trivial ist, die verf√ºgbare Funktionalit√§t f√ºr ihre L√∂sung nicht ausreicht, die Aussichten in diesem Moment neblig sind ... <br><br>  Und diese Frage blieb in der Schwebe, mit der Aussicht auf Verwirklichung in unbestimmter Zukunft (aber der Wunsch blieb wahrscheinlich bestehen, und die Hoffnung stirbt, wie Sie wissen, zuletzt!). <br><br>  Es gibt einen Vorschlag: Finden Sie endlich eine L√∂sung f√ºr dieses Problem! <br><a name="habracut"></a><br><h2>  Definieren Sie die Begriffe </h2><br>  Es wird weiterhin angenommen, dass es sich um Intel 64- und IA-32-Architektur handelt. <br><br>  Um eindeutig zu bestimmen, was wir bauen wollten, m√ºssen wir uns eingehender mit der Funktionsweise der einzelnen Phasen des BIOS / UEFI-Vorgangs befassen. <br><br>  Wenn Sie sich die Dateitypen in den <abbr title="Firmware-Dateisystem">FFS-</abbr> Firmware-Volumes genau ansehen, stellt sich heraus, dass die meisten verf√ºgbaren Dateien einen Abschnitt mit ausf√ºhrbaren Modulen enthalten. <br><br>  Selbst wenn wir die neue Firmware von ASUS oder ASRock betrachten, in der Sie m√ºhelos bis zu eineinhalb hundert Dateien vom Typ EFI_FV_FILETYPE_FREEFORM finden k√∂nnen, die Bilder verschiedener Formate enthalten, gibt es auch in diesen Firmwares mehr ausf√ºhrbare Dateien als Dateien anderer Typen. <br><br><pre><code class="plaintext hljs">+--------------------------------------------------------------------------+ | File Types Information | +--------------------------------------------------------------------------+ | EFI_FV_FILETYPE_RAW = 6 | | EFI_FV_FILETYPE_FREEFORM = 83 | | EFI_FV_FILETYPE_SECURITY_CORE = 1 | | EFI_FV_FILETYPE_PEI_CORE = 1 | | EFI_FV_FILETYPE_DXE_CORE = 1 | | EFI_FV_FILETYPE_PEIM = 57 | | EFI_FV_FILETYPE_DRIVER = 196 | | EFI_FV_FILETYPE_APPLICATION = 1 | | EFI_FV_FILETYPE_SMM = 60 | | EFI_FV_FILETYPE_SMM_CORE = 1 | | EFI_FV_FILETYPE_PAD = 4 | +--------------------------------------------------------------------------+ | Total Files : = 411 | +--------------------------------------------------------------------------+</code> </pre>  <b>Ein Beispiel f√ºr die Zusammensetzung einer gew√∂hnlichen (gew√∂hnlichen) Firmware.</b> <br><br>  Obwohl Dateien mit ausf√ºhrbaren Modulen in dieser Tabelle nicht markiert sind, sind sie (per Definition) alle in dieser Liste enthalten, mit Ausnahme von Dateien mit den Suffixen RAW, FREEFORM und PAD. <br><br>  Dateien mit dem Suffix "CORE" (SECURITY_CORE, PEI_CORE und DXE_CORE) sind die entsprechenden "Kernel" (Kopfmodule der entsprechenden Phase), die von anderen Phasen (oder nach dem Start) gesteuert werden. SMM_CORE ist eine Unterphase der DXE-Phase und wird w√§hrend dieser aufgerufen Erf√ºllung.  Die Anwendung kann nur auf Anfrage des Benutzers durchgef√ºhrt werden, es besteht keine spezifische Bindung an die Phasen. <br><br>  Die h√§ufigsten Dateitypen wurden nicht aufgef√ºhrt: PEIM (PEI-Phasenmodule), DRIVER (DXE-Phasenmodule) und SMM (DXE-Subphasenmodule).  Die CORE-Module der PEI- und DXE-Phasen enthalten einen Dispatcher, der die Reihenfolge der Lade- / Startmodule der entsprechenden Phase steuert. <br><br>  Im obigen Beispiel gibt es keine kombinierten Optionen, an die wir uns nicht erinnern werden: Obwohl sie in echter Firmware enthalten sind, ist dies ziemlich selten.  Wer detailliertere und detailliertere Informationen erhalten m√∂chte, wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">gebeten</a> , auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">CodeRush-</a> Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> zu verweisen.  Und zitieren Sie auch seinen Rat: ‚ÄûF√ºr Fans der Originaldokumentation ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die UEFI PI-Spezifikation</a> immer verf√ºgbar, alles wird viel detaillierter beschrieben.‚Äú <br><br>  Jedes ausf√ºhrbare Firmware-Modul ist ein Modul im PE + -Format (Portable Executable) oder dessen Ableitung (Terse Executable: TE-Format).  Das ausf√ºhrbare Modul im PE + -Format besteht aus einer Reihe von "leicht" gepackten strukturierten Daten, die die Informationen enthalten, die der Loader ben√∂tigt, um dieses Modul dem Speicher zuzuordnen. <br><br>  Das PE + -Format (Struktur) selbst hat keinen Interaktionsmechanismus zwischen einzelnen PE + -Modulen.  Jedes ausf√ºhrbare Modul nach dem Laden und Starten der Ausf√ºhrung ist ein autonomer unabh√§ngiger Prozess <b>(nun, es sollte so sein!)</b> , D.h.  Das Modul sollte nichts dar√ºber ‚Äûannehmen‚Äú, was au√üerhalb des Moduls getan wird. <br><br>  Die Organisation der Interaktion zwischen separaten ausf√ºhrbaren Modulen einer UEFI-Phase wird mittels des CORE-Moduls der entsprechenden Phase organisiert.  Einzelne ausf√ºhrbare Module k√∂nnen Protokolle definieren (installieren), von anderen Modulen deklarierte Protokolle anfordern (lokalisieren) und verwenden, Ereignisse festlegen / deklarieren und Ereignishandler deklarieren (benachrichtigen). <br><br>  Daher sind wir f√ºr jedes ausf√ºhrbare Firmware-Modul an folgenden Artefakten interessiert: <br><br><ol><li>  Liste der Protokolle, die dieses Modul definiert.  (Jedes Protokoll ist durch eine eindeutige Nummer gekennzeichnet). </li><li>  Liste der Protokolle, die dieses Modul verwendet (versucht zu verwenden). </li><li>  Liste der Ereignisse, die dieses Modul ank√ºndigt.  (Die Veranstaltung hat eine eindeutige Nummer - Anleitung). </li><li>  Eine Liste der in diesem Modul vorhandenen (implementierten und installierbaren / initialisierbaren) Ereignishandler. </li></ol><blockquote>  <i><u>Ein statisches Abh√§ngigkeitsdiagramm</u></i> f√ºr eine bestimmte BIOS / UEFI-Phase gilt als definiert, wenn f√ºr jedes ausf√ºhrbare Phasenmodul alle oben in den Abschnitten 1 bis 4 aufgef√ºhrten Artefakte bekannt sind.  (Mit anderen Worten, wenn wir alle Informationen definiert haben, die die Abh√§ngigkeiten zwischen den Modulen beschreiben). </blockquote>  Wir werden nur die Option der statischen Analyse betrachten. Dies bedeutet, dass einige Elemente des Codes, die die Elemente 1 bis 4 implementieren, nicht erreichbar sein k√∂nnen (Fragmente des "toten" Codes sind) oder nur mit bestimmten Optionen f√ºr Eingabedaten / Parameter erreichbar sind. <br><br>  Alles, was wir bisher ber√ºcksichtigt haben, basiert nur auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BIOS / UEFI-</a> Spezifikation.  Und um die ‚ÄûBeziehungen‚Äú der vorhandenen ausf√ºhrbaren Module der betreffenden Firmware zu verstehen, m√ºssen wir uns eingehender mit ihrer Struktur befassen, was bedeutet, dass wir sie zumindest teilweise umkehren sollten (Wiederherstellung der urspr√ºnglichen Algorithmen). <br><br>  Wie oben bereits erw√§hnt, ist das ausf√ºhrbare Modul im PE + -Format nur eine Reihe von Strukturen f√ºr den Loader, die im Speicher ein Objekt erstellen, an das die Steuerung √ºbertragen wird, und dieses Objekt besteht naturgem√§√ü aus Prozessoranweisungen sowie Daten f√ºr diese Anweisungen. <br><blockquote>  Wir werden sagen, dass eine <i><u>vollst√§ndige Demontage des</u></i> ausf√ºhrbaren Moduls vorgenommen wurde, wenn es m√∂glich war, das Problem der Trennung der in diesem Modul dargestellten Befehle und Daten zu l√∂sen. </blockquote>  Gleichzeitig werden wir keine Anforderungen an die Struktur und die Datentypen stellen. Es reicht aus, wenn wir f√ºr jedes Byte, das zum Image des vom Loader empfangenen ausf√ºhrbaren Moduls geh√∂rt, klar sagen k√∂nnen, zu welcher der beiden Kategorien es geh√∂rt: Befehlsbyte oder Datenbyte. <br><br>  Die Aufgabe, <i><u>das</u></i> ausf√ºhrbare Modul selbst <i><u>vollst√§ndig zu zerlegen,</u></i> ist im Allgemeinen nicht trivial, au√üerdem ist es im allgemeinen Fall algorithmisch nicht l√∂sbar.  Wir werden nicht auf die Details dieser Ausgabe eingehen, auch die Speere brechen, wir betrachten diese Aussage als Axiom. <br><br>  Angenommen,: <br><br><ol><li>  Wir haben bereits das Problem der <i><u>vollst√§ndigen Demontage</u></i> f√ºr ein bestimmtes BIOS / UEFI-Ausf√ºhrungsmodul gel√∂st, d. H.  Es ist uns gelungen, Befehle und Daten zu trennen. </li><li>  Es gibt den Quellcode f√ºr das Modul in der Sprache ‚ÄûC‚Äú (in der aktuellen BIOS / UEFI-Firmware werden die Module meist nur in der Sprache ‚ÄûC‚Äú entwickelt). </li></ol><br>  Selbst in diesem Fall erfordert der einfache Vergleich der erzielten Ergebnisse (Assembler-Text ist nur eine Textdarstellung von Prozessoranweisungen) mit dem Quellcode in der Sprache ‚ÄûC‚Äú fast immer gute Erfahrung / Qualifikation, mit Ausnahme absolut entarteter F√§lle. <br><br>  Eine vollst√§ndige Untersuchung von Beispielen, die Schwierigkeiten beim Identifizieren oder Vergleichen von Demontageergebnissen mit Quellcode zeigen, ist nicht Teil unserer aktuellen Pl√§ne. <br>  Betrachten wir nur ein Beispiel, wenn wir in der Assembler-Liste auf den Befehl <b>"Indirekter Aufruf"</b> sto√üen - einen impliziten Prozeduraufruf. <br><br>  Dies ist ein Beispiel f√ºr einen Prozeduraufruf, auf den in einer Tabelle verwiesen wird.  Eine Tabelle mit Links zu verschiedenen Prozeduren ist ein typischer Fall f√ºr die Implementierung der Darstellung von Schnittstellen eines beliebigen Protokolls. <br><br>  Eine solche Tabelle muss nicht nur aus Verweisen auf Prozeduren bestehen, niemand verbietet das Speichern beliebiger Daten in dieser Struktur (und dies ist ein Beispiel f√ºr eine typische C-Struktur). <br><br>  Hier ist eine Form eines solchen Aufrufs (anstelle des ecx-Registers sind fast alle Varianten von 32-Bit-Prozessorregistern m√∂glich): <br><blockquote>  FF 51 18 call dword ptr [ecx + 18h] </blockquote>  Nachdem bei der Analyse ein √§hnlicher Befehl erhalten wurde, ist es m√∂glich herauszufinden, welche Art von Prozedur aufgerufen wird. Eine Liste ihrer Parameter, der Typ und der Wert des zur√ºckgegebenen Ergebnisses ist nur m√∂glich, wenn wir den Objekttyp (Protokoll) kennen, dessen Schnittstelle von diesem Befehl aufgerufen wird. <br><br>  Wenn wir wissen, dass im vorherigen Beispiel das Register ‚Äûecx‚Äú einen Zeiger enth√§lt (die Adresse am Anfang der Tabelle EFI_PEI_SERVICES), k√∂nnen wir diesen Befehl auf folgende verst√§ndlichere und ‚Äûangenehmere‚Äú Weise empfangen (pr√§sentieren): <blockquote>  FF 51 18 call [exx + EFI_PEI_SERVICES.InstallPpi] </blockquote>  Das Abrufen von Informationen √ºber den Inhalt des Registers, das am Befehl <b>"Indirekter Aufruf"</b> teilnimmt, geht meist √ºber die F√§higkeiten eines "typischen" Disassemblers hinaus, dessen Aufgabe es ist, den Bin√§rcode des Prozessors einfach zu analysieren und in eine f√ºr Menschen lesbare Form umzuwandeln - eine Textdarstellung des entsprechenden Prozessorbefehls. <br><br>  Um dieses Problem zu l√∂sen, m√ºssen h√§ufig zus√§tzliche (Meta-) Informationen verwendet werden, die im ausf√ºhrbaren Bin√§rmodul nicht verf√ºgbar sind (verloren durch Kompilierung und Verkn√ºpfung - sie werden bei Transformationen von einer Darstellung des Algorithmus zu einer anderen verwendet, aber der Prozessor muss die empfangenen Befehle nicht mehr ausf√ºhren). <br><br>  Wenn uns diese Metadaten noch aus zus√§tzlichen Quellen zur Verf√ºgung stehen, erhalten wir durch Verwendung dieser Metadaten und Durchf√ºhrung zus√§tzlicher Analysen eine verst√§ndlichere (und genauere) Darstellung des Befehls <b>‚ÄûIndirekter Aufruf‚Äú</b> . <br><br>  Tats√§chlich erinnert diese erweiterte Analyse bereits mehr an den "Dekompilierungs" -Prozess, obwohl das Ergebnis nicht wie der Quellcode des Moduls in der "C" -Sprache aussieht. In Zukunft werden wir diesen Prozess jedoch als <i>Dekompilierung von Befehlen bezeichnen, die <b>"Indirekter Aufruf"</b></i> oder <i>"</i> <i><b>Indirekter Aufruf</b></i> <i>" sind teilweise "Dekompilierung</i> . <br><br>  Wir sind also bereit, die ausreichenden Bedingungen f√ºr die Erstellung des Diagramms der gegenseitigen Abh√§ngigkeit der ausf√ºhrbaren Firmware-Module f√ºr die gegebene BIOS / UEFI-Phase zu bestimmen: <br><blockquote>  Um ein <u><i>statisches Abh√§ngigkeitsdiagramm</i></u> (eine der Phasen - PEI oder DXE) zu erhalten, reicht es <b><i>aus</i></b> , alle ausf√ºhrbaren Module der entsprechenden Phase vollst√§ndig zu zerlegen (mindestens alle Befehle zu trennen) und die in den zerlegten Modulen vorhandenen Befehle <b>"Indirekter Aufruf" zu</b> dekompilieren. </blockquote>  Es gibt sofort viele Fragen dar√ºber, wie unser Wissen √ºber <b>‚ÄûIndirect Call‚Äú</b> -Teams mit Interaktionen zwischen Modulen verbunden ist. <br>  Wie oben erw√§hnt, wird der gesamte Interaktionsverwaltungsdienst vom Modul "CORE" der entsprechenden Phase bereitgestellt, und die Dienste in den Phasen werden als "grundlegende" Diensttabellen entworfen. <br><br>  Da die Interaktionsmodelle zwischen den Modulen in der PEI- und der DXE-Phase zwar ideologisch (strukturell) √§hnlich, aber technisch immer noch unterschiedlich sind, wird vorgeschlagen, von einigen formalen √úberlegungen zu einer spezifischen direkten Konstruktion eines <u><i>statischen Abh√§ngigkeitsgraphen</i></u> f√ºr die PEI-Phase √ºberzugehen. <br><br>  Wir werden sogar in der Lage sein, die <b><i>notwendigen und ausreichenden</i></b> Bedingungen f√ºr die M√∂glichkeit der Erstellung eines <u><i>statischen Abh√§ngigkeitsgraphen</i></u> f√ºr die PEI-Phase zu bestimmen und zu formulieren. <br><br><h2>  Erstellen eines <i><u>statischen Abh√§ngigkeitsdiagramms</u></i> f√ºr die PEI-Phase </h2><br>  Beschreibungen der L√∂sung des Problems der <u><i>vollst√§ndigen Demontage</i></u> ausf√ºhrbarer Module der PEI-Phase und der Dekompilierung der in diesen Modulen enthaltenen <b>Indirect Call-</b> Befehle gehen √ºber den Rahmen unserer Erz√§hlung hinaus und werden darin nicht gegeben. Die Darstellung dieses Materials in Umfang kann die Gr√∂√üe dieses Opus √ºberschreiten. <br><br>  Es ist m√∂glich, dass dies im Laufe der Zeit als separates Material geschieht, aber vorerst - Know-how. <br><br>  Wir stellen nur fest, dass die Verwendung von Metadaten sowie das Vorhandensein einer bestimmten Struktur zum Erstellen von Bin√§rcode es in der Praxis erm√∂glicht, ausf√ºhrbare BIOS / UEFI-Module <i><u>vollst√§ndig zu zerlegen</u></i> .  Ein formaler Beweis dieser Tatsache wird weder jetzt noch in Zukunft angenommen.  Zumindest bei der Analyse / Verarbeitung von mehr als hundert (100) BIOS / UEFI verschiedener Hersteller gab es keine Beispiele, bei denen eine <i><u>vollst√§ndige Demontage</u></i> nicht m√∂glich war. <br><br>  Weiter nur spezifische Ergebnisse (mit Erkl√§rungen: was, wie und wie viel ...). <br><br>  Die Struktur EFI_PEI_SERVICES ist die Grundstruktur der PEI-Phase, die als Parameter an den Einstiegspunkt jedes PEI-Moduls √ºbergeben wird und Links zu den Basisdiensten enth√§lt, die f√ºr die Funktion der PEI-Module erforderlich sind. <br><br>  Wir werden uns nur f√ºr die Felder interessieren, die sich ganz am Anfang der Struktur befinden: <br><br><img src="https://habrastorage.org/webt/w_/iz/_m/w_iz_mocpact66z4c382r0o53zc.png"><br><br>  <b>Ein Fragment einer realen Struktur vom Typ EFI_PEI_SERVICES im IDA Pro-Disassembler.</b> <br><br>  Und so erscheint es im Quellcode in der Sprache ‚ÄûC‚Äú (denken Sie daran, dies ist nur ein Fragment der Struktur): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EFI_PEI_SERVICES</span></span></span><span class="hljs-class"> {</span></span> EFI_TABLE_HEADER Hdr; EFI_PEI_INSTALL_PPI InstallPpi; EFI_PEI_REINSTALL_PPI ReInstallPpi; EFI_PEI_LOCATE_PPI LocatePpi; EFI_PEI_NOTIFY_PPI NotifyPpi; <span class="hljs-comment"><span class="hljs-comment">//...      ... };</span></span></code> </pre> <br>  Am Anfang der Struktur EFI_PEI_SERVICES steht wie in allen "grundlegenden" Servicetabellen (Servicetabellen) die Struktur EFI_TABLE_HEADER.  Mit den in dieser Header-Struktur dargestellten Werten k√∂nnen wir eindeutig feststellen, dass, wenn die EFI_PEI_SERVICES-Struktur selbst tats√§chlich auf dem Fragment des Disassemblers vorhanden ist (siehe Feld ‚ÄûHdr.Signature‚Äú), zumindest die Vorlage dieser Struktur! <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EFI_TABLE_HEADER</span></span></span><span class="hljs-class"> {</span></span> UINT64 Signature; UINT32 Revision; UINT32 HeaderSize; UINT32 CRC32; UINT32 Reserved; };</code> </pre> <br>  Auf dem Weg dorthin k√∂nnen wir feststellen, dass die Firmware zu einem Zeitpunkt entwickelt wurde, als die Version der UEFI PI-Spezifikation 1,2 betrug, deren Relevanzzeitraum von 2009 bis 2013 betrug, aber im Moment (Anfang 2019) ist die aktuelle Version der Spezifikation bereits gewachsen (buchst√§blich neulich gewachsen). auf Version 1.7. <br><br>  Aus dem Feld "Hdr.HeaderSize" kann bestimmt werden, dass die Gesamtl√§nge der Struktur 78h betr√§gt (und dies ist nicht die L√§nge des Headers, wie der Name schon sagt, sondern die L√§nge der gesamten Struktur von EFI_PEI_SERVICES). <br><br>  Schnittstellen EFI_PEI_SERVICES sind in 7 Kategorien / Klassen unterteilt.  Wir listen sie nur auf: <br><br><ol><li>  PPI-Dienste. </li><li>  Boot Mode Services. </li><li>  HOB-Dienstleistungen. </li><li>  Firmware Volume Services. </li><li>  PEI-Speicherdienste. </li><li>  Statuscode-Dienste. </li><li>  Dienste zur√ºcksetzen. </li></ol><br>  Alle weiteren Erl√§uterungen beziehen sich direkt auf die Verfahren der Kategorie / Klasse der PPI-Dienste, die f√ºr die Organisation der Interaktion zwischen Modulen von ausf√ºhrbaren Modulen in der PEI-Phase vorgesehen sind. <br><br>  Und f√ºr die PEI-Phase gibt es nur vier. <br><br>  Im Allgemeinen muss der Zweck jeder der Schnittstellen nicht erraten werden: Die Funktionalit√§t wird vollst√§ndig durch den Namen der Schnittstelle bestimmt, alle Details sind in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation enthalten</a> . <br><br>  Das Folgende sind Prototypen dieser Verfahren: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_INSTALL_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *PpiList)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_REINSTALL_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *OldPpi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *NewPpi)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_LOCATE_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_GUID *Guid, UINTN Instance, EFI_PEI_PPI_DESCRIPTOR **PpiDescriptor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **Ppi)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_NOTIFY_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_NOTIFY_DESCRIPTOR *NotifyList)</span></span></span></span>;</code> </pre> <br>  Wir stellen nur fest, dass zus√§tzlich zu den Befehlen <b>"Indirekter Aufruf"</b> , die die Prozeduren / Schnittstellen der Klasse "PPI Services" aufrufen, ein expliziter (direkter - nicht tabellarischer) Aufruf dieser Prozeduren m√∂glich ist, der manchmal in den ausf√ºhrenden Modulen erfolgt, in denen die Struktur EFI_PEI_SERVICES definiert / erstellt wird. <br><br>  Ich werde Ihnen ein kleines Geheimnis verraten: Seltsamerweise ist dies zwar die "grundlegende" Tabelle der Dienste f√ºr die PEI-Phase, aber wie die Praxis zeigt, kann sie nicht nur im PEI_CORE-Modul definiert werden. <br><br>  In der Realit√§t gibt es Firmwares, in denen die Struktur EFI_PEI_SERVICES definiert / gebildet und in mehreren Modulen verwendet wurde, und dies waren keineswegs Kopien des Moduls PEI_CORE. <br><br>  Somit sind folgende Codeoptionen m√∂glich: <br><br><pre> <code class="cpp hljs">seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>0D B8 <span class="hljs-number"><span class="hljs-number">8</span></span>C A6 <span class="hljs-number"><span class="hljs-number">78</span></span>+ mov eax, offset ppiList_78A68C seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>12 <span class="hljs-number"><span class="hljs-number">50</span></span> push eax ; PpiList seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>13 <span class="hljs-number"><span class="hljs-number">57</span></span> push edi ; PeiServices seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>14 <span class="hljs-number"><span class="hljs-number">89</span></span> <span class="hljs-number"><span class="hljs-number">86</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>E+ mov [esi+<span class="hljs-number"><span class="hljs-number">0E40</span></span>h], eax seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>1A E8 <span class="hljs-number"><span class="hljs-number">70</span></span> FC FF+ call InstallPpi</code> </pre> <br>  <b>Ein Beispiel f√ºr einen expliziten Aufruf der Prozedur "InstallPpi".</b> <br><br><pre> <code class="cpp hljs">seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBB <span class="hljs-number"><span class="hljs-number">8B</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>D FC mov ecx, [ebp+PeiServices] seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBE <span class="hljs-number"><span class="hljs-number">50</span></span> push eax ; PpiList seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBF C7 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>+ mov dword ptr [eax], <span class="hljs-number"><span class="hljs-number">80000010</span></span>h seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CC5 C7 <span class="hljs-number"><span class="hljs-number">43</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>C A8+ mov dword ptr [ebx+<span class="hljs-number"><span class="hljs-number">3</span></span>Ch], offset guid_78A9A8 seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCC <span class="hljs-number"><span class="hljs-number">8B</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> mov edx, [ecx] seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCE <span class="hljs-number"><span class="hljs-number">51</span></span> push ecx ; PeiServices seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCF FF <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call [edx+EFI_PEI_SERVICES.InstallPpi]</code> </pre> <br>  <b>Ein Beispiel f√ºr einen impliziten Aufruf der InstallPpi-Schnittstelle.</b> <br><br><pre> <code class="cpp hljs">FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">18</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call [ex+EFI_PEI_SERVICES.InstallPpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">1</span></span>Ch] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>C call [ex+EFI_PEI_SERVICES.ReInstallPpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">20</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> call [ex+EFI_PEI_SERVICES.LocatePpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">24</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> call [ex+EFI_PEI_SERVICES.NotifyPpi]</code> </pre>  <b>Beispiele f√ºr implizite Schnittstellenaufrufe vor und nach der Authentifizierung.</b> <br><br>  Wir stellen ein charakteristisches Merkmal fest: Im Fall der PEI-Phase f√ºr die IA-32-Architektur weisen Schnittstellen der PPI Services-Klasse Offsets von 18h, 1Ch, 20h und 24h auf. <br><br>  Und jetzt geben wir folgende Aussage an: <br><blockquote>  Um ein <u><i>statisches Abh√§ngigkeitsdiagramm der</i></u> PEI-Phase zu erstellen, ist <b>es notwendig und ausreichend</b> , alle ausf√ºhrbaren Module der Phase <u><i>vollst√§ndig zu zerlegen</i></u> (mindestens alle Befehle zu trennen) und die Befehle <b>"Indirekter Aufruf"</b> mit Offsets 18h, 1Ch, 20h, 24h in zerlegten Modulen zu dekompilieren. </blockquote>  Tats√§chlich haben wir einen Algorithmus zur L√∂sung des Problems vollst√§ndig formuliert. Sobald es uns gelungen ist, alle Aufrufe der Schnittstellen / Prozeduren der PPI Services-Klasse zu isolieren, muss nur noch bestimmt werden, welche Parameter an diese Aufrufe √ºbergeben werden.  Die Aufgabe mag nicht die trivialste sein, aber wie die Praxis gezeigt hat, ist sie vollst√§ndig l√∂sbar, wir haben alle Daten daf√ºr. <br><br>  Und jetzt echte Beispiele f√ºr echte Daten f√ºr echte PEI-Phasenmodule.  Wir geben nicht wissentlich an, welche BIOS / UEFI-Ergebnisse des Unternehmens erzielt wurden, sondern geben nur Beispiele f√ºr deren Aussehen. <br><br><h2>  Zwei Beispiele f√ºr PEIM-Modulbeschreibungen mit vollst√§ndigen Informationen zur Verwendung der PPI Services-Schnittstellen in diesen Modulen </h2><br><pre> <code class="plaintext hljs"> -- File 04-047/0x02F/: "TcgPlatformSetupPeiPolicy" : [007CCAF0 - 007CD144] DEPENDENCY_START EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI DEPENDENCY_END Install Protocols: [1] TCG_PLATFORM_SETUP_PEI_POLICY Locate Protocols: [2] EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI</code> </pre><pre> <code class="plaintext hljs">-- File 04-048/0x030/: "TcgPei" : [007CD160 - 007CF5DE] DEPENDENCY_START EFI_PEI_MASTER_BOOT_MODE_PEIM_PPI EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI AND DEPENDENCY_END Install Protocols: [1] AMI_TCG_PLATFORM_PPI [2] EFI_PEI_TCG_PPI [2] PEI_TPM_PPI Locate Protocols: [1] EFI_PEI_TCG_PPI [1] EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI [1] TCG_PLATFORM_SETUP_PEI_POLICY [5] PEI_TPM_PPI Notify Events: [1] AMI_TCM_CALLBACK ReInstall Protocols: [1] PEI_TPM_PPI</code> </pre><br><h2>  Protokolllisten nach Schnittstellentypen, in denen sie verwendet wurden </h2><br>  Unter den Spoilern finden Sie abgek√ºrzte Beispiele f√ºr Listen von PPIM-Protokollen f√ºr jede der Schnittstellen der PPI Services-Klasse. <br><br>  Das Format der Listen ist wie folgt: <br><pre> |  Seriennummer |  name_PPI |  guid_PPI |  ausf√ºhrbarer_name: benutzername |
</pre><br><div class="spoiler">  <b class="spoiler_title">***** Installiere 99 Ppi in "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/kl/o_/-q/klo_-qpqz-m_lokouctilmlnbxw.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Suchen Sie 194 Ppi in "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_i/bl/30/_ibl301bqdkcqk33z-i7ifzqejk.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Installieren Sie 5 Ppi in "Firmware" neu</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/7g/pe/xb/7gpexbxvf_k4sla038anu32el7s.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Benachrichtigen Sie 29 Ppi in "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ui/fj/m6/uifjm6sznoctafiav_4cez64ezc.png"><br></div></div><br><h2>  Die endg√ºltige Liste aller Handb√ºcher der Protokolle, auf die in einem bestimmten BIOS / UEFI verwiesen wird, mit einer Legende, die angibt, in welchen "PPI-Diensten" diese Protokolle enthalten sind </h2><br>  Unten finden Sie eine Spoiler-Liste von 97 PPi-Guids, die in einer bestimmten Firmware gefunden und explizit verwendet wurden, deren Daten zuvor angegeben wurden. <br><br>  Vor jedem Element aus der Liste steht eine Legende, die alle Verwendungsarten eines bestimmten Protokolls widerspiegelt. <br><br><pre> <code class="plaintext hljs">"D" - in DEPENDENCY section used "I" - in "InstallPpi" functions used "L" - in "LocatePpi" functions used "R" - in "ReInstallPpi" functions used "N" - in "NotifyPpi" functions used</code> </pre><br><div class="spoiler">  <b class="spoiler_title">***** Liste Ppi in "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wn/cm/8y/wncm8ymfrh-8oxdssbu0kuazejc.png"><br><img src="https://habrastorage.org/webt/t1/sn/xq/t1snxq4jhzprqvwoq93ithtlfow.png"><br><img src="https://habrastorage.org/webt/y1/tg/mz/y1tgmz0bysbuzmszkope_hegfoa.png"><br></div></div><br>  Die folgenden Protokolllistenintervalle sind in diesem BIOS / UEFI bemerkenswert: <br><br><ol><li>  Nr. 38-50. <br>  Definieren von Protokollen / Ereignissen (InstallPpi), die von keinem Modul verwendet werden. </li><li>  Nr. 87-95. <br>  Versuchen Sie, Protokolle anzufordern, die von keinem Modul dieser Firmware installiert wurden. <br></li><li>  Nr. 96-97. <br>  Zwei "Benachrichtigungs" -Ereignisse, f√ºr die sich kein Modul die M√ºhe gemacht hat, die entsprechende Schnittstelle zu deklarieren. Obwohl diese Prozeduren in ausf√ºhrbaren Modulen deklariert sind, funktionieren sie niemals. </li></ol><br><h2>  Fazit </h2><br><ul><li>  √Ñhnliche Ergebnisse wie oben wurden f√ºr BIOS / UEFI von verschiedenen Herstellern erhalten, weshalb alle Beispiele anonym sind. </li><li>  Tats√§chlich wurden allgemeinere Aufgaben zum Umkehren der Algorithmen ausf√ºhrbarer BIOS / UEFI-Module gel√∂st, und das resultierende Diagramm ist ein Nebenergebnis, eine Art zus√§tzlicher Bonus. </li><li><blockquote>  Die korrekte L√∂sung der Aufgabe <i><u>"Abrufen eines statischen Abh√§ngigkeitsgraphen"</u></i> f√ºr ausf√ºhrbare BIOS / UEFI-Module erfordert eine statische Analyse des Bin√§rcodes, die eine <i><u>vollst√§ndige Demontage der</u></i> ausf√ºhrbaren Module und eine <i><u>teilweise Dekompilierung</u></i> <b>der Indirect Call-</b> Befehle dieser Module umfasst. </blockquote></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440052/">https://habr.com/ru/post/de440052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440040/index.html">In der Entwicklung - jeder f√ºr sich. Aber manchmal f√ºhrt es zu einer Sackgasse.</a></li>
<li><a href="../de440044/index.html">Qualcomm Detaillierte Geschichte</a></li>
<li><a href="../de440046/index.html">Offene Lektion "Erstellen von REST-Clients im Fr√ºhling"</a></li>
<li><a href="../de440048/index.html">Lieblingskennzahlen: 5 Indikatoren, denen jedes Verkaufsteam folgen muss</a></li>
<li><a href="../de440050/index.html">Do-it-yourself-DNS-Proxys auf Node.JS</a></li>
<li><a href="../de440054/index.html">√úbertragen Sie den Webdienst mit AWS auf Yandex.Cloud</a></li>
<li><a href="../de440058/index.html">Internet Issues & Availability Report 2018‚Äì2019</a></li>
<li><a href="../de440060/index.html">TensorFlow auf Apache Ignite</a></li>
<li><a href="../de440062/index.html">Mit Vergn√ºgen planen. Wie wir Prozesse ohne Manager einrichten</a></li>
<li><a href="../de440064/index.html">Rechenzentren zur Auswahl: London, Moskau, Z√ºrich, St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>