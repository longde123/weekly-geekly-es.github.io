<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏üèΩ üë©üèº‚Äçüè≠ üç≥ C√≥mo acelerar el trabajo con la API de lenguaje R usando computaci√≥n paralela, usando el ejemplo de la API Yandex.Direct (Parte 2) üë®‚Äçüë¶ üóÑÔ∏è üèÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el √∫ltimo art√≠culo, habl√© sobre lo que es el subprocesamiento m√∫ltiple y di ejemplos de su implementaci√≥n en el lenguaje R al trabajar con la API d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo acelerar el trabajo con la API de lenguaje R usando computaci√≥n paralela, usando el ejemplo de la API Yandex.Direct (Parte 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448404/"><p> En el √∫ltimo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo,</a> habl√© sobre lo que es el subprocesamiento m√∫ltiple y di ejemplos de su implementaci√≥n en el lenguaje R al trabajar con la API <code>doSNOW</code> usando los <code>doParallel</code> <code>doSNOW</code> , <code>doParallel</code> y la construcci√≥n <code>foreach</code> . </p><br><p>  Este art√≠culo es una continuaci√≥n, pero se puede considerar como una gu√≠a fuera de l√≠nea para subprocesos m√∫ltiples en R. Se me solicit√≥ que lo escribiera por los comentarios recibidos en la primera parte (aqu√≠ un agradecimiento especial a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Alexey_mosc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">SatCat</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Ananiev_Genrih</a> ), en el que me dieron una serie de paquetes que representan un enfoque m√°s moderno para implementaciones de subprocesos m√∫ltiples en R, hablaremos de ellas m√°s adelante. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/302/1a1/570/3021a15709dae984b328e3af5364d1de.png" alt="Multithreading"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Contenido </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desaf√≠o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Preparaci√≥n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplo de soluci√≥n de procesamiento en serie, funci√≥n sapply y paquete purrr</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funci√≥n Sapply</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paquete Purrr</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Opciones multiproceso para resolver la tarea de recopilar palabras clave de Yandex.Direct</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paquete paralelo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paquete futuro</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Envolturas sobre el futuro</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paquete de aplicaci√≥n futura.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paquete Furrr</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba de velocidad</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusi√≥n</a> </li><li>  Encuesta </li></ul><br><h1 id="zadacha">  Desaf√≠o </h1><br><p>  Como ejemplo, tomamos el problema considerado en una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n anterior</a> , es decir,  en modo multiproceso, recopile una lista de palabras clave de 4 cuentas de publicidad Yandex.Direct. </p><br><p>  Para trabajar con la API <code>ryandexdirect</code> , utilizaremos el paquete <code>ryandexdirect</code> .  La documentaci√≥n oficial est√° en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> , pero para la implementaci√≥n de la tarea descrita, solo necesitamos 2 funciones: </p><br><ul><li>  <code>yadirAuth</code> : autorizaci√≥n en la API Yandex.Direct; </li><li>  <code>yadirGetKeyWords</code> : descargue una lista de palabras clave de las cuentas publicitarias. </li></ul><br><p>  No es solo que eleg√≠ el proceso de descarga de palabras clave, el hecho es que esta es una de las operaciones m√°s largas en la API Yandex.Direct.  En segundo lugar, en todas las cuentas el n√∫mero de palabras clave es diferente, por lo tanto, el tiempo para completar esta operaci√≥n para cada cuenta ser√° muy diferente, en nuestro caso de 1 a 20 segundos. </p><br><h1 id="podgotovka">  Preparaci√≥n </h1><br><p>  Inicialmente, debe instalar todos los paquetes discutidos en este art√≠culo, para esto puede usar el siguiente c√≥digo. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 1: Instalaci√≥n de paquetes</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#    install.packages("ryandexdirect") install.packages("tictoc") install.packages("rbenchmark") install.packages("dplyr") install.packages("purrr") install.packages("future") install.packages("promises") install.packages("furrr") install.packages("future.apply")</code> </pre> </div></div><br><p>  Para que las funciones del paquete est√©n disponibles para usted, debe conectarlo utilizando el comando de <code>library</code> .  Para mayor comodidad, conectar√© por separado todos los paquetes necesarios en cada ejemplo de c√≥digo dado. </p><br><p>  Creamos un vector que consiste en inicios de sesi√≥n Yandex.Direct, desde el cual luego solicitaremos palabras clave: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 2: Crear un vector de inicio de sesi√≥n</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">logins &lt;- c("login1", "login2", "login3", "login4")</code> </pre> </div></div><br><p>  Para trabajar con la API Yandex.Direct, primero debe pasar por la autorizaci√≥n de cada cuenta, para esto puede usar el siguiente dise√±o: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 3: Autorizaci√≥n en la API Yandex.Direct</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">lapply(logins, function(l) { yadirAuth(Login = l)})</code> </pre> </div></div><br><p>  Despu√©s de ejecutar el c√≥digo anterior, se abrir√° un navegador para autorizaci√≥n bajo cada cuenta.  Usted confirma el permiso para que <code>ryandexdirect</code> acceda a sus materiales publicitarios.  Ser√°s redirigido a la p√°gina donde necesitas copiar el c√≥digo de verificaci√≥n.  Al ingresarlo en la consola R, complete el proceso de autorizaci√≥n.  Esta operaci√≥n se repite para cada inicio de sesi√≥n que especific√≥ al crear los inicios de sesi√≥n vectoriales. </p><br><p>  Algunos usuarios, durante el proceso de autorizaci√≥n, pueden confundirse por el hecho de una redirecci√≥n a un recurso de terceros, pero no hay peligro para su cuenta en esto, describ√≠ este tema con m√°s detalle en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Cu√°n seguro es usar paquetes R para trabajar con API de sistemas publicitarios"</a> . </p><br><p>  A continuaci√≥n, consideraremos varios ejemplos de la implementaci√≥n de la tarea descrita.  Cada uno de los cuales comenzar√° con un c√≥digo de ejemplo y su explicaci√≥n adicional.  Creo que esta opci√≥n ser√° m√°s conveniente para la percepci√≥n. </p><br><h1 id="primer-resheniya-v-posledovatelnom-rezhime-obrabotki-funkciya-sapply-i-paket-purrr">  Ejemplo de soluci√≥n de procesamiento en serie, funci√≥n sapply y paquete purrr </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/369/72e/9d8/36972e9d8707c1c508d2e43b8721778c.jpg"><br>  En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√∫ltimo art√≠culo</a> , cit√© una soluci√≥n usando el bucle <code>for</code> como ejemplo.  Dado que consideramos el subprocesamiento m√∫ltiple utilizando el paquete <code>foreach</code> , cuya sintaxis se asemeja a los bucles, este ejemplo fue apropiado all√≠, aunque el uso de bucles no es bienvenido por los usuarios de R. </p><br><p>  Los paquetes que consideraremos en este art√≠culo recuerdan m√°s las funciones de la familia de aplicaci√≥n en sintaxis; por lo tanto, dar√© un ejemplo de una soluci√≥n en modo serie us√°ndolos. </p><br><h3 id="funkciya-sapply">  Funci√≥n <code>sapply</code> </h3><br><blockquote>  Para estimar el tiempo de ejecuci√≥n de los comandos, en cada uno de los enfoques considerados, utilizaremos el paquete <code>tictoc</code> . </blockquote><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 4: Ejemplo de soluci√≥n en modo secuencial usando la funci√≥n sapply</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(tictoc) library(dplyr) tic() #   kw.sapply &lt;- sapply( logins, #  ,     function(x) #        #     { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE #     ) toc() #   #       result.sapply &lt;- do.call("rbind", kw.sapply)</code> </pre> </div></div><br><p>  Tiempo de <code>39.36 sec elapsed</code> : <code>39.36 sec elapsed</code> </p><br><p>  Al principio, la sintaxis de las funciones de la familia <code>apply</code> no es tan f√°cil de leer como la sintaxis de los bucles, pero de hecho todo es bastante simple. </p><br><p> <code>sapply(X, FUN)</code> </p> <br><p>  Donde: </p><br><ul><li>  <em>X</em> - Un objeto cuyos elementos iteraremos y usaremos a su vez en cada iteraci√≥n, en un bucle <code>for</code> se ve√≠a as√≠: <code>for(i in X)</code> ; </li><li>  <em>FUN</em> : una funci√≥n en la que sustituiremos cada elemento del objeto <em>X</em> a su vez, si dibujamos una analog√≠a con <code>for</code> , entonces este es el cuerpo del bucle. </li></ul><br><p>  En el Ejemplo de <strong>c√≥digo 4</strong> , el vector de <em>inicio de sesi√≥n</em> creado anteriormente se pasa al argumento <em>X.</em>  Cada elemento del vector de <code>function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }</code> de <em>sesi√≥n</em> se pasa a su vez como el √∫nico argumento para la funci√≥n de <code>function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }</code> an√≥nima <code>function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }</code> que se pas√≥ al argumento <em>FUN</em> . </p><br><p>  Es decir  <code>sapply</code> ejecutar√° la funci√≥n especificada en <em>FUN</em> 4 veces, sustituyendo los inicios de sesi√≥n en uno uno por uno, y devolver√° el resultado en forma de una lista (objeto de la <em>lista</em> de clase) que consta de 4 elementos.  Cada elemento es una tabla con una lista de palabras clave recibidas de la cuenta en cada iteraci√≥n. </p><br><ol><li> <code>yadirGetKeyWords(Login = "login1") %&gt;% mutate(login = "login1")</code> </li> <li> <code>yadirGetKeyWords(Login = "login2") %&gt;% mutate(login = "login2")</code> </li> <li> <code>yadirGetKeyWords(Login = "login3") %&gt;% mutate(login = "login3")</code> </li> <li> <code>yadirGetKeyWords(Login = "login4") %&gt;% mutate(login = "login4")</code> </li> </ol><br><p>  El objeto obtenido usando <code>sapply</code> tiene la siguiente estructura: </p><br><pre> <code class="plaintext hljs">summary(kw.sapply)</code> </pre> <br><pre> <code class="plaintext hljs"> Length Class Mode login1 19 data.frame list login2 19 data.frame list login3 19 data.frame list login4 19 data.frame list</code> </pre> <br><p>  Al final de este ejemplo, el comando <code>result.sapply &lt;- do.call("rbind", kw.sapply)</code> combina los 4 elementos de la lista <em>kw.sapply</em> en un marco <em>result.sapply</em> . </p><br><pre> <code class="plaintext hljs"># A tibble: 6,804 x 1 result.sapply$Id $Keyword $AdGroupId $CampaignId $ServingStatus $State &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; 1 15164230566 ~ 3597453985 39351725 ELIGIBLE ON 2 15164230567  ~ 3597453985 39351725 ELIGIBLE ON 3 15164230568  ~ 3597453985 39351725 ELIGIBLE ON 4 15164230569 ~ 3597453985 39351725 ELIGIBLE ON 5 15164230570 ~ 3597453985 39351725 ELIGIBLE ON 6 15164230571  ~ 3597453985 39351725 ELIGIBLE ON 7 15164230572 ~ 3597453985 39351725 ELIGIBLE ON 8 15164230573  ~ 3597453985 39351725 ELIGIBLE ON 9 15164230574 ~ 3597453985 39351725 ELIGIBLE ON 10 15164230575 ~ 3597453985 39351725 ELIGIBLE ON # ... with 6,794 more rows, and 13 more variables: $Status &lt;fct&gt;, # $StrategyPriority &lt;fct&gt;, $StatisticsSearchImpressions &lt;int&gt;, # $StatisticsSearchClicks &lt;int&gt;, $StatisticsNetworkImpressions &lt;int&gt;, # $StatisticsNetworkClicks &lt;lgl&gt;, $UserParam1 &lt;chr&gt;, $UserParam2 &lt;chr&gt;, # $ProductivityValue &lt;lgl&gt;, $ProductivityReferences &lt;lgl&gt;, $Bid &lt;dbl&gt;, # $ContextBid &lt;dbl&gt;, $login &lt;chr&gt;</code> </pre> <br><p>  Adem√°s de <code>sapply</code> , la familia de funciones <code>*apply</code> incluye: <code>apply</code> , <code>lapply</code> , <code>vapply</code> , <code>mapply</code> y otras. </p><br><h3 id="paket-purrr">  Paquete <code>purrr</code> </h3><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 5: ejemplo de soluci√≥n utilizando las funciones del paquete purrr</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) library(dplyr) library(tictoc) tic() #   result.purrr &lt;- map_df( logins, #  ,     ~ #   function(.x) { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) toc() #  </code> </pre> </div></div><br><p>  Tiempo de <code>35.46 sec elapsed</code> : <code>35.46 sec elapsed</code> </p><br><p>  El paquete <code>purrr</code> es parte del n√∫cleo de la biblioteca <code>tidyverse</code> , escrito por Headley Wickham. </p><br><p>  En t√©rminos de significado y sintaxis, las funciones principales del paquete son muy similares a <code>sapply</code> , su principal ventaja es la siguiente: </p><br><ul><li>  Las funciones se dividen en familias <code>map</code> , <code>map2</code> , <code>pmap</code> , <code>walk</code> etc. Las funciones separadas incluidas en la misma familia devuelven el resultado en diferentes formatos: <em>chr</em> , <em>dbl</em> , <em>int</em> , <em>df</em> , etc. </li><li>  Las funciones de la familia <code>map2</code> sobre elementos (iterar) simult√°neamente de dos objetos; </li><li>  Las funciones de la familia <code>pmap</code> simult√°neamente sobre elementos de cualquier cantidad de objetos.  Puede pasar una tabla a la entrada del argumento <em>.l</em> <em>(un an√°logo del argumento X en sapply)</em> , cada columna de los cuales contendr√° los valores por los cuales iterar√°, y que ser√°n sustituidos a su vez en los argumentos de la misma funci√≥n pasada en <em>.f</em> <em>(el an√°logo FUN de sapply)</em> . </li></ul><br><p>  ¬øEn qu√© situaci√≥n necesitamos iterar sobre elementos de varios objetos?  Por ejemplo, trabaja con varias cuentas de agentes, y las cuentas publicitarias de las que desea obtener una lista de palabras clave se encuentran dispersas entre ellas.  En este caso, puede crear un vector a partir de los nombres de las cuentas de agentes e iterar sobre √©l, en paralelo con la forma en que clasifica los inicios de sesi√≥n de las cuentas publicitarias. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 6: ejemplo de trabajo con varias cuentas de agente</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #      agencies &lt;- c("agency1", NA, "agency2", "agency1") #      #         result.pmap2 &lt;- map2_df(.x = logins, .y = agencies, ~ { yadirGetKeyWords(Login = .x, AgencyAccount = .y) %&gt;% mutate(login = .x) })</code> </pre> </div></div><br><p>  Ahora imagine la situaci√≥n de que cuando inici√≥ sesi√≥n con diferentes cuentas, guard√≥ el archivo con las credenciales en diferentes carpetas, luego necesita iterar inmediatamente en tres objetos: inicios de sesi√≥n de cuentas publicitarias, inicios de sesi√≥n de cuentas de agentes, la ruta en la que se almacena el archivo con credenciales.  Esto se puede hacer con ayuda.  <code>pmap</code> familia <code>pmap</code> . </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 7: ejemplo de funci√≥n pmap</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #  ,       #      TokenPath &lt;- c("C:\\proj1\\tokens", "C:\\yandex\\token", "C:\\yandex\\token", "C:\\my_yandex_acoount") #   pmap.result &lt;- pmap_df(list(Login = logins, AgencyAccount = agencies, TokenPath = TokenPath), yadirGetKeyWords)</code> </pre> </div></div><br><p>  En consecuencia, el resultado de ejecutar las funciones <code>map_df</code> , <code>map2_df</code> y <code>pmap_df</code> es el marco de fecha, y cuando se usan, no se requiere el √∫ltimo paso del ejemplo con <code>sapply</code> ( <code>do.call("rbind", kw.sapply)</code> ). </p><br><p>  El c√≥digo se ha vuelto m√°s compacto y ejecutado un poco m√°s r√°pido, pero, sin embargo, los enfoques descritos, <code>sapply</code> y <code>sapply</code> , recopilan palabras clave de cada cuenta de forma secuencial.  Por lo tanto, el tiempo total de ejecuci√≥n de esta operaci√≥n es igual a la suma de las duraciones de la recopilaci√≥n de datos de las cuatro cuentas. </p><br><p>  <strong>Tiempo [total]</strong> = <em>Tiempo [inicio de sesi√≥n1] + Tiempo [inicio de sesi√≥n2] + Tiempo [inicio de sesi√≥n3] + Tiempo [inicio de sesi√≥n4]</em> </p><br><h1 id="mnogopotochnye-varianty-resheniya-zadachi-po-sboru-klyuchevyh-slov-iz-yandeksdirekt">  Opciones multiproceso para resolver la tarea de recopilar palabras clave de Yandex.Direct </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/53c/cf5/ab353ccf566421eaaa6ec3d6445399a1.jpg"></p><br><p>  Entonces, si ya ha le√≠do el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer art√≠culo</a> , entonces sabe que el modo de operaci√≥n multiproceso tiene varias caracter√≠sticas: </p><br><ul><li>  Cada hilo comienza en una sesi√≥n R separada con un entorno de trabajo limpio. </li><li>  Por la misma raz√≥n, en un proceso de ejecuci√≥n separado, los paquetes conectados previamente no se transmiten de manera predeterminada. </li></ul><br><p>  La exportaci√≥n de objetos creados en un entorno de trabajo y la conexi√≥n de paquetes en cada enfoque se implementa de manera diferente, luego los consideraremos con m√°s detalle. </p><br><h3 id="paket-parallel">  Paquete <code>parallel</code> </h3><br><p>  Este paquete se incluy√≥ por primera vez en el paquete R en la versi√≥n 2.14.0 y hasta el d√≠a de hoy viene con R en s√≠. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 8: ejemplo de soluci√≥n al problema a trav√©s del paquete paralelo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictoc) #   cl &lt;- makeCluster(4) #      clusterExport(cl = cl, varlist = "logins") #  ,      #  ,       ryandexdirect clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) tic() #   parallel.kw &lt;- parSapplyLB(cl = cl, #   X = logins, # ,     FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) #    toc() #     #   stopCluster(cl) #      result.parallel &lt;- dplyr::bind_rows(parallel.kw)</code> </pre> </div></div><br><p>  Tiempo de <code>16.75 sec elapsed</code> : <code>16.75 sec elapsed</code> </p><br><p>  Intentemos analizar el <strong>C√≥digo 8</strong> .  La funci√≥n <code>makeCluster</code> crea un grupo de 4 procesos.  Podemos exportar objetos de nuestro entorno de trabajo principal al cl√∫ster creado usando la funci√≥n <code>clusterExport</code> , para esto necesitamos usar sus argumentos: </p><br><ul><li>  <em>cl</em> : cl√∫ster en el que exportaremos objetos </li><li>  <em>varlist</em> : un vector de texto que contiene los nombres de los objetos que se exportar√°n a cada proceso de cl√∫ster. </li></ul><br><p>  Una forma de conectar los paquetes correctos en cada nodo del cl√∫ster es usar la funci√≥n <code>clusterEvalQ</code> .  En nuestro ejemplo, lo usamos para conectar paquetes, pero puede escribir cualquier c√≥digo R dentro de <code>clusterEvalQ</code> , y se iniciar√° al comienzo de cada nodo del cl√∫ster.  Los argumentos para esta funci√≥n son bastante obvios, debe especificar el cl√∫ster y los comandos que se ejecutar√°n en √©l. </p><br><p>  <code>parSapplyLB</code> es una versi√≥n paralela de la funci√≥n <code>sapply</code> con equilibrio de carga entre los nodos del cl√∫ster, tambi√©n lo usan, pero debe especificar el cl√∫ster con el argumento <em>cl</em> . </p><br><p>  Tambi√©n en <code>parallel</code> hay otras versiones paralelas de las funciones de la familia <code>*apply</code> : <code>parLapply</code> , <code>parSapply</code> , <code>parApply</code> , etc. </p><br><p>  <code>parSapply</code> difiere de <code>parSapplyLB</code> solo en que no tiene equilibrio de carga en los nodos del cl√∫ster. </p><br><p>  La funci√≥n <code>stopCluster</code> se usa para detener el cl√∫ster creado. </p><br><p>  El √∫ltimo comando, <code>dplyr::bind_rows(parallel.kw)</code> combinamos el objeto <em>parallel.kw</em> obtenido usando <code>parSapplyLB</code> en una tabla. </p><br><p>  Para Linux, el <code>parallel</code> tiene funciones separadas: <code>mclapply</code> , <code>mcmapply</code> , <code>mcMap</code> .  A menudo, en este sistema operativo, los comandos se ejecutan m√°s r√°pido y el c√≥digo se vuelve m√°s compacto. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 9: Soluci√≥n usando mclapply para Linux</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictic) library(dplyr) library(ryandexdirect) tic() mclapply.kw &lt;- mclapply(logins, FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, mc.cores = 4) toc()</code> </pre> </div></div><br><p>  Al usar estas funciones, no es necesario iniciar el cl√∫ster con el <code>makeCluster</code> .  El n√∫mero de nodos que <em>especifique</em> utilizando el argumento <em>mc.cores</em> .  Tampoco es necesario conectar paquetes y exportar objetos; estas operaciones se realizan autom√°ticamente. </p><br><h3 id="paket-future">  Paquete <code>future</code> </h3><br><p>  Uno de los enfoques m√°s modernos para la programaci√≥n asincr√≥nica en R. </p><br><p>  Un c√≥digo que en paralelo resolver√° nuestro problema con la ayuda del <code>future</code> es lo suficientemente complicado como para comprenderlo.  Por lo tanto, analicemos su trabajo en un ejemplo m√°s simple, solicitaremos una lista de palabras clave de una cuenta. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 10: el ejemplo m√°s simple de usar el paquete futuro</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) #    plan(multiprocess) #      #    future.kw &lt;- future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins") #     resolved(future.kw) #     future.result.1 &lt;- value(future.kw)</code> </pre> </div></div><br><p>  Intentemos descubrir el ejemplo del <strong>C√≥digo 10</strong> .  La funci√≥n de <code>plan</code> permite establecer y cambiar el modo de ejecuci√≥n de las expresiones dadas, estas son las principales: </p><br><ul><li>  <em>secuencial</em> : este es el modo de operaci√≥n R habitual; los comandos se ejecutan secuencialmente en la sesi√≥n actual; </li><li>  <em>multisesi√≥n</em> : modo paralelo, los comandos se ejecutar√°n en las sesiones en ejecuci√≥n en segundo plano en la m√°quina actual, mientras que su sesi√≥n de trabajo no se bloquear√°; </li><li>  <em>cluster</em> : modo paralelo, los comandos se ejecutar√°n en la m√°quina actual o remota, de forma similar a c√≥mo se implementa en el paquete <code>parallel</code> . </li></ul><br><p>  Todo el paquete <code>future</code> se basa en la ejecuci√≥n de comandos en procesos en segundo plano sin bloquear la sesi√≥n actual.  Ejecutar la ejecuci√≥n de comandos sigue la funci√≥n del mismo nombre <code>future</code> , as√≠ que cuando ejecutamos el comando: </p><br><pre> <code class="plaintext hljs">future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins")</code> </pre> <br><p>  Nuestra sesi√≥n actual en R no est√° bloqueada, y el comando se ejecuta en segundo plano, ejecutando otra sesi√≥n de R. </p><br><p>  Puede verificar el estado actual del proceso de ejecuci√≥n de una expresi√≥n dada utilizando la funci√≥n <code>resolved</code> .  Finalmente, la funci√≥n de <code>value</code> se usa para obtener el resultado de <code>future</code> ejecuci√≥n <code>future</code> .  Si ejecuta la funci√≥n de <code>value</code> antes de su ejecuci√≥n <code>future</code> en una sesi√≥n de ejecuci√≥n paralela, la sesi√≥n de trabajo actual se bloquear√° hasta que se complete la expresi√≥n de sesi√≥n paralela. </p><br><p>  El ejemplo de trabajo m√°s avanzado es el uso del <code>future</code> junto con las <code>promises</code> . </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 11: Ejemplo de compartir paquetes de `futuro` y` promesas`</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(promises) #    plan(multiprocess) #      #    future.kw &lt;- future({suppressMessages( yadirGetKeyWords(Login = logins[4]))}, packages = "ryandexdirect", globals = "logins") %...&gt;% #     future, #      nrow() %...&gt;% paste("words loaded") %...&gt;% print()</code> </pre> </div></div><br><p>  El paquete de <code>promises</code> proporciona un conjunto de operadores de tuber√≠as que complementan perfectamente la funcionalidad <code>future</code> . </p><br><p>  En el ejemplo del <strong>C√≥digo 11</strong> , en segundo plano, comenzamos el proceso de descargar palabras clave de una cuenta publicitaria.  Adem√°s, el operador de canalizaci√≥n <code>%...&gt;%</code> sin bloquear la sesi√≥n de trabajo espera <code>future</code> el <code>future</code> y realiza las operaciones restantes.  Como resultado de la ejecuci√≥n del c√≥digo, al finalizar el trabajo <code>future</code> , la cantidad de palabras clave de la cuenta especificada se mostrar√° en la consola: </p><br><pre> <code class="plaintext hljs">[1] "1855 words loaded"</code> </pre> <br><blockquote>  Al final del art√≠culo, se demostrar√° un ejemplo m√°s ilustrativo de un mont√≥n de <code>future</code> y <code>promises</code> . </blockquote><p>  De manera predeterminada, el paquete <code>future</code> exporta todo el espacio de trabajo a cada sesi√≥n de ejecuci√≥n paralela, pero usted mismo puede especificar una lista de objetos para exportar utilizando el argumento <em>global</em> . </p><br><p>  Para conectar paquetes al <code>future</code> debe pasar un vector que contenga sus nombres al argumento de <em>paquetes</em> . </p><br><p>  Ahora, de vuelta a nuestra tarea, el siguiente ejemplo de c√≥digo en modo paralelo cargar√° una lista de palabras clave de 4 cuentas: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 12: un ejemplo de resoluci√≥n de un problema utilizando el paquete futuro</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(tictoc) #   plan("multisession", workers = 4) tic() #   futs &lt;- lapply(logins, #      function(i) #        #   future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) #    kw &lt;- lapply(futs, value) #    toc() #    #     result.future &lt;- dplyr::bind_rows(kw)</code> </pre> </div></div><br><p>  Tiempo de <code>14.83 sec elapsed</code> : <code>14.83 sec elapsed</code> </p><br><p>  Para descargar una lista de palabras clave en modo multiproceso de todas las cuentas publicitarias que figuran en los <em>inicios de sesi√≥n de</em> vectores <em>,</em> debe ejecutar un <code>future</code> separado en segundo plano.  En el Ejemplo de <strong>c√≥digo 12,</strong> implementamos esto usando la funci√≥n <code>lapply</code> . </p><br><p>  El resultado de trabajar <code>lapply</code> es una lista de <code>future</code> lanzados.  Puede verificar el estado de cada uno utilizando el <code>sapply(futs, resolved)</code> , que devolver√° un vector l√≥gico donde <em>VERDADERO</em> significar√° que <code>future</code> cumple el <code>future</code> y <em>FALSO</em> ese <code>future</code> est√° actualmente en progreso. </p><br><p>  Para obtener resultados de cada <code>future</code> , despu√©s de completar su trabajo, utilizamos el <code>lapply(futs, value)</code> . </p><br><p>          : <code>result.future &lt;- dplyr::bind_rows(kw)</code> . </p><br><h3 id="obyortki-nad-future">   <code>future</code> </h3><br><p>      ,      (   <br> <code>future</code> ),      . </p><br><h6 id="paket-futureapply">  <code>future.apply</code> </h6><br><p> <code>future.apply</code>     <code>future</code> ,  . </p><br><div class="spoiler"> <b class="spoiler_title"> 13:       future.apply</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future.apply) library(tictoc) #    plan("multisession", workers = 4) tic() #   kw.future.apply &lt;- future_sapply(logins, #    ,   function(x) { #     yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, #    #   future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) toc() #   </code> </pre> </div></div><br><p>  : <code>17.28 sec elapsed</code> </p><br><p>   <strong> 13</strong> ,  <code>future.apply</code>         <code>future</code> ,         . </p><br><p>         4 : <code>plan("multisession", workers = 4)</code> . </p><br><p> <code>future_sapply</code>      <em>logins</em>    .  Es decir   ,  ,        <code>sapply</code> ,    . </p><br><p>      <code>future_sapply</code>    <em>future.packages</em> .             <em>future.globals</em> .       ,              . </p><br><h4 id="paket-furrr">  <code>furrr</code> </h4><br><p>     <code>future</code> .          <code>purrr</code> ,   <code>furrr</code>     . </p><br><div class="spoiler"> <b class="spoiler_title"> 14:      furrr</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(tictoc) #   cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) tic() #   furrr.kw &lt;- future_map(logins, ~ #   function(.x) yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) toc() #    #      result.furrr &lt;-dplyr::bind_rows(furrr.kw)</code> </pre> </div></div><br><p>  : <code>15.45 sec elapsed</code> </p><br><p> <code>furrr</code>          <code>purrr</code> .     <code>purrr</code>  ,          . </p><br><p>           <em>.options</em> .     <em>.options</em>  <code>future_options</code>     ,         . </p><br><p>   <strong> 14</strong>    <em>packages</em>  <em>globals</em>    : </p><br><pre> <code class="plaintext hljs">.options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())</code> </pre> <br><h1 id="test-skorosti">   </h1><br><p>           <code>rbenchmark</code> . </p><br><p>    ,          <code>future</code>  <code>promises</code> .                . </p><br><p>   ,     20       4     () . </p><br><p>    = (T[1] * 20) + (T[2] * 20) + (T[N] * 20) </p><br><div class="spoiler"> <b class="spoiler_title"> 15:        future  promises</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(parallel) library(dplyr) library(future) library(ryandexdirect) library(tictoc) library(rbenchmark) #   logins &lt;- c("login1", "login2", "login3", "login4") #        #        par par.furrr &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) furrr.kw &lt;- future_map(logins, ~ yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) result.furrr &lt;-dplyr::bind_rows(furrr.kw) } par.future &lt;- function(logins) { plan("multisession", workers = 4) futs &lt;- lapply(logins, function(i) future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) kw &lt;- lapply(futs, value) result.future &lt;- dplyr::bind_rows(kw) } par.future.apply &lt;- function(logins) { plan("multisession", workers = 4) kw.future.apply &lt;- future_sapply(logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) result.future.apply &lt;- dplyr::bind_rows(kw.future.apply) } par.parallel &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) clusterExport(cl = cl, varlist = "logins") clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) parallel.kw &lt;- parSapplyLB(cl = cl, X = logins, FUN = function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) stopCluster(cl) result.parallel &lt;- dplyr::bind_rows(parallel.kw) } #          seq seq.apply &lt;- function(logins) { kw.sapply &lt;- sapply( logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE ) result.sapply &lt;- do.call("rbind", kw.sapply) } seq.purrr &lt;- function(logins) { kw.purrr &lt;- map_df( logins, ~ { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) result.purrr &lt;- do.call("rbind", kw.purrr) } #       rbenchmark #   future + promises #  ,       #          plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4))) tic() speed.test &lt;- future({ #          within(benchmark(furrr = par.furrr(logins), future = par.future(logins), future.apply = par.future.apply(logins), parallel = par.parallel(logins), apply = seq.apply(logins), purrr = seq.purrr(logins), replications = c(20), columns = c('test', 'replications', 'elapsed'), order = c('elapsed', 'test')), { average = round(elapsed/replications, 2) }) }, packages = c("dplyr", "ryandexdirect", "rbenchmark", "parallel", "purrr", "future", "promises", "furrr", "future.apply"), globals = c("logins", "par.furrr", "par.future", "par.future.apply", "par.parallel", "seq.apply", "seq.purrr")) %...&gt;% print() %...T&gt;% toc() message("My Session is not blocked")</code> </pre> </div></div><br><p>       3370 , ..   . </p><br><p>           .  ,               <code>future</code>   ,       <code>promises</code>    ,                  . </p><br><p>        ,       .         "My Session is not blocked",       ,       , ..      . </p><br><p>  <code>promises</code>   : </p><br><ul><li> <code>%...&gt;%</code> ‚Äî     <code>%&gt;%</code> ,     .  Es decir   ,       <code>resolved</code> ,     <code>future</code> ,          <code>value</code>          .       ,         <code>print</code> . </li><li> <code>%...T&gt;%</code> ‚Äî  <code>%T&gt;%</code> ,  ,          .    ,          ,     , ..    ..  <code>print</code>       ,   ,    . </li><li> %...T!% ‚Äî      . </li></ul><br><p>  <strong> 15</strong>  <code>plan</code>    <code>tweak</code> ( <code>plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4)))</code> ),      ,    2 ,   <code>future</code>       4 . </p><br><p>       : </p><br><pre> <code class="plaintext hljs">My Session is not blocked test replications elapsed average 4 parallel 20 393.02 19.65 1 furrr 20 402.09 20.10 2 future 20 431.19 21.56 3 future.apply 20 432.29 21.61 5 apply 20 847.77 42.39 6 purrr 20 864.19 43.21 3370.55 sec elapsed</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/16e/906/831/16e90683145df442ca830a6758734cbe.png" alt="imagen"></p><br><p>   ,        <code>parallel</code> ,        .    <code>furrr</code> ,     <code>future</code>  <code>future.apply</code> . </p><br><p>     1 ,           ,   .         ,      API .     . </p><br><p>   ,     4        ,          . </p><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p>               R,             API. </p><br><p>   ,     API    .              <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">" R    ,  1"</a> . </p><br><p>          : </p><br><ul><li> doSNOW / doParallel + foreach </li><li> future + promises </li><li> future.apply / furrr </li><li> parallel </li></ul><br><p>         ,   ,        . </p><br><p>         ,          R  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448404/">https://habr.com/ru/post/448404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448392/index.html">Dos enfoques para estructurar un cuadro de actividades</a></li>
<li><a href="../448394/index.html">¬°La versi√≥n 12 se lanza hoy! (Y es un gran salto para Wolfram Language y Mathematica)</a></li>
<li><a href="../448396/index.html">Prepar√°ndose para Hardened Runtime and Notary Service en macOS Mojave</a></li>
<li><a href="../448400/index.html">Netplan y c√≥mo cocinarlo adecuadamente</a></li>
<li><a href="../448402/index.html">Migraci√≥n fallida de Certificate Authority (CA) de Windows 2008R a Windows 2012 R2</a></li>
<li><a href="../448408/index.html">DCIM: la clave para la gesti√≥n del centro de datos</a></li>
<li><a href="../448410/index.html">Los rastreadores de Google est√°n integrados en una serie de recursos electr√≥nicos oficiales rusos</a></li>
<li><a href="../448414/index.html">Laboratorio casero para autocontrol, o qu√© comprar en un kit geek</a></li>
<li><a href="../448416/index.html">La forma m√°s f√°cil de hacer chat en la aplicaci√≥n iOS</a></li>
<li><a href="../448420/index.html">De la vida con Kubernetes: c√≥mo el servidor HTTP de Espa√±a no se quej√≥</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>