<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏿 👨🏾‍✈️ 💛 ObjectRepository - .NET dalam memori repositori pola untuk proyek-proyek rumah Anda ⚰️ 👩🏼‍🤝‍👨🏾 👎🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa menyimpan semua data dalam memori? 


 Untuk menyimpan data situs atau backend, keinginan pertama kebanyakan orang waras adalah database SQL. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ObjectRepository - .NET dalam memori repositori pola untuk proyek-proyek rumah Anda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452232/"><h2 id="zachem-hranit-vse-dannye-v-pamyati">  Mengapa menyimpan semua data dalam memori? </h2><br><p>  Untuk menyimpan data situs atau backend, keinginan pertama kebanyakan orang waras adalah database SQL. </p><br><p>  Tapi kadang-kadang muncul ide bahwa model data tidak cocok untuk SQL: misalnya, ketika membangun pencarian atau grafik sosial, Anda perlu mencari hubungan yang kompleks antara objek. </p><br><p>  <strong>Situasi terburuk adalah ketika Anda bekerja dalam sebuah tim, dan seorang kolega tidak dapat membangun kueri cepat.</strong>  <strong>Berapa banyak waktu yang Anda habiskan untuk menyelesaikan masalah N + 1 dan membangun indeks tambahan sehingga SELECT di halaman utama berhasil dalam waktu yang wajar?</strong> </p><br><p>  Pendekatan populer lainnya adalah NoSQL.  Beberapa tahun yang lalu ada hype besar di sekitar topik ini - untuk setiap kesempatan, kami menyebarkan MongoDB dan menikmati jawaban dalam bentuk dokumen json <em>(omong-omong, berapa banyak kruk harus dimasukkan karena tautan melingkar dalam dokumen?)</em> . </p><br><p>  Mengapa tidak mencoba menyimpan semua data dalam memori aplikasi, menyimpannya secara berkala ke penyimpanan sewenang-wenang (file, basis data jauh)? </p><a name="habracut"></a><br><p>  Memori telah menjadi murah, dan setiap data yang mungkin dari sebagian besar proyek kecil dan menengah akan masuk ke dalam memori 1 GB.  <em>(Misalnya, proyek rumah favorit saya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelacak keuangan</a> yang menyimpan statistik harian dan riwayat pengeluaran, saldo, dan transaksi saya selama satu setengah tahun hanya menghabiskan 45 MB memori.)</em> </p><br><p>  Pro: </p><br><ul><li>  Akses ke data menjadi lebih mudah - tidak perlu khawatir tentang pertanyaan, pemuatan malas, fitur ORM, bekerja dengan objek C # biasa; </li><li>  Tidak ada masalah yang terkait dengan akses dari utas berbeda; </li><li>  Sangat cepat - tidak ada permintaan jaringan, tidak ada terjemahan kode ke dalam bahasa query, tidak ada (de) serialisasi objek; </li><li>  Diperbolehkan untuk menyimpan data dalam bentuk apa pun - setidaknya dalam XML pada disk, setidaknya dalam SQL Server, setidaknya dalam Azure Table Storage. </li></ul><br><p>  Cons: </p><br><ul><li>  Penskalaan horisontal hilang, dan sebagai hasilnya, penerapan downtime nol tidak dapat dilakukan; </li><li>  Jika aplikasi macet, Anda dapat kehilangan sebagian data.  <em>(Tapi aplikasi kita tidak pernah crash, kan?)</em> </li></ul><br><h2 id="kak-eto-rabotaet">  Bagaimana cara kerjanya? </h2><br><p>  Algoritma adalah sebagai berikut: </p><br><ul><li>  Pada awalnya, koneksi ke data warehouse dibuat, dan data diunduh; </li><li>  Model objek, indeks primer, dan indeks hubungan (1: 1, 1: Banyak) dibangun; </li><li>  Langganan dibuat untuk mengubah properti objek (INotifyPropertyChanged) dan untuk menambah atau menghapus elemen ke koleksi (INotifyCollectionChanged); </li><li>  Ketika langganan dipicu - objek yang diubah ditambahkan ke antrian untuk menulis ke gudang data; </li><li>  Secara berkala (berdasarkan waktu), perubahan pada penyimpanan disimpan dalam aliran latar belakang; </li><li>  Saat Anda keluar dari aplikasi, perubahan pada repositori juga disimpan. </li></ul><br><h2 id="primer-koda">  Contoh kode </h2><br><div class="spoiler">  <b class="spoiler_title">Tambahkan dependensi yang diperlukan</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   Install-Package OutCode.EscapeTeams.ObjectRepository    //  ,      //  ,   . Install-Package OutCode.EscapeTeams.ObjectRepository.File Install-Package OutCode.EscapeTeams.ObjectRepository.LiteDb Install-Package OutCode.EscapeTeams.ObjectRepository.AzureTableStorage    //  -       Hangfire // Install-Package OutCode.EscapeTeams.ObjectRepository.Hangfire</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Kami menggambarkan model data yang akan disimpan di repositori</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ParentEntity</span></span> : <span class="hljs-title"><span class="hljs-title">BaseEntity</span></span> {  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParentEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Guid id</span></span></span><span class="hljs-function">)</span></span> =&gt; Id = id; }  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ChildEntity</span></span> : <span class="hljs-title"><span class="hljs-title">BaseEntity</span></span> {  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChildEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Guid id</span></span></span><span class="hljs-function">)</span></span> =&gt; Id = id;  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Guid ParentId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Kemudian model objek:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ParentModel</span></span> : <span class="hljs-title"><span class="hljs-title">ModelBase</span></span> {  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParentModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ParentEntity entity</span></span></span><span class="hljs-function">)</span></span>  {    Entity = entity;  }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParentModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>  {    Entity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParentEntity(Guid.NewGuid());  }    <span class="hljs-comment"><span class="hljs-comment">//   1:Many  public IEnumerable&lt;ChildModel&gt; Children =&gt; Multiple&lt;ChildModel&gt;(x =&gt; x.ParentId);    protected override BaseEntity Entity { get; } }  public class ChildModel : ModelBase {  private ChildEntity _childEntity;    public ChildModel(ChildEntity entity)  {    _childEntity = entity;  }    public ChildModel()  {    _childEntity = new ChildEntity(Guid.NewGuid());  }    public Guid ParentId  {    get =&gt; _childEntity.ParentId;    set =&gt; UpdateProperty(() =&gt; _childEntity.ParentId, value);  }    public string Value  {    get =&gt; _childEntity.Value;    set =&gt; UpdateProperty(() =&gt; _childEntity.Value, value);  }    //       public ParentModel Parent =&gt; Single&lt;ParentModel&gt;(ParentId);    protected override BaseEntity Entity =&gt; _childEntity; }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Dan akhirnya, kelas repositori itu sendiri untuk mengakses data:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyObjectRepository</span></span> : <span class="hljs-title"><span class="hljs-title">ObjectRepositoryBase</span></span> {  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyObjectRepository</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStorage storage</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">storage, NullLogger.Instance</span></span></span><span class="hljs-function">)</span></span>  {    IsReadOnly = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,            AddType((ParentEntity x) =&gt; new ParentModel(x));    AddType((ChildEntity x) =&gt; new ChildModel(x));      //   Hangfire       Hangfire  ObjectRepository    // this.RegisterHangfireScheme();      Initialize();  } }</span></span></code> </pre> </div></div><br><p>  Buat instance dari ObjectRepository: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LiteDatabase(memory); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LiteDbStorage(db);  <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repository = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyObjectRepository(dbStorage); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> repository.WaitForInitialize();</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jika proyek akan menggunakan HangFire</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services, ObjectRepository objectRepository</span></span></span><span class="hljs-function">)</span></span> {  services.AddHangfire(s =&gt; s.UseHangfireStorage(objectRepository)); }</code> </pre> </div></div><br><p>  Sisipkan objek baru: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newParent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParentModel() repository.Add(newParent);</code> </pre> <br><p>  Dalam panggilan ini, objek <strong>ParentModel</strong> ditambahkan ke cache lokal dan ke antrian tulis ke database.  Oleh karena itu, operasi ini membutuhkan O (1), dan Anda dapat segera bekerja dengan objek ini. </p><br><p>  Misalnya, untuk menemukan objek ini di repositori dan memastikan bahwa objek yang dikembalikan adalah contoh yang sama: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parents = repository.Set&lt;ParentModel&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myParent = parents.Find(newParent.Id); Assert.IsTrue(ReferenceEquals(myParent, newParent));</code> </pre> <br><p>  Apa yang terjadi dengan ini?  <em>Setel &lt;ParentModel&gt; ()</em> mengembalikan <em>TableDictionary &lt;ParentModel&gt;</em> , yang berisi <em>ConcurrentDictionary &lt;ParentModel, ParentModel&gt;</em> dan menyediakan fungsionalitas tambahan untuk indeks primer dan sekunder.  Ini memungkinkan Anda memiliki metode untuk mencari berdasarkan ID (atau indeks kustom arbitrer lainnya) tanpa menyebutkan secara lengkap semua objek. </p><br><p>  Ketika objek ditambahkan ke <em>ObjectRepository</em> , langganan ditambahkan untuk mengubah propertinya, sehingga setiap perubahan properti juga menyebabkan objek ini ditambahkan ke antrian tulis. <br>  Memperbarui properti dari luar terlihat sama dengan bekerja dengan objek POCO: </p><br><pre> <code class="cs hljs">myParent.Children.First().Property = <span class="hljs-string"><span class="hljs-string">"Updated value"</span></span>;</code> </pre> <br><p>  Anda dapat menghapus objek dengan cara berikut: </p><br><pre> <code class="cs hljs">repository.Remove(myParent); repository.RemoveRange(otherParents); repository.Remove&lt;ParentModel&gt;(x =&gt; !x.Children.Any());</code> </pre> <br><p>  Ini juga menambahkan objek ke antrian hapus. </p><br><h2 id="kak-rabotaet-sohranenie">  Bagaimana cara kerja konservasi? </h2><br><p>  <em>ObjectRepository</em> ketika mengubah objek yang dilacak (baik menambah atau menghapus, dan mengubah properti) memunculkan peristiwa <em>ModelChanged</em> , yang <em>berlangganan IStorage</em> .  Implementasi <em>IStorage,</em> ketika peristiwa <em>ModelChanged</em> terjadi, <em>merangkum</em> perubahan dalam 3 antrian - tambah, perbarui, dan hapus. </p><br><p>  Juga, implementasi <em>IStorage</em> selama inisialisasi membuat timer yang setiap 5 detik menyebabkan perubahan disimpan. </p><br><p>  <em>Selain itu, ada API untuk memaksa panggilan save: <strong>ObjectRepository.Save ()</strong> .</em> </p><br><p>  Sebelum setiap penyimpanan, operasi pertama yang tidak berarti dihapus dari antrian (misalnya, acara duplikat - ketika suatu objek berubah dua kali atau penambahan / penghapusan cepat objek), dan hanya kemudian menyimpan itu sendiri. </p><br><p>  <em>Dalam semua kasus, seluruh objek dipertahankan, sehingga ada kemungkinan bahwa objek disimpan dalam urutan yang berbeda dari yang diubah, termasuk versi yang lebih baru dari objek daripada pada saat menambahkan ke antrian.</em> </p><br><h2 id="chto-est-eschyo">  Apa lagi yang ada di sana? </h2><br><ul><li>  Semua perpustakaan didasarkan pada .NET Standard 2.0.  Ini dapat digunakan dalam proyek .NET modern. </li><li>  API aman utas.  Koleksi internal didasarkan pada <em>ConcurrentDictionary</em> , pengendali acara memiliki kunci atau tidak memerlukannya. <br>  Satu-satunya hal yang perlu diingat adalah memanggil <em>ObjectRepository.Save ();</em> </li><li>  Indeks khusus (memerlukan keunikan): </li></ul><br><pre> <code class="cs hljs">repository.Set&lt;ChildModel&gt;().AddIndex(x =&gt; x.Value); repository.Set&lt;ChildModel&gt;().Find(x =&gt; x.Value, <span class="hljs-string"><span class="hljs-string">"myValue"</span></span>);</code> </pre> <br><h2 id="kto-eto-ispolzuet">  Siapa yang menggunakannya? </h2><br><p>  Secara pribadi, saya mulai menggunakan pendekatan ini dalam semua proyek hobi, karena itu nyaman, dan tidak memerlukan biaya besar untuk menulis lapisan akses data atau menggunakan infrastruktur yang berat.  Secara pribadi, sebagai aturan, menyimpan data dalam litedb atau dalam file biasanya cukup bagi saya. </p><br><p>  Tetapi di masa lalu, ketika EscapeTeams, startup yang terlambat, dibuat dengan tim (mereka <em>pikir itu adalah uang - tapi tidak, pengalaman lagi</em> ) - mereka menggunakan Azure Table Storage untuk menyimpan data. </p><br><h2 id="plany-na-buduschee">  Rencana masa depan </h2><br><p>  Saya ingin memperbaiki salah satu kelemahan utama dari pendekatan ini - penskalaan horizontal.  Untuk melakukan ini, Anda perlu salah satu transaksi terdistribusi (sic!), Atau membuat keputusan dengan tekad kuat bahwa data yang sama dari contoh berbeda tidak boleh berubah, atau biarkan mereka berubah sesuai dengan prinsip "siapa yang terakhir - itu benar." </p><br><p>  Dari sudut pandang teknis, saya melihat skema berikut ini mungkin: </p><br><ul><li>  Simpan EventLog dan Snapshot alih-alih model objek </li><li>  Temukan instance lain (tambahkan titik akhir dari semua instance? Penemuan Udp? Master / slave? Ke pengaturan) </li><li>  Replikasi antara instance EventLog melalui salah satu algoritma konsensus, seperti RAFT. </li></ul><br><p>  Ada juga masalah lain yang mengganggu saya - adalah penghapusan cascading, atau mendeteksi kasus menghapus objek yang dirujuk dari objek lain. </p><br><h2 id="ishodnyy-kod">  Kode sumber </h2><br><p>  Jika Anda membaca hingga sini - maka hanya kode yang harus dibaca, itu bisa saja <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditemukan di github</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452232/">https://habr.com/ru/post/id452232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452222/index.html">Menara telepon penerbangan, langkah berikutnya 5G</a></li>
<li><a href="../id452224/index.html">Panduan Cepat untuk Pengembang Web</a></li>
<li><a href="../id452226/index.html">Judulnya akan berbeda</a></li>
<li><a href="../id452228/index.html">Anna Boyarkina, Miro (sebelumnya RealtimeBoard): tentang pemikiran produk, budaya tim, keterampilan masa depan</a></li>
<li><a href="../id452230/index.html">Kami mempelajari dioda terowongan pada contoh 3I306M</a></li>
<li><a href="../id452234/index.html">Termometer & Hygrometer pada ATMEGA 328P-MU - Meningkatkan Level Pengembangan Arduino</a></li>
<li><a href="../id452236/index.html">Harmoni skrip di dalam aplikasi Android</a></li>
<li><a href="../id452240/index.html">Apa yang umum antara orgasme dan Wi-Fi</a></li>
<li><a href="../id452244/index.html">PHPUnit. Manajer Entitas Doktrin Menangis</a></li>
<li><a href="../id452246/index.html">Wawancara dengan Vitaly Bragilevsky: “Dunia di mana semua orang akan memprogram di Haskell bukan dunia yang baik”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>