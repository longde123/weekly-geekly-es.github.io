<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö™ üë©üèæ‚Äçüîß ‚ôìÔ∏è C√°lculo da canibaliza√ß√£o com base no teste A / B cl√°ssico e no m√©todo de autoinicializa√ß√£o üçõ ü•ò ‚ö†Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo discute um m√©todo para calcular a canibaliza√ß√£o de um aplicativo m√≥vel com base no teste A / B cl√°ssico. Nesse caso, as a√ß√µes-alvo s√£o con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√°lculo da canibaliza√ß√£o com base no teste A / B cl√°ssico e no m√©todo de autoinicializa√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451488/">  Este artigo discute um m√©todo para calcular a canibaliza√ß√£o de um aplicativo m√≥vel com base no teste A / B cl√°ssico.  Nesse caso, as a√ß√µes-alvo s√£o consideradas e avaliadas como parte do processo de redistribui√ß√£o de uma fonte de publicidade (Direct, Criteo, AdWords UAC e outras) em compara√ß√£o com as a√ß√µes-alvo no grupo em que o an√∫ncio foi desativado. <br><br>  O artigo fornece uma vis√£o geral dos m√©todos cl√°ssicos para comparar amostras independentes com uma breve base te√≥rica e uma descri√ß√£o das bibliotecas utilizadas, incluindo  descreve brevemente a ess√™ncia do m√©todo de inicializa√ß√£o e sua implementa√ß√£o na biblioteca do FaceBook Bootstrapped, bem como os problemas que surgem na pr√°tica ao aplicar essas t√©cnicas e como resolv√™-las. <br><a name="habracut"></a><br>  As evid√™ncias s√£o ofuscadas ou n√£o s√£o fornecidas para manter um acordo de n√£o divulga√ß√£o. <br><br>  No futuro, pretendo complementar e modificar levemente este artigo √† medida que novos fatos aparecerem, para que esta vers√£o possa ser considerada o primeiro lan√ßamento.  Ficaria muito grato pelos coment√°rios e cr√≠ticas. <br><br><h3>  1. Introdu√ß√£o </h3> <br>  Canibaliza√ß√£o √© o processo de fluxo de tr√°fego, completo e direcionado, de um canal para outro. <br><br>  Os profissionais de marketing geralmente usam esse indicador como um coeficiente K adicional no c√°lculo do CPA: o CPA calculado √© multiplicado por 1 + K.  Nesse caso, CPA significa o custo total de atra√ß√£o de tr√°fego / n√∫mero de a√ß√µes segmentadas que s√£o monetizadas diretamente, ou seja, que geraram lucro real - por exemplo, uma chamada direcionada e / ou monetizada indiretamente - por exemplo, aumentando o volume do banco de dados de an√∫ncios, aumentando o p√∫blico-alvo e assim por diante. <br><br>  Quando canais gratuitos (por exemplo, visitas de SERPs org√¢nicos, cliques em links em sites gratuitos para uso) s√£o canibalizados por pagos (direto, Adwords em vez de org√¢nicos, publicidade em feeds de redes sociais em vez de clicar em an√∫ncios, √© gratuito colocados em grupos e assim por diante), isso acarreta riscos de perda financeira; portanto, √© importante conhecer a taxa de canibaliza√ß√£o. <br><br>  No nosso caso, a tarefa era calcular a canibaliza√ß√£o de transi√ß√µes "org√¢nicas" para o aplicativo por transi√ß√µes da rede de publicidade da Criteo.  A vigil√¢ncia √© um dispositivo ou um uid de usu√°rio (GAID / ADVID e IDFA). <br><br><h3>  Prepara√ß√£o da experi√™ncia </h3><br>  Voc√™ pode preparar o p√∫blico para o experimento dividindo os usu√°rios na interface do sistema anal√≠tico do AdJust em grupos para isolar aqueles que ver√£o an√∫ncios de uma determinada rede de publicidade (amostra de controle) e aqueles que n√£o receber√£o an√∫ncios usando GAID ou ADVID e IDFA, respectivamente (O AdJust fornece a API do Construtor de p√∫blicos-alvo).  Em seguida, na amostra de controle, voc√™ pode incluir uma campanha publicit√°ria na rede de publicidade estudada no experimento. <br><br>  Observo por mim mesmo que, como parece intuitivamente, a seguinte implementa√ß√£o do experimento seria mais competente neste caso: selecionar quatro grupos - aqueles que tiveram o redirecionamento desativado de todos os canais (1), como o grupo experimental, e aqueles que tiveram somente redirecionamento ativado com Criteo (2);  aqueles que tiveram apenas o redirecionamento desativado com o Criteo (3), aqueles que tiveram todos os redirecionamentos (4) ativados.  Seria poss√≠vel calcular (1) / (2), tendo recebido o valor real de campanhas de canibaliza√ß√£o da rede Criteo para transi√ß√µes "org√¢nicas" para o aplicativo e (3) / (4), tendo recebido o Criteo de canibaliza√ß√£o no ambiente "natural" (afinal, a Criteo, obviamente tamb√©m pode canibalizar outros canais pagos).  O mesmo experimento deve ser repetido para outras redes de an√∫ncios, a fim de descobrir o impacto de cada uma delas;  em um mundo ideal, seria bom investigar a canibaliza√ß√£o cruzada entre todas as principais fontes pagas que comp√µem a maior participa√ß√£o no tr√°fego total, mas levaria muito tempo (tanto para preparar experimentos do ponto de vista de desenvolvimento quanto para avaliar os resultados), o que causaria cr√≠ticas por meticulosidade irracional. <br><br>  De fato, nosso experimento foi realizado nas condi√ß√µes (3) e (4), as amostras foram divididas na propor√ß√£o de 10% a 90%, o experimento foi realizado por 2 semanas. <br><br><h3>  Prepara√ß√£o e verifica√ß√£o de dados </h3><br>  Antes de iniciar qualquer estudo, uma etapa importante √© o pr√©-treinamento e a limpeza de dados competentes. <br><br>  Note-se que, de fato, os dispositivos ativos para o per√≠odo experimental foram 2 vezes menos (42,5% e 50% dos grupos controle e experimental, respectivamente) do que os dispositivos nas amostras iniciais completas, o que √© explicado pela natureza dos dados: <br><br><ol><li>  Em primeiro lugar (e esse √© o principal motivo), a sele√ß√£o para redirecionar do Adjust cont√©m os identificadores de todos os dispositivos que j√° instalaram o aplicativo, ou seja, aqueles que n√£o est√£o mais em uso e aqueles com os quais o aplicativo j√° estava exclu√≠do </li><li>  segundo, n√£o √© necess√°rio que todos os dispositivos tenham feito login no aplicativo durante o experimento. </li></ol><br>  No entanto, calculamos a canibaliza√ß√£o com base nos dados de uma amostra completa.  Para mim, pessoalmente, a corre√ß√£o de tal c√°lculo ainda parece um ponto discut√≠vel - em geral, na minha opini√£o, √© mais correto limpar todos aqueles que desinstalaram o aplicativo e n√£o o instalaram pelas tags correspondentes, bem como aqueles que n√£o fazem login no aplicativo h√° mais de um ano - esse per√≠odo de tempo em que o usu√°rio pode alterar o dispositivo;  menos - dessa forma, para o experimento, os usu√°rios que n√£o mudaram para o aplicativo, mas puderam faz√™-lo, poderiam ser removidos da sele√ß√£o se mostr√°ssemos an√∫ncios na rede Criteo.  Quero observar que, em um mundo bom, todas essas neglig√™ncias e suposi√ß√µes for√ßadas devem ser investigadas e verificadas separadamente, mas vivemos em um mundo r√°pido e furioso. <br><br>  No nosso caso, √© importante verificar os seguintes pontos: <br><br><ol><li>  Verificamos a interse√ß√£o em nossas amostras iniciais - experimental e controle.  Em um experimento implementado corretamente, essas interse√ß√µes n√£o devem ser, no entanto, no nosso caso, houve v√°rias duplicatas da amostra experimental no controle.  No nosso caso, a participa√ß√£o dessas duplicatas no volume total de dispositivos envolvidos no experimento foi pequena e, portanto, negligenciamos essa condi√ß√£o.  Se houver&gt; 1% de duplicatas, o experimento deve ser considerado incorreto e um segundo experimento deve ser realizado, ap√≥s a limpeza pr√©via dos duplicados. </li><li>  Verificamos que os dados do experimento foram realmente afetados - o redirecionamento deve ser desativado na amostra experimental (pelo menos com o Criteo, no experimento definido corretamente - de todos os canais); portanto, √© necess√°rio verificar a aus√™ncia de DeviceID do experimento no redirecionamento com o Criteo.  No nosso caso, o DeviceID do grupo experimental, no entanto, caiu no redirecionamento, mas havia menos de 1%, o que √© insignificante. </li></ol><br><h3>  Avalia√ß√£o direta do experimento </h3><br>  Consideraremos a altera√ß√£o nas seguintes m√©tricas de destino: absoluto - o n√∫mero de chamadas e relativo - o n√∫mero de chamadas por usu√°rio nos grupos de controle (an√∫ncios vistos na rede Criteo) e experimental (an√∫ncios foram desativados).  No c√≥digo abaixo, os dados vari√°veis ‚Äã‚Äãreferem-se √† estrutura pandas.DataFrame, formada a partir dos resultados de uma amostra experimental ou de controle. <br><br>  Existem m√©todos param√©tricos e n√£o param√©tricos para avaliar a signific√¢ncia estat√≠stica da diferen√ßa de valores em amostras n√£o relacionadas.  Os crit√©rios de avalia√ß√£o param√©trica fornecem maior precis√£o, mas t√™m limita√ß√µes em sua aplica√ß√£o - em particular, uma das principais condi√ß√µes √© que os valores medidos para as observa√ß√µes na amostra sejam distribu√≠dos normalmente. <br><br><h4>  1. O estudo da distribui√ß√£o de valores nas amostras para normalidade </h4><br>  A primeira etapa √© examinar as amostras existentes para o tipo de distribui√ß√£o de valores e a igualdade das varia√ß√µes das amostras usando testes padr√£o - os crit√©rios Kolmogorov-Smirnov e Shapiro-Wilks e o teste de Bartlett implementado na biblioteca sklearn.stats, assumindo p-value = 0.05: <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    : def norm_test(df, pvalue = 0.05, test_name = 'kstest'): if test_name == 'kstest': st = stats.kstest(df, 'norm') if test_name == 'shapiro': st = stats.shapiro(df) sys.stdout.write('According to {} {} is {}normal\n'.format(test_name, df.name, {True:'NOT ', False:''}[st[1] &lt; pvalue])) #    : def barlett_test(df1, df2, pvalue = 0.05): st = stats.bartlett(df1, df2) sys.stdout.write('Variances of {} and {} is {}equals\n'.format(df1.name, df2.name, {True:'NOT ', False:''}[st[1] &lt; pvalue]))</span></span></code> </pre> <br>  Al√©m disso, para uma avalia√ß√£o visual dos resultados, voc√™ pode usar a fun√ß√£o histograma. <br><br><pre> <code class="python hljs">data_agg = data.groupby([<span class="hljs-string"><span class="hljs-string">'bucket'</span></span>]).aggregate({<span class="hljs-string"><span class="hljs-string">'device_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'nunique'</span></span>, <span class="hljs-string"><span class="hljs-string">'calls'</span></span>: <span class="hljs-string"><span class="hljs-string">'sum'</span></span>}).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) data_conv = data_agg[<span class="hljs-string"><span class="hljs-string">'calls_auto'</span></span>]/data_agg[<span class="hljs-string"><span class="hljs-string">'device_id'</span></span>] data_conv.hist(bins=<span class="hljs-number"><span class="hljs-number">20</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/8m/zc/u4/8mzcu4-emautrimdpvczuttfkf8.png" alt="imagem"><br><br>  Voc√™ pode ler o histograma assim: 10 vezes na amostra houve uma convers√£o de 0,08, 1 - 0,14.  Isso n√£o diz nada sobre o n√∫mero de dispositivos como observa√ß√µes para qualquer um dos indicadores de convers√£o. <br><br>  No nosso caso, a distribui√ß√£o do valor do par√¢metro em valores absolutos e em relativo (o n√∫mero de chamadas para o dispositivo) nas amostras n√£o √© normal. <br>  Nesse caso, voc√™ pode usar o teste n√£o param√©trico de Wilcoxon implementado na biblioteca sklearn.stats padr√£o ou tentar trazer a distribui√ß√£o de valores nas amostras para a forma normal e aplicar um dos crit√©rios param√©tricos - teste t de Student ou teste de Shapiro-Wilks. <br><br><h4>  2. M√©todos para reduzir a distribui√ß√£o dos valores nas amostras para a forma normal </h4><br>  <b>2.1</b>  <b>Sub-buckets</b> <br><br>  Uma abordagem para trazer a distribui√ß√£o ao normal √© o m√©todo sub-bucket.  Sua ess√™ncia √© simples, e a seguinte tese matem√°tica √© a base te√≥rica: de acordo com o teorema cl√°ssico do limite central, a distribui√ß√£o das m√©dias tende a normal - a soma de n vari√°veis ‚Äã‚Äãaleat√≥rias independentes distribu√≠das identicamente tem uma distribui√ß√£o pr√≥xima do normal e, de forma equivalente, a distribui√ß√£o das m√©dias amostrais da primeira n aleat√≥ria independente distribu√≠da identicamente quantidades tende ao normal.  Portanto, podemos dividir os buckets existentes em sub-bucket'y e, consequentemente, considerando os valores m√©dios de sub-bucket'y para cada um dos bucket'ov, podemos obter uma distribui√ß√£o quase normal: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   subbucket' data['subbucket'] = data['device_id'].apply(lambda x: randint(0,1000)) # Variant 1 data['subbucket'] = data['device_id'].apply(lambda x: hash(x)%1000) # Variant 2</span></span></code> </pre> <br>  Pode haver muitas op√ß√µes para dividir, tudo depende da imagina√ß√£o e dos princ√≠pios morais do desenvolvedor - voc√™ pode coletar aleatoriamente honestamente ou usar o hash do balde original, levando em considera√ß√£o o mecanismo de emiss√£o no esquema. <br><br>  No entanto, na pr√°tica, de v√°rias dezenas de lan√ßamentos de c√≥digo, recebemos a distribui√ß√£o normal apenas uma vez, ou seja, esse m√©todo n√£o √© garantido nem est√°vel. <br><br>  Al√©m disso, a propor√ß√£o de a√ß√µes de destino e usu√°rios em rela√ß√£o ao n√∫mero total de a√ß√µes e usu√°rios no subconjunto pode n√£o ser consistente com os backets iniciais, portanto, voc√™ deve primeiro verificar se a propor√ß√£o √© mantida. <br><br><pre> <code class="python hljs">data[data[<span class="hljs-string"><span class="hljs-string">'calls'</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>].device_id.nunique()/data.device_id.nunique() <span class="hljs-comment"><span class="hljs-comment"># Total buckets = data.groupby(['bucket']).aggregate({'device_id': 'nunique', 'calls': 'sum'}) buckets[buckets['calls'] &gt; 0].device_id.nunique()/buckets.device_id.nunique() # Buckets subbuckets = data.groupby(['subbucket']).aggregate({'device_id': 'nunique', 'calls': 'sum'}) subbuckets[subbuckets['calls'] &gt; 0].device_id.nunique()/subbuckets.device_id.nunique() # Subbuckets</span></span></code> </pre> <br>  No processo dessa verifica√ß√£o, descobrimos que as taxas de convers√£o para sub-baldes em rela√ß√£o √† sele√ß√£o original n√£o s√£o preservadas.  Como precisamos garantir adicionalmente a consist√™ncia da taxa de compartilhamento de chamadas nas amostras de sa√≠da e de origem, usamos o balanceamento de classe, adicionando pondera√ß√£o para que os dados sejam selecionados separadamente por subgrupos: separadamente de observa√ß√µes com a√ß√µes de destino e separadamente de observa√ß√µes sem a√ß√µes de destino na propor√ß√£o correta.  Al√©m disso, no nosso caso, as amostras foram distribu√≠das de maneira desigual;  intuitivamente, parece que a m√©dia n√£o deve mudar, mas como a n√£o uniformidade das amostras afeta a varia√ß√£o n√£o √© √≥bvia a partir da f√≥rmula de dispers√£o.  Para esclarecer se a diferen√ßa no tamanho das amostras afeta o resultado, √© utilizado o crit√©rio Xi-quadrado - se for detectada uma diferen√ßa estatisticamente significativa, ser√° amostrado um quadro de dados maior com um tamanho menor: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class_arrays_balancer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df1, df2, target = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'calls'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, pvalue=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.05</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> df1_target_size = len(df1[df1[target] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>]) print(df1.columns.to_list()) df2_target_size = len(df2[df2[target] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>]) total_target_size = df1_target_size + df2_target_size chi2_target, pvalue_target, dof_target, expected_target = chi2_contingency([[df1_target_size, total_target_size], [df2_target_size, total_target_size]]) df1_other_size = len(df1[df1[target] == <span class="hljs-number"><span class="hljs-number">0</span></span>]) df2_other_size = len(df1[df1[target] == <span class="hljs-number"><span class="hljs-number">0</span></span>]) total_other_size = df1_other_size + df2_other_size chi2_other, pvalue_other, dof_other, expected_other = chi2_contingency([[df1_other_size, total_other_size], [df2_other_size, total_other_size]]) df1_target, df2_target, df1_other, df2_other = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pvalue_target &lt; pvalue: sample_size = min([df1_target_size, df2_target_size]) df1_rnd_indx = np.random.choice(df1_target_size, size=sample_size, replace=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) df2_rnd_indx = np.random.choice(df2_target_size, size=sample_size, replace=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) df1_target = pd.DataFrame((np.asarray(df1[df1[target] == <span class="hljs-number"><span class="hljs-number">1</span></span>])[df1_rnd_indx]).tolist(), columns = df1.columns.tolist()) df2_target = pd.DataFrame((np.asarray(df2[df2[target] == <span class="hljs-number"><span class="hljs-number">1</span></span>])[df2_rnd_indx]).tolist(), columns = df2.columns.tolist()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p_value_other &lt; pvalue: sample_size = min([df1_other_size, df2_other_size]) df1_rnd_indx = np.random.choice(df1_other_size, size=sample_size, replace=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) df2_rnd_indx = np.random.choice(df2_other_size, size=sample_size, replace=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) df1_other = pd.DataFrame((np.asarray(df1[df1[target] == <span class="hljs-number"><span class="hljs-number">0</span></span>])[df1_rnd_indx]).tolist(), columns = df1.columns.tolist()) df2_other = pd.DataFrame((np.asarray(df2[df2[target] == <span class="hljs-number"><span class="hljs-number">0</span></span>])[df2_rnd_indx]).tolist(), columns = df2.columns.tolist()) df1 = pd.concat([df1_target, df1_other]) df2 = pd.concat([df2_target, df2_other]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df1, df2 exp_classes, control_classes = class_arrays_balancer(data_exp, data_control)</code> </pre> <br>  Na sa√≠da, obtemos dados balanceados em tamanho e consistentes com as taxas de convers√£o iniciais, as m√©tricas estudadas (calculadas para valores m√©dios para sub-bucket) nas quais elas j√° est√£o distribu√≠das normalmente, que podem ser vistas visualmente e pelos resultados da aplica√ß√£o dos crit√©rios de teste j√° conhecidos por n√≥s. normalidade (com valor-p&gt; = 0,05).  Por exemplo, para indicadores relativos: <br><br><pre> <code class="python hljs">data_conv = (data[data[<span class="hljs-string"><span class="hljs-string">'calls'</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>].groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).calls.sum()*<span class="hljs-number"><span class="hljs-number">1.0</span></span>/data.groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).device_id.nunique()) data_conv.hist(bins = <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br>  Agora, o teste t pode ser aplicado √† m√©dia sobre os sub-buckets (portanto, n√£o √© device_id, n√£o √© um dispositivo, mas um sub-bucket que atua como uma observa√ß√£o). <br><br>  Depois de garantir que as mudan√ßas sejam estatisticamente significativas, podemos, com a consci√™ncia limpa, fazer o que come√ßamos: calcular a canibaliza√ß√£o: <br><br><pre> <code class="python hljs">(data_exp.groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).calls.avg() - data_cntrl.groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).calls.avg() )/ data_exp.groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).calls.avg()</code> </pre> <br>  O denominador deve ser tr√°fego sem an√∫ncios, ou seja, experimental. <br><br><h4>  3. M√©todo de Bootstrap </h4><br>  O m√©todo bootstrap √© uma extens√£o do m√©todo sub-bucket e representa sua vers√£o mais avan√ßada e aprimorada;  uma implementa√ß√£o de software desse m√©todo em Python pode ser encontrada na biblioteca de inicializa√ß√£o do Facebook. <br>  Resumidamente, a ideia de bootstrap pode ser descrita da seguinte maneira: um m√©todo nada mais √© do que um construtor de amostras geradas de maneira semelhante aos m√©todos de sub-bucket aleatoriamente, mas com poss√≠veis repeti√ß√µes.  Podemos dizer a coloca√ß√£o da popula√ß√£o em geral (se √© que se pode chamar a amostra original) com o retorno.  Na sa√≠da, as m√©dias (ou medianas, quantidades, etc.) s√£o formadas a partir das m√©dias para cada uma das subamostras geradas. <br><br>  <i>Os principais m√©todos da biblioteca do FaceBook Bootstrap</i> : <br><pre> <code class="python hljs">bootstrap()</code> </pre>  - implementa um mecanismo para a forma√ß√£o de subamostras;  retorna limite inferior (percentil 5) e limite superior (percentil 95) por padr√£o;  para retornar uma distribui√ß√£o discreta nesse intervalo, voc√™ deve definir o par√¢metro <i>return_distribution = True</i> (√© gerado pela fun√ß√£o auxiliar <i>generate_distributions ()</i> ). <br><br>  Voc√™ pode especificar o n√∫mero de itera√ß√µes usando o par√¢metro <i>num_iterations</i> , no qual as subamostras ser√£o geradas, e o n√∫mero de subamostras <i>iteration_batch_size</i> para cada itera√ß√£o.  Na sa√≠da de <i>generate_distributions ()</i> , uma amostra ser√° gerada com um tamanho igual ao n√∫mero de itera√ß√µes <i>num_iterations</i> , <i>cujos</i> elementos ser√£o a m√©dia dos valores das amostras de <i>iteration_batch_size</i> calculadas em cada itera√ß√£o.  Com grandes volumes de amostras, os dados podem n√£o caber mais na mem√≥ria; portanto, nesses casos, √© aconselh√°vel reduzir o valor de <i>iteration_batch_size</i> . <br><br>  <i>Exemplo</i> : deixe a amostra original ser 2.000.000;  <i>num_iterations</i> = 10.000, <i>iteration_batch_size</i> = 300. Em cada uma das 10.000 itera√ß√µes, 300 listas de 2.000.000 de itens ser√£o armazenadas na mem√≥ria. <br><br>  A fun√ß√£o tamb√©m permite a computa√ß√£o paralela em v√°rios n√∫cleos do processador, em v√°rios threads, configurando o n√∫mero necess√°rio usando o par√¢metro <i>num_threads</i> . <br><br><pre> <code class="python hljs">bootstrap_ab()</code> </pre> <br>  executa as mesmas a√ß√µes que a fun√ß√£o <i>bootstrap ()</i> descrita acima, no entanto, al√©m disso, a agrega√ß√£o de valores m√©dios tamb√©m √© executada pelo m√©todo especificado em <i>stat_func</i> - a partir dos valores de <i>num_iterations</i> .  A seguir, a m√©trica especificada no par√¢metro compare_func √© calculada e a signific√¢ncia estat√≠stica √© estimada. <br><br><pre> <code class="python hljs">compare_functions</code> </pre> <br>  - uma classe de fun√ß√µes que fornece ferramentas para a forma√ß√£o de m√©tricas para avalia√ß√£o: <br><pre> <code class="python hljs">compare_functions.difference() compare_functions.percent_change() compare_functions.ratio() compare_functions.percent_difference() <span class="hljs-comment"><span class="hljs-comment"># difference = (test_stat - ctrl_stat) # percent_change = (test_stat - ctrl_stat) * 100.0 / ctrl_stat # ratio = test_stat / ctrl_stat # percent_difference = (test_stat - ctrl_stat) / ((test_stat + ctrl_stat) / 2.0) * 100.0</span></span></code> </pre> <br><pre> <code class="python hljs">stats_functions</code> </pre>  - uma classe de fun√ß√µes a partir da qual o m√©todo de agrega√ß√£o da m√©trica estudada √© selecionado: <br><pre> <code class="python hljs">stats_functions.mean stats_functions.sum stats_functions.median stats_functions.std</code> </pre> <br>  Como <i>stat_func,</i> voc√™ pode usar uma fun√ß√£o personalizada definida pelo usu√°rio, por exemplo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(test_stat, ctrl_stat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (test_stat - ctrl_stat)/test_stat bs.bootstrap_ab(test.values, control.values, stats_functions.mean, test_func, num_iterations=<span class="hljs-number"><span class="hljs-number">5000</span></span>, alpha=<span class="hljs-number"><span class="hljs-number">0.05</span></span>, iteration_batch_size=<span class="hljs-number"><span class="hljs-number">100</span></span>, scale_test_by=<span class="hljs-number"><span class="hljs-number">1</span></span>, num_threads=<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br>  De fato, <i>(test_stat - ctrl_stat) / test_stat</i> √© a f√≥rmula para calcular nossa canibaliza√ß√£o. <br><br>  Como alternativa, ou com a finalidade de um experimento pr√°tico, voc√™ pode obter inicialmente distribui√ß√µes usando o <i>bootstrap ()</i> , verificar a signific√¢ncia estat√≠stica das diferen√ßas nas m√©tricas de destino usando o teste t e aplicar as manipula√ß√µes necess√°rias a elas. <br>  Um exemplo de como a distribui√ß√£o normal de "qualidade" pode ser obtida usando este m√©todo: <br><br><img src="https://habrastorage.org/webt/pc/is/ws/pciswsulv_wuinbcqkn-hgmluwe.png"><br><br>  Documenta√ß√£o mais detalhada pode ser encontrada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√°gina do reposit√≥rio</a> . <br><br>  No momento, isso √© tudo sobre o que eu queria (ou consegui) falar.  Tentei descrever brevemente, mas claramente, os m√©todos usados ‚Äã‚Äãe o processo de sua implementa√ß√£o.  √â poss√≠vel que as metodologias exijam ajustes, por isso serei grato por coment√°rios e cr√≠ticas. <br><br>  Tamb√©m quero agradecer aos meus colegas por sua ajuda na prepara√ß√£o deste trabalho.  Se o artigo receber feedback predominantemente positivo, indicarei aqui seus nomes ou apelidos (mediante acordo pr√©vio). <br><br>  Muitas felicidades a todos!  :) <br><br>  PS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Caro canal do campeonato</a> , a tarefa de avaliar os resultados dos testes A / B √© uma das mais importantes em ci√™ncia de dados, porque nem um lan√ßamento de um novo modelo de ML na produ√ß√£o est√° completo sem A / B.  Talvez seja hora de organizar uma competi√ß√£o para desenvolver um sistema para avaliar os resultados dos testes A / B?  :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt451488/">https://habr.com/ru/post/pt451488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt451468/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 364 (6 a 12 de maio de 2019)</a></li>
<li><a href="../pt451476/index.html">LLVM em termos de Go</a></li>
<li><a href="../pt451478/index.html">Acelerando a explora√ß√£o de dados usando a biblioteca de cria√ß√£o de perfil de pandas</a></li>
<li><a href="../pt451480/index.html">Por que o Minist√©rio da Ind√∫stria e Com√©rcio pro√≠be o armazenamento de dados em equipamentos estrangeiros</a></li>
<li><a href="../pt451482/index.html">Compet√™ncias de um programador moderno de um √¢ngulo diferente</a></li>
<li><a href="../pt451492/index.html">Sete vari√°veis ‚Äã‚Äãinesperadas do bash</a></li>
<li><a href="../pt451496/index.html">Mitap Netologii ‚ÄúCarreiras em ci√™ncia de dados para iniciantes‚Äù</a></li>
<li><a href="../pt451498/index.html">Food Design Digest, abril de 2019</a></li>
<li><a href="../pt451502/index.html">Eventos digitais em Moscou, de 13 a 19 de maio</a></li>
<li><a href="../pt451504/index.html">Fotos na web 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>