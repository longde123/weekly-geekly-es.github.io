<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏽 🏇🏽 🙆🏼 CSS overflow dan kehilangan data 🧚🏼 🧑🏾‍🤝‍🧑🏼 📓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini, Rachel Andrew membahas situasi di mana Anda dapat mengalami overflow dalam tata letak situs, dan menjelaskan bagaimana CSS berevolu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CSS overflow dan kehilangan data</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466665/"><img src="https://habrastorage.org/webt/uf/5c/f-/uf5cf-rpyucmvhnx58fj9xrwsec.jpeg"><br>  Dalam artikel ini, Rachel Andrew membahas situasi di mana Anda dapat mengalami overflow dalam tata letak situs, dan menjelaskan bagaimana CSS berevolusi untuk menciptakan metode tata letak yang lebih efisien dalam situasi di mana volume konten tidak diketahui sebelumnya. <br><a name="habracut"></a><br><hr><br>  CSS telah dirancang untuk membuat konten dapat dibaca.  Jika Anda melihat dokumen HTML yang ditandai dengan heading dan paragraf (tanpa CSS), itu ditampilkan di browser dalam bentuk yang mudah dibaca.  Judulnya besar dan tebal, dan di antara paragraf ada ruang yang dikendalikan oleh style sheet yang tertanam di browser.  Namun, segera setelah Anda perlu mengubah tata letak halaman, Anda akan mulai mengambil kendali desain ke tangan Anda sendiri.  Dalam beberapa situasi, ini berarti Anda mengambil alih pekerjaan dengan elemen-elemen yang berlebihan. <br><br>  Dalam artikel ini, saya akan mempertimbangkan berbagai situasi di mana kita mungkin mengalami overflow di web.  Kita akan melihat bagaimana metode markup baru dan nilai-nilai CSS baru dapat membantu kita menangani luapan dan membuat desain yang kurang rapuh.  Saya juga akan menjelaskan salah satu konsep dasar yang mendasari desain CSS - mencegah kehilangan data. <br><br><h2>  Apa yang kita maksud dengan melimpah? </h2><br>  Jika Anda kembali beberapa tahun (sebelum munculnya metode tata letak seperti Flexbox dan Grid), pikirkan bagaimana Anda akan menerapkan contoh yang ditunjukkan di bawah ini.  Tata letak yang sangat sederhana dari tiga blok memiliki jumlah konten yang berbeda, tetapi batas bawahnya harus berada pada baris yang sama. <br><br><img src="https://habrastorage.org/webt/gt/vf/hg/gtvfhgx4qssj5ipb-epo-alqk-o.jpeg"><br><br>  Menggunakan float, tugas yang tampaknya sederhana ini tidak mungkin.  Ketika sebuah blok menjadi efisien (mengambang), ia tidak berinteraksi dengan tetangganya;  ini berarti bahwa tidak ada cara untuk mengetahui elemen apa yang lebih tinggi dan meningkatkan arus ke ketinggian yang sama. <br><br><img src="https://habrastorage.org/webt/za/_y/i3/za_yi3eklarqeo31uherxd4i-fu.jpeg"><br><br>  Terkadang, mencoba untuk meluruskan elemen dalam satu baris, pengembang menetapkan ketinggian blok tetap, mencoba memprediksi jumlah konten yang mungkin untuk membuat ketinggiannya sama.  Tentu saja, web tidak begitu sederhana, dan ketika jumlah konten berbeda, atau ukuran teks menjadi lebih besar, teks mulai melampaui bagian bawah blok.  Ini meluap. <br><br><img src="https://habrastorage.org/webt/e3/6w/jq/e36wjqxw2vqxnfejadqygan3iuk.jpeg"><br><br>  Terkadang orang bertanya bagaimana mereka dapat mencegah terlalu banyak konten dari mencapai situs.  Dukungan teknis dari CMS saya dihubungi oleh pengguna yang bertanya bagaimana membatasi konten karena alasan ini.  Mereka mengatakan bahwa konten tambahan ini "merusak tata letak".  Bagi kita yang mengerti bahwa ketidakmungkinan mengetahui ketinggian elemen adalah sifat dasar dari tata letak, mereka memaksa kita untuk membuat tata letak yang menyembunyikan ketiadaan balok dengan ketinggian yang sama.  Solusi umum adalah menambahkan gradien dengan efek menghilangnya konten yang melampaui batas.  Kami akan menghindari menggunakan warna latar belakang dan bingkai blok.  Atau kita akan menggunakan teknik kolom buatan untuk membuat ketinggian elemen sama. <br><br>  Ketidakmampuan untuk mengontrol ketinggian satu elemen relatif terhadap yang lain, oleh karena itu, mempengaruhi desain web - batasan teknis mengubah cara situs web dirancang.  Saya senang bahwa dengan munculnya Flexbox dan Grid, masalah ini tidak hanya menghilang, tetapi secara default, perilaku metode tata letak baru ini membentang blok ke ketinggian yang sama.  Nilai awal properti <code>align-items - stretch</code> , karena blok diregangkan ke ketinggian Grid-area atau Flex-container. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/rachelandrew/embed/preview/VwZzxjV" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Selain itu, CSS Grid memberi kita cara yang baik untuk memberikan elemen ukuran tertentu, tetapi memungkinkan mereka untuk tumbuh jika mereka membutuhkannya.  Jika Anda mengatur ukuran trek (kolom atau garis) menggunakan fungsi minmax (), Anda dapat melihat ukuran minimum dan maksimumnya.  Mengatur garis ke <code>minmax(200px, auto)</code> berarti trek akan selalu setidaknya 200px, bahkan jika elemen grid kosong.  Namun, jika konten elemen grid lebih dari 200px, berkat nilai <code>auto</code> elemen ini dapat tumbuh.  Anda dapat melihatnya pada contoh di bawah ini.  Baris pertama adalah 200px, karena tidak ada elemen untuk meningkatkannya.  Baris kedua berisi elemen grid, yang isinya tidak cocok dan nilai <code>auto</code> mulai berfungsi, karena garis menjadi lebih besar dari 200px. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/rachelandrew/embed/preview/zYOdjKP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Fungsi <code>minmax()</code> memberi Anda kemampuan untuk membuat antarmuka seolah-olah mereka adalah ukuran tetap yang sempurna.  Di dunia yang ideal (ketika jumlah konten memenuhi harapan), Anda mendapatkan garis yang indah dan identik ini.  Namun, jika Anda menambahkan konten tambahan, tidak akan ada overflow, seolah-olah Anda mengatur tinggi saluran tetap ke 200px.  String akan mengembang;  itu mungkin tidak persis apa yang Anda, sebagai pengembang, inginkan, tetapi itu tidak akan terbaca. <br><br><h2>  Line overflow </h2><br>  Risiko luapan terjadi setiap kali kita membatasi ukuran elemen.  Dalam contoh di atas, saya menggambarkan batasan dalam dimensi blok yang akan dirasakan oleh pengguna dengan bahasa horizontal sebagai ketinggian.  Namun, kita juga bisa mendapatkan luapan jika kita membatasi lebar blok.  Ini yang kita lihat di CSS adalah meme Luar Biasa. <br><br><img src="https://habrastorage.org/webt/uf/5c/f-/uf5cf-rpyucmvhnx58fj9xrwsec.jpeg"><br><br>  Penulis meme ini mengomentari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos CSS-Trick</a> tentang ini, dengan mengatakan: <br><blockquote>  <i>Sekarang saya memahami konsep melimpah sedikit lebih baik, tetapi pada saat itu otak saya hanya terpesona oleh ketidakpahaman mengapa seseorang berpikir bahwa perilaku default seharusnya hanya mendorong teks ke kanan blok, daripada membuat blok lebih besar, seperti tabel selalu lakukan .</i> <br></blockquote>  Jadi mengapa CSS mendorong teks di luar kotak daripada meningkatkan ukuran blok itu sendiri? <br><br>  Dalam meme, limpahan dalam arah garis diperoleh.  Kata "luar biasa" lebih besar daripada lebar yang diterapkan pada blok, itulah sebabnya ia meluap.  CSS secara wajar mengasumsikan bahwa jika Anda memberikan blok dengan lebar tertentu, Anda membutuhkan blok dengan lebar hanya itu.  Mungkin dia harus meletakkan tata letak yang pecah jika balok tiba-tiba menjadi lebih besar dari apa yang ditetapkan. <br><br>  Masalah khusus ini (yaitu, kebutuhan untuk mengatur dimensi untuk semua elemen tata letak dan memastikan bahwa mereka tidak melebihi total ruang kontainer yang tersedia) adalah masalah yang diselesaikan oleh metode tata letak modern untuk kita.  Jika kami membayangkan bahwa blok kami memiliki ukuran yang dipilih secara khusus agar sesuai dalam satu baris dengan blok lain dalam float grid, hari ini Anda dapat memilih untuk menggunakan Flexbox. <br><br>  Menggunakan tata letak float, Anda harus mengatur ukuran setiap elemen - mungkin sebelum Anda tahu apa isinya.  Dalam hal ini, Anda mungkin menemukan bahwa konten besar akan berada dalam wadah kecil, dan konten kecil akan memiliki ruang tambahan. <br><br><img src="https://habrastorage.org/webt/dw/1k/um/dw1kumj10p4gf265pnrdc2htg9g.jpeg"><br><br>  Namun, jika kita menggunakan Flexbox, kita dapat membiarkan browser menghitung berapa banyak ruang yang diberikan untuk setiap elemen.  Flexbox akan menyediakan item yang lebih besar dengan lebih banyak ruang, sementara yang lebih kecil akan mendapatkan lebih sedikit.  Distribusi ukuran yang fleksibel ini berarti bahwa blok yang berisi kata "luar biasa" akan meningkat untuk mengakomodasi semua konten dan teks tidak akan melampauinya.  Masalah overflow diselesaikan;  perilaku ini persis seperti apa Flexbox dibuat.  Flexbox melakukan pekerjaan yang hebat dengan elemen-elemen dengan ukuran yang berbeda dan mengaturnya ke dalam tata letak yang paling tepat untuk mereka. <br><br><img src="https://habrastorage.org/webt/j6/cg/vp/j6cgvpadsslenylgg_cew86amya.jpeg"><br><br>  Di luar Flexbox, kita dapat mengatakan bahwa blok kita harus sebesar yang diperlukan untuk konten dan tidak lebih.  Kata kunci konten-min dapat digunakan sebagai nilai untuk properti ukuran lebar atau inline saat bekerja dengan properti logis yang terkait dengan aliran.  Setel lebar: min-konten dan blok akan tumbuh cukup untuk mengakomodasi kata "luar biasa". <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/rachelandrew/embed/preview/LYPjmbJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Pencegahan kehilangan data </h2><br>  Alasan blok meluap (seperti dalam contoh dengan kata yang melampaui batas blok) adalah karena properti <code>overflow</code> memiliki nilai default yang <code>visible</code> .  Anda dapat (jika mau) mengendalikan overflow dengan cara yang berbeda.  Misalnya, menggunakan <code>overflow: auto</code> atau <code>overflow: scroll</code> dapat memberikan blok Anda bilah gulir.  Ini mungkin bukan yang Anda inginkan dalam situasi ini, tetapi mungkin ada situasi di mana blok dengan bilah gulir akan sesuai. <br><br>  Anda juga dapat berasumsi bahwa Anda siap untuk memotong overflow menggunakan <code>overflow: hidden</code> .  Anda mungkin berpikir bahwa menyembunyikan overflow akan lebih baik secara default, namun, fakta bahwa CSS memilih untuk membuat overflow terlihat secara default (daripada disembunyikan) adalah kunci nilai inti dari pengembangan CSS.  Dalam CSS (seperti pada banyak teknologi lainnya), kami berusaha menghindari kehilangan data.  Ketika kita berbicara tentang kehilangan data dalam CSS, kita biasanya berbicara tentang bagian dari konten yang tidak akan terlihat.  Dalam kasus <code>overflow: hidden</code> , konten yang meluap blok induk menghilang.  Ini berarti bahwa kita tidak memiliki cara untuk sampai ke sana, untuk mengetahui bagian apa yang hilang. <br><br>  Dalam situasi tertentu, ini bisa menjadi masalah serius.  Jika Anda berhasil membuat tata letak sangat rapuh sehingga tombol pada formulir Anda melampaui area yang terlihat, pengguna Anda tidak akan dapat mengirimkan formulir.  Jika paragraf terakhir dari teks terputus, kita tidak akan pernah tahu bagaimana cerita berakhir.  Juga, masalah dengan elemen yang hilang adalah bahwa tidak selalu jelas bahwa mereka hilang.  Sebagai pengembang, Anda mungkin tidak melihat masalah, terutama jika ini hanya terjadi pada ukuran area tampilan tertentu dalam desain responsif.  Pengguna Anda mungkin tidak melihat masalah - mereka tidak akan melihat ajakan untuk bertindak, atau mereka akan berpikir bahwa masalah di mana mereka tidak dapat melakukan pemesanan ada di perangkat mereka dan mereka pergi begitu saja.  Namun, jika elemen meluap di tempat yang seharusnya tidak, Anda kemungkinan besar akan melihat ini.  Atau, dalam skenario terburuk, seseorang yang mengunjungi situs akan memperhatikan ini dan memberi tahu Anda. <br><br>  Itu sebabnya elemen CSS meluap ceroboh dan cukup terlihat.  Dengan melihat secara eksplisit overflow, Anda lebih cenderung memperbaiki kesalahan daripada jika konten berlebih disembunyikan.  Namun, dengan bantuan properti melimpah Anda mendapatkan kesempatan untuk membuat keputusan sendiri tentang apa yang harus terjadi.  Jika Anda ingin overflow dipotong (yang mungkin merupakan solusi yang tepat dalam situasi tertentu), gunakan <code>overflow: hidden</code> . <br><br><h2>  Kehilangan dan penyelarasan data </h2><br>  Alat leveling terbaik yang kami terima selama beberapa tahun terakhir juga dapat menyebabkan hilangnya data.  Pertimbangkan kolom elemen fleksibel yang ada di tepi viewport dan memiliki ukuran yang berbeda.  Ketika disejajarkan dengan nilai <code>flex-start</code> , elemen-elemen menjorok ke kanan.  Namun, ketika dipusatkan dengan <code>center</code> , elemen yang lebih luas akan melampaui batas viewport.  Oleh karena itu, perataan dapat menyebabkan hilangnya data. <br><br>  Untuk mencegah kehilangan data yang tidak disengaja yang disebabkan oleh perataan, CSS sekarang memiliki beberapa kata kunci baru yang dapat digunakan bersama dengan properti perataan.  Mereka didefinisikan dalam Alignment Box, spesifikasi yang berkaitan dengan penyelarasan dalam semua metode desain, termasuk Grid dan Flexbox.  Mereka saat ini hanya didukung di Firefox.  Dalam contoh kami di atas, jika kami menetapkan <code>align-items: safe center</code> , item terakhir akan dibenarkan kiri, bukan di tengah.  Ini akan mencegah kehilangan data yang disebabkan oleh pemusatan elemen dan oleh karena itu mendorongnya keluar dari viewport. <br><br>  Jika Anda membutuhkan perataan (bahkan jika itu mengarah ke overflow), maka Anda dapat menentukan <code>unsafe center</code> .  Dalam hal ini, Anda meminta agar browser melakukan penyelarasan pilihan Anda, terlepas dari apa yang terjadi pada konten.  Jika Anda memiliki Firefox, maka Anda dapat melihat dua contoh: yang pertama dengan penyelarasan yang aman, dan yang kedua dengan yang tidak aman. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/rachelandrew/embed/preview/QWLMrpE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan itu</a> , atas dasar yang saya tulis artikel ini, saya menggambarkan tata letak sebagai <b>perjuangan terus</b> - <b>menerus dengan meluap</b> .  Salah satu kebenaran desain untuk web adalah sangat sulit untuk mengetahui seberapa besar elemen yang mengandung teks.  Namun, seperti yang saya tunjukkan di atas, kami tidak pernah memiliki begitu banyak cara untuk mengendalikan kelebihan atau kelebihan.  Ini berarti bahwa tata letak kami dapat jauh lebih berkelanjutan dan kami dapat membuat template yang akan bekerja dengan jumlah konten yang berbeda.  Ini mungkin tampak seperti perubahan kecil saja, tapi saya pikir peluang yang mereka buka sangat besar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466665/">https://habr.com/ru/post/id466665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466653/index.html">Game debug untuk NES: bagaimana hal itu terjadi hari ini</a></li>
<li><a href="../id466657/index.html">Detail dinamis: game kompiler rahasia, kebocoran memori, nuansa kinerja</a></li>
<li><a href="../id466659/index.html">Ulasan Kubecost untuk menghemat uang di Kubernetes di awan</a></li>
<li><a href="../id466661/index.html">Gelar Master Jarak Di Luar Negeri: Catatan Sebelum Tesis</a></li>
<li><a href="../id466663/index.html">Eksperimen sederhana dengan mikrokontroler STM32F103 (Blue Tablet)</a></li>
<li><a href="../id466667/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 379 (2 - 8 September 2019)</a></li>
<li><a href="../id466669/index.html">Tesla mengembangkan baterai yang mampu berjalan 1,6 juta km tanpa penggantian</a></li>
<li><a href="../id466671/index.html">PHP Digest No. 164 (27 Agustus - 9 September 2019)</a></li>
<li><a href="../id466673/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 46. Pemeriksaan Kinerja OSPF</a></li>
<li><a href="../id466675/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari ke 47. Pemecahan Masalah OSPF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>