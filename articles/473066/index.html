<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💘 🎹 🌜 Árboles de cuadrante y reconocimiento de colisión 👞 🙌 💞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta semana fue corta, los lunes y martes seguí trabajando en un sistema de iluminación 2D . El resto del tiempo lo pasé en la implementación de árbol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Árboles de cuadrante y reconocimiento de colisión</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473066/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/237/20a/59e23720a19b3109d80e62c6d2d539a0.gif" alt="imagen"></div><br>  Esta semana fue corta, los lunes y martes seguí trabajando en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un sistema de iluminación 2D</a> .  El resto del tiempo lo pasé en la implementación de árboles quadtree. <br><br>  En este artículo compartiré mi implementación y pensamientos que surgieron en el proceso de su diseño. <br><br>  Primero, necesito decir por qué decidí implementar un árbol de cuadrante. <br><br>  Quadtree es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estructura de datos de partición espacial</a> .  Su principal ventaja sobre otras estructuras de datos es su adaptabilidad.  Proporciona un buen rendimiento al insertar, eliminar y buscar.  Es decir, podemos usar este árbol en un contexto dinámico donde los datos a menudo cambian.  Además, esta estructura es bastante fácil de entender e implementar. <br><br>  Si la partición del espacio es un tema nuevo para usted, le recomiendo leer este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo de</a> Robert Nistrom.  Si desea obtener más información sobre los árboles de cuadrantes, lea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> artículo. <br><a name="habracut"></a><br>  Hay áreas en mi juego en las que el uso de quadtree vale la pena al instante: <br><br><ul><li>  Al reconocer las colisiones, el árbol del cuadrante es mucho más eficiente que el método de fuerza bruta (prueba de todos los pares).  Pero este no es el enfoque más efectivo, en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este artículo</a> se puede estudiar una descripción general de varias técnicas y puntos de referencia.  Sin embargo, para la primera versión de mi motor de física, lo uso.  Quizás más tarde, si es necesario, elegiré un algoritmo más especializado. </li><li>  En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gráfico de escena,</a> al realizar el recorte, puedo usar quadtree para buscar todos los nodos visibles. </li><li>  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un sistema de iluminación,</a> puede usar quadtree para encontrar paredes que crucen el polígono de visibilidad de la fuente de luz. </li><li>  En el sistema de IA, puedes usar quadtree para buscar todos los objetos o enemigos que estén cerca de la esencia. </li><li>  Y así sucesivamente ... </li></ul><br>  Como puede ver, los árboles cuadrantes son bastante versátiles.  Serán una buena reposición en su kit de herramientas. <br><br>  Todo el código que se muestra en el artículo se puede encontrar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br><h1>  Preparación preliminar </h1><br>  Antes de detallar el código quadtree, necesitamos clases pequeñas para primitivas geométricas: la clase <code>Vector2</code> para definir puntos y la clase <code>Box</code> para definir rectángulos.  Ambos serán repetitivos. <br><br><h2>  Vector2 </h2><br>  La clase <a href=""><code>Vector2</code></a> minimalista.  Contiene solo constructores, así como operadores <code>+</code> y <code>/</code> .  Eso es todo lo que necesitamos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T x; T y; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;(TX = <span class="hljs-number"><span class="hljs-number">0</span></span>, TY = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : x(X), y(Y) { } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector2&lt;T&gt;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { x += other.x; y += other.y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/=(T t) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { x /= t; y /= t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Vector2&lt;T&gt; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector2&lt;T&gt;&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { lhs += rhs; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/(Vector2&lt;T&gt; vec, T t) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { vec /= t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec; }</code> </pre> <br><h2>  Caja </h2><br>  La clase <a href=""><code>Box</code></a> no es mucho más complicada: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T left; T top; T width; <span class="hljs-comment"><span class="hljs-comment">// Must be positive T height; // Must be positive constexpr Box(T Left = 0, T Top = 0, T Width = 0, T Height = 0) noexcept : left(Left), top(Top), width(Width), height(Height) { } constexpr Box(const Vector2&lt;T&gt;&amp; position, const Vector2&lt;T&gt;&amp; size) noexcept : left(position.x), top(position.y), width(size.x), height(size.y) { } constexpr T getRight() const noexcept { return left + width; } constexpr T getBottom() const noexcept { return top + height; } constexpr Vector2&lt;T&gt; getTopLeft() const noexcept { return Vector2&lt;T&gt;(left, top); } constexpr Vector2&lt;T&gt; getCenter() const noexcept { return Vector2&lt;T&gt;(left + width / 2, top + height / 2); } constexpr Vector2&lt;T&gt; getSize() const noexcept { return Vector2&lt;T&gt;(width, height); } constexpr bool contains(const Box&lt;T&gt;&amp; box) const noexcept { return left &lt;= box.left &amp;&amp; box.getRight() &lt;= getRight() &amp;&amp; top &lt;= box.top &amp;&amp; box.getBottom() &lt;= getBottom(); } constexpr bool intersects(const Box&lt;T&gt;&amp; box) const noexcept { return !(left &gt;= box.getRight() || getRight() &lt;= box.left || top &gt;= box.getBottom() || getBottom() &lt;= box.top); } };</span></span></code> </pre> <br>  Contiene algunos captadores útiles. <br><br>  Lo que es más interesante es que contiene el método contiene, que verifica si el rectángulo está dentro de otro, y el método de <code>intersects</code> , que verifica si el rectángulo se cruza con otro. <br><br>  Usaremos <code>contains</code> cuando inserte y elimine, e <code>intersects</code> al reconocer intersecciones. <br><br><h1>  Quadtree </h1><br>  Aquí está el <a href=""><code>Quadtree</code></a> clase <a href=""><code>Quadtree</code></a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> GetBox, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Equal = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::equal_to&lt;T&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Float = <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; class Quadtree { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_convertible_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;GetBox, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;&gt;, Box&lt;Float&gt;&gt;, <span class="hljs-string"><span class="hljs-string">"GetBox must be a callable of signature Box&lt;Float&gt;(const T&amp;)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_convertible_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Equal, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;, <span class="hljs-string"><span class="hljs-string">"Equal must be a callable of signature bool(const T&amp;, const T&amp;)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_arithmetic_v&lt;Float&gt;); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Quadtree(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GetBox&amp; getBox = GetBox(), <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Equal&amp; equal = Equal()) : mBox(box), mRoot(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;Node&gt;()), mGetBox(getBox), mEqual(equal) { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Threshold = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> MaxDepth = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Node&gt;, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; children; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; values; }; Box&lt;Float&gt; mBox; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Node&gt; mRoot; GetBox mGetBox; Equal mEqual; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLeaf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Node* node)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(node-&gt;children[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } };</code> </pre> <br>  Como puede ver, <code>Quadtree</code> es una clase de plantilla.  Esto nos permitirá usar la clase para varios propósitos, de los que hablé al principio. <br><br>  Opciones de plantilla: <br><br><ul><li>  <code>T</code> : el tipo de valores que se incluirán en quadtree.  <code>T</code> debería ser una clase fácil, ya que se almacenará dentro de un quadtree.  Idealmente, esto debería ser un puntero o una pequeña estructura de datos simple (POD). </li><li>  <code>GetBox</code> : el tipo del objeto llamado que recibirá el valor en la entrada y devolverá un rectángulo. </li><li>  <code>Equal</code> : tipo del objeto llamado para verificar si dos valores son iguales.  Por defecto, usamos el operador de igualdad estándar. </li><li>  <code>Float</code> : el tipo aritmético utilizado en los cálculos.  Por defecto, usamos <code>float</code> . </li></ul><br>  Al comienzo de la definición de clase, hay tres aserciones estáticas para verificar la validez de los parámetros de la plantilla. <br><br>  Echemos un vistazo a la definición de un nodo.  Un nodo simplemente almacena punteros en sus cuatro nodos secundarios y una lista de los valores contenidos en él.  No almacenamos en él su caja delimitadora o su profundidad, se calcularán sobre la marcha. <br><br>  Realicé puntos de referencia de ambos enfoques (preservar un rectángulo con profundidad y sin preservar) y no encontré ninguna degradación del rendimiento al calcularlos sobre la marcha.  Además, ahorra un poco de memoria. <br><br>  Para poder distinguir un nodo interno de una hoja, <code>isLeaf</code> método <code>isLeaf</code> .  Simplemente verifica que el primer hijo no sea nulo.  Dado que nulo son todos los nodos secundarios, o ninguno de ellos, es suficiente verificar solo el primero. <br><br>  Ahora podemos ver las <code>Quadtree</code> miembro de <code>Quadtree</code> : <br><br><ul><li>  <code>mBox</code> es un cuadro delimitador global.  Todos los valores insertados en quadtree deben estar contenidos dentro de él. </li><li>  <code>mRoot</code> es la raíz de quadtree. </li><li>  <code>mGetBox</code> es el objeto llamado, que usaremos para obtener el rectángulo del valor. </li><li>  <code>mEqual</code> es el objeto llamado, que usaremos para verificar la igualdad de los dos valores. </li></ul><br>  El constructor simplemente establece <code>mBox</code> , <code>mGetBox</code> y <code>mEqual</code> , y también crea un nodo raíz. <br><br>  Los dos últimos parámetros de los que aún no hemos hablado son <code>Threshold</code> y <code>MaxDepth</code> .  <code>Threshold</code> es el número máximo de valores que puede contener un nodo antes de dividirlo.  <code>MaxDepth</code> es la profundidad máxima del nodo, dejamos de intentar dividir los nodos que están en <code>MaxDepth</code> , porque si divide demasiado, puede obstaculizar el rendimiento.  Le di a estas constantes valores razonables adecuados para la mayoría de los casos.  Puede intentar optimizarlos para su configuración. <br><br>  Ahora estamos listos para comenzar operaciones más interesantes. <br><br><h1>  Insertar y eliminar </h1><br>  Antes de mostrar el código de inserción, debemos analizar qué nodos contendrán los valores.  Hay dos estrategias: <br><br><ul><li>  Los valores se almacenan solo en hojas.  Como el cuadro delimitador de un valor puede interactuar con varias hojas, el valor se almacenará en todas estas hojas. </li><li>  Los valores se pueden almacenar en todos los nodos.  Almacenamos el valor en el nodo más pequeño que contiene completamente su cuadro delimitador. </li></ul><br>  Si los rectángulos delimitadores son pequeños y aproximadamente del mismo tamaño, entonces la primera estrategia es más efectiva cuando se buscan intersecciones.  Sin embargo, si existen rectángulos grandes, pueden ocurrir casos degenerados en los que el rendimiento será muy pobre.  Por ejemplo, si insertamos un valor cuyo rectángulo está en el cuadro delimitador global, se agregará a todas las hojas.  Y si insertamos un <code>Threshold</code> para tales valores, todos los nodos se dividirán hasta que <code>MaxDepth</code> alcance <code>MaxDepth</code> y los valores no estén en todas las hojas.  Por lo tanto, quadtree contendrá <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>U</mi><mi>m</mi><mi>b</mi><mi>r</mi><mi>a</mi><mi>l</mi></mrow><mtext>&amp;#xA0;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><mi>e</mi><mi>s</mi><msup><mn>4</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="34.205ex" height="2.539ex" viewBox="0 -987.6 14726.9 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-74" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-65" x="611" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-78" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-74" x="1650" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-74" x="2012" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-74" x="2373" y="0"></use><g transform="translate(2735,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-55" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-6D" x="767" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-62" x="1646" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-72" x="2075" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-61" x="2527" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-6C" x="3056" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-76" x="6340" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-65" x="6825" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-63" x="7292" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-65" x="7725" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-73" x="8192" y="0"></use><g transform="translate(8661,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMAIN-34" x="0" y="0"></use><g transform="translate(500,404)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-74" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-65" x="715" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-78" x="1181" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-74" x="1754" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-74" x="2115" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-74" x="2477" y="0"></use><g transform="translate(2007,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-4D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-61" x="1051" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-78" x="1581" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-44" x="2153" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-65" x="2982" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-70" x="3448" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-74" x="3952" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhV40dvPJn8EFLwd7_zx24OPe5S9g#MJMATHI-68" x="4313" y="0"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></mi><mrow class="MJX-TeXAtom-ORD"><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l</font></font></mi></mrow><mtext>&nbsp;</mtext><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></mi><msup><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 4</font></font></mn><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></mi><mrow class="MJX-TeXAtom-ORD"><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h</font></font></mi></mrow></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ texttt {Umbral} \ veces 4 ^ {\ texttt {MaxDepth}} </script>  significados, y eso es ... mucho. <br><br>  Además, con la primera estrategia, la inserción y eliminación será un poco más lenta, ya que tenemos que insertar (o eliminar) todos los nodos que intersecan el valor. <br><br>  Por lo tanto, usaré la segunda estrategia, en la que no hay casos degenerados.  Como planeo usar quadtree en varios contextos, será más conveniente.  Además, esta estrategia es más adecuada para contextos dinámicos en los que se realizan muchas inserciones y eliminaciones para actualizar valores, por ejemplo, en un motor físico donde se mueven las entidades. <br><br>  Para averiguar en qué nodo insertaremos o eliminaremos un valor, utilizaremos dos funciones auxiliares. <br><br>  El primero, <code>computeBox</code> , calcula el rectángulo del nodo secundario mediante el rectángulo del nodo primario y el índice de su cuadrante. <br><br><pre> <code class="cpp hljs">Box&lt;Float&gt; computeBox(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> origin = box.getTopLeft(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> childSize = box.getSize() / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Float&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i) { <span class="hljs-comment"><span class="hljs-comment">// North West case 0: return Box&lt;Float&gt;(origin, childSize); // Norst East case 1: return Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x + childSize.x, origin.y), childSize); // South West case 2: return Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x, origin.y + childSize.y), childSize); // South East case 3: return Box&lt;Float&gt;(origin + childSize, childSize); default: assert(false &amp;&amp; "Invalid child index"); return Box&lt;Float&gt;(); } }</span></span></code> </pre> <br>  El segundo, <code>getQuadrant</code> , devuelve el cuadrante en el que se encuentra el valor: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getQuadrant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; nodeBox, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; valueBox)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> center = nodeBox.getCenter(); <span class="hljs-comment"><span class="hljs-comment">// West if (valueBox.getRight() &lt; center.x) { // North West if (valueBox.getBottom() &lt; center.y) return 0; // South West else if (valueBox.top &gt;= center.y) return 2; // Not contained in any quadrant else return -1; } // East else if (valueBox.left &gt;= center.x) { // North East if (valueBox.getBottom() &lt; center.y) return 1; // South East else if (valueBox.top &gt;= center.y) return 3; // Not contained in any quadrant else return -1; } // Not contained in any quadrant else return -1; }</span></span></code> </pre> <br>  Devuelve <code>-1</code> si no está contenido en ninguno de los cuadrantes. <br><br>  Ahora estamos listos para considerar los métodos de inserción y eliminación. <br><br><h2>  Insertar </h2><br>  El método <code>add</code> simplemente llama a un método auxiliar privado: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ add(mRoot.get(), <span class="hljs-number"><span class="hljs-number">0</span></span>, mBox, value); }</code> </pre> <br>  Aquí está el código del método auxiliar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(box.contains(mGetBox(value))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLeaf(node)) { <span class="hljs-comment"><span class="hljs-comment">// Insert the value in this node if possible if (depth &gt;= MaxDepth || node-&gt;values.size() &lt; Threshold) node-&gt;values.push_back(value); // Otherwise, we split and we try again else { split(node, box); add(node, depth, box, value); } } else { auto i = getQuadrant(box, mGetBox(value)); // Add the value in a child if the value is entirely contained in it if (i != -1) add(node-&gt;children[static_cast&lt;std::size_t&gt;(i)].get(), depth + 1, computeBox(box, i), value); // Otherwise, we add the value in the current node else node-&gt;values.push_back(value); } }</span></span></code> </pre> <br>  Al principio hay un par de suposiciones que verifican que no estamos haciendo nada ilógico, por ejemplo, no estamos insertando un valor en un nodo que no contiene su cuadro delimitador. <br><br>  Luego, si el nodo es una hoja, y podemos insertar un nuevo valor en él, es decir  no hemos alcanzado <code>MaxDepth</code> o <code>Threshold</code> , realice la inserción.  De lo contrario, compartimos este nodo e intentamos nuevamente. <br><br>  Si el nodo es interno, calculamos el cuadrante que contiene el cuadro delimitador del valor.  Si está completamente contenido en el nodo hijo, hacemos una llamada recursiva.  De lo contrario, inserte en este nodo. <br><br>  Aquí está el procedimiento de separación: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(isLeaf(node) &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Only leaves can be split"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Create children for (auto&amp; child : node-&gt;children) child = std::make_unique&lt;Node&gt;(); // Assign values to children auto newValues = std::vector&lt;T&gt;(); // New values for this node for (const auto&amp; value : node-&gt;values) { auto i = getQuadrant(box, mGetBox(value)); if (i != -1) node-&gt;children[static_cast&lt;std::size_t&gt;(i)]-&gt;values.push_back(value); else newValues.push_back(value); } node-&gt;values = std::move(newValues); }</span></span></code> </pre> <br>  Creamos cuatro nodos secundarios, y luego para cada valor del nodo primario, decidimos en qué nodo (secundario o primario) se debe almacenar el valor. <br><br><h2>  Eliminar </h2><br>  El método <code>remove</code> también simplemente llama a un método auxiliar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ remove(mRoot.get(), <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, mBox, value); }</code> </pre> <br>  Aquí está el código del método auxiliar, es muy similar al código de inserción: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, Node* parent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(box.contains(mGetBox(value))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLeaf(node)) { <span class="hljs-comment"><span class="hljs-comment">// Remove the value from node removeValue(node, value); // Try to merge the parent if (parent != nullptr) tryMerge(parent); } else { // Remove the value in a child if the value is entirely contained in it auto i = getQuadrant(box, mGetBox(value)); if (i != -1) remove(node-&gt;children[static_cast&lt;std::size_t&gt;(i)].get(), node, computeBox(box, i), value); // Otherwise, we remove the value from the current node else removeValue(node, value); } }</span></span></code> </pre> <br>  Si el nodo actual es una hoja, entonces eliminamos el valor de la lista de valores del nodo actual <br>  e intente fusionar este nodo con los nodos hermanos y su padre.  De lo contrario, determinamos en qué cuadrante se ubica el cuadro delimitador del valor.  Si está completamente contenido en el nodo hijo, entonces hacemos una llamada recursiva.  De lo contrario, elimine de los valores del nodo actual. <br><br>  Como no nos importa el orden de los valores almacenados en el nodo, cuando borro, uso una pequeña optimización: simplemente cambio el valor borrado con el último y lo borro: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find the value in node-&gt;values auto it = std::find_if(std::begin(node-&gt;values), std::end(node-&gt;values), [this, &amp;value](const auto&amp; rhs){ return mEqual(value, rhs); }); assert(it != std::end(node-&gt;values) &amp;&amp; "Trying to remove a value that is not present in the node"); // Swap with the last element and pop back *it = std::move(node-&gt;values.back()); node-&gt;values.pop_back(); }</span></span></code> </pre> <br>  También tenemos que echar un vistazo a <code>tryMerge</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryMerge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(!isLeaf(node) &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Only interior nodes can be merged"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> nbValues = node-&gt;values.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; child : node-&gt;children) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLeaf(child.get())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; nbValues += child-&gt;values.size(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nbValues &lt;= Threshold) { node-&gt;values.reserve(nbValues); <span class="hljs-comment"><span class="hljs-comment">// Merge the values of all the children for (const auto&amp; child : node-&gt;children) { for (const auto&amp; value : child-&gt;values) node-&gt;values.push_back(value); } // Remove the children for (auto&amp; child : node-&gt;children) child.reset(); } }</span></span></code> </pre> <br>  <code>tryMerge</code> verifica que todos los nodos secundarios son hojas y que el número total de sus valores y los valores de los nodos secundarios es inferior al umbral.  Si es así, copiamos todos los valores de los nodos secundarios al nodo actual y eliminamos los nodos secundarios. <br><br><h1>  Búsqueda de intersección </h1><br><h2>  Intersección con rectángulo </h2><br>  Finalmente, llegamos a lo más interesante: a la búsqueda de intersecciones.  La primera forma de usarlo es hacer que todos los valores se crucen con un rectángulo dado.  Por ejemplo, esto es necesario para realizar el recorte. <br><br>  Esto se <code>query</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; query(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> values = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;(); query(mRoot.get(), mBox, box, values); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values; }</code> </pre> <br>  En este método, simplemente seleccionamos <code>std::vector</code> , que contendrá los valores que intersecan el cuadro delimitador, y llamaremos al método auxiliar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; queryBox, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; values)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(queryBox.intersects(box)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; value : node-&gt;values) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryBox.intersects(mGetBox(value))) values.push_back(value); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLeaf(node)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); i &lt; node-&gt;children.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> childBox = computeBox(box, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(i)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryBox.intersects(childBox)) query(node-&gt;children[i].get(), childBox, queryBox, values); } } }</code> </pre> <br>  Primero, sumamos todos los valores almacenados en el nodo actual que se cruzan con el rectángulo solicitado.  Luego, si el nodo actual es interno, hacemos una llamada recursiva para cada nodo secundario cuyo rectángulo delimitador se cruza con el rectángulo solicitado. <br><br><h2>  Todas las intersecciones por pares </h2><br>  El segundo caso de uso admitido es buscar todos los pares de valores almacenados en el árbol de cuadrante que se cruzan.  Esto es especialmente útil al crear un motor físico.  Este problema se puede resolver utilizando el método de <code>query</code> .  Y, de hecho, podemos llamar a la <code>query</code> en el cuadro delimitador de todos los valores.  Sin embargo, esto se puede hacer de manera más eficiente agregando solo una intersección para un par (con la <code>query</code> los encontraremos dos veces). <br><br>  Para darnos cuenta de esto, debemos considerar que la intersección solo puede ocurrir <br><br><ul><li>  entre dos valores almacenados en un nodo </li></ul><br>  o <br><br><ul><li>  entre el valor almacenado en el nodo y otro valor almacenado en el descendiente de este nodo. </li></ul><br>  Debido a esto, necesitamos verificar solo la intersección entre: <br><br><ul><li>  valor y los siguientes valores almacenados en el mismo nodo </li></ul><br>  y <br><br><ul><li>  valor y valores almacenados en el descendiente. </li></ul><br>  Por lo tanto, definitivamente no informaremos la misma intersección dos veces. <br><br>  Aquí está el código <code>findAllIntersections</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;T, T&gt;&gt; findAllIntersections() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> intersections = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;T, T&gt;&gt;(); findAllIntersections(mRoot.get(), intersections); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intersections; }</code> </pre> <br>  Nuevamente, simplemente asignamos <code>std::vector</code> para almacenar las intersecciones y llamar a la función auxiliar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllIntersections</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;T, T&gt;&gt;&amp; intersections)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find intersections between values stored in this node // Make sure to not report the same intersection twice for (auto i = std::size_t(0); i &lt; node-&gt;values.size(); ++i) { for (auto j = std::size_t(0); j &lt; i; ++j) { if (mGetBox(node-&gt;values[i]).intersects(mGetBox(node-&gt;values[j]))) intersections.emplace_back(node-&gt;values[i], node-&gt;values[j]); } } if (!isLeaf(node)) { // Values in this node can intersect values in descendants for (const auto&amp; child : node-&gt;children) { for (const auto&amp; value : node-&gt;values) findIntersectionsInDescendants(child.get(), value, intersections); } // Find intersections in children for (const auto&amp; child : node-&gt;children) findAllIntersections(child.get(), intersections); } }</span></span></code> </pre> <br>  En la primera etapa, se verifican las intersecciones entre los valores almacenados en el nodo actual.  Luego, si el nodo actual es interno, <code>findIntersectionInDescendants</code> busca intersecciones entre los valores almacenados en este nodo y los valores almacenados en sus descendientes.  Finalmente, hacemos llamadas recursivas. <br><br>  <code>findIntersectionsInDescendants</code> busca recursivamente intersecciones entre el valor dado y todos los valores almacenados en el subárbol: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findIntersectionsInDescendants</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;T, T&gt;&gt;&amp; intersections)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Test against the values stored in this node for (const auto&amp; other : node-&gt;values) { if (mGetBox(value).intersects(mGetBox(other))) intersections.emplace_back(value, other); } // Test against values stored into descendants of this node if (!isLeaf(node)) { for (const auto&amp; child : node-&gt;children) findIntersectionsInDescendants(child.get(), value, intersections); } }</span></span></code> </pre> <br>  Eso es todo!  Repito, todo el código está publicado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br><h1>  Recursos utiles </h1><br>  Si desea obtener más información sobre el reconocimiento de colisiones y las estructuras de datos de partición, le recomiendo leer el libro de Christer Erickson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Real-Time Collision Detection</a> .  Muchos temas se revelan profundamente y al mismo tiempo el libro está escrito en un lenguaje muy comprensible.  Además, los capítulos se pueden leer por separado.  Esta es una gran fuente de referencia. <br><br><h1>  Conclusión </h1><br>  Esto completa el trabajo con reconocimiento de colisión.  Sin embargo, es solo la mitad del motor físico.  La segunda mitad es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">resolución de colisiones</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/473066/">https://habr.com/ru/post/473066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../473054/index.html">WorldSkills final, desarrollo de soluciones de TI para empresas: qué es, cómo fue y por qué los programadores de 1C ganaron allí</a></li>
<li><a href="../473056/index.html">Cómo Alicia reconoce países a partir de fotografías. Investigación Yandex</a></li>
<li><a href="../473058/index.html">Sergey Sinitsyn: “OSM es más que solo dibujar casas o pistas. ¡Estas son más historias!</a></li>
<li><a href="../473062/index.html">User.js subjetivo para Mozilla Firefox y no solo</a></li>
<li><a href="../473064/index.html">Lágrimas bátavas, autos y Gorilla Glass: sobre algunos tipos de vidrio reforzado</a></li>
<li><a href="../473070/index.html">Redux - ¡No es necesario! ¿Reemplazar con useContext y useReducer en React?</a></li>
<li><a href="../473072/index.html">Cómo Gazpromneft crea una ruta digital para un cliente corporativo</a></li>
<li><a href="../473078/index.html">Administre fácilmente configuraciones de microservicios con microconfig.io</a></li>
<li><a href="../473082/index.html">Cómo escribimos microservicios y por qué no lo hacemos rápidamente</a></li>
<li><a href="../473084/index.html">"Ivan" es una profesión de chat bot. O experimentos creativos con asistentes virtuales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>