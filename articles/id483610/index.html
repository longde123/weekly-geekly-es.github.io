<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•´ üêò ‚úåüèª Apakah otomat merupakan suatu peristiwa? üë©üèΩ‚Äçüíª üó∫Ô∏è üë©üèª‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Pendahuluan 
 Setelah mendengar dari bibir otoritatif bahwa "automata adalah suatu peristiwa" [3], saya menyadari bahwa automata terbatas bermerek ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apakah otomat merupakan suatu peristiwa?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483610/"><h3>  1. Pendahuluan </h3><br>  Setelah mendengar dari bibir otoritatif bahwa "automata adalah suatu peristiwa" [3], saya menyadari bahwa automata terbatas bermerek sepenuhnya.  Nilai sendiri: di perpustakaan Qt, model acara automata [1] diimplementasikan, di UML mereka juga [2], kita melihat automata dari paket ekstensi Simulink-Stateflow dari sistem MATLAB [4] (selanjutnya disebut hanya sebagai Stateflow) dan ada tentang peristiwa, dll.  dll.  Dalam konteks ini, pernyataan Ph.D.  A.A.  Itu nakal untuk menafsirkan dengan cara yang berbeda, karena  tidak ada yang lain, karena tidak mungkin. <br><br>  Tetapi, jika Anda mengingat teori finite automata (TCA), maka tidak ada satu kata pun tentang automata acara di dalamnya!  Tetapi untuk membantah teorinya, diperlukan argumen yang berbobot.  Apakah ada alasan untuk meragukan profesionalisme D. Harell, sebagai pencipta notasi di mana bahasa UML, paket Stateflow, mendasarkan ide-idenya, yang, pada gilirannya, tidak asing dengan A.A.  Nakal?  Memang, UML, Stateflow, pemrograman SWITCH, dan opsi pemrograman otomatis lainnya ada dan, sampai taraf tertentu, berhasil. <br><br>  Jadi mungkinkah untuk menghapus "stigma peristiwa" dari model mesin keadaan terbatas dengan memisahkan "irisan daging dari lalat"?  Yaitu  pisahkan teori automata dan model komputasi yang mirip dengan model D. Harel.  Dan untuk mempertimbangkan bahwa yang terakhir, meskipun menggunakan terminologi teori automata, mewakili, menilai dari implementasinya, pengembangan model diagram blok program. <br><a name="habracut"></a><br>  <i>Catatan 1. Dalam hal ini, kita berbicara tentang model manajemen program, dan bukan tentang model program itu sendiri (untuk detail lebih lanjut tentang model, lihat [5]).</i> <br><br>  Jadi, ingat, perpustakaan Qt mengimplementasikan model acara dari mesin negara terbatas, yang dipinjam dari UML.  Model yang sama diimplementasikan oleh Stateflow.  Yaitu  sumber acara adalah UML, di mana automata didasarkan pada notasi yang diusulkan oleh D. Harel.  Tetapi menyalahkan yang terakhir untuk membuat pemrograman otomatis seperti itu juga tidak akan benar, karena  "Kejadian" adalah kecenderungan pendekatan modern untuk implementasi model perangkat lunak.  Ini didasarkan pada pendapat otoritatif seperti yang disebutkan "mesin adalah suatu peristiwa", dan popularitas tinggi bahasa dan teknologi seperti UML.  Tanpa ragu, ini adalah hasil dari peniruan mesin di bawah prinsip operasi sistem operasi yang ada. <br><br>  Tapi, kami ulangi, karena sepertinya tidak aneh, tetapi bagi sebagian orang itu bahkan mungkin menjadi berita, dalam teori automata tidak ada model kejadian dari robot terbatas.  Setidaknya di bagian itu yang dianggap klasik (lihat untuk detail lebih lanjut, misalnya, [6] atau [7]).  Ada kontradiksi yang jelas antara teori dan praktik.  Dalam situasi seperti itu, Anda perlu melakukan sesuatu dengan teori atau memengaruhi praktik.  Tapi, mungkin, programmer benar dalam keinginan mereka untuk menyelesaikan model mesin negara yang terbatas dengan memasukkan konsep "acara" di dalamnya [8, 9]? <br><br>  Tetapi bagaimana menghubungkan keinginan pemrogram dengan fakta bahwa "kesulitan terbesar dalam menggunakan pendekatan automaton terhubung dengan memahami fitur fungsi automata dalam sistem acara" (lihat [8]).  Saya ingin memahami penyebab masalah seperti itu dan, dalam konteks ini, menerapkan mesin acara dan / atau analog mereka.  Untuk tujuan ini, untuk spesifik, kami mengambil implementasi automata di Qt dan mengulanginya menggunakan model otomat terbatas klasik. <br><br>  Implementasi seperti automata acara diperlukan untuk mengevaluasi dan / atau mengatasi "fitur" yang disebutkan.  Menggunakan model klasik akan memperluas teori automata ke praktik "pemrograman acara" juga.  Dan, pada akhirnya, analog yang didasarkan pada model lain hanya akan memperluas area penerapan model mesin keadaan terbatas. <br><br><h3>  2. Peristiwa, sinyal, dan identitas gender automata </h3><br>  Dalam UML, suatu peristiwa adalah "sebuah fenomena signifikan yang memiliki posisi tertentu dalam ruang dan waktu ... dan membawa konsekuensi tertentu" [10].  Suatu peristiwa dalam teori automata adalah subset dari karakter input yang diwakili oleh karakter alfabet keluaran (bahkan ada konsep aljabar peristiwa dalam TCA) [6].  Hal yang sama yang menyebabkan transisi otomat disebut sinyal input dalam teori automata.  Mereka adalah konsekuensi dan ‚Äúalasannya, transisi otomat dari satu kondisi ke kondisi lainnya.  Dalam hal ini, sinyal output adalah "respons otomat terhadap sinyal input." Keduanya mengacu pada waktu yang ditentukan oleh transisi automaton yang sesuai. [6]. Dalam UML, sinyal (sinyal) adalah "entitas bernama yang berfungsi sebagai alat komunikasi." antar benda ‚Äù[10]. <br><br>  Dengan demikian, nama-nama istilahnya sama, tetapi makna yang diinvestasikan di dalamnya berbeda.  Meskipun, jika Anda mengatur ulang, Anda dapat menemukan kesamaan: menjadi jelas bahwa peristiwa di UML sesuai dengan sinyal mesin keadaan terbatas di TCA.  Tapi, mungkin, entitas yang berbeda juga tersembunyi di bawah istilah "mesin negara terbatas"?  Mari kita coba mencari tahu, dimulai dengan acara ... <br><br>  Acara automaton adalah robot pasif, karena  hanya berfungsi pada saat kedatangan acara.  Sebaliknya, robot klasik mewakili model aktif.  Ini berfungsi tanpa merujuk pada apa pun (untuk detail lebih lanjut tentang automata pasif dan aktif, lihat [9]).  Di sini hubungan dengan dua pelari memohon, di mana yang pertama didorong oleh tendangan (peristiwa), dan yang kedua berjalan dengan sendirinya. <br><br>  Berbeda dengan [8], pada awalnya kami tidak akan mengaitkan momen-momen kejadian peristiwa dengan permulaan otomat.  Jadi kita akan tetap dalam kerangka teori automata, yang menentukan sifat asinkron dari fungsi automata sehubungan dengan lingkungan eksternal.  Ini hanya berbicara tentang waktu diskrit, di mana perubahan negara dilakukan untuk periode waktu-kecil yang sewenang-wenang, tetapi tidak sama dengan nol.  Dan alasan untuk transisi adalah keadaan saat ini dan sinyal input dari mesin, di mana konsekuensinya adalah pemasangan status baru dan nilai-nilai sinyal output dari mesin (untuk rincian lebih lanjut tentang definisi mesin lihat [6]). <br><br>  Teori Automata fleksibel dalam menentukan waktu diskrit, yang merupakan model waktu nyata.  Jadi, siklus waktu diskrit dapat memiliki nilai tetap atau mengambang dari interval waktu-nyata, dan sesuai dengan ini, mesin disebut sinkron atau asinkron.  Pada saat yang sama, interval waktu yang terkait dengan jam dapat memiliki nilai apa pun, termasuk nilai yang sangat kecil, tetapi tidak sama dengan nol. <br><br>  <i>Catatan 2. Model mesin keadaan terbatas adalah salah satu dari beberapa model formal yang termasuk dalam definisi model real-time dalam bentuk eksplisit.</i> <br><br>  Akibatnya, kecepatan "tak terbatas" resmi dari otomat aktif memungkinkan setiap peristiwa diperlakukan sebagai sinyal input potensial (dalam hal UML, kondisi [11] sesuai dengan itu).  Mesin hanya perlu "menangkap" peristiwa / sinyal tersebut dan berhenti di antara keduanya.  Semua ini sebenarnya mendefinisikan protokol untuk kerja bersama medium dan mesin.  Protokol juga harus menyelesaikan masalah mengenali kejadian identik yang diterima secara berturut-turut.  Tanpa ini, misalnya, dua simbol yang identik, yang diterima satu demi satu, dapat dianggap sebagai satu. <br><br>  Secara formal, nuansa pemrosesan peristiwa tidak signifikan (lihat automata abstrak yang sama), tetapi dalam implementasi praktis dari algoritma yang dibangun oleh jenis model peristiwa, mereka harus diperhitungkan.  Dalam kasus perpustakaan Qt, akuntansi mereka disembunyikan di kelas implementasi otomat.  Lebih lanjut, kami akan memperhitungkan perbedaan antara event dan automata klasik menggunakan contoh implementasi kalkulator paling sederhana dari [1], di mana ‚Äúimplementasi event‚Äù diberikan.  Berbeda dengan solusi ini, model yang setara akan dibuat berdasarkan pada mesin state hingga klasik. <br><br><h3>  3. Model Kalkulator </h3><br>  Jadi, mari kita mulai ... Kita menyebut sinyal peristiwa, peristiwa automata biasa ... atau dalam urutan terbalik dan / atau sebaliknya?  Ugh!  Bingung.  Singkatnya, "cuzdra shteko budlanula" yang lengkap dan sesuatu yang "ikal".  Untuk mengetahui siapa itu siapa, apa dan apa yang harus dihubungi, cara paling pasti adalah memilih "bokra" tertentu dan "menabraknya" ... Program "kalkulator otomatis" akan terus menjadi "sisi" seperti itu. <br><br><h4>  3.1.  Model kalkulator aktif </h4><br>  Dalam gbr.  1 menunjukkan model asli dari Kalkulator kelas dari [1].  Secara tampilan, ini terlihat seperti mesin abstrak klasik tanpa jalan keluar.  Perbedaannya adalah bahwa Qt menghubungkan tindakan ketika masuk dan keluar dari keadaan.  Pada output, mereka dipicu oleh sinyal yang keluar (), dan saat memasuki keadaan, oleh sinyal yang dimasukkan ().  Namun, kami perhatikan, tindakan ini tidak terwakili dalam grafik dengan cara apa pun. <br><br>  Jika kita membandingkan model pada Gambar.  1 dengan otomat dengan keadaan abstrak (nama lainnya adalah struktural, automaton logis), orang dapat dengan mudah melihat bahwa tindakan di pintu keluar dari negara sesuai dengan sinyal dari otomat Mealy, dan tindakan di pintu masuk sesuai dengan sinyal dari otomat Moore. <br>  Catatan 3. Selanjutnya, dengan mempertimbangkan implementasi perangkat lunak model, kami tidak akan berbicara tentang sinyal, peristiwa, kondisi, dll., Tetapi tentang tindakan automata, dengan asumsi bahwa pada tingkat program mereka terkait dengan tindakan program tertentu, yang dalam kasus umum diwakili oleh fungsi perangkat lunak. <br><br>  Apa yang disebut automaton Mili-Moore gabungan (atau automaton campuran berbeda [12]), setara dengan automaton pada Gambar.  1, ditunjukkan pada Gambar. 2, di mana fungsi yang sesuai dengan sinyal input dan output dari otomat juga ditampilkan di sebelah kanan grafik. <br><br><img src="https://habrastorage.org/webt/dq/ki/ps/dqkipszttmbkgyexe9labqsio9e.jpeg" alt="gambar"><br>  <i>Fig. 1.</i>  <i>Diagram mesin acara kalkulator</i> <br><br><img src="https://habrastorage.org/webt/c3/la/ue/c3laueqyd9oiwdf9aiu5gpyi_yk.jpeg" alt="gambar"><br>  <i>Fig. 2.</i>  <i>Hitung Miley-Moore Kalkulator kelas automaton</i> <br><br>  Untuk model yang mirip dengan otomat pada Gambar. 2, dengan tindakan input / output yang kami maksudkan adalah predikat dan tindakan yang merupakan metode-metode fungsi program dari kelas [automaton].  Predikat menganalisis keadaan elemen memori saat ini (variabel, properti kelas) dengan cara apa pun (ini penting!) Tanpa memengaruhi mereka, tetapi tergantung pada nilainya, kembalikan nilai Boolean.  Tindakan nilai tidak kembali, tetapi mengubah elemen memori. <br>  Dari ara.  2 itu mengikuti bahwa model kalkulator, seperti "kotak hitam", memiliki empat saluran input dan tujuh saluran output dalam hal jumlah predikat dan tindakan.  Sangat mudah untuk melihat bahwa dibandingkan dengan otomat abstrak, yang menurut definisi tidak memiliki lebih dari satu input dan satu saluran keluaran, otomat struktural yang memiliki banyak saluran lebih universal, fleksibel dan nyaman. <br><br>  Model dalam gbr.  2 dapat disederhanakan dengan "menempelkan" status 1 dan 2. Untuk melakukan ini, pertama-tama Anda harus mengubah automaton asli menjadi otomat Mealy.  Kami mendapatkannya dengan memuat busur memasuki keadaan sinyal dengan sinyal yang diwakili oleh sinyal dari simpul otomat Moore.  Setelah ini, operasi perekatan menjadi jelas.  Hasil pengeleman status ke status 2, yang sekarang menjadi awal, ditunjukkan pada Gambar.  3. <br><br><img src="https://habrastorage.org/webt/qa/en/yw/qaenywlioaky3gizvfju27faxmm.jpeg" alt="gambar"><br>  <i>Fig. 3.</i>  <i>Hasil transformasi dan perekatan keadaan otomat pada Gambar. 2</i> <br><br>  Jelaskan tindakan y1 dan variabel nTypeButtons.  Secara total, mereka menerapkan protokol yang mensimulasikan peristiwa.  Variabel nTypeButtons menentukan jenis simbol input automaton dengan membaginya menjadi simbol digital, simbol operasi, simbol "reset" dan simbol "sama".  Nilainya sama dengan nol berarti tidak adanya karakter input (tidak ada tombol kalkulator yang ditekan).  Setelah memproses simbol, ini juga berarti bahwa simbol input dirasakan secara otomatis.  Ini memblokir respons terhadap karakter input. <br><br>  Kode untuk kelas kalkulator yang dibuat dalam kerangka lingkungan pemrograman komponen visual otomatis (VKPa) [5] ditunjukkan dalam daftar 1, 2. <br><br><div class="spoiler">  <b class="spoiler_title">Daftar 1. FCalculator header kelas</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"lfsaappl.h"</span></span></span><span class="hljs-meta"> enum Buttons { digit0 = 0, digit1, digit2, digit3, digit4, digit5, digit6, digit7, digit8, digit9, opPlus, opMinus, opCancel, opEqual, opNone }; class FCalculator : public LFsaAppl { public: void MooreAction(); LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FCalculator(pTAppCore, nameFsa, pCVarFsaLibrary); } FCalculator(TAppCore *pInfo, string strNam, CVarFsaLibrary *pCVFL); virtual ~FCalculator(void); public: void digitButtonPressed(int button); void operationButtonPressed(int button); private: void s1Entered(); void s2Entered(); void s3Entered(); void s3Exited(); void s5Entered(); void s5Exited(); private: int Rf, Rb; Buttons transitionButton, Op; int nTypeButtons; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 0 - none; 1 - digit button; 2 - operation button; void doOp(Buttons op); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y3(); void y5(); void y6(); void y7(); void y8(); void y9(); void y10(); int nState{2}; };</span></span></span></span></code> </pre> <br><br></div></div><br>  Mari kita jelaskan.  Dalam VKPa, setiap kelas otomat mewarisi sifat-sifat dari kelas otomat dasar LFsaAppl.  Metode Create () membuat salinan kelas yang termasuk dalam pustaka dinamis proses otomatis.  Metode MooreAction () virtual tumpang tindih ketika model otomat Moore dipilih, mendefinisikan tindakan yang terkait dengan keadaan otomat.  Metode x [n] dan y [n] adalah predikat dan tindakan yang terkait dengan saluran input / output otomat.  Algoritme perilaku kelas [otomat] diwakili oleh tabel transisi (lihat Listing 2), yang terdiri dari array string tipe LArc.  Sisa kode mengulangi kode dari Kalkulator kelas sumber. <br><br><div class="spoiler">  <b class="spoiler_title">Daftar 2. Implementasi kelas FCalculator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FCalculator.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"DlgCalculator.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ui_cdlgcalculator.h"</span></span></span><span class="hljs-meta"> static LArc TBL_Calculator[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//* LArc("1", "2","x1", "y1"), // [0-9] LArc("2", "1","x3", "y1"), // [c] LArc("2", "2","x1", "y1"), // [0-9] LArc("2", "3","x2", "y1"), // [+][-] LArc("3", "1","x3", "y3"), // [c] LArc("3", "3","x2", "y3"), // [+][-] LArc("3", "4","x1", "y3"), // [0-9] LArc("3", "5","x4", "y3"), // [=] LArc("4", "1","x3", "y1"), // [c] LArc("4", "3","x2", "y1"), // [+][-] LArc("4", "4","x1", "y1"), // [0-9] LArc("4", "5","x4", "y1"), // [=] LArc("5", "1","x3", "y5"), // [c] LArc("5", "2","x1", "y5"), // [0-9] LArc("5", "3","x2", "y5"), // [+][-] //*/ /* LArc("2", "2","x1", "y1y7"), // [0-9] LArc("2", "2","x3", "y1y6"), // [c] LArc("2", "3","x2", "y1y8"), // [+][-] LArc("3", "2","x3", "y3y6"), // [c] LArc("3", "3","x2", "y3y8"), // [+][-] LArc("3", "4","x1", "y3y7"), // [0-9] LArc("3", "5","x4", "y3y9"), // [=] LArc("4", "2","x3", "y1y6"), // [c] LArc("4", "3","x2", "y1y8"), // [+][-] LArc("4", "4","x1", "y1y7"), // [0-9] LArc("4", "5","x4", "y1y9"), // [=] LArc("5", "2","x3", "y5y6"), // [c] LArc("5", "2","x1", "y5y7"), // [0-9] LArc("5", "3","x2", "y5y8"), // [+][-] */ // LArc("1", "1","--", "y10"), // SWITCH LArc() }; FCalculator::FCalculator(TAppCore *pInfo, string strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Calculator, strNam, nullptr, pCVFL) { pTAppCore = pInfo; Rf= 0; Rb = 0; Op = opNone; } FCalculator::~FCalculator(void) { } //   int FCalculator::x1() { if (nTypeButtons != 1) return false; else return true; } //   +, - int FCalculator::x2() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton != opCancel &amp;&amp; transitionButton != opEqual ) return true; else return false; } //  Cancel int FCalculator::x3() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton == opCancel) return true; else return false; } //  opEqual int FCalculator::x4() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton == opEqual) return true; else return false; } void FCalculator::y1() { nTypeButtons = 0; } void FCalculator::y3() { s3Exited(); } void FCalculator::y5() { s5Exited(); } void FCalculator::y6() { s1Entered(); } // 1 void FCalculator::y7() { s2Entered(); } // 2, 4 void FCalculator::y8() { s3Entered(); } // 3 void FCalculator::y9() { s5Entered(); } // 5 void FCalculator::y10() { switch(nState) { case 2: if (x1()) { y1();y7(); } if (x3()) { y1();y6(); } if (x2()) { y1();y8(); nState = 3; } break; case 3: if (x3()) { y3();y6(); nState = 2; } if (x2()) { y3();y8(); } if (x1()) { y3();y7(); nState = 4; } if (x4()) { y3();y9(); nState = 5; } break; case 4: if (x3()) { y1();y6(); nState = 2; } if (x2()) { y1();y8(); nState = 3; } if (x1()) { y1();y7(); } if (x4()) { y1();y9(); nState = 5; } break; case 5: if (x3()) { y5();y6(); nState = 2; } if (x1()) { y5();y7(); nState = 2; } if (x2()) { y5();y8(); nState = 3; } break; } } void FCalculator::MooreAction() { // return; string strState = FGetState(); if (strState=="1") { y6(); } else if (strState=="2") { y7(); } else if (strState=="3") { y8(); } else if (strState=="4") { y7(); } else if (strState=="5") { y9(); } } /////////////////////////////////////////////////////////////////////////// void FCalculator::digitButtonPressed(int button) { transitionButton = static_cast&lt;Buttons&gt;(button); nTypeButtons = 1; } void FCalculator::operationButtonPressed(int button) { transitionButton = static_cast&lt;Buttons&gt;(button); nTypeButtons = 2; } void FCalculator::s1Entered() { Rf = 0; Rb = 0; Op = opNone; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } void FCalculator::s2Entered() { if (Rf &lt; 9999999) { Rf = Rf*10 + transitionButton; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } } void FCalculator::s3Entered() { if (Rb != 0) { doOp(Op); static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } Rb = Rf; Op = transitionButton; } void FCalculator::s3Exited() { nTypeButtons = 0; if (transitionButton &gt; digit9 &amp;&amp; transitionButton &lt; opCancel ) { doOp(transitionButton); Rb = 0; Op = transitionButton; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } else { Rf = 0; } } void FCalculator::s5Entered() { doOp(Op); Op = opNone; Rb = Rf; // added by me static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } void FCalculator::s5Exited() { nTypeButtons = 0; if (transitionButton &lt;= 9) { Rb = 0; Rf = 0; } } void FCalculator::doOp(Buttons op) { switch (op) { case opPlus: Rf = Rf + Rb; break; case opMinus: Rf = Rb - Rf; break; default: break; } }</span></span></span></span></code> </pre><br><br></div></div><br>  Pemberitahuan Listing 2 berisi tiga tabel lompatan (dua dikomentari).  Ini adalah bagaimana kemampuan kontrol khusus direalisasikan ketika, setelah menghapus komentar, perilaku kelas dapat diubah "dengan klik" tanpa memengaruhi metode dan propertinya.  Metode y10 dan garis yang sesuai dalam tabel transisi (lihat baris yang ditandai dengan komentar SWICH) diperkenalkan untuk memodelkan teknologi SWITCH (untuk lebih jelasnya lihat [9]) dalam kerangka teknologi VKPA.  Dalam hal ini, perilaku robot apa pun dimodelkan dengan panggilan siklik ke operator SWITCH, yang meniru perilaku robot tersebut (di sini robot VKPa bertindak sebagai lingkungan eksternal). <br><br><h4>  3.2.  Model kalkulator pasif </h4><br>  Model kalkulator aktif secara konstan memindai saluran input.  Segera setelah nilai variabel nTypeButtons menjadi nol, ini berfungsi sebagai tanda kedatangan simbol berikutnya ke input otomat.  Akibatnya, transisi dan tindakan y1 dipicu, mengatur ulang variabel nTypeButtons, memblokir mesin otomatis yang dipicu oleh karakter yang sama. <br>  Berbeda dengan model "kalkulator aktif", robot peristiwa tidak dapat, menurut definisi, memproses ulang simbol input.  Sekarang jelas bahwa "kesulitan terbesar dalam menggunakan pendekatan otomat ... dalam sistem acara" tampaknya muncul untuk menekan aktivitas automaton aktif dan menghubungkan fungsinya dengan peristiwa.  Kami menunjukkan prosedur untuk beralih ke robot pasif menggunakan contoh "kalkulator aktif" yang baru dibuat. <br>  Lingkungan VKPa berisi mode operasi selangkah demi selangkah yang diperkenalkan untuk proses debugging otomatis.  Tetapi dapat digunakan untuk mensimulasikan mesin acara.  Untuk melakukan ini, 1) mengatur ruang otomat di mana otomat ditempatkan mode operasi langkah-demi-langkah (perhatikan, bukan otomat terpisah, tetapi seluruh ruang otomat yang berisi automata), dan 2) mengaitkan momen-momen kejadian peristiwa dengan eksekusi satu langkah terpisah dari operasi ruang.  Listing 3 menunjukkan bagaimana melakukan ini, hanya mencerminkan perubahan yang dilakukan pada model (header kelas tetap tidak berubah). <br><br><div class="spoiler">  <b class="spoiler_title">Listing 3. Varian akhirnya dari kelas FCalculator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> LArc TBL_Calculator[] = { LArc(<span class="hljs-string"><span class="hljs-string">"st"</span></span>, <span class="hljs-string"><span class="hljs-string">"st"</span></span>,<span class="hljs-string"><span class="hljs-string">"^x12"</span></span>, <span class="hljs-string"><span class="hljs-string">"y12"</span></span>), <span class="hljs-comment"><span class="hljs-comment">// LArc("st", "1","x12", "y11"), // // ... }; ... //   bool FCalculator::FCreationOfLinksForVariables() { pNet = GetPointerToNet(); //    if (pNet) { string str = pNet-&gt;strName; //    //  -  pSV = this-&gt;pTAppCore-&gt;pSetVarSetting-&gt;GetAddressVar(const_cast&lt;char*&gt;(str.c_str())); } return true; } ... // int FCalculator::x12() { if (!pNet) return false; if (!pSV) return false; return true; } ... //    step-by-step void FCalculator::y11() { pSV-&gt;bIfStepByStep = true; } //   void FCalculator::y12() { FCreationOfLinksForVariables(); } // ... ///////////////////////////////////////////////////////////////////////////////////////////////////////////////// void FCalculator::digitButtonPressed(int button) { ... pSV-&gt;bIfStopAllTasks = false; //     } void FCalculator::operationButtonPressed(int button) { ... pSV-&gt;bIfStopAllTasks = false; //     } ...</span></span></code> </pre><br><br></div></div><br>  Di sini, pertama, status [awal] tambahan diperkenalkan, di mana referensi ke ruang di mana mesin berada, dan tautan ke objek yang menentukan sifat-sifat ruang (termasuk mode operasinya) diperiksa.  Eh membentuk aksi y12.  Ketika tautan diatur, ada transisi ke keadaan awal [sebelumnya] dari model kalkulator dengan pemasangan mode operasi langkah-demi-langkah dari ruang otomat. <br><br>  Lebih lanjut, model ini beroperasi dalam mode operasi ruang angkasa selangkah demi selangkah.  Peluncuran satu langkah mengimplementasikan kode yang dimasukkan ke event handler yang terkait dengan input karakter berikutnya (lihat Listing 3 untuk perubahan yang dilakukan pada digitTombol Ditekan dan metode operasiTombol Ditekan). <br><br><h3>  4. Mengapa? </h3><br>  Mengapa menemukan sesuatu, jika ada, seperti yang dapat diasumsikan, model acara D. Harel yang lebih maju.  Dan bagaimana cara berpikir yang berbeda jika dijalankan di UML, Stateflow, di perpustakaan Qt, dll.  dll.  dan tidak ada banyak panik tentang kekurangannya.  Nah, mereka menyebut peristiwa sinyal, dan mengubah mesin aktif menjadi pasif ... Dan jika model, seperti yang mereka katakan, juga secara formal setara dengan mesin Mili / Moore klasik, lalu bagaimana tidak percaya?  Dan begitulah, jika semua pernyataan ini diambil hanya dengan iman ... <br><br>  Ikuti awal acara (ini persis seperti yang kami lakukan di atas).  Otomat struktural klasik memiliki, misalnya, banyak saluran input, yang masing-masing terkait dengan sinyal, dan mereka dapat diproses secara bersamaan / secara paralel.  Tetapi UML mengatakan bahwa ‚Äúsetiap objek hanya dapat memproses satu peristiwa pada satu waktu‚Äù dan bahkan ‚Äújika dua peristiwa terjadi secara bersamaan, objek tersebut masih akan memprosesnya satu per satu‚Äù [10].  Dengan demikian, pada tingkat definisi, sinyal dan peristiwa adalah setara, tetapi idyll runtuh dalam proses implementasi transisi model. <br><br>  Pertimbangkan contoh yang dengannya saya mulai menguji / mempelajari bahasa atau teknologi apa pun.  Ini tentang implementasi perangkat lunak dari model elemen AND-NOT.  Pada tingkat struktural, itu sesuai dengan "kotak hitam", yang memiliki dua saluran input dan satu output, dan pada yang algoritmik, otomat ditunjukkan pada Gambar.  4. <br><br><img src="https://habrastorage.org/webt/6q/7d/ve/6q7dve1toup6onrda9kkjsqzg2u.jpeg" alt="gambar"><br>  <i>Fig.</i>  <i>4. Model otomat elemen DAN TIDAK</i> <br><br>  Bagaimana cara membuat model prosedural reguler (lihat Listing 4) atau bagaimana mengimplementasikan otomaton dalam VKPa (lihat Listing 5) dapat dimengerti, tetapi bagaimana mengulang ini berdasarkan automaton event dari perpustakaan Qt tidak begitu jelas karena masalah implementasi transisi dari negara ‚Äú1‚Äù untuk menyatakan "0", yang memerlukan analisis simultan dari beberapa peristiwa. <br><br>  Listing 4. Obyek implementasi model prosedural AND-NOT <br><br><div class="spoiler">  <b class="spoiler_title">Listing 4. Obyek implementasi model prosedural AND-NOT</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INE</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: INE() {} ~INE(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bX1, bX2, bY; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bY = !(bX1&amp;&amp;bX2); } };</code> </pre><br><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Listing 5. Obyek implementasi model AND-NOT automaton</b> <div class="spoiler_text"><pre> <code class="cpp hljs">LArc T_INE[] = { LArc(<span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"x1x2"</span></span>, <span class="hljs-string"><span class="hljs-string">"y1"</span></span>), LArc(<span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"^x1"</span></span>, <span class="hljs-string"><span class="hljs-string">"y2"</span></span>), LArc(<span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"^x2"</span></span>, <span class="hljs-string"><span class="hljs-string">"y2"</span></span>), }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ine</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LFsaAppl { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Ine(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> strNam = <span class="hljs-string"><span class="hljs-string">"-"</span></span>): LFsaAppl(T_INE, strNam) {} ~Ine(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bX1, bX2; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bX1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bX2; } };</code> </pre><br><br></div></div>  Dengan demikian, biarkan implementasi model acara elemen NAND dalam kerangka kerja kelas otomat Qt menjadi "pekerjaan rumah" bagi warga Habrovans.  Saya hanya bisa mengutip keputusannya di Stateflow sebagai "cherry on the cake".  Itu ditunjukkan dalam gambar.  5. Bantuan Stateflow digunakan di sini, yang memungkinkan tidak menandai transisi dengan suatu peristiwa: jika nama acara tidak ditentukan, maka transisi akan terjadi ketika peristiwa apa pun terjadi (lihat label transisi pada [13] untuk contoh). <br><br><img src="https://habrastorage.org/webt/_9/j7/4e/_9j74efmsk0ema7itfdezvpmfca.jpeg" alt="gambar"><br>  <i>Fig.</i>  <i>5. Model otomat elemen AND-NOT di Stateflow</i> <br><br>  Dengan demikian, mesin negara adalah model mesin hybrid (aktif-pasif).  Benar, tidak jelas bagaimana mesin akan berperilaku tanpa adanya peristiwa sama sekali.  Dapat diasumsikan bahwa itu akan "membeku" untuk mengantisipasi peristiwa.  Dan jika tidak?  Yaitu  pada akhirnya, itu masih lebih cenderung pasif daripada model mesin yang aktif.  Meskipun hanya dalam penampilan, sulit untuk membedakan dari yang terakhir. <br><br><h3>  5. Kesimpulan </h3><br>  Sehubungan dengan peristiwa, kita dapat mengatakan bahwa, karena aktivitas, implementasi model klasik automata terlihat lebih disukai daripada model automata sinkron.  Jika kita berbicara tentang pemrograman otomatis secara umum, paket ekstensi Stateflow menunjukkan jenis pemrograman yang benar-benar berbeda.  Tapi, sayangnya, sejauh ini hanya dalam perspektif, karena  masalah tetap karena model komputasi Stateflow, yang pada dasarnya tetap diagram blok.  Tampaknya tepat karena alasan ini, bersama dengan automata, pemrograman visual di Statefow diwakili oleh notasi diagram alur. <br><br>  Untuk mengetahui di mana pemrograman otomatis sebenarnya, dan di mana tiruannya, adalah salah satu tujuan utama kami.  Dalam artikel sebelumnya [5], kami memecahkan salah satu tugas dasar yang diajukan - kami merumuskan konsep program otomat.  Selanjutnya, Anda perlu berurusan dengan definisi model manajemen program, yang seharusnya menjadi otomat-terbatas dan menjadi efektif dan nyaman untuk programmer. <br><br>  Setelah menangani berbagai peristiwa, kami meletakkan dasar untuk pekerjaan semacam itu.  Dalam artikel selanjutnya, kita akan sudah memahami detail model yang diusulkan oleh D. Harel.  Berjalan sedikit di depan, kami katakan bahwa, terus terang saja, dia mendistorsi pemahaman automata.  Tetapi, di sisi lain, di sini kita harus memberikan haknya, dia mengungkapkan masalah yang tidak akan memungkinkan, tanpa dia, untuk membentuk pemrograman otomatis yang efektif dalam kerangka model klasik yang akan menarik para programmer. <br><br>  Kami menemukan di atas bahwa, setidaknya, pada tingkat acara, automata klasik tidak memiliki masalah.  Kami akan mengerti lebih jauh ... Sementara itu, ini hanya permulaan.  Kami sedang menunggu banyak hal menarik, dan, perhatikan, tidak melampaui teori klasik automata.  Ini sangat penting jika kita ingin pemrograman yang benar-benar otomatis.  Semoga sukses!  :) <br><br><h3>  Referensi </h3><br>  1. Borovsky A.N.  Qt4.7.  Praktis pemrograman C ++.  - SPb.: BHV-Petersburg, 2012 .-- 496 hal. <br>  2. BUCH G., RAMBO J., JACOBSON I. UML.  Panduan pengguna.  Edisi kedua.  Akademiya IT: Moscow, 2007 .-- 493 hal. <br>  3. Shalyto A. A. Kuliah baru tentang pemrograman otomatis.  2019, [Sumber daya elektronik], <a href="https://www.youtube.com/watch%3Fv%3DPPWTxceMutk%26feature%3Dyoutu.be" rel="nofollow">Mode</a> akses: <a href="https://www.youtube.com/watch%3Fv%3DPPWTxceMutk%26feature%3Dyoutu.be" rel="nofollow">www.youtube.com/watch?v=PPWTxceMutk&amp;feature=youtu.be</a> , gratis.  Yaz.  Rusia  (tanggal perawatan 5 Desember 2019). <br>  4. Stateflow.  <a href="https://www.mathworks.com/products/stateflow.html" rel="nofollow">www.mathworks.com/products/stateflow.html</a> , gratis.  Yaz.  Bahasa inggris  (tanggal sirkulasi 7.01.2020). <br>  5. Mesin Turing, sebagai model program otomat.  <a href="https://habr.com/ru/post/481998/">habr.com/en/post/481998</a> , gratis.  Yaz.  Rusia  (tanggal sirkulasi 7.01.2020). <br>  6. Melikhov A.N.  Grafik berorientasi dan mesin negara hingga.  - M.: Nauka, 1971. - 416 hal. <br>  7. KUDRYAVTSEV VB, Aleshin S.V., PODKOLZIN A.S.  Pengantar teori automata - M.: Ilmu.  Ch.  ed.  Fisika-Matematika.  lit., 1985.-- 320 hal. <br>  8. Tukkel N.I., Shalyto A.A.  Implementasi automata saat pemrograman sistem acara.  "Programmer", 2002. No. 4.  C.74-80. <br>  9. Polikarpova N., A. Shalyto A. pemrograman Automaton.  2nd ed., St. Petersburg.: Peter, 2011 .-- 176 hal. <br>  10. Rambo J., Jacobson A., Butch G. UML: referensi khusus.  - St. Petersburg: Peter, 2002 .-- 656 hal. <br>  11. Goma H. ‚Äã‚ÄãUML.  Desain sistem waktu-nyata, aplikasi paralel dan terdistribusi: Per.  dari bahasa inggris  - M.: DMK Press, 2002. - 2002. - 704 p. <br>  12. SHALYTO A.A.  Teknologi BERALIH.  Algoritma dan pemrograman tugas kontrol logika.  St. Petersburg: Nauka, 1998.628 s. <br>  13. Rogachev G.N.  Stateflow notations.  <a href="http://bourabai.kz/cm/stateflow13.htm" rel="nofollow">bourabai.kz/cm/stateflow13.htm</a> , gratis.  Yaz.  Rusia  (tanggal banding 01.10.2020). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483610/">https://habr.com/ru/post/id483610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483594/index.html">Ekonomi masa depan untuk fisikawan</a></li>
<li><a href="../id483598/index.html">Bahkan lebih banyak telur Paskah yang musikal: kami terus berbicara tentang hadiah untuk pendengar yang penuh perhatian</a></li>
<li><a href="../id483602/index.html">Konferensi DefCon 27: Di Balik Layar Membuat Lencana Elektronik Bagian 2</a></li>
<li><a href="../id483604/index.html">Iridium: menerima dan mendekode sinyal konstelasi satelit di rumah</a></li>
<li><a href="../id483608/index.html">Visualisasi batas-batas solusi classifier berbasis gambar</a></li>
<li><a href="../id483612/index.html">Pengemudi Tesla didenda karena menyikat giginya saat mengemudi dengan autopilot</a></li>
<li><a href="../id483614/index.html">Metode memerangi pencurian di klub robotika</a></li>
<li><a href="../id483616/index.html">Proyek Lacmus: Bagaimana Visi Komputer Membantu Menyelamatkan Orang yang Hilang</a></li>
<li><a href="../id483624/index.html">Persaingan dari Yandex.Taxi: analisis trek backend kejuaraan pemrograman</a></li>
<li><a href="../id483626/index.html">Cara menggambarkan pekerjaan 100 gitlab dalam 100 baris di Jsonnet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>