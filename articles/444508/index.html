<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüíº üçØ ü§∞üèª C√≥mo creamos PHP 7 el doble de r√°pido que PHP 5. Parte 1: optimizaci√≥n de estructuras de datos ‚úäüèΩ üë´ üêøÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En diciembre de 2015 , se lanz√≥ PHP 7.0. Las compa√±√≠as que cambiaron al "siete" notaron que la productividad ha aumentado y la carga en el servidor ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo creamos PHP 7 el doble de r√°pido que PHP 5. Parte 1: optimizaci√≥n de estructuras de datos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/444508/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">En diciembre de 2015</a> , se lanz√≥ PHP 7.0.  Las compa√±√≠as que cambiaron al "siete" notaron que la productividad ha aumentado y la carga en el servidor ha disminuido.  Los primeros en pasar a los siete fueron Vebia y Etsy, y tenemos a Badoo, Avito y OLX.  Para Badoo, cambiar a los siete le cost√≥ $ 1 mill√≥n en ahorros de servidor.  Gracias a PHP 7 en OLX, la carga promedio del servidor disminuy√≥ 3 veces, aument√≥ la eficiencia y el ahorro de recursos. <br><br>  <strong>Dmitry Stogov</strong> de Zend Technologies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habl√≥</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++</a> , lo que aument√≥ la productividad.  En la decodificaci√≥n: sobre la estructura interna de PHP, sobre las ideas centrales de la versi√≥n 7.0, sobre los cambios en las estructuras de datos b√°sicos y los algoritmos que determinaron el √©xito. <br><br>  <em>Descargo de responsabilidad: a partir de marzo de 2019, el</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>80% de los sitios se</em></a> <em>ejecutan en PHP, y el</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>70% de ellos se</em></a> <em>ejecutan en</em> <em>PHP 5, aunque</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>esta versi√≥n no se admite</em></a> <em>desde el 1 de enero de 2019</em> <em>.</em>  <em>El informe de 2016 de Dmitry sobre los principios por los cuales hubo un doble salto en la productividad entre PHP 5 y 7 tambi√©n es relevante en marzo de 2019. Para la mitad de los sitios, seguro.</em> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/tHapNKpacSQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <strong>Sobre el orador: Dmitry Stogov</strong> comenz√≥ a programar en los a√±os 80: "Electronics B3-34", Basic, ensamblador.  En 2002, Dmitry se familiariz√≥ con PHP y pronto comenz√≥ a trabajar para mejorarlo: desarroll√≥ Turck MMCache para PHP, dirigi√≥ el proyecto PHPNG y desempe√±√≥ un papel importante en el trabajo en JIT para PHP.  Los √∫ltimos 14 a√±os de ingeniero principal en Zend Technologies. <br><br>  Zend Technologies est√° desarrollando PHP y soluciones comerciales basadas en √©l.  En 1999, fue fundada por los programadores israel√≠es Andy Gutmans y Zeev Suraski, que hace dos a√±os crearon PHP 3. Estas personas estuvieron a la vanguardia del desarrollo de PHP y determinaron en gran medida el aspecto actual del lenguaje y el √©xito de la tecnolog√≠a. <br><br>  Zend Technologies desarrolla el n√∫cleo de PHP y las aplicaciones para √©l, y durante el trabajo tuve que escribir extensiones, entrar en todos los subsistemas e incluso participar en proyectos comerciales, a veces nada relacionados con PHP.  Pero el tema m√°s interesante para m√≠ siempre ha sido el <strong>rendimiento</strong> . <br><br>  Empec√© a buscar formas de acelerar PHP incluso antes de unirme a Zend, trabajando en mi propio proyecto que compet√≠a con la compa√±√≠a.  Durante el trabajo en el proyecto, entend√≠ completamente el lenguaje y me di cuenta de que trabajar no con el proyecto principal, solo puede influir en ciertos aspectos de la ejecuci√≥n del script, y todo lo m√°s interesante y efectivo solo se puede crear <strong>en el n√∫cleo</strong> .  Esta comprensi√≥n y coincidencia me llevaron a Zend. <br><br><h2>  Una peque√±a digresi√≥n en la historia de PHP </h2><br>  PHP no es solo y <strong>no solo un lenguaje de programaci√≥n</strong> .  PHP significa P√°gina de inicio personal: una herramienta para crear p√°ginas web personales y sitios web din√°micos.  El idioma es solo una de sus partes principales.  PHP es una gran biblioteca de funciones, muchas extensiones para trabajar con otras bibliotecas de terceros, por ejemplo, para acceder a la base de datos o analizadores XML, as√≠ como un conjunto de m√≥dulos para comunicarse con varios servidores web. <br><br>  El programador dan√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rasmus Lerdorf</a> present√≥ PHP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en junio de 1995</a> .  En ese momento, era solo una <strong>colecci√≥n de scripts CGI escritos en Perl</strong> .  En abril de 96, Rasmus introdujo PHP / FI, y en junio se lanz√≥ PHP / FI 2.0.  Posteriormente, Andy Gutmans y Zeev Surasky reelaboraron sustancialmente esta versi√≥n, y en el 98th lanz√≥ PHP 3.0.  Para el a√±o 2000, el lenguaje lleg√≥ al tipo que estamos acostumbrados a ver hoy tanto en t√©rminos de lenguaje como de arquitectura interna: PHP 4, basado en Zend Engine. <br><br>  Desde la versi√≥n 4, PHP ha evolucionado.  El punto de inflexi√≥n fue el lanzamiento de PHP 5 en 2004, cuando el <strong>modelo de objetos se actualiz√≥ por completo</strong> .  Fue ella quien abri√≥ la era de los frameworks PHP y plante√≥ la cuesti√≥n del rendimiento a un nuevo nivel.  Anticipando esto, inmediatamente despu√©s del lanzamiento de 5.0, en Zend pensamos en acelerar PHP y comenzamos a trabajar para mejorar la productividad. <br><br>  La versi√≥n 7.1, que se lanz√≥ en noviembre de 2016 en pruebas sint√©ticas, <strong>es 25 veces m√°s r√°pida que la versi√≥n 2002</strong> .  Seg√∫n el gr√°fico de cambios de rendimiento en diferentes ramas, los principales avances son visibles en 5.1 y 7.0. <br><br><img src="https://habrastorage.org/webt/ao/_s/mp/ao_smpopukfzjmclxqqu83xefvo.png"><br><br>  En la versi√≥n 5.1, comenzamos a trabajar en el rendimiento y obtuvimos todo lo que asumimos, pero despu√©s de 5.3 nos topamos con una pared, todos los intentos de mejorar el int√©rprete quedaron en nada. <br><br>  Sin embargo, encontramos d√≥nde cavar y obtuvimos a√∫n m√°s de lo esperado: aceleraci√≥n de 2.5 veces en comparaci√≥n con la versi√≥n 5.6 anterior en las pruebas.  Pero lo m√°s interesante es que obtuvimos la misma aceleraci√≥n de 2.5 veces en aplicaciones reales sin cambios.  Este es un fen√≥meno, porque desarrollamos el factor 2 anterior a lo largo de la vida de los cinco en 10 a√±os. <br><br><img src="https://habrastorage.org/webt/ge/9j/n_/ge9jn_isn9hxm-gbrk0ahaexfms.png"><br><br>  El gran salto en 5.1 en pruebas sint√©ticas no se nota en aplicaciones reales.  La raz√≥n es que con diferentes usos, el rendimiento de PHP se basa en los frenos asociados con diferentes subsistemas. <br><br>  <strong>La historia de PHP 7 comienza con un estancamiento de tres a√±os</strong> que comenz√≥ en 2012 y termin√≥ en 2015 con el lanzamiento de la s√©ptima versi√≥n.  Luego nos dimos cuenta de que ya no pod√≠amos aumentar la productividad con peque√±as mejoras de nuestro int√©rprete y pasamos al lado de JIT. <br><br><h2>  Deambulando por JIT </h2><br>  Pasamos casi dos a√±os en el prototipo JIT para PHP-5.5.  Al principio, generamos un c√≥digo muy simple: una secuencia de llamadas para controladores est√°ndar, algo as√≠ como un c√≥digo Fort cosido.  Luego escribieron su propio <strong>Runtime Assembler</strong> , un c√≥digo separado en l√≠nea para soluciones alternativas, pero se dieron cuenta de que tales <strong>optimizaciones de bajo nivel no daban</strong> efecto <strong>pr√°ctico</strong> incluso en las pruebas. <br><br>  Luego pensamos en derivar tipos de variables utilizando m√©todos de an√°lisis est√°tico.  Al darnos cuenta de la conclusi√≥n, de inmediato recibimos <strong>una aceleraci√≥n de 2 veces en las pruebas.</strong>  Animados, intentaron escribir asignadores de registros globales, pero fallaron.  Usamos una representaci√≥n de alto nivel y era casi imposible usarla para la asignaci√≥n de registros. <br><br>  Para evitar problemas de bajo nivel, decidimos probar LLVM, y un a√±o despu√©s obtuvimos una <strong>aceleraci√≥n 10x para bench.php</strong> , pero nada en aplicaciones reales.  Adem√°s, compilar aplicaciones reales ahora tom√≥ minutos, por ejemplo, la primera <strong>solicitud a Wordpress tom√≥ 2 minutos y no dio aceleraci√≥n.</strong>  Por supuesto, esto era completamente inadecuado para la pr√°ctica real. <br><br><blockquote>  Un buen c√≥digo es posible con una predicci√≥n de tipo adecuada, que funciona mal en aplicaciones reales, y el uso de estructuras de datos PHP hace que el c√≥digo generado sea ineficiente. </blockquote><br><h3>  ¬øQu√© se ralentiza? </h3><br>  Repensamos las razones de las fallas y decidimos una vez m√°s ver por qu√© PHP es lento.  La imagen muestra el resultado del perfil de varias solicitudes a la p√°gina de inicio de Wordpress. <br><br><img src="https://habrastorage.org/webt/3w/dh/7v/3wdh7vd40xumtwtyqgshsdan-a8.png"><br><br>  Menos del 30% se gasta en la interpretaci√≥n de bytecode, el 20% es la sobrecarga del administrador de memoria, el 13% est√° trabajando con tablas hash y el 5% est√° trabajando con expresiones regulares. <br><br>  Trabajando para JIT, nos libramos solo del primer 30%, y todo lo dem√°s yac√≠a en peso muerto.  Casi en todas partes, nos vimos obligados a usar estructuras de datos PHP est√°ndar, lo que implicaba una sobrecarga: asignaci√≥n de memoria, conteo de referencias, etc.  Esta comprensi√≥n llev√≥ a la conclusi√≥n de que es necesario reemplazar las estructuras de datos clave en PHP.  Con esta <strong>sustituci√≥n de la fundaci√≥n</strong> , <strong>comenz√≥ el</strong> proyecto <strong>PHPNG.</strong> <br><br><h2>  Phpng  Nueva generacion </h2><br>  El proyecto se desarroll√≥ despu√©s de intentos fallidos de crear JIT para PHP.  El objetivo principal es <strong>lograr un nuevo nivel de productividad y sentar las bases para futuras mejoras</strong> . <br><br>  Nos prometimos por un tiempo que ya no usaremos pruebas sint√©ticas para medir el rendimiento; estos son generalmente peque√±os programas inform√°ticos que usan una cantidad limitada de datos que se ajusta completamente en la memoria cach√© del procesador.  Las aplicaciones reales, por el contrario, est√°n sujetas a los frenos asociados con la memoria del subsistema, y ‚Äã‚Äãuna sola lectura de la memoria puede costar 100 instrucciones computacionales.  <strong>El proyecto PHPNG es una refactorizaci√≥n de estructuras clave de datos PHP para optimizar el acceso a la memoria</strong> .  Sin innovaci√≥n, 100% compatible con PHP 5. <br><br>  C√≥mo cambiar estas estructuras estaba claro.  Pero el volumen de cambios dependientes fue enorme, porque el <strong>n√∫cleo de PHP en</strong> s√≠ <strong>era de 150,000 l√≠neas</strong> , y casi cada tercio necesitaba ser cambiado.  Agregue cien extensiones m√°s que se incluyen en la distribuci√≥n base, una docena de m√≥dulos para diferentes servidores web y se dar√° cuenta de la grandeza del proyecto. <br><br>  Ni siquiera est√°bamos seguros de que terminar√≠amos el proyecto.  Por lo tanto, lanzaron el proyecto en secreto y lo abrieron solo cuando aparecieron los primeros resultados optimistas.  Tom√≥ dos semanas simplemente <strong>compilar el n√∫cleo</strong> .  Dos semanas despu√©s, bench.php gan√≥.  Pasamos un mes y medio para apoyar Wordpress.  Un mes despu√©s, abrimos el proyecto: era mayo de 2014.  En ese momento, tuvimos una <strong>aceleraci√≥n del 30% en Wordpress</strong> .  Ya parec√≠a un gran evento. <br><br>  PHPNG despert√≥ inmediatamente una ola de inter√©s, y en agosto de 2014 se <strong>adopt√≥ como base para el futuro de PHP 7</strong> .  Ya era otro proyecto, con un conjunto diferente de objetivos, donde la productividad era solo uno de ellos. <br><br><h2>  PHP 7.0 </h2><br>  La versi√≥n n√∫mero 7 en s√≠ estaba en duda.  La versi√≥n anterior era la quinta.  Y el sexto se desarroll√≥ hace varios a√±os y estaba completamente dedicado al <strong>soporte</strong> nativo de <strong>Unicode</strong> , pero las decisiones fallidas tomadas en las primeras etapas de desarrollo llevaron a una complejidad excesiva del c√≥digo del n√∫cleo y cada extensi√≥n.  Al final, se decidi√≥ congelar el proyecto. <br><br>  En este momento, ya se hab√≠a acumulado una gran cantidad de material dedicado a PHP 6: discursos en conferencias, libros publicados.  Para no confundir a nadie, llamamos al proyecto PHP 7, omitiendo PHP 6. Esta versi√≥n fue mucho m√°s afortunada: PHP 7 se lanz√≥ en diciembre de 2015, casi de acuerdo con el plan. <br><br>  Adem√°s del rendimiento, aparecieron algunas innovaciones muy buscadas en PHP 7: <br><br><ul><li>  Capacidad para definir tipos escalares de par√°metros y valores de retorno. </li><li>  Excepciones en lugar de errores: ahora podemos detectarlos y procesarlos. </li><li> <code>Zero-cost assert()</code> , clases an√≥nimas, inconsistencias de limpieza, nuevos operadores y funciones (&lt;=&gt;, ??) aparecieron. </li></ul><br>  La innovaci√≥n es buena, pero volviendo a los cambios internos.  Hablemos sobre el camino que ha seguido PHP 7 y hacia d√≥nde nos puede llevar este camino. <br><br><h2>  zval </h2><br>  Esta es la estructura b√°sica de datos PHP.  Se utiliza para <strong>representar cualquier valor en PHP</strong> .  Como nuestro lenguaje se escribe din√°micamente y el tipo de variables puede cambiar durante la ejecuci√≥n del programa, necesitamos almacenar un campo de tipo (tipo zend_uchar), que puede tomar los valores IS_NULL, IS_BOOL, IS_LONG, IS_DOUBLE, IS_ARRAY, IS_OBJECT, etc., y en realidad El valor representado por la uni√≥n (valor), donde se puede almacenar un n√∫mero entero, n√∫mero real, cadena, matriz u objeto. <br><br><h3>  zval en PHP 5 </h3><br>  La memoria para cada estructura se asign√≥ por separado en el mont√≥n.  Adem√°s del tipo y el valor, tambi√©n conten√≠a un contador de referencias a la estructura.  Entonces, la estructura tom√≥ 24 bytes, sin contar la sobrecarga del administrador de memoria y el puntero a ella. <br><br>  La imagen en la parte superior derecha muestra las estructuras de datos que se crearon en la memoria de PHP 5 para un script simple. <br><br><img src="https://habrastorage.org/webt/m8/km/ix/m8kmixgehjrhtxthe-gefmmi86i.png"><br><br>  En la pila, se asign√≥ memoria para 4 variables representadas por punteros.  Los valores mismos (zval) est√°n en el mont√≥n.  En nuestro caso, estos son solo dos zval, cada uno de los cuales est√° referenciado por dos variables, y en consecuencia sus contadores de referencia se establecen en 2. <br><br>  Para acceder a un tipo o un valor escalar, necesita al menos dos lecturas: primero lea el valor del puntero y luego el valor de la estructura.  Si necesita leer no un valor escalar, sino, por ejemplo, parte de una cadena o matriz, necesitar√° al menos una lectura m√°s. <br><br><h3>  zval en PHP 7 </h3><br>  Donde usamos punteros antes, en los siete comenzamos a incrustar zval.  Nos hemos alejado del recuento de referencias para tipos escalares.  El tipo y el valor de los campos se mantuvieron sin cambios significativos, pero se agregaron algunas banderas m√°s y un lugar reservado, del que hablar√© un poco m√°s adelante. <br><br><img src="https://habrastorage.org/webt/tz/we/yn/tzweyn8n32_rntdwwjxhz-fbwc4.png"><br><br>  A la izquierda es lo que parec√≠a en PHP 5, y a la derecha, en PHP 7. <br><br><img src="https://habrastorage.org/webt/5n/wl/4h/5nwl4hrqaqr2kb4pmenzvbtrnh4.png"><br><br>  Ahora los mismos zval est√°n en la pila.  Para leer tipos y valores escalares, solo una instrucci√≥n de m√°quina es suficiente.  Todos los valores se agrupan en un √°rea de memoria, lo que significa que cuando trabajemos con variables locales, pr√°cticamente no tendremos p√©rdidas debido a errores en la memoria cach√© del procesador.  Pero el verdadero poder del nuevo rendimiento se incluye cuando se necesita copiar. <br><br><h3>  Copiar registro </h3><br>  En la l√≠nea superior del gui√≥n, se agreg√≥ otra asignaci√≥n. <br><br><img src="https://habrastorage.org/webt/kb/yr/ww/kbyrwwvzaeuqpt8quf1lyujztjo.png"><br><br>  En PHP5, asignamos memoria del mont√≥n para el nuevo zval, inicializamos su int (2), cambiamos el valor del puntero a la variable b y disminuimos el contador de referencia del valor al que b se hab√≠a referido previamente. <br><br>  En PHP 7, simplemente <strong>inicializamos la variable b directamente en su lugar con unas pocas instrucciones</strong> , mientras que en PHP 5 requer√≠a cientos de instrucciones.  Entonces zval se ve ahora en la memoria. <br><br><img src="https://habrastorage.org/webt/ax/ab/sa/axabsadvso8c49azoqvvks5jsfc.png"><br><br>  Estas son dos palabras de 64 bits.  La primera palabra es <strong>significado:</strong> entero, real o puntero.  En la segunda palabra, el <strong>tipo</strong> (dice c√≥mo interpretar el significado), las banderas y un lugar reservado que a√∫n se agregar√≠a al alinear.  Pero no desaparece, sino que es utilizado por diferentes subsistemas para almacenar valores relacionados indirectamente. <br><br>  <strong>Las banderas son un conjunto de bits</strong> donde cada bit indica si zval admite un protocolo.  Por ejemplo, si es <code>IS_TYPE_REFCOUNTED</code> , cuando trabaje con este zval, el motor debe cuidar el valor del contador de referencia.  Al asignar, aumente; al salir del alcance, disminuya; si el contador de referencia llega a cero, destruya la estructura dependiente. <br><br>  De los tipos, en comparaci√≥n con PHP 5, aparecieron varios nuevos. <br><br><ul><li>  <code>IS_UNDEF</code> : un marcador de una variable no inicializada. </li><li>  El <code>IS_BOOL</code> √∫nico <code>IS_BOOL</code> reemplaz√≥ por <code>IS_FALSE</code> e <code>IS_TRUE</code> por separado. </li><li>  Se agreg√≥ un tipo separado para enlaces y algunos tipos m√°gicos m√°s. </li></ul><br>  Los tipos de <code>IS_UNDEF</code> a <code>IS_DOUBLE</code> son escalares y no requieren memoria adicional.  Para copiarlos, es suficiente copiar la primera palabra de m√°quina de 64 bits con un valor y la mitad del segundo con un tipo y banderas. <br><br><h3>  Reembolsado </h3><br>  Con otros tipos m√°s dif√≠ciles.  Todos est√°n representados por una estructura subordinada, y zval simplemente almacena una referencia a esta estructura.  Para cada tipo, esta estructura es diferente, pero en t√©rminos de OOP, todos tienen un ancestro abstracto com√∫n o estructura zend_refcounted.  Determina el formato de la primera <strong>palabra de 64 bits</strong> , donde se almacenan el recuento de referencia y otra informaci√≥n para el recolector de basura. <br><br><img src="https://habrastorage.org/webt/vn/zm/yy/vnzmyywum831lpzipgxtenm_98s.png"><br><br>  Esta palabra puede considerarse simplemente como informaci√≥n para el recolector de basura, y las estructuras para tipos espec√≠ficos agregan sus campos despu√©s de esta primera palabra. <br><br><h3>  L√≠neas </h3><br>  En el siete para la cadena, almacenamos el valor calculado de la funci√≥n hash, su longitud y los propios caracteres.  El tama√±o de dicha estructura es variable y depende de la longitud de la cadena.  La funci√≥n hash se calcula para la cadena una vez, cuando sea necesario.  En PHP 5, se volvi√≥ a calcular en cada necesidad. <br><br><img src="https://habrastorage.org/webt/em/2t/ax/em2tax1wdnckpbzqxjh1tlqn37o.png"><br><br>  Ahora las cadenas se han convertido en contables de referencia, y si en PHP 5 copiamos los propios caracteres, ahora es suficiente para aumentar el recuento de referencias para esta estructura. <br><br>  Como en PHP 5, todav√≠a tenemos el concepto de <strong>cadenas inmutables o internados</strong> .  Por lo general, existen en una instancia, viven hasta el final de la consulta y pueden comportarse como valores escalares.  No necesitamos ocuparnos del contador de referencias a ellos, y para copiar es suficiente copiar solo zval con la ayuda de cuatro instrucciones de m√°quina. <br><br><h3>  Matrices </h3><br>  Las matrices est√°n representadas por una tabla hash incorporada y no son muy diferentes de PHP 5. La tabla hash en s√≠ misma ha cambiado, pero m√°s sobre eso por separado. <br><br><img src="https://habrastorage.org/webt/_u/kn/ls/_uknlsdbw247d7whq_-euez8zuw.png"><br><br>  Las matrices ahora son una <strong>estructura adaptativa</strong> que cambia ligeramente su estructura interna y su comportamiento seg√∫n los datos almacenados.  Si almacenamos solo elementos con teclas num√©ricas cercanas, entonces tenemos acceso a los elementos directamente por √≠ndice con una velocidad comparable a la velocidad de las matrices en C.Pero si agrega un elemento con una clave de cadena a la misma matriz, se convierte en un hash real con resoluci√≥n de colisi√≥n. <br><br>  As√≠ es como se ve la tabla hash en PHP 5. <br><br><img src="https://habrastorage.org/webt/d6/c-/6r/d6c-6rvue6zlsyyhnscfyjtnjj4.png"><br><br>  Esta es una implementaci√≥n cl√°sica de tabla hash con resoluci√≥n de colisi√≥n utilizando listas lineales (se muestra en la esquina superior derecha).  Cada art√≠culo est√° representado por un cubo.  Todos los cubos est√°n vinculados por listas doblemente vinculadas para resolver colisiones, y vinculados por otra lista doblemente vinculada para iterar en orden.  Los valores para cada zval se asignan por separado: en Bucket solo almacenamos un enlace a √©l.  Adem√°s, las claves de cadena se pueden asignar por separado. <br><br>  Por lo tanto, para cada tabla hash, debe asignar muchos bloques peque√±os de memoria y, para encontrar algo m√°s adelante, debe ejecutar los punteros.  Cada transici√≥n de este tipo puede causar una p√©rdida de velocidad y un retraso de ~ 10-100 ciclos de procesador. <br><br>  Esto es lo que sucedi√≥ en PHP 7. <br><br><img src="https://habrastorage.org/webt/g_/mk/ax/g_mkaxt7a0ua8shao-rzketmjag.png"><br><br>  La estructura l√≥gica se mantuvo sin cambios, solo cambi√≥ la f√≠sica.  Ahora, bajo una tabla hash, la memoria se asigna con una operaci√≥n. <br><br>  En la imagen, en la parte inferior del puntero base, hay elementos, y en la parte superior hay una matriz hash a la que se dirige una funci√≥n hash.  Para las matrices planas o empaquetadas, cuando almacenamos solo elementos con √≠ndices num√©ricos, la parte superior no se asigna en absoluto, y abordamos el Bucket directamente por n√∫mero. <br><br>  Para omitir elementos, los ordenamos secuencialmente de arriba a abajo o de abajo a arriba, lo que los procesadores modernos hacen perfectamente.  Los valores est√°n incorporados en Buckets, pero el espacio reservado en ellos solo se usa para resolver colisiones.  Almacena el √≠ndice de otro Bucket con el mismo valor de funci√≥n hash o el final del marcador de lista. <br><br>  La memoria para los valores de cadena de las claves se asigna por separado, pero sigue siendo la misma zend_string.  Al pegar en una matriz, es suficiente aumentar el contador de referencia de la cadena, aunque antes ten√≠amos que copiar los caracteres directamente, y al buscar, ahora no podemos comparar los caracteres, sino los punteros a las cadenas en s√≠. <br><br><h3>  Matrices inmutables </h3><br>  Anteriormente, ten√≠amos cadenas inmutables, pero ahora tambi√©n han aparecido matrices inmutables.  Al igual que las cadenas, no utilizan el recuento de referencia y no se destruyen hasta el final de la solicitud.  Este es un script simple que crea una matriz de un mill√≥n de elementos, y cada elemento es la misma matriz con un solo elemento "hola". <br><br><img src="https://habrastorage.org/webt/uv/sm/lu/uvsmluqtfldezjnbbfdqvd83sr8.png"><br><br>  En PHP 5, en cada iteraci√≥n de bucle, se cre√≥ una nueva matriz vac√≠a, se escribi√≥ "hola" y se agreg√≥ todo esto a la matriz resultante.  En PHP 7, en la etapa de compilaci√≥n, <strong>creamos solo una matriz inmutable</strong> que se comporta como un escalar, y la agregamos a la resultante.  En el ejemplo presentado, esto nos permite lograr una reducci√≥n de m√°s de 10 veces en el consumo de memoria y una aceleraci√≥n de casi 10 veces. <br><br>  Las matrices constantes de millones de elementos en aplicaciones reales, por supuesto, no se encuentran a menudo, pero las peque√±as son bastante comunes.  En cada uno de ellos obtendr√° un peque√±o, pero una victoria. <br><br><h3>  Los objetos </h3><br>  Los enlaces a todos los objetos en PHP 5 se encuentran en un repositorio separado, y en zval solo hab√≠a un identificador de objeto √∫nico. <br><br><img src="https://habrastorage.org/webt/in/lo/dq/inlodqhjne7lo12nslgcuqrckvy.png"><br><br>  Para llegar al objeto, hicimos al menos 3 lecturas.  Adem√°s, la memoria para el valor de cada propiedad del objeto se asign√≥ por separado, y necesit√°bamos al menos 2 lecturas m√°s para leerlo. <br><br>  En PHP 7, pudimos pasar al direccionamiento directo. <br><br><img src="https://habrastorage.org/webt/zm/vp/vv/zmvpvvqlmybttr3zvze6gzglin4.png"><br><br>  La direcci√≥n <code>zend_object</code> es accesible con una sola instrucci√≥n de m√°quina.  Y las propiedades est√°n integradas y para leerlas solo necesita una lectura adicional.  Tambi√©n se agrupan, lo que <strong>mejora la localidad de los datos</strong> y ayuda a los procesadores modernos a no tropezar. <br><br>  Adem√°s de la propiedad predefinida, tambi√©n se almacena aqu√≠ un enlace a la clase de este objeto, algunos controladores, un an√°logo de tablas de m√©todos virtuales y una tabla hash para propiedades que no se definieron.  En PHP, puede agregar propiedades a cualquier objeto que no se defini√≥ originalmente, y si varias instrucciones de la m√°quina son suficientes para acceder a la propiedad predefinida, para las propiedades no predefinidas tendr√° que usar una tabla hash, que requerir√° docenas de instrucciones de la m√°quina.  Por supuesto, esto es mucho m√°s caro. <br><br><h3>  Referencia </h3><br>  Finalmente, tuvimos que introducir un <strong>tipo separado</strong> para representar enlaces PHP. <br><br><img src="https://habrastorage.org/webt/yk/jj/ng/ykjjngfnlq8sefuvmwzjfxwjz7g.png"><br><br>  Este es un tipo completamente transparente.  No es visible para los scripts PHP.  Las secuencias de comandos ven otro zval integrado en la estructura zend_reference.  Se entiende que nos referimos a una de esas estructuras desde al menos dos lugares, y el contador de referencia de esta estructura siempre es mayor que 1. Tan pronto como el contador cae a 1, el enlace se convierte en un valor escalar regular.  El zval incrustado en el enlace se copia al √∫ltimo zval que hace referencia a √©l, y la estructura misma se elimina. <br><br>  Parece que trabajar con referencia ahora es mucho m√°s complicado que con otros tipos (y esto es cierto), pero de hecho en PHP 5 tuvimos que hacer un trabajo de complejidad comparable al acceder a cualquier valor (incluso un n√∫mero entero primo).  Ahora estamos aplicando protocolos m√°s complejos a un solo tipo y acelerando as√≠ el trabajo con todos los dem√°s, especialmente con valores escalares. <br><br><h3>  IS_FALSE y IS_TRUE </h3><br>  Ya he dicho que el tipo √∫nico IS_BOOL se dividi√≥ en IS_FALSE e IS_TRUE por separado.  Esta idea se espi√≥ en la implementaci√≥n de LuaJIT y se hizo para acelerar una de las operaciones m√°s comunes: la transici√≥n condicional. <br><br><img src="https://habrastorage.org/webt/fv/5j/-z/fv5j-zx0u_2kfmtmxjwce4uzetk.png"><br><br>  Si en PHP 5 se requer√≠a leer el tipo, verificar el valor booleano, leer el valor, averiguar si es verdadero o falso y hacer una transici√≥n basada en esto, ahora es suficiente simplemente verificar el tipo y compararlo con verdadero: <br><br><ul><li>  si es cierto, entonces vamos a lo largo de una rama; </li><li>  si no es cierto, ve a otra rama; </li><li>  si es m√°s que cierto, vaya a la llamada ruta lenta (ruta lenta) y all√≠ verificaremos de qu√© tipo proviene y qu√© hacer con ella: si es un n√∫mero entero, debemos comparar su valor con 0, si es flotante, nuevamente con 0 ( pero real), etc. </li></ul><br><h2>  Convenci√≥n de convocatoria </h2><br>  Un cambio en la Convenci√≥n de llamada o la convenci√≥n de llamada de funci√≥n es una optimizaci√≥n importante que afecta no solo a las estructuras de datos, sino tambi√©n a los algoritmos subyacentes.  En la imagen de la izquierda hay un peque√±o script que consiste en la funci√≥n foo () y su llamada.  A continuaci√≥n se muestra el c√≥digo de bytes en el que PHP 5 compil√≥ este script. <br><br><img src="https://habrastorage.org/webt/bn/fw/a4/bnfwa4e5ifjqs6rd6cp66uctega.png"><br><br>  Primero, te dir√© c√≥mo funcion√≥ en PHP 5. <br><br><h3>  Convenci√≥n de llamadas en PHP 5 </h3><br>  La primera instrucci√≥n <code>SEND_VAL</code> fue enviar el valor "3" a la funci√≥n foo.  Para hacer esto, se vio obligada a asignar un nuevo zval en el mont√≥n, copiar el valor (3) all√≠ y escribir el valor del puntero a esta estructura en la pila. <br><br><img src="https://habrastorage.org/webt/mt/vu/d3/mtvud3tb2ljaijnwecbmvnqepjs.png"><br><br>  Del mismo modo con la segunda instrucci√≥n.  Adem√°s, <code>DO_FCALL</code> inicializ√≥ <code>CALL FRAME</code> , reserv√≥ un lugar para las variables locales y temporales, y transfiri√≥ el control a la funci√≥n llamada. <br><br><img src="https://habrastorage.org/webt/rx/rw/qo/rxrwqogtbhgd0q9tsd7wnw2r4og.png"><br><br>  La primera <code>RECV</code> verific√≥ el primer argumento e inicializ√≥ la ranura en la pila con la variable local correspondiente ($ a).  Aqu√≠ lo hicimos sin copiar y simplemente aumentamos el contador de referencia del par√°metro correspondiente (zval con un valor de 3).  De manera similar, la segunda <code>RECV</code> estableci√≥ una conexi√≥n entre la variable $ by el par√°metro 5. <br><br><img src="https://habrastorage.org/webt/lw/c1/zw/lwc1zw26uby_oj54yjzu7yz-vus.png"><br><br>  Otras funciones corporales.  Sucedi√≥ 3 + 5: result√≥ 8. Esta es una variable temporal y su valor se almacen√≥ directamente en la pila. <br><br><img src="https://habrastorage.org/webt/d0/xj/s5/d0xjs5j2c0i6qgioybezypay9k4.png"><br><br>  REGRESAR y volvemos de la funci√≥n. <br><br><img src="https://habrastorage.org/webt/zd/cc/nb/zdccnbal1xuynwdcymbrwcf2fmq.png"><br><br>  Al regresar, liberamos todas las variables y argumentos que est√°n fuera de alcance.  Para hacer esto, revisamos todos los zval referenciados por las ranuras del marco liberado, y para cada uno de ellos disminuimos el recuento de referencia.  Si llega a 0, destruya la estructura correspondiente. <br><br>  Como puede ver, incluso una operaci√≥n tan simple como enviar una constante a una funci√≥n requiere asignar nueva memoria, copiar y aumentar el contador de referencia, y luego tambi√©n duplicar la disminuci√≥n y la eliminaci√≥n. <br><br><h3>  Convenci√≥n de llamadas en PHP 7 </h3><br>  En PHP 7, estos problemas se han solucionado: ahora en la pila no almacenamos los punteros zval, sino los mismos zval. <br><br><img src="https://habrastorage.org/webt/xc/ek/ls/xceklspoxwmga__zvpeat1a4plw.png"><br><br>  Tambi√©n introdujimos una nueva instrucci√≥n, <code>INIT_FCALL</code> , que ahora es responsable de inicializar y asignar memoria en <code>CALL FRAME</code> , y reservar espacio para argumentos y variables temporales. <br><br><img src="https://habrastorage.org/webt/yi/gd/a5/yigda5wg7xswdcyadip7euboboa.png"><br><br>  <code>SEND_VAL 3</code> ahora solo copia el argumento en el primer espacio despu√©s de <code>CALL FRAME</code> .  Siguiente <code>SEND_VAL 5</code> a la segunda ranura. <br><br><img src="https://habrastorage.org/webt/-0/es/8_/-0es8_skigjtyvja3vzzegwo-su.png"><br><br>  Entonces lo m√°s interesante.  Parece que <code>DO_FCALL</code> deber√≠a pasar el control a la primera instrucci√≥n de la funci√≥n llamada.  Pero los argumentos ya han llegado a los espacios reservados para los par√°metros variables $ a y $ b, y las instrucciones <code>RECV</code> simplemente no hacen nada.  Por lo tanto, simplemente puede omitirlos.  Enviamos dos par√°metros, por lo que omitimos dos instrucciones.  Si enviaron tres, se habr√≠an perdido tres. <br><br><img src="https://habrastorage.org/webt/4z/vm/gj/4zvmgjldpmtfpgprtvqoks__-km.png"><br><br>  Entonces vamos directamente al cuerpo de la funci√≥n, hacemos suma y regresamos. <br><br><img src="https://habrastorage.org/webt/zh/j1/yf/zhj1yfwxp5kf1s4xxlyoasy170i.png"><br><br>  Al regresar, borramos todas las variables locales, pero ahora solo para dos ranuras, y dado que tenemos escalares all√≠, nuevamente no necesitamos hacer nada. <br><br><img src="https://habrastorage.org/webt/wy/dh/2p/wydh2pvz_hpawjivtoxx3hmxoqa.png"><br><br>  Mi historia est√° un poco simplificada, no tiene en cuenta las funciones con un n√∫mero variable de argumentos y la necesidad de verificaci√≥n de tipo y algunos otros puntos. <br><br>  <strong>La nueva Convenci√≥n de llamadas ha roto un poco la compatibilidad</strong> .  PHP tiene funciones como <code>func_get_arg</code> y <code>func_get_args</code> .  Si antes devolv√≠an el valor original del par√°metro enviado, ahora devuelven el valor actual de la variable local correspondiente, porque simplemente no almacenamos los valores originales.  Al igual que los depuradores C. <br><br><img src="https://habrastorage.org/webt/5r/n2/6j/5rn26j24gjyfolmeu07qgv1wmxu.png"><br><br>  Adem√°s, la funci√≥n ya no puede tener m√∫ltiples par√°metros con el mismo nombre.  No ten√≠a sentido en esto antes, pero conoc√≠ ese c√≥digo PHP <code>foo($_, $_)</code> .  ¬øC√≥mo se ve?  (Reconoc√≠ a Prolog) <br><br><h2>  Nuevo administrador de memoria </h2><br>  Habiendo terminado con la optimizaci√≥n de estructuras de datos y algoritmos b√°sicos, una vez m√°s llamamos la atenci√≥n sobre todos los subsistemas de frenado.  El administrador de memoria en PHP 5 tom√≥ <strong>casi el 20% del tiempo del procesador</strong> en Wordpress. <br><br>  Despu√©s de deshacernos de muchas asignaciones, sus costos generales se redujeron, pero siguieron siendo significativos, y no porque estaba haciendo un trabajo significativo, sino porque tropez√≥ con el cach√©.  Esto sucedi√≥ debido al hecho de que utilizamos el cl√°sico algoritmo malloc de Doug Lea, que implicaba encontrar ubicaciones adecuadas de memoria libre viajando a trav√©s de enlaces y √°rboles, y todos estos viajes inevitablemente causaron errores de cach√©. <br><br>  Hoy en d√≠a, hay nuevos algoritmos de administraci√≥n de memoria que tienen en cuenta las caracter√≠sticas de los procesadores modernos.  Por ejemplo: <strong>jemalloc</strong> y <strong>ptmalloc de Google</strong> .  Al principio, intentamos usarlos sin cambios, pero no obtuvimos una victoria, ya que la falta de la funcionalidad espec√≠fica de PHP hac√≠a que fuera m√°s costoso liberar memoria por completo al final de la solicitud.  Como resultado, abandonamos dlmalloc y escribimos algo propio, combinando ideas del antiguo administrador de memoria y jemalloc. <br><br>  Hemos <strong>reducido la sobrecarga de Memory Manager al 5%</strong> , hemos <strong>reducido la sobrecarga de memoria</strong> para la informaci√≥n de servicio y hemos mejorado el uso de la memoria cach√© de la CPU.  Los mapas de bits ahora buscan bloques de memoria adecuados, la memoria para bloques peque√±os se asigna desde p√°ginas individuales y se almacena en cach√© en el momento del lanzamiento, se agregan funciones especializadas para tama√±os de bloque usados ‚Äã‚Äãfrecuentemente. <br><br><h2>  Muchas peque√±as mejoras </h2><br>  Solo habl√© sobre las mejoras m√°s importantes, pero hubo muchas m√°s peque√±as.  Puedo mencionar algunos de ellos. <br><br><ul><li>  API r√°pida para analizar par√°metros de funciones internas y una nueva API para iterar sobre HashTable. </li><li>  Nuevas instrucciones de VM: concatenaci√≥n de cadenas, especializaci√≥n, superinstrucciones. </li><li>  Algunas funciones internas se han convertido en instrucciones de VM: strlen, is_int. </li><li>  Uso de registros de CPU para registros de VM: IP y FP. </li><li>  Optimizaci√≥n de la duplicaci√≥n y eliminaci√≥n de matrices. </li><li>  Usar enlaces cuenta en lugar de copiar donde sea que pueda. </li><li>  PCRE JIT. </li><li>  Optimizaci√≥n de funciones internas y serializaci√≥n (). </li><li>  Tama√±o de c√≥digo reducido y datos procesados. </li></ul><br>  Algunos eran muy simples, por ejemplo, solo se necesitaban tres l√≠neas de c√≥digo para habilitar JIT en expresiones Perl regulares, y esto inmediatamente trajo una aceleraci√≥n visible (2-3%) a casi todas las aplicaciones.  Otras optimizaciones tocaron algunos aspectos estrechos de ciertas funciones de PHP, y no son particularmente interesantes, aunque la contribuci√≥n total de todas estas mejoras menores es bastante significativa. <br><br><h2>  ¬øA qu√© has venido? </h2><br>  Esta es la contribuci√≥n de varios subsistemas en WordPress / PHP 7.0. <br><br><img src="https://habrastorage.org/webt/7q/r4/d0/7qr4d08m8yhid4rngwh9-gffxbu.png"><br><br>  La contribuci√≥n de la m√°quina virtual aument√≥ al 50%.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El Administrador de memoria ya consume menos del 5%, y principalmente no debido a las optimizaciones del Administrador de memoria en s√≠, sino al reducir el n√∫mero de llamadas. </font><font style="vertical-align: inherit;">Si anteriormente en la misma prueba, la memoria se asign√≥ 130 millones de veces, ahora son solo 10 millones. Puede parecer que toda la aceleraci√≥n principal se logr√≥ al reducir la sobrecarga del Administrador de memoria y la cantidad de llamadas debido a la mejora de las estructuras de datos, pero en realidad Todos los subsistemas se han mejorado significativamente. </font></font><br><br><img src="https://habrastorage.org/webt/kk/nq/5p/kknq5ppnd1ihr8wjw9xfv38boyy.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las principales fuentes de aceleraci√≥n:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El int√©rprete comenz√≥ a trabajar 2 veces mejor. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los gastos generales de MM disminuyeron 17 veces. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las tablas hash comenzaron a funcionar 4 veces m√°s r√°pido. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La productividad total de WordPress ha crecido 3.5 veces. </font></font></li></ul><br>       2,5-  ,    .  ?   ,         ,        CPU time,   ‚Äî  ,    .  PHP     ,        . <br><br><h3>  PHP 7 </h3><br> WordPress 3.6      ‚Äî         .  - ,   PHP 7   mysql,     ,     . <br><br><img src="https://habrastorage.org/webt/bs/x9/pa/bsx9pa3fc3ccedmnajaj1h5dm0q.png"><br><br>   ,          PHPNG.     2/3 .     ,    . <br><br> ,       WordPress,      ,      ‚Äî  1,5  2- . <br><br><h3> PHP 7  HHVM </h3><br>              HHVM. <br><br><img src="https://habrastorage.org/webt/fs/vg/ot/fsvgotogozunvqed7dwflmmef1u.png"><br><br>      ‚Äî  .     .   Facebook   .   HHVM   . ,      ,     ,    ,      . <br><br><img src="https://habrastorage.org/webt/c_/pg/jv/c_pgjvoejr-q3o5sgvgtplxkbm0.png"><br><br>  PHP 7 ‚Äî    .    Vebia,  Etsy  Badoo. Highload-    ,       . <br><br>   PHP 7.0  Etsy  Badoo       -. Badoo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>    . <br><br><img src="https://habrastorage.org/webt/pn/rv/rj/pnrvrjrzp9re46lbmngnyddzu44.png"><br><br>  ,          2 ,    ‚Äî   7 . <br><br>         PHP 7.0.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ,  PHP 7.1,        . <br><br><blockquote>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHP Russia</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>        <b>PHP 8</b> .         PHP,  ,    ,      ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>  1 .  , ,    ‚Äî   ,    ,     ,  . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444508/">https://habr.com/ru/post/444508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444494/index.html">La Moto Volante (Lazareth LMV 496) - motocicleta transformadora voladora</a></li>
<li><a href="../444496/index.html">Nuevas herramientas para detectar la intercepci√≥n HTTPS</a></li>
<li><a href="../444500/index.html">29 de marzo, Mosc√∫ - Backend Stories 3.0</a></li>
<li><a href="../444502/index.html">¬øLa criptograf√≠a cu√°ntica es realmente confiable?</a></li>
<li><a href="../444504/index.html">Usando el directorio del paquete local en Python ahora</a></li>
<li><a href="../444512/index.html">Crear una aplicaci√≥n gr√°fica para resolver el problema del curso del caballo.</a></li>
<li><a href="../444514/index.html">Seminario web "Seguridad del aprendizaje autom√°tico: problemas naturales de la inteligencia artificial"</a></li>
<li><a href="../444516/index.html">Wolfenstein 3D: trazado de rayos con WebGL1</a></li>
<li><a href="../444518/index.html">Hacia una teor√≠a fundamental de la conciencia.</a></li>
<li><a href="../444520/index.html">2. Check Point Getting Started R80.20. Arquitectura de soluciones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>