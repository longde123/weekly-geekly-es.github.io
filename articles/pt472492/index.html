<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ ü¶ç üïò Analisando o C√≥digo de ROOT, Estrutura de An√°lise de Dados Cient√≠ficos üë®üèª‚ÄçüöÄ üç∂ ‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Enquanto Estocolmo realizava a 118¬™ Semana Nobel, eu estava sentado em nosso escrit√≥rio, onde desenvolvemos o analisador est√°tico PVS-Studio, trabalha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisando o C√≥digo de ROOT, Estrutura de An√°lise de Dados Cient√≠ficos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/472492/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df2/7f4/bcd/df27f4bcd139790b322570ee2f48e1ab.png" alt="Quadro 3"></div>  Enquanto Estocolmo realizava a 118¬™ Semana Nobel, eu estava sentado em nosso escrit√≥rio, onde desenvolvemos o analisador est√°tico PVS-Studio, trabalhando em uma revis√£o de an√°lise do projeto ROOT, uma estrutura de processamento de big data usada em pesquisas cient√≠ficas.  Esse c√≥digo n√£o ganharia um pr√™mio, √© claro, mas os autores podem definitivamente contar com uma revis√£o detalhada dos defeitos mais interessantes, al√©m de uma licen√ßa gratuita para verificar o projeto por conta pr√≥pria. <br><br><h2>  1. Introdu√ß√£o </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/187/f04/a89187f045bbcb2b5b8d5ab7c9dc7da1.png" alt="Quadro 1"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ROOT</a> √© um kit de ferramentas de software cient√≠fico modular.  Ele fornece todas as funcionalidades necess√°rias para lidar com o processamento de big data, an√°lise estat√≠stica, visualiza√ß√£o e armazenamento.  √â escrito principalmente em C ++.  ROOT nasceu no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CERN</a> , no cora√ß√£o da pesquisa em f√≠sica de alta energia.  Todos os dias, milhares de f√≠sicos usam aplicativos ROOT para analisar seus dados ou realizar simula√ß√µes. <br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O PVS-Studio</a> √© uma ferramenta para detectar bugs de software e poss√≠veis vulnerabilidades no c√≥digo fonte de programas escritos em C, C ++, C # e Java.  √â executado no Windows, Linux e macOS de 64 bits e pode analisar o c√≥digo-fonte escrito para plataformas ARM de 32 bits, 64 bits e incorporadas. <br><br><h2>  Estr√©ia de um novo diagn√≥stico </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V1046</a> Uso inseguro dos tipos bool 'e' int 'juntos na opera√ß√£o' &amp; = '.  GSLMultiRootFinder.h 175 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ROOT::Math::IMultiGenFunction &amp; func)</span></span></span><span class="hljs-function"> </span></span>{ ROOT::Math::IMultiGenFunction * f = func.Clone(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!f) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; fFunctions.push_back(f); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fFunctions.size(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SetFunctionList</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">begin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ret = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (FuncIterator itr = begin; itr != end; ++itr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ROOT::Math::IMultiGenFunction * f = *itr; ret &amp;= AddFunction(*f); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br>  Primeiro, aqui est√° um bug maravilhoso encontrado pela vers√£o beta do PVS-Studio, que eu estava usando para esta revis√£o. <br><br>  <b>Expectativas</b>  A fun√ß√£o <i>SetFunctionList</i> percorre uma lista de iteradores.  Se pelo menos um iterador for inv√°lido, a fun√ß√£o retornar√° <i>false</i> ou <i>true,</i> caso contr√°rio. <br><br>  <b>Realidade</b>  A fun√ß√£o <i>SetFunctionList</i> pode retornar <i>false,</i> mesmo para iteradores v√°lidos.  Vamos descobrir o porqu√™.  A fun√ß√£o <i>AddFunction</i> retorna o n√∫mero de iteradores v√°lidos na lista <i>fFunctions</i> .  Ou seja, adicionar iteradores n√£o nulos far√° com que a lista cres√ßa gradualmente em tamanho: 1, 2, 3, 4 e assim por diante.  √â aqui que o bug entra em jogo: <br><br><pre> <code class="cpp hljs">ret &amp;= AddFunction(*f);</code> </pre> <br>  Como a fun√ß√£o retorna um valor do tipo <i>int em</i> vez de <i>bool</i> , a opera√ß√£o '&amp; =' retornar√° <i>false</i> para valores pares porque o bit menos significativo de um n√∫mero par √© sempre definido como zero.  √â assim que um bug sutil pode quebrar o valor de retorno de <i>SetFunctionsList,</i> mesmo quando seus argumentos s√£o v√°lidos. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa4/c23/64f/aa4c2364f5205b526db1625aeebd32ff.png" alt="Quadro 2"></div><br><h2>  Erros em express√µes condicionais </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V501</a> Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">subexpress√µes</a> id√™nticas √† esquerda e √† direita do operador '&amp;&amp;': module &amp;&amp; module rootcling_impl.cxx 3650 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleDiagnostic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> override </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isROOTSystemModuleDiag = <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; ....; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isSystemModuleDiag = <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-&gt;IsSystem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isROOTSystemModuleDiag &amp;&amp; !isSystemModuleDiag) fChild-&gt;HandleDiagnostic(DiagLevel, Info); .... }</code> </pre> <br>  Vamos come√ßar com o bug menos prejudicial.  O ponteiro do <i>m√≥dulo</i> √© verificado duas vezes.  Uma das verifica√ß√µes provavelmente √© redundante, mas ainda assim seria prudente corrigi-la para evitar qualquer confus√£o no futuro. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V501</a> Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">subexpress√µes</a> id√™nticas 'strchr (fHostAuth-&gt; GetHost (),' * ')' √† esquerda e √† direita da '||'  operador.  TAuthenticate.cxx 300 <br><br><pre> <code class="cpp hljs">TAuthenticate::TAuthenticate(TSocket *sock, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *remote, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *proto, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *user) { .... <span class="hljs-comment"><span class="hljs-comment">// If generic THostAuth (ie with wild card or user == any) // make a personalized memory copy of this THostAuth if (strchr(fHostAuth-&gt;GetHost(),'*') || strchr(fHostAuth-&gt;GetHost(),'*') || fHostAuth-&gt;GetServer() == -1 ) { fHostAuth = new THostAuth(*fHostAuth); fHostAuth-&gt;SetHost(fqdn); fHostAuth-&gt;SetUser(checkUser); fHostAuth-&gt;SetServer(servtype); } .... }</span></span></code> </pre> <br>  A <i>string fHostAuth-&gt; GetHost ()</i> √© varrida pelo caractere '*' duas vezes.  Uma dessas verifica√ß√µes provavelmente foi feita para procurar o '?'  caractere, pois esses dois caracteres geralmente s√£o os usados ‚Äã‚Äãpara especificar v√°rias m√°scaras curinga. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V517</a> O uso do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">padr√£o</a> 'if (A) {...} else if (A) {...}' foi detectado.  H√° uma probabilidade de presen√ßa de erro l√≥gico.  Verifique as linhas: 163, 165. TProofMonSenderML.cxx 163 <br><br><pre> <code class="cpp hljs">Int_t TProofMonSenderML::SendSummary(TList *recs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *id) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fSummaryVrs == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((dsn = recs-&gt;FindObject(<span class="hljs-string"><span class="hljs-string">"dataset"</span></span>))) recs-&gt;Remove(dsn); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fSummaryVrs == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Only the first records xrecs = new TList; xrecs-&gt;SetOwner(kFALSE); TIter nxr(recs); TObject *o = 0; while ((o = nxr())) { if (!strcmp(o-&gt;GetName(), "vmemmxw")) break; xrecs-&gt;Add(o); } } .... }</span></span></code> </pre> <br>  A vari√°vel <i>fSummaryVrs</i> √© comparada com zero duas vezes, portanto, a execu√ß√£o nunca atinge o c√≥digo na ramifica√ß√£o <i>else-if</i> .  E h√° bastante c√≥digo l√° ... <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V523</a> A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instru√ß√£o</a> 'then' √© equivalente √† instru√ß√£o 'else'.  TKDTree.cxx 805 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Index, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Value&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TKDTree&lt;Index, Value&gt;::UpdateRange(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (point[fAxis[inode]]&lt;=fValue[inode]){ <span class="hljs-comment"><span class="hljs-comment">//first examine the node that contains the point UpdateRange(GetLeft(inode),point, range, res); UpdateRange(GetRight(inode),point, range, res); } else { UpdateRange(GetLeft(inode),point, range, res); UpdateRange(GetRight(inode),point, range, res); } .... }</span></span></code> </pre> <br>  O mesmo bloco de c√≥digo, que √© um clone de copiar e colar, √© executado independentemente da condi√ß√£o.  Acho que h√° uma confus√£o entre as palavras <i>esquerda</i> e <i>direita</i> . <br><br>  O projeto est√° cheio de pontos suspeitos como esse: <br><br><ul><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  TContainerConverters.cxx 51 </li><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  TWebFile.cxx 1310 </li><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  MethodMLP.cxx 423 </li><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  RooAbsCategory.cxx 394 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> express√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V547</a> '! File_name_value.empty ()' √© sempre falsa.  SelectionRules.cxx 1423 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SelectionRules::AreAllSelectionRulesUsed() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; rule : fClassSelectionRules){ .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file_name_value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rule.GetAttributeValue(<span class="hljs-string"><span class="hljs-string">"file_name"</span></span>, file_name_value)) file_name_value.clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file_name_value.empty()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= // don't complain about defined_in rules continue; } const char* attrName = nullptr; const char* attrVal = nullptr; if (!file_name_value.empty()) { // &lt;= attrName = "file name"; attrVal = file_name_value.c_str(); } else { attrName = "class"; if (!name.empty()) attrVal = name.c_str(); } ROOT::TMetaUtils::Warning(0,"Unused %s rule: %s\n", attrName, attrVal); } .... }</span></span></code> </pre> <br>  Provavelmente n√£o √© um bug;  o analisador acabou de encontrar algum c√≥digo que pode ser simplificado.  Como o valor de retorno <i>file_name_value.empty ()</i> j√° est√° verificado no in√≠cio do loop, a segunda verifica√ß√£o duplicada pode ser removida, descartando, assim, uma boa quantidade de c√≥digo desnecess√°rio. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V590</a> Considere inspecionar o '! File1 ||  c &lt;= 0 ||  c == '*' ||  c! = '(' 'express√£o. A express√£o √© excessiva ou cont√©m um erro de impress√£o. TTabCom.cxx 840 <br><br><pre> <code class="cpp hljs">TString TTabCom::DetermineClass(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> varName[]) { .... c = file1.get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file1 || c &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || c == <span class="hljs-string"><span class="hljs-string">'*'</span></span> || c != <span class="hljs-string"><span class="hljs-string">'('</span></span>) { Error(<span class="hljs-string"><span class="hljs-string">"TTabCom::DetermineClass"</span></span>, <span class="hljs-string"><span class="hljs-string">"variable \"%s\" not defined?"</span></span>, varName); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> cleanup; } .... }</code> </pre> <br>  Aqui est√° a parte do problema da express√£o condicional relatada pelo analisador: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (.... || c == <span class="hljs-string"><span class="hljs-string">'*'</span></span> || c != <span class="hljs-string"><span class="hljs-string">'('</span></span>) { .... }</code> </pre> <br>  A verifica√ß√£o do caractere asterisco n√£o afetar√° o resultado da condi√ß√£o.  Esta parte sempre ser√° verdadeira para qualquer caractere que n√£o seja '('. Voc√™ pode verificar isso facilmente desenhando uma tabela verdade. <br><br>  Mais dois avisos sobre condi√ß√µes com l√≥gica estranha: <br><br><ul><li>  V590 Considere inspecionar esta express√£o.  A express√£o √© excessiva ou cont√©m uma impress√£o incorreta.  TFile.cxx 3963 </li><li>  V590 Considere inspecionar esta express√£o.  A express√£o √© excessiva ou cont√©m uma impress√£o incorreta.  TStreamerInfoActions.cxx 3084 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V593</a> Considere revisar a express√£o do tipo 'A = B &lt;C'.  A express√£o √© calculada da seguinte forma: 'A = (B &lt;C)'.  TProofServ.cxx 1903 <br><br><pre> <code class="cpp hljs">Int_t TProofServ::HandleSocketInput(TMessage *mess, Bool_t all) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Int_t ret = fProof-&gt;AddWorkers(workerList) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Error(<span class="hljs-string"><span class="hljs-string">"HandleSocketInput:kPROOF_GETSLAVEINFO"</span></span>, <span class="hljs-string"><span class="hljs-string">"adding a list of worker nodes returned: %d"</span></span>, ret); } .... }</code> </pre> <br>  Esse bug se revela apenas no caso de comportamento defeituoso do programa.  A vari√°vel <i>ret</i> deve armazenar o c√≥digo de retorno da fun√ß√£o <i>AddWorkers</i> e gravar esse valor no log em caso de condi√ß√£o de erro.  Mas n√£o funciona como pretendido.  A condi√ß√£o n√£o possui par√™nteses adicionais, for√ßando a ordem de avalia√ß√£o desejada.  O que a vari√°vel <i>ret</i> realmente armazena n√£o √© o c√≥digo de retorno, mas o resultado da compara√ß√£o l√≥gica, ou seja, 0 ou 1. <br><br>  Outro problema semelhante: <br><br><ul><li>  V593 Considere revisar a express√£o do tipo 'A = B &lt;C'.  A express√£o √© calculada da seguinte forma: 'A = (B &lt;C)'.  TProofServ.cxx 3897 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V768</a> A constante de enumera√ß√£o 'kCostComplexityPruning' √© usada como uma vari√°vel de um tipo booleano.  MethodDT.cxx 283 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EPruneMethod {kExpectedErrorPruning=<span class="hljs-number"><span class="hljs-number">0</span></span>, kCostComplexityPruning, kNoPruning}; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMVA::MethodDT::ProcessOptions() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fPruneStrength &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) fAutomatic = kTRUE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fAutomatic = kFALSE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fAutomatic &amp;&amp; fPruneMethod==!DecisionTree::kCostComplexityPruning){ Log() &lt;&lt; kFATAL &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Sorry automatic pruning strength determination is ...."</span></span> &lt;&lt; Endl; } .... }</code> </pre> <br>  Hum ... Por que negar o valor constante <i>kCostComplexityPruning</i> ?  Suspeito que o caractere de nega√ß√£o seja um erro de digita√ß√£o, que agora distorce a l√≥gica de execu√ß√£o. <br><br><h2>  Erros de manipula√ß√£o de ponteiro </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V522 A</a> desreferencia√ß√£o do ponteiro nulo 'pr√©' pode ocorrer.  TSynapse.cxx 61 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TSynapse::SetPre(TNeuron * pre) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pre) { Error(<span class="hljs-string"><span class="hljs-string">"SetPre"</span></span>,<span class="hljs-string"><span class="hljs-string">"this synapse is already assigned to a pre-neuron."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } fpre = pre; pre-&gt;AddPost(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Fiz o meu melhor tentando entender esse c√≥digo estranho, e parece que a id√©ia era evitar atribuir um novo valor ao campo <i>fpre</i> .  Nesse caso, o programador est√° checando acidentalmente o ponteiro errado.  A implementa√ß√£o atual leva a remover a refer√™ncia de um ponteiro nulo se voc√™ passar o valor <i>nullptr</i> para a fun√ß√£o <i>SetPre</i> . <br><br>  Eu acho que esse trecho deve ser corrigido da seguinte forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TSynapse::SetPre(TNeuron * pre) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fpre) { Error(<span class="hljs-string"><span class="hljs-string">"SetPre"</span></span>,<span class="hljs-string"><span class="hljs-string">"this synapse is already assigned to a pre-neuron."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } fpre = pre; pre-&gt;AddPost(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Isso, no entanto, n√£o impediria a passagem de um ponteiro nulo para a fun√ß√£o, mas pelo menos essa vers√£o √© mais logicamente consistente que a original. <br><br>  Um clone ligeiramente modificado desse c√≥digo pode ser encontrado em outro local: <br><br><ul><li>  V522 A desreferencia√ß√£o do ponteiro nulo 'postagem' pode ocorrer.  TSynapse.cxx 74 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V595</a> O ponteiro 'N' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 484, 488. Scanner.cxx 484 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> RScanner::shouldVisitDecl(clang::NamedDecl *D) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> M = D-&gt;getOwningModule()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= 2 return fInterpreter.getSema().isModuleVisible(M); } return true; } bool RScanner::VisitNamespaceDecl(clang::NamespaceDecl* N) { if (fScanType == EScanType::kOnePCM) return true; if (!shouldVisitDecl(N)) // &lt;= 1 return true; if((N &amp;&amp; N-&gt;isImplicit()) || !N){ // &lt;= 3 return true; } .... }</span></span></code> </pre> <br>  Este √© um peda√ßo de c√≥digo extremamente perigoso!  O ponteiro <i>N</i> n√£o √© verificado como nulo antes de ser desferenciado pela primeira vez.  Al√©m disso, voc√™ n√£o pode ver isso acontecer aqui porque a desrefer√™ncia ocorre dentro da fun√ß√£o <i>shouldVisitDecl</i> . <br><br>  Tradicionalmente, esse diagn√≥stico gera v√°rios avisos relevantes.  Aqui est√£o apenas alguns exemplos: <br><br><ul><li>  V595 O ponteiro 'arquivo' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 141, 153. TFileCacheRead.cxx 141 </li><li>  V595 O ponteiro 'fFree' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 2029, 2038. TFile.cxx 2029 </li><li>  V595 O ponteiro 'tbuf' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 586, 591. TGText.cxx 586 </li><li>  V595 O ponteiro 'fPlayer' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 3425, 3430. TProof.cxx 3425 </li><li>  V595 O ponteiro 'gProofServ' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 1192, 1194. TProofPlayer.cxx 1192 </li><li>  V595 O ponteiro 'projDataTmp' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 791, 804. RooSimultaneous.cxx 791 </li></ul><br>  O pr√≥ximo n√£o √© um bug, mas √© outro exemplo de como as macros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">incentivam a</a> escrever c√≥digo defeituoso ou redundante. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V571</a> Verifica√ß√£o recorrente.  A condi√ß√£o 'if (fCanvasImp)' j√° foi verificada na linha 799. TCanvas.cxx 800 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SafeDelete(p) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p) { delete p; p = 0; } } void TCanvas::Close(Option_t *option) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (fCanvasImp) SafeDelete(fCanvasImp); .... }</span></span></code> </pre> <br>  O ponteiro <i>fCanvasImp</i> √© verificado duas vezes, com uma das verifica√ß√µes j√° implementadas na macro <i>SafeDelete</i> .  Um dos problemas das macros √© que elas s√£o dif√≠ceis de navegar a partir do c√≥digo, e √© por isso que muitos programadores n√£o examinam seu conte√∫do antes de us√°-lo. <br><br><h2>  Erros de manipula√ß√£o de matriz </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V519</a> A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vari√°vel</a> 'Line [Cursor]' recebe valores duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 352, 353. Editor.cpp 353 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> find_last_non_alnum(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;str, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::size_type index = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tmp = Line.GetText()[Cursor]; Line[Cursor] = Line[Cursor - <span class="hljs-number"><span class="hljs-number">1</span></span>]; Line[Cursor] = tmp; .... }</code> </pre> <br>  O elemento <i>Linha [Cursor]</i> recebe um novo valor, que √© substitu√≠do imediatamente.  Isso n√£o parece certo ... <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'ivar' est√° apontando al√©m do limite da matriz.  BasicMinimizer.cxx 130 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BasicMinimizer::SetVariableValue(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ivar, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ivar &gt; fValues.size() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; fValues[ivar] = val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Cometer esse erro ao verificar os √≠ndices da matriz √© uma tend√™ncia recente;  n√≥s vemos isso em quase todos os terceiros projetos.  Embora seja f√°cil indexar em uma matriz dentro de um loop - voc√™ normalmente usa o operador '&lt;' para comparar o √≠ndice com o tamanho da matriz - verifica√ß√µes como a mostrada acima exigem o operador '&gt; =', n√£o '&gt;'.  Caso contr√°rio, voc√™ corre o risco de indexar um elemento al√©m do limite da matriz. <br><br>  Este bug foi clonado em todo o c√≥digo algumas vezes: <br><br><ul><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'ivar' est√° apontando al√©m do limite da matriz.  BasicMinimizer.cxx 186 </li><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'ivar' est√° apontando al√©m do limite da matriz.  BasicMinimizer.cxx 194 </li><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'ivar' est√° apontando al√©m do limite da matriz.  BasicMinimizer.cxx 209 </li><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'ivar' est√° apontando al√©m do limite da matriz.  BasicMinimizer.cxx 215 </li><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'ivar' est√° apontando al√©m do limite da matriz.  BasicMinimizer.cxx 230 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V621</a> Considere inspecionar o operador 'for'.  √â poss√≠vel que o loop seja executado incorretamente ou n√£o seja executado.  TDataMember.cxx 554 <br><br><pre> <code class="cpp hljs">Int_t TDataMember::GetArrayDim() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fArrayDim&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; fInfo) { R__LOCKGUARD(gInterpreterMutex); TDataMember *dm = <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;TDataMember*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); dm-&gt;fArrayDim = gCling-&gt;DataMemberInfo_ArrayDim(fInfo); <span class="hljs-comment"><span class="hljs-comment">// fArrayMaxIndex should be zero if (dm-&gt;fArrayDim) { dm-&gt;fArrayMaxIndex = new Int_t[fArrayDim]; for(Int_t dim = 0; dim &lt; fArrayDim; ++dim) { dm-&gt;fArrayMaxIndex[dim] = gCling-&gt;DataMemberInfo_MaxIndex(fInfo,dim); } } } return fArrayDim; }</span></span></code> </pre> <br>  No loop <i>for</i> , os desenvolvedores aparentemente pretendiam comparar a vari√°vel <i>dim</i> com <i>dm-&gt; fArrayDim em</i> vez de <i>fArrayDim</i> .  O valor de <i>fArrayDim</i> √© negativo, o que √© garantido pela condi√ß√£o no in√≠cio da fun√ß√£o.  Conseq√ºentemente, esse loop nunca ser√° executado. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V767</a> Acesso suspeito ao elemento da matriz 'atual' por um √≠ndice constante dentro de um loop.  TClingUtils.cxx 3082 <br><br><pre> <code class="cpp hljs">llvm::StringRef ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current!=<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Check the token if (isdigit(current[0])) { for(i=0;i&lt;strlen(current);i++) { if (!isdigit(current[0])) { if (errstr) *errstr = current; if (errnum) *errnum = NOT_INT; return llvm::StringRef(); } } } else { // current token is not a digit .... } .... } .... }</span></span></code> </pre> <br>  Este c√≥digo est√° analisando e verificando alguma sequ√™ncia.  Se o primeiro caractere da string <i>atual</i> (ou seja, no √≠ndice 0) for reconhecido como um n√∫mero, o loop percorrer√° todos os caracteres restantes para garantir que todos sejam n√∫meros.  Bem, pelo menos essa √© a ideia.  O problema √© que o contador <i>i</i> n√£o √© usado no loop.  A condi√ß√£o deve ser reescrita para verificar a <i>corrente [i]</i> em vez da <i>corrente [0]</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16e/c09/97a/16ec0997a4c29ce4a257d4124cf63ce2.png" alt="Quadro 4"></div><br><h2>  Vazamento de mem√≥ria </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V773</a> A fun√ß√£o foi encerrada sem liberar o ponteiro 'optionlist'.  √â poss√≠vel um vazamento de mem√≥ria.  TDataMember.cxx 355 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TDataMember::Init(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> afterReading) { .... TList *optionlist = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TList(); <span class="hljs-comment"><span class="hljs-comment">//storage for options strings for (i=0;i&lt;token_cnt;i++) { if (strstr(tokens[i],"Items")) { ptr1 = R__STRTOK_R(tokens[i], "()", &amp;rest); if (ptr1 == 0) { Fatal("TDataMember","Internal error, found \"Items....",GetTitle()); return; } ptr1 = R__STRTOK_R(nullptr, "()", &amp;rest); if (ptr1 == 0) { Fatal("TDataMember","Internal error, found \"Items....",GetTitle()); return; } .... } .... } .... // dispose of temporary option list... delete optionlist; .... }</span></span></code> </pre> <br>  O ponteiro <i>optionList</i> n√£o √© liberado antes de retornar da fun√ß√£o.  N√£o sei se essa libera√ß√£o √© necess√°ria nesse caso espec√≠fico, mas quando relatamos erros como esse, os desenvolvedores geralmente os corrigem.  Tudo depende se voc√™ deseja ou n√£o que seu programa continue sendo executado em caso de condi√ß√£o de erro.  O ROOT tem v√°rios defeitos assim, ent√£o eu aconselho os autores a verificar novamente o projeto. <br><br><h2>  memset novamente </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V597</a> O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o buffer 'x'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  TMD5.cxx 366 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMD5::Transform(UInt_t buf[<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UChar_t in[<span class="hljs-number"><span class="hljs-number">64</span></span>]) { UInt_t a, b, c, d, x[<span class="hljs-number"><span class="hljs-number">16</span></span>]; .... <span class="hljs-comment"><span class="hljs-comment">// Zero out sensitive information memset(x, 0, sizeof(x)); }</span></span></code> </pre> <br>  Muitos acham que o coment√°rio n√£o chegar√° ao arquivo bin√°rio ap√≥s a compila√ß√£o e eles est√£o absolutamente corretos: D.  O que alguns podem n√£o saber √© que o compilador tamb√©m remover√° a fun√ß√£o <i>memset</i> .  E isso vai acontecer com certeza.  Se o buffer em quest√£o n√£o for mais usado no c√≥digo, o compilador otimizar√° a chamada de fun√ß√£o.  Tecnicamente, √© uma decis√£o razo√°vel, mas se o buffer estiver armazenando dados privados, esses dados permanecer√£o l√°.  Esta √© uma fraqueza cl√°ssica de seguran√ßa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE-14</a> . <br><br><h2>  Diversos </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V591</a> A fun√ß√£o n√£o nula deve retornar um valor.  LogLikelihoodFCN.h 108 <br><br><pre> <code class="cpp hljs">LogLikelihoodFCN &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LogLikelihoodFCN &amp; rhs) { SetData(rhs.DataPtr() ); SetModelFunction(rhs.ModelFunctionPtr() ); fNEffPoints = rhs.fNEffPoints; fGrad = rhs.fGrad; fIsExtended = rhs.fIsExtended; fWeight = rhs.fWeight; fExecutionPolicy = rhs.fExecutionPolicy; }</code> </pre> <br>  O operador sobrecarregado n√£o tem valor de retorno.  Essa √© outra tend√™ncia recente. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V596</a> O objeto foi criado, mas n√£o est√° sendo usado.  A palavra-chave 'throw' pode estar ausente: throw runtime_error (FOO);  RTensor.hxx 363 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Value_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container_t&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> RTensor&lt;Value_t, Container_t&gt; RTensor&lt;Value_t, Container_t&gt;::Transpose() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fLayout == MemoryLayout::RowMajor) { fLayout = MemoryLayout::ColumnMajor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fLayout == MemoryLayout::ColumnMajor) { fLayout = MemoryLayout::RowMajor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Memory layout is not known."</span></span>); } .... }</code> </pre> <br>  O problema √© que o programador acidentalmente deixou de fora a palavra-chave <i>throw</i> , impedindo, assim, o lan√ßamento de uma exce√ß√£o em caso de condi√ß√£o de erro. <br><br>  Havia apenas dois avisos desse tipo.  Aqui est√° o segundo: <br><br><ul><li>  V596 O objeto foi criado, mas n√£o est√° sendo usado.  A palavra-chave 'throw' pode estar ausente: throw runtime_error (FOO);  Forest.hxx 137 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V609</a> Divida por zero.  Intervalo do denominador [0..100].  TGHtmlImage.cxx 340 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *TGHtml::GetPctWidth(TGHtmlElement *p, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opt, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ret) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, m, val; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opt[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'h'</span></span>) { val = fCanvas-&gt;GetHeight() * <span class="hljs-number"><span class="hljs-number">100</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { val = fCanvas-&gt;GetWidth() * <span class="hljs-number"><span class="hljs-number">100</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fInTd) { <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(ret, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-string"><span class="hljs-string">"%d"</span></span>, val / n); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } else { .... } .... }</span></span></code> </pre> <br>  Este √© semelhante aos exemplos de manipula√ß√£o de matriz discutidos anteriormente.  A vari√°vel <i>n</i> √© limitada ao intervalo de 0 a 100. Mas h√° um ramo que executa a divis√£o pela vari√°vel <i>n</i> que pode ter o valor 0. Acho que os limites do intervalo de <i>n</i> devem ser fixados da seguinte forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V646</a> Considere inspecionar a l√≥gica do aplicativo.  √â poss√≠vel que a palavra-chave 'else' esteja ausente.  TProofServ.cxx 729 <br><br><pre> <code class="cpp hljs">TProofServ::TProofServ(Int_t *argc, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **argv, FILE *flog) : TApplication(<span class="hljs-string"><span class="hljs-string">"proofserv"</span></span>, argc, argv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!logmx.IsDigit()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"K"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'K'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"M"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'M'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"G"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'G'</span></span>); } } .... }</code> </pre> <br>  O analisador relata uma instru√ß√£o <i>if</i> estranhamente formatada com a palavra-chave <i>else else</i> ausente.  A apar√™ncia desse c√≥digo sugere que ele precisa ser corrigido. <br><br>  Mais alguns avisos desse tipo: <br><br><ul><li>  V646 Considere inspecionar a l√≥gica do aplicativo.  √â poss√≠vel que a palavra-chave 'else' esteja ausente.  TFormula_v5.cxx 3702 </li><li>  V646 Considere inspecionar a l√≥gica do aplicativo.  √â poss√≠vel que a palavra-chave 'else' esteja ausente.  RooAbsCategory.cxx 604 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V663</a> Loop infinito √© poss√≠vel.  A condi√ß√£o 'cin.eof ()' √© insuficiente para interromper o loop.  Considere adicionar a chamada de fun√ß√£o 'cin.fail ()' √† express√£o condicional.  M√©todoKNN.cxx 602 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMVA::MethodKNN::ReadWeightsFromStream(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream&amp; is) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!is.eof()) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> line; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getline(is, line); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (line.empty() || line.find(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } .... } .... }</code> </pre> <br>  Ao trabalhar com a classe <i>std :: istream</i> , chamar a fun√ß√£o <i>eof ()</i> n√£o √© suficiente para finalizar o loop.  A fun√ß√£o <i>eof ()</i> sempre retornar√° <i>false</i> se os dados n√£o puderem ser lidos e n√£o houver outros pontos de termina√ß√£o nesse c√≥digo.  Para garantir o t√©rmino do loop, √© necess√°ria uma verifica√ß√£o adicional do valor retornado pela fun√ß√£o <i>fail ()</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!is.eof() &amp;&amp; !is.fail()) { .... }</code> </pre> <br>  Como alternativa, ele pode ser reescrito da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (is) { .... }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V678</a> Um objeto √© usado como argumento para seu pr√≥prio m√©todo.  Considere verificar o primeiro argumento real da fun√ß√£o 'Copiar'.  TFormLeafInfo.cxx 2414 <br><br><pre> <code class="cpp hljs">TFormLeafInfoMultiVarDim::TFormLeafInfoMultiVarDim( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TFormLeafInfoMultiVarDim&amp; orig) : TFormLeafInfo(orig) { fNsize = orig.fNsize; fSizes.Copy(fSizes); <span class="hljs-comment"><span class="hljs-comment">// &lt;= fCounter2 = orig.fCounter2?orig.fCounter2-&gt;DeepCopy():0; fSumOfSizes = orig.fSumOfSizes; fDim = orig.fDim; fVirtDim = orig.fVirtDim; fPrimaryIndex = orig.fPrimaryIndex; fSecondaryIndex = orig.fSecondaryIndex; }</span></span></code> </pre> <br>  Vamos terminar o artigo com este pequeno erro de digita√ß√£o.  A fun√ß√£o <i>Copiar</i> deve ser chamada com <i>orig.fSizes</i> , n√£o <i>fSizes</i> . <br><br><h2>  Conclus√£o </h2><br>  H√° cerca de um ano, verificamos o projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NCBI Genome Workbench</a> , outro programa usado em pesquisas cient√≠ficas que tratam da an√°lise do genoma.  Estou mencionando isso porque a qualidade do software cient√≠fico √© extremamente crucial, mas os desenvolvedores tendem a subestim√°-lo. <br><br>  A prop√≥sito, o macOS 10.15 Catalina foi lan√ßado outro dia, onde deixou de oferecer suporte a aplicativos de 32 bits.  Felizmente, o PVS-Studio oferece um grande conjunto de diagn√≥sticos projetados especificamente para detectar bugs que acompanham a portabilidade de programas para sistemas de 64 bits.  Saiba mais neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">post</a> pela equipe do PVS-Studio. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472492/">https://habr.com/ru/post/pt472492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472482/index.html">Acidente radioativo: descoberta de uma fase s√≥lida e est√°vel do plut√¥nio</a></li>
<li><a href="../pt472484/index.html">Fechando furos em um cluster Kubernetes. Relat√≥rio e transcri√ß√£o com DevOpsConf</a></li>
<li><a href="../pt472486/index.html">Armazenamento de dados a longo prazo. (Artigo - discuss√£o)</a></li>
<li><a href="../pt472488/index.html">Trinta relat√≥rios do DevOops 2019: Tim Lister, Hadi Hariri, Roman Shaposhnik e outras estrelas do DevOps internacional</a></li>
<li><a href="../pt472490/index.html">Como pesquisei um padr√£o de beleza usando o Processamento de linguagem natural (e n√£o o encontrei)</a></li>
<li><a href="../pt472494/index.html">An√°lise de c√≥digo ROOT - estrutura de an√°lise de dados de pesquisa</a></li>
<li><a href="../pt472496/index.html">Criando um Layout de Scrapbook na Grade CSS</a></li>
<li><a href="../pt472502/index.html">O SOC √© pessoal: a dura vida cotidiana do gerente de servi√ßos do centro para monitoramento e resposta a ataques cibern√©ticos</a></li>
<li><a href="../pt472504/index.html">PHP Microservice Framework Swoft: Use o Banco de Dados Parte 1</a></li>
<li><a href="../pt472506/index.html">Onde est√° o erro, Billy? Precisamos de um erro ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>