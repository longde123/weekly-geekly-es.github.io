<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕌 🧟 🕕 基于明信片的编程语言 👨🏼 😀 👴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="来源 


 四人帮成员之一拉尔夫·约翰逊（Ralph Johnson）曾经展示过Smalltalk-80语言的语法如何适合明信片。 现在，距Smalltalk的第一个版本已经将近30年了，发展最快的Smalltalk方言就是Pharo，我们稍后会介绍。 
 方法声明 


exampleWithN...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>基于明信片的编程语言</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446578/"><p><img src="https://habrastorage.org/getpro/habr/post_images/fba/b78/b21/fbab78b212fe7d49e49dbf842e4314de.svg" alt="图片"><br>  <a href=""><em>来源</em></a> </p><br><p> 四人帮成员之一拉尔夫·约翰逊（Ralph Johnson）曾经展示过Smalltalk-80语言的语法如何适合明信片。 现在，距Smalltalk的第一个版本已经将近30年了，发展最快的Smalltalk方言就是Pharo，我们稍后会介绍。 </p><a name="habracut"></a><br><h3 id="obyavlenie-metoda"> 方法声明 </h3><br><pre><code class="smalltalk hljs">exampleWithNumber: x</code> </pre> <br><p> 方法被声明为<code>: </code>并且是该类的成员。 这样声明具有多个参数的方法 </p><br><pre> <code class="smalltalk hljs">rangeFrom: start to: end</code> </pre> <br><p> 方法名称为<code>rangeFrom:to:</code> ，参数名称为<code>start</code>和<code>end</code> 。 </p><br><h3 id="deklaraciya-pragma"> 语用宣言 </h3><br><pre> <code class="smalltalk hljs">&lt;syntaxOn: <span class="hljs-symbol"><span class="hljs-symbol">#postcard</span></span>&gt;</code> </pre> <br><p> 注释用于注释该方法。 编译器或其他方法可以将此注释用作元数据。 </p><br><h3 id="kommentarii"> 留言 </h3><br><pre> <code class="smalltalk hljs"><span class="hljs-comment"><span class="hljs-comment">"A "</span></span><span class="hljs-comment"><span class="hljs-comment">"complete"</span></span><span class="hljs-comment"><span class="hljs-comment">" Pharo syntax"</span></span></code> </pre> <br><p> 注释用引号引起来。 注释内的引号由双引号指示。 </p><br><h3 id="obyavlenie-lokalnoy-peremennoy"> 声明局部变量 </h3><br><pre> <code class="smalltalk hljs">| y |</code> </pre> <br><p> 局部变量用于方法内部的计算中。 由于Smalltalk是动态类型化的语言，因此不需要变量类型声明。 </p><br><p> 在一个列表中声明了几个变量。 </p><br><pre> <code class="smalltalk hljs">| yx totalSum |</code> </pre> <br><h3 id="obekty-i-soobscheniya"> 对象和消息 </h3><br><pre> <code class="smalltalk hljs"><span class="hljs-keyword"><span class="hljs-keyword">true</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> not &amp; (<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> isNil)</code> </pre> <br><p>  Smalltalk中的所有内容都是一个对象，对象可以接收消息。 执行顺序（即发送消息）从左到右，但是不带参数的消息主要根据优先级规则发送，因此此处的计算顺序为 </p><br><pre> <code class="smalltalk hljs">(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> &amp; (<span class="hljs-keyword"><span class="hljs-keyword">false</span></span> not)) &amp; (<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> isNil)</code> </pre> <br><p>  Smalltalk中只有四个优先级规则：首先，消息在括号中发送，然后是一元消息（除了接收者对象本身之外没有其他参数，例如<code>false not</code> ），然后是二进制消息（带有一个其他参数，例如<code>1 + 2</code> ），然后是带有几个参数（例如<code>15 between: 1 and: 2</code> ）。 执行的优先级由一个简单的方案表示。 </p><br><p>  <em>括号</em> &gt; <em>一元</em> &gt; <em>二进制</em> &gt; <em>具有多个参数的消息</em> </p><br><p> 这些规则也适用于数学运算，因此表达式的结果 </p><br><pre> <code class="smalltalk hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">15</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">" = (1 + 15) / 4 "</span></span></code> </pre> <br><p> 将是<code>4</code> 。 顺便说一句， <code>nil</code>也是一个对象，可以接收和响应消息。 </p><br><h3 id="uslovnoe-vypolnenie-i-bloki-koda"> 条件执行和代码块 </h3><br><pre> <code class="smalltalk hljs"><span class="hljs-keyword"><span class="hljs-keyword">true</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> not &amp; (<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> isNil) ifFalse: [ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> perform: <span class="hljs-symbol"><span class="hljs-symbol">#add</span></span>: with: x ].</code> </pre> <br><p> 通过将<code>ifTrue</code>和<code>ifFalse</code>消息发送到<code>ifFalse</code>对象来实现条件执行。 该消息的参数是一个代码块，由方括号表示，如果满足指定条件，则执行该代码块。 </p><br><p>  Smalltalk块还用作匿名函数： </p><br><pre> <code class="smalltalk hljs">sum := [ :x :y | x+y ]. <span class="hljs-comment"><span class="hljs-comment">"  x,y -&gt; x+y "</span></span> sum value: <span class="hljs-number"><span class="hljs-number">10</span></span> value: <span class="hljs-number"><span class="hljs-number">25.</span></span> <span class="hljs-comment"><span class="hljs-comment">"  ,  - 35"</span></span></code> </pre> <br><h3 id="otpravka-soobscheniy-samomu-sebe"> 向自己发送消息 </h3><br><pre> <code class="smalltalk hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span> perform: <span class="hljs-symbol"><span class="hljs-symbol">#add</span></span>: with: x</code> </pre> <br><p> 在向对象本身发送消息时， <code>self</code>关键字用作包含该方法的对象的引用。 在这里，我们发送一个<code>#add</code> ：with：消息，其中包含<code>#add</code>和<code>x</code>参数。 符号<code>#</code>表示文字字符串，在此用作方法标识符。 </p><br><h3 id="prisvoenie-peremennoy"> 变量分配 </h3><br><pre> <code class="smalltalk hljs">y := <span class="hljs-keyword"><span class="hljs-keyword">thisContext</span></span> stack size + <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> size.</code> </pre> <br><p> 分配变量由运算符<code>:=</code>指示。  super关键字用于引用超类对象。 </p><br><p> 所有Smalltalk对象都从<code>Object</code>类或其父类继承，而后者又从其超类或<code>Object</code>类继承。 </p><br><h3 id="staticheskiy-massiv"> 静态数组 </h3><br><pre> <code class="smalltalk hljs">byteArray := #[<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>r100 <span class="hljs-number"><span class="hljs-number">8</span></span>r20 <span class="hljs-number"><span class="hljs-number">16</span></span>rFF].</code> </pre> <br><p>  <code>byteArray</code>是在声明类时声明的类实例变量。  byteArray数组由以不同形式写在不同数字系统中的整数组成 </p><br><pre> <code class="smalltalk hljs">&lt;&gt;r&lt;&gt;</code> </pre> <br><p> 静态数组的大小是固定的，并在编译时设置。 数组索引从1开始 </p><br><pre> <code class="smalltalk hljs">byteArray at: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">" = 2r100 "</span></span></code> </pre> <br><p> 从一开始，Smalltalk不仅是一种语言，而且是具有自己的虚拟机的集成开发环境：Smalltalk类和方法不存储在单独的文本文件中，而是立即保存在虚拟机映像中并通过开发环境接口声明。 例如，类<code>Counter</code>在类部分中声明为 </p><br><pre> <code class="smalltalk hljs"><span class="hljs-type"><span class="hljs-type">Object</span></span> subclass: <span class="hljs-symbol"><span class="hljs-symbol">#Counter</span></span> instanceVariableNames: <span class="hljs-string"><span class="hljs-string">'count initialValue'</span></span> classVariableNames: <span class="hljs-string"><span class="hljs-string">''</span></span> package: <span class="hljs-string"><span class="hljs-string">'MyCounter'</span></span></code> </pre> <br><p> 及其方法在<code>Counter</code>类的方法部分中声明。 </p><br><h3 id="dinamicheskiy-massiv"> 动态数组 </h3><br><pre> <code class="smalltalk hljs">{ <span class="hljs-number"><span class="hljs-number">-42</span></span> . #(<span class="hljs-string"><span class="hljs-string">$a</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#a</span></span> #<span class="hljs-string"><span class="hljs-string">'I'</span></span><span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-number"><span class="hljs-number">1.23e2</span></span> <span class="hljs-number"><span class="hljs-number">3.14</span></span>s2 <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><p> 动态数组在运行时创建。 <br> 数组可以包含不同类型的数据：数组的第一个元素是数字-42，数组的第二个元素是具有不同类型的元素的数组： </p><br><ul><li>  <code>$a</code> a-字符“ a” </li><li>  <code>#a #'I''m'</code>文字字符串“ a”和“ I'm” </li><li>  <code>'a'</code> a'-字符串“ a” </li><li>  <code>1.0 1.23e2</code>浮点数 </li><li>  <code>3.14s2</code>比例为2的小数部分 </li></ul><br><h3 id="cikly"> 周期数 </h3><br><pre> <code class="smalltalk hljs">{ <span class="hljs-number"><span class="hljs-number">-42</span></span> . #(<span class="hljs-string"><span class="hljs-string">$a</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#a</span></span> #<span class="hljs-string"><span class="hljs-string">'I'</span></span><span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-number"><span class="hljs-number">1.23e2</span></span> <span class="hljs-number"><span class="hljs-number">3.14</span></span>s2 <span class="hljs-number"><span class="hljs-number">1</span></span>) } do: [ :each | | var | var := Transcript show: each class name; show: each printString ].</code> </pre> <br><p> 通过将消息发送到带有将在该数组的每个元素上执行的块的数组来实现Smalltalk中的循环，这与功能方法非常相似。 在每次迭代时，将数组的元素作为参数传递给对它执行一些计算的块。 在示例的块中，声明了局部变量var，该变量被分配了将最后一个显示消息发送到全局<code>Transcript</code>对象的结果。 </p><br><p>  Smalltalk的一个有趣功能是能够级联消息：表达式 </p><br><pre> <code class="smalltalk hljs"><span class="hljs-type"><span class="hljs-type">Transcript</span></span> show: <span class="hljs-string"><span class="hljs-string">'A'</span></span>; show: <span class="hljs-string"><span class="hljs-string">'B'</span></span>.</code> </pre> <br><p> 在“ <code>Transcript</code>控制台窗口中顺序显示<code>A</code>和<code>B</code>行。 这相当于代码 </p><br><pre> <code class="smalltalk hljs"><span class="hljs-type"><span class="hljs-type">Transcript</span></span> show: <span class="hljs-string"><span class="hljs-string">'A'</span></span>. <span class="hljs-type"><span class="hljs-type">Transcript</span></span> show: <span class="hljs-string"><span class="hljs-string">'B'</span></span>.</code> </pre> <br><p> 但要避免重复Transcript消息接收者对象的名称。 级联的结果是对象对最后一条消息的响应。 </p><br><p> 从方法返回值 </p><br><pre> <code class="smalltalk hljs">^ x &lt; y</code> </pre> <br><p> 返回由<code>^</code>表示。 在这种情况下，将返回逻辑值-比较结果<code>x &lt; y</code> 。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446578/">https://habr.com/ru/post/zh-CN446578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446566/index.html">零项目。 亚马逊如何应对假货</a></li>
<li><a href="../zh-CN446568/index.html">Umbraco 8大规模CMS更新：新功能</a></li>
<li><a href="../zh-CN446570/index.html">第一个GPU的故事：RenditionVérité1000</a></li>
<li><a href="../zh-CN446572/index.html">Editor.js是一款出色的编辑器，可以将源代码保存为JSON格式</a></li>
<li><a href="../zh-CN446576/index.html">进口替代品，或俄罗斯直升机如何做错了事</a></li>
<li><a href="../zh-CN446582/index.html">关于养蜂养蜂的思考</a></li>
<li><a href="../zh-CN446586/index.html">通过DHCP从FreeRadius进行网络设置</a></li>
<li><a href="../zh-CN446588/index.html">检查Roslyn源代码</a></li>
<li><a href="../zh-CN446590/index.html">Java 12将提供39种新功能</a></li>
<li><a href="../zh-CN446592/index.html">检查Roslyn的源代码</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>