<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title> 猬锔  The Tale of the Dangerous std :: enable_shared_from_this, o el antipatr贸n Zombie   ぉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El art铆culo proporciona un antipatr贸n peligroso "Zombie", que en algunas situaciones surge naturalmente cuando se usa std :: enable_shared_from_this. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>The Tale of the Dangerous std :: enable_shared_from_this, o el antipatr贸n Zombie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471326/">  El art铆culo proporciona un antipatr贸n peligroso "Zombie", que en algunas situaciones surge naturalmente cuando se usa std :: enable_shared_from_this.  El material est谩 en alg煤n lugar en la uni贸n de la tecnolog铆a y la arquitectura modernas de C ++. <br><a name="habracut"></a><br><h3>  Introduccion </h3><br>  C ++ 11 proporcion贸 al desarrollador herramientas maravillosas para trabajar con memoria: punteros inteligentes std :: unique_ptr y un mont贸n de std :: shared_ptr + std :: weak_ptr.  El uso de punteros inteligentes para mayor comodidad y seguridad supera con creces el uso de punteros en bruto.  Los punteros inteligentes son ampliamente utilizados en la pr谩ctica, ya que  Permitir al desarrollador centrarse en problemas de nivel superior que el seguimiento de la correcci贸n de la creaci贸n / eliminaci贸n de entidades creadas din谩micamente. <br>  La plantilla de clase std :: enable_shared_from_this tambi茅n es parte del est谩ndar, y parece bastante extra帽o cuando la conoces por primera vez. <br>  El art铆culo discutir谩 c贸mo puede quedarse atascado con su uso. <br><br><h2>  Programa educativo </h2><br><div class="spoiler">  <b class="spoiler_title">RAII y punteros inteligentes</b> <div class="spoiler_text"> El prop贸sito directo de los punteros inteligentes es cuidar una <b>porci贸n de RAM</b> asignada en el mont贸n.  Los punteros inteligentes implementan el modismo RAII (la adquisici贸n de recursos es la inicializaci贸n) y se pueden adaptar f谩cilmente para cuidar otros tipos de recursos que requieren inicializaci贸n y una inicializaci贸n no trivial, como: <br>  - archivos; <br>  - carpetas temporales en el disco; <br>  - conexiones de red (http, websockets); <br>  - hilos de ejecuci贸n (hilos); <br>  - mutexes; <br>  - otro (que es suficiente para la fantas铆a). <br>  Para tal generalizaci贸n, es suficiente escribir una clase (de hecho, a veces incluso no puedes escribir una clase, solo usa deleter, pero hoy la historia no se trata de eso), que implementa: <br>  - inicializaci贸n en el constructor o en un m茅todo separado; <br>  - desinicializaci贸n en el destructor, <br>  luego "envu茅lvalo" en el puntero inteligente correspondiente, seg煤n el modelo de propiedad requerido: conjunto (std :: shared_ptr) o 煤nico (std :: unique_ptr).  Esto da como resultado una "RAII de dos capas": un puntero inteligente le permite transferir / compartir la propiedad del recurso, y la clase de usuario inicializa / desinicializa un recurso no est谩ndar. <br>  std :: shared_ptr usa un mecanismo de conteo de enlaces.  El est谩ndar define el contador de enlaces fuertes (cuenta el n煤mero de copias existentes de std :: shared_ptr) y el contador de enlaces d茅biles (cuenta el n煤mero de copias existentes de std :: weak_ptr creadas para esta instancia de std :: shared_ptr).  La presencia de al menos un enlace fuerte asegura que la destrucci贸n a煤n no se ha realizado.  Esta propiedad std :: shared_ptr se usa ampliamente para garantizar la validez de un objeto hasta que se complete el trabajo con 茅l en todas las partes del programa.  La presencia de un enlace d茅bil no evita la destrucci贸n del objeto y le permite obtener un enlace fuerte solo hasta que se destruya. <br>  RAII garantiza que la liberaci贸n de un recurso es mucho m谩s confiable que una llamada expl铆cita para eliminar / eliminar [] / free / close / reset / unlock, porque: <br>  - puedes simplemente olvidar la llamada expl铆cita; <br>  - una llamada expl铆cita puede hacerse err贸neamente m谩s de una vez; <br>  - un desaf铆o expl铆cito es dif铆cil cuando se implementa la propiedad compartida de un recurso; <br>  - el mecanismo de promoci贸n de pila en c ++ garantiza la llamada de destructores para todos los objetos que quedan fuera del alcance en caso de una excepci贸n. <br>  La garant铆a de la inicializaci贸n en el idioma es tan importante que merece un buen lugar en el nombre del idioma junto con la inicializaci贸n. <br>  Los punteros inteligentes tambi茅n tienen desventajas: <br>  - la presencia de sobrecarga en t茅rminos de rendimiento y memoria (para la mayor铆a de las aplicaciones no es significativa); <br>  - la posibilidad de que los enlaces c铆clicos bloqueen la liberaci贸n del recurso y conduzcan a su fuga. <br>  Seguramente, cada desarrollador m谩s de una vez ley贸 sobre enlaces circulares y vio ejemplos sint茅ticos de c贸digo problem谩tico. <br>  El peligro puede parecer insignificante por las siguientes razones: <br>  - si la memoria se pierde con frecuencia y mucho, esto es notable en su consumo, y si rara vez es escaso, entonces es poco probable que el problema se manifieste a nivel del usuario final; <br>  - utiliza an谩lisis de c贸digo din谩mico para fugas (Valgrind, Clang LeakSanitizer, etc.); <br>  - "No escribo as铆"; <br>  - "mi arquitectura es correcta"; <br>  "Nuestro c贸digo est谩 siendo revisado". <br></div></div><br><div class="spoiler">  <b class="spoiler_title">std :: enable_shared_from_this</b> <div class="spoiler_text">  En C ++ 11, se introduce la clase auxiliar std :: enable_shared_from_this.  Para un desarrollador que construye c贸digo exitosamente sin std :: enable_shared_from_this, los usos potenciales de esta clase pueden no ser obvios. <br>  驴Qu茅 hace std :: enable_shared_from_this? <br>  Permite que las funciones miembro de la clase que se instancian en std :: shared_ptr reciban copias adicionales fuertes (shared_from_this ()) o d茅biles (weak_from_this (), a partir de C ++ 17) de std :: shared_ptr en el que se cre贸 .  No puede llamar a shared_from_this () y weak_from_this () desde el constructor y destructor. <br><br>  <b>驴Por qu茅 tan dif铆cil?</b>  <b>Simplemente puede construir std :: shared_ptr &lt;T&gt; (esto)</b> <br>  No, no puedes.  Todos los std :: shared_ptrs que se preocupan por la misma instancia de la clase deben usar una unidad de conteo de enlaces.  No hay forma de hacerlo sin magia especial. <br><br>  Un requisito previo para usar std :: enable_shared_from_this es crear inicialmente un objeto de clase en std :: shared_ptr.  Crear en la pila, asignar din谩micamente en el mont贸n, crear en std :: unique_ptr: todo esto no es adecuado.  Solo estrictamente en std :: shared_ptr. <br><br>  <b>驴Es posible limitar al usuario en la forma de crear instancias de la clase?</b> <br>  Si puedes.  Para hacer esto, solo: <br>  - proporciona un m茅todo est谩tico para crear instancias ubicadas originalmente en std :: shared_ptr; <br>  - poner al constructor en privado o protegido; <br>  - Prohibir la sem谩ntica de copia y movimiento. <br>  La clase entr贸 en la jaula, la cerr贸 con llave y se trag贸 la llave; de ahora en adelante, todas sus instancias vivir谩n solo en std :: shared_ptr, y no hay formas legales de sacarlas de all铆. <br>  Dicha restricci贸n no puede llamarse una buena soluci贸n arquitect贸nica, pero este m茅todo cumple totalmente con el est谩ndar. <br>  Adem谩s, puede usar el lenguaje PIMPL: el 煤nico usuario de la clase caprichosa, la fachada, crear谩 la implementaci贸n estrictamente en std :: shared_ptr, y la fachada misma ya estar谩 privada de restricciones de este tipo. <br><br>  std :: enable_shared_from_this tiene muchos matices en la herencia, pero discutirlos est谩 m谩s all谩 del alcance de este art铆culo. <br></div></div><br><h2>  Llegar al punto </h2><br>  Todos los ejemplos de c贸digo proporcionados en el art铆culo se publican en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> . <br>  El c贸digo demuestra malas t茅cnicas disfrazadas como el uso seguro habitual de C ++ moderno <br><br><h3>  Simplec铆clico </h3><br>  Parece que nada augura problemas.  Una declaraci贸n de clase parece simple y directa.  Excepto por un detalle "peque帽o", por alguna raz贸n se aplica la herencia de std :: enable_shared_from_this. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;functional&gt; namespace SimpleCyclic { class Cyclic final : public std::enable_shared_from_this&lt;Cyclic&gt; { public: static std::shared_ptr&lt;Cyclic&gt; create(); Cyclic(const Cyclic&amp;) = delete; Cyclic(Cyclic&amp;&amp;) = delete; Cyclic&amp; operator=(const Cyclic&amp;) = delete; Cyclic&amp; operator=(Cyclic&amp;&amp;) = delete; ~Cyclic(); void doSomething(); private: Cyclic(); std::function&lt;void(void)&gt; _fn; }; } // namespace SimpleCyclic</span></span></span></span></code> </pre> <br></div></div><br>  Y en implementaci贸n: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "SimpleCyclic.h" namespace SimpleCyclic { Cyclic::Cyclic() = default; Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;Cyclic&gt; Cyclic::create() { return std::shared_ptr&lt;Cyclic&gt;(new Cyclic); } void Cyclic::doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace SimpleCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SimpleCyclic/SimpleCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto simpleCyclic = SimpleCyclic::Cyclic::create(); simpleCyclic-&gt;doSomething(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text"><blockquote>  N12SimpleCyclic6CyclicE :: doSomething <br></blockquote><br></div></div><br>  En el cuerpo de la funci贸n doSomething (), la instancia de la clase crear谩 una copia segura adicional de std :: shared_ptr en la que se coloc贸.  Luego, usando una captura generalizada, esta copia se coloca en una funci贸n lambda asignada al campo de datos de la clase bajo la apariencia de una funci贸n std :: inofensiva.  Una llamada a doSomething () da como resultado una referencia circular, y la instancia de clase ya no se destruir谩 incluso despu茅s de la destrucci贸n de todos los enlaces fuertes externos. <br>  Hay una p茅rdida de memoria.  No se llama al destructor SimpleCyclic :: Cyclic :: ~ Cyclic. <br><br>  <b>La instancia de clase "se mantiene" en s铆 misma.</b> <b><br></b>  <b>El c贸digo qued贸 atrapado en un nudo.</b> <br><br><img src="https://habrastorage.org/webt/xp/jj/_a/xpjj_atj4bf0av8kar46ebxqqew.jpeg"><br>  (imagen tomada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de aqu铆</a> ) <br><br>  <b>驴Y qu茅, este es el antipatr贸n "Zombie"?</b> <br>  No, esto es solo un entrenamiento.  Todo lo m谩s interesante est谩 por venir. <br><br>  <b>驴Por qu茅 el desarrollador escribi贸 esto?</b> <br>  Ejemplo sint茅tico  No tengo conocimiento de ninguna situaci贸n en la que dicho c贸digo se obtenga armoniosamente. <br><br>  <b>Entonces, 驴el an谩lisis de c贸digo din谩mico permaneci贸 en silencio?</b> <br>  No, Valgrind honestamente inform贸 una p茅rdida de memoria: <br><br><div class="spoiler">  <b class="spoiler_title">Publicar Valgrind</b> <div class="spoiler_text"><blockquote>  96 (64 directos, 32 indirectos) bytes en 1 bloques <b>definitivamente se pierden</b> en el registro de p茅rdidas 29 de 46 <br>  en SimpleCyclic :: Cyclic :: create () en /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  1: malloc en /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: operador nuevo (sin firmar largo) en /usr/lib/libc++abi.dylib <br>  3: SimpleCyclic :: Cyclic :: create () en /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  4: principal en /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/main.cpphaps <br></blockquote><br></div></div><br><h3>  Pimplc铆clico </h3><br>  En este caso, el archivo de encabezado se ve completamente correcto y conciso.  Declar贸 una fachada que almacena una determinada implementaci贸n en std :: shared_ptr.  Falta la herencia, incluso de std :: enable_shared_from_this, a diferencia del ejemplo anterior. <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace PimplCyclic { class Cyclic { public: Cyclic(); ~Cyclic(); private: class Impl; std::shared_ptr&lt;Impl&gt; _impl; }; } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br>  Y en implementaci贸n: <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; #include "PimplCyclic.h" namespace PimplCyclic { class Cyclic::Impl : public std::enable_shared_from_this&lt;Cyclic::Impl&gt; { public: ~Impl() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } private: std::function&lt;void(void)&gt; _fn; }; Cyclic::Cyclic() : _impl(std::make_shared&lt;Impl&gt;()) { if (_impl) { _impl-&gt;doSomething(); } } Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"PimplCyclic/PimplCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto pimplCyclic = PimplCyclic::Cyclic(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text"><blockquote>  N11PimplCyclic6Cyclic4ImplE :: doSomething <br>  N11PimplCyclic6CyclicE :: ~ Cyclic <br></blockquote><br></div></div><br>  Llamar a Impl :: doSomething () crea una referencia circular en una instancia de la clase Impl.  La fachada se destruye correctamente, pero la implementaci贸n tiene fugas.  No se llama al destructor PimplCyclic :: Cyclic :: Impl :: ~ Impl. <br>  El ejemplo es nuevamente sint茅tico, pero esta vez m谩s peligroso: todo el equipo defectuoso se encuentra en la implementaci贸n y no aparece en el anuncio. <br>  Adem谩s, para crear un enlace circular, el c贸digo de usuario no requiri贸 ninguna otra acci贸n que no sea la construcci贸n. <br>  Un an谩lisis din谩mico frente a Valgrind, y esta vez revel贸 una fuga: <br><br><div class="spoiler">  <b class="spoiler_title">Publicar Valgrind</b> <div class="spoiler_text"><blockquote>  96 bytes en 1 bloques <b>definitivamente se pierden</b> en el registro de p茅rdida 29 de 46 <br>  en PimplCyclic :: Cyclic :: Cyclic () en /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  1: malloc en /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: operador nuevo (sin firmar largo) en /usr/lib/libc++abi.dylib <br>  3: std :: __ 1 :: __ libcpp_allocate (sin signo largo, sin signo largo) en /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/new:252 <br>  4: std :: __ 1 :: asignador &lt;std :: __ 1 :: __ shared_ptr_emplace &lt;PimplCyclic :: Cyclic :: Impl, std :: __ 1 :: allocator &lt;PimplCyclic :: Cyclic :: Impl &gt;&gt;&gt; allocate (unsigned long , nulo const *) en /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:1813 <br>  5: std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; :: make_shared &lt;&gt; () en /Applications/Xcode.app/Contents /Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4326 <br>  6: _ZNSt3__1L11make_sharedIN11PimplCyclic6Cyclic4ImplEJEEENS_9enable_ifIXntsr8is_arrayIT_EE5valueENS_10shared_ptrIS5_EEE4typeEDpOT0_ en /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4706 <br>  7: PimplCyclic :: Cyclic :: Cyclic () en /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  8: PimplCyclic :: Cyclic :: Cyclic () en /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:29 <br>  9: principal en /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/main.cpphaps <br></blockquote><br></div></div><br>  <b>Es un poco sospechoso ver Pimpl, en el que la implementaci贸n se almacena en std :: shared_ptr.</b> <br>  El Pimpl cl谩sico basado en un puntero sin formato es demasiado arcaico, y std :: unique_ptr tiene el efecto secundario de difundir la prohibici贸n de la sem谩ntica de copias en la fachada.  Tal fachada implementar谩 el idioma de propiedad exclusiva, que puede no corresponder con la idea arquitect贸nica.  Del uso de std :: shared_ptr para almacenar la implementaci贸n, concluimos que la clase est谩 dise帽ada para proporcionar propiedad compartida. <br><br>  <b>驴C贸mo difiere esto de la fuga cl谩sica: asignar memoria llamando expl铆citamente a new sin eliminaci贸n posterior?</b>  <b>Del mismo modo, todo ser铆a hermoso en la interfaz y en la implementaci贸n: un error.</b> <br>  Estamos discutiendo formas <b>modernas</b> de dispararte en el pie. <br><br><h2>  "Zombis" antipatrones </h2><br>  Entonces, del material anterior est谩 claro: <br>  - los punteros inteligentes pueden vincularse en nodos; <br>  - el uso de std :: enable_shared_from_this puede contribuir a esto, porque  permite que una instancia de una clase se vincule a un nodo casi sin ayuda externa. <br><br>  <b>Y ahora, atenci贸n, la pregunta clave del art铆culo: 驴importa el tipo de recurso envuelto en un puntero inteligente?</b>  <b>驴Hay alguna diferencia entre el cuidado de un archivo RAII y una conexi贸n HTTPS as铆ncrona?</b> <br><br><h3>  Simplezomby </h3><br>  El c贸digo com煤n a todos los ejemplos posteriores de zombies se ha movido a la biblioteca com煤n. <br><br>  Interfaz zombie abstracta con el modesto nombre Manager: <br><br><div class="spoiler">  <b class="spoiler_title">Com煤n / Manager.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace Common { class Listener; class Manager { public: Manager() = default; Manager(const Manager&amp;) = delete; Manager(Manager&amp;&amp;) = delete; Manager&amp; operator=(const Manager&amp;) = delete; Manager&amp; operator=(Manager&amp;&amp;) = delete; virtual ~Manager() = default; virtual void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Interfaz abstracta del oyente, lista para aceptar texto seguro para subprocesos: <br><br><div class="spoiler">  <b class="spoiler_title">Common / Listener.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;memory&gt; namespace Common { class Listener { public: virtual ~Listener() = default; using Data = std::string; // thread-safe virtual void processData(const std::shared_ptr&lt;const Data&gt; data) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Oyente que muestra texto en la consola.  Implementa el concepto SingletonShared de mi art铆culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">T茅cnica para evitar comportamientos indefinidos al llamar a un Singleton</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Common / Impl / WriteToConsoleListener.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt; #include "Common/Listener.h" namespace Common { class WriteToConsoleListener final : public Listener { public: WriteToConsoleListener(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener(WriteToConsoleListener&amp;&amp;) = delete; WriteToConsoleListener&amp; operator=(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener&amp; operator=(WriteToConsoleListener&amp;&amp;) = delete; ~WriteToConsoleListener() override; static std::shared_ptr&lt;WriteToConsoleListener&gt; instance(); // blocking void processData(const std::shared_ptr&lt;const Data&gt; data) override; private: WriteToConsoleListener(); std::mutex _mutex; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Common / Impl / WriteToConsoleListener.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "WriteToConsoleListener.h" namespace Common { WriteToConsoleListener::WriteToConsoleListener() = default; WriteToConsoleListener::~WriteToConsoleListener() { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;WriteToConsoleListener&gt; WriteToConsoleListener::instance() { static auto inst = std::shared_ptr&lt;WriteToConsoleListener&gt;(new WriteToConsoleListener); return inst; } void WriteToConsoleListener::processData(const std::shared_ptr&lt;const Data&gt; data) { if (data) { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; *data &lt;&lt; std::flush; } } } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Y finalmente, el primer zombie, el m谩s simple e ingenuo. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SimpleZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; }; } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include "SimpleZomby.h" #include "Common/Listener.h" namespace SimpleZomby { std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::Zomby() = default; Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SimpleZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ while (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;("SimpleZomby is alive!\n")); std::this_thread::sleep_for(std::chrono::seconds(1)); } }); } } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br>  Un zombie ejecuta una funci贸n lambda en un hilo separado, enviando peri贸dicamente una cadena al oyente.  Las funciones de Lambda para el trabajo necesitan un sem谩foro y un oyente, que son campos de la clase zombie.  La funci贸n lambda no los captura como campos separados, sino que usa el objeto como un agregador.  Destruir una instancia de la clase zombie antes de que se complete la funci贸n lambda dar谩 como resultado un comportamiento indefinido.  Para evitar esto, la funci贸n lambda captura una copia segura de shared_from_this (). <br>  En el destructor de zombies, el sem谩foro se establece en falso, despu茅s de lo cual se llama a detach () para la secuencia.  Establecer el sem谩foro le dice al hilo que se apague. <br><br>  <b>En el destructor, era necesario llamar no detach (), sino unirse ()!</b> <br>  ... y obtener un destructor que bloquea la ejecuci贸n por tiempo indefinido, lo que puede ser inaceptable. <br><br>  <b>隆Entonces esto es una violaci贸n de RAII!</b>  <b>隆Se supon铆a que RAII deb铆a salir del destructor solo despu茅s de liberar el recurso!</b> <br>  Si es estrictamente, entonces s铆, el destructor zombie no libera el recurso, sino que solo <b>garantiza que se realizar谩 la liberaci贸n</b> .  En alg煤n momento producido, tal vez pronto, o tal vez no realmente.  E incluso es posible que main termine el trabajo antes, luego el sistema operativo borrar谩 el hilo a la fuerza.  Pero, de hecho, la l铆nea entre RAII "correcto" e "incorrecto" puede ser muy delgada: por ejemplo, RAII "correcto", que llama std :: filesystem :: remove () en un destructor para un archivo temporal, bien puede devolver el control a ese el momento en que el comando de escritura todav铆a estar谩 en cualquiera de los cach茅s vol谩tiles y no se escribir谩 honestamente en la placa magn茅tica del disco duro. <br><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "Common/Impl/WriteToConsoleListener.h" #include "SimpleZomby/SimpleZomby.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto simpleZomby = SimpleZomby::Zomby::create(); simpleZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zomby should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text"><blockquote>  SimpleZomby est谩 vivo! <br>  SimpleZomby est谩 vivo! <br>  SimpleZomby est谩 vivo! <br>  SimpleZomby est谩 vivo! <br>  SimpleZomby est谩 vivo! <br>  =================================================== =========== <br>  El |  Zomby fue asesinado | <br>  =================================================== =========== <br>  SimpleZomby est谩 vivo! <br>  SimpleZomby est谩 vivo! <br>  SimpleZomby est谩 vivo! <br>  SimpleZomby est谩 vivo! <br>  SimpleZomby est谩 vivo! <br></blockquote><br></div></div><br>  Lo que se puede ver en la salida del programa: <br>  - el zombie continu贸 trabajando incluso despu茅s de abandonar el campo de visibilidad; <br>  - no se llamaron destructores para zombies o WriteToConsoleListener. <br>  Se ha producido una p茅rdida de memoria. <br>  Hubo una fuga de recursos.  Y el recurso en este caso es el hilo de ejecuci贸n. <br>  El c贸digo que se supon铆a que deb铆a detenerse continu贸 funcionando en un hilo separado. <br>  Una fuga WriteToConsoleListener podr铆a haberse evitado mediante el uso de la t茅cnica SingletonWeak de mi art铆culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Evitar el comportamiento indeterminado al llamar a un Singleton</a> , pero no lo hice intencionalmente. <br><br><img src="https://habrastorage.org/webt/mg/qu/e3/mgque3fstboi4ot2hvdwniafixe.jpeg"><br>  (imagen tomada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de aqu铆</a> ) <br><br>  <b>驴Por qu茅 zombis?</b> <br>  Porque lo mataron y todav铆a est谩 vivo. <br><br>  <b>驴C贸mo difiere esto de las referencias circulares en ejemplos anteriores?</b> <br>  El hecho de que un recurso perdido no es solo una pieza de memoria, sino algo que ejecuta c贸digo independientemente del hilo que lo lanz贸. <br><br>  <b>驴Es posible destruir a los "zombis"?</b> <br>  Despu茅s de abandonar el alcance (es decir, despu茅s de destruir todas las referencias externas fuertes y d茅biles a zombies), es imposible.  Un zombie ser谩 destruido cuando decida destruirse a s铆 mismo (s铆, es algo con un comportamiento activo), tal vez nunca, es decir.  sobrevivir谩 hasta que el sistema operativo se limpie cuando la aplicaci贸n finalice.  Por supuesto, el c贸digo de usuario puede tener alg煤n efecto sobre la condici贸n para salir del c贸digo zombie, pero este efecto ser谩 indirecto y depender谩 de la implementaci贸n. <br><br>  <b>驴Y antes de salir del alcance?</b> <br>  Puede llamar expl铆citamente al destructor zombie, pero es poco probable que evite un comportamiento indefinido debido a la destrucci贸n repetida del objeto por el destructor de puntero inteligente tambi茅n: esta es una lucha contra RAII.  O puede agregar la funci贸n de inicializaci贸n expl铆cita, y esto es un rechazo de RAII. <br><br>  <b>驴En qu茅 se diferencia esto de comenzar un hilo seguido de detach ()?</b> <br>  En el caso de los zombis, en contraste con una simple llamada a detach (), existe la idea de detener el flujo.  Solo que no funciona.  Tener la idea correcta ayuda a enmascarar el problema. <br><br>  <b>驴El ejemplo sigue siendo sint茅tico?</b> <br>  En parte  En este simple ejemplo, no hab铆a suficientes razones para usar shared_from_this (); por ejemplo, podr铆a hacerlo con la captura de weak_from_this () o la captura de todos los campos obligatorios en la clase.  Pero con la complejidad de la tarea, el equilibrio puede desplazarse hacia un lado. <br>  shared_from_this (). <br><br>  <b>Valgrind, Valgrind!</b>  <b>隆Tenemos una l铆nea de defensa adicional contra zombies!</b> <br>  Ay y ah, pero Valgrind no revel贸 una p茅rdida de memoria.  驴Por qu茅? No lo s茅.  En el diagn贸stico, solo hay entradas <b>"posiblemente perdidas"</b> que indican las funciones del sistema, aproximadamente la misma cantidad y aproximadamente la misma cantidad que cuando se trabaja con una tuber铆a principal vac铆a.  No hay referencias de c贸digo de usuario.  Otras herramientas de an谩lisis din谩mico podr铆an funcionar mejor, pero si a煤n conf铆a en ellas, siga leyendo. <br><br><h3>  Steppingzomby </h3><br>  El c贸digo en este ejemplo contin煤a con los pasos resolveDnsName ---&gt; connectTcp ---&gt; establecerSsl ---&gt; sendHttpRequest ---&gt; readHttpReply, simulando la operaci贸n de la conexi贸n HTTPS del cliente en ejecuci贸n asincr贸nica.  Cada paso dura aproximadamente un segundo. <br><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SteppingZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; void resolveDnsName(); void connectTcp(); void establishSsl(); void sendHttpRequest(); void readHttpReply(); }; } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include &lt;string&gt; #include "SteppingZomby.h" #include "Common/Listener.h" namespace { void doSomething(Common::Listener&amp; listener, std::string&amp;&amp; callingFunctionName) { listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " started\n")); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " finished\n")); } } // namespace namespace SteppingZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SteppingZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;resolveDnsName(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;connectTcp(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;establishSsl(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;sendHttpRequest(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;readHttpReply(); } }); } void Zomby::resolveDnsName() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::connectTcp() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::establishSsl() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::sendHttpRequest() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::readHttpReply() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "SteppingZomby/SteppingZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto steppingZomby = SteppingZomby::Zomby::create(); steppingZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(1500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text"><blockquote>  N13SteppingZomby5ZombyE :: resolveDnsName iniciado <br>  N13SteppingZomby5ZombyE :: resolveDnsName terminado <br>  N13SteppingZomby5ZombyE :: connectTcp iniciado <br>  =================================================== =========== <br>  El |  Zomby fue asesinado | <br>  =================================================== =========== <br>  N13SteppingZomby5ZombyE :: connectTcp terminado <br>  N13SteppingZomby5ZombyE :: beginSsl inici贸 <br>  N13SteppingZomby5ZombyE :: establecerSsl terminado <br>  N13SteppingZomby5ZombyE :: sendHttpRequest inici贸 <br>  N13SteppingZomby5ZombyE :: sendHttpRequest finalizado <br>  N13SteppingZomby5ZombyE :: readHttpReply iniciado <br>  N13SteppingZomby5ZombyE :: readHttpReply terminado <br>  N13SteppingZomby5ZombyE :: ~ Zomby <br>  N6Common22WriteToConsoleListenerE :: ~ WriteToConsoleListener <br></blockquote><br></div></div><br>  Como en el ejemplo anterior, una llamada a runOnce () condujo a una referencia circular. <br>  Pero esta vez, se llamaron a los destructores Zomby y WriteToConsoleListener.  Todos los recursos se liberaron correctamente hasta que la aplicaci贸n finaliz贸.  No se produjo una p茅rdida de memoria. <br><br>  <b>驴Cu谩l es el problema entonces?</b> <br>  El problema es que el zombi vivi贸 demasiado tiempo, aproximadamente tres segundos y medio despu茅s de la destrucci贸n de todos los enlaces externos fuertes y d茅biles.  Unos tres segundos m谩s de lo que deber铆a haber vivido.  Y todo este tiempo estuvo involucrado en promover la implementaci贸n de la conexi贸n HTTPS, hasta que la finaliz贸.  A pesar de que el resultado ya no era necesario.  A pesar de que la l贸gica empresarial superior intent贸 detener a los zombis. <br><br>  <b>Bueno, pi茅nsalo, tienes la respuesta que no necesitas ...</b> <br>  En el caso de una conexi贸n HTTPS de cliente, las consecuencias <b>de nuestro lado</b> pueden ser las siguientes: <br>  - consumo de memoria; <br>  - consumo de CPU; <br>  - consumo de puerto TCP; <br>  - el ancho de banda del canal de comunicaci贸n (tanto la solicitud como la respuesta pueden ser un volumen en megabytes); <br>  - los datos inesperados pueden interrumpir el funcionamiento de la l贸gica empresarial de nivel superior, hasta la transici贸n a la rama de ejecuci贸n incorrecta o al comportamiento indefinido, porque  los mecanismos de procesamiento de respuesta ya pueden estar destruidos. <br>  Y <b>en el lado remoto</b> (no lo olvide, la solicitud HTTPS estaba destinada a alguien), exactamente el mismo desperdicio de recursos, adem谩s es posible: <br>  - publicar fotos de gatos en un sitio web corporativo; <br>  - deshabilitar la calefacci贸n por suelo radiante en su cocina; <br>  - ejecuci贸n de una orden comercial en el intercambio; <br>  - transferencia de dinero desde su cuenta; <br>  - lanzamiento de un misil bal铆stico intercontinental. <br>  La l贸gica de negocios trat贸 de detener a los zombies eliminando todos los enlaces fuertes y d茅biles.  Se <b>supon铆a que deb铆a</b> detenerse el progreso de la solicitud HTTPS: todav铆a no era demasiado tarde, los datos del nivel de la aplicaci贸n a煤n no se hab铆an enviado. <br>  Pero los zombis decidieron a su manera. <br><br>  La l贸gica empresarial puede crear nuevos objetos en lugar de zombies y nuevamente intentar destruirlos, multiplicando la fuga de recursos. <br>  En el caso de un proceso continuo (por ejemplo, una conexi贸n Websocket), el desperdicio de recursos puede continuar durante horas, y si hay un mecanismo de reconexi贸n autom谩tica en la implementaci贸n cuando se desconecta la conexi贸n, generalmente se puede detener. <br><br>  <b>Valgrind?</b> <br>  No hay posibilidad  Todo se ha liberado y limpiado correctamente.  Tarde y no desde el hilo principal, pero completamente correcto. <br><br><h3>  Boozdedzomby </h3><br>  Este ejemplo utiliza la biblioteca boozd :: azzio, que es una imitaci贸n de boost :: asio.  A pesar de que la simulaci贸n es bastante cruda, nos permite demostrar la esencia del problema.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La biblioteca tiene una funci贸n io_context :: async_read (en el original, es gratuita, pero no cambia la esencia), que acepta: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- flujo, de donde pueden venir los datos; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- un b煤fer que le permite acumular estos datos; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- una funci贸n de devoluci贸n de llamada que se llamar谩 al finalizar la lectura de datos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci贸n io_context :: async_read se ejecuta instant谩neamente y nunca llama a la devoluci贸n de llamada, incluso si el resultado de la ejecuci贸n ya se conoce (por ejemplo, un error). </font><font style="vertical-align: inherit;">Solo se llama a una devoluci贸n de llamada desde la funci贸n de bloqueo io_context :: run () (en el original, hay otras funciones dise帽adas para llamar a devoluciones de llamada tan pronto como los datos est茅n listos).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buffer.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; namespace boozd::azzio { using buffer = std::vector&lt;int&gt;; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;optional&gt; namespace boozd::azzio { class stream { public: virtual ~stream() = default; virtual std::optional&lt;int&gt; read() = 0; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io_context.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; #include &lt;optional&gt; #include "buffer.h" namespace boozd::azzio { class stream; class io_context { public: ~io_context(); enum class error_code {no_error, good_error, bad_error, unknown_error, known_error, well_known_error}; using handler = std::function&lt;void(error_code)&gt;; // Start an asynchronous operation to read a certain amount of data from a stream. // This function is used to asynchronously read a certain number of bytes of data from a stream. // The function call always returns immediately. void async_read(stream&amp; s, buffer&amp; b, handler&amp;&amp; handler); // Run the io_context object's event processing loop. void run(); private: using pack = std::tuple&lt;stream&amp;, buffer&amp;&gt;; using pack_optional = std::optional&lt;pack&gt;; using handler_optional = std::optional&lt;handler&gt;; pack_optional _pack_optional; handler_optional _handler_optional; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io_context.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;thread&gt; #include &lt;chrono&gt; #include "io_context.h" #include "stream.h" namespace boozd::azzio { io_context::~io_context() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void io_context::async_read(stream&amp; s, buffer&amp; b, io_context::handler&amp;&amp; handler) { _pack_optional.emplace(s, b); _handler_optional.emplace(std::move(handler)); } void io_context::run() { if (_pack_optional &amp;&amp; _handler_optional) { auto&amp; [s, b] = *_pack_optional; using namespace std::chrono; auto start = steady_clock::now(); while (duration_cast&lt;milliseconds&gt;(steady_clock::now() - start).count() &lt; 1000) { if (auto read = s.read()) b.emplace_back(*read); std::this_thread::sleep_for(milliseconds(100)); } (*_handler_optional)(error_code::no_error); } } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La 煤nica implementaci贸n de interfaz boozd :: azzio :: stream que produce datos aleatorios: </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impl / random_stream.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"boozd/azzio/stream.h"</span></span></span><span class="hljs-meta"> namespace boozd::azzio { class random_stream final : public stream { public: ~random_stream() override; std::optional</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int&gt; read() override; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impl / random_stream.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "random_stream.h" namespace boozd::azzio { boozd::azzio::random_stream::~random_stream() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::optional&lt;int&gt; random_stream::read() { if (!(rand() &amp; 0x1)) return rand(); return std::nullopt; } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BoozdedZomby ejecuta una funci贸n lambda en un hilo separado. </font><font style="vertical-align: inherit;">La funci贸n lambda registra el controlador llamando a async_read (), despu茅s de lo cual le da control a los mecanismos internos de boozd :: azzio usando run (). </font><font style="vertical-align: inherit;">Despu茅s de eso, los mecanismos internos de boozd :: azzio pueden realizar llamadas al b煤fer y al flujo (fuente de datos) en cualquier momento antes de llamar a la funci贸n de devoluci贸n de llamada. </font><font style="vertical-align: inherit;">Para garantizar la validez de muchos objetos agregados en una instancia de la clase, la funci贸n lambda captura shared_from_this.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BoozdedZomby.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" #include "boozd/azzio/buffer.h" #include "boozd/azzio/io_context.h" #include "boozd/azzio/impl/random_stream.h" namespace Common { class Listener; } // namespace Common namespace BoozdedZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; Semaphore _semaphore = false; std::shared_ptr&lt;Common::Listener&gt; _listener; boozd::azzio::random_stream _stream; boozd::azzio::buffer _buffer; boozd::azzio::io_context _context; std::thread _thread; }; } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boozdedzomby.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;sstream&gt; #include "boozd/azzio/impl/random_stream.h" #include "BoozdedZomby.h" #include "Common/Listener.h" namespace BoozdedZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("BoozdedZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()]() { while (shis &amp;&amp; shis-&gt;_semaphore &amp;&amp; shis-&gt;_listener) { auto handler = [shis](auto errorCode) { if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; errorCode == boozd::azzio::io_context::error_code::no_error) { std::ostringstream buf; buf &lt;&lt; "BoozdedZomby has got a fresh data: "; for (auto const &amp;elem : shis-&gt;_buffer) buf &lt;&lt; elem &lt;&lt; ' '; buf &lt;&lt; std::endl; shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } }; shis-&gt;_buffer.clear(); shis-&gt;_context.async_read(shis-&gt;_stream, shis-&gt;_buffer, handler); shis-&gt;_context.run(); } }); } } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "BoozdedZomby/BoozdedZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto boozdedZomby = BoozdedZomby::Zomby::create(); boozdedZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salida de la consola</font></font></b> <div class="spoiler_text"><blockquote> BoozdedZomby has got a fresh data: 1144108930 101027544 1458777923 1115438165 74243042 <br> BoozdedZomby has got a fresh data: 143542612 1131570933 <br> BoozdedZomby has got a fresh data: 893351816 563613512 704877633 <br> BoozdedZomby has got a fresh data: 1551901393 1399125485 1899894091 937186357 590357944 357571490 <br> ============================================================ <br>  El | Zomby was killed | <br> ============================================================ <br> BoozdedZomby has got a fresh data: 1927702196 130060903 1083454666 2118797801 2035308228 824938981 <br> BoozdedZomby has got a fresh data: 2020739063 1635339425 34075629 <br> BoozdedZomby has got a fresh data: 2146319451 500782188 1269406752 884936716 892053144 <br> BoozdedZomby has got a fresh data: 330111137 1723153177 1070477904 <br> BoozdedZomby has got a fresh data: 343098142 280090412 589673557 889688008 2014119113 388471006 <br></blockquote><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una llamada a run_once () provoc贸 una referencia circular. Zombie continu贸 trabajando incluso despu茅s de abandonar el campo de visibilidad. No se llamaron a los destructores para muchos objetos creados durante el programa: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- boozdedZomby; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- writeToConsoleListener; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- campos de datos zombie. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se ha producido una p茅rdida de memoria. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hubo una fuga de recursos. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">驴C贸mo es este ejemplo diferente de los anteriores?</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Est谩 mucho m谩s cerca del c贸digo real. Esto ya no es un ejemplo sint茅tico. Tal c贸digo puede ocurrir naturalmente cuando se usa boost :: asio. Adem谩s, no se puede solucionar simplemente neg谩ndose a capturar un enlace fuerte a favor de uno d茅bil; esto interferir谩 con la validez del b煤fer y la transmisi贸n (fuente de datos). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valgrind?</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasado </font><font style="vertical-align: inherit;">Aunque parece haber sido detectar fugas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zombis en la naturaleza </font></font></h2><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隆El problema es descabellado! 隆Entonces nadie escribe!</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como 茅l escribe. </font></font><br> <a href="https://www.boost.org/doc/libs/master/libs/beast/example/http/client/async/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de cliente HTTP Ejemplo de cliente </font></font></a> <br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Websocket</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La documentaci贸n oficial de impulso ense帽a c贸mo escribir un BoozdedZomby + SteppingZomby h铆brido. Es imposible detenerlo, pero nadie lo est谩 intentando. Espec铆ficamente, en el c贸digo de demostraci贸n, la propiedad principal del zombie no aparece, pero debes transferir esto a producci贸n, y ahora ya est谩s caminando por el borde, probablemente incluso en el lado oscuro. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隆Puedes detener a los zombies destruyendo la instancia de boost :: asio :: io_context!</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... en el camino, destruyendo otras n entidades (posiblemente no zombis) que viven en este contexto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M谩s ejemplos: </font></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu铆 hay un ejemplo similar en un recurso de terceros. </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu铆 una persona hace una pregunta sobre stackoverflow, 驴c贸mo har铆a que su c贸digo sea m谩s zombie?</font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu铆 hay otro preguntando por qu茅 su amado zombie no est谩 trabajando. </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu铆 hay un hombre asustado de mensajes sobre p茅rdidas de memoria cuando opera un zombie.</font></font></a> <br><br><h2>  Conclusi贸n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, el art铆culo no describe todas las variedades de los "zombis" antipatr贸n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se puede encontrar tanto en forma de h铆bridos de los tipos anteriores como en forma de nuevos tipos independientes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El antipatr贸n puede ocurrir no solo cuando se inicia std :: thread en su c贸digo; esta parte del trabajo puede ser asumida por una biblioteca multiproceso de terceros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un enlace c铆clico puede ser m谩s largo que en los ejemplos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La arquitectura puede ser controlada por eventos o basada en encuestas peri贸dicas basadas en encuestas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo esto no es muy importante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es importante que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antipattern comienza con la instancia de la clase obteniendo una fuerte referencia a s铆 misma. Casi siempre se genera usando std :: enable_shared_from_this, aunque tambi茅n se puede proporcionar externamente (incluso como un enlace d茅bil, la clase en s铆 misma puede hacerlo fuerte). Tal vez solo haya una excepci贸n ex贸tica a esta regla: cuando el c贸digo externo proporciona una referencia fuerte o d茅bil a una instancia de una clase en uno de sus campos de datos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El an谩lisis de c贸digo din谩mico puede no ser capaz de detectar este antipatr贸n, especialmente su versi贸n de SteppingZomby. Tambi茅n hay pocas esperanzas para el an谩lisis est谩tico: una l铆nea muy delgada entre el uso correcto e incorrecto de shared_from_this (todos los ejemplos de c贸digo dados en el art铆culo se pueden corregir introduciendo cambios muy peque帽os, solo de 1 a 6 l铆neas de c贸digo).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las pruebas autom谩ticas pueden ayudar a identificarlo y verificar la correcci贸n de la eliminaci贸n, pero para esto necesita saber qu茅 buscar. </font><font style="vertical-align: inherit;">Absolutamente saber </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buscar antipatr贸n, aqu铆 y all谩, tendr谩 que hacerlo manualmente. </font><font style="vertical-align: inherit;">Y para esto necesita repensar todas las aplicaciones de std :: enable_shared_from_this, son </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peligrosas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PD: de acuerdo con los resultados de la votaci贸n, preparar茅 un art铆culo separado con una discusi贸n sobre las opciones para eliminar el antipatr贸n.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471326/">https://habr.com/ru/post/471326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471310/index.html">Mi opini贸n muy subjetiva sobre la educaci贸n profesional y no solo en TI</a></li>
<li><a href="../471312/index.html">Preparaci贸n para la certificaci贸n profesional de primavera. Bota de primavera</a></li>
<li><a href="../471318/index.html">Resumen de noticias de septiembre sobre aprendizaje autom谩tico e inteligencia artificial</a></li>
<li><a href="../471320/index.html">Herramientas para desarrolladores de software: Open Framework y bibliotecas de aprendizaje autom谩tico</a></li>
<li><a href="../471324/index.html">驴Las redes neuronales sue帽an con la Mona Lisa?</a></li>
<li><a href="../471330/index.html">Historias de la computadora lunar. Parte 2</a></li>
<li><a href="../471332/index.html">Historias de la computadora lunar. Parte 3</a></li>
<li><a href="../471334/index.html">Para memorizar, pero no para api帽ar: aprender "por cartas"</a></li>
<li><a href="../471336/index.html">Holivar Historia de Runet. Parte 6. Cerraduras: acecho, cinta, camino 282 y chino</a></li>
<li><a href="../471340/index.html">Drimsim vs Mate 20 Pro Round! 驴Pero para quien?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>