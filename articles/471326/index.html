<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐞 ⬜️ 😺 The Tale of the Dangerous std :: enable_shared_from_this, o el antipatrón Zombie 🎡 🎰 🤩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El artículo proporciona un antipatrón peligroso "Zombie", que en algunas situaciones surge naturalmente cuando se usa std :: enable_shared_from_this. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>The Tale of the Dangerous std :: enable_shared_from_this, o el antipatrón Zombie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471326/">  El artículo proporciona un antipatrón peligroso "Zombie", que en algunas situaciones surge naturalmente cuando se usa std :: enable_shared_from_this.  El material está en algún lugar en la unión de la tecnología y la arquitectura modernas de C ++. <br><a name="habracut"></a><br><h3>  Introduccion </h3><br>  C ++ 11 proporcionó al desarrollador herramientas maravillosas para trabajar con memoria: punteros inteligentes std :: unique_ptr y un montón de std :: shared_ptr + std :: weak_ptr.  El uso de punteros inteligentes para mayor comodidad y seguridad supera con creces el uso de punteros en bruto.  Los punteros inteligentes son ampliamente utilizados en la práctica, ya que  Permitir al desarrollador centrarse en problemas de nivel superior que el seguimiento de la corrección de la creación / eliminación de entidades creadas dinámicamente. <br>  La plantilla de clase std :: enable_shared_from_this también es parte del estándar, y parece bastante extraño cuando la conoces por primera vez. <br>  El artículo discutirá cómo puede quedarse atascado con su uso. <br><br><h2>  Programa educativo </h2><br><div class="spoiler">  <b class="spoiler_title">RAII y punteros inteligentes</b> <div class="spoiler_text"> El propósito directo de los punteros inteligentes es cuidar una <b>porción de RAM</b> asignada en el montón.  Los punteros inteligentes implementan el modismo RAII (la adquisición de recursos es la inicialización) y se pueden adaptar fácilmente para cuidar otros tipos de recursos que requieren inicialización y una inicialización no trivial, como: <br>  - archivos; <br>  - carpetas temporales en el disco; <br>  - conexiones de red (http, websockets); <br>  - hilos de ejecución (hilos); <br>  - mutexes; <br>  - otro (que es suficiente para la fantasía). <br>  Para tal generalización, es suficiente escribir una clase (de hecho, a veces incluso no puedes escribir una clase, solo usa deleter, pero hoy la historia no se trata de eso), que implementa: <br>  - inicialización en el constructor o en un método separado; <br>  - desinicialización en el destructor, <br>  luego "envuélvalo" en el puntero inteligente correspondiente, según el modelo de propiedad requerido: conjunto (std :: shared_ptr) o único (std :: unique_ptr).  Esto da como resultado una "RAII de dos capas": un puntero inteligente le permite transferir / compartir la propiedad del recurso, y la clase de usuario inicializa / desinicializa un recurso no estándar. <br>  std :: shared_ptr usa un mecanismo de conteo de enlaces.  El estándar define el contador de enlaces fuertes (cuenta el número de copias existentes de std :: shared_ptr) y el contador de enlaces débiles (cuenta el número de copias existentes de std :: weak_ptr creadas para esta instancia de std :: shared_ptr).  La presencia de al menos un enlace fuerte asegura que la destrucción aún no se ha realizado.  Esta propiedad std :: shared_ptr se usa ampliamente para garantizar la validez de un objeto hasta que se complete el trabajo con él en todas las partes del programa.  La presencia de un enlace débil no evita la destrucción del objeto y le permite obtener un enlace fuerte solo hasta que se destruya. <br>  RAII garantiza que la liberación de un recurso es mucho más confiable que una llamada explícita para eliminar / eliminar [] / free / close / reset / unlock, porque: <br>  - puedes simplemente olvidar la llamada explícita; <br>  - una llamada explícita puede hacerse erróneamente más de una vez; <br>  - un desafío explícito es difícil cuando se implementa la propiedad compartida de un recurso; <br>  - el mecanismo de promoción de pila en c ++ garantiza la llamada de destructores para todos los objetos que quedan fuera del alcance en caso de una excepción. <br>  La garantía de la inicialización en el idioma es tan importante que merece un buen lugar en el nombre del idioma junto con la inicialización. <br>  Los punteros inteligentes también tienen desventajas: <br>  - la presencia de sobrecarga en términos de rendimiento y memoria (para la mayoría de las aplicaciones no es significativa); <br>  - la posibilidad de que los enlaces cíclicos bloqueen la liberación del recurso y conduzcan a su fuga. <br>  Seguramente, cada desarrollador más de una vez leyó sobre enlaces circulares y vio ejemplos sintéticos de código problemático. <br>  El peligro puede parecer insignificante por las siguientes razones: <br>  - si la memoria se pierde con frecuencia y mucho, esto es notable en su consumo, y si rara vez es escaso, entonces es poco probable que el problema se manifieste a nivel del usuario final; <br>  - utiliza análisis de código dinámico para fugas (Valgrind, Clang LeakSanitizer, etc.); <br>  - "No escribo así"; <br>  - "mi arquitectura es correcta"; <br>  "Nuestro código está siendo revisado". <br></div></div><br><div class="spoiler">  <b class="spoiler_title">std :: enable_shared_from_this</b> <div class="spoiler_text">  En C ++ 11, se introduce la clase auxiliar std :: enable_shared_from_this.  Para un desarrollador que construye código exitosamente sin std :: enable_shared_from_this, los usos potenciales de esta clase pueden no ser obvios. <br>  ¿Qué hace std :: enable_shared_from_this? <br>  Permite que las funciones miembro de la clase que se instancian en std :: shared_ptr reciban copias adicionales fuertes (shared_from_this ()) o débiles (weak_from_this (), a partir de C ++ 17) de std :: shared_ptr en el que se creó .  No puede llamar a shared_from_this () y weak_from_this () desde el constructor y destructor. <br><br>  <b>¿Por qué tan difícil?</b>  <b>Simplemente puede construir std :: shared_ptr &lt;T&gt; (esto)</b> <br>  No, no puedes.  Todos los std :: shared_ptrs que se preocupan por la misma instancia de la clase deben usar una unidad de conteo de enlaces.  No hay forma de hacerlo sin magia especial. <br><br>  Un requisito previo para usar std :: enable_shared_from_this es crear inicialmente un objeto de clase en std :: shared_ptr.  Crear en la pila, asignar dinámicamente en el montón, crear en std :: unique_ptr: todo esto no es adecuado.  Solo estrictamente en std :: shared_ptr. <br><br>  <b>¿Es posible limitar al usuario en la forma de crear instancias de la clase?</b> <br>  Si puedes.  Para hacer esto, solo: <br>  - proporciona un método estático para crear instancias ubicadas originalmente en std :: shared_ptr; <br>  - poner al constructor en privado o protegido; <br>  - Prohibir la semántica de copia y movimiento. <br>  La clase entró en la jaula, la cerró con llave y se tragó la llave; de ​​ahora en adelante, todas sus instancias vivirán solo en std :: shared_ptr, y no hay formas legales de sacarlas de allí. <br>  Dicha restricción no puede llamarse una buena solución arquitectónica, pero este método cumple totalmente con el estándar. <br>  Además, puede usar el lenguaje PIMPL: el único usuario de la clase caprichosa, la fachada, creará la implementación estrictamente en std :: shared_ptr, y la fachada misma ya estará privada de restricciones de este tipo. <br><br>  std :: enable_shared_from_this tiene muchos matices en la herencia, pero discutirlos está más allá del alcance de este artículo. <br></div></div><br><h2>  Llegar al punto </h2><br>  Todos los ejemplos de código proporcionados en el artículo se publican en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> . <br>  El código demuestra malas técnicas disfrazadas como el uso seguro habitual de C ++ moderno <br><br><h3>  Simplecíclico </h3><br>  Parece que nada augura problemas.  Una declaración de clase parece simple y directa.  Excepto por un detalle "pequeño", por alguna razón se aplica la herencia de std :: enable_shared_from_this. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;functional&gt; namespace SimpleCyclic { class Cyclic final : public std::enable_shared_from_this&lt;Cyclic&gt; { public: static std::shared_ptr&lt;Cyclic&gt; create(); Cyclic(const Cyclic&amp;) = delete; Cyclic(Cyclic&amp;&amp;) = delete; Cyclic&amp; operator=(const Cyclic&amp;) = delete; Cyclic&amp; operator=(Cyclic&amp;&amp;) = delete; ~Cyclic(); void doSomething(); private: Cyclic(); std::function&lt;void(void)&gt; _fn; }; } // namespace SimpleCyclic</span></span></span></span></code> </pre> <br></div></div><br>  Y en implementación: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "SimpleCyclic.h" namespace SimpleCyclic { Cyclic::Cyclic() = default; Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;Cyclic&gt; Cyclic::create() { return std::shared_ptr&lt;Cyclic&gt;(new Cyclic); } void Cyclic::doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace SimpleCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SimpleCyclic/SimpleCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto simpleCyclic = SimpleCyclic::Cyclic::create(); simpleCyclic-&gt;doSomething(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text"><blockquote>  N12SimpleCyclic6CyclicE :: doSomething <br></blockquote><br></div></div><br>  En el cuerpo de la función doSomething (), la instancia de la clase creará una copia segura adicional de std :: shared_ptr en la que se colocó.  Luego, usando una captura generalizada, esta copia se coloca en una función lambda asignada al campo de datos de la clase bajo la apariencia de una función std :: inofensiva.  Una llamada a doSomething () da como resultado una referencia circular, y la instancia de clase ya no se destruirá incluso después de la destrucción de todos los enlaces fuertes externos. <br>  Hay una pérdida de memoria.  No se llama al destructor SimpleCyclic :: Cyclic :: ~ Cyclic. <br><br>  <b>La instancia de clase "se mantiene" en sí misma.</b> <b><br></b>  <b>El código quedó atrapado en un nudo.</b> <br><br><img src="https://habrastorage.org/webt/xp/jj/_a/xpjj_atj4bf0av8kar46ebxqqew.jpeg"><br>  (imagen tomada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de aquí</a> ) <br><br>  <b>¿Y qué, este es el antipatrón "Zombie"?</b> <br>  No, esto es solo un entrenamiento.  Todo lo más interesante está por venir. <br><br>  <b>¿Por qué el desarrollador escribió esto?</b> <br>  Ejemplo sintético  No tengo conocimiento de ninguna situación en la que dicho código se obtenga armoniosamente. <br><br>  <b>Entonces, ¿el análisis de código dinámico permaneció en silencio?</b> <br>  No, Valgrind honestamente informó una pérdida de memoria: <br><br><div class="spoiler">  <b class="spoiler_title">Publicar Valgrind</b> <div class="spoiler_text"><blockquote>  96 (64 directos, 32 indirectos) bytes en 1 bloques <b>definitivamente se pierden</b> en el registro de pérdidas 29 de 46 <br>  en SimpleCyclic :: Cyclic :: create () en /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  1: malloc en /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: operador nuevo (sin firmar largo) en /usr/lib/libc++abi.dylib <br>  3: SimpleCyclic :: Cyclic :: create () en /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  4: principal en /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/main.cpphaps <br></blockquote><br></div></div><br><h3>  Pimplcíclico </h3><br>  En este caso, el archivo de encabezado se ve completamente correcto y conciso.  Declaró una fachada que almacena una determinada implementación en std :: shared_ptr.  Falta la herencia, incluso de std :: enable_shared_from_this, a diferencia del ejemplo anterior. <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace PimplCyclic { class Cyclic { public: Cyclic(); ~Cyclic(); private: class Impl; std::shared_ptr&lt;Impl&gt; _impl; }; } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br>  Y en implementación: <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; #include "PimplCyclic.h" namespace PimplCyclic { class Cyclic::Impl : public std::enable_shared_from_this&lt;Cyclic::Impl&gt; { public: ~Impl() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } private: std::function&lt;void(void)&gt; _fn; }; Cyclic::Cyclic() : _impl(std::make_shared&lt;Impl&gt;()) { if (_impl) { _impl-&gt;doSomething(); } } Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"PimplCyclic/PimplCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto pimplCyclic = PimplCyclic::Cyclic(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text"><blockquote>  N11PimplCyclic6Cyclic4ImplE :: doSomething <br>  N11PimplCyclic6CyclicE :: ~ Cyclic <br></blockquote><br></div></div><br>  Llamar a Impl :: doSomething () crea una referencia circular en una instancia de la clase Impl.  La fachada se destruye correctamente, pero la implementación tiene fugas.  No se llama al destructor PimplCyclic :: Cyclic :: Impl :: ~ Impl. <br>  El ejemplo es nuevamente sintético, pero esta vez más peligroso: todo el equipo defectuoso se encuentra en la implementación y no aparece en el anuncio. <br>  Además, para crear un enlace circular, el código de usuario no requirió ninguna otra acción que no sea la construcción. <br>  Un análisis dinámico frente a Valgrind, y esta vez reveló una fuga: <br><br><div class="spoiler">  <b class="spoiler_title">Publicar Valgrind</b> <div class="spoiler_text"><blockquote>  96 bytes en 1 bloques <b>definitivamente se pierden</b> en el registro de pérdida 29 de 46 <br>  en PimplCyclic :: Cyclic :: Cyclic () en /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  1: malloc en /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: operador nuevo (sin firmar largo) en /usr/lib/libc++abi.dylib <br>  3: std :: __ 1 :: __ libcpp_allocate (sin signo largo, sin signo largo) en /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/new:252 <br>  4: std :: __ 1 :: asignador &lt;std :: __ 1 :: __ shared_ptr_emplace &lt;PimplCyclic :: Cyclic :: Impl, std :: __ 1 :: allocator &lt;PimplCyclic :: Cyclic :: Impl &gt;&gt;&gt; allocate (unsigned long , nulo const *) en /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:1813 <br>  5: std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; :: make_shared &lt;&gt; () en /Applications/Xcode.app/Contents /Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4326 <br>  6: _ZNSt3__1L11make_sharedIN11PimplCyclic6Cyclic4ImplEJEEENS_9enable_ifIXntsr8is_arrayIT_EE5valueENS_10shared_ptrIS5_EEE4typeEDpOT0_ en /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4706 <br>  7: PimplCyclic :: Cyclic :: Cyclic () en /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  8: PimplCyclic :: Cyclic :: Cyclic () en /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:29 <br>  9: principal en /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/main.cpphaps <br></blockquote><br></div></div><br>  <b>Es un poco sospechoso ver Pimpl, en el que la implementación se almacena en std :: shared_ptr.</b> <br>  El Pimpl clásico basado en un puntero sin formato es demasiado arcaico, y std :: unique_ptr tiene el efecto secundario de difundir la prohibición de la semántica de copias en la fachada.  Tal fachada implementará el idioma de propiedad exclusiva, que puede no corresponder con la idea arquitectónica.  Del uso de std :: shared_ptr para almacenar la implementación, concluimos que la clase está diseñada para proporcionar propiedad compartida. <br><br>  <b>¿Cómo difiere esto de la fuga clásica: asignar memoria llamando explícitamente a new sin eliminación posterior?</b>  <b>Del mismo modo, todo sería hermoso en la interfaz y en la implementación: un error.</b> <br>  Estamos discutiendo formas <b>modernas</b> de dispararte en el pie. <br><br><h2>  "Zombis" antipatrones </h2><br>  Entonces, del material anterior está claro: <br>  - los punteros inteligentes pueden vincularse en nodos; <br>  - el uso de std :: enable_shared_from_this puede contribuir a esto, porque  permite que una instancia de una clase se vincule a un nodo casi sin ayuda externa. <br><br>  <b>Y ahora, atención, la pregunta clave del artículo: ¿importa el tipo de recurso envuelto en un puntero inteligente?</b>  <b>¿Hay alguna diferencia entre el cuidado de un archivo RAII y una conexión HTTPS asíncrona?</b> <br><br><h3>  Simplezomby </h3><br>  El código común a todos los ejemplos posteriores de zombies se ha movido a la biblioteca común. <br><br>  Interfaz zombie abstracta con el modesto nombre Manager: <br><br><div class="spoiler">  <b class="spoiler_title">Común / Manager.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace Common { class Listener; class Manager { public: Manager() = default; Manager(const Manager&amp;) = delete; Manager(Manager&amp;&amp;) = delete; Manager&amp; operator=(const Manager&amp;) = delete; Manager&amp; operator=(Manager&amp;&amp;) = delete; virtual ~Manager() = default; virtual void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Interfaz abstracta del oyente, lista para aceptar texto seguro para subprocesos: <br><br><div class="spoiler">  <b class="spoiler_title">Common / Listener.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;memory&gt; namespace Common { class Listener { public: virtual ~Listener() = default; using Data = std::string; // thread-safe virtual void processData(const std::shared_ptr&lt;const Data&gt; data) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Oyente que muestra texto en la consola.  Implementa el concepto SingletonShared de mi artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Técnica para evitar comportamientos indefinidos al llamar a un Singleton</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Common / Impl / WriteToConsoleListener.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt; #include "Common/Listener.h" namespace Common { class WriteToConsoleListener final : public Listener { public: WriteToConsoleListener(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener(WriteToConsoleListener&amp;&amp;) = delete; WriteToConsoleListener&amp; operator=(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener&amp; operator=(WriteToConsoleListener&amp;&amp;) = delete; ~WriteToConsoleListener() override; static std::shared_ptr&lt;WriteToConsoleListener&gt; instance(); // blocking void processData(const std::shared_ptr&lt;const Data&gt; data) override; private: WriteToConsoleListener(); std::mutex _mutex; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Common / Impl / WriteToConsoleListener.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "WriteToConsoleListener.h" namespace Common { WriteToConsoleListener::WriteToConsoleListener() = default; WriteToConsoleListener::~WriteToConsoleListener() { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;WriteToConsoleListener&gt; WriteToConsoleListener::instance() { static auto inst = std::shared_ptr&lt;WriteToConsoleListener&gt;(new WriteToConsoleListener); return inst; } void WriteToConsoleListener::processData(const std::shared_ptr&lt;const Data&gt; data) { if (data) { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; *data &lt;&lt; std::flush; } } } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Y finalmente, el primer zombie, el más simple e ingenuo. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SimpleZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; }; } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include "SimpleZomby.h" #include "Common/Listener.h" namespace SimpleZomby { std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::Zomby() = default; Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SimpleZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ while (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;("SimpleZomby is alive!\n")); std::this_thread::sleep_for(std::chrono::seconds(1)); } }); } } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br>  Un zombie ejecuta una función lambda en un hilo separado, enviando periódicamente una cadena al oyente.  Las funciones de Lambda para el trabajo necesitan un semáforo y un oyente, que son campos de la clase zombie.  La función lambda no los captura como campos separados, sino que usa el objeto como un agregador.  Destruir una instancia de la clase zombie antes de que se complete la función lambda dará como resultado un comportamiento indefinido.  Para evitar esto, la función lambda captura una copia segura de shared_from_this (). <br>  En el destructor de zombies, el semáforo se establece en falso, después de lo cual se llama a detach () para la secuencia.  Establecer el semáforo le dice al hilo que se apague. <br><br>  <b>En el destructor, era necesario llamar no detach (), sino unirse ()!</b> <br>  ... y obtener un destructor que bloquea la ejecución por tiempo indefinido, lo que puede ser inaceptable. <br><br>  <b>¡Entonces esto es una violación de RAII!</b>  <b>¡Se suponía que RAII debía salir del destructor solo después de liberar el recurso!</b> <br>  Si es estrictamente, entonces sí, el destructor zombie no libera el recurso, sino que solo <b>garantiza que se realizará la liberación</b> .  En algún momento producido, tal vez pronto, o tal vez no realmente.  E incluso es posible que main termine el trabajo antes, luego el sistema operativo borrará el hilo a la fuerza.  Pero, de hecho, la línea entre RAII "correcto" e "incorrecto" puede ser muy delgada: por ejemplo, RAII "correcto", que llama std :: filesystem :: remove () en un destructor para un archivo temporal, bien puede devolver el control a ese el momento en que el comando de escritura todavía estará en cualquiera de los cachés volátiles y no se escribirá honestamente en la placa magnética del disco duro. <br><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "Common/Impl/WriteToConsoleListener.h" #include "SimpleZomby/SimpleZomby.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto simpleZomby = SimpleZomby::Zomby::create(); simpleZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zomby should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text"><blockquote>  SimpleZomby está vivo! <br>  SimpleZomby está vivo! <br>  SimpleZomby está vivo! <br>  SimpleZomby está vivo! <br>  SimpleZomby está vivo! <br>  =================================================== =========== <br>  El |  Zomby fue asesinado | <br>  =================================================== =========== <br>  SimpleZomby está vivo! <br>  SimpleZomby está vivo! <br>  SimpleZomby está vivo! <br>  SimpleZomby está vivo! <br>  SimpleZomby está vivo! <br></blockquote><br></div></div><br>  Lo que se puede ver en la salida del programa: <br>  - el zombie continuó trabajando incluso después de abandonar el campo de visibilidad; <br>  - no se llamaron destructores para zombies o WriteToConsoleListener. <br>  Se ha producido una pérdida de memoria. <br>  Hubo una fuga de recursos.  Y el recurso en este caso es el hilo de ejecución. <br>  El código que se suponía que debía detenerse continuó funcionando en un hilo separado. <br>  Una fuga WriteToConsoleListener podría haberse evitado mediante el uso de la técnica SingletonWeak de mi artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Evitar el comportamiento indeterminado al llamar a un Singleton</a> , pero no lo hice intencionalmente. <br><br><img src="https://habrastorage.org/webt/mg/qu/e3/mgque3fstboi4ot2hvdwniafixe.jpeg"><br>  (imagen tomada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de aquí</a> ) <br><br>  <b>¿Por qué zombis?</b> <br>  Porque lo mataron y todavía está vivo. <br><br>  <b>¿Cómo difiere esto de las referencias circulares en ejemplos anteriores?</b> <br>  El hecho de que un recurso perdido no es solo una pieza de memoria, sino algo que ejecuta código independientemente del hilo que lo lanzó. <br><br>  <b>¿Es posible destruir a los "zombis"?</b> <br>  Después de abandonar el alcance (es decir, después de destruir todas las referencias externas fuertes y débiles a zombies), es imposible.  Un zombie será destruido cuando decida destruirse a sí mismo (sí, es algo con un comportamiento activo), tal vez nunca, es decir.  sobrevivirá hasta que el sistema operativo se limpie cuando la aplicación finalice.  Por supuesto, el código de usuario puede tener algún efecto sobre la condición para salir del código zombie, pero este efecto será indirecto y dependerá de la implementación. <br><br>  <b>¿Y antes de salir del alcance?</b> <br>  Puede llamar explícitamente al destructor zombie, pero es poco probable que evite un comportamiento indefinido debido a la destrucción repetida del objeto por el destructor de puntero inteligente también: esta es una lucha contra RAII.  O puede agregar la función de inicialización explícita, y esto es un rechazo de RAII. <br><br>  <b>¿En qué se diferencia esto de comenzar un hilo seguido de detach ()?</b> <br>  En el caso de los zombis, en contraste con una simple llamada a detach (), existe la idea de detener el flujo.  Solo que no funciona.  Tener la idea correcta ayuda a enmascarar el problema. <br><br>  <b>¿El ejemplo sigue siendo sintético?</b> <br>  En parte  En este simple ejemplo, no había suficientes razones para usar shared_from_this (); por ejemplo, podría hacerlo con la captura de weak_from_this () o la captura de todos los campos obligatorios en la clase.  Pero con la complejidad de la tarea, el equilibrio puede desplazarse hacia un lado. <br>  shared_from_this (). <br><br>  <b>Valgrind, Valgrind!</b>  <b>¡Tenemos una línea de defensa adicional contra zombies!</b> <br>  Ay y ah, pero Valgrind no reveló una pérdida de memoria.  ¿Por qué? No lo sé.  En el diagnóstico, solo hay entradas <b>"posiblemente perdidas"</b> que indican las funciones del sistema, aproximadamente la misma cantidad y aproximadamente la misma cantidad que cuando se trabaja con una tubería principal vacía.  No hay referencias de código de usuario.  Otras herramientas de análisis dinámico podrían funcionar mejor, pero si aún confía en ellas, siga leyendo. <br><br><h3>  Steppingzomby </h3><br>  El código en este ejemplo continúa con los pasos resolveDnsName ---&gt; connectTcp ---&gt; establecerSsl ---&gt; sendHttpRequest ---&gt; readHttpReply, simulando la operación de la conexión HTTPS del cliente en ejecución asincrónica.  Cada paso dura aproximadamente un segundo. <br><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SteppingZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; void resolveDnsName(); void connectTcp(); void establishSsl(); void sendHttpRequest(); void readHttpReply(); }; } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include &lt;string&gt; #include "SteppingZomby.h" #include "Common/Listener.h" namespace { void doSomething(Common::Listener&amp; listener, std::string&amp;&amp; callingFunctionName) { listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " started\n")); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " finished\n")); } } // namespace namespace SteppingZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SteppingZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;resolveDnsName(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;connectTcp(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;establishSsl(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;sendHttpRequest(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;readHttpReply(); } }); } void Zomby::resolveDnsName() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::connectTcp() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::establishSsl() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::sendHttpRequest() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::readHttpReply() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "SteppingZomby/SteppingZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto steppingZomby = SteppingZomby::Zomby::create(); steppingZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(1500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text"><blockquote>  N13SteppingZomby5ZombyE :: resolveDnsName iniciado <br>  N13SteppingZomby5ZombyE :: resolveDnsName terminado <br>  N13SteppingZomby5ZombyE :: connectTcp iniciado <br>  =================================================== =========== <br>  El |  Zomby fue asesinado | <br>  =================================================== =========== <br>  N13SteppingZomby5ZombyE :: connectTcp terminado <br>  N13SteppingZomby5ZombyE :: beginSsl inició <br>  N13SteppingZomby5ZombyE :: establecerSsl terminado <br>  N13SteppingZomby5ZombyE :: sendHttpRequest inició <br>  N13SteppingZomby5ZombyE :: sendHttpRequest finalizado <br>  N13SteppingZomby5ZombyE :: readHttpReply iniciado <br>  N13SteppingZomby5ZombyE :: readHttpReply terminado <br>  N13SteppingZomby5ZombyE :: ~ Zomby <br>  N6Common22WriteToConsoleListenerE :: ~ WriteToConsoleListener <br></blockquote><br></div></div><br>  Como en el ejemplo anterior, una llamada a runOnce () condujo a una referencia circular. <br>  Pero esta vez, se llamaron a los destructores Zomby y WriteToConsoleListener.  Todos los recursos se liberaron correctamente hasta que la aplicación finalizó.  No se produjo una pérdida de memoria. <br><br>  <b>¿Cuál es el problema entonces?</b> <br>  El problema es que el zombi vivió demasiado tiempo, aproximadamente tres segundos y medio después de la destrucción de todos los enlaces externos fuertes y débiles.  Unos tres segundos más de lo que debería haber vivido.  Y todo este tiempo estuvo involucrado en promover la implementación de la conexión HTTPS, hasta que la finalizó.  A pesar de que el resultado ya no era necesario.  A pesar de que la lógica empresarial superior intentó detener a los zombis. <br><br>  <b>Bueno, piénsalo, tienes la respuesta que no necesitas ...</b> <br>  En el caso de una conexión HTTPS de cliente, las consecuencias <b>de nuestro lado</b> pueden ser las siguientes: <br>  - consumo de memoria; <br>  - consumo de CPU; <br>  - consumo de puerto TCP; <br>  - el ancho de banda del canal de comunicación (tanto la solicitud como la respuesta pueden ser un volumen en megabytes); <br>  - los datos inesperados pueden interrumpir el funcionamiento de la lógica empresarial de nivel superior, hasta la transición a la rama de ejecución incorrecta o al comportamiento indefinido, porque  los mecanismos de procesamiento de respuesta ya pueden estar destruidos. <br>  Y <b>en el lado remoto</b> (no lo olvide, la solicitud HTTPS estaba destinada a alguien), exactamente el mismo desperdicio de recursos, además es posible: <br>  - publicar fotos de gatos en un sitio web corporativo; <br>  - deshabilitar la calefacción por suelo radiante en su cocina; <br>  - ejecución de una orden comercial en el intercambio; <br>  - transferencia de dinero desde su cuenta; <br>  - lanzamiento de un misil balístico intercontinental. <br>  La lógica de negocios trató de detener a los zombies eliminando todos los enlaces fuertes y débiles.  Se <b>suponía que debía</b> detenerse el progreso de la solicitud HTTPS: todavía no era demasiado tarde, los datos del nivel de la aplicación aún no se habían enviado. <br>  Pero los zombis decidieron a su manera. <br><br>  La lógica empresarial puede crear nuevos objetos en lugar de zombies y nuevamente intentar destruirlos, multiplicando la fuga de recursos. <br>  En el caso de un proceso continuo (por ejemplo, una conexión Websocket), el desperdicio de recursos puede continuar durante horas, y si hay un mecanismo de reconexión automática en la implementación cuando se desconecta la conexión, generalmente se puede detener. <br><br>  <b>Valgrind?</b> <br>  No hay posibilidad  Todo se ha liberado y limpiado correctamente.  Tarde y no desde el hilo principal, pero completamente correcto. <br><br><h3>  Boozdedzomby </h3><br>  Este ejemplo utiliza la biblioteca boozd :: azzio, que es una imitación de boost :: asio.  A pesar de que la simulación es bastante cruda, nos permite demostrar la esencia del problema.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La biblioteca tiene una función io_context :: async_read (en el original, es gratuita, pero no cambia la esencia), que acepta: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- flujo, de donde pueden venir los datos; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- un búfer que le permite acumular estos datos; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- una función de devolución de llamada que se llamará al finalizar la lectura de datos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La función io_context :: async_read se ejecuta instantáneamente y nunca llama a la devolución de llamada, incluso si el resultado de la ejecución ya se conoce (por ejemplo, un error). </font><font style="vertical-align: inherit;">Solo se llama a una devolución de llamada desde la función de bloqueo io_context :: run () (en el original, hay otras funciones diseñadas para llamar a devoluciones de llamada tan pronto como los datos estén listos).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buffer.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; namespace boozd::azzio { using buffer = std::vector&lt;int&gt;; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;optional&gt; namespace boozd::azzio { class stream { public: virtual ~stream() = default; virtual std::optional&lt;int&gt; read() = 0; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io_context.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; #include &lt;optional&gt; #include "buffer.h" namespace boozd::azzio { class stream; class io_context { public: ~io_context(); enum class error_code {no_error, good_error, bad_error, unknown_error, known_error, well_known_error}; using handler = std::function&lt;void(error_code)&gt;; // Start an asynchronous operation to read a certain amount of data from a stream. // This function is used to asynchronously read a certain number of bytes of data from a stream. // The function call always returns immediately. void async_read(stream&amp; s, buffer&amp; b, handler&amp;&amp; handler); // Run the io_context object's event processing loop. void run(); private: using pack = std::tuple&lt;stream&amp;, buffer&amp;&gt;; using pack_optional = std::optional&lt;pack&gt;; using handler_optional = std::optional&lt;handler&gt;; pack_optional _pack_optional; handler_optional _handler_optional; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io_context.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;thread&gt; #include &lt;chrono&gt; #include "io_context.h" #include "stream.h" namespace boozd::azzio { io_context::~io_context() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void io_context::async_read(stream&amp; s, buffer&amp; b, io_context::handler&amp;&amp; handler) { _pack_optional.emplace(s, b); _handler_optional.emplace(std::move(handler)); } void io_context::run() { if (_pack_optional &amp;&amp; _handler_optional) { auto&amp; [s, b] = *_pack_optional; using namespace std::chrono; auto start = steady_clock::now(); while (duration_cast&lt;milliseconds&gt;(steady_clock::now() - start).count() &lt; 1000) { if (auto read = s.read()) b.emplace_back(*read); std::this_thread::sleep_for(milliseconds(100)); } (*_handler_optional)(error_code::no_error); } } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La única implementación de interfaz boozd :: azzio :: stream que produce datos aleatorios: </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impl / random_stream.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"boozd/azzio/stream.h"</span></span></span><span class="hljs-meta"> namespace boozd::azzio { class random_stream final : public stream { public: ~random_stream() override; std::optional</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int&gt; read() override; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impl / random_stream.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "random_stream.h" namespace boozd::azzio { boozd::azzio::random_stream::~random_stream() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::optional&lt;int&gt; random_stream::read() { if (!(rand() &amp; 0x1)) return rand(); return std::nullopt; } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BoozdedZomby ejecuta una función lambda en un hilo separado. </font><font style="vertical-align: inherit;">La función lambda registra el controlador llamando a async_read (), después de lo cual le da control a los mecanismos internos de boozd :: azzio usando run (). </font><font style="vertical-align: inherit;">Después de eso, los mecanismos internos de boozd :: azzio pueden realizar llamadas al búfer y al flujo (fuente de datos) en cualquier momento antes de llamar a la función de devolución de llamada. </font><font style="vertical-align: inherit;">Para garantizar la validez de muchos objetos agregados en una instancia de la clase, la función lambda captura shared_from_this.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BoozdedZomby.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" #include "boozd/azzio/buffer.h" #include "boozd/azzio/io_context.h" #include "boozd/azzio/impl/random_stream.h" namespace Common { class Listener; } // namespace Common namespace BoozdedZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; Semaphore _semaphore = false; std::shared_ptr&lt;Common::Listener&gt; _listener; boozd::azzio::random_stream _stream; boozd::azzio::buffer _buffer; boozd::azzio::io_context _context; std::thread _thread; }; } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boozdedzomby.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;sstream&gt; #include "boozd/azzio/impl/random_stream.h" #include "BoozdedZomby.h" #include "Common/Listener.h" namespace BoozdedZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("BoozdedZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()]() { while (shis &amp;&amp; shis-&gt;_semaphore &amp;&amp; shis-&gt;_listener) { auto handler = [shis](auto errorCode) { if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; errorCode == boozd::azzio::io_context::error_code::no_error) { std::ostringstream buf; buf &lt;&lt; "BoozdedZomby has got a fresh data: "; for (auto const &amp;elem : shis-&gt;_buffer) buf &lt;&lt; elem &lt;&lt; ' '; buf &lt;&lt; std::endl; shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } }; shis-&gt;_buffer.clear(); shis-&gt;_context.async_read(shis-&gt;_stream, shis-&gt;_buffer, handler); shis-&gt;_context.run(); } }); } } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "BoozdedZomby/BoozdedZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto boozdedZomby = BoozdedZomby::Zomby::create(); boozdedZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salida de la consola</font></font></b> <div class="spoiler_text"><blockquote> BoozdedZomby has got a fresh data: 1144108930 101027544 1458777923 1115438165 74243042 <br> BoozdedZomby has got a fresh data: 143542612 1131570933 <br> BoozdedZomby has got a fresh data: 893351816 563613512 704877633 <br> BoozdedZomby has got a fresh data: 1551901393 1399125485 1899894091 937186357 590357944 357571490 <br> ============================================================ <br>  El | Zomby was killed | <br> ============================================================ <br> BoozdedZomby has got a fresh data: 1927702196 130060903 1083454666 2118797801 2035308228 824938981 <br> BoozdedZomby has got a fresh data: 2020739063 1635339425 34075629 <br> BoozdedZomby has got a fresh data: 2146319451 500782188 1269406752 884936716 892053144 <br> BoozdedZomby has got a fresh data: 330111137 1723153177 1070477904 <br> BoozdedZomby has got a fresh data: 343098142 280090412 589673557 889688008 2014119113 388471006 <br></blockquote><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una llamada a run_once () provocó una referencia circular. Zombie continuó trabajando incluso después de abandonar el campo de visibilidad. No se llamaron a los destructores para muchos objetos creados durante el programa: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- boozdedZomby; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- writeToConsoleListener; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- campos de datos zombie. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se ha producido una pérdida de memoria. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hubo una fuga de recursos. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo es este ejemplo diferente de los anteriores?</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Está mucho más cerca del código real. Esto ya no es un ejemplo sintético. Tal código puede ocurrir naturalmente cuando se usa boost :: asio. Además, no se puede solucionar simplemente negándose a capturar un enlace fuerte a favor de uno débil; esto interferirá con la validez del búfer y la transmisión (fuente de datos). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valgrind?</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasado </font><font style="vertical-align: inherit;">Aunque parece haber sido detectar fugas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zombis en la naturaleza </font></font></h2><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡El problema es descabellado! ¡Entonces nadie escribe!</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como él escribe. </font></font><br> <a href="https://www.boost.org/doc/libs/master/libs/beast/example/http/client/async/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de cliente HTTP Ejemplo de cliente </font></font></a> <br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Websocket</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La documentación oficial de impulso enseña cómo escribir un BoozdedZomby + SteppingZomby híbrido. Es imposible detenerlo, pero nadie lo está intentando. Específicamente, en el código de demostración, la propiedad principal del zombie no aparece, pero debes transferir esto a producción, y ahora ya estás caminando por el borde, probablemente incluso en el lado oscuro. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Puedes detener a los zombies destruyendo la instancia de boost :: asio :: io_context!</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... en el camino, destruyendo otras n entidades (posiblemente no zombis) que viven en este contexto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Más ejemplos: </font></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay un ejemplo similar en un recurso de terceros. </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí una persona hace una pregunta sobre stackoverflow, ¿cómo haría que su código sea más zombie?</font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay otro preguntando por qué su amado zombie no está trabajando. </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay un hombre asustado de mensajes sobre pérdidas de memoria cuando opera un zombie.</font></font></a> <br><br><h2>  Conclusión </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, el artículo no describe todas las variedades de los "zombis" antipatrón. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se puede encontrar tanto en forma de híbridos de los tipos anteriores como en forma de nuevos tipos independientes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El antipatrón puede ocurrir no solo cuando se inicia std :: thread en su código; esta parte del trabajo puede ser asumida por una biblioteca multiproceso de terceros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un enlace cíclico puede ser más largo que en los ejemplos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La arquitectura puede ser controlada por eventos o basada en encuestas periódicas basadas en encuestas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo esto no es muy importante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es importante que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antipattern comienza con la instancia de la clase obteniendo una fuerte referencia a sí misma. Casi siempre se genera usando std :: enable_shared_from_this, aunque también se puede proporcionar externamente (incluso como un enlace débil, la clase en sí misma puede hacerlo fuerte). Tal vez solo haya una excepción exótica a esta regla: cuando el código externo proporciona una referencia fuerte o débil a una instancia de una clase en uno de sus campos de datos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El análisis de código dinámico puede no ser capaz de detectar este antipatrón, especialmente su versión de SteppingZomby. También hay pocas esperanzas para el análisis estático: una línea muy delgada entre el uso correcto e incorrecto de shared_from_this (todos los ejemplos de código dados en el artículo se pueden corregir introduciendo cambios muy pequeños, solo de 1 a 6 líneas de código).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las pruebas automáticas pueden ayudar a identificarlo y verificar la corrección de la eliminación, pero para esto necesita saber qué buscar. </font><font style="vertical-align: inherit;">Absolutamente saber </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buscar antipatrón, aquí y allá, tendrá que hacerlo manualmente. </font><font style="vertical-align: inherit;">Y para esto necesita repensar todas las aplicaciones de std :: enable_shared_from_this, son </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peligrosas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PD: de acuerdo con los resultados de la votación, prepararé un artículo separado con una discusión sobre las opciones para eliminar el antipatrón.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471326/">https://habr.com/ru/post/471326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471310/index.html">Mi opinión muy subjetiva sobre la educación profesional y no solo en TI</a></li>
<li><a href="../471312/index.html">Preparación para la certificación profesional de primavera. Bota de primavera</a></li>
<li><a href="../471318/index.html">Resumen de noticias de septiembre sobre aprendizaje automático e inteligencia artificial</a></li>
<li><a href="../471320/index.html">Herramientas para desarrolladores de software: Open Framework y bibliotecas de aprendizaje automático</a></li>
<li><a href="../471324/index.html">¿Las redes neuronales sueñan con la Mona Lisa?</a></li>
<li><a href="../471330/index.html">Historias de la computadora lunar. Parte 2</a></li>
<li><a href="../471332/index.html">Historias de la computadora lunar. Parte 3</a></li>
<li><a href="../471334/index.html">Para memorizar, pero no para apiñar: aprender "por cartas"</a></li>
<li><a href="../471336/index.html">Holivar Historia de Runet. Parte 6. Cerraduras: acecho, cinta, camino 282 y chino</a></li>
<li><a href="../471340/index.html">Drimsim vs Mate 20 Pro Round! ¿Pero para quien?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>