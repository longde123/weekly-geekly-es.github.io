<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ù§Ô∏è üïå üíí Stehlen: Wer stiehlt virtuellen Maschinen Prozessorzeit üëµüèø üÜñ ‚õëÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Ich m√∂chte im Klartext √ºber die Mechanismen der Entstehung von Diebstahl in virtuellen Maschinen und √ºber einige nicht offensichtliche Artefakt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Stehlen: Wer stiehlt virtuellen Maschinen Prozessorzeit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/449316/"><img src="https://habrastorage.org/getpro/habr/post_images/af7/c70/8aa/af7c708aa619490409ed5cf46d9c96fa.jpg"><br><br>  Hallo!  Ich m√∂chte im Klartext √ºber die Mechanismen der Entstehung von Diebstahl in virtuellen Maschinen und √ºber einige nicht offensichtliche Artefakte berichten, die wir w√§hrend seiner Recherchen herausfinden konnten, in die ich als technischer Berater der Cloud-Plattform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mail.ru Cloud Solutions</a> eintauchen musste.  Die Plattform l√§uft auf KVM. <br><br>  Die CPU-Diebstahlzeit ist die Zeit, in der die virtuelle Maschine keine Prozessorressourcen f√ºr ihre Ausf√ºhrung empf√§ngt.  Diese Zeit wird nur in Gastbetriebssystemen in Virtualisierungsumgebungen ber√ºcksichtigt.  Die Gr√ºnde, aus denen diese sehr zugewiesenen Ressourcen wie im Leben verwendet werden, sind sehr vage.  Aber wir haben uns entschlossen, es herauszufinden und sogar eine ganze Reihe von Experimenten durchzuf√ºhren.  Nicht, dass wir jetzt alles √ºber Stehlen wissen, aber wir werden Ihnen jetzt etwas Interessantes erz√§hlen. <br><a name="habracut"></a><br><h2>  1. Was ist stehlen </h2><br>  Steal ist also eine Metrik, die auf einen Mangel an Prozessorzeit f√ºr Prozesse in einer virtuellen Maschine hinweist.  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im KVM-Kernel-Patch beschrieben</a> , ist Steal die Zeit, zu der der Hypervisor andere Prozesse auf dem Host-Betriebssystem ausf√ºhrt, obwohl er den Prozess der virtuellen Maschine zur Ausf√ºhrung in die Warteschlange gestellt hat.  Das hei√üt, Steal wird als Differenz zwischen der Zeit, zu der der Prozess zur Ausf√ºhrung bereit ist, und der Zeit, zu der der Prozessor dem Prozess zugewiesen ist, betrachtet. <br><br>  Der Kernel-Kernel empf√§ngt den metrischen Diebstahl vom Hypervisor.  Gleichzeitig gibt der Hypervisor nicht genau an, welche anderen Prozesse er ausf√ºhrt. Er sagt lediglich: "W√§hrend ich besch√§ftigt bin, kann ich Ihnen keine Zeit geben."  In KVM wurde die Unterst√ºtzung f√ºr das Stehlenz√§hlen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patches</a> hinzugef√ºgt.  Hier gibt es zwei wichtige Punkte: <br><br><ul><li>  Die virtuelle Maschine lernt vom Hypervisor, wie man stiehlt.  Das hei√üt, unter dem Gesichtspunkt der Verluste ist dies f√ºr Prozesse auf der virtuellen Maschine selbst eine indirekte Messung, die verschiedenen Verzerrungen unterliegen kann. <br></li><li> Der Hypervisor teilt der virtuellen Maschine keine Informationen dar√ºber mit, was er mit anderen tut. Hauptsache, er widmet ihr keine Zeit.  Aus diesem Grund kann die virtuelle Maschine selbst keine Verzerrungen im Steal-Index erkennen, die durch die Art der konkurrierenden Prozesse gesch√§tzt werden k√∂nnten. <br></li></ul><br><h2>  2. Was beeinflusst stehlen </h2><br><h3>  2.1.  Berechnung stehlen </h3><br>  Tats√§chlich wird Steal als ungef√§hr gleichbedeutend mit der normalen CPU-Auslastungszeit angesehen.  Es gibt nicht viele Informationen dar√ºber, wie die Entsorgung ber√ºcksichtigt wird.  Wahrscheinlich, weil die Mehrheit diese Frage f√ºr offensichtlich h√§lt.  Aber hier gibt es auch Fallstricke.  Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sich</a> mit diesem Prozess vertraut zu machen, lesen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel von Brendann Gregg</a> : Sie lernen eine Reihe von Nuancen bei der Berechnung der Auslastung kennen und Situationen, in denen diese Berechnung aus folgenden Gr√ºnden fehlerhaft ist: <br><br><ul><li>  √úberhitzung des Prozessors, w√§hrend der Taktzyklen √ºbersprungen werden. <br></li><li>  Schalten Sie den Turbo-Boost ein / aus, wodurch sich die Prozessortaktfrequenz √§ndert. <br></li><li>  Eine √Ñnderung der Dauer eines Zeitquantums, die bei Verwendung energiesparender Prozessortechnologien wie SpeedStep auftritt. <br></li><li>  Das Problem der Berechnung des Durchschnitts: Eine Sch√§tzung der Auslastung innerhalb einer Minute bei 80% kann einen kurzfristigen Ausbruch in 100% verbergen. <br></li><li>  Die zyklische Sperre (Spin Lock) f√ºhrt dazu, dass der Prozessor entsorgt wird, der Benutzerprozess jedoch keinen Fortschritt bei seiner Ausf√ºhrung sieht.  Infolgedessen betr√§gt die gesch√§tzte Prozessorauslastung durch den Prozess hundertprozentig, obwohl der Prozess keine physische Prozessorzeit verbraucht. <br></li></ul><br>  Ich habe keinen Artikel gefunden, der eine √§hnliche Berechnung f√ºr Diebstahl beschreibt (wenn Sie wissen, teilen Sie dies in den Kommentaren mit).  Nach der Quelle zu urteilen, ist der Berechnungsmechanismus jedoch der gleiche wie f√ºr die Entsorgung.  Es ist nur so, dass dem Kernel direkt f√ºr den KVM-Prozess (Virtual Machine Process) ein weiterer Z√§hler hinzugef√ºgt wird, der die Zeitdauer z√§hlt, in der sich der KVM-Prozess im Standby-Zustand der Prozessorzeit befindet.  Der Z√§hler entnimmt Informationen √ºber den Prozessor seiner Spezifikation und pr√ºft, ob alle seine Ticks vom virtuellen Prozess verwendet wurden.  Wenn das alles ist, dann glauben wir, dass der Prozessor nur am Prozess der virtuellen Maschine beteiligt war.  Ansonsten informieren wir, dass der Prozessor etwas anderes getan hat, Steal erschien. <br><br>  Der Diebstahlz√§hlprozess unterliegt denselben Problemen wie die regul√§re Recyclingz√§hlung.  Um nicht zu sagen, dass solche Probleme h√§ufig auftreten, aber sie sehen entmutigend aus. <br><br><h3>  2.2.  Arten der Virtualisierung auf KVM </h3><br>  Im Allgemeinen gibt es drei Arten der Virtualisierung, die alle von KVM unterst√ºtzt werden.  Die Art der Virtualisierung kann den Mechanismus bestimmen, durch den der Diebstahl erfolgt. <br><br>  <b>Sendung</b>  In diesem Fall erfolgt der Betrieb des Betriebssystems der virtuellen Maschine mit den physischen Ger√§ten des Hypervisors ungef√§hr so: <br><br><ol><li>  Das Gastbetriebssystem sendet einen Befehl an sein Gastger√§t. <br></li><li>  Der Gastger√§tetreiber akzeptiert den Befehl, generiert eine Anforderung f√ºr das Ger√§te-BIOS und sendet sie an den Hypervisor. <br></li><li>  Der Hypervisor-Prozess √ºbersetzt einen Befehl in einen Befehl f√ºr ein physisches Ger√§t, wodurch es unter anderem sicherer wird. <br></li><li>  Der physische Ger√§tetreiber akzeptiert den ge√§nderten Befehl und sendet ihn an das physische Ger√§t selbst. <br></li><li>  Die Ergebnisse der Befehlsausf√ºhrung gehen auf die gleiche Weise zur√ºck. <br></li></ol><br>  Der Vorteil der √úbersetzung besteht darin, dass Sie jedes Ger√§t emulieren k√∂nnen und keine spezielle Vorbereitung des Kernels des Betriebssystems erforderlich ist.  Aber daf√ºr muss man vor allem schnell bezahlen. <br><br>  <b>Hardware-Virtualisierung</b> .  In diesem Fall versteht das Ger√§t auf Hardwareebene die Befehle des Betriebssystems.  Dies ist der schnellste und beste Weg.  Leider wird es nicht von allen physischen Ger√§ten, Hypervisoren und Gastbetriebssystemen unterst√ºtzt.  Derzeit sind die Hauptger√§te, die die Hardwarevirtualisierung unterst√ºtzen, Prozessoren. <br><br>  <b>Paravirtualisierung (Paravirtualisierung)</b> .  Die h√§ufigste Version der Ger√§tevirtualisierung unter KVM und im Allgemeinen der h√§ufigste Virtualisierungsmodus f√ºr Gastbetriebssysteme.  Die Besonderheit besteht darin, dass die Arbeit mit einigen Subsystemen des Hypervisors (z. B. mit einem Netzwerk- oder Plattenstapel) oder die Zuweisung von Speicherseiten mithilfe der Hypervisor-API erfolgt, ohne dass Befehle auf niedriger Ebene √ºbersetzt werden m√ºssen.  Der Nachteil dieser Virtualisierungsmethode besteht darin, dass der Kernel des Gastbetriebssystems so ge√§ndert werden muss, dass er mithilfe dieser API mit dem Hypervisor interagieren kann.  In der Regel wird dies jedoch durch die Installation spezieller Treiber auf dem Gastbetriebssystem gel√∂st.  In KVM wird diese API als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">virtio-API bezeichnet</a> . <br><br>  Bei der Paravirtualisierung wird im Vergleich zur √úbersetzung der Pfad zum physischen Ger√§t erheblich reduziert, indem Befehle direkt von der virtuellen Maschine an den Host-Hypervisor-Prozess gesendet werden.  Auf diese Weise k√∂nnen Sie die Ausf√ºhrung aller Anweisungen in der virtuellen Maschine beschleunigen.  In KVM ist die virtio-API daf√ºr verantwortlich, die nur f√ºr bestimmte Ger√§te wie ein Netzwerk oder einen Festplattenadapter funktioniert.  Aus diesem Grund werden Virtio-Treiber in virtuellen Maschinen platziert. <br><br>  Die Kehrseite dieser Beschleunigung ist, dass nicht alle Prozesse, die in einer virtuellen Maschine ausgef√ºhrt werden, in dieser verbleiben.  Dadurch entstehen einige Spezialeffekte, die zum Stehlen f√ºhren k√∂nnen.  Ich empfehle, eine detaillierte Studie zu diesem Problem mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer API f√ºr virtuelle E / A: virtio zu starten</a> . <br><br><h3>  2.3.  Fair Sheduling </h3><br>  Die Virtualisierung auf einem Hypervisor ist in der Tat ein gew√∂hnlicher Prozess, der den Gesetzen des Sheduling (Zuweisung von Ressourcen zwischen Prozessen) im Linux-Kernel folgt. Wir werden ihn daher genauer betrachten. <br><br>  Linux verwendet den sogenannten CFS (Completely Fair Scheduler), der seit Kernel 2.6.23 zum Standard-Dispatcher geworden ist.  Um diesen Algorithmus zu verstehen, k√∂nnen Sie die Linux-Kernel-Architektur oder -Quellen lesen.  Das Wesentliche von CFS ist die Verteilung der Prozessorzeit zwischen Prozessen in Abh√§ngigkeit von der Dauer ihrer Ausf√ºhrung.  Je mehr Prozessorzeit der Prozess ben√∂tigt, desto weniger Zeit erh√§lt er.  Dies garantiert die ‚Äûehrliche‚Äú Ausf√ºhrung aller Prozesse - so dass ein Prozess nicht st√§ndig alle Prozessoren belegt und auch andere Prozesse ausgef√ºhrt werden k√∂nnen. <br><br>  Manchmal f√ºhrt dieses Paradigma zu interessanten Artefakten.  Langj√§hrige Linux-Benutzer werden sich wahrscheinlich an das Verblassen eines normalen Desktop-Texteditors erinnern, w√§hrend sie anspruchsvolle compiler√§hnliche Anwendungen ausf√ºhren.  Dies geschah, weil nicht ressourcenintensive Aufgaben von Desktopanwendungen mit Aufgaben konkurrierten, die aktiv Ressourcen verbrauchen, wie z. B. einem Compiler.  CFS h√§lt dies f√ºr unehrlich, sodass der Texteditor regelm√§√üig angehalten wird und der Prozessor die Compiler-Aufgaben verarbeiten kann.  Dies wurde mithilfe des Mechanismus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sched_autogroup</a> korrigiert, aber viele andere Funktionen der Verteilung der CPU-Zeit zwischen den Aufgaben blieben erhalten.  In dieser Geschichte geht es nicht darum, wie schlimm die Dinge in CFS sind, sondern darum, die Aufmerksamkeit auf die Tatsache zu lenken, dass eine ‚Äûehrliche‚Äú Verteilung der Prozessorzeit nicht die trivialste Aufgabe ist. <br><br>  Ein weiterer wichtiger Punkt im Schuppen ist die Vorauszahlung.  Dies ist erforderlich, um den Snickering-Prozess vom Prozessor aus zu steuern und andere arbeiten zu lassen.  Der Exilprozess wird als Kontextumschaltung, Prozessorkontextumschaltung bezeichnet.  In diesem Fall wird der gesamte Kontext der Aufgabe gespeichert: der Status des Stapels, der Register usw., wonach der Prozess wartet und ein anderer seinen Platz einnimmt.  Dies ist eine teure Operation f√ºr das Betriebssystem und wird selten verwendet, aber tats√§chlich ist daran nichts auszusetzen.  H√§ufiges Wechseln des Kontexts kann auf ein Problem im Betriebssystem hinweisen, wird jedoch normalerweise kontinuierlich fortgesetzt und zeigt nichts Besonderes an. <br><br>  Eine so lange Geschichte ist erforderlich, um eine Tatsache zu erkl√§ren: Je mehr Prozessorressourcen ein ehrlicher Linux-Sheduler zu verbrauchen versucht, desto schneller wird sie gestoppt, damit auch andere Prozesse funktionieren k√∂nnen.  Ob dies richtig ist oder nicht, ist ein komplexes Problem, das unter verschiedenen Belastungen unterschiedlich gel√∂st wird.  In Windows konzentrierte sich der Sheduler bis vor kurzem auf die Priorit√§tsverarbeitung von Desktopanwendungen, aufgrund derer Hintergrundprozesse h√§ngen bleiben konnten.  Sun Solaris hatte f√ºnf verschiedene Klassen von Schuppen.  Als sie mit der Virtualisierung begannen, f√ºgten sie den sechsten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fair Share Scheduler hinzu</a> , da die vorherigen f√ºnf nicht ausreichend mit der Virtualisierung von Solaris Zones arbeiteten.  Ich empfehle, eine detaillierte Studie zu diesem Problem mit B√ºchern wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Solaris Internals: Solaris 10 und OpenSolaris Kernel Architecture</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Understanding the Linux Kernel zu beginnen</a> . <br><br><h3>  2.4.  Wie kann man den Diebstahl √ºberwachen? </h3><br>  Die √úberwachung des Diebstahls in einer virtuellen Maschine ist wie bei jeder anderen Prozessormetrik einfach: Sie k√∂nnen alle Methoden zum Entfernen von Prozessormetriken verwenden.  Die Hauptsache ist, dass die virtuelle Maschine unter Linux l√§uft.  Aus irgendeinem Grund stellt Windows seinen Benutzern solche Informationen nicht zur Verf√ºgung.  :( <br><br><img src="https://habrastorage.org/getpro/habr/post_images/804/731/75c/80473175cd23f0ba8721ca61c65fe111.png"><br>  <i>Die Ausgabe des Befehls top: Details zum Prozessorladen in der Spalte ganz rechts - stehlen</i> <br><br>  Die Schwierigkeit tritt auf, wenn versucht wird, diese Informationen vom Hypervisor abzurufen.  Sie k√∂nnen versuchen, den Diebstahl auf dem Hostcomputer vorherzusagen, indem Sie beispielsweise den Parameter Load Average (LA) verwenden - den Durchschnittswert der Anzahl der Prozesse, die in der Warteschlange auf die Ausf√ºhrung warten.  Die Methode zur Berechnung dieses Parameters ist nicht einfach. Wenn jedoch LA, normalisiert durch die Anzahl der Prozessorthreads, gr√∂√üer als 1 ist, bedeutet dies, dass der Linux-Server etwas √ºberlastet ist. <br><br>  Worauf warten all diese Prozesse?  Die offensichtliche Antwort ist der Prozessor.  Die Antwort ist jedoch nicht ganz richtig, da manchmal der Prozessor frei ist und LA √ºberrollt.  Denken Sie daran, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie NFS abf√§llt und wie LA w√§chst</a> .  Dies kann bei einer Festplatte und bei anderen Eingabe- / Ausgabeger√§ten ungef√§hr gleich sein.  Tats√§chlich k√∂nnen Prozesse jedoch das Ende jeder Sperre erwarten, sowohl physisch, mit einem E / A-Ger√§t verkn√ºpft, als auch logisch, z. B. mit einem Mutex.  Dies umfasst auch Sperren auf Hardwareebene (dieselbe Antwort von der Festplatte) oder Logik (die sogenannten Sperrprimitive, die eine Reihe von Entit√§ten, Mutex Adaptive und Spin, Semaphoren, Bedingungsvariablen, RW-Sperren, IPC-Sperren ...) enthalten. <br><br>  Ein weiteres Merkmal von LA ist, dass es als Durchschnittswert f√ºr das Betriebssystem betrachtet wird.  Beispielsweise konkurrieren 100 Prozesse um eine Datei, und dann ist LA = 50.  Ein so gro√üer Wert scheint darauf hinzudeuten, dass das Betriebssystem schlecht ist.  Bei anderem schief geschriebenem Code kann dies jedoch ein normaler Zustand sein, obwohl er nur f√ºr ihn schlecht ist und andere Prozesse im Betriebssystem nicht darunter leiden. <br><br>  Aufgrund dieser Mittelung (und nicht weniger als einer Minute) ist es nicht die dankbarste Aufgabe, etwas anhand des LA-Indikators zu bestimmen, was in bestimmten F√§llen zu sehr unsicheren Ergebnissen f√ºhrt.  Wenn Sie versuchen, es herauszufinden, werden Sie feststellen, dass nur die einfachsten F√§lle in Wikipedia-Artikeln und anderen verf√ºgbaren Ressourcen beschrieben werden, ohne eine ausf√ºhrliche Erkl√§rung des Prozesses.  Ich sende alle Interessierten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier noch einmal an Brendann Gregg</a> - weiter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unten</a> unter den Links.  Wem Faulheit auf Englisch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung seines beliebten Artikels √ºber LA ist</a> . <br><br><h2>  3. Spezialeffekte </h2><br>  Lassen Sie uns nun auf die wichtigsten F√§lle von Diebstahl eingehen, auf die wir gesto√üen sind.  Ich werde Ihnen sagen, wie sie sich aus dem Vorstehenden ergeben und wie sie sich auf Indikatoren auf dem Hypervisor beziehen. <br><br>  <b>Recycling</b> .  Das einfachste und h√§ufigste: Der Hypervisor wird wiederverwendet.  In der Tat gibt es viele laufende virtuelle Maschinen, einen gro√üen Prozessorverbrauch, viel Konkurrenz, die LA-Auslastung betr√§gt mehr als 1 (normalisiert durch Prozessorthreads).  In allen Virtualoks verlangsamt sich alles.  Der vom Hypervisor √ºbertragene Diebstahl nimmt ebenfalls zu. Es ist notwendig, die Last neu zu verteilen oder jemanden auszuschalten.  Im Allgemeinen ist alles logisch und verst√§ndlich. <br><br>  <b>Paravirtualisierung versus Einzelinstanzen</b> .  Es gibt eine einzige virtuelle Maschine auf dem Hypervisor, die einen kleinen Teil davon verbraucht, aber die Eingabe / Ausgabe, beispielsweise auf einer Festplatte, stark belastet.  Und von irgendwo darin erscheint ein kleiner Diebstahl, bis zu 10% (wie mehrere Experimente gezeigt haben). <br><br>  Der Fall ist interessant.  Steal wird hier nur aufgrund von Sperren auf der Ebene paravirtualisierter Treiber angezeigt.  In der virtuellen Maschine wird ein Interrupt erstellt, der vom Treiber verarbeitet wird und an den Hypervisor gesendet wird.  Aufgrund der Interrupt-Verarbeitung auf dem Hypervisor f√ºr die virtuelle Maschine sieht es wie eine gesendete Anforderung aus, sie ist zur Ausf√ºhrung bereit und wartet auf den Prozessor, gibt dem Prozessor jedoch keine Zeit.  Virtualka glaubt, dass diese Zeit gestohlen wird. <br><br>  Dies geschieht, wenn der Puffer gesendet wird, in den Kernelbereich des Hypervisors gelangt und wir beginnen, darauf zu warten.  Obwohl er aus Sicht von virtualka sofort zur√ºckkehren sollte.  Daher wird diese Zeit gem√§√ü dem Diebstahlberechnungsalgorithmus als gestohlen betrachtet.  In dieser Situation gibt es h√∂chstwahrscheinlich andere Mechanismen (z. B. die Verarbeitung einiger anderer Systemaufrufe), die jedoch nicht sehr unterschiedlich sein sollten. <br><br>  <b>Sheduler gegen stark belastete Virtualoks</b> .  Wenn eine virtuelle Maschine mehr als andere gestohlen wird, ist sie genau mit dem Sheduler verbunden.  Je st√§rker der Prozess den Prozessor l√§dt, desto eher wird er vom Sheduler ausgesto√üen, sodass auch die anderen arbeiten k√∂nnen.  Wenn die virtuelle Maschine ein wenig verbraucht, sieht sie fast keinen Diebstahl: Ihr Prozess hat ehrlich gesessen und gewartet, es ist notwendig, ihm mehr Zeit zu geben.  Wenn die virtuelle Maschine die maximale Belastung aller ihrer Kerne erzeugt, wird sie h√§ufig aus dem Prozessor entfernt und versucht, nicht viel Zeit zu geben. <br><br>  Schlimmer noch, wenn die Prozesse in der virtuellen Maschine versuchen, mehr Prozessor zu erhalten, weil sie die Datenverarbeitung nicht bew√§ltigen k√∂nnen.  Dann wird das Betriebssystem auf dem Hypervisor aufgrund einer ehrlichen Optimierung immer weniger Prozessorzeit geben.  Dieser Prozess findet wie eine Lawine statt und der Diebstahl springt in den Himmel, obwohl andere virtuelle Maschinen ihn m√∂glicherweise fast nicht bemerken.  Und je mehr Kerne, desto schlimmer fiel die Maschine unter die Verteilung.  Kurz gesagt, stark ausgelastete virtuelle Maschinen mit vielen Kernen leiden am meisten. <br><br>  <b>Low LA, aber es gibt ein Schn√§ppchen</b> .  Wenn LA ungef√§hr 0,7 betr√§gt (das hei√üt, der Hypervisor scheint unterlastet zu sein), aber innerhalb einzelner virtueller Maschinen ein Diebstahl beobachtet wird: <br><br><ul><li>  Die oben beschriebene Option mit Paravirtualisierung.  Eine virtuelle Maschine kann Metriken empfangen, die auf Diebstahl hinweisen, obwohl mit dem Hypervisor alles in Ordnung ist.  Nach den Ergebnissen unserer Experimente √ºberschreitet eine solche Steal-Option 10% nicht und sollte keinen signifikanten Einfluss auf die Anwendungsleistung innerhalb der virtuellen Maschine haben. <br></li><li>  Der Parameter LA wird falsch ber√ºcksichtigt.  Genauer gesagt wird es in jedem bestimmten Moment als wahr angesehen, aber wenn es f√ºr eine Minute gemittelt wird, stellt sich heraus, dass es untersch√§tzt wird.  Wenn beispielsweise eine virtuelle Maschine genau eine halbe Minute pro Drittel des Hypervisors alle ihre Prozessoren verbraucht, betr√§gt LA pro Minute auf dem Hypervisor 0,15.  Vier solcher virtuellen Maschinen, die gleichzeitig arbeiten, ergeben 0,6.  Und die Tatsache, dass es in LA jeweils eine halbe Minute lang einen wilden Diebstahl von 25% gab, kann nicht mehr herausgezogen werden. <br></li><li>  Wieder wegen des Schuppens, der entschied, dass jemand zu viel a√ü, und diesen warten lie√ü.  In der Zwischenzeit wechsle ich den Kontext, verarbeite Interrupts und mache andere wichtige Systemaufgaben.  Infolgedessen treten bei einigen virtuellen Maschinen keine Probleme auf, w√§hrend bei anderen ernsthafte Leistungseinbu√üen auftreten. <br></li></ul><br><h2>  4. Andere Verzerrungen </h2><br>  Es gibt weitere Millionen Gr√ºnde, die ehrliche R√ºckgabe der Prozessorzeit auf der virtuellen Maschine zu verzerren.  Zum Beispiel erh√∂hen Hypertreading und NUMA die Komplexit√§t der Berechnungen.  Sie verwirren die Wahl des Kernels f√ºr die Ausf√ºhrung des Prozesses v√∂llig, da der Sheduler Koeffizienten - Gewichte verwendet, die beim Wechseln von Kontexten die Berechnung noch schwieriger machen. <br><br>  Es gibt Verzerrungen aufgrund von Technologien wie Turbo-Boost oder umgekehrt dem Energiesparmodus, der bei der Berechnung der Auslastung die Frequenz oder sogar die Zeitscheibe auf dem Server k√ºnstlich erh√∂hen oder verringern kann.  Das Einschalten des Turbo-Boosts verringert die Leistung eines Prozessorthreads aufgrund der erh√∂hten Leistung eines anderen.  In diesem Moment werden keine Informationen √ºber die aktuelle Prozessorfrequenz an die virtuelle Maschine √ºbertragen, und sie glaubt, dass jemand ihre Zeit bindet (zum Beispiel hat sie 2 GHz angefordert, aber halb so viel erhalten). <br><br>  Im Allgemeinen kann es viele Ursachen f√ºr Verzerrungen geben.  In einem bestimmten System finden Sie m√∂glicherweise etwas anderes.  Beginnen Sie besser mit den B√ºchern, auf die ich oben verwiesen habe, und nehmen Sie Statistiken vom Hypervisor mit Dienstprogrammen wie perf, sysdig, systemtap, von denen es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dutzende gibt</a> . <br><br><h2>  5. Schlussfolgerungen </h2><br><ol><li>  Aufgrund der Paravirtualisierung kann ein gewisser Diebstahl auftreten, der als normal angesehen werden kann.  Im Internet schreiben sie, dass dieser Wert 5-10% betragen kann.  Dies h√§ngt von den Anwendungen in der virtuellen Maschine und von der Belastung der physischen Ger√§te ab.  Es ist wichtig zu beachten, wie sich Anwendungen in virtuellen Maschinen anf√ºhlen. <br></li><li>  Das Verh√§ltnis der Belastung des Hypervisors und des Diebstahls innerhalb der virtuellen Maschine ist nicht immer eindeutig miteinander verbunden. Beide Diebstahlsch√§tzungen k√∂nnen in bestimmten Situationen bei unterschiedlichen Belastungen fehlerhaft sein. <br></li><li>  Scheduler mag keine Prozesse, die viel verlangen.  Er versucht, denen, die mehr verlangen, weniger zu geben.  Gro√üe virtuelle Maschinen sind b√∂se. <br></li><li>  Ein kleiner Diebstahl kann die Norm ohne Paravirtualisierung sein (unter Ber√ºcksichtigung der Last in der virtuellen Maschine, der Merkmale der Last der Nachbarn, der Lastverteilung unter den Threads und anderer Faktoren). <br></li><li>  Wenn Sie herausfinden m√∂chten, wie Sie in einem bestimmten System stehlen, m√ºssen Sie verschiedene Optionen untersuchen, Metriken sammeln, sorgf√§ltig analysieren und √ºberlegen, wie Sie die Last gleichm√§√üig verteilen k√∂nnen.  Abweichungen sind in jedem Fall m√∂glich, die experimentell best√§tigt oder im Kernel-Debugger angezeigt werden m√ºssen. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449316/">https://habr.com/ru/post/de449316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449306/index.html">12 englische W√∂rter, die oft falsch geschrieben und gesprochen werden</a></li>
<li><a href="../de449308/index.html">Einf√ºhrung in Microsoft Azure DevTest Labs</a></li>
<li><a href="../de449310/index.html">Citymobil - ein Handbuch zur Verbesserung der Verf√ºgbarkeit bei Unternehmenswachstum f√ºr Startups. Teil 2</a></li>
<li><a href="../de449312/index.html">Hardware-RAID: Nutzungsfunktionen</a></li>
<li><a href="../de449314/index.html">Freiberufliche Einwanderung: Was Sie wissen m√ºssen</a></li>
<li><a href="../de449318/index.html">Wie der Erfolg von Fortnite zu Monaten intensiver Krise bei Epic Games f√ºhrte</a></li>
<li><a href="../de449320/index.html">Wie sich die Informationssicherheit in den letzten 20 Jahren ver√§ndert hat</a></li>
<li><a href="../de449322/index.html">Kabelfernsehnetze f√ºr die Kleinsten. Teil 1: Allgemeine Architektur des KTV-Netzes</a></li>
<li><a href="../de449324/index.html">Lasten, Smartphones, Riesenunternehmen: Heisenbug 2019 Piter-Programm</a></li>
<li><a href="../de449326/index.html">WebRTC und Video√ºberwachung: Wie wir die Verz√∂gerung von Videos von Kameras besiegt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>