<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî¢ üê§ ‚ôêÔ∏è Escrevemos o proxy reverso socks5 no PowerShell. ü¶ä üßöüèæ ü•ñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A hist√≥ria da pesquisa e desenvolvimento em 3 partes. Parte 2 - desenvolvimento. 
 Existem muitas faias - ainda mais benef√≠cios. 

 Na primeira parte ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escrevemos o proxy reverso socks5 no PowerShell.</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453970/">  A hist√≥ria da pesquisa e desenvolvimento em 3 partes.  Parte 2 - desenvolvimento. <br>  Existem muitas faias - ainda mais benef√≠cios. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Na primeira parte do</a> artigo, nos familiarizamos com algumas ferramentas para organizar t√∫neis reversos, analisamos suas vantagens e desvantagens, estudamos o mecanismo de opera√ß√£o do multiplexador Yamux e descrevemos os requisitos b√°sicos para o m√≥dulo PowerShell rec√©m-criado.  √â hora de come√ßar a desenvolver o m√≥dulo do powershell do cliente para a implementa√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pronta do</a> t√∫nel reverso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RSocksTun</a> . <br><br>  Primeiro de tudo, precisamos entender em que modo nosso m√≥dulo funcionar√°.  Obviamente, para a transfer√™ncia prim√°ria de dados, precisaremos usar o mecanismo de soquete do Windows e os recursos .Net para transmitir leitura e grava√ß√£o em soquetes.  Mas, por outro lado, porque  Como nosso m√≥dulo deve atender a v√°rios fluxos do yamux ao mesmo tempo, todas as opera√ß√µes de E / S n√£o devem bloquear completamente a execu√ß√£o do nosso programa.  Isso sugere a conclus√£o de que nosso m√≥dulo deve usar multithreading de software e executar opera√ß√µes de leitura e grava√ß√£o com um servidor yamux, bem como opera√ß√µes de leitura e grava√ß√£o para servidores de destino em diferentes fluxos de programas.  Bem, √© claro, √© necess√°rio fornecer um mecanismo de intera√ß√£o entre nossos fluxos paralelos.  Felizmente, o PowerShell oferece amplas oportunidades para iniciar e gerenciar fluxos de programas. <br><a name="habracut"></a><br><h3>  Algoritmo geral de trabalho </h3><br>  Assim, o algoritmo geral do nosso cliente deve ser algo como isto: <br><br><ul><li>  estabelecer uma conex√£o SSL com o servidor; </li><li>  fa√ßa login com uma senha para que o servidor possa nos diferenciar de um agente de seguran√ßa; </li><li>  aguarde o pacote yamux instalar um novo fluxo, respondendo periodicamente √†s solicita√ß√µes de manuten√ß√£o do servidor; </li><li>  inicie um novo fluxo de programa socksScript (para n√£o confundir com um fluxo) assim que o pacote yamux chegar para instalar um novo fluxo.  Dentro do socksScript, implemente o trabalho do servidor socks5; </li><li>  ap√≥s a chegada do pacote com dados do yamux - entenda no cabe√ßalho de 12 bytes para qual dos fluxos os dados se destinam, bem como seu tamanho, leia os dados do servidor yamux e transfira os dados recebidos para o fluxo com o n√∫mero de fluxo correspondente; </li><li>  monitore periodicamente a disponibilidade dos dados destinados ao servidor yamux em cada um dos scripts de meias em execu√ß√£o.  Se houver esses dados, adicione o cabe√ßalho de 12 bytes correspondente a eles e envie-o para o servidor yamux; </li><li>  ap√≥s a chegada de um pacote yamux para fechar o fluxo, transmita um sinal ao fluxo correspondente para encerrar e desconectar o fluxo e, depois disso, concluir o pr√≥prio fluxo; </li></ul><br>  Portanto, em nosso cliente, √© necess√°rio implementar pelo menos tr√™s fluxos de programas: <br><br><ol><li>  o principal, que estabelecer√° a conex√£o, efetue login no servidor yamux, receba dados dele, processe os cabe√ßalhos do yamux e envie dados brutos para outros fluxos de programas; </li><li>  fluxos com servidores de meias.  Pode haver v√°rios - um para cada fluxo.  Eles implementam a funcionalidade socks5.  Esses fluxos ir√£o interagir com os pontos de destino na rede interna; </li><li>  fluxo reverso.  Ele recebe dados de fluxos de meias, adiciona cabe√ßalhos do yamux a eles e os envia ao servidor do yamux; </li></ol><br>  E, √© claro, precisamos prever a intera√ß√£o entre todos esses fluxos. <br><br>  Precisamos n√£o apenas fornecer essa intera√ß√£o, mas tamb√©m obter a conveni√™ncia de transmitir entrada e sa√≠da (da mesma forma que os soquetes).  O mecanismo mais apropriado seria usar pipes de software.  No Windows, os pipes s√£o registrados quando cada canal tem seu pr√≥prio nome e s√£o an√¥nimos - cada canal √© identificado por seu manipulador.  Por uma quest√£o de segredo, √© claro, usaremos tubos an√¥nimos.  (Afinal, n√£o queremos que nosso m√≥dulo seja calculado usando tubos registrados no sistema - certo?).  Assim, entre os fluxos principal / reverso e os fluxos de meias, a intera√ß√£o ser√° por meio de tubos an√¥nimos, suportando E / S de fluxo ass√≠ncrono.  Entre os fluxos principal e de retorno, a comunica√ß√£o ocorrer√° atrav√©s do mecanismo de objeto compartilhado (vari√°veis ‚Äã‚Äãsincronizadas compartilhadas) (mais sobre o que s√£o essas vari√°veis ‚Äã‚Äãe como conviver com elas, voc√™ pode ler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ). <br><br>  Informa√ß√µes sobre fluxos de meias em execu√ß√£o devem ser armazenadas na estrutura de dados correspondente.  Ao criar um segmento de meias nessa estrutura, devemos escrever: <br><br><ul><li>  n√∫mero da sess√£o do yamux: $ ymxstream; </li><li>  4 vari√°veis ‚Äã‚Äãpara trabalhar com tubos (canais): $ cipipe, $ copipe, $ sipipe, $ sopipe.  Como os canais an√¥nimos funcionam em IN ou OUT, para cada fluxo de meias, precisamos de dois canais an√¥nimos, cada um dos quais deve ter duas extremidades (pipestream) (servidor e cliente); </li><li>  o resultado da chamada para o fluxo √© $ AsyncJobResult; </li><li>  manipulador de fluxo - $ Psobj.  Atrav√©s dele, fecharemos o fluxo e liberaremos recursos; </li><li>  o resultado da leitura ass√≠ncrona do canal an√¥nimo pelo fluxo reverso ($ readjob).  Essa vari√°vel √© usada no fluxo yamuxScript reverso para leitura ass√≠ncrona do canal correspondente; </li><li>  buffer para leitura de dados para cada fluxo de meias; </li></ul><br><h3>  Fluxo principal </h3><br>  Portanto, do ponto de vista do processamento de dados, o trabalho do nosso programa √© constru√≠do da seguinte maneira: <br><br><ul><li>  o lado do servidor (rsockstun - implementado no Golang) eleva o servidor ssl e aguarda as conex√µes do cliente; </li><li>  ao receber uma conex√£o do cliente, o servidor verifica a senha e, se estiver correta, estabelece uma conex√£o yamux, eleva a porta socks e aguarda as conex√µes dos clientes socks (nossos proxychains, navegador etc.), trocando periodicamente pacotes keepalive com o nosso cliente.  Se a senha estiver incorreta - √© realizado um redirecionamento para a p√°gina que especificamos ao instalar o servidor (esta √© uma p√°gina "legal" para o administrador vigilante da seguran√ßa da informa√ß√£o); </li><li>  ao receber uma conex√£o de um cliente de meias, o servidor envia um pacote yamux ao nosso cliente para estabelecer um novo fluxo (YMX SYN); </li></ul><br>  <b>Obtendo e analisando um cabe√ßalho Yamux</b> <br><br>  Nosso m√≥dulo primeiro estabelece uma conex√£o SSL com o servidor e efetua login com uma senha: <br><br><pre><code class="plaintext hljs">$tcpConnection = New-Object System.Net.Sockets.TcpClient($server, $port) $tcpStream = New-Object System.Net.Security.SslStream($tcpConnection.GetStream(),$false,({$True} -as [Net.Security.RemoteCertificateValidationCallback])) $tcpStream.AuthenticateAsClient('127.0.0.1')</code> </pre> <br>  Em seguida, o script aguarda um cabe√ßalho yamux de 12 bytes e o analisa. <br>  H√° uma pequena nuance ... Como mostra a pr√°tica, basta ler 12 bytes do soquete: <br><br><pre> <code class="plaintext hljs"> $num = $tcpStream.Read($tmpbuffer,0,12)</code> </pre> <br>  n√£o √© suficiente, pois a opera√ß√£o de leitura pode ser conclu√≠da ap√≥s a chegada de apenas parte dos bytes necess√°rios.  Portanto, precisamos aguardar todos os 12 bytes no loop: <br><br><pre> <code class="plaintext hljs"> do { try { $num = $tcpStream.Read($tmpbuffer,0,12) } catch {} $tnum += $num $ymxbuffer += $tmpbuffer[0..($num-1)] }while ($tnum -lt 12 -and $tcpConnection.Connected)</code> </pre> <br>  Ap√≥s a conclus√£o do loop, devemos analisar o cabe√ßalho de 12 bytes contido na vari√°vel $ ymxbuffer para seu tipo e definir sinalizadores de acordo com a especifica√ß√£o do Yamux. <br><br>  O cabe√ßalho do Yamux pode ser de v√°rios tipos: <br><br><ul><li>  ymx syn - instale um novo fluxo; </li><li>  ymx fin - conclus√£o do fluxo; </li><li>  ymx data - representa informa√ß√µes sobre os dados (qual tamanho e para qual fluxo eles se destinam); </li><li>  ymx ping - mensagem keepalive; </li><li>  ymx win update - confirma√ß√£o da transfer√™ncia de uma parte dos dados; </li></ul><br>  Qualquer coisa que n√£o se encaixe nos tipos listados de cabe√ßalhos yamux √© considerada uma situa√ß√£o excepcional.  10 exce√ß√µes, e acreditamos que algo est√° errado aqui e estamos concluindo o trabalho do nosso m√≥dulo.  <s>(al√©m de apagar todos os nossos arquivos, limpe o disco, mude o sobrenome, fa√ßa um novo passaporte, saia do pa√≠s etc. de acordo com a lista ...)</s> <br><br>  <b>Criando um novo segmento de meias</b> <br><br>  Ap√≥s receber um pacote yamux para estabelecer um novo fluxo, nosso cliente cria dois pipes de servidor an√¥nimos ($ sipipe, $ sopipe), pois in / out, respectivamente, cria pipes de clientes ($ cipipe, $ copipe) com base neles: <br><br><pre> <code class="plaintext hljs">$sipipe = new-object System.IO.Pipes.AnonymousPipeServerStream(1) $sopipe = new-object System.IO.Pipes.AnonymousPipeServerStream(2,1) $sipipe_clHandle = $sipipe.GetClientHandleAsString() $sopipe_clHandle = $sopipe.GetClientHandleAsString() $cipipe = new-object System.IO.Pipes.AnonymousPipeClientStream(1,$sopipe_clHandle) $copipe = new-object System.IO.Pipes.AnonymousPipeClientStream(2,$sipipe_clHandle)</code> </pre> <br>  cria um espa√ßo de execu√ß√£o para o fluxo de meias, define vari√°veis ‚Äã‚Äãcompartilhadas para interagir com esse fluxo (StopFlag) e executa o bloco de script SocksScript, que implementa a funcionalidade do servidor de meias em um fluxo separado: <br><br><pre> <code class="plaintext hljs">$state = [PSCustomObject]@{"StreamID"=$ymxstream;"inputStream"=$cipipe;"outputStream"=$copipe} $PS = [PowerShell]::Create() $socksrunspace = [runspacefactory]::CreateRunspace() $socksrunspace.Open() $socksrunspace.SessionStateProxy.SetVariable("StopFlag",$StopFlag) $PS.Runspace = $socksrunspace $PS.AddScript($socksScript).AddArgument($state) | Out-Null [System.IAsyncResult]$AsyncJobResult = $null $StopFlag[$ymxstream] = 0 $AsyncJobResult = $PS.BeginInvoke()</code> </pre> <br>  As vari√°veis ‚Äã‚Äãcriadas s√£o gravadas em uma estrutura ArrayList especial - um an√°logo do Dictionary em Python <br><br><pre> <code class="plaintext hljs">[System.Collections.ArrayList]$streams = @{}</code> </pre><br>  A adi√ß√£o ocorre atrav√©s do m√©todo Add interno: <br><br><pre> <code class="plaintext hljs">$streams.add(@{ymxId=$ymxstream;cinputStream=$cipipe;sinputStream=$sipipe;coutputStream=$copipe;soutputStream=$sopipe;asyncobj=$AsyncJobResult;psobj=$PS;readjob=$null;readbuffer=$readbuffer}) | out-null</code> </pre> <br>  <b>Processamento de Dados Yamux</b> <br><br>  Ap√≥s o recebimento dos dados destinados a qualquer fluxo de meias do servidor yamux, devemos determinar o n√∫mero do fluxo do yamux (o n√∫mero do fluxo de meias ao qual esses dados se destinam) e o n√∫mero de bytes de dados do cabe√ßalho do yamux de 12 bytes: <br><br><pre> <code class="plaintext hljs">$ymxstream = [bitconverter]::ToInt32($buffer[7..4],0) $ymxcount = [bitconverter]::ToInt32($buffer[11..8],0)</code> </pre> <br>  Em seguida, no fluxo ArrayList, usando o campo ymxId, obtemos os manipuladores do canal de sa√≠da do servidor correspondentes a esse fluxo de meias: <br><br><pre> <code class="plaintext hljs"> if ($streams.Count -gt 1){$streamind = $streams.ymxId.IndexOf($ymxstream)} else {$streamind = 0} $outStream = $streams[$streamind].soutputStream</code> </pre> <br>  Depois disso, lemos os dados do soquete, lembrando que precisamos ler um certo n√∫mero de bytes atrav√©s do loop: <br><br><pre> <code class="plaintext hljs"> $databuffer = $null $tnum = 0 do { if ($buffer.length -le ($ymxcount-$tnum)) { $num = $tcpStream.Read($buffer,0,$buffer.Length) }else { $num = $tcpStream.Read($buffer,0,($ymxcount-$tnum)) } $tnum += $num $databuffer += $buffer[0..($num-1)] }while ($tnum -lt $ymxcount -and $tcpConnection.Connected)</code> </pre> <br>  e escreva os dados recebidos no canal correspondente: <br><br><pre> <code class="plaintext hljs">$num = $tcpStream.Read($buffer,0,$ymxcount) $outStream.Write($buffer,0,$ymxcount)</code> </pre> <br><br>  <b>Processamento FIN do Yamux - Fluxo final</b> <br><br>  Quando recebemos um pacote do servidor yamix que sinaliza o fechamento de um fluxo, tamb√©m obtemos primeiro o n√∫mero do fluxo yamux no cabe√ßalho de 12 bytes: <br><br><pre> <code class="plaintext hljs"> $ymxstream = [bitconverter]::ToInt32($buffer[7..4],0)</code> </pre> <br>  ent√£o, atrav√©s de uma vari√°vel compartilhada (ou melhor, uma matriz de sinalizadores, onde o √≠ndice √© o n√∫mero do fluxo do yamux), sinalizamos para que o segmento de meias seja conclu√≠do: <br><br><pre> <code class="plaintext hljs">if ($streams.Count -gt 1){$streamind = $streams.ymxId.IndexOf($ymxstream)} else {$streamind = 0} if ($StopFlag[$ymxstream] -eq 0){ write-host "stopflag is 0. Setting to 1" $StopFlag[$ymxstream] = 1 }</code> </pre> <br>  depois de definir o sinalizador, antes de interromper o fluxo de meias, √© necess√°rio aguardar um certo tempo para que o fluxo de meias processe esse sinalizador.  200 ms √© suficiente para isso: <br><br><pre> <code class="plaintext hljs">start-sleep -milliseconds 200 #wait for thread check flag</code> </pre><br>  feche todos os pipes relacionados a esse fluxo, feche o Runspace correspondente e mate o objeto Powershell para liberar recursos: <br><br><pre> <code class="plaintext hljs">$streams[$streamind].cinputStream.close() $streams[$streamind].coutputStream.close() $streams[$streamind].sinputStream.close() $streams[$streamind].soutputStream.close() $streams[$streamind].psobj.Runspace.close() $streams[$streamind].psobj.Dispose() $streams[$streamind].readbuffer.clear()</code> </pre> <br>  Depois de fechar o fluxo de meias, precisamos remover o elemento correspondente dos fluxos ArrayList: <br><br><pre> <code class="plaintext hljs">$streams.RemoveAt($streamind)</code> </pre> <br>  E, no final, precisamos for√ßar o coletor de lixo .Net a liberar os recursos usados ‚Äã‚Äãpelo encadeamento.  Caso contr√°rio, nosso script consumir√° cerca de 100-200 MB de mem√≥ria, o que pode chamar a aten√ß√£o de um usu√°rio experiente e corrosivo, mas n√£o precisamos disso: <br><br><pre> <code class="plaintext hljs">[System.GC]::Collect()#clear garbage to minimize memory usage</code> </pre> <br><h3>  Script Yamux - fluxo reverso </h3><br>  Como mencionado acima, os dados recebidos dos fluxos de meias s√£o processados ‚Äã‚Äãpor um fluxo yamuxScript separado, que come√ßa desde o in√≠cio (ap√≥s uma conex√£o bem-sucedida ao servidor).  Sua tarefa √© pesquisar periodicamente os tubos de sa√≠da dos fluxos de meias localizados nos fluxos ArrayList $: <br><pre> <code class="plaintext hljs">foreach ($stream in $state.streams){ ... }</code> </pre> <br>  e se houver dados neles, envie-os para o servidor yamux, ap√≥s fornecer o cabe√ßalho correspondente do yamux de 12 bytes com o n√∫mero da sess√£o do yamux e o n√∫mero de bytes de dados: <br><br><pre> <code class="plaintext hljs"> if ($stream.readjob -eq $null){ $stream.readjob = $stream.sinputStream.ReadAsync($stream.readbuffer,0,1024) }elseif ( $stream.readjob.IsCompleted ){ #if read asyncjob completed - generate yamux header $outbuf = [byte[]](0x00,0x00,0x00,0x00)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ [bitconverter]::getbytes([int32]$stream.readjob.Result)[3..0] $state.tcpstream.Write($outbuf,0,12) #write raw data from socks thread to yamux $state.tcpstream.Write($stream.readbuffer,0,$stream.readjob.Result) $state.tcpstream.flush() #create new readasync job $stream.readjob = $stream.sinputStream.ReadAsync($stream.readbuffer,0,1024) }else{ #write-host "Not readed" }</code> </pre> <br>  O YamuxScript tamb√©m monitora o sinalizador definido na matriz compartilhada $ StopFlag para cada um dos threads socksScript que s√£o executados.  Esse sinalizador pode ser definido como 2 se o servidor remoto que socksScript estiver trabalhando com desconex√µes.  Nessa situa√ß√£o, as informa√ß√µes precisam ser relatadas ao cliente de meias.  A cadeia √© a seguinte: o yamuxScript deve informar o servidor do yamux sobre a desconex√£o, para que por sua vez sinalize isso para o cliente de meias. <br><br><pre> <code class="plaintext hljs">if ($StopFlag[$stream.ymxId] -eq 2){ $stream.ymxId | out-file -Append c:\work\log.txt $outbuf = [byte[]](0x00,0x01,0x00,0x04)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ [byte[]](0x00,0x00,0x00,0x00) $state.tcpstream.Write($outbuf,0,12) $state.tcpstream.flush() }</code> </pre> <br><h3>  Atualiza√ß√£o da janela do Yamux </h3><br>  Al√©m disso, o yamuxScript deve monitorar o n√∫mero de bytes recebidos do servidor yamux e enviar periodicamente uma mensagem YMX WinUpdate.  Esse mecanismo no Yamux √© respons√°vel por monitorar e alterar o chamado tamanho da janela (semelhante ao protocolo TCP) - o n√∫mero de bytes de dados que podem ser enviados sem reconhecimento.  Por padr√£o, o tamanho da janela √© de 256 Kbytes.  Isso significa que, ao enviar ou receber arquivos ou dados maiores que esse tamanho, precisamos enviar o pacote de atualiza√ß√£o do windpw para o servidor yamux.  Para controlar a quantidade de dados recebidos do servidor yamux, foi introduzida uma matriz compartilhada especial $ RcvBytes, na qual o fluxo principal, incrementando o valor atual, registra o n√∫mero de bytes recebidos do servidor para cada fluxo.  Se o limite definido for excedido, o yamuxScript dever√° enviar um pacote ao servidor WinUpdate e redefinir o contador: <br><br><pre> <code class="plaintext hljs"> if ($RcvBytes[$stream.ymxId] -ge 256144){ #out win update ymx packet with 256K size $outbuf = [byte[]](0x00,0x01,0x00,0x00)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ (0x00,0x04,0x00,0x00) $state.tcpstream.Write($outbuf,0,12) $RcvBytes[$stream.ymxId] = 0 }</code> </pre> <br><h3>  SocksScript Streams </h3><br>  Agora vamos passar diretamente para o pr√≥prio socksScript. <br>  Lembre-se de que o socksScript √© chamado de forma ass√≠ncrona: <br><br><pre> <code class="plaintext hljs">$state = [PSCustomObject]@{"StreamID"=$ymxstream;"inputStream"=$cipipe;"outputStream"=$copipe} $PS = [PowerShell]::Create() .... $AsyncJobResult = $PS.BeginInvoke()</code> </pre> <br>  e no momento da chamada, os seguintes dados est√£o presentes na vari√°vel $ state transferida para o fluxo: <br><br><ul><li>  $ state.streamId - n√∫mero da sess√£o do yamux; </li><li>  $ state.inputStream - canal de leitura; </li><li>  $ state.oututStream - canal de grava√ß√£o; </li></ul><br>  Os dados nos tubos s√£o fornecidos em forma bruta sem cabe√ßalhos yamux, ou seja,  na forma em que eles vieram do cliente de meias. <br><br>  Dentro do socksScript, antes de tudo, precisamos determinar a vers√£o do socks e garantir que seja 5: <br><br><pre> <code class="plaintext hljs">$state.inputStream.Read($buffer,0,2) | Out-Null $socksVer=$buffer[0] if ($socksVer -eq 5){ ... }</code> </pre> <br>  Bem, ent√£o fazemos exatamente como implementado no script Invoke-SocksProxy.  A √∫nica diferen√ßa ser√° que, em vez de chamadas <br><br><pre> <code class="plaintext hljs">$AsyncJobResult.AsyncWaitHandle.WaitOne(); $AsyncJobResult2.AsyncWaitHandle.WaitOne();</code> </pre> <br>  √â necess√°rio monitorar a conex√£o tcp e o sinalizador de termina√ß√£o correspondente na matriz $ StopFlag em um modo c√≠clico; caso contr√°rio, n√£o poderemos reconhecer a situa√ß√£o do final da conex√£o pelo lado do cliente de meias e do servidor ymux: <br><br><pre> <code class="plaintext hljs">while ($StopFlag[$state.StreamID] -eq 0 -and $tmpServ.Connected ){ start-sleep -Milliseconds 50 }</code> </pre> <br>  Caso a conex√£o termine no lado tcp do servidor ao qual estamos nos conectando, definimos esse sinalizador como 2, o que for√ßar√° o yamuxscript a reconhecer isso e enviar o pacote ymx FIN correspondente ao servidor yamux: <br><br><pre> <code class="plaintext hljs">if ($tmpServ.Connected){ $tmpServ.close() }else{ $StopFlag[$state.StreamID] = 2 }</code> </pre> <br>  Tamb√©m devemos definir esse sinalizador se o socksScript n√£o puder se conectar ao servidor de destino: <br><br><pre> <code class="plaintext hljs">if($tmpServ.Connected){ ... } else{ $buffer[1]=4 $state.outputStream.Write($buffer,0,2) $StopFlag[$state.StreamID] = 2 }</code> </pre> <br><h3>  Conclus√£o para a segunda parte </h3><br>  No decorrer de nossa pesquisa de codifica√ß√£o, fomos capazes de criar um cliente powershell para o servidor RsocksTun com a capacidade de: <br><br><ul><li>  Conex√µes SSL </li><li>  autoriza√ß√£o no servidor; </li><li>  trabalhe com o yamux-server com suporte para pings keepalive; </li><li>  modo de opera√ß√£o multithread; </li><li>  suporte para transfer√™ncia de arquivos grandes; </li></ul><br>  Fora do artigo, houve uma implementa√ß√£o da funcionalidade de conectar-se atrav√©s de um servidor proxy e autoriz√°-lo, al√©m de transformar nosso script em uma vers√£o embutida, que pode ser executada na linha de comando.  Ser√° na terceira parte. <br><br>  Isso √© tudo por hoje.  Como se costuma dizer - inscreva-se, como, deixe coment√°rios (especialmente sobre seus pensamentos em melhorar o c√≥digo e adicionar funcionalidade). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453970/">https://habr.com/ru/post/pt453970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453958/index.html">Monoreposit√≥rios: por favor</a></li>
<li><a href="../pt453960/index.html">Global DevOps Bootcamp 2019 em Moscou</a></li>
<li><a href="../pt453962/index.html">RxSwift e Coroutines na Kotlin - desenvolvimento m√≥vel opcional da AGIMA e GeekBrains</a></li>
<li><a href="../pt453964/index.html">POO na linguagem R (parte 1): classes S3</a></li>
<li><a href="../pt453968/index.html">Desaprender pr√°ticas de revis√£o de c√≥digo t√≥xico</a></li>
<li><a href="../pt453972/index.html">Arque√≥logos recriam um alfinete de dois mil anos usando impress√£o e digitaliza√ß√£o 3D</a></li>
<li><a href="../pt453974/index.html">Concorr√™ncia de sistemas ML em material lingu√≠stico. Como aprendemos a preencher os espa√ßos em branco</a></li>
<li><a href="../pt453976/index.html">Programa educacional econ√¥mico para especialistas em TI</a></li>
<li><a href="../pt453978/index.html">Impressora 3D de constru√ß√£o do MIT imprime um edif√≠cio em 14 horas</a></li>
<li><a href="../pt453980/index.html">Impress√£o de etiquetas e pre√ßos na loja online .net</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>