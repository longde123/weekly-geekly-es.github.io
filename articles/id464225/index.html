<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóΩ üîª ‚òÑÔ∏è REST Assured: apa yang kami pelajari dari lima tahun menggunakan alat ini üÖ±Ô∏è üöß ‚òéÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="REST Assured - DSL untuk menguji layanan REST, yang tertanam dalam pengujian Java. Solusi ini muncul lebih dari sembilan tahun yang lalu dan telah men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>REST Assured: apa yang kami pelajari dari lima tahun menggunakan alat ini</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/464225/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">REST Assured</a> - DSL untuk menguji layanan REST, yang tertanam dalam pengujian Java.  Solusi ini muncul lebih dari sembilan tahun yang lalu dan telah menjadi populer karena kesederhanaan dan fungsionalitasnya yang nyaman. </p><br><p>  Dalam DINS, kami menulis lebih dari 17.000 tes dengan itu dan selama lima tahun penggunaan, kami menemukan banyak "jebakan" yang tidak dapat ditemukan tepat setelah mengimpor perpustakaan ke dalam proyek: konteks statis, kebingungan dalam urutan filter yang diterapkan pada kueri, kesulitan dalam menyusun tes. </p><br><p>  Artikel ini adalah tentang fitur implisit REST Tertanggung.  Mereka perlu diperhitungkan jika ada kemungkinan bahwa jumlah tes dalam proyek akan meningkat dengan cepat - sehingga Anda tidak perlu menulis ulang nanti. </p><br><p><img src="https://habrastorage.org/webt/yr/xi/jp/yrxijpz_m48cyfek2-0czo55bqc.png" alt="gambar"></p><a name="habracut"></a><br><h3 id="chto-testiruem">  Apa yang kami uji </h3><br><p>  DINS terlibat dalam pengembangan platform UCaaS.  Secara khusus, kami mengembangkan dan menguji API yang digunakan RingCentral sendiri dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyediakan untuk pengembang pihak ketiga</a> . </p><br><p>  Saat mengembangkan API apa pun, penting untuk memastikan bahwa API itu berfungsi dengan benar, tetapi ketika Anda memberikannya, Anda harus memeriksa lebih banyak kasus.  Oleh karena itu, puluhan dan ratusan tes ditambahkan ke setiap titik akhir baru.  Tes ditulis dalam Java, TestNG dipilih sebagai kerangka uji, dan REST Assured digunakan untuk permintaan API. </p><br><h3 id="kogda-rest-assured-prineset-polzu">  Ketika REST Diasuransikan Akan Mendapat Manfaat </h3><br><p>  Jika tujuan Anda bukan untuk menguji keseluruhan API secara menyeluruh, maka cara termudah untuk melakukannya adalah dengan REST Assured.  Sangat cocok untuk memeriksa struktur respons, PVD, dan tes asap. </p><br><p>  Ini adalah bagaimana tes sederhana terlihat, yang akan memeriksa bahwa titik akhir memberikan status 200 OK ketika mengaksesnya: </p><br><pre><code class="java hljs">given() .baseUri(<span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>) .when() .get(<span class="hljs-string"><span class="hljs-string">"/cookies"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>);</code> </pre> <br><p>  Kata kunci yang <code>given</code> , <code>when</code> dan <code>then</code> membentuk permintaan: <code>given</code> menentukan apa yang akan dikirim dalam permintaan, <code>when</code> ‚Äì‚Äì dengan metode apa dan ke titik akhir mana kami mengirim permintaan, dan <code>then</code> ‚Äì‚Äì bagaimana respons yang diterima diperiksa.  Selain itu, Anda bisa mengekstrak badan respons dalam bentuk objek bertipe <code>JsonPath</code> atau <code>XmlPath</code> , lalu menggunakan data yang diterima. </p><br><p>  Tes nyata biasanya lebih besar dan lebih rumit.  Tajuk, cookie, otorisasi, badan permintaan ditambahkan ke permintaan.  Dan jika API yang diuji tidak terdiri dari lusinan sumber daya unik, yang masing-masing memerlukan parameter khusus, Anda akan ingin menyimpan template yang sudah jadi di suatu tempat untuk menambahkannya nanti ke panggilan tertentu dalam pengujian. </p><br><p>  Untuk ini, di REST Tertanggung ada: </p><br><ul><li>  <code>RequestSpecification</code> / <code>ResponseSpecification</code> ; </li><li>  konfigurasi dasar; </li><li>  filter. </li></ul><br><h3 id="requestspecification-i-responsespecification">  RequestSpecification dan ResponseSpecification </h3><br><p>  Dua kelas ini memungkinkan Anda untuk menentukan parameter permintaan dan harapan dari respons: </p><br><pre> <code class="java hljs">RequestSpecification requestSpec = given() .baseUri(<span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>) .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>); requestSpec.when() .get(<span class="hljs-string"><span class="hljs-string">"/cookiesformonster"</span></span>) .then() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>); requestSpec.when() .get(<span class="hljs-string"><span class="hljs-string">"/soup"</span></span>) .then() .statusCode(<span class="hljs-number"><span class="hljs-number">400</span></span>);</code> </pre> <br><pre> <code class="java hljs">ResponseSpecification responseSpec = expect() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>); given() .expect() .spec(responseSpec) .when() .get(<span class="hljs-string"><span class="hljs-string">"/hello"</span></span>); given() .expect() .spec(responseSpec) .when() .get(<span class="hljs-string"><span class="hljs-string">"/goodbye"</span></span>);</code> </pre> <br><p>  Satu spesifikasi digunakan dalam beberapa panggilan, tes, dan kelas uji, tergantung di mana ia didefinisikan - tidak ada batasan.  Anda bahkan dapat menambahkan beberapa spesifikasi ke satu permintaan.  Namun, ini merupakan <strong>sumber masalah</strong> potensial: </p><br><pre> <code class="java hljs">RequestSpecification requestSpec = given() .baseUri(<span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>) .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>); RequestSpecification yetAnotherRequestSpec = given() .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"fr"</span></span>); given() .spec(requestSpec) .spec(yetAnotherRequestSpec) .when() .get(<span class="hljs-string"><span class="hljs-string">"/cookies"</span></span>) .then() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>);</code> </pre> <br><p>  Log Panggilan: </p><br><pre> <code class="plaintext hljs">Request method: GET Request URI: http://localhost:8080/ Headers: Language=en Language=fr Accept=*/* Cookies: &lt;none&gt; Multiparts: &lt;none&gt; Body: &lt;none&gt; java.net.ConnectException: Connection refused (Connection refused)</code> </pre> <br><p>  Ternyata semua header ditambahkan ke panggilan, tetapi URI tiba-tiba menjadi hosting lokal - meskipun ditambahkan dalam spesifikasi pertama. </p><br><p>  Ini terjadi karena fakta bahwa REST Assured menangani penggantian untuk parameter permintaan secara berbeda (sama dengan jawabannya).  Header atau filter ditambahkan ke daftar dan kemudian diterapkan secara bergantian.  Hanya ada satu URI, jadi yang terakhir diterapkan.  Itu tidak ditentukan dalam spesifikasi terakhir yang ditambahkan - oleh karena itu, REST Assured menimpanya dengan nilai default (localhost). </p><br><p>  <strong>Jika Anda menambahkan spesifikasi ke permintaan, tambahkan satu</strong> .  Nasihatnya tampak jelas, tetapi ketika proyek dengan tes tumbuh, kelas pembantu dan kelas tes dasar muncul, sebelum metode muncul di dalamnya.  Melacak apa yang sebenarnya terjadi dengan permintaan Anda menjadi sulit, terutama jika beberapa orang menulis tes sekaligus. </p><br><h3 id="bazovaya-konfiguraciya-rest-assured">  Konfigurasi REST Dasar Terjamin </h3><br><p>  Cara lain untuk templat kueri di REST Assured adalah mengonfigurasi konfigurasi dasar dan menentukan bidang statis kelas RestAssured: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BeforeMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureRestAssured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ RestAssured.baseURI = <span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>; RestAssured.requestSpecification = given() .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>); RestAssured.filters(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ResponseLoggingFilter()); ... }</code> </pre> <br><p>  Nilai akan ditambahkan secara otomatis ke permintaan setiap kali.  Konfigurasi ini dikombinasikan dengan penjelasan <code>@BeforeMethod</code> di TestNG dan <code>@BeforeEach</code> di JUnit - sehingga Anda dapat yakin bahwa setiap pengujian yang Anda jalankan akan mulai dengan parameter yang sama. </p><br><p>  Namun, <strong>konfigurasi akan menjadi sumber masalah potensial, karena bersifat statis</strong> . </p><br><p>  Contoh: sebelum setiap pengujian, kami mengambil pengguna tes, mendapatkan token otorisasi untuknya, dan kemudian menambahkannya melalui AuthenticationScheme atau filter otorisasi ke konfigurasi dasar.  Selama tes berjalan dalam satu utas, semuanya akan bekerja. <br>  Ketika ada terlalu banyak tes, keputusan biasa untuk membagi eksekusi menjadi beberapa utas akan menyebabkan penulisan ulang sepotong kode sehingga token dari satu utas tidak jatuh ke yang tetangga. </p><br><h3 id="filtry-rest-assured">  REST Filter Tertanggung </h3><br><p>  Filter memodifikasi kedua permintaan sebelum mengirim dan merespons sebelum memeriksa kepatuhan dengan harapan yang ditentukan.  Contoh aplikasi - menambahkan logging, atau otorisasi: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OAuth2Filter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthFilter</span></span></span><span class="hljs-class"> </span></span>{ String accessToken; OAuth2Filter(String accessToken) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.accessToken = accessToken; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FilterableRequestSpecification requestSpec, FilterableResponseSpecification responseSpec, FilterContext ctx)</span></span></span><span class="hljs-function"> </span></span>{ requestSpec.replaceHeader(<span class="hljs-string"><span class="hljs-string">"Authorization"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bearer "</span></span> + accessToken); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx.next(requestSpec, responseSpec); } }</code> </pre> <br><pre> <code class="java hljs">String accessToken = getAccessToken(username, password); OAuth2Filter auth = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OAuth2Filter(accessToken); given() .filter(auth) .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter()) .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ResponseLoggingFilter()) ...</code> </pre> <br><p>  Filter yang ditambahkan ke permintaan disimpan di <code>LinkedList</code> .  Sebelum mengajukan permintaan, REST Assured memodifikasinya dengan menelusuri daftar dan menerapkan satu filter setelah filter lainnya.  Kemudian hal yang sama dilakukan dengan jawaban yang datang. </p><br><p>  <strong>Urutan filter penting</strong> .  Dua kueri ini akan menghasilkan log yang berbeda: yang pertama menunjukkan header otorisasi, yang kedua - tidak.  Dalam hal ini, tajuk akan ditambahkan ke kedua permintaan - hanya dalam kasus pertama, REST Tertanggung pertama akan menambahkan otorisasi sebelum mendaftar, dan sebaliknya - sebaliknya. </p><br><pre> <code class="java hljs">given() .filter(auth) .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter()) ‚Ä¶ given() .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter()) .filter(auth)</code> </pre> <br><p>  Selain aturan umum bahwa filter diterapkan dalam urutan penambahannya, masih ada peluang untuk memprioritaskan filter Anda dengan mengimplementasikan antarmuka <code>OrderedFilter</code> .  Ini memungkinkan Anda untuk menetapkan prioritas numerik khusus untuk filter, di atas atau di bawah default (1000).  Filter dengan prioritas di atas akan dieksekusi lebih awal dari biasanya, dengan prioritas di bawah - setelah mereka. </p><br><p>  Tentu saja, di sini Anda dapat menjadi bingung dan secara tidak sengaja mengatur dua filter ke prioritas yang sama, misalnya, pada 999. Kemudian yang ditambahkan sebelumnya akan diterapkan pada permintaan terlebih dahulu. </p><br><h3 id="ne-tolko-filtry">  Tidak hanya filter </h3><br><p>  Cara melakukan otorisasi melalui filter ditunjukkan di atas.  Namun selain metode ini di REST Assured, ada metode lain, melalui <code>AuthenticationScheme</code> : </p><br><pre> <code class="java hljs">String accessToken = getAccessToken(username, password); OAuth2Scheme scheme = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OAuth2Scheme(); scheme.setAccessToken(accessToken); RestAssured.authentication = scheme;</code> </pre> <br><p>  Ini adalah metode yang usang.  Sebaliknya, Anda harus memilih yang ditunjukkan di atas.  Ada dua alasan: </p><br><p>  <strong>Masalah Ketergantungan</strong> </p><br><p>  Dokumentasi untuk REST Tertanggung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menunjukkan</a> bahwa untuk menggunakan Oauth1 atau Oauth2 (dengan menetapkan token sebagai parameter kueri), otorisasi harus ditambahkan tergantung pada juru tulis.  Namun, mengimpor versi terbaru tidak akan membantu Anda - Anda akan memiliki kesalahan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan di salah satu masalah terbuka</a> .  Anda dapat menyelesaikannya hanya dengan mengimpor perpustakaan versi lama, 2.5.3.  Namun, dalam hal ini Anda akan menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah lain</a> . </p><br><p>  Secara umum, tidak ada versi lain dari Scribe yang berfungsi dengan Oauth2 REST Assured versi 3.0.3 dan lebih tinggi (dan rilis terbaru 4.0.0 tidak memperbaiki ini). </p><br><p>  <strong>Pencatatan tidak berfungsi</strong> </p><br><p>  Filter diterapkan ke kueri dalam urutan tertentu.  Dan <code>AuthenticationScheme</code> diterapkan setelah mereka.  Ini berarti bahwa akan sulit untuk mendeteksi masalah dengan otorisasi dalam tes - tidak dijaminkan. </p><br><h3 id="esche-o-sintaksise-rest-assured">  Lebih lanjut tentang sintaks REST Assured </h3><br><p>  Sejumlah besar tes biasanya berarti bahwa mereka juga kompleks.  Dan jika API adalah subjek utama pengujian, dan Anda perlu memeriksa tidak hanya bidang json, tetapi logika bisnis, kemudian dengan REST Assured, pengujian berubah menjadi lembaran: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldCorrectlyCountAddedCookies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Integer addNumber = <span class="hljs-number"><span class="hljs-number">10</span></span>; JsonPath beforeCookies = given() .when() .get(<span class="hljs-string"><span class="hljs-string">"/latestcookies"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>) .extract() .jsonPath(); String beforeId = beforeCookies.getString(<span class="hljs-string"><span class="hljs-string">"id"</span></span>); JsonPath afterCookies = given() .body(String.format(<span class="hljs-string"><span class="hljs-string">"{number: %s}"</span></span>, addNumber)) .when() .put(<span class="hljs-string"><span class="hljs-string">"/cookies"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>) .extract() .jsonPath(); Integer afterNumber = afterCookies.getInt(<span class="hljs-string"><span class="hljs-string">"number"</span></span>); String afterId = afterCookies.getString(<span class="hljs-string"><span class="hljs-string">"id"</span></span>); JsonPath history = given() .when() .get(<span class="hljs-string"><span class="hljs-string">"/history"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>) .extract() .jsonPath(); assertThat(history.getInt(String.format(<span class="hljs-string"><span class="hljs-string">"records.find{r -&gt; r.id == %s}.number"</span></span>, beforeId))) .isEqualTo(afterNumber - addNumber); assertThat(history.getInt(String.format(<span class="hljs-string"><span class="hljs-string">"records.find{r -&gt; r.id == %s}.number"</span></span>, afterId))) .isEqualTo(afterNumber); }</code> </pre> <br><p>  Tes ini memverifikasi bahwa ketika kami memberi makan cookie monster, kami menghitung dengan benar berapa banyak cookie yang diberikan kepadanya, dan menunjukkan ini dalam cerita.  Tetapi pada pandangan pertama ini tidak dapat dipahami - semua permintaan terlihat sama, dan tidak jelas di mana persiapan data melalui API berakhir, dan di mana permintaan pengujian dikirim. </p><br><p>  <code>given()</code> , <code>when()</code> dan <code>then()</code> REST Assured mengambil dari BDD, seperti Spock atau Mentimun.  Namun, dalam tes yang kompleks, maknanya hilang, karena skala tes menjadi jauh lebih besar dari satu permintaan - ini adalah satu tindakan kecil yang perlu dilambangkan dengan satu baris.  Dan untuk ini, Anda dapat mentransfer panggilan REST Assured ke kelas tambahan: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CookieMonsterHelper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> JsonPath </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCookies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> given() .when() .get(<span class="hljs-string"><span class="hljs-string">"/cookiesformonster"</span></span>) .then() .extract() .jsonPath(); } ... }</code> </pre> <br><p>  Dan hubungi tes: </p><br><pre> <code class="java hljs">JsonPath response = CookieMonsterHelper.getCookies();</code> </pre> <br><p>  Ada baiknya ketika kelas pembantu seperti itu bersifat universal sehingga panggilan ke satu metode dapat tertanam dalam sejumlah besar tes - maka mereka dapat dimasukkan ke perpustakaan terpisah secara umum: tiba-tiba, Anda perlu memanggil metode di beberapa titik di proyek lain.  Hanya dalam kasus ini Anda harus menghapus semua verifikasi dari respons yang dapat dilakukan oleh Tertanggung - lagi pula, data yang sangat berbeda seringkali dapat dikembalikan sebagai tanggapan atas permintaan yang sama. </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  REST Assured adalah perpustakaan untuk pengujian.  Dia tahu bagaimana melakukan dua hal: mengirim permintaan dan memeriksa jawaban.  Jika kami mencoba menghapusnya dari pengujian dan menghapus semua validasi, maka itu <strong>berubah menjadi klien HTTP</strong> . </p><br><p>  Jika Anda harus menulis sejumlah besar tes dan terus mendukungnya, pikirkan apakah Anda memerlukan klien HTTP dengan sintaks yang rumit, konfigurasi statis, kebingungan dalam urutan penerapan filter dan spesifikasi, dan pencatatan yang mudah rusak?  Mungkin sembilan tahun yang lalu, REST Assured adalah alat yang paling nyaman, tetapi selama ini alternatif muncul - Retrofit, Feign, Unirest, dll - yang tidak memiliki fitur seperti itu. </p><br><p>  Sebagian besar masalah yang dijelaskan dalam artikel memanifestasikan diri dalam proyek-proyek besar.  Jika Anda perlu dengan cepat menulis beberapa tes dan melupakannya selamanya, dan Retrofit tidak menyukainya, REST Assured adalah pilihan terbaik. </p><br><p>  Jika Anda sudah menulis tes menggunakan REST Assured, tidak perlu terburu-buru untuk menulis ulang semuanya.  Jika mereka stabil dan cepat, itu akan menghabiskan lebih banyak waktu daripada membawa manfaat praktis.  Jika tidak, REST Tertanggung bukan masalah utama Anda. </p><br><p>  Setiap hari, jumlah tes yang ditulis dalam DINS untuk RingCentral API terus bertambah, dan mereka masih menggunakan REST Assured.  Jumlah waktu yang harus dihabiskan untuk beralih ke klien HTTP lain, setidaknya dalam pengujian baru, terlalu besar, dan kelas pembantu yang dibuat dan metode yang mengonfigurasi konfigurasi pengujian menyelesaikan sebagian besar masalah.  Dalam hal ini, menjaga integritas proyek dengan tes lebih penting daripada menggunakan klien yang paling cantik dan modis.  REST Diasuransikan, terlepas dari kekurangannya, melakukan tugas utamanya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464225/">https://habr.com/ru/post/id464225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464209/index.html">Gutenberg Editor, cara membuat editor dan huruf-huruf nyaman</a></li>
<li><a href="../id464217/index.html">Cara memvisualisasikan suara di web: pilihan materi tematik dan ceramah video dengan teori dan praktik</a></li>
<li><a href="../id464219/index.html">Toolkit timlid dari email ke papan kanban</a></li>
<li><a href="../id464221/index.html">Belajar bekerja dengan tim di Saint TeamLead Conf</a></li>
<li><a href="../id464223/index.html">Pengembangan Kesadaran di Saint TeamLead Conf</a></li>
<li><a href="../id464227/index.html">Bagaimana mereka hidup dan bekerja di Krasnodar</a></li>
<li><a href="../id464233/index.html">Konstruksi Chaos 2019 Hadir ...</a></li>
<li><a href="../id464235/index.html">"Slurm" sangat adiktif. Bagaimana mengubah komplotan rahasia menjadi proyek global</a></li>
<li><a href="../id464237/index.html">Pascal Tanchiki: bagaimana anak-anak diajarkan pemrograman pada tahun 90-an dan apa yang salah dengan itu</a></li>
<li><a href="../id464245/index.html">Mengkonfigurasi Pembunuh Kehabisan Memori di Linux untuk PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>