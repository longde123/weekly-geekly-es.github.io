<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏿 🙍🏿 🚒 Vue，Storybook，TypeScript —在考虑最佳实践的情况下开始新项目 ☝🏻 💧 👨🏿‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="（最初在Medium上发布） 


 我喜欢编写React代码。 这可能是关于Vue的故事的奇怪介绍，但是您需要了解我的背景才能理解为什么我在这里讨论Vue。 


 我喜欢编写React代码，但我讨厌阅读它。 JSX是将各个组件快速组装在一起的好主意，Material-UI是引导下一个初创公司UI...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vue，Storybook，TypeScript —在考虑最佳实践的情况下开始新项目</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438354/"><p><img src="https://habrastorage.org/webt/3l/z_/hj/3lz_hjzvuh91eqfwdlcux6yluyy.png"></p><br><p>  <em>（最初在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Medium上</a>发布）</em> </p><br><p> 我喜欢编写React代码。 这可能是关于Vue的故事的奇怪介绍，但是您需要了解我的背景才能理解为什么我在这里讨论Vue。 </p><br><p> 我喜欢编写React代码，但我讨厌阅读它。  JSX是将各个组件快速组装在一起的好主意，Material-UI是引导下一个初创公司UI的绝佳解决方案，通过JS常量计算CSS可以使您非常灵活。 但是，阅读旧的JSX感觉很糟糕-即使采用了严格的代码审查实践，当您尝试计算组件的复杂嵌套时，您可能也不会一次挠头。 </p><br><p> 我听说过有关Vue的许多事情-并不是那么新手-最终我决定弄湿我的脚。 带来了我所有的React和Polymer（以及Angular，但我们不要再谈论它）了。 </p><a name="habracut"></a><br><p> Vue非常类似于Polymer，因此作者将其命名为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">灵感</a>的来源之一。  <code>*.vue</code>文件的结构似乎是Polymer最好的部分，我直接参与其中。 几天后，我摆脱了打字稿，UI驱动的开发和众多最佳实践的沼泽，我准备分享自己的发现。 </p><br><h2 id="lets-go"> 走吧 </h2><br><p> 我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">npx</a>运行命令。 如果您还没有<code>npm install -g npx</code> ： <code>npm install -g npx</code> 。 当您处理npm cli软件包并且不想<code>npm install -g</code>数十种应用程序时，Npx可以节省生命。 如果您还没有的话，还需要使用Yarn- <code>npm install -g yarn</code>应该会让您了解最新信息。 </p><br><pre> <code class="plaintext hljs">$ npx vue create not-a-todo-app Vue CLI v3.3.0 ? Please pick a preset: Manually select features ? Check the features needed for your project: Babel, TS, PWA, Router, Vuex, CSS Pre-processors, Linter, Unit, E2E ? Use class-style component syntax? Yes ? Use Babel alongside TypeScript for auto-detected polyfills? Yes ? Use history mode for router? (Requires proper server setup for index fallback in production) Yes ? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Sass/SCSS ? Pick a linter / formatter config: TSLint ? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)Lint on save ? Pick a unit testing solution: Jest ? Pick a E2E testing solution: Cypress ? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files ? Save this as a preset for future projects? No</code> </pre> <br><p>  Vue Cli有一个不错的向导来指导您完成操作； 对于本教程，我们将使用手动模式并启用<strong>所有功能</strong> 。 过度杀伤力？ 也许可以，但是我们想看看Vue如何与开箱即用的产品一起工作。 尽管如此，让我们研究一下选择方式和原因以及原因。 </p><br><p> 我们需要同时启用<strong>Babel</strong>和<strong>TypeScript</strong> 。  TS将是首选的主要语言，Babel将支持处理需要编译的外部代码。 您可能会争辩说TypeScript也可以转换JS代码，的确如此，但是在我的实验中（尤其是与单元测试和Vuetify有关），我认为将TS保留为<code>*.ts</code>并将Babel用于其他所有内容要好得多。 </p><br><p>  <strong>CSS预处理器</strong>将在Vuetify中派上用场； 尽管它带有预缩小的CSS，但您可能需要包括原始样式文件以使用样式。 对于任何新项目， <strong>Linter / Formatter</strong>都是一个明显的要求（您必须遵循单一的代码样式，并且在阅读旧代码的一年内可以感谢我）。 我们同时启用了<strong>单元测试</strong>和<strong>E2E测试-</strong>尽管您可能不想执行完整的e2e测试用例，但在使用Vuetify完成操作后了解如何修复这些问题很有用。 </p><br><p> 本教程并不严格要求<strong>Progressive Web App（PWA）支持</strong> ， <strong>Router</strong>和<strong>Vuex</strong> ，并且我们不会使用它们，但启用它们将简化您在实际项目中的生活。 </p><br><p>  <strong>使用类样式的组件语法？</strong> 是的 类使代码略显笨重，但可读性更高，更易于推理。 它们也使您的TypeScript生活更加轻松。 </p><br><p>  <strong>将Babel与TypeScript一起使用以进行自动检测的polyfill吗？</strong> 是的 我们希望同时使用Babel和TS，以便稍后进行调查。 </p><br><p>  <strong>使用路由器的历史记录模式？</strong> 是的（但YMMV）。 我们不会编写任何后端来在生产中提供此服务，但是使用历史记录API通常是一个好主意。 </p><br><p>  <strong>选择一个CSS预处理器（默认情况下支持PostCSS，Autoprefixer和CSS模块）：</strong>在本教程中我们将仅使用CSS模块，因此您可以根据自己的喜好随意选择sass / less / stylus。 </p><br><p>  <strong>选择一个</strong> linter <strong>/ formatter配置：</strong> TSlint是一个显而易见的选择，因为我们想尽可能多地使用TypeScript。 </p><br><p>  <strong>选择其他皮棉功能：同时</strong>启用（ <code>a</code> ）。 棉绒好。 </p><br><p>  <strong>选择一个单元测试解决方案：</strong>本教程重点介绍Jest，因此必须选择它。 </p><br><p>  <strong>选择一个E2E测试解决方案：</strong>本教程重点介绍赛普拉斯。 </p><br><p>  <strong>您希望在哪里放置Babel，PostCSS，ESLint等的配置？</strong> 您难道不是每个人都试图将更多内容放到<code>package.json</code>有点奇怪吗？ 该文件几乎无法读取。 使用专用的配置文件-它们更易于使用，并且您的git历史记录会更漂亮。 </p><br><p> 是时候验证设置，运行<code>yarn serve</code> ： <br><img src="https://habrastorage.org/webt/5p/ak/ty/5paktyugcycg2dzdtjt1ss1vfoi.png"></p><br><p> 控制台中应该没有错误，并且导航到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http：// localhost：8080 /</a>将向您打招呼： <br><img src="https://habrastorage.org/webt/z4/hj/hv/z4hjhvcto1oaxdxokxi5rmuzque.png"></p><br><p> 验证单元测试是否正常，运行<code>yarn test:unit</code> ： <br><img src="https://habrastorage.org/webt/gd/v1/i1/gdv1i1hpoxsejeovp1bvbc4jnbg.png"></p><br><p> 和e2e测试工作（ <code>yarn test:e2e --headless</code> ）： <br><img src="https://habrastorage.org/webt/_p/td/ho/_ptdhoshlgew083bq7hfaapmvnu.png"></p><br><p> 太好了！ 转到UI。 </p><br><h2 id="the-material-dilemma"> 物质困境 </h2><br><p> 有一些针对Vue的Material UI库，它们的灵活性和改进程度不同。 当然，还有许多其他组件库，因此您可以随意使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Bootstrap Vue</a> 。 由于许多原因，本教程重点介绍<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vuetify</a> ： </p><br><ul><li> 它是GitHub上最受欢迎的Material库； </li><li> 使它正常工作是一种皇家痛苦，因此它是您可以进入的所有边缘案例的绝佳演示。 </li></ul><br><p> 说服了吗 然后继续安装： <code>vue add vuetify</code> 。 选择<strong>配置（高级）</strong>选项。 </p><br><p>  <strong>使用预制模板？</strong>  Vuetify将覆盖默认的App.vue和HelloWorld.vue。 对此回答是，因为这是一个新项目。 </p><br><p>  <strong>使用自定义主题？</strong> 是的 无论如何，迟早都需要一个，所以让我们对其进行配置。 出于相同的原因，对<strong>使用自定义属性（CSS变量）</strong>回答是<strong>？</strong>  。 </p><br><p>  <strong>选择图标字体：</strong> Material Icons（但稍后我还将向您展示如何修复它的Font Awesome）。  <strong>使用字体作为依赖项？</strong> 不行 我们将从CDN获得字体。 </p><br><p>  <strong>使用点菜组件？</strong> 是的 这似乎是使用Vuetify的最简单方法。 <br><img src="https://habrastorage.org/webt/w1/aa/v9/w1aav901fzrpaeqnnvluidjoufu.png"></p><br><p> 有很多更改，但是最重要的是，现在运行<code>yarn serve</code>您会看到不同的图片： <br><img src="https://habrastorage.org/webt/3l/z_/hj/3lz_hjzvuh91eqfwdlcux6yluyy.png"></p><br><p>  （您的短毛猫还会收到几十个警告）。 </p><br><p> 让我们检查单元测试... <br><img src="https://habrastorage.org/webt/ov/ks/29/ovks2927ibmuxyxblnxamj_jyb8.png"></p><br><h2 id="making-vuetify-work-with-unit-and-e2e-tests"> 使Vuetify与单元测试和端到端测试一起工作 </h2><br><p> 让我们检查<code>./tests/unit/example.spec.ts</code> 。 该测试验证<code>msg</code>是否显示“ <em>新消息</em> ”，但Vuetify随附的模板不再支持该道具。 在现实情况下，您将同时删除HelloWorld组件及其测试，但是在这里，我们更新消息以查找该组件中的内容： </p><br><pre> <code class="plaintext hljs">const msg = 'Welcome to Vuetify';</code> </pre> <br><p> 现在测试通过了（用<code>yarn test:unit</code>验证<code>yarn test:unit</code> ），但是仍然有很多类似的警告 </p><br><pre> <code class="plaintext hljs">[Vue warn]: Unknown custom element: &lt;v-layout&gt; - did you register the component correctly? For recursive components, make sure to provide the "name" option.</code> </pre> <br><p>  Vuetify的工作方式会添加<code>./src/plugins/vuetify.ts</code> ，将<code>./src/plugins/vuetify.ts</code>配置为应用程序的一部分。 该文件来自<code>./src/main.ts</code> 。 不幸的是，在运行单元测试时， <code>main.ts</code>被跳过了。 </p><br><p> 首先，让我们修复生成的<code>vuetify.ts</code>的错误和警告。 </p><br><p> 打开您的<code>./tsconfig.json</code>并将<code>vuetify</code>添加到<code>vuetify</code>部分： </p><br><pre> <code class="plaintext hljs"> "types": [ "webpack-env", "vuetify", "jest" ],</code> </pre> <br><p> 这告诉TypeScript编译器从何处获取Vuetify类型，。/ <code>./src/plugins/vuetify.ts</code>的错误消失了。 让我们修复一些样式警告以进行清理： </p><br><pre> <code class="plaintext hljs">import Vue from 'vue'; import Vuetify from 'vuetify/lib'; import 'vuetify/src/stylus/app.styl'; Vue.use(Vuetify, { theme: { primary: '#ee44aa', secondary: '#424242', accent: '#82B1FF', error: '#FF5252', info: '#2196F3', success: '#4CAF50', warning: '#FFC107', }, customProperties: true, iconfont: 'md', });</code> </pre> <br><p> 现在，我们需要在单元测试的上下文中加载Vuetify。 在<code>./tests/jest-setup.js</code>创建一个新文件，其内容如下： </p><br><pre> <code class="plaintext hljs">import '@/plugins/vuetify';</code> </pre> <br><p> 并更新<code>./jest.config.js</code>以加载它： </p><br><pre> <code class="plaintext hljs">module.exports = { ... setupFiles: ['./tests/jest-setup.js'], }</code> </pre> <br><p><img src="https://habrastorage.org/webt/xi/xk/-h/xixk-hz2bwqbiqo5_nlxo1ahgq8.png"></p><br><p> 测试仍然失败，但是以一种相当神秘的方式。 怎么了 </p><br><p>  <code>vuetify/lib</code>是未经处理的Vuetify原始资源，其中包括ES模块之类的东西。  Jest默认情况下仅对源代码运行转换，这意味着它将忽略<code>node_modules</code>所有<code>node_modules</code> 。 更重要的是，假设我们告诉Vue使用TypeScript，则没有将Jest配置为可转换JS。 </p><br><p> 要解决此问题，我们需要对<code>./jest.config.js</code>进行两项更改： </p><br><pre> <code class="plaintext hljs">module.exports = { ... transform: { '^.+\\.vue$': 'vue-jest', '.+\\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$': 'jest-transform-stub', '^.+\\.tsx?$': 'ts-jest', '^.+\\.jsx?$': 'babel-jest', // &lt;-- (1) }, transformIgnorePatterns: [ 'node_modules/(?!(vuetify)/)', // &lt;-- (2) ], }</code> </pre> <br><p> 在<strong>（1）中，</strong>我们告诉Jest使用Babel转换任何<code>*.js</code>或<code>*.jsx</code>文件（并且Babel由Vue Cli为我们预先配置），但是<strong>（2）是</strong>什么？  <code>transformIgnorePatterns</code>指定Jest在编译代码时将忽略的路径，并且正如我之前提到的，默认<code>node_modules</code>包括<code>node_modules</code> 。 在这里，我们用一个<code>node_modules/(?!(vuetify)/)</code>正则表达式<code>node_modules/(?!(vuetify)/)</code>替换默认值，这意味着“忽略以<code>node_modules/</code>开头的任何路径，除非后面跟随<code>vuetify</code> ”： <br><img src="https://habrastorage.org/webt/7e/z_/yi/7ez_yimfw1mdrnxxm0didej0piq.png"></p><br><p> 请注意，前两条路径如何匹配，而第三条没有。 当我们现在添加Storybook时，此技巧将派上用场。 </p><br><p> 再次运行测试... <br><img src="https://habrastorage.org/webt/p9/yy/sa/p9yysa_dproyxl5wtyovsh0p6f8.png"></p><br><p> 未知的自定义元素又回来了； 但至少它可以编译并成功运行。  Vuetify已转入其中，但我们仍然需要手动注册组件。 有几种方法可以做到这一点（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请查看其文档中的其他选项</a> ）； 我们在这里要做的是将所需的组件导入Vue的全球范围。 再次打开<code>./src/plugins/vuetify.ts</code>并将其更新为： </p><br><pre> <code class="plaintext hljs">import Vue from 'vue'; import Vuetify, { VFlex, VLayout, VContainer, VImg } from 'vuetify/lib'; import 'vuetify/src/stylus/app.styl'; Vue.use(Vuetify, { components: { VFlex, VLayout, VContainer, VImg }, theme: { primary: '#ee44aa', secondary: '#424242', accent: '#82B1FF', error: '#FF5252', info: '#2196F3', success: '#4CAF50', warning: '#FFC107', }, customProperties: true, iconfont: 'md', });</code> </pre> <br><p> 最后，测试通过： <br><img src="https://habrastorage.org/webt/5f/7s/n1/5f7sn17rr8sk9ei5pgib4x3kc_0.png"></p><br><p>  E2E测试也将失败（ <code>yarn test:e2e --headless</code> ），但这是由于<code>./tests/e2e/specs/test.js</code>寻找不再存在的字符串。  E2E测试可以在真实的浏览器中启动真实的应用程序，因此无需修复任何代码-Vuetify已在您的应用程序中全部设置。 修复<code>test.js</code>以查找新的标头： </p><br><pre> <code class="plaintext hljs">cy.contains('h1', 'Welcome to Vuetify')</code> </pre> <br><p> 它将再次变为绿色。 </p><br><p> 让我们回顾一下。 我们添加了Vuetify，修复了单元测试和e2e测试以处理新模板，并更新了Jest以转换Vuetify的源代码并加载它。 我们的应用程序功能正常，可以使用各种材料组件。 继续讲故事！ </p><br><h2 id="storybooks"> 故事书 </h2><br><p> 故事书是一个绝妙的主意：您从设计师的角度编写测试用例：从小型组件到完整的应用程序。 您可以对数据流进行推理，确保一切看起来都与UI设计器在Photoshop中的布局完全一致，并单独测试组件。 让我们添加故事书支持！ </p><br><p> 有一个Vue故事书插件，但我发现<code>sb init</code>提供了更好的默认模板，因此我们将改用它。 运行<code>npx -p @storybook/cli sb init</code> ，几分钟后，您将得到提示以运行<code>yarn storybook</code> 。 让我们做吧： <br><img src="https://habrastorage.org/webt/zl/nk/zp/zlnkzp3a8aoo-hvz9m_n8yu3moa.png"></p><br><p> 让我们添加一个新故事！ 创建具有以下内容的<code>./src/components/LoveButton.stories.ts</code> ： </p><br><pre> <code class="plaintext hljs">import { storiesOf } from '@storybook/vue'; import LoveButton from './LoveButton.vue'; storiesOf('LoveButton', module) .add('default', () =&gt; ({ components: { LoveButton }, template: `&lt;love-button love="vue"/&gt;`, }));</code> </pre> <br><p>  （请注意，如果您不想在输入故事中输入内容，可以在这里使用<code>LoveButton.stories.js</code> ）。 </p><br><p>  TypeScript将警告您有关丢失的类型的信息，您可以使用<code>yarn add -D @types/storybook__vue</code>进行修复。 </p><br><p> 现在，使用以下内容创建<code>./src/components/LoveButton.vue</code> ： </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">v-btn</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"red"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">v-icon</span></span></span><span class="hljs-tag">&gt;</span></span>favorite<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">v-icon</span></span></span><span class="hljs-tag">&gt;</span></span> {{love}} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">v-btn</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lang</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ts"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> Vue </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'vue'</span></span></span><span class="javascript">; </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">export</span></span></span><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">default</span></span></span><span class="javascript"> Vue.extend({ </span><span class="hljs-attr"><span class="javascript"><span class="hljs-attr">props</span></span></span><span class="javascript">: [</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'love'</span></span></span><span class="javascript">], }); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 故事书默认情况下会查找故事的<code>./stories</code> ，但将故事保持在距组件更近的位置通常更方便（就像我们所做的那样）。 告诉故事书在哪里寻找那些更新您的<code>./.storybook/config.js</code> ： </p><br><pre> <code class="plaintext hljs">import { configure } from '@storybook/vue'; const req = require.context('../src', true, /.stories.(j|t)s$/); function loadStories() { req.keys().forEach(filename =&gt; req(filename)); } configure(loadStories, module);</code> </pre> <br><p> 现在，再次运行<code>yarn storybook</code> ： <br><img src="https://habrastorage.org/webt/zp/et/ow/zpetowrxhyjw0fk58backjxdtj8.png"></p><br><p> 不太令人兴奋。 控制台上充满了警告： <br><img src="https://habrastorage.org/webt/8r/cr/kj/8rcrkj3uud0cc8kaaya3rr1lkho.png"></p><br><p> 不过，我们知道现在的情况。 故事书是另一个具有自己入口点的“根”上下文； 它不使用<code>main.ts</code> ，因此不会加载Vuetify，因此我们需要告诉它这样做。 更新<code>./.storybook/config.js</code> ： </p><br><pre> <code class="plaintext hljs">import { configure } from '@storybook/vue'; import '../src/plugins/vuetify'; // &lt;-- add this const req = require.context('../src', true, /.stories.(j|t)s$/); function loadStories() { req.keys().forEach(filename =&gt; req(filename)); } configure(loadStories, module);</code> </pre> <br><p> 我们将再次加载现有配置，以确保Storybook使用与真实应用相同的主题。 不幸的是， <code>yarn storybook</code>现在将失败： <br><img src="https://habrastorage.org/webt/lb/g0/nq/lbg0nq7fapzeztm7zfrzrhx8lz8.png"></p><br><p> 故事书不知道我们使用TypeScript，因此它无法加载<code>vuetify.ts</code>文件。 要解决此问题，我们需要更新Storybook自己的webpack配置。 使用以下内容创建<code>./.storybook/webpack.config.js</code> ： </p><br><pre> <code class="plaintext hljs">const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin'); module.exports = (baseConfig, env, defaultConfig) =&gt; { defaultConfig.resolve.extensions.push('.ts', '.tsx', '.vue', '.css', '.less', '.scss', '.sass', '.html') defaultConfig.module.rules.push({ test: /\.ts$/, exclude: /node_modules/, use: [ { loader: 'ts-loader', options: { appendTsSuffixTo: [/\.vue$/], transpileOnly: true }, } ], }); defaultConfig.module.rules.push({ test: /\.less$/, loaders: [ 'style-loader', 'css-loader', 'less-loader' ] }); defaultConfig.module.rules.push({ test: /\.styl$/, loader: 'style-loader!css-loader!stylus-loader' }); defaultConfig.plugins.push(new ForkTsCheckerWebpackPlugin()) return defaultConfig; };</code> </pre> <br><p> 这将加载默认配置，为TypeScript文件添加<code>ts-loader</code> ，还增加了对less和styl（Vuetify使用的）的支持。 </p><br><p> 警告仍然存在，因为我们需要注册所使用的组件。 这次让我们使用本地组件，以便您可以看到不同之处（在实际的生产应用程序中，将它们全部注册到<code>vuetify.ts</code>要简单得多）。 更新<code>./src/components/LoveButton.vue</code> ： </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">v-btn</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"red"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">v-icon</span></span></span><span class="hljs-tag">&gt;</span></span>favorite<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">v-icon</span></span></span><span class="hljs-tag">&gt;</span></span> {{love}} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">v-btn</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lang</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ts"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> Vue </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'vue'</span></span></span><span class="javascript">; </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> { VBtn, VIcon } </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'vuetify/lib'</span></span></span><span class="javascript">; </span><span class="hljs-comment"><span class="javascript"><span class="hljs-comment">// &lt;-- add this export default Vue.extend({ components: { VBtn, VIcon }, // &lt;-- and this props: ['love'], }); </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 故事书在保存时刷新： <br><img src="https://habrastorage.org/webt/jb/eb/yn/jbebynfkavexxg2og5kbdcvtaou.png"></p><br><p> 略胜一筹。 缺少什么？  Vuetify安装程序将字体css直接添加到<code>./public/index.html</code>但Storybook不使用该文件，因此我们需要添加缺少的Material Icons字体。 使用以下命令创建<code>./.storybook/preview-head.hmtl</code> （从<code>./public/index.html</code>复制）： </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"stylesheet"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"stylesheet"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://fonts.googleapis.com/css?family=Material+Icons"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  （还有其他方法可以做到这一点，例如使用CSS <code>@import</code> ）。 </p><br><p> 您需要重新启动<code>yarn storybook</code>才能正确重新渲染它： <br><img src="https://habrastorage.org/webt/ar/pn/i2/arpni2dvklu5w-cdct4fvgtl00q.png"></p><br><p> 更好但仍然低于标准：文本字体不正确，因为Vuetify希望其所有组件都嵌套在<code>v-app</code>页面样式的<code>v-app</code>中。 当然，我们不能将<code>v-app</code>添加到我们的按钮中，所以让我们来装饰故事。 更新您的<code>./src/components/LoveButton.stories.ts</code> ： </p><br><pre> <code class="plaintext hljs">import { storiesOf } from '@storybook/vue'; import { VApp, VContent } from 'vuetify/lib'; // &lt;-- add the import import LoveButton from './LoveButton.vue'; // add the decorator const appDecorator = () =&gt; { return { components: { VApp, VContent }, template: ` &lt;v-app&gt; &lt;div style="background-color: rgb(134, 212, 226); padding: 20px; width: 100%; height: 100%;"&gt; &lt;v-content&gt; &lt;story/&gt; &lt;/v-content&gt; &lt;/div&gt; &lt;/v-app&gt; `, }; }; storiesOf('LoveButton', module) .addDecorator(appDecorator) // &lt;-- decorate the stories .add('default', () =&gt; ({ components: { LoveButton }, template: `&lt;love-button love="vue"/&gt;`, }));</code> </pre> <br><p> 您必须在全局范围内注册<code>VApp</code>和<code>VContent</code> ，更新<code>./src/plugins/vuetify.ts</code> ： </p><br><pre> <code class="plaintext hljs">import Vue from 'vue'; import Vuetify, { VFlex, VLayout, VContainer, VImg, VApp, VContent } from 'vuetify/lib'; import 'vuetify/src/stylus/app.styl'; Vue.use(Vuetify, { components: { VFlex, VLayout, VContainer, VImg, VApp, VContent }, theme: { primary: '#ee44aa', secondary: '#424242', accent: '#82B1FF', error: '#FF5252', info: '#2196F3', success: '#4CAF50', warning: '#FFC107', }, customProperties: true, iconfont: 'md', });</code> </pre> <br><p> 最后，结果是惊人的： <br><img src="https://habrastorage.org/webt/gv/4a/nn/gv4ann-op0rqahdnqjpuzjqlgya.png"></p><br><h2 id="adding-storybook-testing"> 添加故事书测试 </h2><br><p> 最后，让我们确保单元测试涵盖了我们的故事。 添加所需的依赖项： <code>yarn add -D @storybook/addon-storyshots jest-vue-preprocessor babel-plugin-require-context-hook</code>并创建<code>./test/unit/storybook.spec.js</code> ： </p><br><pre> <code class="plaintext hljs">import registerRequireContextHook from 'babel-plugin-require-context-hook/register'; import initStoryshots from '@storybook/addon-storyshots'; registerRequireContextHook(); initStoryshots();</code> </pre> <br><p> 故事书配置使用<code>require.context</code>收集所有源； 该功能由webpack提供，我们需要使用<code>babel-plugin-require-context-hook</code>在Jest中替代它。 修改您的<code>./babel.config.js</code> ： </p><br><pre> <code class="plaintext hljs">module.exports = api =&gt; ({ presets: ['@vue/app'], ...(api.env('test') &amp;&amp; { plugins: ['require-context-hook'] }), });</code> </pre> <br><p> 如果babel运行用于单元测试，则在此处添加<code>require-context-hook</code>插件。 </p><br><p> 最后，我们需要允许Jest转换故事书的<code>*.vue</code>文件。 还记得<code>./jest.config.js</code>中的前瞻正则表达式吗？ 现在让我们重温一下： </p><br><pre> <code class="plaintext hljs">module.exports = { ... transformIgnorePatterns: [ 'node_modules/(?!(vuetify/|@storybook/.*\\.vue$))', ], }</code> </pre> <br><p> 请注意，我们不能仅在此处添加第二行。 请记住，这是一个忽略模式，因此，如果第一个模式忽略除Vuetify之外的所有内容，那么在Jest到达第二个正则表达式时，故事书文件已被忽略。 </p><br><p> 新测试按预期工作： <br><img src="https://habrastorage.org/webt/dn/t6/22/dnt622f3au95rkrhcfgusnkdj_e.png"></p><br><p> 该测试将运行您的所有故事，并根据<code>./tests/unit/__snapshots__/</code>中的本地快照对其进行验证。 要查看实际效果，可以从按钮组件中删除<code>&lt;v-icon&gt;favorite&lt;/v-icon&gt;</code>并重新运行测试以查看失败： <br><img src="https://habrastorage.org/webt/rf/oh/09/rfoh09qhni7mvf_jzsj_dmzuf_e.png"></p><br><p>  <code>yarn test:unit -u</code>将为新的按钮布局更新快照。 </p><br><h2 id="recap"> 回顾 </h2><br><p> 在本教程中，我们学习了如何在启用TypeScript的情况下创建新的Vue应用程序。 如何使用Material UI组件添加Vuetify库。 我们确保我们的单元测试和e2e测试按预期进行。 最后，我们增加了对故事书的支持，创建了一个示例故事，并确保我们的单元测试涵盖了UI更改。 </p><br><h2 id="closing-thoughts"> 总结思想 </h2><br><p>  JS是一个瞬息万变的世界，事物不断变化，新的格局出现，旧的事物被遗忘。 本教程可能仅在几个月后就过时了，因此这里有一些有用的提示。 </p><br><p> 了解您的工具。 可以从堆栈溢出中复制粘贴行，直到代码可以正常工作，但是您<strong>必须</strong>研究为什么更改以后才能起作用。 阅读文档，并确保您了解更改的确切含义。 </p><br><p> 如果您有部分工作要做，请提交。 即使这项工作仍在进行中，如果您所做的进一步更改会破坏某些内容，您也可以将其还原。 </p><br><p> 实验！ 如果某些方法不符合您的想法，而文档另有说明，请尝试！ 前端世界主要是开源的，因此请深入研究第三方资源，看看是否可以从内部修改您的仪器以添加调试日志记录。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN438354/">https://habr.com/ru/post/zh-CN438354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN438342/index.html">为什么在Ghost Recon Wildlands中欺骗友好的AI</a></li>
<li><a href="../zh-CN438346/index.html">他们是如何做到的？ 加密货币匿名化技术概述</a></li>
<li><a href="../zh-CN438348/index.html">如何在9岁时独立学习编程</a></li>
<li><a href="../zh-CN438350/index.html">有关隐藏摄像机和间谍设备的专业搜索的完整指南</a></li>
<li><a href="../zh-CN438352/index.html">月球表面第一米处“ Yutu-2”流动站下降的视频。 在月球上睡了两个星期</a></li>
<li><a href="../zh-CN438356/index.html">SQL Server数据仓库快速通道（DWFT）认证的体系结构：含义和工作方式</a></li>
<li><a href="../zh-CN438358/index.html">前美国国家安全局特工在阿联酋监视受害者的iPhone</a></li>
<li><a href="../zh-CN438362/index.html">我们如何将服务的配置从XML转换为YAML</a></li>
<li><a href="../zh-CN438364/index.html">复制世界上第一个数字语音加密器</a></li>
<li><a href="../zh-CN438366/index.html">Azure Cloud MFA中OATH硬件令牌功能的另一篇评论</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>