<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔚 🗑️ ☢️ Wiederherstellen von Fotos mithilfe neuronaler Netze 😘 👼🏿 🏊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits, ich arbeite als Forschungsprogrammierer im Computer Vision Team der Mail.ru Group. Für den diesjährigen Tag des Sieges haben wir bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wiederherstellen von Fotos mithilfe neuronaler Netze</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/453872/"><img src="https://habrastorage.org/getpro/habr/post_images/333/44a/c78/33344ac788b63200841180799417f934.jpg"><br><br>  Hallo allerseits, ich arbeite als Forschungsprogrammierer im Computer Vision Team der Mail.ru Group.  Für den diesjährigen Tag des Sieges haben wir beschlossen, ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt zur Restaurierung von Militärfotografien durchzuführen</a> .  Was ist Fotorestaurierung?  Es besteht aus drei Stufen: <br><br><ul><li>  wir finden alle Bildfehler: Brüche, Kratzer, Löcher; <br></li><li>  Übermalen Sie die gefundenen Fehler anhand der Pixelwerte um sie herum. <br></li><li>  kolorieren Sie das Bild. <br></li></ul><br>  In diesem Artikel werde ich jede Phase der Wiederherstellung im Detail durchgehen und Ihnen erklären, wie und wo wir Daten aufgenommen haben, welche Netzwerke wir gelernt haben, was wir getan haben, auf welche Rechen wir getreten sind. <br><a name="habracut"></a><br><h1>  Fehlersuche </h1><br>  Wir möchten alle Pixel im Zusammenhang mit Fehlern im hochgeladenen Foto finden.  Zunächst müssen wir verstehen, welche Art von Fotos der Kriegsjahre die Menschen hochladen werden.  Wir wandten uns an die Organisatoren des Immortal Regiment-Projekts, die Daten mit uns teilten.  Nach der Analyse haben wir festgestellt, dass Personen häufig Einzel- oder Gruppenporträts hochladen, die eine mäßige oder große Anzahl von Fehlern aufweisen. <br><br>  Dann war es notwendig, eine Trainingsprobe zu sammeln.  Das Trainingsmuster für die Segmentierungsaufgabe ist ein Bild und eine Maske, auf der alle Fehler markiert sind.  Am einfachsten ist es, den Markern Fotos zu geben.  Natürlich sind die Leute gut darin, Fehler zu finden, aber das Problem ist, dass das Markup ein sehr langer Prozess ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d5d/a19/892/d5da1989220f10bcaac3944d27d64276.png"><br><br>  Das Markieren von Pixeln im Zusammenhang mit Fehlern in einem Foto kann von einer Stunde bis zu einem ganzen Arbeitstag dauern. Daher ist es schwierig, in wenigen Wochen eine Probe von mehr als 100 Fotos zu sammeln.  Deshalb haben wir versucht, unsere Daten irgendwie zu ergänzen und selbst Fehler zu schreiben: Wir haben ein sauberes Foto gemacht, künstliche Fehler darauf angebracht und eine Maske bekommen, die uns zeigt, welche Teile des Bildes beschädigt wurden.  Der Hauptteil unserer Trainingsprobe bestand aus 79 manuell markierten Fotos, von denen 11 auf die Testprobe übertragen wurden. <br><br>  Der beliebteste Ansatz für das Segmentierungsproblem: Nehmen Sie Unet mit einem vorab trainierten Encoder und minimieren Sie die Menge <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi><mi>c</mi><mi>e</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.854ex" height="2.057ex" viewBox="0 -780.1 1659.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-42" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-63" x="759" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-65" x="1193" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>B</mi><mi>c</mi><mi>e</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> Bce </script>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">binäre Kreuzentropie</a> ) und <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>D</mi><mi>I</mi><mi>C</mi><mi>E</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.638ex" height="2.057ex" viewBox="0 -780.1 2858 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-44" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-49" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-43" x="1333" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-45" x="2093" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi><mi>I</mi><mi>C</mi><mi>E</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> DICE </script>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sørensen - Würfelkoeffizient</a> ). <br><br>  Welche Probleme treten bei diesem Ansatz beim Problem der Segmentierung von Fehlern auf? <br><br><ul><li>  Auch wenn es uns so vorkommt, als ob das Foto viele Mängel aufweist, dass es sehr schmutzig und zeitlich sehr zerrissen ist, ist der von Fehlern eingenommene Bereich immer noch viel kleiner als der unbeschädigte Teil des Bildes.  Um dieses Problem zu lösen, können Sie das Gewicht der positiven Klasse in erhöhen <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi><mi>c</mi><mi>e</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.854ex" height="2.057ex" viewBox="0 -780.1 1659.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-42" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-63" x="759" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-65" x="1193" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>B</mi><mi>c</mi><mi>e</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> Bce </script>  und das optimale Gewicht ist das Verhältnis der Anzahl aller reinen Pixel zur Anzahl der zu den Defekten gehörenden Pixel. <br></li><li>  Das zweite Problem ist, dass wir viele Positionsinformationen verlieren, wenn wir Unet sofort mit einem vorab trainierten Encoder verwenden, beispielsweise Albunet-18.  Die erste Schicht von Albunet-18 besteht aus einer Faltung mit einem Kern von 5 und einem Schritt von zwei.  Dadurch kann das Netzwerk schnell arbeiten.  Wir haben die Betriebszeit des Netzwerks für eine bessere Lokalisierung von Fehlern geopfert: Wir haben das maximale Pooling nach der ersten Schicht entfernt, den Schritt auf 1 reduziert und den Faltungskern auf 3 reduziert. <br></li><li>  Wenn wir beispielsweise mit kleinen Bildern arbeiten und ein Bild auf 256 x 256 oder 512 x 512 komprimieren, verschwinden kleine Fehler aufgrund der Interpolation einfach.  Daher müssen Sie mit einem großen Bild arbeiten.  Jetzt in der Produktion segmentieren wir Defekte in Fotografien von 1024 x 1024. Daher war es notwendig, das neuronale Netzwerk in einer großen Anzahl großer Bilder zu trainieren.  Aus diesem Grund gibt es Probleme mit der geringen Größe des Stapels auf einer Grafikkarte. <br></li><li>  Während des Trainings haben wir ungefähr 20 Bilder auf einer Karte.  Aus diesem Grund ist die Schätzung des Mittelwerts und der Varianz in den BatchNorm-Ebenen ungenau.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In-Place-BatchNorm</a> hilft uns bei der Lösung dieses Problems, das zum einen Speicher spart und zum anderen eine Version von Synchronized BatchNorm enthält, mit der Statistiken zwischen allen Karten synchronisiert werden.  Jetzt betrachten wir den Durchschnitt und die Varianz nicht mit 20 Bildern auf einer Karte, sondern mit 80 Bildern von 4 Karten.  Dies verbessert die Netzwerkkonvergenz. <br></li></ul><br>  Am Ende Gewichtszunahme <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi><mi>c</mi><mi>e</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.854ex" height="2.057ex" viewBox="0 -780.1 1659.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-42" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-63" x="759" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-65" x="1193" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>B</mi><mi>c</mi><mi>e</mi></math></span></span><script type="math/tex" id="MathJax-Element-4"> Bce </script>  Durch Ändern der Architektur und Verwenden von In-Place BatchNorm haben wir begonnen, nach Fehlern im Foto zu suchen.  Aber billig könnten Sie es noch ein bisschen besser machen, indem Sie Test Time Augmentation hinzufügen.  Wir können das Netzwerk einmal im Eingabebild ausführen, es dann spiegeln und das Netzwerk erneut ausführen. Dies kann uns helfen, kleine Fehler zu finden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c75/95b/702/c7595b702dcb921dac612b0218ce13e4.png"><br><br>  Infolgedessen konvergierte unser Netzwerk in 18 Stunden auf vier GeForce 1080Ti.  Inferenz dauert 290 ms.  Es stellt sich lange genug heraus, aber dies ist der Preis dafür, dass wir gut nach kleinen Mängeln suchen.  Validierung <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>D</mi><mi>I</mi><mi>C</mi><mi>E</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.638ex" height="2.057ex" viewBox="0 -780.1 2858 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-44" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-49" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-43" x="1333" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-45" x="2093" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi><mi>I</mi><mi>C</mi><mi>E</mi></math></span></span><script type="math/tex" id="MathJax-Element-5"> DICE </script>  gleich 0,35 und <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>R</mi><mi>O</mi><mi>C</mi><mi>A</mi><mi>U</mi><mi>C</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.596ex" height="2.057ex" viewBox="0 -780.1 4562 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-52" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-4F" x="759" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-43" x="1523" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-41" x="2283" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-55" x="3034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;usg=ALkJrhhDWmkYEg4zmTTrsbni0BpTZPynWQ#MJMATHI-43" x="3801" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi><mi>O</mi><mi>C</mi><mi>A</mi><mi>U</mi><mi>C</mi></math></span></span><script type="math/tex" id="MathJax-Element-6"> ROCAUC </script>  - 0,93. <br><br><h1>  Fragmentwiederherstellung </h1><br>  Unet hat uns geholfen, dieses Problem wieder zu lösen.  Zur Eingabe gaben wir ihm das Originalbild und eine Maske, auf der wir saubere Räume mit Einheiten markieren, sowie die Pixel, die wir mit Nullen übermalen möchten.  Wir haben die Daten wie folgt gesammelt: Wir haben aus dem Internet einen großen Datensatz mit Bildern, beispielsweise OpenImagesV4, und künstlich hinzugefügten Fehlern entnommen, deren Form denen des realen Lebens ähnelt.  Danach trainierten sie das Netzwerk, um die fehlenden Teile zu reparieren. <br><br>  Wie können wir Unet für diese Aufgabe ändern? <br><br>  Sie können die Teilfaltung anstelle der üblichen Faltung verwenden.  Ihre Idee ist, dass wir beim Reduzieren eines Bildbereichs mit einem Kernel die Pixelfehler, die sich auf Fehler beziehen, nicht berücksichtigen.  Dies hilft, das Bild genauer zu machen.  Ein Beispiel aus einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NVIDIA-Artikel</a> .  Im zentralen Bild verwendeten sie Unet mit der üblichen Faltung und rechts - mit Teilfaltung: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a5/280/a4b/5a5280a4be71695d16ab08af876c5d23.png"><br><br>  Wir haben das Netzwerk 5 Tage lang trainiert.  Am letzten Tag haben wir BatchNorm eingefroren. Dies hat dazu beigetragen, dass die Ränder des gemalten Teils des Bildes weniger auffällig sind. <br><br>  Das Netzwerk verarbeitet ein Bild von 512 x 512 in 50 ms.  Das Validierungs-PSNR beträgt 26,4.  Metriken können in dieser Aufgabe jedoch nicht unbedingt vertraut werden.  Aus diesem Grund haben wir zunächst mehrere gute Modelle für unsere Daten erstellt, die Ergebnisse anonymisiert und dann für diejenigen gestimmt, die uns besser gefallen haben.  Also haben wir das endgültige Modell gewählt. <br><br>  Ich erwähnte, dass wir sauberen Bildern künstlich Fehler hinzugefügt haben.  Während des Trainings müssen Sie die maximale Größe der überlagerten Fehler sorgfältig überwachen, da das Netzwerk bei sehr großen Fehlern, die das Netzwerk im Lernprozess noch nie gesehen hat, wild phantasiert und ein absolut nicht anwendbares Ergebnis liefert.  Wenn Sie also große Fehler übermalen müssen, wenden Sie während des Trainings auch große Fehler an. <br><br>  Hier ist ein Beispiel für den Algorithmus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/abd/6cb/c8c/abd6cbc8c05396042bf83c00516b630e.png"><br><br><h1>  Färben </h1><br>  Wir haben die Fehler segmentiert und bemalt, der dritte Schritt ist die Rekonstruktion der Farbe.  Ich möchte Sie daran erinnern, dass es auf den Fotografien des "Unsterblichen Regiments" viele Einzel- oder Gruppenporträts gibt.  Und wir wollten, dass unser Netzwerk gut mit ihnen zusammenarbeitet.  Wir haben uns für eine eigene Kolorierung entschieden, da keiner der uns bekannten Dienste schnell und gut Porträts malt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/015/bce/bf1/015bcebf15ef1ee069fdf08f16e00542.png"><br><br>  GitHub hat ein beliebtes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> zum Ausmalen von Fotos.  Im Durchschnitt macht er diesen Job gut, aber er hat mehrere Probleme.  Zum Beispiel malt er gerne Kleidung in Blau.  Deshalb haben wir es auch abgelehnt. <br><br>  Also beschlossen wir, ein neuronales Netzwerk für die Kolorierung zu erstellen.  Die naheliegendste Idee: Nehmen Sie ein Schwarzweißbild auf und sagen Sie drei Kanäle voraus: Rot, Grün und Blau.  Aber im Allgemeinen können wir unsere Arbeit vereinfachen.  Wir können nicht mit der RGB-Darstellung der Farbe arbeiten, sondern mit der YCbCr-Darstellung.  Komponente Y ist die Helligkeit (Luma).  Das heruntergeladene Schwarzweißbild ist der Y-Kanal, wir werden ihn wiederverwenden.  Es blieb Cb und Cr vorherzusagen: Cb ist der Unterschied in blauer Farbe und Helligkeit, und Cr ist der Unterschied in roter Farbe und Helligkeit. <br><br><img src="https://habrastorage.org/webt/k8/ke/l_/k8kel_xrjco6euolh8ypkchjm8g.jpeg"><br><br>  Warum haben wir die YCbCr-Ansicht gewählt?  Das menschliche Auge ist anfälliger für Helligkeitsänderungen als für Farbänderungen.  Daher verwenden wir die Y-Komponente (Helligkeit), für die das Auge anfangs gut empfänglich ist, wieder und sagen Cb und Cr voraus, bei denen wir etwas mehr Fehler machen können, da die Menschen weniger „falsche“ Farben bemerken.  Diese Funktion wurde zu Beginn des Farbfernsehens aktiv genutzt, als die Kanalbandbreite nicht ausreichte, um alle Farben vollständig zu übertragen.  Das Bild wurde auf YCbCr übertragen, unverändert auf die Y-Komponente übertragen und Cb und Cr wurden zweimal komprimiert. <br><br><h1>  So montieren Sie die Grundlinie </h1><br>  Sie können Unet erneut mit einem vorab trainierten Encoder verwenden und den L1-Verlust zwischen dem realen CbCr und dem vorhergesagten minimieren.  Wir möchten Porträts einfärben, daher müssen wir zusätzlich zu den Fotos von OpenImages Fotos hinzufügen, die für unsere Aufgabe spezifisch sind. <br><br>  Wo kann ich Farbfotos von Menschen in Militäruniform bekommen?  Es gibt Leute im Internet, die alte Fotos als Hobby oder auf Bestellung malen.  Sie tun dies sehr sorgfältig und versuchen, alle Nuancen vollständig einzuhalten.  Sie färben die Uniform, Schulterklappen und Medaillen und wenden sich Archivmaterial zu, damit das Ergebnis ihrer Arbeit vertrauenswürdig ist.  Insgesamt haben wir 200 handgemalte Fotos verwendet.  Die zweite nützliche Datenquelle ist der Standort der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Roten Armee</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeiter und Bauern</a> .  Einer seiner Schöpfer wurde während des Großen Vaterländischen Krieges in fast allen möglichen Varianten einer Militäruniform fotografiert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f72/999/7d9/f729997d9fd02755fd95967ff09d27ca.png"><br><br>  Auf einigen Fotografien wiederholte er die Posen von Menschen aus berühmten Archivfotos.  Es ist besonders gut, dass er auf einem weißen Hintergrund aufgenommen hat. Dadurch konnten wir die Daten sehr gut erweitern und dem Hintergrund verschiedene natürliche Objekte hinzufügen.  Wir haben auch gewöhnliche moderne Porträts von Menschen verwendet, die durch Abzeichen und andere Attribute von Kriegskleidung ergänzt wurden. <br><br>  Wir haben AlbuNet-50 trainiert - dies ist Unet, in dem AlbuNet-50 als Encoder verwendet wird.  Das Netzwerk lieferte adäquate Ergebnisse: Die Haut ist rosa, die Augen sind grau-blau, die Schultergurte sind gelblich.  Das Problem ist aber, dass sie die Bilder mit Flecken bemalt hat.  Dies liegt an der Tatsache, dass es aus Sicht des L1-Fehlers manchmal rentabler ist, nichts zu tun, als zu versuchen, eine Farbe vorherzusagen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/435/4a9/63c/4354a963c4cd2789c434002e44fdda26.png"><br>  <i>Wir vergleichen unser Ergebnis mit einem Foto von Ground Truth - manuelle Kolorierung des Künstlers unter dem Spitznamen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klimbim</a></i> <br><br>  Wie kann man dieses Problem lösen?  Wir brauchen einen Diskriminator: ein neuronales Netzwerk, an das wir Bilder für die Eingabe liefern und das sagt, wie realistisch dieses Bild aussieht.  Unten ist ein Foto handgemalt und das zweite von einem neuronalen Netzwerk.  Welches denkst du? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/253/86a/abd/25386aabd9080c14daf71b60d9968453.png"><br><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Das linke Foto wird manuell gemalt. <br></div></div><br>  Als Diskriminator verwenden wir den Diskriminator aus dem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Self-Attention GAN</a> .  Dies ist ein kleines Faltungsnetzwerk, in dessen letzten Schichten die sogenannte Selbstaufmerksamkeit eingebaut ist.  Es ermöglicht Ihnen, mehr auf die Bilddetails zu achten.  Wir verwenden auch die spektrale Normalisierung.  Die genaue Erklärung und Motivation finden Sie im Artikel.  Wir haben ein Netzwerk mit einer Kombination aus L1-Verlust und dem vom Diskriminator zurückgegebenen Fehler trainiert.  Jetzt malt das Netzwerk die Details des Bildes besser und der Hintergrund ist konsistenter.  Ein weiteres Beispiel: Links ist das Ergebnis des Netzwerks, das nur mit L1-Verlust trainiert wurde, rechts - mit L1-Verlust und einem Diskriminatorfehler. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa4/724/ada/aa4724ada4e0bbdc52dbcaadd5bb3fdc.png"><br><br>  Bei vier Geforce 1080Ti dauerte das Training zwei Tage.  Das Netzwerk hat in 30 ms im Bild 512 x 512 gearbeitet. Die Validierungs-MSE betrug 34,4.  Wie beim Inpainting-Problem können Metriken nicht vollständig als vertrauenswürdig eingestuft werden.  Daher haben wir 6 Modelle ausgewählt, die die besten Metriken für die Validierung hatten, und blind für das beste Modell gestimmt. <br><br>  Nachdem wir das Modell in der Produktion eingeführt hatten, setzten wir die Experimente fort und kamen zu dem Schluss, dass es besser ist, nicht den L1-Verlust pro Pixel, sondern den Wahrnehmungsverlust zu minimieren.  Um dies zu berechnen, müssen Sie die Netzwerkvorhersage und das Quellfoto über das VGG-16-Netzwerk ausführen, die Attributkarten auf den unteren Ebenen verwenden und sie gemäß MSE vergleichen.  Dieser Ansatz malt mehr Bereiche und hilft, ein farbenfroheres Bild zu erhalten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db9/303/509/db93035094c4906cf82c246151432cbc.jpg"><br><br><h1>  Schlussfolgerungen und Schlussfolgerung </h1><br>  Unet ist ein cooles Modell.  Beim ersten Segmentierungsproblem ist beim Training und Arbeiten mit hochauflösenden Bildern ein Problem aufgetreten. Daher verwenden wir In-Place BatchNorm.  Bei der zweiten Aufgabe (Inpainting) haben wir anstelle der üblichen Faltung die Teilfaltung verwendet, um bessere Ergebnisse zu erzielen.  Im Kolorierungsproblem für Unet haben wir ein kleines Diskriminatornetzwerk hinzugefügt, das den Generator für ein unrealistisch aussehendes Bild bestraft und Wahrnehmungsverlust verwendet. <br><br>  Die zweite Schlussfolgerung ist, dass Accessoren wichtig sind.  Und das nicht nur beim Markieren von Bildern vor dem Training, sondern auch zur Validierung des Endergebnisses, denn bei Problemen mit Lackfehlern oder Kolorierungen müssen Sie das Ergebnis noch mit Hilfe einer Person validieren.  Wir geben dem Benutzer drei Fotos: das Original mit den entfernten Fehlern, das mit den entfernten Fehlern eingefärbt ist, und nur das eingefärbte Foto, falls der Algorithmus zum Auffinden und Malen von Fehlern falsch ist. <br><br>  Wir haben einige Fotos des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Military Album-</a> Projekts gemacht und sie mit unseren neuronalen Netzen verarbeitet.  Hier sind die erzielten Ergebnisse: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a51/ade/15e/a51ade15e9cee54ec8269dc1e22df0af.jpg"><br><br>  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> können Sie sie in der Originalauflösung und in jeder Phase der Verarbeitung sehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453872/">https://habr.com/ru/post/de453872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453862/index.html">Warum sollten Sie Pathlib verwenden</a></li>
<li><a href="../de453864/index.html">Das Verwenden einer Maus und einer Tastatur auf Konsolen ist Betrug?</a></li>
<li><a href="../de453866/index.html">API-Anfrage mit React Hooks, HOC oder Render Prop</a></li>
<li><a href="../de453868/index.html">Berühren Sie den Mini-Schalter mit Glasscheibe am nRF52832</a></li>
<li><a href="../de453870/index.html">Wir schreiben Reverse socks5 Proxy auf Powershell. Teil 1</a></li>
<li><a href="../de453874/index.html">Vom russischen Roulette zum sicheren LOTO: So schützen Sie das Personal des Rechenzentrums</a></li>
<li><a href="../de453876/index.html">Wie bei Yandex.Practicum gewann das Front-End-Desync: eine akrobatische Nummer mit Redux-Saga, postMessage und Jupyter</a></li>
<li><a href="../de453882/index.html">Ein guter Leitfaden zum Beruf eines Lösungsarchitekten (+ Liste nützlicher Links)</a></li>
<li><a href="../de453884/index.html">HYIP Kamera oder DSLR Ersatz?</a></li>
<li><a href="../de453886/index.html">Programm funktioniert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>