<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óÄÔ∏è üôéüèΩ üîô Winkel: ngx-translate. Verbesserung der Infrastruktur mit Webpack üåÜ üßú üéë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. 


 Es ist Zeit f√ºr ngx-translate Life Hacks. Anfangs habe ich 3 Teile geplant, aber weil der zweite Teil eigentlich nicht sehr informativ ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Winkel: ngx-translate. Verbesserung der Infrastruktur mit Webpack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413787/"><p>  Guten Tag. </p><br><p>  Es ist Zeit f√ºr ngx-translate Life Hacks.  Anfangs habe ich 3 Teile geplant, aber weil der zweite Teil eigentlich nicht sehr informativ ist, werde ich versuchen, den zweiten Teil so kurz wie m√∂glich zusammenzufassen. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> </p><br><p> <code>AppTranslateLoader</code> Sie <code>AppTranslateLoader</code> in Betracht, um <code>TranslateHttpLoader</code> zu ersetzen.  Unser <code>AppTranslateLoader</code> achtet zun√§chst auf die Browsersprache und enth√§lt Fallback-Logik, importiert MomentJs-Lokalisierungen und l√§dt √ºber APP_INITIALIZER.  Als Ergebnis der Kombination von zwei Teilen von Life-Hacks werden wir uns auf dem Weg mit der Schaffung einer bequemen und flexiblen Lokalisierungsinfrastruktur im Projekt befassen. </p><br><p>  Das Hauptziel ist nicht <code>AppTranslateLoader</code> (weil es recht einfach und nicht schwer zu <code>AppTranslateLoader</code> ist), sondern die Schaffung einer Infrastruktur. </p><br><p>  Ich habe versucht, so zug√§nglich wie m√∂glich zu schreiben, aber da der Artikel viele Dinge enth√§lt, die detaillierter beschrieben werden k√∂nnen, wird dies viel Zeit in Anspruch nehmen und f√ºr diejenigen, die bereits wissen, wie es geht, nicht interessant sein.  Daher war der Artikel f√ºr Anf√§nger nicht sehr freundlich.  Auf der anderen Seite gibt es am Ende einen Link zum Beispiel prodg. </p><a name="habracut"></a><br><p>  Bevor ich anfange, m√∂chte ich darauf hinweisen, dass es nicht nur m√∂glich ist, Sprachen √ºber http herunterzuladen, sondern auch einen Loader so zu schreiben, dass er die erforderlichen Sprachen in der Assembly-Phase in unser Bundle l√§dt.  Sie m√ºssen also keine Loader √ºber http hinzuf√ºgen. Bei diesem Ansatz m√ºssen Sie die Anwendung jedoch jedes Mal neu erstellen, wenn wir unsere Dateien mit Lokalisierungen √§ndern. Dies kann auch die Gr√∂√üe des .js-Bundles erheblich erh√∂hen. </p><br><pre> <code class="hljs pgsql">// webpack-translate-loader.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TranslateLoader } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@ngx-translate/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> WebpackTranslateLoader implements TranslateLoader { getTranslation(lang: string): Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.fromPromise(<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(`../assets/i18n/${lang}.json`)); } }</code> </pre> <br><p>  Wenn die IDE auf <code>System</code> schw√∂rt <code>System</code> m√ºssen Sie sie zu typings.d.ts hinzuf√ºgen: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>; interface <span class="hljs-keyword"><span class="hljs-keyword">System</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(request: string): Promise&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt;; }</code> </pre> <br><p>  Jetzt k√∂nnen wir <code>WebpackTranslateLoader</code> in app.module verwenden: </p><br><pre> <code class="hljs powershell">@NgModule({ bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], imports: [ <span class="hljs-type"><span class="hljs-type">TranslateModule.forRoot</span></span>({ <span class="hljs-type"><span class="hljs-type">loader</span></span>: { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">TranslateLoader</span></span>, <span class="hljs-type"><span class="hljs-type">useClass</span></span>: <span class="hljs-type"><span class="hljs-type">WebpackTranslateLoader</span></span> } }) ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <cut></cut><br><h4 id="apptranslateloader">  AppTranslateLoader </h4><br><p>  Beginnen wir <code>AppTranslateLoader</code> mit dem Schreiben unseres <code>AppTranslateLoader</code> .  Zun√§chst m√∂chte ich einige Probleme identifizieren, die mit dem Standard- <code>TranslateHttpLoader</code> : </p><br><ul><li><p>  <strong>Flackern √ºbersetzen.</strong>  <code>TranslateHttpLoader</code> wei√ü nicht, wie es als Teil des Anwendungsinitialisierungsprozesses ausgef√ºhrt werden soll, und wir k√∂nnen in eine Situation geraten, in der wir nach der Initialisierung feststellen, dass wir den Platz f√ºr die richtigen Beschriftungen in der Anwendung haben - die Schl√ºssel (MY_BUTTON_KEY ist der Platz f√ºr Meine Schaltfl√§che), die sich nach einem Moment in den richtigen Text √§ndern. </p><br></li><li><p>  <strong>Termine</strong>  Es w√§re sch√∂n, einen Dienst zu haben, der die Lokalisierung von Daten √§ndert.  Wenn Sie Text lokalisieren m√∂chten, m√ºssen Sie sich h√∂chstwahrscheinlich um die Lokalisierung von Datum, Uhrzeit usw. k√ºmmern.  Sie k√∂nnen momentJs oder die in Angular integrierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">i18n-</a> L√∂sung verwenden.  Beide L√∂sungen sind gut und verf√ºgen √ºber Angular 2+ -Pipes zum Formatieren in Ansichten. </p><br></li><li>  <strong>Caching.</strong>  Mit <code>TranslateHttpLoader</code> m√ºssen Sie Ihren FE-Server so konfigurieren, dass Ihre JSON-Bundles korrekt zwischengespeichert werden.  Andernfalls sehen Benutzer alte Versionen der Lokalisierung, schlimmer noch, sie sehen Lokalisierungsschl√ºssel (wenn nach dem Zwischenspeichern durch den Benutzer neue hinzugef√ºgt wurden).  Ich m√∂chte mich nicht jedes Mal darum k√ºmmern, wenn ich auf einem neuen Server bereitstelle, wenn das Caching eingerichtet wird.  Also werden wir Webpack dazu bringen, alles f√ºr uns zu tun, so wie es f√ºr .js-Bundles tut. </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppTranslateLoader-Entwurf</a> </p><cut></cut><br><h5 id="resheniya-problem">  L√∂sungen f√ºr Probleme: </h5><br><h6 id="1-problema-translate-flickering---ispolzovat-apptranslateloaderv-ramkah-app_initializer">  1. <code>AppTranslateLoader</code> √ºbersetzen - <code>AppTranslateLoader</code> als Teil von <code>APP_INITIALIZER</code> </h6><br><p>  APP_INITIALIZER war auch aktiv an einem Artikel √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aktualisierungstoken beteiligt</a> , wenn auch nicht geschmackvoll √ºber Initialisierer. Ich empfehle Ihnen, den Artikel zu lesen, obwohl es sich um Aktualisierungstoken handelt.  Tats√§chlich ist die Entscheidung, Initialisierer zu verwenden, sehr offensichtlich (f√ºr diejenigen, die einen Initialisierer haben), aber ich hoffe trotzdem, dass es Leute gibt, die sich als n√ºtzlich erweisen: </p><br><pre> <code class="hljs powershell">//app.module.ts export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translationLoader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loader: AppTranslateLoader)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; loader.loadTranslation(); } @NgModule({ bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], providers: [ { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">APP_INITIALIZER</span></span>, <span class="hljs-type"><span class="hljs-type">useFactory</span></span>: <span class="hljs-type"><span class="hljs-type">translationLoader</span></span>, <span class="hljs-type"><span class="hljs-type">deps</span></span>: [<span class="hljs-type"><span class="hljs-type">AppTranslateLoader</span></span>], <span class="hljs-type"><span class="hljs-type">multi</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> } ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <br><h6 id="2-problema-dat-prosto-budem-pereklyuchat-yazyk-v-momentjs-vmeste-c-ngx-tranlate">  2. Das Problem der Daten.  Wir werden die Sprache in K√ºrze zusammen mit ngx-tranlate wechseln. </h6><br><p>  Hier ist alles einfach - nachdem json mit Lokalisierung geladen wurde, schalten wir die Lokalisierung einfach auf momentJs (oder i18n) um. </p><br><p>  Es ist auch erw√§hnenswert, dass momentJs wie i18n Lokalisierungen separat importieren k√∂nnen, momentJs k√∂nnen auch ein Bundle importieren, aber das gesamte B√ºndel von Lokalisierungen ben√∂tigt ~ 260 KB, und Sie ben√∂tigen nur 2 davon. </p><br><p>  In diesem Fall k√∂nnen Sie nur zwei davon direkt in die Datei importieren, in der <code>AppTranslateLoader</code> deklariert ist. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'moment/locale/en-gb'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'moment/locale/ru'</span></span>;</code> </pre> <br><p>  Jetzt befinden sich die Lokalisierungen en-gb und ru im js-Anwendungspaket.  In <code>AppTranslateLoader</code> k√∂nnen Sie einen frisch geladenen Sprachhandler hinzuf√ºgen: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> Class AppTranslateLoader { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .... private onLangLoaded(newLang: string) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang !== newLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.resetLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang = newLang; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang = newLang; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO:       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  en  ru,  momentJs   en. moment().locale(newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  .  momentJs localStorage.setItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageKey, newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ls <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.complete(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -      . }</code> </pre> <br><p>  !!!  Dieser Handler hat einen Nachteil: Wenn in unserem Projekt nur die en-Lokalisierung f√ºr ngx-translate bereitgestellt wird, aber zum Beispiel momentan oder en oder gb verwendet werden muss, muss die Logik des Handlers erweitert werden, oder es sollte auch die en-Lokalisierung von en-gb bereitgestellt werden ngx-translate. </p><br><p>  !!!  Im Moment mit // TODO: Wir k√∂nnen ein Webpack-Plugin schreiben. Wir werden sp√§ter einige Plugins in Betracht ziehen, aber das habe ich noch nicht. </p><br><p>  Sie fragen, warum es unm√∂glich ist, Lokalisierungen von Datum und Uhrzeit sowie Lokalisierungen von Text in die Benutzeroberfl√§che zu laden (dynamisch √ºber HTTP)?  Dies liegt daran, dass Datumslokalisierungen ihre eigene Logik enthalten und daher als <a href="">Javascript-</a> Code dargestellt werden. </p><br><p>  Trotzdem gibt es eine M√∂glichkeit, solche Lokalisierungen zu laden, indem Sie einen kleinen "schmutzigen" Code schreiben.  Ich verwende diesen Code nicht in der Produktion, aber die zweite Lokalisierung in meinem Bundle st√∂rt mich nicht.  Wenn Sie jedoch viele Lokalisierungen haben, m√∂chten Sie diese dynamisch und nicht sehr sicher laden. Beachten Sie Folgendes: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadAngularCulture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locale</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> angularLocaleText = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(`assets/angular-locales/${locale}.js`).toPromise(); <span class="hljs-comment"><span class="hljs-comment">// extracting the part of the js code before the data, // and i didn't need the plural so i just replace plural by null. const startPos = angularLocaleText.indexOf('export default '); angularLocaleText = 'return ' + angularLocaleText.substring(startPos + 15).replace('plural', null); // The trick is here : to read cldr data, i use a function const f = new Function(angularLocaleText); const angularLocale = f(); // console.log(angularLocale); // And now, just registrer the object you just created with the function registerLocaleData(angularLocale); }</span></span></code> </pre> <br><p>  Das letzte Mal habe ich diese Methode in Angular 4 getestet. H√∂chstwahrscheinlich funktioniert sie jetzt. </p><br><p>  Leider funktioniert ein solcher Dirty-Life-Hack bei c momentJs nicht (nur Angular-Lokalisierung).  Zumindest konnte ich keinen Weg finden, dies zu tun, aber wenn Sie ein sehr b√§rtiger Hacker-Programmierer sind, werde ich mich freuen, die L√∂sung in den Kommentaren zu sehen. </p><br><h6 id="3-keshirovanie-podobno-sborke-js-bandla-mozhno-dobavit-k-imeni-json-bandla-hesh">  3. Caching.  √Ñhnlich wie beim Erstellen eines .js-Bundles k√∂nnen Sie dem Namen des .json-Bundles einen Hash hinzuf√ºgen. </h6><br><p>  Es h√§ngt alles davon ab, wie genau Sie alle json'es in einer Datei sammeln. Vielleicht haben Sie einfach alles in einer Datei.  Im Internet finden Sie eine Reihe von npm-Modulen, die kleine json in einer Datei sammeln k√∂nnen.  Ich habe nicht diejenigen gefunden, die an einen Hash anh√§ngen und alles in einer Datei sammeln k√∂nnen.  Webpack selbst kann auch nicht mit json umgehen, wie es die ngx-translate-Besonderheiten erfordern.  Deshalb werden wir unser Webpack-Plugin schreiben. </p><br><p>  Kurz gesagt: Wir m√ºssen alle json im Projekt nach einem bestimmten Muster sammeln, w√§hrend wir sie nach Namen (en, ru, de usw.) gruppieren m√ºssen, da sich en.json beispielsweise in verschiedenen Ordnern befinden kann.  Dann m√ºssen Sie f√ºr jede gesammelte Datei einen Hash anh√§ngen. </p><br><p>  Hier gibt es ein Problem.  Wie erkennt <code>AppTranslateLoader</code> Dateinamen, wenn jede Lokalisierung einen eigenen Namen hat?  Wenn Sie beispielsweise das Bundle in index.html aufnehmen, k√∂nnen Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HtmlWebpackPlugin einf√ºgen</a> und es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auffordern</a> , ein Skript-Tag mit dem Namen des Bundles selbst hinzuzuf√ºgen. </p><br><p>  Um dieses Problem f√ºr .json-Lokalisierungen zu l√∂sen, erstellt unser Webpack-Plugin config.json, das die Zuordnung des Sprachcodes zum Hash-Dateinamen enth√§lt: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"en"</span></span>: <span class="hljs-string"><span class="hljs-string">"en.some_hash.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru.some_hash.json"</span></span> }</code> </pre> <br><p>  config.json wird ebenfalls vom Browser zwischengespeichert, aber es wird einige Zeit dauern, und wir k√∂nnen einfach einen zuf√§lligen queryString-Parameter angeben, wenn GET mit dieser Datei √ºberwachsen ist (wodurch sie st√§ndig neu geladen wird).  Oder weisen Sie config.json eine zuf√§llige ID zu (ich werde diese Methode beschreiben, die erste finden Sie in Google). </p><br><p>  Ich m√∂chte auch die Infrastruktur und Atomizit√§t von Lokalisierungen ein wenig vereinfachen.  json mit Lokalisierung liegt im Ordner mit seiner Komponente.  Um doppelte Schl√ºssel zu vermeiden, wird die Struktur des JSON-Bundles basierend auf dem Pfad zu einer bestimmten JSON-Datei erstellt.  Zum Beispiel haben wir zwei en.json, eine liegt auf dem Pfad <code>src/app/article-component</code> und die andere <code>src/app/comment-component</code> .  Ich m√∂chte den folgenden JSON in der Ausgabe erhalten: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"article-component"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"TITLE"</span></span>: <span class="hljs-string"><span class="hljs-string">"Article title"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"comment-component"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"TITLE"</span></span>: <span class="hljs-string"><span class="hljs-string">"Comment title"</span></span> } }</code> </pre> <br><p>  Wir k√∂nnen den Teil des Pfades verwerfen, den wir nicht ben√∂tigen, damit die Schl√ºssel in den Ansichten so kurz wie m√∂glich sind. </p><br><p>  !!!  Es gibt einen Nachteil: Wenn Sie die Komponente in einem anderen Ordner ablegen, √§ndert sich der Lokalisierungsschl√ºssel. </p><br><p>  Sp√§ter werden wir einen weiteren Life-Hack in Betracht ziehen, mit dem wir in der Komponente nur das letzte Schl√ºsselfeld angeben k√∂nnen, unabh√§ngig davon, wo und wie tief unser Projekt im Projekt ist. Dementsprechend k√∂nnen wir es nach Belieben √ºbertragen und nach Belieben umbenennen. </p><br><p>  Grunds√§tzlich m√∂chte ich eine Kapselung und sogar einen Hinweis auf Polymorphismus von ngx-translate-Lokalisierungen erreichen.  Ich mag das Konzept der Kapselung von Ansichten in Angular - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Angular View Encapsulation</a> oder besser gesagt im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shadow DOM</a> .  Ja, dies vergr√∂√üert die Anwendung insgesamt, aber ich werde im Voraus sagen, dass die Arbeit mit Lokalisierungsdateien viel angenehmer geworden ist, nachdem ngx-translate st√§rker gekapselt wurde.  Die Komponenten k√ºmmerten sich nur noch um ihre Lokalisierungen. Au√üerdem k√∂nnen die Lokalisierungen in der untergeordneten Komponente abh√§ngig von den Lokalisierungen in der √ºbergeordneten Komponente neu definiert werden.  Au√üerdem k√∂nnen Sie jetzt Komponenten von Projekt zu Projekt √ºbertragen, die bereits lokalisiert sind.  Aber wie anderswo gibt es Nuancen, dazu sp√§ter mehr. </p><br><p>  Fahren wir also mit unserem Plugin fort.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist das und wie?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin zum Zusammenf√ºhren von Lokalisierungen</a> . <br>  Den Quellcode f√ºr den Loader und das Plugin finden Sie unter dem Beispiellink am Ende des Artikels (Ordner ./build-utils). </p><br><p>  Das Plugin macht alles mit dem, was oben geschrieben wurde, und akzeptiert die folgenden Optionen: </p><br><ul><li>  weglassen.  Namen im Pfad zur Lokalisierung, die ignoriert werden m√ºssen (genau in diesem Moment m√∂chte ich die zus√§tzlichen Teile des Pfads zur Datei entfernen). </li><li>  fileInput.  regelm√§√üig zum Abrufen von Lokalisierungsdateien in prodge (wie Test in Webpack) </li><li>  rootDir.  Wo soll ich nach der Datei nach dem fileInput-Muster suchen? </li><li>  outputDir.  Hier werden die Konfigurationsdatei und die Lokalisierungen im Ordner dist erstellt </li><li>  Konfigurationsname.  Unter welchem ‚Äã‚ÄãNamen wird die Konfigurationsdatei erstellt? </li></ul><br><p>  In meinem Projekt ist das Plugin folgenderma√üen verbunden: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// build-utils.js // part of METADATA { // ... translationsOutputDir: 'langs/', translationsFolder: '@translations', translationsConfig: `config.${Math.random().toString(36).substr(2, 9)}.json`, } //webpack.common.js new MergeLocalizationPlugin({ fileInput: [`**/${METADATA.translationsFolder}/*.json`, 'app-translations/**/*.json'], rootDir: 'src', omit: new RegExp(`app-translations|${METADATA.translationsFolder}|^app`, 'g'), outputDir: METADATA.translationsOutputDir, configName: METADATA.translationsConfig }),</span></span></code> </pre> <br><p>  In Komponenten, die lokalisiert werden m√ºssen, befindet sich ein <code>@translations</code> Ordner, der en.json, ru usw. enth√§lt. </p><br><p>  Infolgedessen wird beim Umbl√§ttern alles in einer Datei zusammengefasst, wobei der Pfad zum Ordner <code>@translations</code> ber√ºcksichtigt wird.  Das Lokalisierungspaket befindet sich in dist / langs / und die Konfiguration wird als config. $ {Some-random} .json bezeichnet. </p><br><p>  Als N√§chstes stellen wir sicher, dass das gew√ºnschte Lokalisierungspaket in die Anwendung geladen wird.  Es gibt einen fragilen Punkt: Nur das Webpack kennt den Pfad zu den Lokalisierungen und den Namen der Konfigurationsdatei. Ber√ºcksichtigen Sie dies, damit die neuesten Daten in AppTranslateLoader eingehen und die Namen nicht an zwei Stellen ge√§ndert werden m√ºssen. </p><br><pre> <code class="hljs powershell">// some inmports // ... // momentJs import * as moment from <span class="hljs-string"><span class="hljs-string">'moment'</span></span>; import <span class="hljs-string"><span class="hljs-string">'moment/locale/en-gb'</span></span>; import <span class="hljs-string"><span class="hljs-string">'moment/locale/ru'</span></span>; @Injectable() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppTranslateLoader</span></span></span></span> { //            public additionalStorageKey: string = <span class="hljs-string"><span class="hljs-string">''</span></span>; private translationsDir: string; private translationsConfig: string; private selectedLang: string; private fallbackLang: string; private loadedLang: string; private config: { [<span class="hljs-type"><span class="hljs-type">key</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>]: string; } = null; private loadSubs = new Subscription(); private configSubs = new Subscription(); private loadSubj = new Subject(); private get storageKey(): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.additionalStorageKey ? `APP_LANG_<span class="hljs-variable"><span class="hljs-variable">$</span></span>{this.additionalStorageKey}` : <span class="hljs-string"><span class="hljs-string">'APP_LANG'</span></span>; } constructor(private http: HttpClient, private translate: TranslateService) { //   webpack       //     . this.translationsDir = `${process.env.TRANSLATE_OUTPUT}`; this.translationsConfig = `${process.env.TRANSLATE_CONFIG}`; this.fallbackLang = <span class="hljs-string"><span class="hljs-string">'en'</span></span>; const storedLang = this.getUsedLanguage(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (storedLang) { this.selectedLang = storedLang; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { this.selectedLang = translate.getBrowserLang() || this.fallbackLang; } } }</code> </pre> <br><p>  <code>process.env.TRANSLATE_OUTPUT</code> funktioniert einfach nicht, wir m√ºssen ein anderes Plugin im Webpack deklarieren (DefinePlugin oder EnvironmentPlugin): </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// METADATA declaration const METADATA = { translationsOutputDir: 'langs/', translationsFolder: '@translations', translationsConfig: `config. ${Math.random().toString(36).substr(2, 9)}.json`, }; // complex webpack config... // webpack plugins... new DefinePlugin({ 'process.env.TRANSLATE_OUTPUT': JSON.stringify(METADATA.translationsOutputDir), 'process.env.TRANSLATE_CONFIG': JSON.stringify(METADATA.translationsConfig), }),</span></span></code> </pre> <br><p>  Jetzt k√∂nnen wir den Pfad zu Lokalisierungen und den Namen der Konfiguration an nur einer Stelle √§ndern. <br>  Standardm√§√üig k√∂nnen Sie vom Standard-Angular-Verkauf, der in der Webpack-Assembly generiert wird ( <code>ng eject</code> eject), process.env.someValue nicht aus dem Code angeben (selbst wenn Sie DefinePlugin verwenden), der Compiler kann schw√∂ren.  Damit dies funktioniert, m√ºssen Sie 2a Bedingungen erf√ºllen: </p><br><ul><li>  F√ºgen Sie in main.ts die erste Zeile <code>/// &lt;reference types="node"/&gt;</code> </li><li>  package.json muss <code>@types/node</code> - <code>npm install --save-dev @types/node</code> . </li></ul><br><p>  Wir fahren direkt mit dem Startvorgang fort. <br>  Wenn Sie APP_INITIALIZER verwenden m√∂chten, geben Sie Promise und nicht Observable zur√ºck.  Unsere Aufgabe ist es, eine Abfragekette zu schreiben: </p><br><ul><li>  Zuerst m√ºssen Sie config.json herunterladen (nur wenn nicht geladen). </li><li>  Versuchen Sie, die Sprache zu laden, die die Sprache des Browsers des Benutzers ist </li><li>  Stellen Sie die Fallback-Logik mit der Standard-Download-Sprache bereit. </li></ul><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> imports @Injectable() AppTranslateLoader { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fields ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,         <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Subscription    unsubscribe    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   private loadSubs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscription(); private configSubs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscription(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       -   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Subject       private loadSubj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> constructor ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  Promise! public loadTranslation(lang: string = <span class="hljs-string"><span class="hljs-string">''</span></span>): Promise&lt;any&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lang) { lang = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang; } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lang === <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get&lt;Response&gt;(`<span class="javascript"><span class="javascript">${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsDir}${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsConfig}</span></span>`) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config: any)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config = config; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(lang); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(lang); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.asObservable().toPromise(); } private loadAndUseLang(lang: string) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get&lt;Response&gt;(`<span class="javascript"><span class="javascript">${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsDir}${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.config[lang] || </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.config[</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.fallbackLang]}</span></span>`) .subscribe(res =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.setTranslation(lang, res); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.use(lang).subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLangLoaded(lang); }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fallback  ngx-translate   (err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLoadLangError(lang, err)); }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fallback  http   (err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLoadLangError(lang, err)); } private onLangLoaded(newLang: string) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang !== newLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.resetLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang = newLang; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang = newLang; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO:       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  en  ru,  momentJs   en. moment().locale(newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  .  momentJs localStorage.setItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageKey, newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ls <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.complete(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -      . } private onLoadLangError(langKey: string, error: any) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.use(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) .subscribe( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLangLoaded(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang), <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.error(err)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (langKey !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fallbackLang) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      fallback  <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fallbackLang); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.error(error); } }</code> </pre> <br><p>  Fertig. </p><br><p>  Nun zur√ºck zum Problem des Verschiebens von Komponenten in andere Ordner, der Kapselung und der √Ñhnlichkeit des Polymorphismus. </p><br><p>  Tats√§chlich haben wir bereits eine Art Kapselung.  Lokalisierungen werden in Ordner neben den Komponenten verschoben. Alle Schl√ºsselpfade sind eindeutig. Wir k√∂nnen jedoch die Schl√ºssel der Komponente some-component1 in some-component2 lokalisieren, und es wird schwierig sein, alles im Auge zu behalten. Wir werden es sp√§ter herausfinden. </p><br><pre> <code class="hljs powershell">&lt;some<span class="hljs-literal"><span class="hljs-literal">-component1</span></span> [<span class="hljs-type"><span class="hljs-type">someLabel</span></span>]=<span class="hljs-string"><span class="hljs-string">"'components.some-component2.some_key' | tanslate"</span></span>&gt;&lt;/some<span class="hljs-literal"><span class="hljs-literal">-component1</span></span>&gt; // components.some<span class="hljs-literal"><span class="hljs-literal">-component2</span></span> -    </code> </pre> <br><p>  In Bezug auf die Bewegung von Bauteilen: <br>  Der Schl√ºssel, den wir in der Ansicht verwenden, ist nun fest an den relativen Pfad zur Lokalisierungsdatei gebunden und h√§ngt von der spezifischen Infrastruktur des Projekts ab. </p><br><p>  Ich werde einen ziemlich traurigen Fall dieser Situation geben: </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">translate</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"+lazy-module.components.article-component.article_title"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Was aber, wenn ich den Namen des Komponentenordners in Post-Component √§ndere? <br>  Es wird ziemlich schwierig sein, diesen Schl√ºssel an allen erforderlichen Stellen einzugeben.  Nat√ºrlich hat niemand das Kopieren, Einf√ºgen und Ersetzen abgebrochen, aber das Schreiben ohne die Eingabeaufforderungen der IDE ist auch stressig. </p><br><p>  Um diese Probleme zu l√∂sen, achten wir darauf, was das Webpack dagegen unternimmt.  Webpack hat so etwas wie einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Loader</a> . Es gibt viele Loader, die mit Dateipfaden arbeiten: Zum Beispiel Ressourcenpfade in CSS - dank Webpack k√∂nnen wir relative Pfade f√ºr Hintergrundbilder angeben: url (../ relative.png) und so weiter Der Rest der Dateipfade im Projekt ist √ºberall! </p><br><p>  Wer auch immer seine Webpack-Builds erstellt hat, wei√ü, dass der Loader an der Eingabe eine Datei empf√§ngt, die einem bestimmten Muster entspricht.  Die Aufgabe des Loaders selbst besteht darin, diese Eingabedatei irgendwie zu transformieren und f√ºr weitere √Ñnderungen durch andere Loader zur√ºckzugeben. </p><br><p>  Deshalb m√ºssen wir unseren Loader schreiben.  Die Frage ist, welche Art von Dateien werden wir √§ndern: Ansichten oder Komponenten?  Auf einer Seite k√∂nnen Ansichten direkt in der Komponente und separat sein.  Ansichten k√∂nnen gro√ü genug und schwer zu analysieren sein. Stellen Sie sich vor, wir haben eine Ansicht, in der 100 Direktiven √ºbersetzen (nicht in einer Schleife): </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'./some_key_1'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; ... &lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"100"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'../another_key_!'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;</code> </pre><br><p>  √úber Loader k√∂nnen wir den Schl√ºsselpfad zu Komponentenlokalisierungen in der N√§he jeder Pipe oder Direktive ersetzen. </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'app.some-component.some_key_1'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; <span class="hljs-comment"><span class="hljs-comment">// app.some-component. -   loader'</span></span></code> </pre> <br><p>  Wir k√∂nnen einer Komponente, die die Lokalisierung erm√∂glicht, ein Feld hinzuf√ºgen: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-some'</span></span></span><span class="hljs-meta">, template: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'&lt;div&gt;{{(localization + '</span></span></span><span class="hljs-meta">key</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">') | tanslate}}&lt;/div&gt;'</span></span></span><span class="hljs-meta"> })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ localization = <span class="hljs-string"><span class="hljs-string">'./'</span></span> }</code> </pre> <br><p>  Es ist auch schlecht - Sie m√ºssen √ºberall einen Lokalisierungsschl√ºssel erstellen. </p><br><p>  Da die offensichtlichsten Optionen schlecht aussehen, verwenden Sie einen Dekorator und speichern Sie einige Metadaten im Prototyp der Komponente (wie bei Angular). </p><br><p><img src="https://habrastorage.org/webt/gu/_4/vp/gu_4vpfjn_3ujxoh3tragj7wi2s.png" alt="Bild"></p><br><p>  <strong>Anmerkungen</strong> - Metadaten f√ºr Winkeldekorateure <br>  __app_annotations__ - Metadaten, die wir f√ºr uns selbst speichern </p><br><p>  Der Pfad zum Lokalisierungsordner relativ zur Komponente kann in den Dekorator geschrieben werden. Der gleiche Dekorator kann mit anderen Optionen als dem Pfad erweitert werden. </p><br><pre> <code class="hljs powershell">//translate.service.ts const app_annotations_key = <span class="hljs-string"><span class="hljs-string">'__app_annotations__'</span></span>; export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Localization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: string)</span></span></span></span> { // tslint:<span class="hljs-built_in"><span class="hljs-built_in">disable-next</span></span><span class="hljs-literal"><span class="hljs-literal">-line</span></span>:only<span class="hljs-literal"><span class="hljs-literal">-arrow</span></span><span class="hljs-literal"><span class="hljs-literal">-functions</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target: Function)</span></span></span></span> { const metaKey = app_annotations_key; Object.defineProperty(target, metaKey, { value: { //         path. path, name: <span class="hljs-string"><span class="hljs-string">'Translate'</span></span> } } as PropertyDescriptor); }; } //some.component.ts @Component({...}) @Localization({ path: <span class="hljs-string"><span class="hljs-string">'./'</span></span>, otherOptions: {...} }); export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span></span> { }</code> </pre> <br><p>      webpack,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">loader</a>           ,      -    .          ,     (      styleUrls)      . loader,     npm .    . </p><br><p>        ,   -.       ,          -. </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'just_key'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;</code> </pre> <br><p>          .    ,      ,      ,           .    ‚Äî Injector, .   ,       Injector,     ''  ,  translate       .      Injector,       (    ),         'get'. </p><br><p><img src="https://habrastorage.org/webt/jl/vw/0x/jlvw0xsep9o3valmkhc3uxblvdm.png" alt="Bild"></p><br><p>  ,  parent  ,     ,    Injector'a  ,      ,     ,   ,   ,        . </p><br><p>  ,     API,   forwarRef() (    Angular reactive forms,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">control</a> ).  ,      .         . </p><br><pre> <code class="hljs powershell">// translate.service.ts export const TRANSLATE_TOKEN = new InjectionToken(<span class="hljs-string"><span class="hljs-string">'MyTranslateToken'</span></span>); // app.component.ts @Component({ selector: <span class="hljs-string"><span class="hljs-string">'app-root'</span></span>, templateUrl: <span class="hljs-string"><span class="hljs-string">'./app.component.html'</span></span>, styleUrls: [<span class="hljs-string"><span class="hljs-string">'./app.component.css'</span></span>], providers: [{<span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">TRANSLATE_TOKEN</span></span>, <span class="hljs-type"><span class="hljs-type">useExisting</span></span>: <span class="hljs-type"><span class="hljs-type">forwardRef</span></span>(() =&gt; <span class="hljs-type"><span class="hljs-type">AppComponent</span></span>)}] }) @Localization(<span class="hljs-string"><span class="hljs-string">'./'</span></span>) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span></span> { title = <span class="hljs-string"><span class="hljs-string">'app'</span></span>; }</code> </pre> <br><p>        , ,         ,   forwardRef(). </p><br><p>  ,     Injector     forwardRef()        ,             .       ,        '' .     ,   ,   . </p><br><pre> <code class="hljs pgsql">// my-translate.directive.ts @Directive({ // tslint:<span class="hljs-keyword"><span class="hljs-keyword">disable</span></span>-next-<span class="hljs-type"><span class="hljs-type">line</span></span>:directive-selector selector: <span class="hljs-string"><span class="hljs-string">'[myTranslate]'</span></span> }) export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyTranslateDirective extends TranslateDirective { @<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> myTranslate(e: string) { this.translate = e; } private keyPath: string; constructor(private _translateService: TranslateService, private _element: ElementRef, _chRef: ChangeDetectorRef, //    forwardRef() @Inject(TRANSLATE_TOKEN) @Optional() protected cmp: <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>) { super(_translateService, _element, _chRef); //    const prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.getPrototypeOf(cmp || {}).constructor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prototype[app_annotations_key]) { //      this.keyPath = prototype[app_annotations_key].path; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> updateValue(key: string, node: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, translations: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.keyPath) { //     ,   //   key = `${this.keyPath.replace(/\//, <span class="hljs-string"><span class="hljs-string">'.'</span></span>)}.${key}`; } super.updateValue(key, node, translations); } }</code> </pre> <br><p>      . </p><br><p>  -      : </p><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{'just_this_component_key' | myTranslate}}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> //  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">myTranslate</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"just_this_component_key"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>    translate , .      ,       ,          -    : </p><br><pre> <code class="hljs pgsql">//en.bundle.json { "global_key": "Global key" "app-component": { "just_key": "Just key" } } //<span class="hljs-keyword"><span class="hljs-keyword">some</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.html &lt;div translate="global_key"&gt;&lt;/div&gt;</code> </pre> <br><p> Research and improve! </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">full example</a> </p><br><p>       : </p><br><ol><li>     FE     node.js   stacktrace.js. </li><li>  Jest  Angular . </li><li> Web worker )      , ,  Angular  . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413787/">https://habr.com/ru/post/de413787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413775/index.html">Gegnerische Angriffe auf Maschinen k√∂nnen 2018 sehen</a></li>
<li><a href="../de413777/index.html">Wochenendlesung: IaaS-Einf√ºhrungsmaterialien, Informationssicherheit und IT-Regulierungsveranstaltungen</a></li>
<li><a href="../de413779/index.html">Timer und Multitasking auf Arduino</a></li>
<li><a href="../de413781/index.html">Wie Werbebluthunde Ihrer Spur im Internet folgen</a></li>
<li><a href="../de413783/index.html">Wie sterben die massereichsten Sterne: Supernova, Hypernova oder direkter Zusammenbruch?</a></li>
<li><a href="../de413789/index.html">In Florida √ºberpr√ºften sie ein Jahr lang keine Waffeneink√§ufer bei der FBI-Basis, weil sie das Passwort vergessen hatten</a></li>
<li><a href="../de413791/index.html">Quantenmechanik von Berechnungen in JS</a></li>
<li><a href="../de413793/index.html">Audiokassetten in der Popkultur: Warum das veraltete Tonaufnahmeformat wieder als modisch gilt</a></li>
<li><a href="../de413795/index.html">Warum die Unterhaltungsindustrie zu IaaS wechselt: Fallstudie</a></li>
<li><a href="../de413797/index.html">EA stellte den neuen Teil von C & C auf der E3 vor. Und es ist k√∂rperlich schmerzhaft, es anzusehen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>