<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏼 👨‍👧‍👦 🧜🏻 Efek penyaringan SVG. Bagian 1. Filter SVG 101 💿 🧑🏽‍🤝‍🧑🏽 🌃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rangkaian artikel yang diusulkan, " Efek Penyaringan SVG, " oleh Sara Soueidan, pengembang antarmuka UI / UX lepas dan penulis banyak artikel teknis y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Efek penyaringan SVG. Bagian 1. Filter SVG 101</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439282/"><p>  Rangkaian artikel yang diusulkan, " <strong>Efek Penyaringan SVG,</strong> " oleh Sara Soueidan, pengembang antarmuka UI / UX lepas dan penulis banyak artikel teknis yang berbasis di Lebanon, berfokus pada karya filter SVG dan terdiri dari artikel berikut: </p><br><h1 id="effekty-filtracii-svg">  Efek Penyaringan SVG </h1><br><ol><li>  Efek filter SVG.  Bagian 1. Filter SVG 101. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek filter SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Kontur teks menggunakan feMorphology</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek penyaringan SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3. Pengaruh posterisasi gambar menggunakan feComponentTransfer</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek penyaringan SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4. Gambar dua warna dengan <strong>feComponentTransfer</strong></a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek penyaringan SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 5. Mencocokkan teks dengan tekstur permukaan dengan <strong>feDisplacementMap</strong></a> </li></ol><br><hr><br><p>  Ini adalah artikel pertama dalam seri tentang filter SVG.  Panduan ini akan membantu Anda memahami apa itu dan menunjukkan kepada Anda bagaimana menggunakannya untuk membuat efek visual Anda sendiri. </p><br><p><img src="https://habrastorage.org/webt/_8/ka/is/_8kaisnavnh_qmr3tvdsxofq0ii.png"></p><a name="habracut"></a><br><p>  <strong>CSS</strong> saat ini memberi kami cara untuk menerapkan efek warna pada gambar, seperti saturasi, kecerahan, dan kontras, di antara efek lainnya, menggunakan properti <strong>filter</strong> dan fungsinya yang menyertainya. </p><br><p>  Sekarang kami memiliki 11 fungsi filter dalam CSS yang melakukan sejumlah efek dari kabur hingga mengubah kontras dan saturasi warna, dan banyak lagi.  Untuk informasi lebih lanjut tentang ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat referensi CSS</a> . </p><br><p>  Meskipun kuat dan sangat nyaman, filter CSS juga sangat terbatas.  Efek yang dapat kita buat dengannya sering berlaku untuk gambar dan terbatas pada manipulasi warna dan pengaburan yang sederhana.  Jadi, untuk menciptakan efek yang lebih kuat yang dapat kita terapkan pada elemen yang lebih luas, kita membutuhkan fungsi yang lebih luas.  Fitur-fitur ini tersedia hari ini, dan telah tersedia selama lebih dari sepuluh tahun di SVG.  Dalam artikel ini, yang merupakan seri pertama pada filter SVG, Anda akan belajar tentang fungsi filter SVG, yang dikenal sebagai "primitif," dan cara menggunakannya. </p><br><p>  Filter CSS diimpor dari SVG.  Mereka adalah versi yang dioptimalkan dengan cukup baik dari subset efek penyaringan yang diperkenalkan dalam SVG dan ada dalam spesifikasi SVG selama bertahun-tahun. </p><br><p>  SVG memiliki lebih banyak efek penyaringan daripada CSS, dan versi SVG lebih kuat dan melakukan efek yang jauh lebih kompleks daripada pintasan CSS mereka.  Misalnya, Anda saat ini dapat mengaburkan elemen menggunakan fungsi filter CSS <strong>blur ()</strong> .  Menerapkan efek blur dengan fungsi ini akan membuat Gaussian blur yang seragam dari elemen yang diterapkannya.  Gambar berikut menunjukkan hasil penerapan blur 6px ke gambar di CSS: </p><br><p><img src="https://habrastorage.org/webt/b0/qa/fy/b0qafyst_uc08euvuxzilp13-wi.png" alt="Efek menerapkan fungsi blur ** () ** - Gaussian blur"><br>  <em>Fig_1.</em>  <em>Efek penerapan fungsi <strong>blur ()</strong> CSS adalah Gaussian blur.</em> </p><br><p>  Fungsi <strong>blur ()</strong> menciptakan efek blur yang diterapkan secara merata di kedua arah (X dan Y) pada gambar.  Tetapi fungsi ini hanyalah pengurangan sederhana dan terbatas dari filter blur primitif yang tersedia di SVG, yang memungkinkan kita untuk mengaburkan gambar secara seragam atau menerapkan efek blur searah di sepanjang sumbu X atau Y. </p><br><p><img src="https://habrastorage.org/webt/e5/gp/rr/e5gprr6riymt0ede8sxusumcyfk.png" alt="Efek penerapan fungsi SVG ** blur () ** secara terpisah di sepanjang sumbu"><br>  <em>Fig_2.</em>  <em>Efek menerapkan fungsi <strong>blur ()</strong> SVG secara terpisah di sepanjang sumbu.</em> </p><br><p>  Filter SVG dapat diterapkan pada elemen HTML dan elemen SVG.  Efek filter SVG dapat diterapkan ke elemen HTML di CSS menggunakan fungsi filter url ().  Misalnya, jika Anda memiliki efek filter dengan pengidentifikasi <strong>myAwesomeEffect yang</strong> didefinisikan dalam SVG (kami akan berbicara tentang mendefinisikan efek filter dalam SVG dalam waktu dekat), Anda dapat menerapkan efek ini ke elemen HTML atau gambar seperti ini: </p><br><pre><code class="plaintext hljs">.el { filter: url(#myAwesomeEffect); }</code> </pre> <br><p>  Yang terbaik dari semuanya, seperti yang akan Anda lihat dalam seri artikel ini, filter SVG mampu menciptakan efek tingkat Photoshop di browser menggunakan beberapa baris kode.  Saya berharap seri ini akan membantu menghilangkan halo kerahasiaan dan melepaskan bagian dari potensi filter SVG, yang akan menginspirasi Anda untuk menggunakannya dalam proyek Anda sendiri. </p><br><p>  Tapi bagaimana dengan dukungan browser, Anda bertanya ..? </p><br><h2 id="podderzhka-brauzerami">  Dukungan browser </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dukungan browser untuk</a> sebagian besar filter SVG sangat mengesankan.  Namun, metode penerapan efek mungkin berbeda di beberapa browser tergantung pada dukungan mereka untuk masing-masing filter primer yang digunakan dalam efek filter SVG, serta pada kemungkinan kesalahan browser.  Dukungan browser juga dapat berbeda ketika filter SVG diterapkan ke elemen SVG atau ke elemen HTML. </p><br><p>  Saya akan merekomendasikan agar Anda mempertimbangkan efek pemfilteran sebagai ekstensi: Anda hampir selalu dapat menerapkan efek sebagai peningkatan di atas pengalaman yang benar-benar bermanfaat tanpa filter.  Banyak orang tahu bahwa saya mendukung pendekatan progresif untuk menciptakan UI bila memungkinkan.  Dengan demikian, kami tidak akan terlalu khawatir tentang dukungan browser dalam seri artikel ini. </p><br><p>  Akhirnya, meskipun dukungan untuk filter SVG umumnya baik, perlu diingat bahwa beberapa efek yang akan kita bahas nanti dapat dianggap eksperimental.  Saya akan menunjukkan masalah atau kesalahan besar, jika dan kapan mereka mau. </p><br><p>  Jadi, bagaimana cara mendefinisikan dan membuat efek penyaringan di SVG? </p><br><h2 id="element--filter">  Elemen &lt;Filter&gt; </h2><br><p>  Seperti gradien linier, topeng, pola, dan efek grafis lainnya di SVG, filter memiliki elemen khusus yang dinamai dengan mudah: <strong>&lt;filter&gt;</strong> . </p><br><p>  Itu tidak pernah ditampilkan secara langsung, tetapi hanya digunakan sebagai objek yang dapat direferensikan menggunakan atribut <strong>filter</strong> dalam SVG atau fungsi <strong>url ()</strong> di CSS.  Elemen yang tidak ditampilkan tanpa referensi eksplisit biasanya didefinisikan sebagai templat di dalam elemen <strong>&lt;defs&gt;</strong> di SVG.  Tetapi SVG <strong>&lt;filter&gt;</strong> tidak perlu dibungkus dengan elemen <strong>defs</strong> .  Apakah Anda membungkus filter dalam elemen <strong>defs</strong> atau tidak, itu tetap tidak akan ditampilkan. </p><br><p>  Alasannya adalah karena <strong>filter ini membutuhkan gambar asli untuk diproses</strong> .  Dan jika Anda tidak secara eksplisit mendefinisikan gambar sumber ini dengan memanggil filter di atasnya, filter tidak akan menghasilkan apa-apa, dan karenanya tidak akan berfungsi. </p><br><p>  Contoh kode minimal yang sangat sederhana yang mendefinisikan filter SVG dan menerapkannya pada gambar asli di SVG akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="450" viewBox="0 0 600 450"&gt; &lt;filter id="myFilter"&gt; &lt;!-- filter effects go in here --&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="100%" height="100%" x="0" y="0" filter="url(#myFilter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Filter dalam contoh kode di atas tidak melakukan apa-apa saat ini, karena kosong.  Untuk membuat efek filter, Anda harus menentukan serangkaian satu atau lebih operasi penyaringan yang membuat efek ini di dalam filter.  Dengan kata lain, elemen <strong>&lt;filter&gt;</strong> adalah wadah untuk serangkaian operasi penyaringan yang bersama-sama menciptakan efek filter.  Operasi penyaringan ini dalam SVG disebut “ <strong>filter primitif</strong> ”. </p><br><h2 id="primitivy-filtra">  Filter primitif </h2><br><p>  Dengan demikian, dalam SVG, setiap elemen <strong>&lt;filter&gt;</strong> berisi satu set filter primitif sebagai elemen anak.  Setiap filter primitif melakukan satu operasi grafis dasar pada satu atau beberapa input, menciptakan hasil grafik. </p><br><p>  Filter primitif dinamai sesuai dengan operasi grafis yang mereka lakukan.  Misalnya, primitif yang menerapkan efek Gaussian Blur ke sumber grafis disebut <strong>feGaussianBlur</strong> .  Semua primitif memiliki awalan yang sama: fe, kependekan dari " <em>efek filter</em> ".  Sekali lagi, nama-nama di SVG nyaman untuk memilih untuk memahami apa elemen ini atau apa fungsinya. </p><br><p>  Cuplikan kode berikut menunjukkan bagaimana filter sederhana akan terlihat jika Anda menerapkan blur Gaussian 5px ke gambar: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="450" viewBox="0 0 600 450"&gt; &lt;filter id="myFilter"&gt; &lt;feGaussianBlur stDeviation="5"&gt;&lt;/feGaussianBlur&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="100%" height="100%" x="0" y="0" filter="url(#myFilter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Saat ini, spesifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>SVG Filter</strong></a> mendefinisikan 17 filter primitif yang mampu menciptakan efek grafis yang sangat kuat, termasuk tetapi tidak terbatas pada generasi kebisingan dan tekstur, efek pencahayaan, manipulasi warna (saluran ke saluran), dan banyak lagi. </p><br><p>  Filter primitif berfungsi dengan menerima sumber grafis untuk input dan keluaran ke yang lain.  Dan output dari satu efek filter dapat digunakan sebagai input ke yang lain.  Ini sangat penting dan sangat efektif, karena dengan kombinasi efek filter yang hampir tak terhitung, Anda dapat membuat efek grafis yang hampir tak terhitung jumlahnya. </p><br><p>  Setiap filter primitif dapat menerima satu atau dua input dan hanya menghasilkan satu hasil.  Input dari primitif filter didefinisikan dalam atribut in.  Hasil operasi didefinisikan dalam atribut <strong>hasil</strong> .  Jika efek filter memerlukan input kedua, maka ditentukan dalam atribut <strong>in2</strong> .  Hasil operasi dapat digunakan sebagai input untuk operasi lain, tetapi jika input operasi tidak ditentukan dalam atribut in, maka hasil operasi sebelumnya secara otomatis digunakan sebagai input.  Jika Anda tidak menentukan <strong>hasil</strong> primitif, maka hasilnya akan secara otomatis digunakan sebagai input untuk primitif berikutnya.  Ini akan menjadi lebih jelas ketika kita mulai mempelajari contoh kode. </p><br><p>  Filter primitif dapat menggunakan tipe data lain sebagai input, yang paling penting adalah: </p><br><ul><li>  <strong>SourceGraphic</strong> : elemen di mana seluruh filter diterapkan;  misalnya, gambar atau potongan teks. </li><li>  <strong>SourceAlpha</strong> : Ini sama dengan <strong>SourceGraphic</strong> , kecuali bahwa grafik ini hanya mengandung saluran alpha elemen.  Misalnya, untuk gambar JPEG, ini adalah kotak hitam ukuran gambar itu sendiri. </li></ul><br><p>  Anda akan menemukan bahwa kadang-kadang Anda ingin menggunakan sumber grafik sebagai input, dan kadang-kadang hanya saluran alpha-nya.  Contoh-contoh yang akan kita bahas dalam artikel ini dan selanjutnya akan memberikan pemahaman yang jelas tentang kapan dan apa yang harus digunakan. </p><br><p>  Cuplikan kode ini adalah contoh tampilan filter dengan paket filter primitif sebagai anak-anak.  Jangan khawatir tentang primitif dan apa yang mereka lakukan.  Pada titik ini, perhatikan bagaimana input dan output primitif tertentu didefinisikan dan digunakan.  Saya menambahkan beberapa komentar untuk bantuan. </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="filter"&gt; &lt;feOffset in="SourceAlpha" dx="20" dy="20"&gt;&lt;/feOffset&gt; &lt;!-- since the previous filter did not have a result defined and this following one does not have the input set, the result of the above primitive is automatically used as input to the following filter --&gt; &lt;feGaussianBlur stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- setting/defining the result names in all caps is a good way to make them more distinguishable and the overall code more readable --&gt; &lt;feFlood flood-color="#000" result="COLOR"&gt;&lt;/feFlood&gt; &lt;!-- This primitive is using the outputs of the previous two primitives as input, and outputting a new effect --&gt; &lt;feComposite in="DROP" in2="COLOR" operator="in" result="SHADOW1"&gt;&lt;/feComposite&gt; &lt;feComponentTransfer in="SHADOW1" result="SHADOW"&gt; &lt;feFuncA type="table" tableValues="0 0.5"&gt;&lt;/feFuncA&gt; &lt;/feComponentTransfer&gt; &lt;!-- You can use ANY two results as inputs to any primitive, regardless of their order in the DOM.--&gt; &lt;feMerge&gt; &lt;feMergeNode in="SHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#filter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Sekarang, konsep terakhir yang ingin saya jelaskan sebentar sebelum beralih ke contoh filter pertama kami adalah konsep <strong>Wilayah Filter</strong> . </p><br><h2 id="oblast-filtracii">  Area Filtrasi </h2><br><p>  Serangkaian operasi penyaringan membutuhkan area untuk diproses, area di mana mereka dapat diterapkan.  Misalnya, Anda mungkin memiliki SVG kompleks dengan banyak elemen, dan Anda ingin menerapkan efek penyaringan hanya untuk area tertentu atau ke satu atau sekelompok elemen dalam SVG yang sama. </p><br><p>  Dalam SVG elemen memiliki "wilayah" yang batas-batasnya ditentukan oleh tepi persegi panjang yang mengikat elemen.  Kotak pembatas (juga disingkat "bbox") adalah kotak terlampir terkecil di sekitar elemen.  Misalnya, pada gambar berikut, untuk sepotong teks, persegi panjang seperti itu disorot dengan warna merah muda. </p><br><p><img src="https://habrastorage.org/webt/hu/uy/i1/huuyi1kr0i8ldvfpggxgwpdi6sm.png" alt="Kotak tertutup terkecil di sekitar sepotong teks"><br>  <em>Fig_3.</em>  <em>Kotak tertutup terkecil di sekitar sepotong teks.</em> </p><br><p>  Harap perhatikan bahwa persegi panjang ini mungkin berisi beberapa ruang vertikal lagi, karena ketinggian garis teks diperhitungkan saat menghitung ketinggian persegi panjang pembatas. </p><br><p>  Secara default, area filter elemen adalah bingkai elemen pembatas.  Karenanya, jika Anda menerapkan efek filter pada fragmen teks kami, efeknya akan terbatas pada persegi panjang ini, dan setiap hasil penyaringan yang di luarnya akan terpotong.  Meskipun ini masuk akal, ini tidak terlalu praktis, karena banyak filter akan memengaruhi beberapa piksel di luar kotak pembatas, dan secara default, piksel ini pada akhirnya akan terpotong. </p><br><p>  Misalnya, jika Anda menerapkan efek blur ke fragmen teks kami, Anda dapat melihat bahwa itu dipotong di sepanjang tepi kiri dan kanan persegi panjang yang membatasi teks: </p><br><p><img src="https://habrastorage.org/webt/ll/ih/e4/llihe4hbwx94zl3xk-w9zmcmmkq.png" alt="Efek blur yang diterapkan pada teks terpotong pada sisi kanan dan kiri persegi panjang yang membatasi teks."><br>  <em>Fig_4.</em>  <em>Efek blur yang diterapkan pada teks terpotong pada sisi kanan dan kiri persegi panjang yang membatasi teks.</em> </p><br><p>  Jadi bagaimana kita mencegahnya?  Jawabannya adalah: dengan memperluas area filter.  Kami dapat memperluas cakupan penerapan filter dengan mengubah atribut <strong>x</strong> , <strong>y</strong> , <strong>width,</strong> dan <strong>height</strong> dari elemen &lt;filter&gt;. </p><br><p>  Sesuai dengan spesifikasi, </p><br><blockquote>  Seringkali diperlukan untuk menyediakan bidang dalam area filter, karena efek filter dapat mempengaruhi beberapa bit di luar kotak pembatas untuk objek tertentu.  Untuk melakukan ini, Anda bisa memberikan nilai negatif dalam persen ke properti <strong>X</strong> dan <strong>Y</strong> , dan nilai lebih dari 100% untuk properti <strong>lebar</strong> dan <strong>tinggi</strong> . </blockquote><p>  Secara default, filter memiliki area yang memperpanjang 10% dari lebar dan tinggi kotak pembatas di keempat arah.  Dengan kata lain, nilai default untuk atribut <strong>x</strong> , <strong>y</strong> , <strong>width,</strong> dan <strong>height</strong> adalah: </p><br><pre> <code class="plaintext hljs">&lt;filter x="-10%" y="-10%" width="120%" height="120%" filterUnits="objectBoundingBox"&gt; &lt;!-- filter operations here --&gt; &lt;/filter&gt;</code> </pre> <br><p>  Jika Anda tidak menyertakan atribut ini dalam elemen <strong>&lt;filter&gt;</strong> , maka nilai default akan digunakan.  Anda juga dapat menimpa mereka untuk memperluas atau mengurangi area sesuai kebutuhan. </p><br><p>  Perlu diingat bahwa unit yang digunakan dalam atribut <strong>x</strong> , <strong>y</strong> , <strong>lebar,</strong> dan <strong>tinggi</strong> tergantung pada <strong>nilai</strong> atribut <strong>filterUnits yang</strong> digunakan.  Ini mendefinisikan sistem koordinat atribut <strong>x</strong> , <strong>y</strong> , <strong>lebar</strong> dan <strong>tinggi</strong> dan dapat mengambil salah satu dari dua nilai: </p><br><ul><li>  <strong>objectBoundingBox</strong> .  Ini adalah nilai default.  Ketika <strong>filterUnits</strong> diatur ke <strong>objectBoundingBox</strong> , nilai atribut <strong>x</strong> , <strong>y</strong> , <strong>width,</strong> dan <strong>height</strong> adalah persentase atau fraksi dari ukuran kotak pembatas elemen.  Ini juga berarti bahwa Anda dapat menggunakan nilai fraksional alih-alih persentase jika Anda mau. </li><li>  <strong>userSpaceOnUse</strong> Jika <strong>filterUnits</strong> diatur ke <strong>userSpaceOnUse</strong> , koordinat atribut x, y, lebar, dan tinggi relatif terhadap sistem koordinat saat ini yang digunakan oleh pengguna.  Dengan kata lain, ini relatif terhadap sistem koordinat saat ini yang digunakan dalam SVG, yang menggunakan piksel sebagai satuan pengukuran dan, sebagai aturan, relatif terhadap ukuran SVG itu sendiri, dengan asumsi bahwa nilai-nilai <strong>viewBox</strong> sesuai dengan nilai-nilai sistem koordinat asli. </li></ul><br><blockquote>  Semua yang perlu Anda ketahui tentang sistem koordinat di SVG dapat ditemukan di artikel ini, yang saya tulis beberapa tahun lalu. </blockquote><br><pre> <code class="plaintext hljs">&lt;!-- Using objectBoundingBox units --&gt; &lt;filter id="filter" x="5%" y="5%" width="100%" height="100%"&gt; &lt;!-- Using userSpaceOnUse units --&gt; &lt;filter id="filter" filterUnits="userSpaceOnUse" x="5px" y="5px" width="500px" height="350px"&gt;</code> </pre> <br><h3 id="bystryy-sovet-vizualizaciya-tekuschey-oblasti-filtra-s-pomoschyu-feflood">  Kiat cepat: memvisualisasikan area filter saat ini dengan feFlood </h3><br><p>  Jika Anda perlu melihat batas area filter, Anda dapat memvisualisasikannya dengan mengisinya dengan beberapa warna.  <strong>Mudahnya</strong> , ada filter primitif bernama <strong>feFlood</strong> , yang tujuan utamanya adalah ini: untuk mengisi area filter saat ini dengan warna yang ditentukan dalam atribut <strong>warna banjir</strong> . </p><br><p>  Jadi, jika kita berasumsi bahwa kita memiliki sepotong teks, area filter yang ingin kita lihat, maka kodenya mungkin terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600px" height="400px" viewBox="0 0 600 400"&gt; &lt;filter id="flooder" x="0" y="0" width="100%" height="100%"&gt; &lt;feFlood flood-color="#EB0066" flood-opacity=".9"&gt;&lt;/feFlood&gt; &lt;/filter&gt; &lt;text dx="100" dy="200" font-size="150" font-weight="bold" filter="url(#flooder)"&gt;Effect!&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Seperti yang dapat Anda lihat dari cuplikan kode di atas, primitif <strong>feFlood</strong> juga menerima atribut <strong>opacity-banjir</strong> , yang dapat digunakan untuk membuat transparansi untuk lapisan isian warna. </p><br><p>  Cuplikan di atas mengisi area filter dengan warna pink.  Tetapi ada satu hal: ketika Anda mengisi area dengan warna, Anda benar-benar mengisinya dengan warna, yang berarti bahwa warna akan mencakup semua yang ada di area filter, termasuk elemen dan efek yang Anda buat sebelumnya, serta teks itu sendiri.  Lagipula, itu konsep isi, kan? </p><br><p><img src="https://habrastorage.org/webt/aj/pc/qc/ajpcqctctaikdiirvjexjeuh6yg.png" alt="Sebelum dan sesudah mengisi area teks filter dengan warna"><br>  <em>Fig_5.</em>  <em>Sebelum dan sesudah mengisi area teks dari filter dengan warna.</em> </p><br><p>  Untuk mengubah ini, kita perlu memindahkan layer warna di bawah ini dan menunjukkan layer teks asli di atas. </p><br><p>  Jika Anda memiliki beberapa lapisan konteks yang harus ditampilkan di atas satu sama lain di filter SVG, Anda dapat menggunakan filter <strong>&lt;feMerge&gt;</strong> primitif.  Sesuai namanya, primitif <strong>feMerge</strong> digunakan untuk menggabungkan lapisan elemen atau efek secara bersamaan. </p><br><p>  Primitif <strong>tidak memiliki atribut in.</strong>  <strong>Untuk menggabungkan lapisan di dalam <strong>&lt;feMerge&gt;</strong> , digunakan dua atau lebih <strong>&lt;feMergeNode&gt;</strong> , yang masing-masing memiliki atributnya sendiri, yang mewakili lapisan yang ingin kita tambahkan.</strong> <br></p><p>  Peletakan lapisan (atau "simpul") tergantung pada urutan sumber <strong>&lt;feMergeNode&gt;</strong> - yang pertama <strong>&lt;feMergeNode&gt;</strong> ditampilkan "di belakang" atau "di bawah" yang kedua.  <strong>&lt;feMergeNode&gt; terakhir</strong> mewakili lapisan paling atas.  Dan sebagainya. </p><br><p>  Jadi, dalam contoh kita dengan teks, fill warna adalah layer, dan sumber teks (sumber grafis) adalah layer yang berbeda, dan kami ingin meletakkan teks di atas fill warna.  Kode kami akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600px" height="400px" viewBox="0 0 600 400"&gt; &lt;filter id="flooder"&gt; &lt;feFlood flood-color="#EB0066" flood-opacity=".9" result="FLOOD"&gt;&lt;/feFlood&gt; &lt;feMerge&gt; &lt;feMergeNode in="FLOOD" /&gt; &lt;feMergeNode in="SourceGraphic" /&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;text dx="100" dy="200" font-size="150" font-weight="bold" filter="url(#flooder)"&gt;Effect!&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Perhatikan bagaimana saya menamai hasil dari <strong>feFlood</strong> di atribut <strong>hasil</strong> , sehingga saya dapat menggunakan nama ini di lapisan <strong>&lt;feMergeNode&gt;</strong> sebagai input.  Karena kami ingin menampilkan teks sumber di atas warna aliran, kami mereferensikan teks ini menggunakan <strong>SourceGraphic</strong> .  Demo berikut menunjukkan hasilnya: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/dJddbK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="primenenie-teni-k-izobrazheniyu">  Terapkan bayangan ke suatu gambar </h2><br><p>  Mari saya mulai dengan peringatan singkat: lebih baik Anda membuat bayangan sederhana menggunakan fungsi filter CSS <strong>drop-shadow ()</strong> .  Jalur filter SVG jauh lebih bertele-tele.  Bagaimanapun, seperti yang kami sebutkan sebelumnya, fungsi filter CSS adalah cara pintas yang nyaman.  Tapi saya masih ingin mempertimbangkan contoh ini sebagai titik masuk sederhana ke efek filter yang lebih kompleks, yang akan kita bahas di artikel mendatang. </p><br><p>  Jadi bagaimana bayangan itu dibuat? </p><br><p>  Sebuah bayangan biasanya merupakan lapisan abu-abu muda di belakang atau di bawah elemen yang memiliki bentuk (atau bentuk) yang sama dengan elemen itu sendiri.  Dengan kata lain, Anda dapat menganggap ini salinan elemen abu-abu buram. </p><br><p>  Saat membuat filter SVG, Anda perlu bernalar secara bertahap.  Langkah apa yang diperlukan untuk mencapai efek ini atau itu?  Untuk bayangan, salinan abu-abu kabur dari suatu elemen dapat dibuat dengan mengaburkan salinan hitam elemen dan kemudian mewarnai salinan hitam ini, mis.  membuatnya menjadi abu-abu.  Kemudian salinan abu-abu kabur yang baru dibuat ini ditempatkan di belakang elemen asli dan sedikit bergeser ke dua arah. </p><br><p>  Jadi, kita <strong>akan mulai dengan mendapatkan salinan hitam dari elemen kita dan mengaburkannya</strong> .  Salinan hitam dapat dibuat menggunakan saluran alpha elemen, menggunakan <strong>SourceAlpha</strong> sebagai input filter. </p><br><p>  <strong>Primitive feGaussianBlur</strong> akan digunakan untuk menerapkan Gaussian blur ke layer SourceAlpha ini.  Jumlah blur yang diperlukan diatur dalam atribut <strong>stdDeviation</strong> (kependekan dari Standar Deviasi).  Jika Anda menetapkan satu nilai atribut <strong>stdDeviation</strong> , nilai ini akan digunakan untuk menerapkan pengaburan data input yang seragam.  Anda juga dapat menentukan dua nilai numerik, kemudian yang pertama akan digunakan untuk mengaburkan elemen dalam arah horizontal, dan yang kedua untuk blur vertikal.  Untuk bayangan, kita perlu menerapkan blur yang seragam, sehingga kode kita akan mulai dengan ini: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;-- Grab a blakc copy of the source image and blur it by 10 --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Cuplikan kode di atas mengarah ke efek berikut, di mana hanya saluran alfa kabur dari gambar yang saat ini ditampilkan: </p><br><p><img src="https://habrastorage.org/webt/zd/e9/ye/zde9ye5ycftyjmi_cru94ty3jde.png" alt="Membuat salinan foto hitam dengan blur (bayangan)"><br>  <em>Fig_6.</em>  <em>Dibuat salinan hitam dari gambar dengan blur (bayangan).</em> </p><br><p>  Lalu kami ingin <strong>mengubah warna bayangan dan membuatnya abu-abu</strong> .  Kami akan melakukan ini dengan menerapkan isian warna ke area filter, dan kemudian menggabungkan lapisan isian warna ini dengan lapisan bayangan yang kami buat. </p><br><p>  Alignment adalah koneksi elemen grafis dengan latar belakang buram.  Latar belakang kabur adalah konten di balik elemen yang elemennya selaras.  Di filter kami, warna isian adalah lapisan atas, dan bayangan buram adalah latar belakangnya, karena terletak di belakangnya.  Kami akan mempertimbangkan primitif <strong>feComposite</strong> lebih terinci dalam artikel berikut, jadi jika Anda tidak terbiasa dengan komposisi dan cara kerjanya, maka saya sarankan Anda membaca <strong>artikel terperinci</strong> tentang topik ini di blog saya. </p><br><p>  Primitif <strong>feComposite</strong> memiliki atribut <strong>operator</strong> , yang digunakan untuk menunjukkan operasi gabungan yang ingin kita gunakan. </p><br><p>  Menggunakan operator <strong>komposit</strong> , lapisan isi warna akan "terpotong", dan hanya wilayah warna yang cocok dengan lapisan bayangan kami yang akan ditampilkan.  Kedua lapisan akan dicampur di tempat mereka berpotongan, mis.  warna abu-abu akan digunakan untuk mewarnai bayangan hitam kami. </p><br><p>  <strong>feComposite</strong>      ,    <strong>in</strong>  <strong>in2</strong> .   —    ,   —   .    ,    <strong>operator</strong> ,      : </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;feFlood flood-color="#bbb" result="COLOR"&gt;&lt;/feFlood&gt; &lt;feComposite in="COLOR" in2="DROP" operator="in" result="SHADOW"&gt;&lt;/feComposite&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  ,   <strong>feGaussianBlur</strong>   <strong>feFlood</strong>       .     : </p><br><p><img src="https://habrastorage.org/webt/_c/c7/an/_cc7an_zj43v7gv4jka--6mpnpi.png" alt="  "><br> <em>_7.   .</em> </p><br><p>  ,        ,       / .          .     ,      ,       ,          . </p><br><p>     SVG   <strong>feOffset</strong> .    <strong>in</strong>  <strong>result</strong>      : <strong>dx</strong>  <strong>dy</strong> ,   ,         X  Y . </p><br><p>   ,       ,  <strong>feMerge</strong> ,  ,           —  <strong>mergeNode</strong>       ,    <strong>mergeNode</strong>    ,  <strong>SourceGraphic</strong>    .     : </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;!-- Get the source alpha and blur it; we'll name the result "DROP" --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- flood the region with a ligh grey color; we'll name this layer "COLOR" --&gt; &lt;feFlood flood-color="#bbb" result="COLOR"&gt;&lt;/feFlood&gt; &lt;!-- Composite the DROP and COLOR layers together to colorize the shadow. The result is named "SHADOW" --&gt; &lt;feComposite in="COLOR" in2="DROP" operator="in" result="SHADOW"&gt;&lt;/feComposite&gt; &lt;!-- Move the SHADOW layer 20 pixels down and to the right. The new layer is now called "DROPSHADOW" --&gt; &lt;feOffset in="SHADOW" dx="20" dy="20" result="DROPSHADOW"&gt;&lt;/feOffset&gt; &lt;!-- Layer the DROPSHADOW and the Source Image, ensuring the image is positioned on top (remember: MergeNode order matters) --&gt; &lt;feMerge&gt; &lt;feMergeNode in="DROPSHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;!-- Apply the filter to the source image in the `filter` attribute --&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>      : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/qpoqwQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>         SVG,   SVG.  ,        . </p><br><h2 id="est-drugoy-sposob">   … </h2><br><p>  ,     .  ,         ,    ,      ,    , , . </p><br><p>     ,     ,  <strong>feFlood</strong> ,  ,  , ,      .    ,    .    ,    ,     , ,  - ,  , ,    . </p><br><p>         <strong>feColorMatrix</strong> ,  <strong>feComponentTransfer</strong> .   <strong>feComponentTransfer</strong>       ,    <strong>feColorMatrix</strong> ,     . </p><br><p>  <strong>feColorMatrix</strong>   .         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Una Kravet</a> ,        . </p><br><p>  ,        R(), G(), B()  A()              -.  ,       .     : </p><br><pre> <code class="plaintext hljs">&lt;filter id="myFilter"&gt; &lt;feColorMatrix type="matrix" values="R 0 0 0 0 0 G 0 0 0 0 0 B 0 0 0 0 0 A 0 "/&gt; &lt;/feColorMatrix&gt; &lt;/filter&gt;</code> </pre> <br><p>      ,      . </p><br><p>        ,     ,     RGB,     -   : </p><br><pre> <code class="plaintext hljs">&lt;filter id="filter"&gt; &lt;!-- Get the source alpha and blur it, --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- offset the drop shadow --&gt; &lt;feOffset in="SHADOW" dx="20" dy="20" result="DROPSHADOW"&gt;&lt;/feOffset&gt; &lt;!-- make the shadow translucent by reducing the alpha channel value to 0.3 --&gt; &lt;feColorMatrix type="matrix" in="DROPSHADOW" result="FINALSHADOW" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.3 0"&gt; &lt;/feColorMatrix&gt; &lt;!-- Merge the shadow and the source image --&gt; &lt;feMerge&gt; &lt;feMergeNode in="FINALHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt;</code> </pre> <br><p>     : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/opEZee" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>                   .         ,    .         ,         .  ,       ,   ,   ,   ,    .       ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> .   ,     ,  ,         .             . </p><br><p> ,     SVG-      ,            .  Tetap bersama kami. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439282/">https://habr.com/ru/post/id439282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439268/index.html">Bagaimana VR, AR, dan pencetakan 3D bekerja bersama: Pengalaman Konsep VR</a></li>
<li><a href="../id439270/index.html">Contoh parsing kode C ++ menggunakan libclang dengan Python</a></li>
<li><a href="../id439272/index.html">Notebook Jupyter di Netflix</a></li>
<li><a href="../id439278/index.html">ACS LCD saya - pengaman di dua baut</a></li>
<li><a href="../id439280/index.html">Trautonium: gelombang Jerman dalam sejarah synthesizer</a></li>
<li><a href="../id439286/index.html">Tentang analisis statis dalam semua kejujuran</a></li>
<li><a href="../id439288/index.html">SciPy, optimasi</a></li>
<li><a href="../id439290/index.html">Mempercepat kompilasi dalam Xcode saat swift</a></li>
<li><a href="../id439294/index.html">Tinjau terjemahan “Jika perangkat lunak dibuat dengan uang publik, kodenya harus terbuka”</a></li>
<li><a href="../id439296/index.html">Plat nomor Soviet dan kompleksitas Kolmogorov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>