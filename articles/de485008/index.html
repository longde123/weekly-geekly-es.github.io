<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💳 👩🏾‍✈️ 🌾 Schnelle Eigenschaftenverpackungen 👩🏾‍🔧 🍥 🌀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie SwiftUI verwendet haben, haben Sie wahrscheinlich auf Schlüsselwörter wie @ObservedObject, @EnvironmentObject, @FetchRequest usw. geachtet. P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnelle Eigenschaftenverpackungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/485008/"><p>  Wenn Sie SwiftUI verwendet haben, haben Sie wahrscheinlich auf Schlüsselwörter wie @ObservedObject, @EnvironmentObject, @FetchRequest usw. geachtet.  Property Wrapper (im Folgenden als "Property Wrapper" bezeichnet) ist eine neue Funktion von Swift 5.1.  In diesem Artikel erfahren Sie, woher alle Konstruktionen von @ stammen und wie Sie sie in SwiftUI und in Ihren Projekten verwenden. </p><br><img src="https://habrastorage.org/webt/vp/5r/4c/vp5r4ct4rymlk9mzxdlvkb73uqe.jpeg"><br><p>  <em>Übersetzt von: Evgeny Zavozhansky, Entwickler von FunCorp.</em> </p><br><p>  <em>Hinweis:</em> Zum Zeitpunkt der Erstellung der Übersetzung hatte ein Teil des Quellcodes des Originalartikels aufgrund von Änderungen in der Sprache seine Relevanz verloren, sodass einige Codebeispiele absichtlich ersetzt wurden. <a name="habracut"></a></p><br><p> Property Wrapper wurden erstmals im März 2019 in <a href="https://forums.swift.org/t/pitch-property-delegates/21895" title="Schnell">Swift-</a> Foren vorgestellt, einige Monate vor der Ankündigung von SwiftUI.  In seinem ursprünglichen Vorschlag beschrieb Douglas Gregor, ein Mitglied des Swift Core-Teams, dieses Konstrukt (damals als Eigenschaftendelegierte bezeichnet) als "eine benutzerfreundliche Verallgemeinerung der Funktionalität, die derzeit von einem Sprachkonstrukt wie z. B. <code>lazy</code> bereitgestellt wird". </p><br><p>  Wenn eine Eigenschaft mit dem Schlüsselwort <code>lazy</code> deklariert wird, bedeutet dies, dass sie beim ersten Zugriff initialisiert wird.  Beispielsweise könnte eine verzögerte Eigenschaftsinitialisierung unter Verwendung einer privaten Eigenschaft implementiert werden, auf die über eine berechnete Eigenschaft zugegriffen wird.  Die Verwendung des Schlüsselworts " <code>lazy</code> erleichtert dies jedoch erheblich. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Structure</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//      lazy    lazy var deferred = …    //            private var _deferred: Type?    var deferred: Type {        get {            if let value = _deferred { return value }            let initialValue = …            _deferred = initialValue            return initialValue        }        set {            _deferred = newValue        }    } }</span></span></code> </pre> <br><p>  <a href="" title="SE-0258: Eigenschaftenwrapper">SE-0258: Property Wrapper</a> erklärt den Entwurf und die Implementierung von Property Wrappern perfekt.  Anstatt zu versuchen, die Beschreibung in der offiziellen Dokumentation zu verbessern, sollten Sie einige Beispiele betrachten, die mit Eigenschaftenwrappern implementiert werden können: </p><br><ul><li>  Einschränkung von Eigenschaftswerten; <br></li><li>  Umwandlung von Werten beim Ändern von Eigenschaften; <br></li><li>  Gleichheitssemantik ändern und Eigenschaften vergleichen; <br></li><li>  Eigenschaftenzugriffsprotokollierung. <br></li></ul><br><h2>  Eigenschaftswerte begrenzen </h2><br><p>  <a href="" title="SE-0258">SE-0258: Property Wrapper</a> enthält mehrere praktische Beispiele, darunter <code>@Clamping</code> , <code>@Copying</code> , <code>@Atomic</code> , <code>@ThreadSpecific</code> , <code>@Box</code> , <code>@UserDefault</code> .  Betrachten Sie den <code>@Clamping</code> Wrapper, mit dem Sie den Maximal- oder Minimalwert einer Eigenschaft begrenzen können. </p><br><pre> <code class="swift hljs">@propertyWrapper <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clamping</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&gt; </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">Value</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> range: <span class="hljs-type"><span class="hljs-type">ClosedRange</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Value</span></span>&gt;    <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(initialValue value: <span class="hljs-type"><span class="hljs-type">Value</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> range: <span class="hljs-type"><span class="hljs-type">ClosedRange</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Value</span></span>&gt;) {        <span class="hljs-built_in"><span class="hljs-built_in">precondition</span></span>(range.<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>(value))        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.range = range    }    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedValue: <span class="hljs-type"><span class="hljs-type">Value</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { value }        <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { value = <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(range.lowerBound, newValue), range.upperBound) }    } }</code> </pre> <br><p>  <code>@Clamping</code> kann beispielsweise der Säuregehalt einer Lösung modelliert werden, deren Wert einen Wert von 0 bis 14 annehmen kann. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Solution</span></span></span><span class="hljs-class"> </span></span>{    @<span class="hljs-type"><span class="hljs-type">Clamping</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pH: <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-number"><span class="hljs-number">7.0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> carbonicAcid = <span class="hljs-type"><span class="hljs-type">Solution</span></span>(pH: <span class="hljs-number"><span class="hljs-number">4.68</span></span>)</code> </pre> <br><p>  Wenn Sie versuchen, den pH-Wert außerhalb des Bereichs von <code>(0...14)</code> einzustellen, nimmt die Eigenschaft den Wert an, der dem minimalen oder maximalen Intervall am nächsten liegt. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> superDuperAcid = <span class="hljs-type"><span class="hljs-type">Solution</span></span>(pH: -<span class="hljs-number"><span class="hljs-number">1</span></span>) superDuperAcid.pH <span class="hljs-comment"><span class="hljs-comment">// 0</span></span></code> </pre> <br><p>  Eigenschaftenwrapper können verwendet werden, um andere Eigenschaftenwrapper zu implementieren.  Beispielsweise begrenzt der Wrapper <code>@UnitInterval</code> den Wert einer Eigenschaft mithilfe von <code>@Clamping(0...1)</code> auf das Intervall <code>@Clamping(0...1)</code> : </p><br><pre> <code class="swift hljs">@propertyWrapper <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnitInterval</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FloatingPoint</span></span></span><span class="hljs-class">&gt; </span></span>{    @<span class="hljs-type"><span class="hljs-type">Clamping</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">1</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedValue: <span class="hljs-type"><span class="hljs-type">Value</span></span> = .zero    <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(initialValue value: <span class="hljs-type"><span class="hljs-type">Value</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrappedValue = value    } }</code> </pre> <br><h3>  Ähnliche Ideen </h3><br><ul><li>  <code>@Positive</code> / <code>@NonNegative</code> gibt an, dass der Wert entweder eine positive oder eine negative Zahl sein kann. </li><li>  <code>@NonZero</code> gibt an, dass der Wert der Eigenschaft nicht 0 sein kann. </li><li>  <code>@Validated</code> oder <code>@Whitelisted</code> / <code>@Blacklisted</code> schränkt den Wert einer Eigenschaft auf bestimmte Werte ein. </li></ul><br><h2>  Konvertieren von Werten beim Ändern von Eigenschaften </h2><br><p>  Das Validieren von Textfeldwerten bereitet Anwendungsentwicklern ständig Kopfzerbrechen.  Es gibt so viele Dinge zu beachten: von Plattitüden wie der Codierung bis zu böswilligen Versuchen, einen Code über ein Textfeld einzugeben.  Verwenden Sie einen Eigenschaftenwrapper, um Leerzeichen zu entfernen, die ein Benutzer am Anfang und Ende einer Zeile eingegeben hat. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation let url = URL(string: " https:<span class="hljs-comment"><span class="hljs-comment">//habrahabr.ru") // nil let date = ISO8601DateFormatter().date(from: " 2019-06-24") // nil let words = " Hello, world!".components(separatedBy: .whitespaces) words.count // 3</span></span></code> </pre> <br><p>  <code>Foundation</code> bietet die <code>trimmingCharacters(in:)</code> -Methode an, mit der Sie Leerzeichen am Anfang und Ende einer Zeile entfernen können.  Sie können diese Methode immer dann aufrufen, wenn Sie die Richtigkeit der Eingabe gewährleisten müssen, dies ist jedoch nicht sehr praktisch.  Hierfür können Sie den Property Wrapper verwenden. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation @propertyWrapper struct Trimmed {    private(set) var value: String = ""    var wrappedValue: String {        get { return value }        set { value = newValue.trimmingCharacters(in: .whitespacesAndNewlines) }    }    init(initialValue: String) {        self.wrappedValue = initialValue    } }</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span></span>{    @<span class="hljs-type"><span class="hljs-type">Trimmed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span>    @<span class="hljs-type"><span class="hljs-type">Trimmed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> quine = <span class="hljs-type"><span class="hljs-type">Post</span></span>(title: <span class="hljs-string"><span class="hljs-string">" Swift Property Wrappers "</span></span>, body: <span class="hljs-string"><span class="hljs-string">"…"</span></span>) quine.title <span class="hljs-comment"><span class="hljs-comment">// "Swift Property Wrappers" —        quine.title = "   @propertyWrapper " // "@propertyWrapper"</span></span></code> </pre> <br><h3>  Ähnliche Ideen </h3><br><ul><li>  <code>@Transformed</code> wendet die <a href="https://developer.apple.com/documentation/foundation/nsstring/1407787-applyingtransform" title="ICU-Konvertierung">ICU-Konvertierung</a> auf die <code>@Transformed</code> . </li><li>  <code>@Rounded</code> / <code>@Truncated</code> rundet oder <code>@Truncated</code> einen Zeichenfolgenwert ab. </li></ul><br><h2>  Ändern Sie die Semantik von Gleichheit und Eigenschaftsvergleich </h2><br><p>  In Swift sind zwei Saiten gleich, wenn sie <a href="https://unicode.org/reports/tr15/" title="kanonisch gleichwertig">kanonisch äquivalent sind</a> , d. H.  enthalten die gleichen Zeichen.  Angenommen, wir möchten, dass die Zeichenfolgeneigenschaften gleich sind und nicht zwischen Groß- und Kleinschreibung unterscheiden. </p><br><p>  <code>@CaseInsensitive</code> implementiert einen Wrapper für Eigenschaften vom Typ <code>String</code> oder <code>SubString</code> . </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation @propertyWrapper struct CaseInsensitive&lt;Value: StringProtocol&gt; {    var wrappedValue: Value } extension CaseInsensitive: Comparable {    private func compare(_ other: CaseInsensitive) -&gt; ComparisonResult {        wrappedValue.caseInsensitiveCompare(other.wrappedValue)    }    static func == (lhs: CaseInsensitive, rhs: CaseInsensitive) -&gt; Bool {        lhs.compare(rhs) == .orderedSame    }    static func &lt; (lhs: CaseInsensitive, rhs: CaseInsensitive) -&gt; Bool {        lhs.compare(rhs) == .orderedAscending    }    static func &gt; (lhs: CaseInsensitive, rhs: CaseInsensitive) -&gt; Bool {        lhs.compare(rhs) == .orderedDescending    } }</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hello: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">HELLO</span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"HELLO"</span></span> hello == <span class="hljs-type"><span class="hljs-type">HELLO</span></span> <span class="hljs-comment"><span class="hljs-comment">// false CaseInsensitive(wrappedValue: hello) == CaseInsensitive(wrappedValue: HELLO) // true</span></span></code> </pre> <br><h3>  Ähnliche Ideen </h3><br><ul><li>  <code>@Approximate</code> für einen groben Vergleich von Eigenschaften des Typs Double oder Float. </li><li>  <code>@Ranked</code> für Eigenschaften, deren Werte in der <code>@Ranked</code> Reihenfolge sind (z. B. der Rang der Spielkarten). </li></ul><br><h2>  Protokollierung des Eigenschaftenzugriffs </h2><br><p>  <code>@Versioned</code> können Sie zugewiesene Werte abfangen und sich merken, wann sie festgelegt wurden. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation @propertyWrapper struct Versioned&lt;Value&gt; {    private var value: Value    private(set) var timestampedValues: [(Date, Value)] = []    var wrappedValue: Value {        get { value }        set {            defer { timestampedValues.append((Date(), value)) }            value = newValue        }    }    init(initialValue value: Value) {        self.wrappedValue = value    } }</code> </pre> <br><p>  Mit der <code>ExpenseReport</code> Klasse können <code>ExpenseReport</code> Zeitstempel der Verarbeitungszustände der Spesenabrechnung speichern. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpenseReport</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> submitted, received, approved, denied }    @<span class="hljs-type"><span class="hljs-type">Versioned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: <span class="hljs-type"><span class="hljs-type">State</span></span> = .submitted }</code> </pre> <br><p>  Das obige Beispiel zeigt jedoch eine schwerwiegende Einschränkung in der aktuellen Implementierung von Eigenschaftenwrappern, die sich aus der Swift-Einschränkung ergibt: Eigenschaften können keine Ausnahmen auslösen.  Wenn wir <code>@Versioned</code> eine Einschränkung hinzufügen <code>@Versioned</code> , um zu verhindern, dass der Wert nach dem <code>.approved</code> des Werts <code>.denied</code> in <code>.approved</code> <code>.denied</code> , ist <code>fatalError()</code> die beste Option, die für echte Anwendungen nicht geeignet ist. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpenseReport</span></span></span><span class="hljs-class"> </span></span>{    @<span class="hljs-type"><span class="hljs-type">Versioned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: <span class="hljs-type"><span class="hljs-type">State</span></span> = .submitted {        <span class="hljs-keyword"><span class="hljs-keyword">willSet</span></span> {            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newValue == .approved,                $state.timestampedValues.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0.1</span></span> }.<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>(.denied)            {                <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>)            }        }    } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tripExpenses = <span class="hljs-type"><span class="hljs-type">ExpenseReport</span></span>() tripExpenses.state = .denied tripExpenses.state = .approved <span class="hljs-comment"><span class="hljs-comment">// Fatal error: «»   .</span></span></code> </pre> <br><h3>  Ähnliche Ideen </h3><br><ul><li>  <code>@Audited</code> , <code>@Audited</code> Eigenschaftenzugriff zu <code>@Audited</code> . </li><li>  <code>@UserDefault</code> , um den Mechanismus zum Lesen und Speichern von Daten in <code>UserDefaults</code> . </li></ul><br><h2>  Einschränkungen </h2><br><h3>  Eigenschaften können keine Ausnahmen auslösen </h3><br><p>  Wie bereits erwähnt, können Eigenschafts-Wrapper nur wenige Methoden zum Verarbeiten ungültiger Werte verwenden: </p><br><ul><li>  ignoriere sie; <br></li><li>  Beenden Sie die Anwendung mit fatalError (). <br></li></ul><br><h3>  Umbrochene Eigenschaften können nicht mit dem Attribut `typealias` gekennzeichnet werden </h3><br><p>  Das <code>@UnitInterval</code> Beispiel <code>@UnitInterval</code> , dessen Eigenschaft durch das Intervall <code>(0...1)</code> , kann nicht als deklariert werden </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">UnitInterval</span></span> = <span class="hljs-type"><span class="hljs-type">Clamping</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><h3>  Beschränkung der Verwendung von Zusammensetzungen aus mehreren Eigenschaftenverpackungen </h3><br><p>  Das Erstellen von Eigenschaftenwrappern ist keine kommutative Operation: Die Reihenfolge der Deklaration wirkt sich auf das Verhalten aus.  Stellen Sie sich ein Beispiel vor, in dem die Eigenschaft slug, die die URL eines Blogposts darstellt, normalisiert ist.  In diesem Fall hängt das Ergebnis der Normalisierung davon ab, wann die Leerzeichen vor oder nach dem Entfernen von Leerzeichen durch Bindestriche ersetzt werden.  Daher wird eine Komposition mehrerer Property Wrapper derzeit nicht unterstützt. </p><br><pre> <code class="swift hljs">@propertyWrapper <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dasherized</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedValue: <span class="hljs-type"><span class="hljs-type">String</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { value }        <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { value = newValue.replacingOccurrences(of: <span class="hljs-string"><span class="hljs-string">" "</span></span>, with: <span class="hljs-string"><span class="hljs-string">"-"</span></span>) }    }    <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(initialValue: <span class="hljs-type"><span class="hljs-type">String</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrappedValue = initialValue    } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span></span>{    …    @<span class="hljs-type"><span class="hljs-type">Dasherized</span></span> @<span class="hljs-type"><span class="hljs-type">Trimmed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slug: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-comment"><span class="hljs-comment">// error: multiple property wrappers are not supported }</span></span></code> </pre> <br><p>  Diese Einschränkung kann jedoch durch die Verwendung von Wrappern für verschachtelte Eigenschaften umgangen werden. </p><br><pre> <code class="swift hljs">@propertyWrapper <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrimmedAndDasherized</span></span></span><span class="hljs-class"> </span></span>{    @<span class="hljs-type"><span class="hljs-type">Dasherized</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedValue: <span class="hljs-type"><span class="hljs-type">String</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { value }        <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { value = newValue.trimmingCharacters(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: .whitespacesAndNewlines) }    }    <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(initialValue: <span class="hljs-type"><span class="hljs-type">String</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrappedValue = initialValue    } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span></span>{    …    @<span class="hljs-type"><span class="hljs-type">TrimmedAndDasherized</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slug: <span class="hljs-type"><span class="hljs-type">String</span></span> }</code> </pre> <br><h3>  Andere Einschränkungen für Eigenschaftenwrapper </h3><br><ul><li>  Kann nicht innerhalb des Protokolls verwendet werden. </li><li>  Eine Wrapper-Eigenschaftsinstanz kann nicht in <code>enum</code> deklariert werden. </li><li>  Eine in einer Klasse deklarierte umschlossene Eigenschaft kann nicht von einer anderen Eigenschaft überschrieben werden. </li><li>  Eine <code>@NSCopying</code> Eigenschaft kann nicht <code>lazy</code> , <code>@NSCopying</code> , <code>@NSManaged</code> , <code>weak</code> oder nicht im <code>unowned</code> . </li><li>  Eine umschlossene Eigenschaft sollte die einzige in ihrer Definition sein (d. H. <code>@Lazy var (x, y) = /* ... */</code> ). </li><li>  Für eine umschlossene Eigenschaft kann kein <code>getter</code> und <code>setter</code> definiert werden. </li><li>  Die Typen der <code>wrappedValue</code> Eigenschaft und der <code>wrappedValue</code> Variablen in <code>init(wrappedValue:)</code> müssen dieselbe Zugriffsebene haben wie der Wrapper-Typ der Eigenschaft. </li><li>  Die type-Eigenschaft von <code>projectedValue</code> muss dieselbe Zugriffsebene wie der Wrapper-Typ der Eigenschaft haben. </li><li>  <code>init()</code> muss dieselbe Zugriffsebene wie der Property-Wrapper-Typ haben. </li></ul><br><p>  Lassen Sie uns zusammenfassen.  Eigenschaftenwrapper in Swift ermöglichen Bibliotheksautoren den Zugriff auf das allgemeine Verhalten, das zuvor für Sprachfunktionen reserviert war.  Ihr Potenzial zur Verbesserung der Lesbarkeit und zur Reduzierung der Codekomplexität ist riesig, und wir haben die Funktionen dieses Tools nur oberflächlich untersucht. </p><br><p>  Verwenden Sie Property Wrapper in Ihren Projekten?  Schreibe in die Kommentare! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485008/">https://habr.com/ru/post/de485008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484992/index.html">Schöner in großen Projekten: Verbringen Sie 20 Minuten mit dem Einrichten, vergessen Sie die Formatierung für immer</a></li>
<li><a href="../de484996/index.html">Virtuelle Telefonanlage Beeline. Was der Manager Ihnen nicht sagen wird</a></li>
<li><a href="../de485000/index.html">Ist der US-Verkehr teuer oder nicht?</a></li>
<li><a href="../de485002/index.html">Flattern BloC-Muster + Provider + Tests + erinnere mich an den Zustand</a></li>
<li><a href="../de485006/index.html">Buch (des Seins?). Reflexionen über die Natur des Geistes. Teil II</a></li>
<li><a href="../de485010/index.html">Weine nicht, Mädchen! Antwort an den Autor mit vc.ru auf den Brief über Habré</a></li>
<li><a href="../de485012/index.html">Verwendung von Control Inversion in JavaScript und Reactjs zur Vereinfachung der Codebehandlung</a></li>
<li><a href="../de485014/index.html">Soll ich mich über Interviews beschweren?</a></li>
<li><a href="../de485016/index.html">Verwaltete Datenbanken bei Selectel: Willkommen bei Beta</a></li>
<li><a href="../de485018/index.html">Schreiben von Shadern mit Code in Unity LWRP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>