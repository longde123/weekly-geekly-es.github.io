<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíî üì¥ üßöüèΩ √úbertragen Sie 30.000 Codezeilen von Flow nach TypeScript üå∫ üôç üëÅ‚Äçüó®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben k√ºrzlich 30.000 Zeilen JavaScript-Code von unserem MemSQL Studio- System von Flow nach TypeScript verschoben . In diesem Artikel werde ich e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úbertragen Sie 30.000 Codezeilen von Flow nach TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436554/">  Wir haben k√ºrzlich 30.000 Zeilen JavaScript-Code von unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MemSQL Studio-</a> System von Flow nach TypeScript <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verschoben</a> .  In diesem Artikel werde ich erkl√§ren, warum wir die Codebasis portiert haben, wie es passiert ist und was passiert ist. <br><br>  <i>Haftungsausschluss: Mein Ziel ist es, Flow √ºberhaupt nicht zu kritisieren.</i>  <i>Ich bewundere das Projekt und denke, dass in der JavaScript-Community gen√ºgend Platz f√ºr beide Optionen zur Typpr√ºfung vorhanden ist.</i>  <i>Am Ende wird jeder w√§hlen, was am besten zu ihm passt.</i>  <i>Ich hoffe aufrichtig, dass der Artikel bei dieser Wahl helfen wird.</i> <br><br>  Zun√§chst werde ich Sie auf den neuesten Stand bringen.  Wir bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MemSQL sind</a> gro√üe Fans von statischer und starker JavaScript-Typisierung, um h√§ufige Probleme mit dynamischer und schwacher Typisierung zu vermeiden. <br><a name="habracut"></a><br>  Rede √ºber h√§ufige Probleme: <br><br><ol><li>  Tippfehler in der Laufzeit aufgrund der Tatsache, dass die verschiedenen Teile des Codes bei impliziten Typen nicht konsistent sind. </li><li>  Es wird zu viel Zeit damit verbracht, Tests f√ºr so triviale Dinge wie das √úberpr√ºfen von Typparametern zu schreiben (das √úberpr√ºfen der Laufzeit erh√∂ht auch die Gr√∂√üe des Pakets). </li><li> Es gibt einen Mangel an Editor / IDE-Integration, da es ohne statische Typisierung viel schwieriger ist, die Funktion "Zur Definition springen", das mechanische Refactoring und andere Funktionen zu implementieren. </li><li>  Es gibt keine M√∂glichkeit, Code um Datenmodelle herum zu schreiben, dh zuerst Datentypen zu entwerfen, und dann schreibt sich der Code im Grunde selbst. </li></ol><br>  Dies sind nur einige der Vorteile der statischen Typisierung, die in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√ºrzlich erschienenen Artikel √ºber Flow</a> n√§her aufgef√ºhrt sind. <br><br>  Anfang 2016 haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tcomb</a> implementiert, um eine Art Sicherheit zur Laufzeit eines unserer internen JavaScript-Projekte zu implementieren (Haftungsausschluss: Ich habe mich nicht mit diesem Projekt befasst).  Obwohl die Laufzeitpr√ºfung manchmal n√ºtzlich ist, bietet sie nicht einmal alle Vorteile der statischen Typisierung (die Kombination aus statischer Typisierung und Typpr√ºfung zur Laufzeit kann in bestimmten F√§llen geeignet sein. Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">io-ts</a> k√∂nnen Sie dies mit tcomb und TypeScript tun, obwohl ich es noch nie versucht habe )  Um dies zu verstehen, haben wir uns entschlossen, Flow f√ºr ein anderes Projekt zu implementieren, das wir 2016 gestartet haben.  Zu dieser Zeit schien Flow eine gute Wahl zu sein: <br><br><ul><li>  Unterst√ºtzung von Facebook, das bei der Entwicklung von React und dem Wachstum der Community hervorragende Arbeit geleistet hat (sie haben auch React <i>with</i> Flow entwickelt). </li><li>  Etwa das gleiche JavaScript-Entwicklungs√∂kosystem.  Es war be√§ngstigend, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Babel</a> f√ºr tsc (den TypeScript-Compiler) aufzugeben, weil wir die Flexibilit√§t verloren hatten, zu einer anderen Typpr√ºfung zu wechseln (offensichtlich hat sich die Situation seitdem ge√§ndert). </li><li>  Es ist nicht erforderlich, die gesamte Codebasis zu typisieren (wir wollten uns vor dem All-In eine Vorstellung von statisch typisiertem JavaScript machen), sondern nur einen Teil der Dateien.  Bitte beachten Sie, dass sowohl Flow als auch TypeScript dies jetzt zulassen. </li><li>  TypeScript (zu dieser Zeit) fehlten einige der Grundfunktionen, die jetzt verf√ºgbar sind. Dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sind Nachschlagetypen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardparameter f√ºr generische Typen</a> usw. </li></ul><br>  Als wir Ende 2017 mit der Arbeit an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MemSQL Studio</a> begannen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wollten</a> wir die Typen der gesamten Anwendung behandeln (sie ist vollst√§ndig in JavaScript geschrieben: Sowohl das Frontend als auch das Backend werden im Browser ausgef√ºhrt).  Wir haben Flow als Werkzeug genommen, das wir in der Vergangenheit erfolgreich eingesetzt haben. <br><br>  Aber meine Aufmerksamkeit wurde auf <a href="">Babel 7 mit TypeScript-Unterst√ºtzung</a> gelenkt.  Diese Version bedeutete, dass f√ºr die Umstellung auf TypeScript kein √úbergang mehr zum gesamten TypeScript-√ñkosystem erforderlich war und Sie Babel weiterhin f√ºr JavaScript verwenden konnten.  Noch wichtiger ist, dass wir <b>TypeScript nur zur Typpr√ºfung verwenden</b> k√∂nnen und nicht als vollwertige ‚ÄûSprache‚Äú. <br><br>  Pers√∂nlich glaube ich, dass die Trennung der Typpr√ºfung vom Codegenerator eine elegantere Art der statischen (und starken) Eingabe in JavaScript ist, weil: <br><br><ol><li>  Wir teilen die Probleme des Codes und der Eingabe.  Dies reduziert die Stopps der Typpr√ºfung und beschleunigt die Entwicklung: Wenn die Typpr√ºfung aus irgendeinem Grund langsam ist, wird der Code weiterhin korrekt generiert (wenn Sie tsc mit Babel verwenden, k√∂nnen Sie ihn so konfigurieren, dass er dasselbe tut). </li><li>  Babel hat gro√üartige Plugins und Funktionen, die der TypeScript-Generator nicht hat.  Mit Babel k√∂nnen Sie beispielsweise unterst√ºtzte Browser angeben und geben automatisch Code f√ºr diese aus.  Dies ist eine sehr komplexe Funktion und es macht keinen Sinn, sie in zwei verschiedenen Projekten gleichzeitig zu unterst√ºtzen. </li><li>  Ich mag JavaScript als Programmiersprache (mit Ausnahme des Fehlens statischer Typisierung), und ich habe keine Ahnung, wie viel TypeScript existieren wird, w√§hrend ich seit vielen Jahren an ECMAScript glaube.  Daher schreibe und "denke" ich lieber in JavaScript (beachten Sie, dass ich "Flow verwenden" oder "TypeScript verwenden" anstelle von "In Flow schreiben" oder "TypeScript" sage, da ich sie immer mit Werkzeugen und nicht mit Programmiersprachen darstelle). </li></ol><br>  Dieser Ansatz hat nat√ºrlich einige Nachteile: <br><br><ol><li>  Der TypeScript-Compiler kann theoretisch typbasierte Optimierungen durchf√ºhren, aber hier verlieren wir diese M√∂glichkeit. </li><li>  Die Konfiguration des Projekts ist etwas komplizierter, da die Anzahl der Tools und Abh√§ngigkeiten zunimmt.  Ich denke, das ist ein relativ schwaches Argument: Ein Haufen Babel und Flow hat uns nie im Stich gelassen. </li></ol><br><h1>  TypeScript als Alternative zu Flow </h1><br>  Ich bemerkte ein wachsendes Interesse an TypeScript in der JavaScript-Community: sowohl online als auch bei Entwicklern.  Sobald ich herausfand, dass Babel 7 TypeScript unterst√ºtzt, begann ich sofort, m√∂gliche √úbergangsoptionen zu untersuchen.  Dar√ºber hinaus sind wir auf einige der Nachteile von Flow gesto√üen: <br><br><ol><li>  Geringere Qualit√§t der Editor / IDE-Integration (im Vergleich zu TypeScript).  Nuclide, Facebooks eigene IDE mit der besten Integration, ist bereits veraltet. </li><li>  Eine kleinere Community, dh weniger Typdefinitionen f√ºr verschiedene Bibliotheken, und sie sind von geringerer Qualit√§t (derzeit hat das DefinitelyTyped-Repository 19 682 GitHub-Sterne und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flow-</a> Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-</a> Repository nur 3070). </li><li>  Fehlen eines √∂ffentlichen Entwicklungsplans und schlechte Interaktion zwischen dem Flow-Team auf Facebook und der Community.  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Kommentar</a> eines Facebook-Mitarbeiters lesen, um die Situation zu verstehen. </li><li>  Hoher Speicherverbrauch und h√§ufige Lecks - f√ºr einige unserer Entwickler hat Flow manchmal fast 10 GB RAM beansprucht. </li></ol><br>  Nat√ºrlich sollten Sie untersuchen, wie TypeScript zu uns passt.  Dies ist eine sehr komplexe Frage: Das Studium des Themas beinhaltete ein gr√ºndliches Lesen der Dokumentation, was zu dem Verst√§ndnis beitrug, dass es f√ºr jede Flow-Funktion ein gleichwertiges TypeScript gibt.  Dann habe ich den √∂ffentlichen TypeScript-Entwicklungsplan untersucht und die f√ºr die Zukunft geplanten Funktionen (z. B. teilweise Ableitung von Typargumenten, die wir in Flow verwendet haben) sehr gemocht. <br><br><h1>  √úbertragen Sie mehr als 30.000 Codezeilen von Flow nach TypeScript </h1><br>  F√ºr den Anfang sollten Sie Babel von 6 auf 7 aktualisieren. Diese einfache Aufgabe dauerte 16 Mannstunden, da wir beschlossen, Webpack 3 auf 4 gleichzeitig zu aktualisieren. Einige veraltete Abh√§ngigkeiten in unserem Code erschwerten die Aufgabe.  Die √ºberwiegende Mehrheit der JavaScript-Projekte wird solche Probleme nicht haben. <br><br>  Danach haben wir die Babel Flow-Voreinstellung durch die neue TypeScript-Voreinstellung ersetzt und dann zum ersten Mal den TypeScript-Compiler f√ºr alle unsere mit Flow geschriebenen Quellen gestartet.  Das Ergebnis sind <b>8245-Syntaxfehler</b> (tsc CLI zeigt keine echten Fehler f√ºr das Projekt an, bis alle Syntaxfehler behoben wurden). <br><br>  Anfangs erschreckte uns diese Zahl (sehr), aber wir stellten schnell fest, dass die meisten Fehler darauf zur√ºckzuf√ºhren waren, dass TypeScript keine .js-Dateien unterst√ºtzte.  Nachdem ich das Thema studiert hatte, erfuhr ich, dass TypeScript-Dateien entweder mit .ts oder .tsx enden sollten (wenn sie JSX haben).  Dies scheint mir eine klare Unannehmlichkeit zu sein.  Um nicht √ºber das Vorhandensein / Fehlen von JSX nachzudenken, habe ich einfach alle Dateien in .tsx umbenannt. <br><br>  Es verbleiben ca. 4.000 Syntaxfehler.  Die meisten davon beziehen sich auf den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typimport</a> , der mit TypeScript einfach durch Import ersetzt werden kann, sowie auf den Unterschied in der Bezeichnung von Objekten ( <code>{||}</code> anstelle von <code>{}</code> ).  Wir haben schnell ein paar regul√§re Ausdr√ºcke angewendet und 414 Syntaxfehler hinterlassen.  Alles andere musste manuell repariert werden: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der existenzielle Typ</a> , mit dem wir teilweise Argumente eines generischen Typs ableiten, sollte durch explizite oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unbekannte</a> Argumente ersetzt werden, um TypeScript mitzuteilen, dass einige Argumente unwichtig sind. </li><li>  Type <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">$ Keys</a> und andere erweiterte Flow-Typen haben in TypeScript eine andere Syntax (z. B. entspricht <code>$Shape‚Äú‚Äù</code> <code>Partial‚Äú‚Äù</code> in TypeScript). </li></ul><br>  Nachdem wir alle Syntaxfehler korrigiert hatten, sagte tsc schlie√ülich, wie viele echte Typfehler in unserer Codebasis nur etwa 1300 sind. Jetzt mussten wir uns hinsetzen und entscheiden, ob wir fortfahren wollten oder nicht.  Wenn die Migration Wochen dauert, ist es schlie√ülich am besten, auf Flow zu bleiben.  Wir haben jedoch beschlossen, dass die Code-Portierung weniger als eine Woche Arbeit eines Ingenieurs erfordert, was durchaus akzeptabel ist. <br><br>  Bitte beachten Sie, dass ich w√§hrend der Migration alle Arbeiten an dieser Codebasis einstellen musste.  Parallel dazu k√∂nnen Sie neue Projekte starten - aber Sie m√ºssen m√∂glicherweise Hunderte von Typfehlern in vorhandenem Code ber√ºcksichtigen, was nicht einfach ist. <br><br><h1>  Was f√ºr Fehler? </h1><br>  TypeScript und Flow verarbeiten JavaScript-Code auf viele Arten.  Daher ist Flow in Bezug auf einige Dinge strenger und TypeScript in Bezug auf andere.  Ein tiefer Vergleich der beiden Systeme wird sehr lang sein. Schauen Sie sich also nur einige Beispiele an. <br><br>  Hinweis: Alle Links zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TypeScript-Sandbox</a> setzen "strenge" Parameter voraus.  Wenn Sie einen Link freigeben, werden diese Optionen leider nicht in der URL gespeichert.  Daher m√ºssen sie manuell festgelegt werden, nachdem ein Link zur Sandbox aus diesem Artikel ge√∂ffnet wurde. <br><br><h3>  invariant.js </h3><br>  Die <code>invariant</code> Funktion war in unserem Quellcode sehr verbreitet.  Nur um die Dokumentation zu zitieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> invariant = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'invariant'</span></span>); invariant(someTruthyVal, <span class="hljs-string"><span class="hljs-string">'This will not throw'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// No errors invariant(someFalseyVal, 'This will throw an error with this message'); // Error raised: Invariant Violation: This will throw an error with this message</span></span></code> </pre> <br>  Die Idee ist klar: Eine einfache Funktion, die unter bestimmten Bedingungen einen Fehler ausl√∂st.  Mal sehen, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">man es</a> in Flow <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implementiert und verwendet</a> : <br><br><pre> <code class="javascript hljs">type Maybe&lt;T&gt; = T | <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invariant</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">condition: boolean, message: string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!condition) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(message); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: Maybe&lt;number&gt;, c: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { invariant(x !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-string"><span class="hljs-string">"When c is positive, x should never be undefined"</span></span>); (x + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// works because x has been refined to "number" } }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laden Sie nun dasselbe Snippet in TypeScript</a> .  Wie Sie dem Link entnehmen k√∂nnen, gibt TypeScript einen Fehler aus, da nicht verstanden werden kann, dass <code>x</code> nach der letzten Zeile garantiert nicht <code>undefined</code> bleibt.  Dies ist eigentlich ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bekanntes Problem</a> - TypeScript wei√ü (vorerst) nicht, wie diese Folgerung √ºber eine Funktion durchgef√ºhrt werden soll.  Dies ist jedoch eine sehr h√§ufige Vorlage in unserer Codebasis, daher musste ich jede invariante Instanz (mehr als 150 Teile) manuell durch einen anderen Code ersetzen, der sofort einen Fehler ausgibt: <br><br><pre> <code class="javascript hljs">type Maybe&lt;T&gt; = T | <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: Maybe&lt;number&gt;, c: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"When c is positive, x should never be undefined"</span></span>); } (x + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// works because x has been refined to "number" } }</span></span></code> </pre> <br>  Nicht wirklich im Vergleich zu <code>invariant</code> , aber kein so wichtiges Thema. <br><br><h3>  $ ExpectError vs @ ts-ignore </h3><br>  Flow hat eine sehr interessante Funktion, √§hnlich wie <code>@ts-ignore</code> , au√üer dass es einen Fehler ausl√∂st, wenn die n√§chste Zeile <b>kein</b> Fehler ist.  Dies ist sehr n√ºtzlich, um ‚ÄûTypentests‚Äú zu schreiben, die sicherstellen, dass bei der Typpr√ºfung (ob TypeScript oder Flow) bestimmte Typfehler festgestellt werden. <br><br>  Leider hat TypeScript keine solche Funktion, so dass unsere Tests an Wert verloren haben.  Ich freue mich darauf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, diese Funktion in TypeScript</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implementieren</a> . <br><br><h3>  Generische Typfehler und Typinferenz </h3><br>  Oft erlaubt TypeScript expliziteren Code als Flow, wie in diesem Beispiel: <br><br><pre> <code class="javascript hljs">type Leaf = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: string; port: number; type: <span class="hljs-string"><span class="hljs-string">"LEAF"</span></span>; }; type Aggregator = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: string; port: number; type: <span class="hljs-string"><span class="hljs-string">"AGGREGATOR"</span></span>; } type MemsqlNode = Leaf | Aggregator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">leaves: Array&lt;Leaf&gt;, aggregators: Array&lt;Aggregator&gt;</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemsqlNode</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// The next line errors because you cannot concat aggregators to leaves. return leaves.concat(aggregators); }</span></span></code> </pre> <br>  Flow <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">leitet den Typ leaf.concat (Aggregatoren) als Array &lt;Leaf | ab</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aggregator&gt;</a> , der dann in <code>Array&lt;MemsqlNode&gt;</code> .  Ich denke, dies ist ein gutes Beispiel, bei dem Flow etwas intelligenter sein kann und TypeScript ein wenig Hilfe ben√∂tigt: In diesem Fall k√∂nnen wir eine Typzusicherung anwenden, dies ist jedoch gef√§hrlich und sollte sehr sorgf√§ltig durchgef√ºhrt werden. <br><br>  Obwohl ich keine formalen Beweise habe, glaube ich, dass Flow TypeScript in der Typinferenz weit √ºberlegen ist.  Ich hoffe wirklich, dass TypeScript das Flow-Level erreicht, da sich die Sprache sehr aktiv entwickelt und in diesem Bereich in letzter Zeit viele Verbesserungen vorgenommen wurden.  An vielen Stellen in unserem Code musste TypeScript ein wenig durch Anmerkungen oder Typzusicherungen helfen, obwohl wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letztere</a> so weit wie m√∂glich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vermieden haben</a> .  Betrachten wir noch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> (wir hatten mehr als 200 solcher Fehler): <br><br><pre> <code class="javascript hljs">type Player = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string; age: number; position: <span class="hljs-string"><span class="hljs-string">"STRIKER"</span></span> | <span class="hljs-string"><span class="hljs-string">"GOALKEEPER"</span></span>, }; type F = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;Player&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f1: F = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"David Gomes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-attr"><span class="hljs-attr">position</span></span>: <span class="hljs-string"><span class="hljs-string">"GOALKEEPER"</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Cristiano Ronaldo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-attr"><span class="hljs-attr">position</span></span>: <span class="hljs-string"><span class="hljs-string">"STRIKER"</span></span>, } ]); };</code> </pre> <br>  Mit TypeScript k√∂nnen Sie dies nicht schreiben, da Sie <code>{ name: "David Gomes", age: 23, type: "GOALKEEPER" }</code> als Objekt vom Typ <code>Player</code> <code>{ name: "David Gomes", age: 23, type: "GOALKEEPER" }</code> (den genauen Fehler finden Sie in der Sandbox).  Dies ist ein weiterer Fall, in dem TypeScript nicht intelligent genug ist (zumindest im Vergleich zu Flow, der diesen Code versteht). <br><br>  Es gibt verschiedene M√∂glichkeiten, dies zu beheben: <br><br><ul><li>  Deklarieren Sie <code>"STRIKER"</code> als <code>"STRIKER"</code> damit TypeScript versteht, dass die Zeichenfolge eine g√ºltige Aufz√§hlung vom Typ <code>"STRIKER" | "GOALKEEPER"</code>  <code>"STRIKER" | "GOALKEEPER"</code> . </li><li>  Deklarieren Sie alle Objekte als <code>Player</code> . </li><li>  Oder was ich f√ºr die beste L√∂sung halte: Helfen Sie TypeScript einfach, ohne <code>Promise.all&lt;Player&gt;(...)</code> indem Sie <code>Promise.all&lt;Player&gt;(...)</code> schreiben. </li></ul><br>  Hier ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">weiteres Beispiel</a> (TypeScript), in dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flow bei der Typinferenz wieder besser ist</a> : <br><br><pre> <code class="javascript hljs">type Connection = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: number }; declare <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Connection</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resolve(getConnection()); }) } resolveConnection().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">conn</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TypeScript errors in the next line because it does not understand // that conn is of type Connection. We have to manually annotate // resolveConnection as Promise&lt;Connection&gt;. (conn.id); });</span></span></code> </pre> <br>  Ein sehr kleines, aber interessantes Beispiel: Flow betrachtet <code>Array&lt;T&gt;.pop()</code> Typ <code>T</code> und TypeScript als <code>T | void</code>  <code>T | void</code>  Ein Punkt zugunsten von TypeScript, da Sie <code>Array.pop</code> , die Existenz eines Elements zu √ºberpr√ºfen (wenn das Array leer ist, gibt <code>Array.pop</code> <code>undefined</code> ).  Es gibt einige andere kleine Beispiele wie dieses, bei denen TypeScript Flow √ºberlegen ist. <br><br><h3>  TypeScript-Definitionen f√ºr Abh√§ngigkeiten von Drittanbietern </h3><br>  Wenn Sie eine JavaScript-Anwendung schreiben, haben Sie nat√ºrlich mindestens einige Abh√§ngigkeiten.  Sie sollten eingegeben werden, da Sie sonst die meisten M√∂glichkeiten der statischen Typanalyse verlieren (wie am Anfang des Artikels beschrieben). <br><br>  Bibliotheken von npm k√∂nnen mit Flow- oder TypeScript-Typdefinitionen mit oder ohne beides geliefert werden.  Sehr oft werden (kleine) Bibliotheken weder mit der einen noch mit der anderen geliefert, daher m√ºssen Sie Ihre eigenen Typdefinitionen schreiben oder sie von der Community ausleihen.  Sowohl Flow als auch TypeScript unterst√ºtzen Standarddefinitions-Repositorys f√ºr JavaScript-Pakete von Drittanbietern: Diese sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flow-typisiert</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DefinitelyTyped</a> . <br><br>  Ich muss sagen, dass DefinitelyTyped uns viel besser gefallen hat.  Bei Flow-Typing musste ich das CLI-Tool verwenden, um Typdefinitionen f√ºr verschiedene Abh√§ngigkeiten in das Projekt einzuf√ºhren.  DefinitelyTyped kombiniert diese Funktion mit dem npm CLI-Tool, indem <code>@types/package-name</code> Pakete an das npm-Paketrepository gesendet werden.  Dies ist sehr cool und hat die Eingabe von Typdefinitionen f√ºr unsere Abh√§ngigkeiten stark vereinfacht (Scherz, Reagieren, Lodash, Reagieren-Redux, dies sind nur einige davon). <br><br>  Au√üerdem hatte ich viel Spa√ü beim Auff√ºllen der DefinitelyTyped-Datenbank (denken Sie nicht, dass Typdefinitionen beim Portieren von Code von Flow nach TypeScript gleichwertig sind).  Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habe bereits</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pull-Anfragen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesendet</a> , und es gab nirgendwo Probleme.  Klonen Sie einfach das Repository, bearbeiten Sie Typdefinitionen, f√ºgen Sie Tests hinzu - und senden Sie eine Pull-Anfrage.  Der DefinitelyTyped GitHub-Bot markiert die Autoren der von Ihnen bearbeiteten Definitionen.  Wenn keiner von ihnen innerhalb von 7 Tagen eine R√ºckmeldung gibt, wird die Pull-Anfrage zur Pr√ºfung an den Betreuer gesendet.  Nach dem Zusammenf√ºhren mit dem Hauptzweig wird eine neue Version des Abh√§ngigkeitspakets an npm gesendet.  Als ich beispielsweise das Paket @ types / redux-form zum ersten Mal aktualisierte, wurde Version 7.4.14 automatisch an npm gesendet.  Aktualisieren Sie einfach die Datei package.json, um neue Typdefinitionen zu erhalten.  Wenn Sie nicht auf die Annahme der Pull-Anforderung warten k√∂nnen, k√∂nnen Sie jederzeit die Definitionen der in Ihrem Projekt verwendeten Typen √§ndern, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem der vorherigen Artikel beschrieben</a> . <br><br>  Im Allgemeinen ist die Qualit√§t der Typdefinitionen in DefinitelyTyped aufgrund der gr√∂√üeren und erfolgreicheren TypeScript-Community viel besser.  Nachdem das Projekt auf TypeScript √ºbertragen wurde <b>, stieg unsere Typabdeckung von 88% auf 96%</b> , haupts√§chlich aufgrund besserer Definitionen von Abh√§ngigkeitstypen von Drittanbietern mit weniger Typen. <br><br><h1>  Flusen und Tests </h1><br><ol><li>  Wir haben von eslint zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tslint gewechselt</a> (mit eslint f√ºr TypeScript schien es schwieriger zu sein, loszulegen). </li><li>  TypeScript-Tests verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ts-jest</a> .  Einige der Tests werden getippt, andere nicht (wenn sie zu lange getippt werden, speichern wir sie als .js-Dateien). </li></ol><br><h1>  Was ist passiert, nachdem alle Tippfehler behoben wurden? </h1><br>  Nach 40 Arbeitsstunden haben wir den letzten Tippfehler erreicht und ihn mit <code>@ts-ignore</code> f√ºr eine Weile verschoben. <br><br>  Nachdem ich die Kommentare zur Code√ºberpr√ºfung √ºberpr√ºft und einige Fehler behoben habe (leider musste ich den Laufzeitcode ein wenig √§ndern, um die Logik zu beheben, die TypeScript nicht verstehen konnte), ist die Pull-Anforderung weg, und seitdem verwenden wir TypeScript.  (Und ja, wir haben das letzte <code>@ts-ignore</code> in der n√§chsten Pull-Anfrage behoben). <br><br>  Neben der Integration in den Editor ist die Arbeit mit TypeScript der Arbeit mit Flow sehr √§hnlich.  Die Leistung des Flow-Servers ist etwas h√∂her, dies ist jedoch kein gro√ües Problem, da sie gleich schnell Fehler f√ºr die aktuelle Datei generieren.  Der einzige Leistungsunterschied besteht darin, dass TypeScript einen neuen Fehler meldet, nachdem die Datei etwas sp√§ter (um 0,5 - 1 s) gespeichert wurde.  Die Startzeit des Servers ist ungef√§hr gleich (ca. 2 Minuten), aber nicht so wichtig.  Bisher hatten wir keine Probleme mit dem Speicherverbrauch.  Es scheint, dass tsc st√§ndig rund 600 MB verwendet. <br><br>  Es mag den Anschein haben, dass die Typinferenzfunktion Flow einen gro√üen Vorteil verschafft, aber es gibt zwei Gr√ºnde, warum dies nicht wirklich wichtig ist: <br><br><ol><li>  Wir haben die Flow-Codebasis in TypeScript konvertiert.  Offensichtlich sind wir nur auf solchen Code gesto√üen, den Flow ausdr√ºcken kann, TypeScript jedoch nicht.  Wenn die Migration in die entgegengesetzte Richtung stattgefunden h√§tte, w√ºrde es sicher Dinge geben, die TypeScript besser anzeigt / ausdr√ºckt. </li><li>  Typinferenz ist wichtig, um pr√§ziseren Code zu schreiben.  Trotzdem sind andere Dinge wichtiger, wie eine starke Community und die Verf√ºgbarkeit von Typdefinitionen, da schwache Typinferenzen behoben werden k√∂nnen, indem etwas mehr Zeit f√ºr die Eingabe aufgewendet wird. </li></ol><br><h3>  Codestatistik </h3><br><pre> <code class="bash hljs">$ npm run <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>-coverage <span class="hljs-comment"><span class="hljs-comment"># https://github.com/plantain-00/type-coverage 43330 / 45047 96.19% $ cloc # ignoring tests and dependencies -------------------------------------------------------------------------------- Language files blank comment code -------------------------------------------------------------------------------- TypeScript 330 5179 1405 31463</span></span></code> </pre> <br><h1>  Was weiter? </h1><br>  Wir sind nicht damit fertig, die statische Typanalyse zu verbessern.  MemSQL hat andere Projekte, die irgendwann von Flow zu TypeScript wechseln werden (und einige JavaScript-Projekte, die TypeScript verwenden), und wir m√∂chten unsere TypeScript-Konfiguration strenger gestalten.  Wir haben derzeit die Option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">strictNullChecks aktiviert</a> , aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">noImplicitAny ist</a> immer noch deaktiviert.  Wir werden auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige gef√§hrliche Typanweisungen</a> aus dem Code entfernen. <br><br>  Ich freue mich, Ihnen alles mitteilen zu k√∂nnen, was ich w√§hrend meiner Abenteuer mit der Eingabe von JavaScript gelernt habe.  Wenn Sie an einem bestimmten Thema interessiert sind, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lassen</a> Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es mich</a> bitte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wissen</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436554/">https://habr.com/ru/post/de436554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436544/index.html">Der Marktplatz wird f√ºr alles antworten</a></li>
<li><a href="../de436546/index.html">Entwicklung eines Teams zum Anfordern von Daten aus einer Datenbank - Teil 3</a></li>
<li><a href="../de436548/index.html">Bildungsprogramm f√ºr virtuelle Realit√§t</a></li>
<li><a href="../de436550/index.html">Dank des Roboters lernten die Wissenschaftler, wie einer der ersten Bewohner von Sushi ging</a></li>
<li><a href="../de436552/index.html">Nachruf auf den Tod von Chromecast Audio oder warum Google schwarze Discs get√∂tet hat</a></li>
<li><a href="../de436556/index.html">Jobs in einem deutschen Unternehmen - wie bewerbe ich mich und bekomme keine Ablehnung?</a></li>
<li><a href="../de436558/index.html">Alles Gute zum 18. Geburtstag, Wikipedia; Wir feiern das Erwachsenwerden eines guten Projekts</a></li>
<li><a href="../de436560/index.html">Kryptografische Protokolle f√ºr die elektronische Abstimmung</a></li>
<li><a href="../de436564/index.html">Wie ProGuard funktioniert</a></li>
<li><a href="../de436568/index.html">Eigene Videoplattform oder wie man viele Computerressourcen beansprucht. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>