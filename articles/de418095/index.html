<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📯 😗 🤫 Über das Gerät der eingebauten Testfunktionalität in Rust (Übersetzung) 🍯 👨🏿‍⚕️ 😆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen die Übersetzung des Eintrags "# [test] in 2018" auf John Renners Blog, den Sie hier finden . 

 Vor kurzem habe ich ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Über das Gerät der eingebauten Testfunktionalität in Rust (Übersetzung)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418095/">  Hallo Habr!  Ich präsentiere Ihnen die Übersetzung des Eintrags "# [test] in 2018" auf John Renners Blog, den Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier finden</a> . <br><br>  Vor kurzem habe ich an der Implementierung von <a href="">eRFC für benutzerdefinierte Test-Frameworks</a> für Rust gearbeitet.  Als ich die Codebasis des Compilers studierte, studierte ich die Interna des Testens in Rust und erkannte, dass es interessant wäre, dies zu teilen. <br><a name="habracut"></a><br><h3>  Attribut # [Test] </h3><br>  Heute verlassen sich Rust-Programmierer auf das integrierte Attribut <code>#[test]</code> .  Sie müssen lediglich die Funktion als Test markieren und einige Überprüfungen aktivieren: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre><br>  Wenn dieses Programm mit den <code>rustc --test</code> oder <code>rustc --test</code> kompiliert wird, wird eine ausführbare Datei erstellt, in der diese und alle anderen Testfunktionen ausgeführt werden können.  Mit dieser Testmethode können Sie Tests organisch in der Nähe des Codes halten.  Sie können sogar Tests in privaten Modulen durchführen: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> my_priv_mod { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_priv_func</span></span></span></span>() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> {} <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_priv_func</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(my_priv_func()); } }</code> </pre><br>  Somit können private Entitäten einfach ohne Verwendung externer Testwerkzeuge getestet werden.  Dies ist der Schlüssel zu ergonomischen Tests in Rust.  Semantisch ist dies jedoch ziemlich seltsam.  Wie ruft die <code>main</code> diese Tests auf, wenn sie nicht sichtbar sind ( <b>Anmerkung des Übersetzers</b> : Ich erinnere Sie daran, dass privat - ohne Verwendung des Schlüsselworts <code>pub</code> deklariert - durch Kapselung vor Zugriff von außen geschützt sind)?  Was genau macht <code>rustc --test</code> ? <br><br>  <code>#[test]</code> als Syntaxkonvertierung in der libsyntax-Compilerkiste implementiert.  Dies ist im Wesentlichen ein ausgefallenes Makro, das unsere Kiste in drei Schritten umschreibt: <br><br><h3>  Schritt 1: Reexport </h3><br>  Wie bereits erwähnt, können Tests in privaten Modulen vorhanden sein. Daher benötigen wir eine Möglichkeit, sie der <code>main</code> zugänglich zu machen, ohne den vorhandenen Code zu beschädigen.  Zu diesem Zweck <i>erstellt</i> <code>libsyntax</code> <i>lokale Module mit dem Namen <code>__test_reexports</code> , die Tests rekursiv <code>__test_reexports</code></i> .  Diese Offenbarung übersetzt das obige Beispiel in: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> my_priv_mod { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_priv_func</span></span></span></span>() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_priv_func</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(my_priv_func()); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> __test_reexports { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::test_priv_func; } }</code> </pre><br>  Jetzt ist unser Test als <code>my_priv_mod::__test_reexports::test_priv_func</code> .  Bei verschachtelten Modulen <code>__test_reexports</code> Module, die die Tests enthalten, erneut, sodass der Test <code>a::b::my_test</code> zu <code>a::__test_reexports::b::__test_reexports::my_test</code> .  Dieser Prozess scheint bisher ziemlich sicher zu sein, aber was passiert, wenn ein <code>__test_reexports</code> Modul vorhanden ist?  Antwort: <b>nichts</b> . <br><br>  Um dies zu erklären, müssen wir verstehen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie der AST Bezeichner darstellt</a> .  Der Name jeder Funktion, Variablen, jedes Moduls usw.  nicht als Zeichenfolge gespeichert, sondern als undurchsichtiges <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Symbol</a> , das im Wesentlichen eine Identifikationsnummer für jede Kennung darstellt.  Der Compiler speichert eine separate Hash-Tabelle, mit der wir bei Bedarf den lesbaren Namen des Symbols wiederherstellen können (z. B. beim Drucken eines Syntaxfehlers).  Wenn der Compiler das Modul <code>__test_reexports</code> , generiert er ein neues Symbol für den Bezeichner. Obwohl die vom Compiler generierten <code>__test_reexports</code> möglicherweise denselben Namen wie Ihr generisches Modul haben, wird sein Symbol nicht verwendet.  Diese Technik verhindert Namenskollisionen während der Codegenerierung und ist die Grundlage für die Hygiene des Rust-Makrosystems. <br><br><h3>  Schritt 2: Umreifen der Umreifung </h3><br>  Jetzt, da unsere Tests von der Wurzel unserer Kiste aus zugänglich sind, müssen wir etwas damit anfangen.  <code>libsyntax</code> generiert ein solches Modul: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> __test { <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> test; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TESTS: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> [self::test::TestDescAndFn] = &amp;[<span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>]; <span class="hljs-meta"><span class="hljs-meta">#[main]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { self::test::test_static_main(TESTS); } }</code> </pre><br>  Obwohl diese Konvertierung einfach ist, gibt sie uns viele Informationen darüber, wie die Tests tatsächlich durchgeführt werden.  Tests werden in einem Array gesammelt und an den Testläufer mit dem Namen <code>test_static_main</code> .  Wir werden zu <code>TestDescAndFn</code> , aber im Moment ist die wichtigste Schlussfolgerung, dass es eine Kiste namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">test gibt</a> , die Teil des Rust-Kernels ist und die gesamte Laufzeit zum Testen implementiert.  Die <code>test</code> ist instabil, daher ist das Makro <code>#[test]</code> die einzige stabile Möglichkeit, mit ihr zu interagieren. <br><br><h3>  Schritt 3: Generieren eines Testobjekts </h3><br>  Wenn Sie zuvor Tests in Rust geschrieben haben, sind Sie möglicherweise mit einigen der optionalen Attribute vertraut, die für Testfunktionen verfügbar sind.  Zum Beispiel kann ein Test mit <code>#[should_panic]</code> kommentiert werden, wenn wir erwarten, dass der Test eine Panik <code>#[should_panic]</code> .  Es sieht ungefähr so ​​aus: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[should_panic]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"intentional"</span></span>); }</code> </pre><br>  Dies bedeutet, dass unsere Tests mehr als einfache Funktionen sind und Konfigurationsinformationen enthalten.  <code>test</code> codiert diese Konfigurationsdaten in eine Struktur namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TestDesc</a> .  Für jede Testfunktion in der Kiste analysiert <code>libsyntax</code> ihre Attribute und generiert eine Instanz von <code>TestDesc</code> .  Anschließend werden <code>TestDesc</code> und die Testfunktion in der logischen Struktur <code>TestDescAndFn</code> , mit der <code>test_static_main</code> arbeitet.  Für diesen Test sieht die generierte Instanz von <code>TestDescAndFn</code> aus: <br><br><pre> <code class="rust hljs">self::test::TestDescAndFn { desc: self::test::TestDesc { name: self::test::StaticTestName(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>), ignore: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, should_panic: self::test::ShouldPanic::Yes, allow_fail: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, testfn: self::test::StaticTestFn(|| self::test::assert_test_result(::crate::__test_reexports::foo())), }</code> </pre><br>  Sobald wir ein Array dieser Testobjekte erstellt haben, werden sie über die in Schritt 2 generierte Bindung an den Testläufer übergeben. Obwohl dieser Schritt als Teil des zweiten Schritts betrachtet werden kann, möchte ich als separates Konzept darauf aufmerksam machen, da dies der Schlüssel zur Implementierung eines benutzerdefinierten Tests ist Frameworks, aber dies wird ein weiterer Blog-Beitrag sein. <br><br><h3>  Nachwort: Forschungsmethoden </h3><br>  Obwohl ich viele Informationen direkt von den Compilerquellen erhalten habe, konnte ich herausfinden, dass es eine sehr einfache Möglichkeit gibt, zu sehen, was der Compiler tut.  Der nächtliche Compiler-Build verfügt über ein instabiles Flag namens <code>unpretty</code> , mit dem Sie den Quellcode des Moduls nach dem Erweitern der Makros drucken können: <br><br><pre> <code class="rust hljs">$ rustc my_mod.rs -Z unpretty=hir</code> </pre><br><h4>  Anmerkung des Übersetzers </h4><br>  Interessant ist, dass ich den Code des Testfalls nach der Offenlegung von Makros veranschaulichen werde: <br><br>  Benutzerdefinierter Quellcode: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">4</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() {}</code> </pre><br>  Code nach dem Erweitern von Makros: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[prelude_import]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::prelude::v1::*; <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> std <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> std; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !(<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">4</span></span>) { { ::rt::begin_panic(<span class="hljs-string"><span class="hljs-string">"assertion failed: 2 + 2 == 4"</span></span>, &amp;(<span class="hljs-string"><span class="hljs-string">"test_test.rs"</span></span>, <span class="hljs-number"><span class="hljs-number">3u32</span></span>, <span class="hljs-number"><span class="hljs-number">3u32</span></span>)) } }; } <span class="hljs-meta"><span class="hljs-meta">#[allow(dead_code)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> __test_reexports { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::my_test; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> __test { <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> test; <span class="hljs-meta"><span class="hljs-meta">#[main]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() -&gt; () { test::test_main_static(TESTS) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TESTS: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> [self::test::TestDescAndFn] = &amp;[self::test::TestDescAndFn { desc: self::test::TestDesc { name: self::test::StaticTestName(<span class="hljs-string"><span class="hljs-string">"my_test"</span></span>), ignore: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, should_panic: self::test::ShouldPanic::No, allow_fail: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, testfn: self::test::StaticTestFn(::__test_reexports::my_test), }]; }</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418095/">https://habr.com/ru/post/de418095/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418085/index.html">Versprechen in JavaScript verwenden</a></li>
<li><a href="../de418087/index.html">80% der Selbstbedienungskassen sind gefährdet</a></li>
<li><a href="../de418089/index.html">SolidCraft CNC-Fräsmaschine Übersicht</a></li>
<li><a href="../de418091/index.html">Liste der Artikel und Literatur zu NAS</a></li>
<li><a href="../de418093/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 3: Pufferüberläufe: Exploits und Schutz, Teil 2</a></li>
<li><a href="../de418099/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 3: Pufferüberläufe: Exploits und Schutz, Teil 3</a></li>
<li><a href="../de418101/index.html">Etymologie der IT-Begriffe</a></li>
<li><a href="../de418103/index.html">Der Chef von Roscosmos erinnerte sich an seine erste Rakete und teilte Pläne für die Zukunft</a></li>
<li><a href="../de418105/index.html">Warum das Öffnen von YouTube in Firefox oder Edge fünfmal länger dauern kann als in Google Chrome</a></li>
<li><a href="../de418107/index.html">Festlegen eines Präfixes für den MINDEO CS2190-Scanner für die Arbeit mit 1C im Tastaturunterbrechungsmodus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>