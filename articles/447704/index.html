<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐔 🕴🏼 👰 Climbing Elbrus - Reconocimiento en batalla. Parte técnica 1. Registros, pilas y otros detalles técnicos. 🛌🏽 👇🏽 🤙🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Según lo prometido , seguimos hablando sobre el desarrollo de procesadores Elbrus . Este artículo es técnico. La información proporcionada en el artíc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Climbing Elbrus - Reconocimiento en batalla. Parte técnica 1. Registros, pilas y otros detalles técnicos.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/447704/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Según lo prometido</a> , seguimos hablando sobre el desarrollo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de procesadores Elbrus</a> .  Este artículo es técnico.  La información proporcionada en el artículo no es documentación oficial, ya que se obtuvo durante el estudio de Elbrus como una caja negra.  Pero sin duda será interesante para una mejor comprensión de la arquitectura de Elbrus, porque aunque teníamos documentación oficial, muchos detalles quedaron claros solo después de largos experimentos, cuando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Embox</a> funcionó. <br><br>  Recuerde que en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo anterior</a> hablamos sobre el arranque básico del sistema y el controlador del puerto serie.  Embox comenzó, pero para avanzar aún más necesitábamos interrupciones, un temporizador del sistema y, por supuesto, me gustaría incluir un conjunto de pruebas unitarias, y para esto necesitamos setjmp.  Este artículo se enfocará en registros, pilas y otros detalles técnicos necesarios para implementar todas estas cosas. <br><a name="habracut"></a><br>  Comencemos con una breve introducción a la arquitectura, que es la información mínima necesaria para comprender lo que se discutirá más adelante.  En el futuro, nos referiremos a la información de esta sección. <br><br><h3>  Breve introducción: pilas </h3><br>  Hay tres pilas en Elbrus: <br><br><ul><li>  Pila de procedimientos (PS) </li><li> Pila de cadena de procedimiento (PCS) </li><li>  Pila de usuario (EE. UU.) </li></ul><br>  Analicemos con más detalle.  Las direcciones en la figura son condicionales, muestran en qué dirección se dirigen los movimientos, desde una dirección más grande a una más pequeña o viceversa. <br><br><img src="https://habrastorage.org/webt/le/bc/ac/lebcace6fqkdk5vvhwke6kajyuu.png"><br><br>  La pila de procedimientos (PS) está destinada a datos asignados a registros "operativos". <br><br>  Por ejemplo, pueden ser argumentos de función, en arquitecturas "ordinarias", este concepto está más cerca de los registros de propósito general.  A diferencia de las arquitecturas de procesador "normales", en E2K, los registros utilizados en las funciones se apilan en una pila separada. <br><br>  La Pila de información de enlace (PCS) está diseñada para colocar información sobre el procedimiento (de llamada) anterior y se utiliza al regresar.  Los datos en la dirección del remitente, así como en el caso de los registros, se colocan en un lugar separado.  Por lo tanto, la promoción de la pila (por ejemplo, salir por excepción en C ++) es un proceso que consume más tiempo que en las arquitecturas "ordinarias".  Por otro lado, esto elimina los problemas de desbordamiento de pila. <br><br>  Ambas pilas (PS y PCS) se caracterizan por una dirección base, tamaño y desplazamiento actual.  Estos parámetros se establecen en los registros PSP y PCSP, son de 128 bits y en el ensamblador debe hacer referencia a campos específicos (por ejemplo, alto o bajo).  Además, el funcionamiento de las pilas está estrechamente relacionado con el concepto de un archivo de registro, más sobre eso a continuación.  La interacción con el archivo ocurre a través del mecanismo de bombeo / intercambio de registros.  El llamado "puntero de hardware a la parte superior de la pila" del procedimiento o la pila de información vinculante desempeña un papel activo en este mecanismo, respectivamente.  Sobre esto también a continuación.  Es importante que en cada momento los datos de estas pilas estén en RAM o en un archivo de registro. <br><br>  También vale la pena señalar que estas pilas (la pila de procedimientos y la pila de información de enlace) crecen.  Nos encontramos con esto cuando implementamos context_switch. <br><br>  La pila de usuarios también recibe la dirección base y el tamaño.  El puntero actual está en el registro USD.lo.  En esencia, es una pila clásica que crece hacia abajo.  Solo que, a diferencia de las arquitecturas "ordinarias", la información de otras pilas (registros y direcciones de retorno) no cabe allí. <br><br>  Un requisito no estándar, en mi opinión, para los límites y tamaños de las pilas es la alineación de 4Kb, y tanto la dirección base de la pila como su tamaño deben estar alineados a 4Kb.  En otras arquitecturas, no he cumplido esa restricción.  Nos encontramos con este detalle, nuevamente, cuando implementamos context_switch. <br><br><h3>  Breve introducción: registros.  Registrar archivos  Registrar ventanas </h3><br>  Ahora que hemos descubierto un poco las pilas, necesitamos entender cómo se presenta la información en ellas.  Para hacer esto, necesitamos introducir algunos conceptos más. <br><br>  Un archivo de registro (RF) es un conjunto de todos los registros.  Hay dos archivos de registro que necesitamos: un archivo de información de conexión (archivo de cadena - CF), el otro se llama archivo de registro (RF), almacena registros "operativos", que se almacenan en la pila de procedimientos. <br><br>  La ventana de registro es el área (conjunto de registros) del archivo de registro que está disponible actualmente. <br><br>  Explicaré con más detalle.  Creo que es un conjunto de registros que nadie necesita explicar. <br><br>  Es bien sabido que uno de los cuellos de botella en la arquitectura x86 es precisamente un pequeño número de registros.  En arquitecturas RISC con registros es más simple, generalmente alrededor de 16 registros, de los cuales varios (2-3) están ocupados para necesidades oficiales.  ¿Por qué no simplemente hacer 128 registros, porque parece que esto aumentará el rendimiento del sistema?  La respuesta es bastante simple: una instrucción de procesador necesita un lugar para almacenar la dirección de registro, y si hay muchos de ellos, también se necesitan muchos bits para esto.  Por lo tanto, recurren a todo tipo de trucos, hacen registros de sombra, registran bancos, ventanas, etc.  Por registros sombra, me refiero al principio de organización de registros en ARM.  Si ocurre una interrupción u otra situación, entonces está disponible un conjunto diferente de registros con los mismos nombres (números), mientras la información almacenada en el conjunto original permanece allí.  Los bancos de registros, de hecho, son muy similares a los registros sombra, simplemente no hay cambio de hardware de los conjuntos de registros, y el programador elige a qué banco (conjunto de registros) contactar ahora. <br><br>  Las ventanas de registro están diseñadas para optimizar el trabajo con la pila.  Como probablemente comprenda, en una arquitectura "normal" usted ingresa un procedimiento, guarda registros en la pila (o el procedimiento de llamada guarda, depende del acuerdo) y puede usar registros, porque la información ya está almacenada en la pila.  Pero el acceso a la memoria es lento y, por lo tanto, debe evitarse.  Al ingresar al procedimiento, hagamos que un nuevo conjunto de registros esté disponible, los datos del anterior se guardarán, lo que significa que no necesita volcarlos en la memoria.  Además, cuando regrese al procedimiento de llamada, la ventana de registro anterior también devolverá, por lo tanto, todos los datos en los registros serán relevantes.  Este es el concepto de una ventana de registro. <br><br><img src="https://habrastorage.org/webt/lg/5e/6u/lg5e6u_pfus75yedi6hefckkqkk.png"><br><br>  Está claro que aún necesita guardar los registros en la pila (en la memoria), pero esto puede hacerse cuando las ventanas de registro libre hayan finalizado. <br><br>  ¿Y qué hacer con los registros de entrada y salida (argumentos al ingresar la función y el resultado devuelto)?  Deje que la ventana contenga parte de los registros visibles desde la ventana anterior, más precisamente, parte de los registros estará disponible para ambas ventanas.  Luego, en general, cuando se llama a la función, no tiene que acceder a la memoria.  Supongamos que nuestros registros se ven así <br><br><img src="https://habrastorage.org/webt/n9/ki/zw/n9kizwn2qkag4rew2jspyassaco.png"><br><br>  Es decir, r0 en la primera ventana será el mismo registro que r2 en cero, y r1 desde la primera ventana en el mismo registro que r3.  Es decir, escribiendo en r2 antes de llamar al procedimiento (cambiando el número de ventana) obtenemos el valor en r0 en el procedimiento llamado.  Este principio se llama mecanismo de ventanas giratorias. <br><br>  Optimicemos un poco más, porque los creadores de Elbrus hicieron exactamente eso.  Deje que las ventanas que tenemos no sean de un tamaño fijo, sino variable, el tamaño de la ventana se puede establecer en el momento de la entrada en el procedimiento.  Haremos lo mismo con el número de registros rotados.  Por supuesto, esto nos llevará a algunos problemas, porque si en las ventanas giratorias clásicas, hay un índice de ventana a través del cual se determina que necesita guardar los datos del archivo de registro en la pila o cargarlos.  Pero si ingresa no el índice de la ventana, sino el índice de registro desde el cual comienza nuestra ventana actual, entonces este problema no surgirá.  En Elbrus, estos índices están contenidos en los registros PSHTP (para la pila de procedimientos PS) y PCSHTP (para la pila de información de procedimientos PCS).  La documentación se refiere a "punteros de hardware en la parte superior de la pila".  Ahora puedes intentar leer de nuevo sobre las pilas, creo que será más claro. <br><br>  Como comprenderá, dicho mecanismo implica que tiene la capacidad de controlar lo que está en la memoria.  Es decir, sincronice el archivo de registro y la pila.  Me refiero a un programador de sistemas.  Si usted es un programador de aplicaciones, el equipo proporcionará una entrada y una salida transparentes del procedimiento.  Es decir, si no hay suficientes registros al intentar seleccionar una nueva ventana, la ventana de registro se "bombeará" automáticamente.  En este caso, todos los datos del archivo de registro se guardarán en la pila apropiada (en la memoria), y el "puntero a la parte superior del hardware de la pila" (índice de compensación) se restablecerá a cero.  Del mismo modo, el intercambio de un archivo de registro de la pila se produce automáticamente.  Pero si está desarrollando, por ejemplo, el cambio de contexto, que es exactamente lo que hicimos, entonces necesita un mecanismo para trabajar con la parte oculta del archivo de registro.  En Elbrus, los comandos FLUSHR y FLUSHC se utilizan para esto.  FLUSHR: al borrar el archivo de registro, todas las ventanas, excepto la actual, se vacían a la pila de procedimientos, por lo que el índice PSHTP se restablece a cero.  FLUSHC: limpia el archivo de información de enlace, todo, excepto la ventana actual, se descarga en la pila de información de enlace, el índice PCSHTP también se restablece a cero. <br><br><h3>  Breve introducción: implementación en Elbrus </h3><br>  Ahora que hemos discutido el trabajo no obvio con registros y pilas, hablaremos más específicamente sobre varias situaciones en Elbrus. <br><br>  Cuando ingresamos a la siguiente función, el procesador crea dos ventanas: una ventana en la pila PS y una ventana en la pila PCS. <br><br>  Una ventana en la pila PCS contiene la información necesaria para regresar de una función: por ejemplo, IP (puntero de instrucción) de la instrucción en la que deberá regresar de la función.  Con esto, todo está más o menos claro. <br><br>  La ventana en la pila PS es un poco más complicada.  Se introduce el concepto de registros de la ventana actual.  En esta ventana, tendrá acceso a los registros de la ventana actual:% dr0,% dr1, ...,% dr15, ... Es decir, para nosotros, como usuario, siempre están numerados desde 0, pero esta es una numeración relativa a la dirección base de la ventana actual.  A través de estos registros, los argumentos se pasan cuando se llama a la función, se devuelve el valor y la función se utiliza como registros de propósito general dentro de la función.  En realidad, esto se explicó al considerar el mecanismo de rotación de las ventanas de registro. <br><br>  El tamaño de la ventana de registro en Elbrus se puede controlar.  Esto, como dije, es necesario para la optimización.  Por ejemplo, en una función solo necesitamos 4 registros para pasar argumentos y algunos cálculos, en este caso el programador (o compilador) decide cuántos registros asignar para la función, y en función de esto establece el tamaño de la ventana.  El tamaño de la ventana lo establece la operación setwd: <br><br><pre><code class="cpp hljs">setwd wsz=<span class="hljs-number"><span class="hljs-number">0x10</span></span></code> </pre> <br>  Especifica el tamaño de la ventana en términos de registros cuádruples (registros de 128 bits). <br><br><img src="https://habrastorage.org/webt/tf/ov/px/tfovpxrj1wkos3e29zsl0fj_8p8.png"><br><br>  Ahora, supongamos que desea llamar a una función desde una función.  Para esto, se aplica el concepto ya descrito de una ventana de registro girada.  La imagen de arriba muestra un fragmento de un archivo de registro donde una función con la ventana 1 (verde) llama a una función con la ventana 2 (naranja).  En cada una de estas dos funciones tendrá acceso a su% dr0,% dr1, ... Pero los argumentos se pasarán por los llamados registros rotativos.  En otras palabras, parte de los registros de la ventana 1 se convertirán en los registros de la ventana 2 (tenga en cuenta que estas dos ventanas se cruzan).  Estos registros también los establece la ventana (consulte Registros rotativos en la imagen) y tienen la dirección% db [0],% db [1], ... Por lo tanto, el registro% dr0 en la ventana 2 no es más que el registro% db [0] en ventana 1. <br><br>  La ventana de registro de rotación se establece mediante la operación setbn: <br><br><pre> <code class="cpp hljs"> setbn rbs = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rsz = <span class="hljs-number"><span class="hljs-number">0x8</span></span></code> </pre> <br>  rbs establece el tamaño de la ventana girada y rsz establece la dirección base, pero en relación con la ventana de registro actual.  Es decir  Aquí hemos asignado 3 registros, comenzando desde el 8. <br><br>  En base a lo anterior, mostramos cómo se ve la llamada a la función.  Por simplicidad, suponemos que la función toma un argumento: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Luego, para llamar a esta función, debe preparar una ventana de registros rotativos (ya lo hemos hecho a través de setbn).  Luego, en el registro% db0 colocamos el valor que se pasará a my_func.  Después de esto, debe llamar a la instrucción CALL y no olvide decirle dónde comienza la ventana de registros rotados.  Omitimos la preparación para la llamada (el comando disp) ahora, porque no distingue entre mayúsculas y minúsculas.  Como resultado, en ensamblador, una llamada a esta función debería verse así: <br><br><pre> <code class="cpp hljs"> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, my_func call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x8</span></span></code> </pre> <br>  Entonces, con registros un poco resueltos.  Ahora veamos la pila de información vinculante.  Almacena los llamados registros CR.  De hecho, dos: CR0, CR1.  Y ya contienen la información necesaria para regresar de la función. <br><br><img src="https://habrastorage.org/webt/rc/8q/kl/rc8qklg-pb3tgwv3jjz_8pc6l3g.png"><br><br>  Los registros CR0 y CR1 de la ventana de la función que llamó a la función con los registros marcados en naranja son verdes.  Los registros CR0 contienen el puntero de instrucción de la función de llamada y un determinado archivo de predicado (PF-Predicate File), una historia al respecto definitivamente está fuera del alcance de este artículo. <br><br>  Los registros CR1 contienen datos como PSR (estado del procesador de textos), número de ventana, tamaños de ventana, etc.  En Elbrus, todo es tan flexible que cada procedimiento almacena información en CR1, incluso si la operación de punto flotante está incluida en el procedimiento, y un registro que contiene información sobre excepciones de software, pero para esto, por supuesto, debe pagar para guardar información adicional. <br><br>  Es muy importante no olvidar que el archivo de registro y el archivo de información de enlace se pueden extraer y cambiar de la memoria principal y viceversa (de las pilas PS y PCS descritas anteriormente).  Este punto es importante al implementar setjmp que se describe más adelante. <br><br><h3>  SETJMP / LONGJMP </h3><br>  Y finalmente, al menos de alguna manera entendiendo cómo se organizan las pilas y los registros en Elbrus, puede comenzar a hacer algo útil, es decir, agregar una nueva funcionalidad a Embox. <br><br>  En Embox, el sistema de prueba de la unidad requiere setjmp / longjmp, por lo que tuvimos que implementar estas funciones. <br><br>  Para la implementación, se requiere guardar / restaurar los registros: CR0, CR1, PSP, PCSP, USD, que ya conocemos en una breve introducción.  De hecho, guardar / restaurar se implementa en nuestra frente, pero hay un matiz significativo que a menudo se insinuó en la descripción de pilas y registros, a saber: las pilas deben estar sincronizadas, porque están ubicadas no solo en la memoria, sino también en el archivo de registro.  Este matiz significa que necesita cuidar varias características, sin las cuales nada funcionará. <br><br>  La primera característica es deshabilitar las interrupciones durante el guardado y la restauración.  Al restaurar una interrupción, es obligatorio prohibirla; de lo contrario, puede surgir una situación en la que ingresemos el controlador de interrupciones con pilas a medio cambiar (refiriéndose a bombear el intercambio de archivos de registro descrito en la "breve descripción").  Y al guardar, el problema es que después de ingresar y salir de la interrupción, el procesador puede intercambiar nuevamente parte del archivo de registro de la RAM (y esto arruinará las condiciones invariantes PSHTP = 0 y PSCHTP = 0, un poco más sobre ellas).  Es por eso que, tanto en setjmp como en longjmp, las interrupciones deben deshabilitarse.  También debe señalarse aquí que los especialistas del MCST nos aconsejaron usar corchetes atómicos en lugar de deshabilitar las interrupciones, pero por ahora usamos la implementación más simple (comprensible para nosotros). <br><br>  La segunda característica está relacionada con el bombeo / bombeo de un archivo de registro de la memoria.  Es como sigue.  El archivo de registro tiene un tamaño limitado y, por lo tanto, a menudo se bombea a la memoria y viceversa.  Por lo tanto, si simplemente guardamos los valores de los registros PSP y PSHTP, entonces fijaremos el valor del puntero actual en la memoria y en el archivo de registro.  Pero dado que el archivo de registro está cambiando, en el momento de la restauración del contexto indicará datos ya incorrectos (no los que hemos "guardado").  Para evitar esto, debe vaciar todo el archivo de registro en la memoria.  Por lo tanto, al guardar en setjmp, tenemos registros PSP.ind en la memoria y registros PSHTP.ind en la ventana de registro.  Resulta que necesita guardar todos los registros PCSP.ind + PCSHTP.ind.  La siguiente es la función que realiza esta operación: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* First arg is PCSP, 2nd arg is PCSHTP * Returns new PCSP value with updated PCSP.ind */</span></span> .type update_pcsp_ind,@function $update_pcsp_ind: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x4</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Here and below, 10 is size of PCSHTP.ind. Here we * extend the sign of PCSHTP.ind */</span></span> shld %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span>), %dr1 shrd %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span>), %dr1 <span class="hljs-comment"><span class="hljs-comment">/* Finally, PCSP.ind += PCSHTP.ind */</span></span> addd %dr1, %dr0, %dr0 E2K_ASM_RETURN</code> </pre> <br>  También es necesario aclarar un pequeño punto en este código descrito en el comentario, es decir, es necesario expandir mediante programación el carácter en el índice PCSHTP.ind, porque el índice puede ser negativo y almacenarse en un código adicional.  Para hacer esto, primero cambiamos a (64-10) a la izquierda (registro de 64 bits), a un campo de 10 bits y luego regresamos. <br><br>  Lo mismo ocurre con la PSP (pila de procedimientos) <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* First arg is PSP, 2nd arg is PSHTP * Returns new PSP value with updated PSP.ind */</span></span> .type update_psp_ind,@function $update_psp_ind: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x4</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Here and below, 12 is size of PSHTP.ind. Here we * extend the sign of PSHTP.ind as stated in documentation */</span></span> shld %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">12</span></span>), %dr1 shrd %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">12</span></span>), %dr1 muld %dr1, <span class="hljs-number"><span class="hljs-number">2</span></span>, %dr1 <span class="hljs-comment"><span class="hljs-comment">/* Finally, PSP.ind += PSHTP.ind */</span></span> addd %dr1, %dr0, %dr0 E2K_ASM_RETURN</code> </pre> <br>  Con una ligera diferencia (el campo es de 12 bits y los registros se cuentan allí en términos de 128 bits, es decir, el valor debe multiplicarse por 2). <br><br>  Código setjmp en sí <br><br><pre> <code class="cpp hljs">C_ENTRY(setjmp): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x14</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* It's for db[N] registers */</span></span> setbn rsz = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, rcur = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* We must disable interrupts here */</span></span> disp %ctpr1, ipl_save ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Store current IPL to dr9 */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr9 <span class="hljs-comment"><span class="hljs-comment">/* Store some registers to jmp_buf */</span></span> rrd %cr0.hi, %dr1 rrd %cr1.lo, %dr2 rrd %cr1.hi, %dr3 rrd %usd.lo, %dr4 rrd %usd.hi, %dr5 <span class="hljs-comment"><span class="hljs-comment">/* Prepare RF stack to flush in longjmp */</span></span> rrd %psp.hi, %dr6 rrd %pshtp, %dr7 addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr6, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr7, %db[<span class="hljs-number"><span class="hljs-number">1</span></span>] disp %ctpr1, update_psp_ind ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr6 <span class="hljs-comment"><span class="hljs-comment">/* Prepare CF stack to flush in longjmp */</span></span> rrd %pcsp.hi, %dr7 rrd %pcshtp, %dr8 addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr7, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr8, %db[<span class="hljs-number"><span class="hljs-number">1</span></span>] disp %ctpr1, update_pcsp_ind ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr7 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr1, [%dr0 + E2K_JMBBUFF_CR0_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_JMBBUFF_CR1_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_JMBBUFF_CR1_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_JMBBUFF_USD_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_JMBBUFF_USD_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr6, [%dr0 + E2K_JMBBUFF_PSP_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr7, [%dr0 + E2K_JMBBUFF_PCSP_HI] <span class="hljs-comment"><span class="hljs-comment">/* Enable interrupts */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, ipl_restore ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* return 0 */</span></span> adds <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, %r0 E2K_ASM_RETURN</code> </pre> <br>  Al implementar longjmp, es importante no olvidarse de la sincronización de ambos archivos de registro, por lo tanto, debe vaciar no solo la ventana de registro (flushr), sino también el archivo de carpeta (flushc).  Describamos la macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_ASM_FLUSH_CPU \ flushr; \ nop 2; \ flushc; \ nop 3;</span></span></code> </pre> <br>  Ahora que toda la información está en la memoria, podemos registrar de forma segura la recuperación en longjmp. <br><br><pre> <code class="cpp hljs">C_ENTRY(longjmp): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x14</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> setbn rsz = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, rcur = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* We must disable interrupts here */</span></span> disp %ctpr1, ipl_save ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Store current IPL to dr9 */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr9 <span class="hljs-comment"><span class="hljs-comment">/* We have to flush both RF and CF to memory because saved values * of P[C]SHTP can be not valid here. */</span></span> E2K_ASM_FLUSH_CPU <span class="hljs-comment"><span class="hljs-comment">/* Load registers previously saved in setjmp. */</span></span> ldd [%dr0 + E2K_JMBBUFF_CR0_HI], %dr2 ldd [%dr0 + E2K_JMBBUFF_CR1_LO], %dr3 ldd [%dr0 + E2K_JMBBUFF_CR1_HI], %dr4 ldd [%dr0 + E2K_JMBBUFF_USD_LO], %dr5 ldd [%dr0 + E2K_JMBBUFF_USD_HI], %dr6 ldd [%dr0 + E2K_JMBBUFF_PSP_HI], %dr7 ldd [%dr0 + E2K_JMBBUFF_PCSP_HI], %dr8 rwd %dr2, %cr0.hi rwd %dr3, %cr1.lo rwd %dr4, %cr1.hi rwd %dr5, %usd.lo rwd %dr6, %usd.hi rwd %dr7, %psp.hi rwd %dr8, %pcsp.hi <span class="hljs-comment"><span class="hljs-comment">/* Enable interrupts */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, ipl_restore ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Actually, we return to setjmp caller with second * argument of longjmp stored on r1 register. */</span></span> adds <span class="hljs-number"><span class="hljs-number">0</span></span>, %r1, %r0 E2K_ASM_RETURN</code> </pre> <br><h3>  Cambio de contexto </h3><br>  Después de descubrir setjmp / longjmp, la implementación básica de context_switch nos pareció bastante clara.  De hecho, como en el primer caso, necesitamos guardar / restaurar los registros de información y pilas de conexión, además de restaurar correctamente el registro de estado del procesador (UPSR). <br><br>  Te lo explicaré.  Como en el caso de setjmp, al guardar registros, primero debe restablecer el archivo de registro y el archivo de información de enlace en la memoria (flushr + flushc).  Después de eso, necesitamos guardar los valores actuales de los registros CR0 y CR1 para que cuando regresemos, saltemos exactamente a donde se cambió la corriente actual.  A continuación, guardamos los descriptores de pila para PS, PCS y EE. UU.  Y finalmente, debe encargarse de la restauración correcta del modo de interrupción; para estos fines, también guardamos el registro UPSR. <br><br>  Código de ensamblador context_switch: <br><br><pre> <code class="cpp hljs">C_ENTRY(context_switch): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Save prev UPSR */</span></span> rrd %upsr, %dr2 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_CTX_UPSR] <span class="hljs-comment"><span class="hljs-comment">/* Disable interrupts before saving/restoring context */</span></span> rrd %upsr, %dr2 andnd %dr2, (UPSR_IE | UPSR_NMIE), %dr2 rwd %dr2, %upsr E2K_ASM_FLUSH_CPU <span class="hljs-comment"><span class="hljs-comment">/* Save prev CRs */</span></span> rrd %cr0.lo, %dr2 rrd %cr0.hi, %dr3 rrd %cr1.lo, %dr4 rrd %cr1.hi, %dr5 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_CTX_CR0_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_CTX_CR0_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_CTX_CR1_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_CTX_CR1_HI] <span class="hljs-comment"><span class="hljs-comment">/* Save prev stacks */</span></span> rrd %usd.lo, %dr3 rrd %usd.hi, %dr4 rrd %psp.lo, %dr5 rrd %psp.hi, %dr6 rrd %pcsp.lo, %dr7 rrd %pcsp.hi, %dr8 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_CTX_USD_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_CTX_USD_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_CTX_PSP_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr6, [%dr0 + E2K_CTX_PSP_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr7, [%dr0 + E2K_CTX_PCSP_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr8, [%dr0 + E2K_CTX_PCSP_HI] <span class="hljs-comment"><span class="hljs-comment">/* Load next CRs */</span></span> ldd [%dr1 + E2K_CTX_CR0_LO], %dr2 ldd [%dr1 + E2K_CTX_CR0_HI], %dr3 ldd [%dr1 + E2K_CTX_CR1_LO], %dr4 ldd [%dr1 + E2K_CTX_CR1_HI], %dr5 rwd %dr2, %cr0.lo rwd %dr3, %cr0.hi rwd %dr4, %cr1.lo rwd %dr5, %cr1.hi <span class="hljs-comment"><span class="hljs-comment">/* Load next stacks */</span></span> ldd [%dr1 + E2K_CTX_USD_LO], %dr3 ldd [%dr1 + E2K_CTX_USD_HI], %dr4 ldd [%dr1 + E2K_CTX_PSP_LO], %dr5 ldd [%dr1 + E2K_CTX_PSP_HI], %dr6 ldd [%dr1 + E2K_CTX_PCSP_LO], %dr7 ldd [%dr1 + E2K_CTX_PCSP_HI], %dr8 rwd %dr3, %usd.lo rwd %dr4, %usd.hi rwd %dr5, %psp.lo rwd %dr6, %psp.hi rwd %dr7, %pcsp.lo rwd %dr8, %pcsp.hi <span class="hljs-comment"><span class="hljs-comment">/* Restore next UPSR */</span></span> ldd [%dr1 + E2K_CTX_UPSR], %dr2 rwd %dr2, %upsr E2K_ASM_RETURN</code> </pre> <br>  Otro punto importante es la inicialización del hilo del sistema operativo.  En Embox, cada hilo tiene un cierto procedimiento primario <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _<span class="hljs-function"><span class="hljs-function">NORETURN </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread_trampoline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  en el que se ejecutará todo el trabajo adicional de la secuencia.  Por lo tanto, necesitamos preparar de alguna manera las pilas para llamar a esta función, es aquí donde nos enfrentamos con el hecho de que hay tres pilas, y que no crecen en la misma dirección.  Por arquitectura, creamos una secuencia con una sola pila, o más bien, tiene un solo lugar debajo de la pila, en la parte superior tenemos una estructura que describe la secuencia en sí, y así sucesivamente, aquí tuvimos que ocuparnos de diferentes pilas, sin olvidar que deberían alinearse en 4 kB, no olvide todo tipo de derechos de acceso, etc. <br><br>  Como resultado, en este momento decidimos que dividiremos el espacio debajo de la pila en tres partes, una cuarta parte debajo de la pila de información vinculante, una cuarta parte debajo de la pila de procedimientos y la mitad debajo de la pila de usuarios. <br><br><div class="spoiler">  <b class="spoiler_title">Traigo el código para que pueda evaluar qué tan grande es, debe tener en cuenta que esta es una inicialización mínima.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* This value is used for both stack base and size align. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_STACK_ALIGN (1UL </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 12) #define round_down(x, bound) ((x) &amp; ~((bound) - 1)) /* Reserve 1/4 for PSP stack, 1/4 for PCSP stack, and 1/2 for USD stack */ #define PSP_CALC_STACK_BASE(sp, size) binalign_bound(sp - size, E2K_STACK_ALIGN) #define PSP_CALC_STACK_SIZE(sp, size) binalign_bound((size) / 4, E2K_STACK_ALIGN) #define PCSP_CALC_STACK_BASE(sp, size) \ (PSP_CALC_STACK_BASE(sp, size) + PSP_CALC_STACK_SIZE(sp, size)) #define PCSP_CALC_STACK_SIZE(sp, size) binalign_bound((size) / 4, E2K_STACK_ALIGN) #define USD_CALC_STACK_BASE(sp, size) round_down(sp, E2K_STACK_ALIGN) #define USD_CALC_STACK_SIZE(sp, size) \ round_down(USD_CALC_STACK_BASE(sp, size) - PCSP_CALC_STACK_BASE(sp, size),\ E2K_STACK_ALIGN) static void e2k_calculate_stacks(struct context *ctx, uint64_t sp, uint64_t size) { uint64_t psp_size, pcsp_size, usd_size; log_debug("Stacks:\n"); ctx-&gt;psp_lo |= PSP_CALC_STACK_BASE(sp, size) &lt;&lt; PSP_BASE; ctx-&gt;psp_lo |= E2_RWAR_RW_ENABLE &lt;&lt; PSP_RW; psp_size = PSP_CALC_STACK_SIZE(sp, size); assert(psp_size); ctx-&gt;psp_hi |= psp_size &lt;&lt; PSP_SIZE; log_debug(" PSP.base=0x%lx, PSP.size=0x%lx\n", PSP_CALC_STACK_BASE(sp, size), psp_size); ctx-&gt;pcsp_lo |= PCSP_CALC_STACK_BASE(sp, size) &lt;&lt; PCSP_BASE; ctx-&gt;pcsp_lo |= E2_RWAR_RW_ENABLE &lt;&lt; PCSP_RW; pcsp_size = PCSP_CALC_STACK_SIZE(sp, size); assert(pcsp_size); ctx-&gt;pcsp_hi |= pcsp_size &lt;&lt; PCSP_SIZE; log_debug(" PCSP.base=0x%lx, PCSP.size=0x%lx\n", PCSP_CALC_STACK_BASE(sp, size), pcsp_size); ctx-&gt;usd_lo |= USD_CALC_STACK_BASE(sp, size) &lt;&lt; USD_BASE; usd_size = USD_CALC_STACK_SIZE(sp, size); assert(usd_size); ctx-&gt;usd_hi |= usd_size &lt;&lt; USD_SIZE; log_debug(" USD.base=0x%lx, USD.size=0x%lx\n", USD_CALC_STACK_BASE(sp, size), usd_size); } static void e2k_calculate_crs(struct context *ctx, uint64_t routine_addr) { uint64_t usd_size = (ctx-&gt;usd_hi &gt;&gt; USD_SIZE) &amp; USD_SIZE_MASK; /* Reserve space in hardware stacks for @routine_addr */ /* Remark: We do not update psp.hi to reserve space for arguments, * since routine do not accepts any arguments. */ ctx-&gt;pcsp_hi |= SZ_OF_CR0_CR1 &lt;&lt; PCSP_IND; ctx-&gt;cr0_hi |= (routine_addr &gt;&gt; CR0_IP) &lt;&lt; CR0_IP; ctx-&gt;cr1_lo |= PSR_ALL_IRQ_ENABLED &lt;&lt; CR1_PSR; /* Divide on 16 because it field contains size in terms * of 128 bit values. */ ctx-&gt;cr1_hi |= (usd_size &gt;&gt; 4) &lt;&lt; CR1_USSZ; } void context_init(struct context *ctx, unsigned int flags, void (*routine_fn)(void), void *sp, unsigned int stack_size) { memset(ctx, 0, sizeof(*ctx)); e2k_calculate_stacks(ctx, sp, stack_size); e2k_calculate_crs(ctx, (uint64_t) routine_fn); if (!(flags &amp; CONTEXT_IRQDISABLE)) { ctx-&gt;upsr |= (UPSR_IE | UPSR_NMIE); } }</span></span></span></span></code> </pre> <br></div></div><br>  El artículo también contenía trabajo con interrupciones, excepciones y temporizadores, pero como resultó ser tan grande, decidimos hablar sobre ello en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">siguiente parte</a> . <br><br>  Por si acaso, repito, este material no es documentación oficial.  Para soporte oficial, documentación y el resto, necesita contactar al ICST directamente.  El código en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Embox</a> , por supuesto, está abierto, pero para compilarlo, necesitará un compilador cruzado, que, nuevamente, se puede obtener del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MCST</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447704/">https://habr.com/ru/post/447704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447694/index.html">Configuración del sistema distribuido compilado</a></li>
<li><a href="../447696/index.html">¿Por qué las ciudades se oponen a Amazon Go, las primeras tiendas sin efectivo?</a></li>
<li><a href="../447698/index.html">Red Hogwarts: académico sin diploma</a></li>
<li><a href="../447700/index.html">La flexibilidad emocional es la clave del crecimiento personal.</a></li>
<li><a href="../447702/index.html">El círculo matemático ideal no existe.</a></li>
<li><a href="../447706/index.html">Ni un solo ORM</a></li>
<li><a href="../447708/index.html">Yandex presentó a los jóvenes científicos y líderes científicos los primeros premios Ilya Segalovich</a></li>
<li><a href="../447712/index.html">Hola SaaS | Rusia SaaS 2018 - resultados</a></li>
<li><a href="../447714/index.html">Sobre la aplicación de la teoría de los procesos ARMA en la práctica de la ingeniería.</a></li>
<li><a href="../447716/index.html">Unidad: dibuja muchas barras de salud en una sola llamada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>