<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游냆 游돖游낖 游놇 Climbing Elbrus - Reconocimiento en batalla. Parte t칠cnica 1. Registros, pilas y otros detalles t칠cnicos. 游띏游낗 游녢游낗 游뱇游</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seg칰n lo prometido , seguimos hablando sobre el desarrollo de procesadores Elbrus . Este art칤culo es t칠cnico. La informaci칩n proporcionada en el art칤c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Climbing Elbrus - Reconocimiento en batalla. Parte t칠cnica 1. Registros, pilas y otros detalles t칠cnicos.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/447704/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Seg칰n lo prometido</a> , seguimos hablando sobre el desarrollo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de procesadores Elbrus</a> .  Este art칤culo es t칠cnico.  La informaci칩n proporcionada en el art칤culo no es documentaci칩n oficial, ya que se obtuvo durante el estudio de Elbrus como una caja negra.  Pero sin duda ser치 interesante para una mejor comprensi칩n de la arquitectura de Elbrus, porque aunque ten칤amos documentaci칩n oficial, muchos detalles quedaron claros solo despu칠s de largos experimentos, cuando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Embox</a> funcion칩. <br><br>  Recuerde que en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art칤culo anterior</a> hablamos sobre el arranque b치sico del sistema y el controlador del puerto serie.  Embox comenz칩, pero para avanzar a칰n m치s necesit치bamos interrupciones, un temporizador del sistema y, por supuesto, me gustar칤a incluir un conjunto de pruebas unitarias, y para esto necesitamos setjmp.  Este art칤culo se enfocar치 en registros, pilas y otros detalles t칠cnicos necesarios para implementar todas estas cosas. <br><a name="habracut"></a><br>  Comencemos con una breve introducci칩n a la arquitectura, que es la informaci칩n m칤nima necesaria para comprender lo que se discutir치 m치s adelante.  En el futuro, nos referiremos a la informaci칩n de esta secci칩n. <br><br><h3>  Breve introducci칩n: pilas </h3><br>  Hay tres pilas en Elbrus: <br><br><ul><li>  Pila de procedimientos (PS) </li><li> Pila de cadena de procedimiento (PCS) </li><li>  Pila de usuario (EE. UU.) </li></ul><br>  Analicemos con m치s detalle.  Las direcciones en la figura son condicionales, muestran en qu칠 direcci칩n se dirigen los movimientos, desde una direcci칩n m치s grande a una m치s peque침a o viceversa. <br><br><img src="https://habrastorage.org/webt/le/bc/ac/lebcace6fqkdk5vvhwke6kajyuu.png"><br><br>  La pila de procedimientos (PS) est치 destinada a datos asignados a registros "operativos". <br><br>  Por ejemplo, pueden ser argumentos de funci칩n, en arquitecturas "ordinarias", este concepto est치 m치s cerca de los registros de prop칩sito general.  A diferencia de las arquitecturas de procesador "normales", en E2K, los registros utilizados en las funciones se apilan en una pila separada. <br><br>  La Pila de informaci칩n de enlace (PCS) est치 dise침ada para colocar informaci칩n sobre el procedimiento (de llamada) anterior y se utiliza al regresar.  Los datos en la direcci칩n del remitente, as칤 como en el caso de los registros, se colocan en un lugar separado.  Por lo tanto, la promoci칩n de la pila (por ejemplo, salir por excepci칩n en C ++) es un proceso que consume m치s tiempo que en las arquitecturas "ordinarias".  Por otro lado, esto elimina los problemas de desbordamiento de pila. <br><br>  Ambas pilas (PS y PCS) se caracterizan por una direcci칩n base, tama침o y desplazamiento actual.  Estos par치metros se establecen en los registros PSP y PCSP, son de 128 bits y en el ensamblador debe hacer referencia a campos espec칤ficos (por ejemplo, alto o bajo).  Adem치s, el funcionamiento de las pilas est치 estrechamente relacionado con el concepto de un archivo de registro, m치s sobre eso a continuaci칩n.  La interacci칩n con el archivo ocurre a trav칠s del mecanismo de bombeo / intercambio de registros.  El llamado "puntero de hardware a la parte superior de la pila" del procedimiento o la pila de informaci칩n vinculante desempe침a un papel activo en este mecanismo, respectivamente.  Sobre esto tambi칠n a continuaci칩n.  Es importante que en cada momento los datos de estas pilas est칠n en RAM o en un archivo de registro. <br><br>  Tambi칠n vale la pena se침alar que estas pilas (la pila de procedimientos y la pila de informaci칩n de enlace) crecen.  Nos encontramos con esto cuando implementamos context_switch. <br><br>  La pila de usuarios tambi칠n recibe la direcci칩n base y el tama침o.  El puntero actual est치 en el registro USD.lo.  En esencia, es una pila cl치sica que crece hacia abajo.  Solo que, a diferencia de las arquitecturas "ordinarias", la informaci칩n de otras pilas (registros y direcciones de retorno) no cabe all칤. <br><br>  Un requisito no est치ndar, en mi opini칩n, para los l칤mites y tama침os de las pilas es la alineaci칩n de 4Kb, y tanto la direcci칩n base de la pila como su tama침o deben estar alineados a 4Kb.  En otras arquitecturas, no he cumplido esa restricci칩n.  Nos encontramos con este detalle, nuevamente, cuando implementamos context_switch. <br><br><h3>  Breve introducci칩n: registros.  Registrar archivos  Registrar ventanas </h3><br>  Ahora que hemos descubierto un poco las pilas, necesitamos entender c칩mo se presenta la informaci칩n en ellas.  Para hacer esto, necesitamos introducir algunos conceptos m치s. <br><br>  Un archivo de registro (RF) es un conjunto de todos los registros.  Hay dos archivos de registro que necesitamos: un archivo de informaci칩n de conexi칩n (archivo de cadena - CF), el otro se llama archivo de registro (RF), almacena registros "operativos", que se almacenan en la pila de procedimientos. <br><br>  La ventana de registro es el 치rea (conjunto de registros) del archivo de registro que est치 disponible actualmente. <br><br>  Explicar칠 con m치s detalle.  Creo que es un conjunto de registros que nadie necesita explicar. <br><br>  Es bien sabido que uno de los cuellos de botella en la arquitectura x86 es precisamente un peque침o n칰mero de registros.  En arquitecturas RISC con registros es m치s simple, generalmente alrededor de 16 registros, de los cuales varios (2-3) est치n ocupados para necesidades oficiales.  쯇or qu칠 no simplemente hacer 128 registros, porque parece que esto aumentar치 el rendimiento del sistema?  La respuesta es bastante simple: una instrucci칩n de procesador necesita un lugar para almacenar la direcci칩n de registro, y si hay muchos de ellos, tambi칠n se necesitan muchos bits para esto.  Por lo tanto, recurren a todo tipo de trucos, hacen registros de sombra, registran bancos, ventanas, etc.  Por registros sombra, me refiero al principio de organizaci칩n de registros en ARM.  Si ocurre una interrupci칩n u otra situaci칩n, entonces est치 disponible un conjunto diferente de registros con los mismos nombres (n칰meros), mientras la informaci칩n almacenada en el conjunto original permanece all칤.  Los bancos de registros, de hecho, son muy similares a los registros sombra, simplemente no hay cambio de hardware de los conjuntos de registros, y el programador elige a qu칠 banco (conjunto de registros) contactar ahora. <br><br>  Las ventanas de registro est치n dise침adas para optimizar el trabajo con la pila.  Como probablemente comprenda, en una arquitectura "normal" usted ingresa un procedimiento, guarda registros en la pila (o el procedimiento de llamada guarda, depende del acuerdo) y puede usar registros, porque la informaci칩n ya est치 almacenada en la pila.  Pero el acceso a la memoria es lento y, por lo tanto, debe evitarse.  Al ingresar al procedimiento, hagamos que un nuevo conjunto de registros est칠 disponible, los datos del anterior se guardar치n, lo que significa que no necesita volcarlos en la memoria.  Adem치s, cuando regrese al procedimiento de llamada, la ventana de registro anterior tambi칠n devolver치, por lo tanto, todos los datos en los registros ser치n relevantes.  Este es el concepto de una ventana de registro. <br><br><img src="https://habrastorage.org/webt/lg/5e/6u/lg5e6u_pfus75yedi6hefckkqkk.png"><br><br>  Est치 claro que a칰n necesita guardar los registros en la pila (en la memoria), pero esto puede hacerse cuando las ventanas de registro libre hayan finalizado. <br><br>  쯏 qu칠 hacer con los registros de entrada y salida (argumentos al ingresar la funci칩n y el resultado devuelto)?  Deje que la ventana contenga parte de los registros visibles desde la ventana anterior, m치s precisamente, parte de los registros estar치 disponible para ambas ventanas.  Luego, en general, cuando se llama a la funci칩n, no tiene que acceder a la memoria.  Supongamos que nuestros registros se ven as칤 <br><br><img src="https://habrastorage.org/webt/n9/ki/zw/n9kizwn2qkag4rew2jspyassaco.png"><br><br>  Es decir, r0 en la primera ventana ser치 el mismo registro que r2 en cero, y r1 desde la primera ventana en el mismo registro que r3.  Es decir, escribiendo en r2 antes de llamar al procedimiento (cambiando el n칰mero de ventana) obtenemos el valor en r0 en el procedimiento llamado.  Este principio se llama mecanismo de ventanas giratorias. <br><br>  Optimicemos un poco m치s, porque los creadores de Elbrus hicieron exactamente eso.  Deje que las ventanas que tenemos no sean de un tama침o fijo, sino variable, el tama침o de la ventana se puede establecer en el momento de la entrada en el procedimiento.  Haremos lo mismo con el n칰mero de registros rotados.  Por supuesto, esto nos llevar치 a algunos problemas, porque si en las ventanas giratorias cl치sicas, hay un 칤ndice de ventana a trav칠s del cual se determina que necesita guardar los datos del archivo de registro en la pila o cargarlos.  Pero si ingresa no el 칤ndice de la ventana, sino el 칤ndice de registro desde el cual comienza nuestra ventana actual, entonces este problema no surgir치.  En Elbrus, estos 칤ndices est치n contenidos en los registros PSHTP (para la pila de procedimientos PS) y PCSHTP (para la pila de informaci칩n de procedimientos PCS).  La documentaci칩n se refiere a "punteros de hardware en la parte superior de la pila".  Ahora puedes intentar leer de nuevo sobre las pilas, creo que ser치 m치s claro. <br><br>  Como comprender치, dicho mecanismo implica que tiene la capacidad de controlar lo que est치 en la memoria.  Es decir, sincronice el archivo de registro y la pila.  Me refiero a un programador de sistemas.  Si usted es un programador de aplicaciones, el equipo proporcionar치 una entrada y una salida transparentes del procedimiento.  Es decir, si no hay suficientes registros al intentar seleccionar una nueva ventana, la ventana de registro se "bombear치" autom치ticamente.  En este caso, todos los datos del archivo de registro se guardar치n en la pila apropiada (en la memoria), y el "puntero a la parte superior del hardware de la pila" (칤ndice de compensaci칩n) se restablecer치 a cero.  Del mismo modo, el intercambio de un archivo de registro de la pila se produce autom치ticamente.  Pero si est치 desarrollando, por ejemplo, el cambio de contexto, que es exactamente lo que hicimos, entonces necesita un mecanismo para trabajar con la parte oculta del archivo de registro.  En Elbrus, los comandos FLUSHR y FLUSHC se utilizan para esto.  FLUSHR: al borrar el archivo de registro, todas las ventanas, excepto la actual, se vac칤an a la pila de procedimientos, por lo que el 칤ndice PSHTP se restablece a cero.  FLUSHC: limpia el archivo de informaci칩n de enlace, todo, excepto la ventana actual, se descarga en la pila de informaci칩n de enlace, el 칤ndice PCSHTP tambi칠n se restablece a cero. <br><br><h3>  Breve introducci칩n: implementaci칩n en Elbrus </h3><br>  Ahora que hemos discutido el trabajo no obvio con registros y pilas, hablaremos m치s espec칤ficamente sobre varias situaciones en Elbrus. <br><br>  Cuando ingresamos a la siguiente funci칩n, el procesador crea dos ventanas: una ventana en la pila PS y una ventana en la pila PCS. <br><br>  Una ventana en la pila PCS contiene la informaci칩n necesaria para regresar de una funci칩n: por ejemplo, IP (puntero de instrucci칩n) de la instrucci칩n en la que deber치 regresar de la funci칩n.  Con esto, todo est치 m치s o menos claro. <br><br>  La ventana en la pila PS es un poco m치s complicada.  Se introduce el concepto de registros de la ventana actual.  En esta ventana, tendr치 acceso a los registros de la ventana actual:% dr0,% dr1, ...,% dr15, ... Es decir, para nosotros, como usuario, siempre est치n numerados desde 0, pero esta es una numeraci칩n relativa a la direcci칩n base de la ventana actual.  A trav칠s de estos registros, los argumentos se pasan cuando se llama a la funci칩n, se devuelve el valor y la funci칩n se utiliza como registros de prop칩sito general dentro de la funci칩n.  En realidad, esto se explic칩 al considerar el mecanismo de rotaci칩n de las ventanas de registro. <br><br>  El tama침o de la ventana de registro en Elbrus se puede controlar.  Esto, como dije, es necesario para la optimizaci칩n.  Por ejemplo, en una funci칩n solo necesitamos 4 registros para pasar argumentos y algunos c치lculos, en este caso el programador (o compilador) decide cu치ntos registros asignar para la funci칩n, y en funci칩n de esto establece el tama침o de la ventana.  El tama침o de la ventana lo establece la operaci칩n setwd: <br><br><pre><code class="cpp hljs">setwd wsz=<span class="hljs-number"><span class="hljs-number">0x10</span></span></code> </pre> <br>  Especifica el tama침o de la ventana en t칠rminos de registros cu치druples (registros de 128 bits). <br><br><img src="https://habrastorage.org/webt/tf/ov/px/tfovpxrj1wkos3e29zsl0fj_8p8.png"><br><br>  Ahora, supongamos que desea llamar a una funci칩n desde una funci칩n.  Para esto, se aplica el concepto ya descrito de una ventana de registro girada.  La imagen de arriba muestra un fragmento de un archivo de registro donde una funci칩n con la ventana 1 (verde) llama a una funci칩n con la ventana 2 (naranja).  En cada una de estas dos funciones tendr치 acceso a su% dr0,% dr1, ... Pero los argumentos se pasar치n por los llamados registros rotativos.  En otras palabras, parte de los registros de la ventana 1 se convertir치n en los registros de la ventana 2 (tenga en cuenta que estas dos ventanas se cruzan).  Estos registros tambi칠n los establece la ventana (consulte Registros rotativos en la imagen) y tienen la direcci칩n% db [0],% db [1], ... Por lo tanto, el registro% dr0 en la ventana 2 no es m치s que el registro% db [0] en ventana 1. <br><br>  La ventana de registro de rotaci칩n se establece mediante la operaci칩n setbn: <br><br><pre> <code class="cpp hljs"> setbn rbs = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rsz = <span class="hljs-number"><span class="hljs-number">0x8</span></span></code> </pre> <br>  rbs establece el tama침o de la ventana girada y rsz establece la direcci칩n base, pero en relaci칩n con la ventana de registro actual.  Es decir  Aqu칤 hemos asignado 3 registros, comenzando desde el 8. <br><br>  En base a lo anterior, mostramos c칩mo se ve la llamada a la funci칩n.  Por simplicidad, suponemos que la funci칩n toma un argumento: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Luego, para llamar a esta funci칩n, debe preparar una ventana de registros rotativos (ya lo hemos hecho a trav칠s de setbn).  Luego, en el registro% db0 colocamos el valor que se pasar치 a my_func.  Despu칠s de esto, debe llamar a la instrucci칩n CALL y no olvide decirle d칩nde comienza la ventana de registros rotados.  Omitimos la preparaci칩n para la llamada (el comando disp) ahora, porque no distingue entre may칰sculas y min칰sculas.  Como resultado, en ensamblador, una llamada a esta funci칩n deber칤a verse as칤: <br><br><pre> <code class="cpp hljs"> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, my_func call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x8</span></span></code> </pre> <br>  Entonces, con registros un poco resueltos.  Ahora veamos la pila de informaci칩n vinculante.  Almacena los llamados registros CR.  De hecho, dos: CR0, CR1.  Y ya contienen la informaci칩n necesaria para regresar de la funci칩n. <br><br><img src="https://habrastorage.org/webt/rc/8q/kl/rc8qklg-pb3tgwv3jjz_8pc6l3g.png"><br><br>  Los registros CR0 y CR1 de la ventana de la funci칩n que llam칩 a la funci칩n con los registros marcados en naranja son verdes.  Los registros CR0 contienen el puntero de instrucci칩n de la funci칩n de llamada y un determinado archivo de predicado (PF-Predicate File), una historia al respecto definitivamente est치 fuera del alcance de este art칤culo. <br><br>  Los registros CR1 contienen datos como PSR (estado del procesador de textos), n칰mero de ventana, tama침os de ventana, etc.  En Elbrus, todo es tan flexible que cada procedimiento almacena informaci칩n en CR1, incluso si la operaci칩n de punto flotante est치 incluida en el procedimiento, y un registro que contiene informaci칩n sobre excepciones de software, pero para esto, por supuesto, debe pagar para guardar informaci칩n adicional. <br><br>  Es muy importante no olvidar que el archivo de registro y el archivo de informaci칩n de enlace se pueden extraer y cambiar de la memoria principal y viceversa (de las pilas PS y PCS descritas anteriormente).  Este punto es importante al implementar setjmp que se describe m치s adelante. <br><br><h3>  SETJMP / LONGJMP </h3><br>  Y finalmente, al menos de alguna manera entendiendo c칩mo se organizan las pilas y los registros en Elbrus, puede comenzar a hacer algo 칰til, es decir, agregar una nueva funcionalidad a Embox. <br><br>  En Embox, el sistema de prueba de la unidad requiere setjmp / longjmp, por lo que tuvimos que implementar estas funciones. <br><br>  Para la implementaci칩n, se requiere guardar / restaurar los registros: CR0, CR1, PSP, PCSP, USD, que ya conocemos en una breve introducci칩n.  De hecho, guardar / restaurar se implementa en nuestra frente, pero hay un matiz significativo que a menudo se insinu칩 en la descripci칩n de pilas y registros, a saber: las pilas deben estar sincronizadas, porque est치n ubicadas no solo en la memoria, sino tambi칠n en el archivo de registro.  Este matiz significa que necesita cuidar varias caracter칤sticas, sin las cuales nada funcionar치. <br><br>  La primera caracter칤stica es deshabilitar las interrupciones durante el guardado y la restauraci칩n.  Al restaurar una interrupci칩n, es obligatorio prohibirla; de lo contrario, puede surgir una situaci칩n en la que ingresemos el controlador de interrupciones con pilas a medio cambiar (refiri칠ndose a bombear el intercambio de archivos de registro descrito en la "breve descripci칩n").  Y al guardar, el problema es que despu칠s de ingresar y salir de la interrupci칩n, el procesador puede intercambiar nuevamente parte del archivo de registro de la RAM (y esto arruinar치 las condiciones invariantes PSHTP = 0 y PSCHTP = 0, un poco m치s sobre ellas).  Es por eso que, tanto en setjmp como en longjmp, las interrupciones deben deshabilitarse.  Tambi칠n debe se침alarse aqu칤 que los especialistas del MCST nos aconsejaron usar corchetes at칩micos en lugar de deshabilitar las interrupciones, pero por ahora usamos la implementaci칩n m치s simple (comprensible para nosotros). <br><br>  La segunda caracter칤stica est치 relacionada con el bombeo / bombeo de un archivo de registro de la memoria.  Es como sigue.  El archivo de registro tiene un tama침o limitado y, por lo tanto, a menudo se bombea a la memoria y viceversa.  Por lo tanto, si simplemente guardamos los valores de los registros PSP y PSHTP, entonces fijaremos el valor del puntero actual en la memoria y en el archivo de registro.  Pero dado que el archivo de registro est치 cambiando, en el momento de la restauraci칩n del contexto indicar치 datos ya incorrectos (no los que hemos "guardado").  Para evitar esto, debe vaciar todo el archivo de registro en la memoria.  Por lo tanto, al guardar en setjmp, tenemos registros PSP.ind en la memoria y registros PSHTP.ind en la ventana de registro.  Resulta que necesita guardar todos los registros PCSP.ind + PCSHTP.ind.  La siguiente es la funci칩n que realiza esta operaci칩n: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* First arg is PCSP, 2nd arg is PCSHTP * Returns new PCSP value with updated PCSP.ind */</span></span> .type update_pcsp_ind,@function $update_pcsp_ind: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x4</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Here and below, 10 is size of PCSHTP.ind. Here we * extend the sign of PCSHTP.ind */</span></span> shld %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span>), %dr1 shrd %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span>), %dr1 <span class="hljs-comment"><span class="hljs-comment">/* Finally, PCSP.ind += PCSHTP.ind */</span></span> addd %dr1, %dr0, %dr0 E2K_ASM_RETURN</code> </pre> <br>  Tambi칠n es necesario aclarar un peque침o punto en este c칩digo descrito en el comentario, es decir, es necesario expandir mediante programaci칩n el car치cter en el 칤ndice PCSHTP.ind, porque el 칤ndice puede ser negativo y almacenarse en un c칩digo adicional.  Para hacer esto, primero cambiamos a (64-10) a la izquierda (registro de 64 bits), a un campo de 10 bits y luego regresamos. <br><br>  Lo mismo ocurre con la PSP (pila de procedimientos) <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* First arg is PSP, 2nd arg is PSHTP * Returns new PSP value with updated PSP.ind */</span></span> .type update_psp_ind,@function $update_psp_ind: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x4</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Here and below, 12 is size of PSHTP.ind. Here we * extend the sign of PSHTP.ind as stated in documentation */</span></span> shld %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">12</span></span>), %dr1 shrd %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">12</span></span>), %dr1 muld %dr1, <span class="hljs-number"><span class="hljs-number">2</span></span>, %dr1 <span class="hljs-comment"><span class="hljs-comment">/* Finally, PSP.ind += PSHTP.ind */</span></span> addd %dr1, %dr0, %dr0 E2K_ASM_RETURN</code> </pre> <br>  Con una ligera diferencia (el campo es de 12 bits y los registros se cuentan all칤 en t칠rminos de 128 bits, es decir, el valor debe multiplicarse por 2). <br><br>  C칩digo setjmp en s칤 <br><br><pre> <code class="cpp hljs">C_ENTRY(setjmp): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x14</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* It's for db[N] registers */</span></span> setbn rsz = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, rcur = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* We must disable interrupts here */</span></span> disp %ctpr1, ipl_save ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Store current IPL to dr9 */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr9 <span class="hljs-comment"><span class="hljs-comment">/* Store some registers to jmp_buf */</span></span> rrd %cr0.hi, %dr1 rrd %cr1.lo, %dr2 rrd %cr1.hi, %dr3 rrd %usd.lo, %dr4 rrd %usd.hi, %dr5 <span class="hljs-comment"><span class="hljs-comment">/* Prepare RF stack to flush in longjmp */</span></span> rrd %psp.hi, %dr6 rrd %pshtp, %dr7 addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr6, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr7, %db[<span class="hljs-number"><span class="hljs-number">1</span></span>] disp %ctpr1, update_psp_ind ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr6 <span class="hljs-comment"><span class="hljs-comment">/* Prepare CF stack to flush in longjmp */</span></span> rrd %pcsp.hi, %dr7 rrd %pcshtp, %dr8 addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr7, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr8, %db[<span class="hljs-number"><span class="hljs-number">1</span></span>] disp %ctpr1, update_pcsp_ind ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr7 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr1, [%dr0 + E2K_JMBBUFF_CR0_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_JMBBUFF_CR1_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_JMBBUFF_CR1_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_JMBBUFF_USD_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_JMBBUFF_USD_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr6, [%dr0 + E2K_JMBBUFF_PSP_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr7, [%dr0 + E2K_JMBBUFF_PCSP_HI] <span class="hljs-comment"><span class="hljs-comment">/* Enable interrupts */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, ipl_restore ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* return 0 */</span></span> adds <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, %r0 E2K_ASM_RETURN</code> </pre> <br>  Al implementar longjmp, es importante no olvidarse de la sincronizaci칩n de ambos archivos de registro, por lo tanto, debe vaciar no solo la ventana de registro (flushr), sino tambi칠n el archivo de carpeta (flushc).  Describamos la macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_ASM_FLUSH_CPU \ flushr; \ nop 2; \ flushc; \ nop 3;</span></span></code> </pre> <br>  Ahora que toda la informaci칩n est치 en la memoria, podemos registrar de forma segura la recuperaci칩n en longjmp. <br><br><pre> <code class="cpp hljs">C_ENTRY(longjmp): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x14</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> setbn rsz = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, rcur = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* We must disable interrupts here */</span></span> disp %ctpr1, ipl_save ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Store current IPL to dr9 */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr9 <span class="hljs-comment"><span class="hljs-comment">/* We have to flush both RF and CF to memory because saved values * of P[C]SHTP can be not valid here. */</span></span> E2K_ASM_FLUSH_CPU <span class="hljs-comment"><span class="hljs-comment">/* Load registers previously saved in setjmp. */</span></span> ldd [%dr0 + E2K_JMBBUFF_CR0_HI], %dr2 ldd [%dr0 + E2K_JMBBUFF_CR1_LO], %dr3 ldd [%dr0 + E2K_JMBBUFF_CR1_HI], %dr4 ldd [%dr0 + E2K_JMBBUFF_USD_LO], %dr5 ldd [%dr0 + E2K_JMBBUFF_USD_HI], %dr6 ldd [%dr0 + E2K_JMBBUFF_PSP_HI], %dr7 ldd [%dr0 + E2K_JMBBUFF_PCSP_HI], %dr8 rwd %dr2, %cr0.hi rwd %dr3, %cr1.lo rwd %dr4, %cr1.hi rwd %dr5, %usd.lo rwd %dr6, %usd.hi rwd %dr7, %psp.hi rwd %dr8, %pcsp.hi <span class="hljs-comment"><span class="hljs-comment">/* Enable interrupts */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, ipl_restore ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Actually, we return to setjmp caller with second * argument of longjmp stored on r1 register. */</span></span> adds <span class="hljs-number"><span class="hljs-number">0</span></span>, %r1, %r0 E2K_ASM_RETURN</code> </pre> <br><h3>  Cambio de contexto </h3><br>  Despu칠s de descubrir setjmp / longjmp, la implementaci칩n b치sica de context_switch nos pareci칩 bastante clara.  De hecho, como en el primer caso, necesitamos guardar / restaurar los registros de informaci칩n y pilas de conexi칩n, adem치s de restaurar correctamente el registro de estado del procesador (UPSR). <br><br>  Te lo explicar칠.  Como en el caso de setjmp, al guardar registros, primero debe restablecer el archivo de registro y el archivo de informaci칩n de enlace en la memoria (flushr + flushc).  Despu칠s de eso, necesitamos guardar los valores actuales de los registros CR0 y CR1 para que cuando regresemos, saltemos exactamente a donde se cambi칩 la corriente actual.  A continuaci칩n, guardamos los descriptores de pila para PS, PCS y EE. UU.  Y finalmente, debe encargarse de la restauraci칩n correcta del modo de interrupci칩n; para estos fines, tambi칠n guardamos el registro UPSR. <br><br>  C칩digo de ensamblador context_switch: <br><br><pre> <code class="cpp hljs">C_ENTRY(context_switch): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Save prev UPSR */</span></span> rrd %upsr, %dr2 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_CTX_UPSR] <span class="hljs-comment"><span class="hljs-comment">/* Disable interrupts before saving/restoring context */</span></span> rrd %upsr, %dr2 andnd %dr2, (UPSR_IE | UPSR_NMIE), %dr2 rwd %dr2, %upsr E2K_ASM_FLUSH_CPU <span class="hljs-comment"><span class="hljs-comment">/* Save prev CRs */</span></span> rrd %cr0.lo, %dr2 rrd %cr0.hi, %dr3 rrd %cr1.lo, %dr4 rrd %cr1.hi, %dr5 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_CTX_CR0_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_CTX_CR0_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_CTX_CR1_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_CTX_CR1_HI] <span class="hljs-comment"><span class="hljs-comment">/* Save prev stacks */</span></span> rrd %usd.lo, %dr3 rrd %usd.hi, %dr4 rrd %psp.lo, %dr5 rrd %psp.hi, %dr6 rrd %pcsp.lo, %dr7 rrd %pcsp.hi, %dr8 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_CTX_USD_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_CTX_USD_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_CTX_PSP_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr6, [%dr0 + E2K_CTX_PSP_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr7, [%dr0 + E2K_CTX_PCSP_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr8, [%dr0 + E2K_CTX_PCSP_HI] <span class="hljs-comment"><span class="hljs-comment">/* Load next CRs */</span></span> ldd [%dr1 + E2K_CTX_CR0_LO], %dr2 ldd [%dr1 + E2K_CTX_CR0_HI], %dr3 ldd [%dr1 + E2K_CTX_CR1_LO], %dr4 ldd [%dr1 + E2K_CTX_CR1_HI], %dr5 rwd %dr2, %cr0.lo rwd %dr3, %cr0.hi rwd %dr4, %cr1.lo rwd %dr5, %cr1.hi <span class="hljs-comment"><span class="hljs-comment">/* Load next stacks */</span></span> ldd [%dr1 + E2K_CTX_USD_LO], %dr3 ldd [%dr1 + E2K_CTX_USD_HI], %dr4 ldd [%dr1 + E2K_CTX_PSP_LO], %dr5 ldd [%dr1 + E2K_CTX_PSP_HI], %dr6 ldd [%dr1 + E2K_CTX_PCSP_LO], %dr7 ldd [%dr1 + E2K_CTX_PCSP_HI], %dr8 rwd %dr3, %usd.lo rwd %dr4, %usd.hi rwd %dr5, %psp.lo rwd %dr6, %psp.hi rwd %dr7, %pcsp.lo rwd %dr8, %pcsp.hi <span class="hljs-comment"><span class="hljs-comment">/* Restore next UPSR */</span></span> ldd [%dr1 + E2K_CTX_UPSR], %dr2 rwd %dr2, %upsr E2K_ASM_RETURN</code> </pre> <br>  Otro punto importante es la inicializaci칩n del hilo del sistema operativo.  En Embox, cada hilo tiene un cierto procedimiento primario <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _<span class="hljs-function"><span class="hljs-function">NORETURN </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread_trampoline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  en el que se ejecutar치 todo el trabajo adicional de la secuencia.  Por lo tanto, necesitamos preparar de alguna manera las pilas para llamar a esta funci칩n, es aqu칤 donde nos enfrentamos con el hecho de que hay tres pilas, y que no crecen en la misma direcci칩n.  Por arquitectura, creamos una secuencia con una sola pila, o m치s bien, tiene un solo lugar debajo de la pila, en la parte superior tenemos una estructura que describe la secuencia en s칤, y as칤 sucesivamente, aqu칤 tuvimos que ocuparnos de diferentes pilas, sin olvidar que deber칤an alinearse en 4 kB, no olvide todo tipo de derechos de acceso, etc. <br><br>  Como resultado, en este momento decidimos que dividiremos el espacio debajo de la pila en tres partes, una cuarta parte debajo de la pila de informaci칩n vinculante, una cuarta parte debajo de la pila de procedimientos y la mitad debajo de la pila de usuarios. <br><br><div class="spoiler">  <b class="spoiler_title">Traigo el c칩digo para que pueda evaluar qu칠 tan grande es, debe tener en cuenta que esta es una inicializaci칩n m칤nima.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* This value is used for both stack base and size align. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_STACK_ALIGN (1UL </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 12) #define round_down(x, bound) ((x) &amp; ~((bound) - 1)) /* Reserve 1/4 for PSP stack, 1/4 for PCSP stack, and 1/2 for USD stack */ #define PSP_CALC_STACK_BASE(sp, size) binalign_bound(sp - size, E2K_STACK_ALIGN) #define PSP_CALC_STACK_SIZE(sp, size) binalign_bound((size) / 4, E2K_STACK_ALIGN) #define PCSP_CALC_STACK_BASE(sp, size) \ (PSP_CALC_STACK_BASE(sp, size) + PSP_CALC_STACK_SIZE(sp, size)) #define PCSP_CALC_STACK_SIZE(sp, size) binalign_bound((size) / 4, E2K_STACK_ALIGN) #define USD_CALC_STACK_BASE(sp, size) round_down(sp, E2K_STACK_ALIGN) #define USD_CALC_STACK_SIZE(sp, size) \ round_down(USD_CALC_STACK_BASE(sp, size) - PCSP_CALC_STACK_BASE(sp, size),\ E2K_STACK_ALIGN) static void e2k_calculate_stacks(struct context *ctx, uint64_t sp, uint64_t size) { uint64_t psp_size, pcsp_size, usd_size; log_debug("Stacks:\n"); ctx-&gt;psp_lo |= PSP_CALC_STACK_BASE(sp, size) &lt;&lt; PSP_BASE; ctx-&gt;psp_lo |= E2_RWAR_RW_ENABLE &lt;&lt; PSP_RW; psp_size = PSP_CALC_STACK_SIZE(sp, size); assert(psp_size); ctx-&gt;psp_hi |= psp_size &lt;&lt; PSP_SIZE; log_debug(" PSP.base=0x%lx, PSP.size=0x%lx\n", PSP_CALC_STACK_BASE(sp, size), psp_size); ctx-&gt;pcsp_lo |= PCSP_CALC_STACK_BASE(sp, size) &lt;&lt; PCSP_BASE; ctx-&gt;pcsp_lo |= E2_RWAR_RW_ENABLE &lt;&lt; PCSP_RW; pcsp_size = PCSP_CALC_STACK_SIZE(sp, size); assert(pcsp_size); ctx-&gt;pcsp_hi |= pcsp_size &lt;&lt; PCSP_SIZE; log_debug(" PCSP.base=0x%lx, PCSP.size=0x%lx\n", PCSP_CALC_STACK_BASE(sp, size), pcsp_size); ctx-&gt;usd_lo |= USD_CALC_STACK_BASE(sp, size) &lt;&lt; USD_BASE; usd_size = USD_CALC_STACK_SIZE(sp, size); assert(usd_size); ctx-&gt;usd_hi |= usd_size &lt;&lt; USD_SIZE; log_debug(" USD.base=0x%lx, USD.size=0x%lx\n", USD_CALC_STACK_BASE(sp, size), usd_size); } static void e2k_calculate_crs(struct context *ctx, uint64_t routine_addr) { uint64_t usd_size = (ctx-&gt;usd_hi &gt;&gt; USD_SIZE) &amp; USD_SIZE_MASK; /* Reserve space in hardware stacks for @routine_addr */ /* Remark: We do not update psp.hi to reserve space for arguments, * since routine do not accepts any arguments. */ ctx-&gt;pcsp_hi |= SZ_OF_CR0_CR1 &lt;&lt; PCSP_IND; ctx-&gt;cr0_hi |= (routine_addr &gt;&gt; CR0_IP) &lt;&lt; CR0_IP; ctx-&gt;cr1_lo |= PSR_ALL_IRQ_ENABLED &lt;&lt; CR1_PSR; /* Divide on 16 because it field contains size in terms * of 128 bit values. */ ctx-&gt;cr1_hi |= (usd_size &gt;&gt; 4) &lt;&lt; CR1_USSZ; } void context_init(struct context *ctx, unsigned int flags, void (*routine_fn)(void), void *sp, unsigned int stack_size) { memset(ctx, 0, sizeof(*ctx)); e2k_calculate_stacks(ctx, sp, stack_size); e2k_calculate_crs(ctx, (uint64_t) routine_fn); if (!(flags &amp; CONTEXT_IRQDISABLE)) { ctx-&gt;upsr |= (UPSR_IE | UPSR_NMIE); } }</span></span></span></span></code> </pre> <br></div></div><br>  El art칤culo tambi칠n conten칤a trabajo con interrupciones, excepciones y temporizadores, pero como result칩 ser tan grande, decidimos hablar sobre ello en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">siguiente parte</a> . <br><br>  Por si acaso, repito, este material no es documentaci칩n oficial.  Para soporte oficial, documentaci칩n y el resto, necesita contactar al ICST directamente.  El c칩digo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Embox</a> , por supuesto, est치 abierto, pero para compilarlo, necesitar치 un compilador cruzado, que, nuevamente, se puede obtener del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MCST</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447704/">https://habr.com/ru/post/447704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447694/index.html">Configuraci칩n del sistema distribuido compilado</a></li>
<li><a href="../447696/index.html">쯇or qu칠 las ciudades se oponen a Amazon Go, las primeras tiendas sin efectivo?</a></li>
<li><a href="../447698/index.html">Red Hogwarts: acad칠mico sin diploma</a></li>
<li><a href="../447700/index.html">La flexibilidad emocional es la clave del crecimiento personal.</a></li>
<li><a href="../447702/index.html">El c칤rculo matem치tico ideal no existe.</a></li>
<li><a href="../447706/index.html">Ni un solo ORM</a></li>
<li><a href="../447708/index.html">Yandex present칩 a los j칩venes cient칤ficos y l칤deres cient칤ficos los primeros premios Ilya Segalovich</a></li>
<li><a href="../447712/index.html">Hola SaaS | Rusia SaaS 2018 - resultados</a></li>
<li><a href="../447714/index.html">Sobre la aplicaci칩n de la teor칤a de los procesos ARMA en la pr치ctica de la ingenier칤a.</a></li>
<li><a href="../447716/index.html">Unidad: dibuja muchas barras de salud en una sola llamada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>