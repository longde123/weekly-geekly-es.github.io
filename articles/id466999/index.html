<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🔬 🤜🏾 🙏 Perbandingan perpustakaan CLI populer untuk Python: klik, semen, api, dan lainnya 🛎️ 👩🏽‍⚖️ 💶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Python adalah bahasa yang bagus untuk aplikasi konsol, dan menyoroti sejumlah besar pustaka untuk tugas-tugas ini. Tapi perpustakaan apa yang ada? Dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perbandingan perpustakaan CLI populer untuk Python: klik, semen, api, dan lainnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466999/"><img src="https://habrastorage.org/webt/rp/ek/be/rpekben_u6jtlwru-flsslxk70e.png"><br><br>  Python adalah bahasa yang bagus untuk aplikasi konsol, dan menyoroti sejumlah besar pustaka untuk tugas-tugas ini.  <i>Tapi perpustakaan apa yang ada?</i>  <i>Dan mana yang lebih baik untuk diambil?</i>  Materi ini membandingkan alat yang populer dan tidak terlalu untuk dunia konsol dan memberikan upaya untuk menjawab pertanyaan kedua. <br><br>  Untuk kemudahan membaca, ulasan dibagi menjadi dua tulisan: yang pertama membandingkan enam perpustakaan paling populer, yang kedua - yang kurang populer dan lebih spesifik, tetapi masih layak diperhatikan. <br><a name="habracut"></a><br>  Pada masing-masing contoh, utilitas konsol untuk perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">todolib</a> akan ditulis dalam Python 3.7, yang dengannya Anda dapat membuat, melihat, menandai, dan menghapus tugas.  Sisanya akan ditambahkan dengan kesederhanaan implementasi pada kerangka kerja tertentu.  Tugas itu sendiri disimpan dalam file json, yang akan disimpan dalam panggilan terpisah - syarat tambahan untuk contoh. <br>  Selain itu, tes sepele akan ditulis untuk setiap implementasi.  Pytest dengan perlengkapan berikut diambil sebagai kerangka pengujian: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.fixture(autouse=True) def db(monkeypatch): """ monkeypatch     ,        """ value = {"tasks": []} monkeypatch.setattr(todolib.TodoApp, "get_db", lambda _: value) return value @pytest.yield_fixture(autouse=True) def check(db): """      """ yield assert db["tasks"] and db["tasks"][0]["title"] == "test" # ,      EXPECTED = "Task 'test' created with number 1.\n"</span></span></code> </pre> <br>  Pada prinsipnya, semua hal di atas akan cukup untuk menunjukkan perpustakaan.  Kode sumber lengkap tersedia di repositori <a href="">ini</a> . <br><br><h2>  argparse </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Argparse</a> memiliki keunggulan yang tidak dapat disangkal - ia ada di pustaka standar dan API-nya tidak sulit untuk dipelajari: ada parser, ada argumen, argumen memiliki <i>tipe</i> , <i>action</i> , <i>dest</i> , <i>default</i> , dan <i>bantuan</i> .  Dan ada <i>subparser</i> - kemampuan untuk memisahkan bagian dari argumen dan logika menjadi perintah terpisah. <br><br><h4>  Parser </h4><br>  Sekilas - tidak ada yang aneh, pengurai seperti pengurai.  Tetapi - menurut saya - keterbacaan bukan yang terbaik bila dibandingkan dengan perpustakaan lain, karena  argumen untuk perintah yang berbeda dijelaskan di satu tempat. <br><br><div class="spoiler">  <b class="spoiler_title">kode sumber</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> parser = argparse.ArgumentParser(<span class="hljs-string"><span class="hljs-string">"Todo notes - argparse version"</span></span>) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--verbose"</span></span>, <span class="hljs-string"><span class="hljs-string">"-v"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Enable verbose mode"</span></span> ) parser.add_argument(<span class="hljs-string"><span class="hljs-string">"--version"</span></span>, <span class="hljs-string"><span class="hljs-string">"-V"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Show version"</span></span>) subparsers = parser.add_subparsers(title=<span class="hljs-string"><span class="hljs-string">"Commands"</span></span>, dest=<span class="hljs-string"><span class="hljs-string">"cmd"</span></span>) add = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"add"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Add new task"</span></span>) add.add_argument(<span class="hljs-string"><span class="hljs-string">"title"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Todo title"</span></span>) show = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"show"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Show tasks"</span></span>) show.add_argument( <span class="hljs-string"><span class="hljs-string">"--show-done"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Include done tasks in the output"</span></span> ) done = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"done"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Mark task as done"</span></span>) done.add_argument(<span class="hljs-string"><span class="hljs-string">"number"</span></span>, type=int, help=<span class="hljs-string"><span class="hljs-string">"Task number"</span></span>) remove = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"remove"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Remove task"</span></span>) remove.add_argument(<span class="hljs-string"><span class="hljs-string">"number"</span></span>, type=int, help=<span class="hljs-string"><span class="hljs-string">"Task number"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser</code> </pre><br></div></div><br><h4>  utama </h4><br>  Dan di sini hal yang sama - parser kecuali untuk argumen parsing tidak bisa berbuat apa-apa lagi, jadi logika harus ditulis secara independen dan di satu tempat.  Di satu sisi - mungkin untuk hidup, di sisi lain - mungkin lebih baik, tetapi belum jelas bagaimana. <br><br>  <b>UPD:</b> <i>Seperti yang dicatat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">foldr</a> , sebenarnya, subparser dapat mengatur fungsi melalui set_defaults (func = foo), yaitu, argparse memungkinkan Anda untuk mempersingkat main menjadi ukuran kecil.</i>  <i>Hidup dan belajar.</i> <br><br><div class="spoiler">  <b class="spoiler_title">kode sumber</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(raw_args=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Argparse example entrypoint """</span></span> parser = get_parser() args = parser.parse_args(raw_args) logging.basicConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.verbose: logging.getLogger(<span class="hljs-string"><span class="hljs-string">"todolib"</span></span>).setLevel(logging.INFO) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.version: print(lib_version) exit(<span class="hljs-number"><span class="hljs-number">0</span></span>) cmd = args.cmd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> cmd: parser.print_help() exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> TodoApp.fromenv() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"add"</span></span>: task = app.add_task(args.title) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"show"</span></span>: app.print_tasks(args.show_done) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"done"</span></span>: task = app.task_done(args.number) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"remove"</span></span>: task = app.remove_task(args.number) print(task, <span class="hljs-string"><span class="hljs-string">"removed from list."</span></span>)</code> </pre><br></div></div><br><h4>  Pengujian </h4><br>  Untuk memeriksa output dari utilitas, fixture <i>capsys digunakan</i> , yang memberikan akses ke teks dari stdout dan stderr. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_argparse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> todo_argparse.main([<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED</code> </pre><br><h4>  Ringkasan </h4><br>  Dari kelebihan - seperangkat fitur yang baik untuk parsing, kehadiran modul di perpustakaan standar. <br><br>  Cons - argparse hanya terlibat dalam argumen parsing, sebagian besar logika utama harus ditulis sendiri.  Dan tidak jelas cara menguji kode keluar dalam tes. <br><br><h2>  docopt </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docopt</a> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parser</a> kecil (&lt;600 baris, dibandingkan dengan 2500 dengan argparse), yang akan membuat Anda tersenyum, mengutip deskripsi pada GitHub.  Gagasan utama docopt adalah untuk menggambarkan antarmuka secara harfiah dengan teks, misalnya, dalam docstring. <br><br>  Pada github yang sama, docopt&gt; 6700 bintang, digunakan di setidaknya 22 ribu proyek lainnya.  Dan ini hanya dengan implementasi python!  Halaman proyek docopt memiliki banyak pilihan untuk bahasa yang berbeda, dari C dan PHP ke CoffeeScript dan bahkan R. Seperti cross-platform hanya dapat dijelaskan oleh kekompakan dan kesederhanaan kode. <br><br><h4>  Parser </h4><br>  Dibandingkan dengan argparse, parser ini merupakan langkah maju yang besar. <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Todo notes on docopt. Usage: todo_docopt [-v | -vv ] add &lt;task&gt; todo_docopt [-v | -vv ] show --show-done todo_docopt [-v | -vv ] done &lt;number&gt; todo_docopt [-v | -vv ] remove &lt;number&gt; todo_docopt -h | --help todo_docopt --version Options: -h --help Show help. -v --verbose Enable verbose mode. """</span></span></code> </pre><br><h4>  utama </h4><br>  Secara umum, semuanya sama dengan argparse, tetapi sekarang <i>verbose</i> dapat memiliki beberapa nilai (0-2), dan akses ke argumen berbeda: docopt mengembalikan bukan namespace dengan atribut, tetapi hanya kamus, di mana pilihan perintah ditunjukkan melalui booleannya, seperti yang terlihat di <i>jika</i> : <br><br><div class="spoiler">  <b class="spoiler_title">kode sumber</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argv=None)</span></span></span><span class="hljs-function">:</span></span> args = docopt(__doc__, argv=argv, version=lib_version) log.setLevel(levels[args[<span class="hljs-string"><span class="hljs-string">"--verbose"</span></span>]]) logging.basicConfig() log.debug(<span class="hljs-string"><span class="hljs-string">"Arguments: %s"</span></span>, args) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> TodoApp.fromenv() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args[<span class="hljs-string"><span class="hljs-string">"add"</span></span>]: task = app.add_task(args[<span class="hljs-string"><span class="hljs-string">"&lt;task&gt;"</span></span>]) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> args[<span class="hljs-string"><span class="hljs-string">"show"</span></span>]: app.print_tasks(args[<span class="hljs-string"><span class="hljs-string">"--show-done"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> args[<span class="hljs-string"><span class="hljs-string">"done"</span></span>]: task = app.task_done(args[<span class="hljs-string"><span class="hljs-string">"&lt;number&gt;"</span></span>]) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> args[<span class="hljs-string"><span class="hljs-string">"remove"</span></span>]: task = app.remove_task(args[<span class="hljs-string"><span class="hljs-string">"&lt;number&gt;"</span></span>]) print(task, <span class="hljs-string"><span class="hljs-string">"removed from list."</span></span>)</code> </pre><br></div></div><br><h4>  Pengujian </h4><br>  Mirip dengan pengujian argparse: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_docopt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> todo_docopt.main([<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED</code> </pre><br><h4>  Ringkasan </h4><br>  Dari manfaat - kode lebih sedikit untuk parser, kemudahan deskripsi dan membaca perintah dan argumen, versi bawaan. <br><br>  Kontra, pertama, sama seperti argparse - banyak logika di <i>utama</i> , Anda tidak dapat menguji kode keluar.  Selain itu, versi saat ini (0,6.2) dari docopt belum stabil dan tidak mungkin - proyek ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara aktif</a> berkembang dari 2012 hingga akhir 2013, komitmen terakhir adalah pada 17 Desember.  Dan hal yang paling tidak menyenangkan saat ini adalah bahwa beberapa pelanggan tetap docopt memprovokasi DeprecationWarning ketika melakukan tes. <br><br><h2>  Klik </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Klik pada</a> dasarnya berbeda dari argparse dan docopt dengan jumlah fitur dan pendekatan untuk mendeskripsikan perintah dan parameter melalui dekorator, dan logika itu sendiri diusulkan untuk dipisahkan ke dalam fungsi-fungsi yang terpisah alih-alih <i>utama yang</i> besar.  Para penulis mengklaim bahwa Klik memiliki banyak pengaturan, tetapi parameter standar harus cukup.  Di antara fitur-fiturnya, perintah bersarang dan pemuatan malasnya ditekankan. <br><br>  Proyek ini sangat populer: selain memiliki&gt; 8100 bintang dan menggunakannya dalam setidaknya 174 ribu (!) Proyek, masih berkembang: versi 7.0 dirilis pada musim gugur 2018, dan komitmen baru serta permintaan gabungan muncul hingga hari ini hari <br><br><h4>  Parser </h4><br>  Pada halaman dokumentasi, saya menemukan dekorator confirm_option, yang meminta konfirmasi dari pengguna sebelum menjalankan perintah.  Untuk mendemonstrasikannya, perintah penghapusan ditambahkan, yang menghapus seluruh daftar tugas. <br><br><div class="spoiler">  <b class="spoiler_title">kode sumber</b> <div class="spoiler_text"><pre> <code class="python hljs">levels = [logging.WARN, logging.INFO, logging.DEBUG] pass_app = click.make_pass_decorator(TodoApp) @click.group() @click.version_option(lib_version, prog_name=<span class="hljs-string"><span class="hljs-string">"todo_click"</span></span>) @click.option(<span class="hljs-string"><span class="hljs-string">"-v"</span></span>, <span class="hljs-string"><span class="hljs-string">"--verbose"</span></span>, count=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-comment"><span class="hljs-comment"># click   ,     @click.option("--db", help="Path to the database file") @click.pass_context def cli(ctx, verbose, db): """Todo notes - click version.""" level = levels[min(verbose, 2)] logging.basicConfig(level=level) logging.getLogger("todolib").setLevel(level) ctx.obj = TodoApp.fromenv(db) atexit.register(ctx.obj.save) @cli.command() @click.argument("task") @pass_app def add(app, task): """ Add new task. """ task = app.add_task(task) click.echo(f"{task} created with number {task.number}.") @cli.command() @click.option("--show-done", is_flag=True, help="Include done tasks") @pass_app def show(app, show_done): """ Show current tasks. """ app.print_tasks(show_done) @cli.command() @click.argument("number", type=int) @pass_app def done(app, number): """ Mark task as done. """ task = app.task_done(number) click.echo(f"{task} marked as done.") @cli.command() @click.argument("number", type=int) @pass_app def remove(app, number): """ Remove task from the list. """ task = app.remove_task(number) click.echo(f"{task} removed from the list.") @cli.command() @click.confirmation_option(prompt="Are you sure you want to remove database") @pass_app def wipe(app): for task in app.list_tasks(): task.remove()</span></span></code> </pre><br></div></div><br><h4>  utama </h4><br>  Dan di sini kita bertemu dengan keunggulan utama Click - karena fakta bahwa logika perintah ditempatkan sesuai dengan fungsinya, hampir tidak ada yang tersisa di utama.  Juga ditunjukkan di sini adalah kemampuan perpustakaan untuk menerima argumen dan parameter dari variabel lingkungan. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: cli(auto_envvar_prefix=<span class="hljs-string"><span class="hljs-string">"TODO"</span></span>)</code> </pre><br><h4>  Pengujian </h4><br>  Dalam kasus Klik, tidak perlu mencegat sys.stdout, karena ada modul <i>click.testing</i> dengan pelari untuk hal-hal seperti itu.  Dan <i>CliRunner</i> sendiri tidak hanya mencegat output, tetapi juga memungkinkan Anda untuk memeriksa kode keluar, yang juga keren.  Semua ini memungkinkan pengujian utilitas klik tanpa menggunakan pytest dan melewati modul <i>unittest</i> standar. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> click.testing <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> runner = click.testing.CliRunner() result = runner.invoke(todo_click.cli, [<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> result.exit_code == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> result.output == EXPECTED</code> </pre><br><h4>  Ringkasan </h4><br>  Ini hanya sebagian kecil dari apa yang bisa dilakukan oleh Klik.  Dari API lainnya - validasi nilai, integrasi dengan terminal (warna, pager a la less, progress bar, dll.), Hasil panggilan balik, pelengkapan otomatis dan banyak lagi.  Anda dapat melihat contohnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Pro: banyak alat untuk setiap kesempatan, asli, tetapi pada saat yang sama pendekatan yang mudah digunakan untuk menggambarkan tim, kemudahan pengujian dan kehidupan proyek yang aktif. <br><br>  Cons: Apa kerugian dari "klik" - ini adalah pertanyaan yang sulit.  Mungkin dia tidak tahu sesuatu dari apa yang mampu dimiliki perpustakaan berikut? <br><br><h2>  Api </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fire</a> bukan hanya perpustakaan muda (muncul pada tahun 2017) untuk antarmuka konsol dari Google, itu adalah perpustakaan untuk menghasilkan antarmuka konsol dari, mengutip kata demi kata, <i>benar-benar objek</i> Python <i>apa pun</i> . <br>  Antara lain, dinyatakan bahwa api membantu dalam pengembangan dan debugging kode, membantu untuk menyesuaikan kode yang ada di CLI, memfasilitasi transisi dari bash ke Python, dan memiliki REPL sendiri untuk pekerjaan interaktif.  Bisakah kita melihat? <br><br><h4>  Parser dan main </h4><br>  fire.Fire benar-benar mampu menerima objek apa pun: modul, instance kelas, kamus dengan nama perintah dan fungsi terkait, dan sebagainya. <br><br>  Yang penting bagi kami adalah bahwa Api memungkinkan transfer objek kelas.  Dengan demikian, konstruktor kelas menerima argumen yang umum untuk semua perintah, dan metode dan atributnya adalah perintah yang terpisah.  Kami akan menggunakan ini: <br><br><div class="spoiler">  <b class="spoiler_title">kode sumber</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Commands</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, db=None, verbose=False)</span></span></span><span class="hljs-function">:</span></span> level = logging.INFO <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> verbose <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> logging.WARNING logging.basicConfig(level=level) logging.getLogger(<span class="hljs-string"><span class="hljs-string">"todolib"</span></span>).setLevel(level) self._app = todolib.TodoApp.fromenv(db) atexit.register(self._app.save) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">version</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> todolib.__version__ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, task)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Add new task."""</span></span> task = self._app.add_task(task) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, show_done=False)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Show current tasks. """</span></span> self._app.print_tasks(show_done) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Mark task as done. """</span></span> task = self._app.task_done(number) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Removes task from the list. """</span></span> task = self._app.remove_task(number) print(task, <span class="hljs-string"><span class="hljs-string">"removed from the list."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args=None)</span></span></span><span class="hljs-function">:</span></span> fire.Fire(Commands, command=args)</code> </pre><br></div></div><br><h4>  Bendera sebaris </h4><br>  Fire memiliki benderanya sendiri dengan sintaks khusus (mereka harus dilewati setelah "-"), yang memungkinkan Anda untuk melihat di bawah kap parser dan aplikasi secara keseluruhan: <br><br><div class="spoiler">  <b class="spoiler_title">sebut contoh</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./todo_fire.py show -- --trace Fire trace: 1. Initial component 2. Instantiated class <span class="hljs-string"><span class="hljs-string">"Commands"</span></span> (todo_fire.py:9) 3. Accessed property <span class="hljs-string"><span class="hljs-string">"show"</span></span> (todo_fire.py:25) $ ./todo_fire.py -- --verbose | head -n 12 <span class="hljs-comment"><span class="hljs-comment">#    , ,  Commands._app NAME todo_fire.py - SYNOPSIS todo_fire.py - GROUP | COMMAND GROUPS GROUP is one of the following: _app Todo Application definition. $ ./todo_fire.py show -- --interactive Fire is starting a Python REPL with the following objects: Modules: atexit, fire, logging, todolib Objects: Commands, args, component, main, result, self, todo_fire.py, trace Python 3.7.4 (default, Aug 15 2019, 13:09:37) [GCC 7.4.0] on linux Type "help", "copyright", "credits" or "license" for more information. (InteractiveConsole) &gt;&gt;&gt; self &lt;__main__.Commands object at 0x7fd0a6125bd0&gt; &gt;&gt;&gt; self._app.db {'tasks': [{'title': 'test', 'done': False}]}</span></span></code> </pre><br></div></div><br><h4>  Pengujian </h4><br>  Menguji fungsi utama mirip dengan menguji argparse dan docopt, jadi saya tidak melihat intinya di sini. <br><br>  Pada saat yang sama, perlu dicatat bahwa, karena sifat Api yang introspektif, sama-sama mungkin untuk menguji kelas Perintah dengan segera. <br><br><h4>  Ringkasan </h4><br>  Api adalah alat yang tidak kalah menarik dari klik.  Tidak memerlukan daftar banyak opsi di parser, konfigurasi minimal, ada opsi untuk debugging, dan perpustakaan itu sendiri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hidup dan berkembang</a> bahkan lebih aktif daripada klik (60 dilakukan musim panas ini). <br><br>  Cons: secara signifikan dapat kurang dari klik dan parser lainnya;  API tidak stabil (versi saat ini adalah 0.2.1). <br><br><h2>  Semen </h2><br>  Faktanya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cement</a> bukanlah perpustakaan CLI, tetapi kerangka kerja untuk aplikasi konsol, tetapi diklaim cocok untuk skrip dan aplikasi kompleks dengan berbagai integrasi. <br><br><h4>  Parser </h4><br>  Parser di Semen terlihat tidak biasa, tetapi jika Anda melihat dengan cermat pada parameternya, mudah untuk menebak bahwa argparse yang sudah dikenal ada di bawah kap.  Tapi mungkin ini yang terbaik - tidak perlu mempelajari parameter baru. <br><br><div class="spoiler">  <b class="spoiler_title">kode sumber</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cement <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Controller, ex <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Controller)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> label = <span class="hljs-string"><span class="hljs-string">"base"</span></span> arguments = [ ( [<span class="hljs-string"><span class="hljs-string">"-v"</span></span>, <span class="hljs-string"><span class="hljs-string">"--version"</span></span>], {<span class="hljs-string"><span class="hljs-string">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"version"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">f"todo_cement v</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{todolib.__version__}</span></span></span><span class="hljs-string">"</span></span>}, ) ] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_default</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Default action if no sub-command is passed."""</span></span> self.app.args.print_help() @ex(help=<span class="hljs-string"><span class="hljs-string">"Add new task"</span></span>, arguments=[([<span class="hljs-string"><span class="hljs-string">"task"</span></span>], {<span class="hljs-string"><span class="hljs-string">"help"</span></span>: <span class="hljs-string"><span class="hljs-string">"Task title"</span></span>})]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> title = self.app.pargs.task self.app.log.debug(<span class="hljs-string"><span class="hljs-string">f"Task title: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{title!r}</span></span></span><span class="hljs-string">"</span></span>) task = self.app.todoobj.add_task(title) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) @ex( help=<span class="hljs-string"><span class="hljs-string">"Show current tasks"</span></span>, arguments=[ ([<span class="hljs-string"><span class="hljs-string">"--show-done"</span></span>], dict(action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Include done tasks"</span></span>)) ], ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.app.todoobj.print_tasks(self.app.pargs.show_done) @ex(help=<span class="hljs-string"><span class="hljs-string">"Mark task as done"</span></span>, arguments=[([<span class="hljs-string"><span class="hljs-string">"number"</span></span>], {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: int})]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> task = self.app.todoobj.task_done(self.app.pargs.number) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) @ex(help=<span class="hljs-string"><span class="hljs-string">"Remove task from the list"</span></span>, arguments=[([<span class="hljs-string"><span class="hljs-string">"number"</span></span>], {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: int})]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> task = self.app.todoobj.remove_task(self.app.pargs.number) print(task, <span class="hljs-string"><span class="hljs-string">"removed from the list."</span></span>)</code> </pre><br></div></div><br><h4>  Aplikasi dan utama </h4><br>  Semen, antara lain, masih membungkus sinyal dalam pengecualian.  Ini ditunjukkan di sini pada output kode nol dengan SIGINT / SIGTERM. <br><br><div class="spoiler">  <b class="spoiler_title">kode sumber</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoApp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(App)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, argv=None)</span></span></span><span class="hljs-function">:</span></span> super().__init__(argv=argv) self.todoobj = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_db</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.todoobj = todolib.TodoApp.fromenv() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.todoobj.save() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># application label label = "todo_cement" # register handlers handlers = [Base] hooks = [("post_setup", lambda app: app.load_db()), ("pre_close", lambda app: app.save())] # call sys.exit() on close close_on_exit = True def main(): with TodoApp() as app: try: app.run() except CaughtSignal as e: if e.signum not in (signal.SIGINT, signal.SIGTERM): raise app.log.debug(f"\n{e}") app.exit_code = 0</span></span></code> </pre><br></div></div><br>  Jika Anda mendapatkan pemahaman utama, Anda dapat melihat bahwa memuat dan menyimpan todolib.TodoApp juga dapat dilakukan di __enter __ / __ keluar yang ditimpa, tetapi fase ini akhirnya dipisahkan menjadi metode terpisah untuk menunjukkan kait Semen. <br><br><h4>  Pengujian </h4><br>  Untuk pengujian, Anda dapat menggunakan kelas aplikasi yang sama: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> todo_cement.TodoApp(argv=[<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: app.run() out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED <span class="hljs-comment"><span class="hljs-comment">#     jinja,       assert app.last_rendered is None</span></span></code> </pre><br><h4>  Ringkasan </h4><br>  Pro: Perangkat API seperti set pisau Swiss, ekstensibilitas melalui kait dan plugin, antarmuka yang stabil dan pengembangan aktif. <br><br>  Cons: Di tempat-tempat dokumentasi kosong;  skrip kecil berbasis Semen mungkin tampak sedikit rumit. <br><br><h2>  Cleo </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cleo</a> jauh dari kerangka yang populer seperti yang lain yang tercantum di sini (total sekitar 400 bintang di GitHub), namun saya berhasil mengetahuinya ketika saya mempelajari bagaimana Puisi memformat output. <br><br>  Jadi, Cleo adalah salah satu proyek dari penulis Puisi yang telah disebutkan, alat untuk mengelola dependensi, virtualenvs dan aplikasi build.  Tentang Puisi pada habr sudah lebih dari sekali menulis, dan tentang bagian konsolnya - tidak. <br><br><h4>  Parser </h4><br>  Cleo, seperti Semen, dibangun di atas prinsip-prinsip objek, mis.  perintah didefinisikan melalui kelas Command dan docstring-nya, parameter diakses melalui metode option (), dan seterusnya.  Selain itu, metode line (), yang digunakan untuk menampilkan teks, mendukung gaya (mis. Warna) dan pemfilteran output berdasarkan jumlah flag verbose di luar kotak.  Cleo juga memiliki output tabel.  Dan juga progress bar.  Namun ... Secara umum, lihat: <br><br><div class="spoiler">  <b class="spoiler_title">kode sumber</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cleo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Command <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> BaseCommand <span class="hljs-comment"><span class="hljs-comment"># cleo    clikit,          from clikit.api.io import flags as verbosity class Command(BaseCommand): def __init__(self): super().__init__() self.todoapp = None def handle(self): with todolib.TodoApp.fromenv() as app: self.todoapp = app self.do_handle() def do_handle(self): raise NotImplementedError class AddCommand(Command): """ Add new task. add {task : Task to add} """ def do_handle(self): title = self.argument("task") task = self.todoapp.add_task(title) # will be printed only on "-vvv" self.line(f"Title: {title}", style="comment", verbosity=verbosity.DEBUG) self.line(f"Task &lt;info&gt;{task.title}&lt;/&gt; created with number {task.number}.") class ShowCommand(Command): """ Show current tasks. show {--show-done : Include tasks that are done.} """ def do_handle(self): tasks = self.todoapp.list_tasks(self.option("show-done")) if not tasks: self.line("There is no TODOs.", style="info") self.render_table( ["Number", "Title", "Status"], [ [str(task.number), task.title, "" if task.done else "✘"] for task in tasks ], ) class DoneCommand(Command): """ Mark task as done. done {number : Task number} """ def do_handle(self): task = self.todoapp.task_done(int(self.argument("number"))) self.line(f"Task &lt;info&gt;{task.title}&lt;/&gt; marked as done.") class RemoveCommand(Command): """ Removes task from the list. remove {number : Task number} """ def do_handle(self): task = self.todoapp.remove_task(int(self.argument("number"))) self.line(f"Task &lt;info&gt;{task.title}&lt;/&gt; removed from the list.")</span></span></code> </pre><br></div></div><br><h4>  utama </h4><br>  Yang diperlukan hanyalah membuat objek <i>cleo.Application</i> lalu meneruskan perintah ke add_commands.  Agar tidak mengulangi selama pengujian, semua ini ditransfer dari main ke konstruktor: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cleo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> BaseApplication <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoApp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseApplication)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> super().__init__(name=<span class="hljs-string"><span class="hljs-string">"ToDo app - cleo version"</span></span>, version=todolib.__version__) self.add_commands(AddCommand(), ShowCommand(), DoneCommand(), RemoveCommand()) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args=None)</span></span></span><span class="hljs-function">:</span></span> TodoApp().run(args=args)</code> </pre><br><h4>  Pengujian </h4><br>  Untuk menguji perintah di Cleo, ada <i>CommandTester</i> , yang, seperti semua <s>paman</s> dewasa <s>dari</s> kerangka kerja, memotong I / O dan kode keluar: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cleo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> app = todo_cleo.TodoApp() command = app.find(<span class="hljs-string"><span class="hljs-string">"add"</span></span>) tester = cleo.CommandTester(command) tester.execute(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> tester.status_code == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> tester.io.fetch_output() == <span class="hljs-string"><span class="hljs-string">"Task test created with number 0.\n"</span></span></code> </pre><br><h4>  Ringkasan </h4><br>  Kelebihan: struktur objek dengan petunjuk jenis, yang menyederhanakan pengembangan (karena banyak IDE dan editor memiliki dukungan yang baik untuk kode OOP dan modul pengetikan);  Sejumlah fungsionalitas yang baik untuk bekerja tidak hanya dengan argumen, tetapi juga I / O. <br><br>  Plus atau minus: parameter verbositasnya, yang hanya kompatibel dengan I / O Cleo / CliKit.  Meskipun Anda bisa menulis custom handler untuk modul logging, bisa jadi sulit untuk mempertahankan seiring dengan pengembangan cleo. <br><br>  Kontra: jelas - pendapat pribadi - API muda: kerangka kerja tidak memiliki pengguna "besar" yang lain, kecuali Puisi, dan Cleo berkembang secara paralel dengan pengembangan dan untuk kebutuhan satu;  kadang-kadang dokumentasinya sudah usang (misalnya, level logging sekarang tidak terletak pada modul clikit, tetapi di clikit.api.io.flags), dan secara umum miskin dan tidak mencerminkan keseluruhan API. <br><br>  Cleo, dibandingkan dengan Semen, lebih fokus pada CLI, dan dia adalah satu-satunya yang berpikir untuk memformat (menyembunyikan jejak tumpukan standar) pengecualian di output default.  Tapi dia - lagi pendapat pribadi - kalah dari Semen di masa mudanya dan stabilitas API. <br><br><h2>  Kesimpulannya </h2><br>  Pada titik ini, semua orang sudah memiliki pendapat mereka sendiri, yang lebih baik, tetapi kesimpulannya adalah: Saya paling suka Klik, karena ada banyak hal di dalamnya dan sangat mudah untuk mengembangkan dan menguji aplikasi dengan itu.  Jika Anda mencoba menulis kode seminimal mungkin - mulailah dengan Api.  Script Anda membutuhkan akses ke Memcached, format dengan jinja dan ekstensibilitas - ambil Cement dan Anda tidak akan menyesalinya.  Anda memiliki proyek kesayangan atau ingin mencoba sesuatu yang lain - lihat cleo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466999/">https://habr.com/ru/post/id466999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466983/index.html">Mengapa tidak ada yang bisa mengalahkan lari Tesla</a></li>
<li><a href="../id466985/index.html">Tentang standar C ++ yang baru</a></li>
<li><a href="../id466987/index.html">"Ls" yang tidak lazim atau bagaimana linuxoids terhibur</a></li>
<li><a href="../id466993/index.html">Konfigurasi Peringatan Next Generation plugin untuk integrasi dengan PVS-Studio</a></li>
<li><a href="../id466995/index.html">Mengkonfigurasi plugin Next Generation untuk integrasi PVS-Studio</a></li>
<li><a href="../id467003/index.html">Menu cepat, nyaman, adaptif untuk 1075 kategori (36000 produk)</a></li>
<li><a href="../id467005/index.html">Cara mewarnai polinomial dengan benar</a></li>
<li><a href="../id467007/index.html">FLProg - Integrasi independen ke dalam program pengontrol khusus</a></li>
<li><a href="../id467009/index.html">Membuat perpustakaan rumah dengan Notion dan Python</a></li>
<li><a href="../id467011/index.html">Apa yang harus dibaca dan dilihat sebagai permulaan dalam Ilmu Data: buku, kamus, dan kursus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>