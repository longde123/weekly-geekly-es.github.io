<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßîüèΩ üë≤üèø üÖ∞Ô∏è Die Geschichte eines Problems: Der k√ºrzeste JavaScript-Memoizer ü§úüèº üï¶ üëë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es war am Abend, am Vorabend der j√§hrlichen HolyJS- Konferenz in St. Petersburg. Unser Unternehmen ist seit mehreren Jahren Sponsor: Dementsprechend h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Geschichte eines Problems: Der k√ºrzeste JavaScript-Memoizer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/413303/"><p><img src="https://habrastorage.org/webt/bn/ca/u1/bncau1_hr7wuzgyelj-ebncmyl4.png" alt="Bild"></p><br><p>  Es war am Abend, am Vorabend der j√§hrlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HolyJS-</a> Konferenz in St. Petersburg.  Unser Unternehmen ist seit mehreren Jahren Sponsor: Dementsprechend hat es auch einen eigenen Stand mit interessanten Interessen f√ºr den neugierigen Geist f√ºrsorglicher Entwickler.  Als das Hauptgericht fertig war und alle Aufgaben von Anw√§lten √ºberpr√ºft und erledigt wurden, beschloss ich, meinen Kollegen nachts mehr intellektuelles Essen zu geben: </p><br><blockquote>  Schreiben Sie einen Memoizer - eine Dekorationsfunktion, die die Ergebnisse der Ausf√ºhrung einer umschlossenen Funktion speichert, um wiederholte Berechnungen zu verhindern.  Sie haben nur 50 Zeichen. </blockquote><p>  Die Sprache ist nat√ºrlich <strong>JavaScript</strong> .  Die Aufgabe selbst ist ein Klassiker, aber die Beschr√§nkung auf 50 Zeichen wurde zu einer echten Herausforderung. </p><br><p>  In den Pausen des ersten Konferenztages diskutierten wir Optionen zur Erreichung des Ziels und reduzierten schrittweise die Reaktion.  Der ganze Hype war gekr√∂nt von der Idee, die Aufgabe mit allen Teilnehmern der Konferenz zu teilen, und am zweiten Tag visualisierten wir die Aufgabe (siehe Anhang) und begannen, Formulare an diejenigen zu verteilen, die wollten.  Als Ergebnis erhielten wir ungef√§hr 40 L√∂sungen und waren erneut von der au√üergew√∂hnlichen Community der js-Entwickler √ºberzeugt, aber <strong>Dmitry</strong> Kataevs Rekord (SEMrush) von <strong>53</strong> Zeichen blieb bestehen.  Lass es uns herausfinden! </p><a name="habracut"></a><br><h3 id="privychnaya-realizaciya">  Gewohnheitsm√§√üige Umsetzung </h3><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cache = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cache.hasOwnProperty(key)) { cache[key] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache[key]; } }</code> </pre> <br><p>  Ergebnis: ~ <strong>190</strong> Zeichen </p><br><ul><li>  memoize - unser memoizer </li><li>  f - dekorierte, verpackte Funktion </li><li>  ret - resultierende Funktion </li></ul><br><p>  Um die Antwort zu erhalten - die Gr√∂√üe der Funktion - verwenden wir: </p><br><pre> <code class="javascript hljs">memoize.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).length</code> </pre> <br><p>  Bei der Bewertung der Gr√∂√üe einer Funktion achten wir auf ihren K√∂rper und eine Liste von Parametern.  Wenn die Funktion anonym ist, wird die Deklaration nicht ber√ºcksichtigt. </p><br><p>  Einfache Tests zum Testen der Gesundheit nach Missbrauch: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = memoize(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inc = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function"> =&gt;</span></span> ox + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><table><thead><tr><th>  Nein, nein. </th><th>  Funktionsaufruf </th><th>  Das Ergebnis der Ausf√ºhrung in der Konsole </th></tr></thead><tbody><tr><td>  1. </td><td> <code>log(false)</code> </td> <td>  &gt; falsch </td></tr><tr><td>  2. </td><td> <code>log('2', {x:1})</code> </td> <td>  &gt; '2', {x: 1} </td></tr><tr><td>  3. </td><td> <code>log(false)</code> </td> <td>  Nichts, da die Funktion f√ºr diese Werte bereits ausgef√ºhrt wurde. </td></tr><tr><td>  4. </td><td> <code>log('2', {x:1})</code> </td> <td>  Nichts, da die Funktion f√ºr diese Werte bereits ausgef√ºhrt wurde. </td></tr><tr><td>  5. </td><td> <code>inc({x:1})</code> </td> <td>  2 </td></tr><tr><td>  6. </td><td> <code>inc({x:2})</code> </td> <td>  3 </td></tr></tbody></table><br><p>  Als n√§chstes wird das Ergebnis jeder Implementierung durch das Testergebnis markiert. </p><br><h3 id="chistaya-realizaciya">  Nettoimplementierung </h3><br><p>  Zun√§chst m√∂chte ich die <em>Funktionsdeklaration</em> zugunsten der Pfeilfunktion loswerden, da wir an <em>diesem</em> Kontext nicht interessiert sind, keine <em>Argumente</em> ansprechen und als Konstruktor nicht beabsichtigen, <em>neue</em> durchzurufen.  Gleichzeitig werden wir die Namen der verwendeten lokalen Variablen reduzieren: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  Ergebnis: <strong>154</strong> , Tests bestanden </p><br><p>  Dann k√∂nnen wir eine √§hnliche Operation mit der resultierenden Funktion ausf√ºhren, aber dort brauchen wir <em>Argumente</em> .  Hier kommt der <em>Spread-Operator</em> zur Rettung, sodass wir das √ºbergebene iterierbare Objekt der Argumente durch die Array-Variable <em>a</em> ersetzen k√∂nnen.  Au√üerdem werden wir <em>diesen</em> Kontext nicht mehr an die zu dekorierende Funktion √ºbergeben: Falls erforderlich, helfen <em>Function.prototype.bind</em> oder unser Polyfil. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f(...a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  Ergebnis: <strong>127</strong> , Tests bestanden </p><br><p>  Nun wenden wir uns dem K√∂rper der resultierenden Funktion zu.  Das Auffinden des Schl√ºssels im Cache und das Zur√ºckgeben des Werts ist nat√ºrlich umst√§ndlich.  Versuchen wir zu reduzieren, wie: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k] || (c[k] = f(...a)); } }</code> </pre> <br><p>  Ergebnis: <strong>101</strong> , Test 3 und 4 fielen </p><br><p>  Hier geben wir die <em>hasOwnProperty-</em> Methode auf.  Wir k√∂nnen es uns leisten, da das Ergebnis der Serialisierung des Argumentarrays √ºber <em>JSON.stringify</em> immer "[...]" ist und es unwahrscheinlich ist, dass eine solche Eigenschaft im Prototyp-Cache ( <em>Objekt</em> ) <em>angezeigt</em> wird. </p><br><p>  Als n√§chstes verwenden wir die Funktion des "logischen" ODER-Operators, um den ersten Ausdruck zur√ºckzugeben, wenn er mit der vorherigen Funktionsberechnung in " <em>true"</em> oder auf andere Weise in den zweiten Ausdruck konvertiert werden kann. </p><br><p>  Und hier sind die Tests 3 und 4 gefallen. Dies geschah, weil die dekorierte Funktion <em>console.log</em> keinen Wert <em>zur√ºckgibt</em> : Das Ergebnis ist <em>undefiniert</em> .  Wir legen dies in den Cache, und wenn wir versuchen, die Disjunctor-Funktion zu √ºberpr√ºfen, wenn wir sie erneut aufrufen, werden wir im ersten Operanden implizit <em>false</em> angezeigt und gelangen dementsprechend in den zweiten, was zum Funktionsaufruf f√ºhrt.  Dieser Effekt tritt f√ºr alle auf <em>false</em> reduzierten Ergebnisse auf: <em>0, "", null, NaN</em> usw. </p><br><p>  Anstelle der <em>Anweisung</em> OR und <em>if k√∂nnen</em> wir einen bedingten tern√§ren Operator verwenden: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.hasOwnProperty(k) ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  Ergebnis: <strong>118</strong> , Tests bestanden </p><br><p>  Sehr leicht reduziert.  Aber was ist, wenn Sie <em>Map</em> als Speicher anstelle eines einfachen Objekts verwenden?  Es gibt auch eine kurze Methode: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c.has(k) ?c :c.set(k, f(...a))).get(k); } }</code> </pre> <br><p>  Ergebnis: <strong>121</strong> , Tests bestanden </p><br><p>  Reduzieren komplett fehlgeschlagen.  Aber <em>Karte</em> sofort zu verwerfen ist es nicht wert.  Diese Implementierung der Schl√ºsselwertspeicherung erm√∂glicht es Ihnen, Objekte als Schl√ºssel zu verwenden.  Und das hei√üt, sollten wir <em>JSON.stringify</em> √ºberhaupt aufgeben? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> (c.has(a) ?c :c.set(a, f(...a))).get(a); }</code> </pre> <br><p>  Ergebnis: <strong>83</strong> , Test 3 und 4 fielen </p><br><p>  Es sieht sehr vielversprechend aus!  Die Tests 3 und 4 fielen jedoch wieder ab. Dies liegt daran, dass der Vergleich der Schl√ºssel im <em>Map-</em> Objekt mithilfe des <em>SameValueZero-</em> Algorithmus implementiert wird.  Wenn Sie die Details mit <em>NaN, -0</em> und <em>0</em> weglassen, funktioniert dies √§hnlich wie bei einem <em>strengen Vergleichsoperator</em> ( <em>===</em> ).  Und wir haben ein neues Array von Argumenten (und damit ein Objekt) f√ºr jeden Aufruf der umschlossenen Funktion, selbst mit denselben Werten.  Der Vergleich erfolgt gem√§√ü der Referenz des Objekts, und daher findet die <em>Map.prototype.has-</em> Methode niemals etwas. </p><br><p>  Daher hat die Verwendung von <em>Map</em> uns <em>hasOwnProperty</em> oder <em>JSON.stringify</em> nicht reduziert. </p><br><p>  Der <em>Bediener</em> kommt zur Rettung, der pr√ºft, ob ein Objekt in einem Objekt oder in der Kette seiner Prototypen vorhanden ist.  Warum wir keine Angst vor der Suche in Prototypen haben k√∂nnen, wurde oben erkl√§rt. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  Ergebnis: <strong>105</strong> , Tests bestanden </p><br><p>  Der Hauptteil des Memoizers und der resultierenden Funktion besteht aus zwei Ausdr√ºcken, bei denen eine lokale Variable vor der Logik in der <em>return-Anweisung</em> deklariert und initialisiert werden muss.  Ist es hier m√∂glich, den K√∂rper der Pfeilfunktion auf einen Ausdruck zu reduzieren?  Nat√ºrlich unter Verwendung des <em>IIFE-Musters</em> ( <em>Sofort aufgerufener Funktionsausdruck</em> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> (...a) =&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function"> =&gt;</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] : c[k] = f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)) )({});</code> </pre> <br><p>  Ergebnis: <strong>82</strong> , Tests bestanden </p><br><p>  Es ist Zeit, zus√§tzliche R√§ume loszuwerden: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)))({});</code> </pre> <br><p>  Ergebnis: <strong>68</strong> , Tests bestanden </p><br><p>  Offensichtlich ist der Engpass jetzt die lange <em>JSON.stringify-</em> Methode, die das Objekt rekursiv in eine JSON-Zeichenfolge serialisiert, die wir als Schl√ºssel verwenden.  Tats√§chlich ben√∂tigen wir keine Serialisierungsfunktion, sondern eine Hash-Funktion, mit der wir die Gleichheit von Objekten √ºberpr√ºfen k√∂nnen, da sie in anderen Sprachen funktioniert.  Leider gibt es in JavaScript keine native L√∂sung, und das selbst geschriebene hashCode-Polyphil im <em>Object-</em> Prototyp liegt eindeutig au√üerhalb des Bereichs. </p><br><p>  Hmm, warum m√ºssen wir uns √ºberhaupt serialisieren?  Wenn Sie einem Objekt ein Element per Schl√ºssel hinzuf√ºgen, wird dessen toString implizit aufgerufen.  Da wir uns geweigert haben, das iterierbare <em>Argumentobjekt</em> zugunsten des Arrays durch den <em>Spread-Operator zu verwenden</em> , erfolgt der Aufruf von <em>String</em> nicht von <em>Object.prototype</em> , sondern von <em>Array.prototype</em> , in dem die Elemente neu definiert und durch Kommas getrennt werden.  F√ºr einen anderen Satz von Argumenten erhalten wir also einen anderen Schl√ºssel. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[a]:c[a]=f(...a))({});</code> </pre> <br><p>  Ergebnis: <strong>44</strong> , Test 6 fiel </p><br><p>  Test 6 beginnt gerade zu fallen. Es scheint, dass der R√ºckgabewert das Ergebnis eines vorherigen Funktionsaufrufs in Test 5 ist. Warum geschieht dies?  Ja, wir haben den Aufruf von <em>String</em> f√ºr das <em>Argumentobjekt</em> umgangen, aber wir haben nicht ber√ºcksichtigt, dass jedes Argument auch ein komplexes Objekt sein kann. Wir rufen <em>toString auf,</em> von dem wir das Lieblingsobjekt <em>[Objektobjekt]</em> aller erhalten.  Dies bedeutet, dass die Argumente {x: 1} und {x: 2} denselben Schl√ºssel im Hash verwenden. </p><br><p>  Die zur Konvertierung in base64 verwendete <em>Btoa</em> schien ein guter Anw√§rter f√ºr die Serialisierungsfunktion zu sein.  Aber er f√ºhrt zuerst zur Saite, also keine Chance.  Wir dachten in Richtung der Erzeugung eines URI und der Bildung eines <em>ArrayBuffers</em> an alle Funktionen, um einen Hash oder einen serialisierten Wert zu erhalten.  Aber sie blieben an Ort und Stelle. </p><br><p>  √úbrigens hat <em>JSON.stringify</em> seine eigenen Besonderheiten: <em>Unendlichkeit, NaN, undefiniert, Symbol</em> wird auf <em>null gesetzt</em> .  Gleiches gilt f√ºr Funktionen.  Wenn m√∂glich, erfolgt ein impliziter Aufruf von <em>JSON</em> vom Objekt aus, und <em>Map</em> und <em>Set</em> werden durch einfach aufgez√§hlte Elemente dargestellt.  Angesichts des endg√ºltigen Formats ist dies verst√§ndlich: JSON. </p><br><p>  Was kommt als n√§chstes? </p><br><h3 id="toksichnaya-dorabotka">  Toxische Modifikation </h3><br><p>  Wir alle lieben sicherlich reine Funktionen, aber angesichts des Problems lohnt sich eine solche Anforderung nicht.  Und das bedeutet, dass es Zeit ist, eine Prise Nebenwirkungen hinzuzuf√ºgen. </p><br><p>  Initiieren Sie zun√§chst den Cache wie folgt: </p><br><pre> <code class="javascript hljs">(f,c={})=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  Ergebnis: <strong>66</strong> , Tests bestanden </p><br><p>  Hier verwenden wir den <em>Standardparameter</em> in der Pfeilfunktion.  Nat√ºrlich geben wir dem Kunden die M√∂glichkeit, seinen Cache festzulegen, na und?  Wir haben aber 2 Zeichen reduziert. </p><br><p>  Wie kann ich sonst einen Cache f√ºr eine zu dekorierende Funktion initiieren?  Die richtige Antwort: Warum m√ºssen wir sie initiieren?  Warum nicht etwas Fertiges im Kontext einer zu verpackenden Funktion verwenden?  Aber was ist, wenn die Funktion selbst?  Wir alle wissen, dass Funktionen in JavaScript auch Objekte sind: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  Ergebnis: <strong>59</strong> , Tests bestanden </p><br><p>  Hier sch√ºtzt uns <em>JSON.stringify</em> vor √úberschneidungen mit anderen Eigenschaften und Methoden des Objekts (Funktion) und umschlie√üt die Argumente mit "[...]". </p><br><p>  In diesem Moment rechtfertigt sich das zuvor angewendete <em>IIFE-</em> Muster <em>nicht</em> mehr.  Es ist jedoch dringend erforderlich, einen einzelnen Ausdruck f√ºr die Pfeilfunktion beizubehalten, um eine <em>return-Anweisung</em> zu vermeiden: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a),k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a));</code> </pre> <br><p>  Ergebnis: <strong>57</strong> , Tests bestanden </p><br><p>  Da wir die <em>block-Anweisung</em> in der Pfeilfunktion nicht verwenden, k√∂nnen wir keine Variable ( <em>var</em> oder <em>let</em> ) deklarieren, aber wir k√∂nnen den globalen Kontext verwenden - Nebeneffekt!  Hier hat der Konflikt schon einige Chancen. </p><br><p>  Mit dem <em>Komma-Operator</em> verketten wir zwei Ausdr√ºcke zu einem: Die Operanden werden von links nach rechts ausgewertet, und das Ergebnis ist der Wert des letzteren. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a))<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a);</code> </pre> <br><p>  Ergebnis: <strong>54</strong> , Tests bestanden </p><br><p>  Indem wir nur eine Klammer neu anordneten, wurden drei Zeichen gleichzeitig entfernt.  <em>Der Gruppierungsoperator</em> bei der Berechnung des Schl√ºssels erm√∂glichte es uns, beide Operanden des Ausdrucks zu nur einem Ausdruck zu kombinieren, und die schlie√üende Klammer entfernte das Leerzeichen vor dem <em>Operator in</em> . </p><br><p>  Und endlich: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>f[k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)]=k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f(...a);</code> </pre> <br><p>  Ergebnis: <strong>53</strong> , Tests bestanden </p><br><p>  Warum nicht den Schl√ºssel berechnen, wenn Sie auf den Wert zugreifen?  Und dann - der gleiche tern√§re Operator und die gleiche Zuordnung.  Insgesamt: 53 Zeichen! </p><br><p>  Ist es m√∂glich, die restlichen 3 Zeichen zu entfernen? </p><br><h3 id="osmyslenie">  Verst√§ndnis </h3><br><p>  Warum das alles?  Diese einfache Aufgabe und die anschlie√üende Konvertierungskette von Gewohnheit zu Unanst√§ndigkeit demonstrieren eine betr√§chtliche Anzahl von Merkmalen der JavaScript-Sprache.  In unseren Diskussionen haben wir folgende Dinge angesprochen: </p><br><ul><li>  Pfeilfunktionsausdruck </li><li>  Lexikalisches Scoping &amp; IIFE </li><li>  Array-√§hnliches Argumentobjekt </li><li>  Spread, Komma oder Operatoren </li><li>  Strenger Vergleichsoperator </li><li>  JSON.stringify &amp; toString </li><li>  In Operator &amp; hasOwnProperty </li><li>  Gruppierungsoperator &amp; Blockanweisung </li><li>  Kartenobjekt </li><li>  und noch etwas </li></ul><br><p>  Solche Geschichten sind ein guter Grund, sich mit dem Studium der Besonderheiten einer Sprache zu besch√§ftigen und sie besser zu verstehen (oder umgekehrt).  Und nat√ºrlich nur zum Spa√ü! </p><br><h3 id="prilozhenie">  App </h3><br><p><img src="https://habrastorage.org/webt/a8/n5/qp/a8n5qppehvlrsk6lmflpijrazjg.jpeg" alt="Bild"></p><br><p>  <em>In seinen Abenteuern muss Rick oft seine Portalwaffe kalibrieren.</em>  <em>Der Vorgang braucht Zeit, aber die Eingabe wird oft wiederholt.</em>  <em>Der Wissenschaftler versucht, sich die bereits einmal erzielten Ergebnisse zu merken, um nicht wiederholt Berechnungen durchzuf√ºhren, aber Alkoholismus und senile Senilit√§t wirken sich stark auf sein Ged√§chtnis aus.</em>  <em>Er bat Morty, das Waffeneinstellungsmodul zu verbessern und eine Memoizer-Funktion hinzuzuf√ºgen.</em>  <em>Diese Funktion sollte die Ergebnisse der zu dekorierenden Funktion speichern, um wiederholte Berechnungen zu verhindern.</em>  <em>Nur Morty hat panische Angst vor langen Funktionen.</em>  <em>Helfen Sie ihm, das Problem <strong>so</strong> kompakt <strong>wie m√∂glich zu</strong> l√∂sen.</em>  <em>Die zu dekorierende Funktion kann Ganzzahlen, Zeichenfolgen, Boolesche Werte und Objekte als Argumente verwenden.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413303/">https://habr.com/ru/post/de413303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413287/index.html">DocumentFragment: Was ist das und wie kann man es (nicht) bek√§mpfen?</a></li>
<li><a href="../de413289/index.html">Automatisierung von Rechenzentren oder "Rebellion von Maschinen"</a></li>
<li><a href="../de413291/index.html">Das Buch "Deep Learning in Python"</a></li>
<li><a href="../de413293/index.html">Gro√üartiger Exodus aus der Videospielbranche</a></li>
<li><a href="../de413297/index.html">Variable Web-Schriftarten</a></li>
<li><a href="../de413305/index.html">Batterien, Gigafactory, Northvolt und Siemens. Au√üenseiter T.</a></li>
<li><a href="../de413307/index.html">ESET entdeckte BackSwap Banker mithilfe einer neuen Browser-Manipulationsmethode</a></li>
<li><a href="../de413309/index.html">Dunkle Seite agil</a></li>
<li><a href="../de413311/index.html">Portieren Sie Ihre Webanwendung von reinem JavaScript nach Vue.js.</a></li>
<li><a href="../de413315/index.html">Klimasystem in der Wohnung mit eigenen H√§nden - Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>