<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏽 👲🏿 🅰️ Die Geschichte eines Problems: Der kürzeste JavaScript-Memoizer 🤜🏼 🕦 👑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es war am Abend, am Vorabend der jährlichen HolyJS- Konferenz in St. Petersburg. Unser Unternehmen ist seit mehreren Jahren Sponsor: Dementsprechend h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Geschichte eines Problems: Der kürzeste JavaScript-Memoizer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/413303/"><p><img src="https://habrastorage.org/webt/bn/ca/u1/bncau1_hr7wuzgyelj-ebncmyl4.png" alt="Bild"></p><br><p>  Es war am Abend, am Vorabend der jährlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HolyJS-</a> Konferenz in St. Petersburg.  Unser Unternehmen ist seit mehreren Jahren Sponsor: Dementsprechend hat es auch einen eigenen Stand mit interessanten Interessen für den neugierigen Geist fürsorglicher Entwickler.  Als das Hauptgericht fertig war und alle Aufgaben von Anwälten überprüft und erledigt wurden, beschloss ich, meinen Kollegen nachts mehr intellektuelles Essen zu geben: </p><br><blockquote>  Schreiben Sie einen Memoizer - eine Dekorationsfunktion, die die Ergebnisse der Ausführung einer umschlossenen Funktion speichert, um wiederholte Berechnungen zu verhindern.  Sie haben nur 50 Zeichen. </blockquote><p>  Die Sprache ist natürlich <strong>JavaScript</strong> .  Die Aufgabe selbst ist ein Klassiker, aber die Beschränkung auf 50 Zeichen wurde zu einer echten Herausforderung. </p><br><p>  In den Pausen des ersten Konferenztages diskutierten wir Optionen zur Erreichung des Ziels und reduzierten schrittweise die Reaktion.  Der ganze Hype war gekrönt von der Idee, die Aufgabe mit allen Teilnehmern der Konferenz zu teilen, und am zweiten Tag visualisierten wir die Aufgabe (siehe Anhang) und begannen, Formulare an diejenigen zu verteilen, die wollten.  Als Ergebnis erhielten wir ungefähr 40 Lösungen und waren erneut von der außergewöhnlichen Community der js-Entwickler überzeugt, aber <strong>Dmitry</strong> Kataevs Rekord (SEMrush) von <strong>53</strong> Zeichen blieb bestehen.  Lass es uns herausfinden! </p><a name="habracut"></a><br><h3 id="privychnaya-realizaciya">  Gewohnheitsmäßige Umsetzung </h3><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cache = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cache.hasOwnProperty(key)) { cache[key] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache[key]; } }</code> </pre> <br><p>  Ergebnis: ~ <strong>190</strong> Zeichen </p><br><ul><li>  memoize - unser memoizer </li><li>  f - dekorierte, verpackte Funktion </li><li>  ret - resultierende Funktion </li></ul><br><p>  Um die Antwort zu erhalten - die Größe der Funktion - verwenden wir: </p><br><pre> <code class="javascript hljs">memoize.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).length</code> </pre> <br><p>  Bei der Bewertung der Größe einer Funktion achten wir auf ihren Körper und eine Liste von Parametern.  Wenn die Funktion anonym ist, wird die Deklaration nicht berücksichtigt. </p><br><p>  Einfache Tests zum Testen der Gesundheit nach Missbrauch: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = memoize(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inc = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function"> =&gt;</span></span> ox + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><table><thead><tr><th>  Nein, nein. </th><th>  Funktionsaufruf </th><th>  Das Ergebnis der Ausführung in der Konsole </th></tr></thead><tbody><tr><td>  1. </td><td> <code>log(false)</code> </td> <td>  &gt; falsch </td></tr><tr><td>  2. </td><td> <code>log('2', {x:1})</code> </td> <td>  &gt; '2', {x: 1} </td></tr><tr><td>  3. </td><td> <code>log(false)</code> </td> <td>  Nichts, da die Funktion für diese Werte bereits ausgeführt wurde. </td></tr><tr><td>  4. </td><td> <code>log('2', {x:1})</code> </td> <td>  Nichts, da die Funktion für diese Werte bereits ausgeführt wurde. </td></tr><tr><td>  5. </td><td> <code>inc({x:1})</code> </td> <td>  2 </td></tr><tr><td>  6. </td><td> <code>inc({x:2})</code> </td> <td>  3 </td></tr></tbody></table><br><p>  Als nächstes wird das Ergebnis jeder Implementierung durch das Testergebnis markiert. </p><br><h3 id="chistaya-realizaciya">  Nettoimplementierung </h3><br><p>  Zunächst möchte ich die <em>Funktionsdeklaration</em> zugunsten der Pfeilfunktion loswerden, da wir an <em>diesem</em> Kontext nicht interessiert sind, keine <em>Argumente</em> ansprechen und als Konstruktor nicht beabsichtigen, <em>neue</em> durchzurufen.  Gleichzeitig werden wir die Namen der verwendeten lokalen Variablen reduzieren: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  Ergebnis: <strong>154</strong> , Tests bestanden </p><br><p>  Dann können wir eine ähnliche Operation mit der resultierenden Funktion ausführen, aber dort brauchen wir <em>Argumente</em> .  Hier kommt der <em>Spread-Operator</em> zur Rettung, sodass wir das übergebene iterierbare Objekt der Argumente durch die Array-Variable <em>a</em> ersetzen können.  Außerdem werden wir <em>diesen</em> Kontext nicht mehr an die zu dekorierende Funktion übergeben: Falls erforderlich, helfen <em>Function.prototype.bind</em> oder unser Polyfil. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f(...a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  Ergebnis: <strong>127</strong> , Tests bestanden </p><br><p>  Nun wenden wir uns dem Körper der resultierenden Funktion zu.  Das Auffinden des Schlüssels im Cache und das Zurückgeben des Werts ist natürlich umständlich.  Versuchen wir zu reduzieren, wie: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k] || (c[k] = f(...a)); } }</code> </pre> <br><p>  Ergebnis: <strong>101</strong> , Test 3 und 4 fielen </p><br><p>  Hier geben wir die <em>hasOwnProperty-</em> Methode auf.  Wir können es uns leisten, da das Ergebnis der Serialisierung des Argumentarrays über <em>JSON.stringify</em> immer "[...]" ist und es unwahrscheinlich ist, dass eine solche Eigenschaft im Prototyp-Cache ( <em>Objekt</em> ) <em>angezeigt</em> wird. </p><br><p>  Als nächstes verwenden wir die Funktion des "logischen" ODER-Operators, um den ersten Ausdruck zurückzugeben, wenn er mit der vorherigen Funktionsberechnung in " <em>true"</em> oder auf andere Weise in den zweiten Ausdruck konvertiert werden kann. </p><br><p>  Und hier sind die Tests 3 und 4 gefallen. Dies geschah, weil die dekorierte Funktion <em>console.log</em> keinen Wert <em>zurückgibt</em> : Das Ergebnis ist <em>undefiniert</em> .  Wir legen dies in den Cache, und wenn wir versuchen, die Disjunctor-Funktion zu überprüfen, wenn wir sie erneut aufrufen, werden wir im ersten Operanden implizit <em>false</em> angezeigt und gelangen dementsprechend in den zweiten, was zum Funktionsaufruf führt.  Dieser Effekt tritt für alle auf <em>false</em> reduzierten Ergebnisse auf: <em>0, "", null, NaN</em> usw. </p><br><p>  Anstelle der <em>Anweisung</em> OR und <em>if können</em> wir einen bedingten ternären Operator verwenden: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.hasOwnProperty(k) ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  Ergebnis: <strong>118</strong> , Tests bestanden </p><br><p>  Sehr leicht reduziert.  Aber was ist, wenn Sie <em>Map</em> als Speicher anstelle eines einfachen Objekts verwenden?  Es gibt auch eine kurze Methode: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c.has(k) ?c :c.set(k, f(...a))).get(k); } }</code> </pre> <br><p>  Ergebnis: <strong>121</strong> , Tests bestanden </p><br><p>  Reduzieren komplett fehlgeschlagen.  Aber <em>Karte</em> sofort zu verwerfen ist es nicht wert.  Diese Implementierung der Schlüsselwertspeicherung ermöglicht es Ihnen, Objekte als Schlüssel zu verwenden.  Und das heißt, sollten wir <em>JSON.stringify</em> überhaupt aufgeben? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> (c.has(a) ?c :c.set(a, f(...a))).get(a); }</code> </pre> <br><p>  Ergebnis: <strong>83</strong> , Test 3 und 4 fielen </p><br><p>  Es sieht sehr vielversprechend aus!  Die Tests 3 und 4 fielen jedoch wieder ab. Dies liegt daran, dass der Vergleich der Schlüssel im <em>Map-</em> Objekt mithilfe des <em>SameValueZero-</em> Algorithmus implementiert wird.  Wenn Sie die Details mit <em>NaN, -0</em> und <em>0</em> weglassen, funktioniert dies ähnlich wie bei einem <em>strengen Vergleichsoperator</em> ( <em>===</em> ).  Und wir haben ein neues Array von Argumenten (und damit ein Objekt) für jeden Aufruf der umschlossenen Funktion, selbst mit denselben Werten.  Der Vergleich erfolgt gemäß der Referenz des Objekts, und daher findet die <em>Map.prototype.has-</em> Methode niemals etwas. </p><br><p>  Daher hat die Verwendung von <em>Map</em> uns <em>hasOwnProperty</em> oder <em>JSON.stringify</em> nicht reduziert. </p><br><p>  Der <em>Bediener</em> kommt zur Rettung, der prüft, ob ein Objekt in einem Objekt oder in der Kette seiner Prototypen vorhanden ist.  Warum wir keine Angst vor der Suche in Prototypen haben können, wurde oben erklärt. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  Ergebnis: <strong>105</strong> , Tests bestanden </p><br><p>  Der Hauptteil des Memoizers und der resultierenden Funktion besteht aus zwei Ausdrücken, bei denen eine lokale Variable vor der Logik in der <em>return-Anweisung</em> deklariert und initialisiert werden muss.  Ist es hier möglich, den Körper der Pfeilfunktion auf einen Ausdruck zu reduzieren?  Natürlich unter Verwendung des <em>IIFE-Musters</em> ( <em>Sofort aufgerufener Funktionsausdruck</em> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> (...a) =&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function"> =&gt;</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] : c[k] = f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)) )({});</code> </pre> <br><p>  Ergebnis: <strong>82</strong> , Tests bestanden </p><br><p>  Es ist Zeit, zusätzliche Räume loszuwerden: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)))({});</code> </pre> <br><p>  Ergebnis: <strong>68</strong> , Tests bestanden </p><br><p>  Offensichtlich ist der Engpass jetzt die lange <em>JSON.stringify-</em> Methode, die das Objekt rekursiv in eine JSON-Zeichenfolge serialisiert, die wir als Schlüssel verwenden.  Tatsächlich benötigen wir keine Serialisierungsfunktion, sondern eine Hash-Funktion, mit der wir die Gleichheit von Objekten überprüfen können, da sie in anderen Sprachen funktioniert.  Leider gibt es in JavaScript keine native Lösung, und das selbst geschriebene hashCode-Polyphil im <em>Object-</em> Prototyp liegt eindeutig außerhalb des Bereichs. </p><br><p>  Hmm, warum müssen wir uns überhaupt serialisieren?  Wenn Sie einem Objekt ein Element per Schlüssel hinzufügen, wird dessen toString implizit aufgerufen.  Da wir uns geweigert haben, das iterierbare <em>Argumentobjekt</em> zugunsten des Arrays durch den <em>Spread-Operator zu verwenden</em> , erfolgt der Aufruf von <em>String</em> nicht von <em>Object.prototype</em> , sondern von <em>Array.prototype</em> , in dem die Elemente neu definiert und durch Kommas getrennt werden.  Für einen anderen Satz von Argumenten erhalten wir also einen anderen Schlüssel. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[a]:c[a]=f(...a))({});</code> </pre> <br><p>  Ergebnis: <strong>44</strong> , Test 6 fiel </p><br><p>  Test 6 beginnt gerade zu fallen. Es scheint, dass der Rückgabewert das Ergebnis eines vorherigen Funktionsaufrufs in Test 5 ist. Warum geschieht dies?  Ja, wir haben den Aufruf von <em>String</em> für das <em>Argumentobjekt</em> umgangen, aber wir haben nicht berücksichtigt, dass jedes Argument auch ein komplexes Objekt sein kann. Wir rufen <em>toString auf,</em> von dem wir das Lieblingsobjekt <em>[Objektobjekt]</em> aller erhalten.  Dies bedeutet, dass die Argumente {x: 1} und {x: 2} denselben Schlüssel im Hash verwenden. </p><br><p>  Die zur Konvertierung in base64 verwendete <em>Btoa</em> schien ein guter Anwärter für die Serialisierungsfunktion zu sein.  Aber er führt zuerst zur Saite, also keine Chance.  Wir dachten in Richtung der Erzeugung eines URI und der Bildung eines <em>ArrayBuffers</em> an alle Funktionen, um einen Hash oder einen serialisierten Wert zu erhalten.  Aber sie blieben an Ort und Stelle. </p><br><p>  Übrigens hat <em>JSON.stringify</em> seine eigenen Besonderheiten: <em>Unendlichkeit, NaN, undefiniert, Symbol</em> wird auf <em>null gesetzt</em> .  Gleiches gilt für Funktionen.  Wenn möglich, erfolgt ein impliziter Aufruf von <em>JSON</em> vom Objekt aus, und <em>Map</em> und <em>Set</em> werden durch einfach aufgezählte Elemente dargestellt.  Angesichts des endgültigen Formats ist dies verständlich: JSON. </p><br><p>  Was kommt als nächstes? </p><br><h3 id="toksichnaya-dorabotka">  Toxische Modifikation </h3><br><p>  Wir alle lieben sicherlich reine Funktionen, aber angesichts des Problems lohnt sich eine solche Anforderung nicht.  Und das bedeutet, dass es Zeit ist, eine Prise Nebenwirkungen hinzuzufügen. </p><br><p>  Initiieren Sie zunächst den Cache wie folgt: </p><br><pre> <code class="javascript hljs">(f,c={})=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  Ergebnis: <strong>66</strong> , Tests bestanden </p><br><p>  Hier verwenden wir den <em>Standardparameter</em> in der Pfeilfunktion.  Natürlich geben wir dem Kunden die Möglichkeit, seinen Cache festzulegen, na und?  Wir haben aber 2 Zeichen reduziert. </p><br><p>  Wie kann ich sonst einen Cache für eine zu dekorierende Funktion initiieren?  Die richtige Antwort: Warum müssen wir sie initiieren?  Warum nicht etwas Fertiges im Kontext einer zu verpackenden Funktion verwenden?  Aber was ist, wenn die Funktion selbst?  Wir alle wissen, dass Funktionen in JavaScript auch Objekte sind: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  Ergebnis: <strong>59</strong> , Tests bestanden </p><br><p>  Hier schützt uns <em>JSON.stringify</em> vor Überschneidungen mit anderen Eigenschaften und Methoden des Objekts (Funktion) und umschließt die Argumente mit "[...]". </p><br><p>  In diesem Moment rechtfertigt sich das zuvor angewendete <em>IIFE-</em> Muster <em>nicht</em> mehr.  Es ist jedoch dringend erforderlich, einen einzelnen Ausdruck für die Pfeilfunktion beizubehalten, um eine <em>return-Anweisung</em> zu vermeiden: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a),k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a));</code> </pre> <br><p>  Ergebnis: <strong>57</strong> , Tests bestanden </p><br><p>  Da wir die <em>block-Anweisung</em> in der Pfeilfunktion nicht verwenden, können wir keine Variable ( <em>var</em> oder <em>let</em> ) deklarieren, aber wir können den globalen Kontext verwenden - Nebeneffekt!  Hier hat der Konflikt schon einige Chancen. </p><br><p>  Mit dem <em>Komma-Operator</em> verketten wir zwei Ausdrücke zu einem: Die Operanden werden von links nach rechts ausgewertet, und das Ergebnis ist der Wert des letzteren. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a))<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a);</code> </pre> <br><p>  Ergebnis: <strong>54</strong> , Tests bestanden </p><br><p>  Indem wir nur eine Klammer neu anordneten, wurden drei Zeichen gleichzeitig entfernt.  <em>Der Gruppierungsoperator</em> bei der Berechnung des Schlüssels ermöglichte es uns, beide Operanden des Ausdrucks zu nur einem Ausdruck zu kombinieren, und die schließende Klammer entfernte das Leerzeichen vor dem <em>Operator in</em> . </p><br><p>  Und endlich: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>f[k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)]=k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f(...a);</code> </pre> <br><p>  Ergebnis: <strong>53</strong> , Tests bestanden </p><br><p>  Warum nicht den Schlüssel berechnen, wenn Sie auf den Wert zugreifen?  Und dann - der gleiche ternäre Operator und die gleiche Zuordnung.  Insgesamt: 53 Zeichen! </p><br><p>  Ist es möglich, die restlichen 3 Zeichen zu entfernen? </p><br><h3 id="osmyslenie">  Verständnis </h3><br><p>  Warum das alles?  Diese einfache Aufgabe und die anschließende Konvertierungskette von Gewohnheit zu Unanständigkeit demonstrieren eine beträchtliche Anzahl von Merkmalen der JavaScript-Sprache.  In unseren Diskussionen haben wir folgende Dinge angesprochen: </p><br><ul><li>  Pfeilfunktionsausdruck </li><li>  Lexikalisches Scoping &amp; IIFE </li><li>  Array-ähnliches Argumentobjekt </li><li>  Spread, Komma oder Operatoren </li><li>  Strenger Vergleichsoperator </li><li>  JSON.stringify &amp; toString </li><li>  In Operator &amp; hasOwnProperty </li><li>  Gruppierungsoperator &amp; Blockanweisung </li><li>  Kartenobjekt </li><li>  und noch etwas </li></ul><br><p>  Solche Geschichten sind ein guter Grund, sich mit dem Studium der Besonderheiten einer Sprache zu beschäftigen und sie besser zu verstehen (oder umgekehrt).  Und natürlich nur zum Spaß! </p><br><h3 id="prilozhenie">  App </h3><br><p><img src="https://habrastorage.org/webt/a8/n5/qp/a8n5qppehvlrsk6lmflpijrazjg.jpeg" alt="Bild"></p><br><p>  <em>In seinen Abenteuern muss Rick oft seine Portalwaffe kalibrieren.</em>  <em>Der Vorgang braucht Zeit, aber die Eingabe wird oft wiederholt.</em>  <em>Der Wissenschaftler versucht, sich die bereits einmal erzielten Ergebnisse zu merken, um nicht wiederholt Berechnungen durchzuführen, aber Alkoholismus und senile Senilität wirken sich stark auf sein Gedächtnis aus.</em>  <em>Er bat Morty, das Waffeneinstellungsmodul zu verbessern und eine Memoizer-Funktion hinzuzufügen.</em>  <em>Diese Funktion sollte die Ergebnisse der zu dekorierenden Funktion speichern, um wiederholte Berechnungen zu verhindern.</em>  <em>Nur Morty hat panische Angst vor langen Funktionen.</em>  <em>Helfen Sie ihm, das Problem <strong>so</strong> kompakt <strong>wie möglich zu</strong> lösen.</em>  <em>Die zu dekorierende Funktion kann Ganzzahlen, Zeichenfolgen, Boolesche Werte und Objekte als Argumente verwenden.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413303/">https://habr.com/ru/post/de413303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413287/index.html">DocumentFragment: Was ist das und wie kann man es (nicht) bekämpfen?</a></li>
<li><a href="../de413289/index.html">Automatisierung von Rechenzentren oder "Rebellion von Maschinen"</a></li>
<li><a href="../de413291/index.html">Das Buch "Deep Learning in Python"</a></li>
<li><a href="../de413293/index.html">Großartiger Exodus aus der Videospielbranche</a></li>
<li><a href="../de413297/index.html">Variable Web-Schriftarten</a></li>
<li><a href="../de413305/index.html">Batterien, Gigafactory, Northvolt und Siemens. Außenseiter T.</a></li>
<li><a href="../de413307/index.html">ESET entdeckte BackSwap Banker mithilfe einer neuen Browser-Manipulationsmethode</a></li>
<li><a href="../de413309/index.html">Dunkle Seite agil</a></li>
<li><a href="../de413311/index.html">Portieren Sie Ihre Webanwendung von reinem JavaScript nach Vue.js.</a></li>
<li><a href="../de413315/index.html">Klimasystem in der Wohnung mit eigenen Händen - Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>