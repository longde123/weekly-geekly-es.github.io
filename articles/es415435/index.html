<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✔️ 🐙 🙏🏾 Desarrollo de tarjetas de interfaz en Soil Xilinx Zynq 7000 para grabación de voz en formato analógico y digital 🌁 😓 🤸🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este artículo, compartiremos nuestra experiencia en el desarrollo de tarjetas de interfaz de la unidad de interfaz basada en SoC ARM + FPGA Xilinx ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de tarjetas de interfaz en Soil Xilinx Zynq 7000 para grabación de voz en formato analógico y digital</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415435/"><img src="https://habrastorage.org/webt/rg/2_/55/rg2_55mpm_gc8ip2vlemo9tel9k.jpeg"><br><br>  En este artículo, compartiremos nuestra experiencia en el desarrollo de tarjetas de interfaz de la unidad de interfaz basada en SoC ARM + FPGA Xilinx Zynq 7000. Las placas se diseñaron para grabar señales de voz en formato PRI / BRI analógico y digital (ISDN, E1 / T1).  El dispositivo final en sí se utilizará para registrar las negociaciones en la aviación civil. <br><a name="habracut"></a><br><h2>  Hierro: selección de plataforma de hardware del dispositivo </h2><br>  La elección de la plataforma de hardware fue determinada por el soporte de los protocolos PRI / BRI, que solo se pueden implementar en el lado de FPGA.  Los microcontroladores (MCU) y los microprocesadores (MPU) no encajaban. <br><br>  Se podrían elegir dos soluciones a este problema: <br><br><ol><li>  Síntesis del núcleo de Microblaze IP </li><li>  SoC Zynq-7000. </li></ol><br>  Nos instalamos en un sistema en un chip Zynq 7000 (SoC), porque  es más fácil escribir aplicaciones de software y proporciona más funcionalidad para tareas actuales y futuras. <br><br>  En total, se recopiló la siguiente lista de hierro en el marco del proyecto: <br><br>  <b>1.Xilinx Zynq 7020</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mars-ZX3</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mars EB1</a> ) <br><img src="https://habrastorage.org/webt/ls/g9/4w/lsg94w0qj20bxkf5t8k2gzvzx1e.jpeg"><br>  <i>Enclustra Mars ZX3 SOM</i> <br><img src="https://habrastorage.org/webt/ft/z3/4t/ftz34tc8zkk-9gddjcx2atmufc8.jpeg"><br>  <i>Enclustra Mars EB1 Baseboard</i> <br><br>  <b>2. TI TLV320AIC34</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tlv320aic34evm-k</a> y placa base USB). <br><br><img src="https://habrastorage.org/webt/3z/ls/g-/3zlsg-yry1k4e4qyqu1g-o0xt4a.jpeg"><br>  <i>Tarjeta de depuración para tlv320aic34 (tlv320aic34evm-k)</i> <br><br><img src="https://habrastorage.org/webt/pb/mk/84/pbmk84mawx1rbpmqreghow9fjim.jpeg"><br>  <i>Tarjeta de expansión USB-MODEVM para tlv320aic34evm-k</i> <br><br>  <b>3. IDT82P2288 - PRI, XHFC-4SU - Microcircuitos BRI,</b> no había kits de depuración, por lo tanto, solo sentamos las bases como un núcleo ip para las pruebas, y el bautismo de fuego ocurrió justo en el proceso, después de hacer placas prototipo. <br><br><h2>  Trabaje con el sistema en el chip Xilinx Zynq 7000 </h2><br><br><img src="https://habrastorage.org/webt/t5/2n/ka/t52nkauzukagn0mp_aruobwjigm.png"><br>  <i>La estructura interna del SoC Xilinx Zynq 7000</i> <br><br><img src="https://habrastorage.org/webt/u9/nn/nl/u9nnnlwp0nib8s4td2drrorqm54.png"><br>  <i>Pasos para generar archivos de arranque para Xilinx Zynq</i> <br><br>  Parpadear / descargar ejecutables para Zynq es diferente de la descarga habitual para MPU.  El trabajo habitual con los procesadores Cortex-A es cargar u-boot, kernel linux, rootfs.  Y en Zynq, aparece Bitstream, el archivo de firmware para FPGA.  El flujo de bits contiene una descripción de los bloques de hardware en el FPGA y la comunicación interna con el procesador.  Este archivo se carga al iniciar el sistema.  También en el lado de Linux hay un mecanismo que le permite flashear la parte PL inmediatamente durante la operación, dicho dispositivo se llama xdevcfg ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">administrador FPGA ZYNQ desde 2018.1</a> ). <br><br><h2>  Interfaces PRI / BRI </h2><br><img src="https://habrastorage.org/webt/om/zo/dr/omzodrzsfz9d5oqyo-ukvvsozve.jpeg"><br>  <i>Características de las redes digitales PRI / BRI</i> <br><br>  La interfaz de velocidad primaria (PRI) es una interfaz de red ISDN estándar que define la disciplina de conectar estaciones ISDN a troncales de banda ancha que conectan centrales locales o centrales o conmutadores de red. <br><br><img src="https://habrastorage.org/webt/_5/p0/5k/_5p05km2btytoe7ptkdrfuz_-8o.png"><br>  <i>Tipo de trama transmitida para PRI</i> <br><br><img src="https://habrastorage.org/webt/rp/ux/hd/rpuxhdxujlk8c2cnxxgdga74-tk.png"><br>  <i>Vista de la trama transmitida para BRI</i> <br><br><img src="https://habrastorage.org/webt/-i/1c/90/-i1c90_mrzspj2jhrog9akk_u4g.png"><br>  <i>La estructura interna de la física del PRI - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IDT82P2288</a></i> <br><br><img src="https://habrastorage.org/webt/ca/iv/s5/caivs5jr2frxcu_xiign_my2db8.png"><br>  <i>La estructura interna de la física BRI - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">XHFC-4SU</a></i> <br><br><h2>  Códec de audio TLV320AIC34 </h2><br>  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">códec de audio TLV320AIC34 de</a> baja potencia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuatro canales</a> para audio y telefonía portátil es una buena solución para su uso en telefonía analógica. <br><br><img src="https://habrastorage.org/webt/7i/7g/lr/7i7glrlam_fmxm2inkwcgqinrl8.png"><br>  <i>Tlv320aic34 Parte A, el códec de audio contiene dos bloques de funciones</i> <br><br>  Los datos pueden transmitirse a través de la interfaz I2S, así como a través de DSP, PCM, TDM. <br><br>  I2S es un estándar de interfaz de bus serie, se utiliza para conectar dispositivos de audio digital y representa eléctricamente 3 conductores que van de un dispositivo activo a uno pasivo, así como 4 señales que corresponden a ellos de la siguiente manera: <br><br><ol><li>  Bit Clock (BCLK). </li><li>  Marco de señal de reloj (según palabras) sincronización (WCLK). </li><li>  Señal de datos que puede transmitir o recibir 2 canales divididos en el tiempo (DIN / DOUT). </li></ol><br>  Los canales para recibir y transmitir datos están divididos, es decir, hay un canal separado para recibir datos y un canal para la transmisión.  El controlador recibe los datos transmitidos por el códec de audio, pero también es posible lo contrario. <br><br><img src="https://habrastorage.org/webt/p5/op/th/p5opthpov06xstxalowbqz_emt8.png"><br>  <i>Marco I2S, características de la interfaz I2S</i> <br><br>  Después de seleccionar todos los componentes de hardware, resolvimos el problema de conectar el códec de audio y Xilinx Zynq 7020. <br><br><h2>  Buscar núcleos I2S </h2><br>  Probablemente el momento más difícil al trabajar con la transmisión de audio en el Xilinx Zynq 7020 fue que en la parte del procesador de este sistema básicamente no hay bus I2S en el chip, por lo que tuve que encontrar el núcleo I2S.  Esta tarea se complicó por la condición de que el núcleo de ip debería estar libre. <br><br>  Nos decidimos por varios núcleos ip.  Encontrado para el núcleo de metal desnudo I2S <b>Digilent</b> .  Encontramos varios núcleos de IP en núcleos <b>abiertos</b> y, probablemente, la mejor opción para nosotros es el núcleo de ip de <b>Analog Devices</b> .  Producen núcleos ip para sus equipos, para la interacción FPGA / FPGA. <br><br>  Estamos interesados ​​en el ip-core llamado <b>AXI-I2S-ADI.</b>  Analog Devices está promoviendo estos núcleos ip para sus plataformas de hardware. <br><br>  Lista total de casos de uso: <br><br><ol><li>  Metal desnudo: núcleo IP para I2S (audio Digilent ZYBO) </li><li>  opencores.org </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Controlador AXI-I2S-ADI</a> (dispositivos analógicos) </li></ol><br><h3>  Núcleo IP AXI-I2S-ADI </h3><br>  El núcleo de ip en sí se ve así: tiene las líneas bclk, wclk, din, dout.  Se conecta al DMA Xilinx Zynq 7000, en nuestro ejemplo, se utiliza la parte DMA PS.  Todo el intercambio de datos ocurre a través de DMA.  DMA puede ser una unidad independiente o una parte integral de PS SoC. <br><br>  Al configurar este kernel ip, es importante no olvidar enviar la frecuencia maestra mclk a tlv320aic34, como una opción al usar el kit de depuración para tlv320aic34: enviar una frecuencia maestra externa. <br><br><img src="https://habrastorage.org/webt/i8/xn/z4/i8xnz4rijta_07gc1zgc2a8vfxc.png"><br>  <i>Bloque de funciones con axi-i2s-adi conectado</i> <br><br>  Después del procedimiento de configuración, la tarea consistía en iniciar la funcionalidad en el sistema operativo Linux. <br><br><h2>  Inicie y configure el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">árbol de dispositivos</a> para tlv320aic34 </h2><br>  Configuración de i2c (tlv320aic34 está configurado en esta interfaz): <br><br><pre><code class="cpp hljs">i2c0: i2c@e0004000 { ... tlv320aic3x: tlv320aic3x@<span class="hljs-number"><span class="hljs-number">18</span></span> { <span class="hljs-meta"><span class="hljs-meta">#sound-dai-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;0&gt;; compatible = "ti,tlv320aic3x"; reg = &lt;0x18&gt;; gpio-reset = &lt;&amp;axi_gpio_0 0 0&gt;; ai3x-gpio-func = &lt;&amp;axi_gpio_0 1 0&gt;, /* AIC3X_GPIO1_FUNC_DISABLED */ &lt;&amp;axi_gpio_0 2 0&gt;; /* AIC3X_GPIO2_FUNC_DIGITAL_MIC_INPUT */ AVDD-supply = &lt;&amp;vmmc2&gt;; DRVDD-supply = &lt;&amp;vmmc2&gt;; IOVDD-supply = &lt;&amp;vmmc2&gt;; DVDD-supply = &lt;&amp;vmmc2&gt;; ai3x-micbias-vg = &lt;1&gt;; }; ... };</span></span></span></span></code> </pre> <br>  Configuración de i2s (los datos de audio se transmiten a través de esta interfaz): <br><br><pre> <code class="cpp hljs">i2s_clk: i2s_clk { <span class="hljs-meta"><span class="hljs-meta">#clock-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;0&gt;; compatible = "fixed-clock"; clock-frequency = &lt;11289600&gt;; clock-output-names = "i2s_clk"; }; axi_i2s_adi_0: axi_i2s_adi@43C00000 { compatible = "adi,axi-i2s-1.00.a"; reg = &lt;0x43C00000 0x1000&gt;; xlnx,bclk-pol = &lt;0x0&gt;; xlnx,dma-type = &lt;0x1&gt;; xlnx,has-rx = &lt;0x1&gt;; xlnx,has-tx = &lt;0x1&gt;; xlnx,lrclk-pol = &lt;0x0&gt;; xlnx,num-ch = &lt;0x1&gt;; xlnx,s-axi-min-size = &lt;0x000001FF&gt;; xlnx,slot-width = &lt;0x18&gt;; }; &amp;axi_i2s_adi_0 { #sound-dai-cells = &lt;0&gt;; compatible = "adi,axi-i2s-1.00.a"; clocks = &lt;&amp;clkc 15&gt;, &lt;&amp;i2s_clk&gt;; clock-names = "axi", "ref"; dmas = &lt;&amp;dmac_s 0 &amp;dmac_s 1&gt;; dma-names = "tx", "rx"; };</span></span></span></span></code> </pre> <br>  Configuración de la tarjeta de sonido en el árbol de dispositivos (tarjetas de audio): <br><br><pre> <code class="cpp hljs"> sound { compatible = <span class="hljs-string"><span class="hljs-string">"simple-audio-card"</span></span>; simple-audio-card,name = <span class="hljs-string"><span class="hljs-string">"TLV320AIC34"</span></span>; simple-audio-card,format = <span class="hljs-string"><span class="hljs-string">"i2s"</span></span>; simple-audio-card,bitclock-master = &lt;&amp;dailink0_master&gt;; simple-audio-card,frame-master = &lt;&amp;dailink0_master&gt;; simple-audio-card,widgets = ... simple-audio-card,routing = ... dailink0_master: simple-audio-card,cpu { clocks = &lt;&amp;i2s_clk&gt;; sound-dai = &lt;&amp;axi_i2s_adi_0&gt;; }; simple-audio-card,codec { clocks = &lt;&amp;i2s_clk&gt;; sound-dai = &lt;&amp;tlv320aic3x&gt;; }; }; };</code> </pre> <br>  Después de todas las manipulaciones para configurar y configurar el códec en el árbol de dispositivos en Linux, apareció la codiciada tarjeta de audio y pudimos escuchar música (nuestra primera pista de música fue Highway to Hell, AC / DC). <br><br>  Esto es lo que tuvimos que hacer para esto: <br><br><ul><li>  Generó la frecuencia necesaria usando clk_wiz (asistente de sincronización) </li><li>  DTS configurado correctamente para tlv320aic34 </li><li>  Soporte agregado para el controlador tlv320aic3x </li><li>  Se agregaron paquetes de audio a buildroot para reproducir audio (aplay, madplay, etc.) </li></ul><br>  En el proceso de desarrollo del dispositivo final, nos enfrentamos a la tarea de conectar 4 microcircuitos tlv320aic34.  El chip tlv320aic34 descrito anteriormente contiene 2 bloques para trabajar con la transmisión de audio, cada bloque tiene su propia línea i2c para configurar y configurar los parámetros de audio.  Un bloque puede tener solo cuatro direcciones, respectivamente, es imposible conectar cuatro microcircuitos tlv320aic34 a una interfaz i2c, debe usar dos interfaces i2c (8 bloques de audio independientes).  Para cada bloque, si inicia mclk, blck, wclk, din / dout individualmente, debe agregar 40 líneas de señal en total, lo cual es imposible e irracional desde el punto de vista del circuito para el módulo som que elegimos, porque además de estas señales, tenía que conectar muchas otras líneas y interfaces <br><br>  Como resultado, decidimos cambiar la tarjeta de audio al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modo TDM</a> , en el que se combinan todas las líneas mclk, bclk, din, dout, lo que reduce el número total de líneas de comunicación.  Esta decisión afectó la operación de axi-i2s-adi, debido al hecho de que el núcleo de ip funcionaba en modo maestro.  Además, este cambio no nos permitió usar nuestro ip-core en modo TDM, y una decisión decidida fue abandonar el uso del ip-core seleccionado.  Tuve que escribir un kernel ip para escuchar el tráfico de i2s y enviarlo a dma, esta solución nos permitió crear una interfaz común para recibir datos que no dependería del tipo de tarjeta para grabar llamadas (tarjetas analógicas y digitales). <br><br>  La arquitectura inicial para recibir la transmisión de audio y su procesamiento a través de la interfaz i2s: <br><br><img src="https://habrastorage.org/webt/yn/24/2d/yn242d_8cm4kazs2ycwceevqqe8.jpeg"><br><br>  La arquitectura final para recibir la transmisión de audio y su procesamiento a través de la interfaz i2s: <br><br><img src="https://habrastorage.org/webt/mz/py/dt/mzpydtgravupatvivp_zmpiitig.jpeg"><br><br>  Arquitectura de recibir un flujo PRI y su procesamiento: <br><br><img src="https://habrastorage.org/webt/qx/ee/7w/qxee7wt1mdazgm0tu0eukbm5rmy.jpeg"><br><br>  Arquitectura de recepción y procesamiento de secuencias BRI: <br><br><img src="https://habrastorage.org/webt/wd/uf/ny/wdufnykenpfxgwyhrnr3x6ep2kg.jpeg"><br><br><h2>  Axi dma </h2><br>  Este es un elemento importante del sistema de sincronización de datos para dma. <br><br><img src="https://habrastorage.org/webt/v7/fx/pk/v7fxpk_3eemrqnlmy3iejsjrup4.png"><br>  <i>Ventana de configuración de AXI DMA en Xilinx Vivado</i> <br><br>  En la pantalla de impresión, se presenta el bloque AXI DMA.  Tiene muchos parámetros.  Puede configurar en el bus la cantidad de datos a transferir.  Los datos se pueden alinear o en cualquier formato.  Una descripción detallada de la operación e interacción con axi dma se describe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la documentación técnica</a> (de una versión a otra hay una adición y corrección de imprecisiones en la descripción, así como el refinamiento de los núcleos ip). <br><br><h2>  Verifique la transferencia de datos a través de las opciones de prueba AXI DMA, AXI DMA </h2><br>  Al desarrollar el controlador, decidimos buscar código abierto y adaptarlo a nuestra tarea.  Como resultado, elegimos las fuentes del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto github ezdma</a> (juego de palabras, leer como dma fácil). <br><br>  El siguiente paso es el desarrollo de un controlador de prueba, fue una etapa preparatoria antes del momento en que nos llegó un núcleo de ip con funcionalidad preparada del departamento de desarrollo de FPGA (el proceso de desarrollo descrito fue formado por programadores integrados).  Antes de este momento, decidimos tomar AXI DMA, AXI DATA FIFO y hacer un loopback para asegurarnos de futuros errores.  Enrollamos el envío y la recepción de datos, por lo que verificamos el resultado de nuestro trabajo y el rendimiento de nuestro controlador.  Adaptamos un poco la funcionalidad, la adaptamos a nuestros deseos en la interfaz de interacción y una vez más verificamos la operatividad del controlador y el principio de interacción seleccionado. <br><br><img src="https://habrastorage.org/webt/iw/si/uj/iwsiujsbv1tckuamu1lsjalzrao.png"><br>  <i>Diseño de bloque retrospectivo, la primera forma de probar AXI DMA</i> <br><br>  Un ejemplo de una descripción de DMA y ezdma en un árbol de dispositivos: <br><br><pre> <code class="cpp hljs">/ { amba_pl: amba_pl { <span class="hljs-meta"><span class="hljs-meta">#address-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;1&gt;; #size-cells = &lt;1&gt;; compatible = "simple-bus"; ranges ; axi_dma_1: axi_dma { #dma-cells = &lt;1&gt;; compatible = "xlnx,axi-dma-1.00.a"; reg = &lt;0x40400000 0x10000&gt;; clock-names = "s_axi_lite_aclk", "m_axi_sg_aclk", "m_axi_mm2s_aclk", "m_axi_s2mm_aclk"; clocks = &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;; interrupt-parent = &lt;&amp;intc&gt;; interrupts = &lt;0 29 4 0 30 4&gt;; xlnx,addrwidth = &lt;0x20&gt;; xlnx,include-sg; dma-channel@40400000 { compatible = "xlnx,axi-dma-mm2s-channel"; dma-channels = &lt;0x1&gt;; interrupts = &lt;0 29 4&gt;; xlnx,datawidth = &lt;0x20&gt;; xlnx,device-id = &lt;0x0&gt;; xlnx,include-dre ; }; dma-channel@40400030 { compatible = "xlnx,axi-dma-s2mm-channel"; dma-channels = &lt;0x1&gt;; interrupts = &lt;0 30 4&gt;; xlnx,datawidth = &lt;0x20&gt;; xlnx,device-id = &lt;0x0&gt;; xlnx,include-dre ; }; }; ezdma0 { compatible = "ezdma"; dmas = &lt;&amp;axi_dma_1 0 &amp;axi_dma_1 1&gt;; dma-names = "loop_tx", "loop_rx"; // used when obtaining reference to above DMA core using dma_request_slave_channel() ezdma,dirs = &lt;2 1&gt;; // direction of DMA channel: 1 = RX (dev-&gt;cpu), 2 = TX (cpu-&gt;dev) }; ... }; };</span></span></span></span></code> </pre> <br>  Puede generar fácilmente archivos dts / dtsi utilizando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta Device Tree Generator</a> . <br><br>  El segundo paso en nuestro proceso de desarrollo es la creación de un kernel ip de prueba para verificar el rendimiento del controlador, solo que esta vez los datos serán significativos, con la transferencia a través de AXIS a AXI_DMA (como lo estará en la versión final del kernel ip). <br><br><img src="https://habrastorage.org/webt/uc/nc/iz/ucncizx2gwl3am9mxz5iursdy1q.png"><br>  <i>Flujo de trabajo de la interfaz AXIS</i> <br><br>  Implementamos dos variantes de núcleos ip para la generación de datos, la primera versión probada se implementa a través de verilog, la segunda, en HLS (en este contexto, HLS apareció bajo el lema "estilo-moda-juventud"). <br><br>  El generador de datos verilog (y generalmente en los idiomas de la familia hdl: verilog, vhdl, etc.) es una solución estándar cuando se desarrollan núcleos ip de este tipo.  Aquí hay algunos fragmentos de código para el núcleo de IP intermedio: <br><br><pre> <code class="hljs sql">module GenCnt ( …. assign HandsHake = m_axis_din_tready &amp; m_axis_dout_tvalid; always @(posedge Clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Rst) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sIDLE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (smCnt) sIDLE: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sDATA; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> sDATA: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Cnt == cTopCnt - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sLAST; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... endmodule</code> </pre> <br>  No hay necesidad de una descripción más detallada, ya que esta es una tarea típica de un diseñador de FPGA. <br><br>  Una "bestia" más interesante aquí es HLS.  <b>Vivado HLS (High Level Synthesis)</b> es el nuevo software Xilinx CAD para crear dispositivos digitales que utilizan lenguajes de alto nivel como OpenCL, C o C ++. <br><br>  C / C ++ son los lenguajes principales para un ingeniero de software integrado, por lo que resolver un problema usando estos lenguajes es más interesante en términos de implementación y análisis comparativo para proyectos futuros. <br><br>  Aquí hay dos pequeños ejemplos de trabajo con HLS.  El primer ejemplo es un generador de datos para AXI_DMA, el segundo ejemplo es el intercambio de datos entre la parte del procesador y la lógica programable a través de la interfaz s_axilite. <br><br>  El intercambio de datos a través de la interfaz s_axilite (el segundo ejemplo) se implementó para que en cualquier momento en procfs fuera posible restar qué bitstream estaba cargado, y para que fuera posible rastrear la corrección del trabajo versionando para la parte PL del SoC.  Aquí aparece un punto muy interesante con s_axilite: Vivado HLS genera un controlador para Linux (el controlador, a su vez, nos adaptamos para trabajar a través de procesos para preservar la herencia de la escritura).  A continuación se muestra un ejemplo del código generado para Linux (la ruta a la solución de origen1 / impl / ip / drivers / name_xxx / src /). <br><br><img src="https://habrastorage.org/webt/ss/kd/rh/sskdrh3olokqp7miv9qm-ni1gnq.png"><br>  <i>Etapas de síntesis HLS y generación de código rtl</i> <br><br>  Generador de datos HLS para verificar la operación con AXI_DMA: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ap_axi_sdata.h&gt; #include &lt;hls_stream.h&gt; #define SIZE_STREAM 1024 struct axis { int tdata; bool tlast; }; void data_generation(axis outStream[SIZE_STREAM]) { #pragma HLS INTERFACE axis port=outStream int i = 0; do{ outStream[i].tdata = i; outStream[i].tlast = (i == (SIZE_STREAM - 1)) ? 1 : 0; i++; }while( i &lt; SIZE_STREAM); }</span></span></span></span></code> </pre> <br>  Un ejemplo de obtención de versiones y tipo de placa de interfaz: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; void info( int &amp;aVersion, int &amp;bSubVersion, int &amp;cTypeBoard, int version, int subVersion, int typeBoard ){ #pragma HLS INTERFACE s_axilite port=aVersion #pragma HLS INTERFACE s_axilite port=bSubVersion #pragma HLS INTERFACE s_axilite port=cTypeBoard #pragma HLS INTERFACE ap_ctrl_none port=return aVersion = version; bSubVersion = subVersion; cTypeBoard = typeBoard; }</span></span></span></span></code> </pre> <br>  Como notó, para el desarrollo en hls es muy importante comprender el trabajo y la aplicación de varios pragmas (pragma HLS), ya que el proceso de síntesis está directamente relacionado con los pragmas. <br><br>  Controlador generado para s_axilita: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ============================================================== // File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC // Version: 2016.4 // Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved. // // ============================================================== #ifdef __linux__ /***************************** Include Files *********************************/ #include "xinfo.h" /***************** Macros (Inline Functions) Definitions *********************/ #define MAX_UIO_PATH_SIZE 256 #define MAX_UIO_NAME_SIZE 64 #define MAX_UIO_MAPS 5 #define UIO_INVALID_ADDR 0 /**************************** Type Definitions ******************************/ typedef struct { u32 addr; u32 size; } XInfo_uio_map; typedef struct { int uio_fd; int uio_num; char name[ MAX_UIO_NAME_SIZE ]; char version[ MAX_UIO_NAME_SIZE ]; XInfo_uio_map maps[ MAX_UIO_MAPS ]; } XInfo_uio_info; /***************** Variable Definitions **************************************/ static XInfo_uio_info uio_info; /************************** Function Implementation *************************/ static int line_from_file(char* filename, char* linebuf) { char* s; int i; FILE* fp = fopen(filename, "r"); if (!fp) return -1; s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp); fclose(fp); if (!s) return -2; for (i=0; (*s)&amp;&amp;(i&lt;MAX_UIO_NAME_SIZE); i++) { if (*s == '\n') *s = 0; s++; } return 0; } static int uio_info_read_name(XInfo_uio_info* info) { char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/name", info-&gt;uio_num); return line_from_file(file, info-&gt;name); } static int uio_info_read_version(XInfo_uio_info* info) { char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/version", info-&gt;uio_num); return line_from_file(file, info-&gt;version); } static int uio_info_read_map_addr(XInfo_uio_info* info, int n) { int ret; char file[ MAX_UIO_PATH_SIZE ]; info-&gt;maps[n].addr = UIO_INVALID_ADDR; sprintf(file, "/sys/class/uio/uio%d/maps/map%d/addr", info-&gt;uio_num, n); FILE* fp = fopen(file, "r"); if (!fp) return -1; ret = fscanf(fp, "0x%x", &amp;info-&gt;maps[n].addr); fclose(fp); if (ret &lt; 0) return -2; return 0; } static int uio_info_read_map_size(XInfo_uio_info* info, int n) { int ret; char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/maps/map%d/size", info-&gt;uio_num, n); FILE* fp = fopen(file, "r"); if (!fp) return -1; ret = fscanf(fp, "0x%x", &amp;info-&gt;maps[n].size); fclose(fp); if (ret &lt; 0) return -2; return 0; } int XInfo_Initialize(XInfo *InstancePtr, const char* InstanceName) { XInfo_uio_info *InfoPtr = &amp;uio_info; struct dirent **namelist; int i, n; char* s; char file[ MAX_UIO_PATH_SIZE ]; char name[ MAX_UIO_NAME_SIZE ]; int flag = 0; assert(InstancePtr != NULL); n = scandir("/sys/class/uio", &amp;namelist, 0, alphasort); if (n &lt; 0) return XST_DEVICE_NOT_FOUND; for (i = 0; i &lt; n; i++) { strcpy(file, "/sys/class/uio/"); strcat(file, namelist[i]-&gt;d_name); strcat(file, "/name"); if ((line_from_file(file, name) == 0) &amp;&amp; (strcmp(name, InstanceName) == 0)) { flag = 1; s = namelist[i]-&gt;d_name; s += 3; // "uio" InfoPtr-&gt;uio_num = atoi(s); break; } } if (flag == 0) return XST_DEVICE_NOT_FOUND; uio_info_read_name(InfoPtr); uio_info_read_version(InfoPtr); for (n = 0; n &lt; MAX_UIO_MAPS; ++n) { uio_info_read_map_addr(InfoPtr, n); uio_info_read_map_size(InfoPtr, n); } sprintf(file, "/dev/uio%d", InfoPtr-&gt;uio_num); if ((InfoPtr-&gt;uio_fd = open(file, O_RDWR)) &lt; 0) { return XST_OPEN_DEVICE_FAILED; } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> slave interface 'Axilites' should be mapped to uioX/map0 InstancePtr-&gt;Axilites_BaseAddress = (u32)mmap(NULL, InfoPtr-&gt;maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr-&gt;uio_fd, 0 * getpagesize()); assert(InstancePtr-&gt;Axilites_BaseAddress); InstancePtr-&gt;IsReady = XIL_COMPONENT_IS_READY; return XST_SUCCESS; } int XInfo_Release(XInfo *InstancePtr) { XInfo_uio_info *InfoPtr = &amp;uio_info; assert(InstancePtr != NULL); assert(InstancePtr-&gt;IsReady == XIL_COMPONENT_IS_READY); munmap((void*)InstancePtr-&gt;Axilites_BaseAddress, InfoPtr-&gt;maps[0].size); close(InfoPtr-&gt;uio_fd); return XST_SUCCESS; } #endif</span></span></code> </pre> <br>  Un archivo importante que le indica la ubicación de las variables (registros) en el espacio de direcciones es el archivo x # your_name # _hw.h.  Siempre puede verificar la corrección del núcleo de IP escrito utilizando la herramienta devmem. <br><br>  El contenido de este archivo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ============================================================== // File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC // Version: 2016.4 // Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved. // // ============================================================== // AXILiteS // 0x00 : reserved // 0x04 : reserved // 0x08 : reserved // 0x0c : reserved // 0x10 : Data signal of aVersion // bit 31~0 - aVersion[31:0] (Read) // 0x14 : Control signal of aVersion // bit 0 - aVersion_ap_vld (Read/COR) // others - reserved // 0x18 : Data signal of bSubVersion // bit 31~0 - bSubVersion[31:0] (Read) // 0x1c : Control signal of bSubVersion // bit 0 - bSubVersion_ap_vld (Read/COR) // others - reserved // 0x20 : Data signal of cTypeBoard // bit 31~0 - cTypeBoard[31:0] (Read) // 0x24 : Control signal of cTypeBoard // bit 0 - cTypeBoard_ap_vld (Read/COR) // others - reserved // (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake) #define XINFO_AXILITES_ADDR_AVERSION_DATA 0x10 #define XINFO_AXILITES_BITS_AVERSION_DATA 32 #define XINFO_AXILITES_ADDR_AVERSION_CTRL 0x14 #define XINFO_AXILITES_ADDR_BSUBVERSION_DATA 0x18 #define XINFO_AXILITES_BITS_BSUBVERSION_DATA 32 #define XINFO_AXILITES_ADDR_BSUBVERSION_CTRL 0x1c #define XINFO_AXILITES_ADDR_CTYPEBOARD_DATA 0x20 #define XINFO_AXILITES_BITS_CTYPEBOARD_DATA 32 #define XINFO_AXILITES_ADDR_CTYPEBOARD_CTRL 0x24</span></span></code> </pre><br>  Este archivo describe las direcciones de los registros, los registros corresponden a la ubicación de los argumentos en la función.  Después de la síntesis del proyecto, puede ver cómo se ejecutará el proyecto creado en ciclos. <br><br><img src="https://habrastorage.org/webt/lj/jw/na/ljjwnalfpfgcsi4yindklhqvowe.png"><br>  <i>Proyecto Beat Ejemplo</i> <br><br>  Trabajar con hls ha demostrado que esta herramienta es adecuada para resolver tareas rápidamente, especialmente se ha demostrado para resolver problemas matemáticos de visión por computadora, que se pueden describir fácilmente en C ++ o C, así como para crear pequeños núcleos de IP para interacciones e intercambios información con interfaces FPGA estándar. <br><br>  Al mismo tiempo, HLS no es adecuado para implementar interfaces de hardware específicas, por ejemplo, en nuestro caso fue I2S, y el código rtl generado ocupa más espacio en FPGA que el escrito en lenguajes hdl estándar. <br><br>  El último paso en la prueba de controladores es el desarrollo de un generador de tráfico I2S.  Este ip-core repite la funcionalidad de los núcleos ip anteriores, excepto que genera datos incrementales (tráfico) que corresponden a datos I2S reales en modo TDM. <br><br><img src="https://habrastorage.org/webt/vc/81/xz/vc81xzbieylxtzhrp6lz-psikva.png"><br>  <i>Diseño de bloques para futuras pruebas de núcleo I2S personalizadas y generador de tráfico I2S</i> <br><br>  Como resultado, obtuvimos los resultados de hls, axi dma y s_axilite, verificamos el rendimiento de nuestro software y controladores. <br><br><h2>  Conclusiones </h2><br>  Logramos desarrollar los tipos necesarios de tarjetas de interfaz, así como los núcleos ip para tdm, pri, bri.  Hemos mejorado significativamente el enfoque actual para el desarrollo de dichos dispositivos y hemos creado una solución integral que puede competir con placas de interfaz similares de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asterick</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Patton</a> y otros.  La ventaja de nuestra solución es que el desarrollador no necesita un enlace intermedio entre la PC y el PCI para la transferencia de datos, podrá transmitir directamente la información recibida a través de Ethernet. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415435/">https://habr.com/ru/post/es415435/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415423/index.html">Infraestructura de clave pública: Autoridad de certificación basada en OpenSSL y SQLite3 Utility (Postcryptum)</a></li>
<li><a href="../es415427/index.html">Toda la verdad sobre RTOS de Colin Walls. Artículo # 4. Tareas, cambio de contexto e interrupciones</a></li>
<li><a href="../es415429/index.html">Toda la verdad sobre RTOS de Colin Walls. Artículo # 5. Interacción de tareas y sincronización</a></li>
<li><a href="../es415431/index.html">Anuncio de Hackathon SmartMail Hack 2: Llamada de datos</a></li>
<li><a href="../es415433/index.html">Gestión de lanzamientos de viviendas y servicios comunitarios de SIG: compartimos experiencia y luchamos con intuición</a></li>
<li><a href="../es415437/index.html">Cómo lanzar ML en prod: seis rastrillos que pisamos</a></li>
<li><a href="../es415439/index.html">¿La comunicación corporativa te obliga a abandonar o arrastrarte a un proyecto como un juego?</a></li>
<li><a href="../es415441/index.html">Los ataques de ransomware contra agencias gubernamentales están creciendo en los EE. UU.</a></li>
<li><a href="../es415443/index.html">MDG e ITMO University invitan a la Escuela de Verano de Machine Learning</a></li>
<li><a href="../es415445/index.html">El resumen de eventos para profesionales de recursos humanos en el campo de TI para julio de 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>