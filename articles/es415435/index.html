<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úîÔ∏è üêô üôèüèæ Desarrollo de tarjetas de interfaz en Soil Xilinx Zynq 7000 para grabaci√≥n de voz en formato anal√≥gico y digital üåÅ üòì ü§∏üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, compartiremos nuestra experiencia en el desarrollo de tarjetas de interfaz de la unidad de interfaz basada en SoC ARM + FPGA Xilinx ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de tarjetas de interfaz en Soil Xilinx Zynq 7000 para grabaci√≥n de voz en formato anal√≥gico y digital</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415435/"><img src="https://habrastorage.org/webt/rg/2_/55/rg2_55mpm_gc8ip2vlemo9tel9k.jpeg"><br><br>  En este art√≠culo, compartiremos nuestra experiencia en el desarrollo de tarjetas de interfaz de la unidad de interfaz basada en SoC ARM + FPGA Xilinx Zynq 7000. Las placas se dise√±aron para grabar se√±ales de voz en formato PRI / BRI anal√≥gico y digital (ISDN, E1 / T1).  El dispositivo final en s√≠ se utilizar√° para registrar las negociaciones en la aviaci√≥n civil. <br><a name="habracut"></a><br><h2>  Hierro: selecci√≥n de plataforma de hardware del dispositivo </h2><br>  La elecci√≥n de la plataforma de hardware fue determinada por el soporte de los protocolos PRI / BRI, que solo se pueden implementar en el lado de FPGA.  Los microcontroladores (MCU) y los microprocesadores (MPU) no encajaban. <br><br>  Se podr√≠an elegir dos soluciones a este problema: <br><br><ol><li>  S√≠ntesis del n√∫cleo de Microblaze IP </li><li>  SoC Zynq-7000. </li></ol><br>  Nos instalamos en un sistema en un chip Zynq 7000 (SoC), porque  es m√°s f√°cil escribir aplicaciones de software y proporciona m√°s funcionalidad para tareas actuales y futuras. <br><br>  En total, se recopil√≥ la siguiente lista de hierro en el marco del proyecto: <br><br>  <b>1.Xilinx Zynq 7020</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mars-ZX3</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mars EB1</a> ) <br><img src="https://habrastorage.org/webt/ls/g9/4w/lsg94w0qj20bxkf5t8k2gzvzx1e.jpeg"><br>  <i>Enclustra Mars ZX3 SOM</i> <br><img src="https://habrastorage.org/webt/ft/z3/4t/ftz34tc8zkk-9gddjcx2atmufc8.jpeg"><br>  <i>Enclustra Mars EB1 Baseboard</i> <br><br>  <b>2. TI TLV320AIC34</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tlv320aic34evm-k</a> y placa base USB). <br><br><img src="https://habrastorage.org/webt/3z/ls/g-/3zlsg-yry1k4e4qyqu1g-o0xt4a.jpeg"><br>  <i>Tarjeta de depuraci√≥n para tlv320aic34 (tlv320aic34evm-k)</i> <br><br><img src="https://habrastorage.org/webt/pb/mk/84/pbmk84mawx1rbpmqreghow9fjim.jpeg"><br>  <i>Tarjeta de expansi√≥n USB-MODEVM para tlv320aic34evm-k</i> <br><br>  <b>3. IDT82P2288 - PRI, XHFC-4SU - Microcircuitos BRI,</b> no hab√≠a kits de depuraci√≥n, por lo tanto, solo sentamos las bases como un n√∫cleo ip para las pruebas, y el bautismo de fuego ocurri√≥ justo en el proceso, despu√©s de hacer placas prototipo. <br><br><h2>  Trabaje con el sistema en el chip Xilinx Zynq 7000 </h2><br><br><img src="https://habrastorage.org/webt/t5/2n/ka/t52nkauzukagn0mp_aruobwjigm.png"><br>  <i>La estructura interna del SoC Xilinx Zynq 7000</i> <br><br><img src="https://habrastorage.org/webt/u9/nn/nl/u9nnnlwp0nib8s4td2drrorqm54.png"><br>  <i>Pasos para generar archivos de arranque para Xilinx Zynq</i> <br><br>  Parpadear / descargar ejecutables para Zynq es diferente de la descarga habitual para MPU.  El trabajo habitual con los procesadores Cortex-A es cargar u-boot, kernel linux, rootfs.  Y en Zynq, aparece Bitstream, el archivo de firmware para FPGA.  El flujo de bits contiene una descripci√≥n de los bloques de hardware en el FPGA y la comunicaci√≥n interna con el procesador.  Este archivo se carga al iniciar el sistema.  Tambi√©n en el lado de Linux hay un mecanismo que le permite flashear la parte PL inmediatamente durante la operaci√≥n, dicho dispositivo se llama xdevcfg ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">administrador FPGA ZYNQ desde 2018.1</a> ). <br><br><h2>  Interfaces PRI / BRI </h2><br><img src="https://habrastorage.org/webt/om/zo/dr/omzodrzsfz9d5oqyo-ukvvsozve.jpeg"><br>  <i>Caracter√≠sticas de las redes digitales PRI / BRI</i> <br><br>  La interfaz de velocidad primaria (PRI) es una interfaz de red ISDN est√°ndar que define la disciplina de conectar estaciones ISDN a troncales de banda ancha que conectan centrales locales o centrales o conmutadores de red. <br><br><img src="https://habrastorage.org/webt/_5/p0/5k/_5p05km2btytoe7ptkdrfuz_-8o.png"><br>  <i>Tipo de trama transmitida para PRI</i> <br><br><img src="https://habrastorage.org/webt/rp/ux/hd/rpuxhdxujlk8c2cnxxgdga74-tk.png"><br>  <i>Vista de la trama transmitida para BRI</i> <br><br><img src="https://habrastorage.org/webt/-i/1c/90/-i1c90_mrzspj2jhrog9akk_u4g.png"><br>  <i>La estructura interna de la f√≠sica del PRI - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IDT82P2288</a></i> <br><br><img src="https://habrastorage.org/webt/ca/iv/s5/caivs5jr2frxcu_xiign_my2db8.png"><br>  <i>La estructura interna de la f√≠sica BRI - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">XHFC-4SU</a></i> <br><br><h2>  C√≥dec de audio TLV320AIC34 </h2><br>  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥dec de audio TLV320AIC34 de</a> baja potencia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuatro canales</a> para audio y telefon√≠a port√°til es una buena soluci√≥n para su uso en telefon√≠a anal√≥gica. <br><br><img src="https://habrastorage.org/webt/7i/7g/lr/7i7glrlam_fmxm2inkwcgqinrl8.png"><br>  <i>Tlv320aic34 Parte A, el c√≥dec de audio contiene dos bloques de funciones</i> <br><br>  Los datos pueden transmitirse a trav√©s de la interfaz I2S, as√≠ como a trav√©s de DSP, PCM, TDM. <br><br>  I2S es un est√°ndar de interfaz de bus serie, se utiliza para conectar dispositivos de audio digital y representa el√©ctricamente 3 conductores que van de un dispositivo activo a uno pasivo, as√≠ como 4 se√±ales que corresponden a ellos de la siguiente manera: <br><br><ol><li>  Bit Clock (BCLK). </li><li>  Marco de se√±al de reloj (seg√∫n palabras) sincronizaci√≥n (WCLK). </li><li>  Se√±al de datos que puede transmitir o recibir 2 canales divididos en el tiempo (DIN / DOUT). </li></ol><br>  Los canales para recibir y transmitir datos est√°n divididos, es decir, hay un canal separado para recibir datos y un canal para la transmisi√≥n.  El controlador recibe los datos transmitidos por el c√≥dec de audio, pero tambi√©n es posible lo contrario. <br><br><img src="https://habrastorage.org/webt/p5/op/th/p5opthpov06xstxalowbqz_emt8.png"><br>  <i>Marco I2S, caracter√≠sticas de la interfaz I2S</i> <br><br>  Despu√©s de seleccionar todos los componentes de hardware, resolvimos el problema de conectar el c√≥dec de audio y Xilinx Zynq 7020. <br><br><h2>  Buscar n√∫cleos I2S </h2><br>  Probablemente el momento m√°s dif√≠cil al trabajar con la transmisi√≥n de audio en el Xilinx Zynq 7020 fue que en la parte del procesador de este sistema b√°sicamente no hay bus I2S en el chip, por lo que tuve que encontrar el n√∫cleo I2S.  Esta tarea se complic√≥ por la condici√≥n de que el n√∫cleo de ip deber√≠a estar libre. <br><br>  Nos decidimos por varios n√∫cleos ip.  Encontrado para el n√∫cleo de metal desnudo I2S <b>Digilent</b> .  Encontramos varios n√∫cleos de IP en n√∫cleos <b>abiertos</b> y, probablemente, la mejor opci√≥n para nosotros es el n√∫cleo de ip de <b>Analog Devices</b> .  Producen n√∫cleos ip para sus equipos, para la interacci√≥n FPGA / FPGA. <br><br>  Estamos interesados ‚Äã‚Äãen el ip-core llamado <b>AXI-I2S-ADI.</b>  Analog Devices est√° promoviendo estos n√∫cleos ip para sus plataformas de hardware. <br><br>  Lista total de casos de uso: <br><br><ol><li>  Metal desnudo: n√∫cleo IP para I2S (audio Digilent ZYBO) </li><li>  opencores.org </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Controlador AXI-I2S-ADI</a> (dispositivos anal√≥gicos) </li></ol><br><h3>  N√∫cleo IP AXI-I2S-ADI </h3><br>  El n√∫cleo de ip en s√≠ se ve as√≠: tiene las l√≠neas bclk, wclk, din, dout.  Se conecta al DMA Xilinx Zynq 7000, en nuestro ejemplo, se utiliza la parte DMA PS.  Todo el intercambio de datos ocurre a trav√©s de DMA.  DMA puede ser una unidad independiente o una parte integral de PS SoC. <br><br>  Al configurar este kernel ip, es importante no olvidar enviar la frecuencia maestra mclk a tlv320aic34, como una opci√≥n al usar el kit de depuraci√≥n para tlv320aic34: enviar una frecuencia maestra externa. <br><br><img src="https://habrastorage.org/webt/i8/xn/z4/i8xnz4rijta_07gc1zgc2a8vfxc.png"><br>  <i>Bloque de funciones con axi-i2s-adi conectado</i> <br><br>  Despu√©s del procedimiento de configuraci√≥n, la tarea consist√≠a en iniciar la funcionalidad en el sistema operativo Linux. <br><br><h2>  Inicie y configure el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rbol de dispositivos</a> para tlv320aic34 </h2><br>  Configuraci√≥n de i2c (tlv320aic34 est√° configurado en esta interfaz): <br><br><pre><code class="cpp hljs">i2c0: i2c@e0004000 { ... tlv320aic3x: tlv320aic3x@<span class="hljs-number"><span class="hljs-number">18</span></span> { <span class="hljs-meta"><span class="hljs-meta">#sound-dai-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;0&gt;; compatible = "ti,tlv320aic3x"; reg = &lt;0x18&gt;; gpio-reset = &lt;&amp;axi_gpio_0 0 0&gt;; ai3x-gpio-func = &lt;&amp;axi_gpio_0 1 0&gt;, /* AIC3X_GPIO1_FUNC_DISABLED */ &lt;&amp;axi_gpio_0 2 0&gt;; /* AIC3X_GPIO2_FUNC_DIGITAL_MIC_INPUT */ AVDD-supply = &lt;&amp;vmmc2&gt;; DRVDD-supply = &lt;&amp;vmmc2&gt;; IOVDD-supply = &lt;&amp;vmmc2&gt;; DVDD-supply = &lt;&amp;vmmc2&gt;; ai3x-micbias-vg = &lt;1&gt;; }; ... };</span></span></span></span></code> </pre> <br>  Configuraci√≥n de i2s (los datos de audio se transmiten a trav√©s de esta interfaz): <br><br><pre> <code class="cpp hljs">i2s_clk: i2s_clk { <span class="hljs-meta"><span class="hljs-meta">#clock-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;0&gt;; compatible = "fixed-clock"; clock-frequency = &lt;11289600&gt;; clock-output-names = "i2s_clk"; }; axi_i2s_adi_0: axi_i2s_adi@43C00000 { compatible = "adi,axi-i2s-1.00.a"; reg = &lt;0x43C00000 0x1000&gt;; xlnx,bclk-pol = &lt;0x0&gt;; xlnx,dma-type = &lt;0x1&gt;; xlnx,has-rx = &lt;0x1&gt;; xlnx,has-tx = &lt;0x1&gt;; xlnx,lrclk-pol = &lt;0x0&gt;; xlnx,num-ch = &lt;0x1&gt;; xlnx,s-axi-min-size = &lt;0x000001FF&gt;; xlnx,slot-width = &lt;0x18&gt;; }; &amp;axi_i2s_adi_0 { #sound-dai-cells = &lt;0&gt;; compatible = "adi,axi-i2s-1.00.a"; clocks = &lt;&amp;clkc 15&gt;, &lt;&amp;i2s_clk&gt;; clock-names = "axi", "ref"; dmas = &lt;&amp;dmac_s 0 &amp;dmac_s 1&gt;; dma-names = "tx", "rx"; };</span></span></span></span></code> </pre> <br>  Configuraci√≥n de la tarjeta de sonido en el √°rbol de dispositivos (tarjetas de audio): <br><br><pre> <code class="cpp hljs"> sound { compatible = <span class="hljs-string"><span class="hljs-string">"simple-audio-card"</span></span>; simple-audio-card,name = <span class="hljs-string"><span class="hljs-string">"TLV320AIC34"</span></span>; simple-audio-card,format = <span class="hljs-string"><span class="hljs-string">"i2s"</span></span>; simple-audio-card,bitclock-master = &lt;&amp;dailink0_master&gt;; simple-audio-card,frame-master = &lt;&amp;dailink0_master&gt;; simple-audio-card,widgets = ... simple-audio-card,routing = ... dailink0_master: simple-audio-card,cpu { clocks = &lt;&amp;i2s_clk&gt;; sound-dai = &lt;&amp;axi_i2s_adi_0&gt;; }; simple-audio-card,codec { clocks = &lt;&amp;i2s_clk&gt;; sound-dai = &lt;&amp;tlv320aic3x&gt;; }; }; };</code> </pre> <br>  Despu√©s de todas las manipulaciones para configurar y configurar el c√≥dec en el √°rbol de dispositivos en Linux, apareci√≥ la codiciada tarjeta de audio y pudimos escuchar m√∫sica (nuestra primera pista de m√∫sica fue Highway to Hell, AC / DC). <br><br>  Esto es lo que tuvimos que hacer para esto: <br><br><ul><li>  Gener√≥ la frecuencia necesaria usando clk_wiz (asistente de sincronizaci√≥n) </li><li>  DTS configurado correctamente para tlv320aic34 </li><li>  Soporte agregado para el controlador tlv320aic3x </li><li>  Se agregaron paquetes de audio a buildroot para reproducir audio (aplay, madplay, etc.) </li></ul><br>  En el proceso de desarrollo del dispositivo final, nos enfrentamos a la tarea de conectar 4 microcircuitos tlv320aic34.  El chip tlv320aic34 descrito anteriormente contiene 2 bloques para trabajar con la transmisi√≥n de audio, cada bloque tiene su propia l√≠nea i2c para configurar y configurar los par√°metros de audio.  Un bloque puede tener solo cuatro direcciones, respectivamente, es imposible conectar cuatro microcircuitos tlv320aic34 a una interfaz i2c, debe usar dos interfaces i2c (8 bloques de audio independientes).  Para cada bloque, si inicia mclk, blck, wclk, din / dout individualmente, debe agregar 40 l√≠neas de se√±al en total, lo cual es imposible e irracional desde el punto de vista del circuito para el m√≥dulo som que elegimos, porque adem√°s de estas se√±ales, ten√≠a que conectar muchas otras l√≠neas y interfaces <br><br>  Como resultado, decidimos cambiar la tarjeta de audio al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modo TDM</a> , en el que se combinan todas las l√≠neas mclk, bclk, din, dout, lo que reduce el n√∫mero total de l√≠neas de comunicaci√≥n.  Esta decisi√≥n afect√≥ la operaci√≥n de axi-i2s-adi, debido al hecho de que el n√∫cleo de ip funcionaba en modo maestro.  Adem√°s, este cambio no nos permiti√≥ usar nuestro ip-core en modo TDM, y una decisi√≥n decidida fue abandonar el uso del ip-core seleccionado.  Tuve que escribir un kernel ip para escuchar el tr√°fico de i2s y enviarlo a dma, esta soluci√≥n nos permiti√≥ crear una interfaz com√∫n para recibir datos que no depender√≠a del tipo de tarjeta para grabar llamadas (tarjetas anal√≥gicas y digitales). <br><br>  La arquitectura inicial para recibir la transmisi√≥n de audio y su procesamiento a trav√©s de la interfaz i2s: <br><br><img src="https://habrastorage.org/webt/yn/24/2d/yn242d_8cm4kazs2ycwceevqqe8.jpeg"><br><br>  La arquitectura final para recibir la transmisi√≥n de audio y su procesamiento a trav√©s de la interfaz i2s: <br><br><img src="https://habrastorage.org/webt/mz/py/dt/mzpydtgravupatvivp_zmpiitig.jpeg"><br><br>  Arquitectura de recibir un flujo PRI y su procesamiento: <br><br><img src="https://habrastorage.org/webt/qx/ee/7w/qxee7wt1mdazgm0tu0eukbm5rmy.jpeg"><br><br>  Arquitectura de recepci√≥n y procesamiento de secuencias BRI: <br><br><img src="https://habrastorage.org/webt/wd/uf/ny/wdufnykenpfxgwyhrnr3x6ep2kg.jpeg"><br><br><h2>  Axi dma </h2><br>  Este es un elemento importante del sistema de sincronizaci√≥n de datos para dma. <br><br><img src="https://habrastorage.org/webt/v7/fx/pk/v7fxpk_3eemrqnlmy3iejsjrup4.png"><br>  <i>Ventana de configuraci√≥n de AXI DMA en Xilinx Vivado</i> <br><br>  En la pantalla de impresi√≥n, se presenta el bloque AXI DMA.  Tiene muchos par√°metros.  Puede configurar en el bus la cantidad de datos a transferir.  Los datos se pueden alinear o en cualquier formato.  Una descripci√≥n detallada de la operaci√≥n e interacci√≥n con axi dma se describe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la documentaci√≥n t√©cnica</a> (de una versi√≥n a otra hay una adici√≥n y correcci√≥n de imprecisiones en la descripci√≥n, as√≠ como el refinamiento de los n√∫cleos ip). <br><br><h2>  Verifique la transferencia de datos a trav√©s de las opciones de prueba AXI DMA, AXI DMA </h2><br>  Al desarrollar el controlador, decidimos buscar c√≥digo abierto y adaptarlo a nuestra tarea.  Como resultado, elegimos las fuentes del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto github ezdma</a> (juego de palabras, leer como dma f√°cil). <br><br>  El siguiente paso es el desarrollo de un controlador de prueba, fue una etapa preparatoria antes del momento en que nos lleg√≥ un n√∫cleo de ip con funcionalidad preparada del departamento de desarrollo de FPGA (el proceso de desarrollo descrito fue formado por programadores integrados).  Antes de este momento, decidimos tomar AXI DMA, AXI DATA FIFO y hacer un loopback para asegurarnos de futuros errores.  Enrollamos el env√≠o y la recepci√≥n de datos, por lo que verificamos el resultado de nuestro trabajo y el rendimiento de nuestro controlador.  Adaptamos un poco la funcionalidad, la adaptamos a nuestros deseos en la interfaz de interacci√≥n y una vez m√°s verificamos la operatividad del controlador y el principio de interacci√≥n seleccionado. <br><br><img src="https://habrastorage.org/webt/iw/si/uj/iwsiujsbv1tckuamu1lsjalzrao.png"><br>  <i>Dise√±o de bloque retrospectivo, la primera forma de probar AXI DMA</i> <br><br>  Un ejemplo de una descripci√≥n de DMA y ezdma en un √°rbol de dispositivos: <br><br><pre> <code class="cpp hljs">/ { amba_pl: amba_pl { <span class="hljs-meta"><span class="hljs-meta">#address-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;1&gt;; #size-cells = &lt;1&gt;; compatible = "simple-bus"; ranges ; axi_dma_1: axi_dma { #dma-cells = &lt;1&gt;; compatible = "xlnx,axi-dma-1.00.a"; reg = &lt;0x40400000 0x10000&gt;; clock-names = "s_axi_lite_aclk", "m_axi_sg_aclk", "m_axi_mm2s_aclk", "m_axi_s2mm_aclk"; clocks = &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;; interrupt-parent = &lt;&amp;intc&gt;; interrupts = &lt;0 29 4 0 30 4&gt;; xlnx,addrwidth = &lt;0x20&gt;; xlnx,include-sg; dma-channel@40400000 { compatible = "xlnx,axi-dma-mm2s-channel"; dma-channels = &lt;0x1&gt;; interrupts = &lt;0 29 4&gt;; xlnx,datawidth = &lt;0x20&gt;; xlnx,device-id = &lt;0x0&gt;; xlnx,include-dre ; }; dma-channel@40400030 { compatible = "xlnx,axi-dma-s2mm-channel"; dma-channels = &lt;0x1&gt;; interrupts = &lt;0 30 4&gt;; xlnx,datawidth = &lt;0x20&gt;; xlnx,device-id = &lt;0x0&gt;; xlnx,include-dre ; }; }; ezdma0 { compatible = "ezdma"; dmas = &lt;&amp;axi_dma_1 0 &amp;axi_dma_1 1&gt;; dma-names = "loop_tx", "loop_rx"; // used when obtaining reference to above DMA core using dma_request_slave_channel() ezdma,dirs = &lt;2 1&gt;; // direction of DMA channel: 1 = RX (dev-&gt;cpu), 2 = TX (cpu-&gt;dev) }; ... }; };</span></span></span></span></code> </pre> <br>  Puede generar f√°cilmente archivos dts / dtsi utilizando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta Device Tree Generator</a> . <br><br>  El segundo paso en nuestro proceso de desarrollo es la creaci√≥n de un kernel ip de prueba para verificar el rendimiento del controlador, solo que esta vez los datos ser√°n significativos, con la transferencia a trav√©s de AXIS a AXI_DMA (como lo estar√° en la versi√≥n final del kernel ip). <br><br><img src="https://habrastorage.org/webt/uc/nc/iz/ucncizx2gwl3am9mxz5iursdy1q.png"><br>  <i>Flujo de trabajo de la interfaz AXIS</i> <br><br>  Implementamos dos variantes de n√∫cleos ip para la generaci√≥n de datos, la primera versi√≥n probada se implementa a trav√©s de verilog, la segunda, en HLS (en este contexto, HLS apareci√≥ bajo el lema "estilo-moda-juventud"). <br><br>  El generador de datos verilog (y generalmente en los idiomas de la familia hdl: verilog, vhdl, etc.) es una soluci√≥n est√°ndar cuando se desarrollan n√∫cleos ip de este tipo.  Aqu√≠ hay algunos fragmentos de c√≥digo para el n√∫cleo de IP intermedio: <br><br><pre> <code class="hljs sql">module GenCnt ( ‚Ä¶. assign HandsHake = m_axis_din_tready &amp; m_axis_dout_tvalid; always @(posedge Clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Rst) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sIDLE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (smCnt) sIDLE: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sDATA; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> sDATA: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Cnt == cTopCnt - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sLAST; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... endmodule</code> </pre> <br>  No hay necesidad de una descripci√≥n m√°s detallada, ya que esta es una tarea t√≠pica de un dise√±ador de FPGA. <br><br>  Una "bestia" m√°s interesante aqu√≠ es HLS.  <b>Vivado HLS (High Level Synthesis)</b> es el nuevo software Xilinx CAD para crear dispositivos digitales que utilizan lenguajes de alto nivel como OpenCL, C o C ++. <br><br>  C / C ++ son los lenguajes principales para un ingeniero de software integrado, por lo que resolver un problema usando estos lenguajes es m√°s interesante en t√©rminos de implementaci√≥n y an√°lisis comparativo para proyectos futuros. <br><br>  Aqu√≠ hay dos peque√±os ejemplos de trabajo con HLS.  El primer ejemplo es un generador de datos para AXI_DMA, el segundo ejemplo es el intercambio de datos entre la parte del procesador y la l√≥gica programable a trav√©s de la interfaz s_axilite. <br><br>  El intercambio de datos a trav√©s de la interfaz s_axilite (el segundo ejemplo) se implement√≥ para que en cualquier momento en procfs fuera posible restar qu√© bitstream estaba cargado, y para que fuera posible rastrear la correcci√≥n del trabajo versionando para la parte PL del SoC.  Aqu√≠ aparece un punto muy interesante con s_axilite: Vivado HLS genera un controlador para Linux (el controlador, a su vez, nos adaptamos para trabajar a trav√©s de procesos para preservar la herencia de la escritura).  A continuaci√≥n se muestra un ejemplo del c√≥digo generado para Linux (la ruta a la soluci√≥n de origen1 / impl / ip / drivers / name_xxx / src /). <br><br><img src="https://habrastorage.org/webt/ss/kd/rh/sskdrh3olokqp7miv9qm-ni1gnq.png"><br>  <i>Etapas de s√≠ntesis HLS y generaci√≥n de c√≥digo rtl</i> <br><br>  Generador de datos HLS para verificar la operaci√≥n con AXI_DMA: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ap_axi_sdata.h&gt; #include &lt;hls_stream.h&gt; #define SIZE_STREAM 1024 struct axis { int tdata; bool tlast; }; void data_generation(axis outStream[SIZE_STREAM]) { #pragma HLS INTERFACE axis port=outStream int i = 0; do{ outStream[i].tdata = i; outStream[i].tlast = (i == (SIZE_STREAM - 1)) ? 1 : 0; i++; }while( i &lt; SIZE_STREAM); }</span></span></span></span></code> </pre> <br>  Un ejemplo de obtenci√≥n de versiones y tipo de placa de interfaz: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; void info( int &amp;aVersion, int &amp;bSubVersion, int &amp;cTypeBoard, int version, int subVersion, int typeBoard ){ #pragma HLS INTERFACE s_axilite port=aVersion #pragma HLS INTERFACE s_axilite port=bSubVersion #pragma HLS INTERFACE s_axilite port=cTypeBoard #pragma HLS INTERFACE ap_ctrl_none port=return aVersion = version; bSubVersion = subVersion; cTypeBoard = typeBoard; }</span></span></span></span></code> </pre> <br>  Como not√≥, para el desarrollo en hls es muy importante comprender el trabajo y la aplicaci√≥n de varios pragmas (pragma HLS), ya que el proceso de s√≠ntesis est√° directamente relacionado con los pragmas. <br><br>  Controlador generado para s_axilita: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ============================================================== // File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC // Version: 2016.4 // Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved. // // ============================================================== #ifdef __linux__ /***************************** Include Files *********************************/ #include "xinfo.h" /***************** Macros (Inline Functions) Definitions *********************/ #define MAX_UIO_PATH_SIZE 256 #define MAX_UIO_NAME_SIZE 64 #define MAX_UIO_MAPS 5 #define UIO_INVALID_ADDR 0 /**************************** Type Definitions ******************************/ typedef struct { u32 addr; u32 size; } XInfo_uio_map; typedef struct { int uio_fd; int uio_num; char name[ MAX_UIO_NAME_SIZE ]; char version[ MAX_UIO_NAME_SIZE ]; XInfo_uio_map maps[ MAX_UIO_MAPS ]; } XInfo_uio_info; /***************** Variable Definitions **************************************/ static XInfo_uio_info uio_info; /************************** Function Implementation *************************/ static int line_from_file(char* filename, char* linebuf) { char* s; int i; FILE* fp = fopen(filename, "r"); if (!fp) return -1; s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp); fclose(fp); if (!s) return -2; for (i=0; (*s)&amp;&amp;(i&lt;MAX_UIO_NAME_SIZE); i++) { if (*s == '\n') *s = 0; s++; } return 0; } static int uio_info_read_name(XInfo_uio_info* info) { char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/name", info-&gt;uio_num); return line_from_file(file, info-&gt;name); } static int uio_info_read_version(XInfo_uio_info* info) { char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/version", info-&gt;uio_num); return line_from_file(file, info-&gt;version); } static int uio_info_read_map_addr(XInfo_uio_info* info, int n) { int ret; char file[ MAX_UIO_PATH_SIZE ]; info-&gt;maps[n].addr = UIO_INVALID_ADDR; sprintf(file, "/sys/class/uio/uio%d/maps/map%d/addr", info-&gt;uio_num, n); FILE* fp = fopen(file, "r"); if (!fp) return -1; ret = fscanf(fp, "0x%x", &amp;info-&gt;maps[n].addr); fclose(fp); if (ret &lt; 0) return -2; return 0; } static int uio_info_read_map_size(XInfo_uio_info* info, int n) { int ret; char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/maps/map%d/size", info-&gt;uio_num, n); FILE* fp = fopen(file, "r"); if (!fp) return -1; ret = fscanf(fp, "0x%x", &amp;info-&gt;maps[n].size); fclose(fp); if (ret &lt; 0) return -2; return 0; } int XInfo_Initialize(XInfo *InstancePtr, const char* InstanceName) { XInfo_uio_info *InfoPtr = &amp;uio_info; struct dirent **namelist; int i, n; char* s; char file[ MAX_UIO_PATH_SIZE ]; char name[ MAX_UIO_NAME_SIZE ]; int flag = 0; assert(InstancePtr != NULL); n = scandir("/sys/class/uio", &amp;namelist, 0, alphasort); if (n &lt; 0) return XST_DEVICE_NOT_FOUND; for (i = 0; i &lt; n; i++) { strcpy(file, "/sys/class/uio/"); strcat(file, namelist[i]-&gt;d_name); strcat(file, "/name"); if ((line_from_file(file, name) == 0) &amp;&amp; (strcmp(name, InstanceName) == 0)) { flag = 1; s = namelist[i]-&gt;d_name; s += 3; // "uio" InfoPtr-&gt;uio_num = atoi(s); break; } } if (flag == 0) return XST_DEVICE_NOT_FOUND; uio_info_read_name(InfoPtr); uio_info_read_version(InfoPtr); for (n = 0; n &lt; MAX_UIO_MAPS; ++n) { uio_info_read_map_addr(InfoPtr, n); uio_info_read_map_size(InfoPtr, n); } sprintf(file, "/dev/uio%d", InfoPtr-&gt;uio_num); if ((InfoPtr-&gt;uio_fd = open(file, O_RDWR)) &lt; 0) { return XST_OPEN_DEVICE_FAILED; } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> slave interface 'Axilites' should be mapped to uioX/map0 InstancePtr-&gt;Axilites_BaseAddress = (u32)mmap(NULL, InfoPtr-&gt;maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr-&gt;uio_fd, 0 * getpagesize()); assert(InstancePtr-&gt;Axilites_BaseAddress); InstancePtr-&gt;IsReady = XIL_COMPONENT_IS_READY; return XST_SUCCESS; } int XInfo_Release(XInfo *InstancePtr) { XInfo_uio_info *InfoPtr = &amp;uio_info; assert(InstancePtr != NULL); assert(InstancePtr-&gt;IsReady == XIL_COMPONENT_IS_READY); munmap((void*)InstancePtr-&gt;Axilites_BaseAddress, InfoPtr-&gt;maps[0].size); close(InfoPtr-&gt;uio_fd); return XST_SUCCESS; } #endif</span></span></code> </pre> <br>  Un archivo importante que le indica la ubicaci√≥n de las variables (registros) en el espacio de direcciones es el archivo x # your_name # _hw.h.  Siempre puede verificar la correcci√≥n del n√∫cleo de IP escrito utilizando la herramienta devmem. <br><br>  El contenido de este archivo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ============================================================== // File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC // Version: 2016.4 // Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved. // // ============================================================== // AXILiteS // 0x00 : reserved // 0x04 : reserved // 0x08 : reserved // 0x0c : reserved // 0x10 : Data signal of aVersion // bit 31~0 - aVersion[31:0] (Read) // 0x14 : Control signal of aVersion // bit 0 - aVersion_ap_vld (Read/COR) // others - reserved // 0x18 : Data signal of bSubVersion // bit 31~0 - bSubVersion[31:0] (Read) // 0x1c : Control signal of bSubVersion // bit 0 - bSubVersion_ap_vld (Read/COR) // others - reserved // 0x20 : Data signal of cTypeBoard // bit 31~0 - cTypeBoard[31:0] (Read) // 0x24 : Control signal of cTypeBoard // bit 0 - cTypeBoard_ap_vld (Read/COR) // others - reserved // (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake) #define XINFO_AXILITES_ADDR_AVERSION_DATA 0x10 #define XINFO_AXILITES_BITS_AVERSION_DATA 32 #define XINFO_AXILITES_ADDR_AVERSION_CTRL 0x14 #define XINFO_AXILITES_ADDR_BSUBVERSION_DATA 0x18 #define XINFO_AXILITES_BITS_BSUBVERSION_DATA 32 #define XINFO_AXILITES_ADDR_BSUBVERSION_CTRL 0x1c #define XINFO_AXILITES_ADDR_CTYPEBOARD_DATA 0x20 #define XINFO_AXILITES_BITS_CTYPEBOARD_DATA 32 #define XINFO_AXILITES_ADDR_CTYPEBOARD_CTRL 0x24</span></span></code> </pre><br>  Este archivo describe las direcciones de los registros, los registros corresponden a la ubicaci√≥n de los argumentos en la funci√≥n.  Despu√©s de la s√≠ntesis del proyecto, puede ver c√≥mo se ejecutar√° el proyecto creado en ciclos. <br><br><img src="https://habrastorage.org/webt/lj/jw/na/ljjwnalfpfgcsi4yindklhqvowe.png"><br>  <i>Proyecto Beat Ejemplo</i> <br><br>  Trabajar con hls ha demostrado que esta herramienta es adecuada para resolver tareas r√°pidamente, especialmente se ha demostrado para resolver problemas matem√°ticos de visi√≥n por computadora, que se pueden describir f√°cilmente en C ++ o C, as√≠ como para crear peque√±os n√∫cleos de IP para interacciones e intercambios informaci√≥n con interfaces FPGA est√°ndar. <br><br>  Al mismo tiempo, HLS no es adecuado para implementar interfaces de hardware espec√≠ficas, por ejemplo, en nuestro caso fue I2S, y el c√≥digo rtl generado ocupa m√°s espacio en FPGA que el escrito en lenguajes hdl est√°ndar. <br><br>  El √∫ltimo paso en la prueba de controladores es el desarrollo de un generador de tr√°fico I2S.  Este ip-core repite la funcionalidad de los n√∫cleos ip anteriores, excepto que genera datos incrementales (tr√°fico) que corresponden a datos I2S reales en modo TDM. <br><br><img src="https://habrastorage.org/webt/vc/81/xz/vc81xzbieylxtzhrp6lz-psikva.png"><br>  <i>Dise√±o de bloques para futuras pruebas de n√∫cleo I2S personalizadas y generador de tr√°fico I2S</i> <br><br>  Como resultado, obtuvimos los resultados de hls, axi dma y s_axilite, verificamos el rendimiento de nuestro software y controladores. <br><br><h2>  Conclusiones </h2><br>  Logramos desarrollar los tipos necesarios de tarjetas de interfaz, as√≠ como los n√∫cleos ip para tdm, pri, bri.  Hemos mejorado significativamente el enfoque actual para el desarrollo de dichos dispositivos y hemos creado una soluci√≥n integral que puede competir con placas de interfaz similares de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asterick</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Patton</a> y otros.  La ventaja de nuestra soluci√≥n es que el desarrollador no necesita un enlace intermedio entre la PC y el PCI para la transferencia de datos, podr√° transmitir directamente la informaci√≥n recibida a trav√©s de Ethernet. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415435/">https://habr.com/ru/post/es415435/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415423/index.html">Infraestructura de clave p√∫blica: Autoridad de certificaci√≥n basada en OpenSSL y SQLite3 Utility (Postcryptum)</a></li>
<li><a href="../es415427/index.html">Toda la verdad sobre RTOS de Colin Walls. Art√≠culo # 4. Tareas, cambio de contexto e interrupciones</a></li>
<li><a href="../es415429/index.html">Toda la verdad sobre RTOS de Colin Walls. Art√≠culo # 5. Interacci√≥n de tareas y sincronizaci√≥n</a></li>
<li><a href="../es415431/index.html">Anuncio de Hackathon SmartMail Hack 2: Llamada de datos</a></li>
<li><a href="../es415433/index.html">Gesti√≥n de lanzamientos de viviendas y servicios comunitarios de SIG: compartimos experiencia y luchamos con intuici√≥n</a></li>
<li><a href="../es415437/index.html">C√≥mo lanzar ML en prod: seis rastrillos que pisamos</a></li>
<li><a href="../es415439/index.html">¬øLa comunicaci√≥n corporativa te obliga a abandonar o arrastrarte a un proyecto como un juego?</a></li>
<li><a href="../es415441/index.html">Los ataques de ransomware contra agencias gubernamentales est√°n creciendo en los EE. UU.</a></li>
<li><a href="../es415443/index.html">MDG e ITMO University invitan a la Escuela de Verano de Machine Learning</a></li>
<li><a href="../es415445/index.html">El resumen de eventos para profesionales de recursos humanos en el campo de TI para julio de 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>