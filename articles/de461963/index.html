<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏼 👎🏿 🦓 Abzug von Klassenvorlagenargumenten 👩🏽‍🤝‍👨🏿 ⏳ 🍚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der C ++ 17-Standard hat der Sprache eine neue Funktion hinzugefügt: Class Template Argument Deduction (CTAD) . Zusammen mit den neuen Funktionen in C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Abzug von Klassenvorlagenargumenten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461963/"><p><img src="https://habrastorage.org/webt/od/-t/zm/od-tzmtj9pxbfzw-hrpd7ml2gpw.jpeg"></p><br><p>  Der C ++ 17-Standard hat der Sprache eine neue Funktion hinzugefügt: <strong>Class Template Argument Deduction (CTAD)</strong> .  Zusammen mit den neuen Funktionen in C ++ wurden traditionell neue Methoden zum Schießen eigener Gliedmaßen hinzugefügt.  In diesem Artikel werden wir verstehen, was CTAD ist, wofür es verwendet wird, wie es das Leben vereinfacht und welche Fallstricke es enthält. </p><a name="habracut"></a><br><h2 id="nachnyom-izdaleka">  Fangen wir von weitem an </h2><br><p>  Erinnern Sie sich daran, worum es beim <em>Abzug von Vorlagenargumenten</em> geht und wofür.  Wenn Sie sich mit C ++ - Vorlagen sicher genug fühlen, können Sie diesen Abschnitt überspringen und sofort mit dem nächsten fortfahren. </p><br><p>  Vor C ++ 17 wurde die Ausgabe von Vorlagenparametern nur auf Funktionsvorlagen angewendet.  Wenn Sie eine Funktionsvorlage instanziieren, geben Sie möglicherweise nicht explizit die Vorlagenargumente an, die aus den Typen der tatsächlichen Funktionsargumente abgeleitet werden können.  Die Regeln für die Ableitung sind recht kompliziert. Sie werden im gesamten Abschnitt <strong>17.9.2</strong> des Standards <strong>[temp.deduct] behandelt</strong> (im Folgenden beziehe ich mich auf die frei verfügbare Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardentwurfs</a> ; in zukünftigen Versionen kann sich die Abschnittsnummerierung ändern, daher empfehle ich, nach dem in spezifizierten Mnemonikcode zu suchen eckige Klammern). </p><br><p> Wir werden nicht alle Feinheiten dieser Regeln im Detail analysieren, sie werden nur von Compiler-Entwicklern benötigt.  Für den praktischen Gebrauch reicht es aus, sich an eine einfache Regel zu erinnern: Der Compiler kann die Argumente der Funktionsvorlage unabhängig voneinander ableiten, wenn dies anhand der verfügbaren Informationen eindeutig möglich ist.  Beim Ableiten von Arten von Vorlagenparametern werden Standardtransformationen wie beim Aufrufen einer regulären Funktion angewendet ( <em>const wird</em> aus <em>Literaltypen</em> verworfen, Arrays werden auf Zeiger reduziert, Funktionsreferenzen werden auf Funktionszeiger reduziert usw.). </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } int some_func(double d) { return static_cast&lt;int&gt;(d); } int main() { const int i = 123; func(i); // func&lt;int&gt; char arr[] = "Some text"; func(arr); // func&lt;char *&gt; func(some_func); // func&lt;int (*)(double)&gt; return 0; }</span></span></code> </pre> <br><p>  All dies vereinfacht die Verwendung von Funktionsvorlagen, ist jedoch leider nicht auf Klassenvorlagen anwendbar.  Bei der Instanziierung von Klassenvorlagen mussten alle nicht standardmäßigen Vorlagenparameter explizit angegeben werden.  Aufgrund dieser unangenehmen Eigenschaft wurde in der Standardbibliothek eine ganze Familie freier Funktionen mit dem Präfix <em>make_</em> <em>angezeigt</em> : <em>make_unique</em> , <em>make_shared</em> , <em>make_pair</em> , <em>make_tuple</em> usw. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  auto tup1 = std::tuple&lt;int, char, double&gt;(123, 'a', 40.0); //   auto tup2 = std::make_tuple(123, 'a', 40.0);</span></span></code> </pre> <br><h2 id="novoe-v-c17">  Neu in C ++ 17 </h2><br><p>  Im neuen Standard werden in Analogie zu den Parametern von Funktionsvorlagen die Parameter von Klassenvorlagen aus den Argumenten der aufgerufenen Konstruktoren abgeleitet: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">pair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">45.67</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// std::pair&lt;bool, double&gt; std::tuple tup(123, 'a', 40.0); // std::tuple&lt;int, char, double&gt; std::less l; // std::less&lt;void&gt;,     std::less&lt;&gt; l template &lt;typename T&gt; struct A { A(T,T); }; auto y = new A{1, 2}; //  A&lt;int&gt; auto lck = std::lock_guard(mtx); // std::lock_guard&lt;std::mutex&gt; std::copy_n(vi1, 3, std::back_insert_iterator(vi2)); //       template &lt;typename T&gt; struct F { F(T); } std::for_each(vi.begin(), vi.end(), Foo([&amp;](int i) {...})); // F&lt;lambda&gt;</span></span></code> </pre> <br><p>  Es ist sofort erwähnenswert, welche CTAD-Einschränkungen zum Zeitpunkt von C ++ 17 gelten (möglicherweise werden diese Einschränkungen in zukünftigen Versionen des Standards entfernt): </p><br><ul><li>  CTAD funktioniert nicht mit Vorlagenaliasnamen: </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> X&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PairIntX = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, X&gt;; PairIntX p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><ul><li>  CTAD erlaubt keine teilweise Ausgabe von Argumenten (wie dies für die reguläre <em>Ableitung von Vorlagenargumenten</em> funktioniert): </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// OK std::pair&lt;double&gt; q{1, 5}; // ,   std::pair&lt;double, int&gt; r{1, 5}; // OK</span></span></code> </pre> <br><p>  Außerdem kann der Compiler keine Typen von Vorlagenparametern ableiten, die nicht explizit mit den Typen von Konstruktorargumenten zusammenhängen.  Das einfachste Beispiel ist ein Containerkonstruktor, der zwei Iteratoren akzeptiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyVector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; MyVector(It from, It to); }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; dv = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">7.0</span></span>}; MyVector v2{dv.begin(), dv.end()}; <span class="hljs-comment"><span class="hljs-comment">//     T   It</span></span></code> </pre> <br><p>  Der Typ <em>Es steht</em> nicht in direktem Zusammenhang mit <em>T</em> , obwohl wir Entwickler genau wissen, wie man es bekommt.  Um dem Compiler mitzuteilen, wie direkt nicht verwandte Typen ausgegeben werden sollen, wurde in C ++ 17 ein neues Sprachkonstrukt angezeigt - der <em>Ableitungsleitfaden</em> , den wir im nächsten Abschnitt behandeln werden. </p><br><h2 id="deduction-guides">  Widmungsleitfäden </h2><br><p>  Für das obige Beispiel würde der <em>Abzugsleitfaden folgendermaßen</em> aussehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; MyVector(It, It) -&gt; MyVector&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iterator_traits&lt;It&gt;::value_type&gt;;</code> </pre> <br><p>  Hier teilen wir dem Compiler mit, dass Sie für einen Konstruktor mit zwei Parametern desselben Typs den Typ von <em>T</em> mithilfe der Konstruktion <code>std::iterator_traits&lt;It&gt;::value_type</code> .  Beachten Sie, dass <em>Abzugsleitfäden</em> außerhalb der Klassendefinition liegen. Auf diese Weise können Sie das Verhalten externer Klassen anpassen, einschließlich Klassen aus der C ++ - Standardbibliothek. </p><br><p>  Eine formale Beschreibung der Syntax von <strong>Abzugsleitfäden finden Sie</strong> in C ++ Standard 17 in Abschnitt <strong>17.10 [temp.deduct.guide]</strong> : </p><br><pre> <code class="cpp hljs">[<span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>-name (parameter-declaration-clause) -&gt; simple-<span class="hljs-keyword"><span class="hljs-keyword">template</span></span>-id;</code> </pre> <br><p>  Das <strong>explizite</strong> Schlüsselwort vor dem <em>Abzugsleitfaden</em> verbietet die Verwendung mit <em>der Initialisierung der Kopierliste</em> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(It, It)</span></span></span><span class="hljs-function"> -&gt; MyVector&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typename</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::iterator_traits&lt;It&gt;::value_type&gt;</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; dv = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">7.0</span></span>}; MyVector v2{dv.begin(), dv.end()}; <span class="hljs-comment"><span class="hljs-comment">//  MyVector v3 = {dv.begin(), dv.end()}; //  </span></span></code> </pre> <br><p>  Der <em>Abzugsleitfaden</em> muss übrigens keine Vorlage sein: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> S(T); }; S(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*) -&gt; S&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;; S s{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// S&lt;std::string&gt;</span></span></code> </pre> <br><h2 id="podrobnyy-algoritm-raboty-ctad">  Detaillierter CTAD-Algorithmus </h2><br><p>  Formale Regeln zum Ableiten von Klassenvorlagenargumenten werden ausführlich in <strong>Abschnitt 16.3.1.8 [over.match.class.deduct] von</strong> C ++ Standard 17 beschrieben.  Versuchen wir, sie herauszufinden. </p><br><p>  Wir haben also einen Vorlagentyp <em>C,</em> für den CTAD angewendet wird.  Um auszuwählen, welcher Konstruktor und mit welchen Parametern für <em>C</em> aufgerufen werden soll, werden viele Vorlagenfunktionen nach den folgenden Regeln gebildet: </p><br><ul><li>  Für jeden <em>Ci-</em> Konstruktor wird eine Dummy- <em>Fi-</em> Vorlagenfunktion generiert.  <em>Fi-</em> Vorlagenparameter sind <em>C-</em> Parameter, gefolgt von <em>Ci-</em> Vorlagenparametern (falls vorhanden), einschließlich Parametern mit Standardwerten.  Die Parametertypen der <em>Fi-</em> Funktion entsprechen den Parametertypen des <em>Ci-</em> Konstruktors.  Gibt eine Dummy-Funktion <em>Fi</em> Typ <em>C</em> mit Argumenten zurück, die mit den <em>C-</em> Vorlagenparametern übereinstimmen. </li></ul><br><p>  Pseudocode: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> W = A&gt; C(V, W); }; <span class="hljs-comment"><span class="hljs-comment">//    template &lt;typename T, typename U, typename V, typename W = A&gt; C&lt;T, U&gt; Fi(V, W);</span></span></code> </pre> <br><ul><li>  Wenn Typ <em>C</em> nicht definiert ist oder keine Konstruktoren angegeben sind, gelten die obigen Regeln für den hypothetischen Konstruktor <em>C ()</em> . </li><li>  Für den <em>C ©</em> -Konstruktor wird eine zusätzliche Dummy-Funktion generiert, für die sogar ein spezieller Name gefunden wurde: <em>Copy Deduction Candidate</em> . </li><li>  Für jeden <em>Abzugsleitfaden</em> wird auch eine Dummy-Funktion <em>Fi</em> mit Vorlagenparametern und <em>Abzugsleitfadenargumenten</em> sowie einem Rückgabewert generiert, der dem Typ rechts von -&gt; im <em>Abzugsleitfaden entspricht</em> (in der formalen Definition heißt er <em>simple-template-id</em> ). </li></ul><br><p>  Pseudocode: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V&gt; C(T, V) -&gt; C&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> DT&lt;T&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> DT&lt;V&gt;&gt;; <span class="hljs-comment"><span class="hljs-comment">//    template &lt;typename T, typename V&gt; C&lt;typename DT&lt;T&gt;, typename DT&lt;V&gt;&gt; Fi(T,V);</span></span></code> </pre> <br><p>  Ferner werden für den resultierenden Satz von <em>Fi-</em> Dummy-Funktionen die üblichen Regeln für die Ausgabe von Vorlagenparametern und die Überlastungsauflösung angewendet, mit einer Ausnahme: Wenn eine Dummy-Funktion mit einer Initialisierungsliste aufgerufen wird, die aus einem einzelnen Parameter vom Typ <em>cv U besteht</em> , wobei <em>U</em> Spezialisierung <em>C</em> oder ein von Spezialisierung <em>C</em> <em>geerbter</em> Typ ist (Nur für den Fall, ich werde klarstellen, dass <em>cv == const flüchtig ist</em> . Ein solcher Datensatz bedeutet, dass die Typen <em>U</em> , <em>const U</em> , <em>flüchtig U</em> und <em>const flüchtig U gleich</em> behandelt werden.) Die Regel, die dem Konstruktor <code>C(std::initializer_list&lt;&gt;)</code> Priorität einräumt <code>C(std::initializer_list&lt;&gt;)</code> (wird übersprungen Einzelheiten zur <em>Liste initia</em>  <em>Die Versionierung</em> finden Sie in <strong>Abschnitt 16.3.1.7 [over.match.list] von</strong> C ++ Standard 17).  Ein Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> v1{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// std::vector&lt;int&gt; std::vector v2{v1}; // std::vector&lt;int&gt;,   std::vector&lt;std::vector&lt;int&gt;&gt;</span></span></code> </pre> <br><p>  Wenn es schließlich möglich war, die einzig am besten geeignete Dummy-Funktion auszuwählen, wird der entsprechende Konstruktor oder <em>Ableitungsleitfaden</em> ausgewählt.  Wenn es keine geeigneten oder mehrere gleich geeignete gibt, meldet der Compiler einen Fehler. </p><br><h2 id="podvodnye-kamni">  Fallstricke </h2><br><p>  CTAD wird zum Initialisieren von Objekten verwendet, und die Initialisierung ist traditionell ein sehr verwirrender Teil der C ++ - Sprache.  Mit der Einführung einer <em>einheitlichen Initialisierung</em> in C ++ 11 haben sich die Möglichkeiten, Ihr Bein abzuschießen, nur erhöht.  Jetzt können Sie den Konstruktor für ein Objekt mit runden und geschweiften Klammern aufrufen.  In vielen Fällen funktionieren beide Optionen gleich, aber nicht immer: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> v1{<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// [8, 15] std::vector v2(8, 15); // [15, 15, … 15] (8 ) std::vector v3{8}; // [8] std::vector v4(8); //  </span></span></code> </pre> <br><p>  Bisher scheint alles ziemlich logisch zu sein: <em>v1</em> und <em>v3</em> rufen den Konstruktor auf, der <code>std::initializer_list&lt;int&gt;</code> , int wird aus den Parametern abgeleitet;  <em>v4</em> kann keinen Konstruktor finden, der nur einen Parameter vom Typ <em>int akzeptiert</em> .  Aber das sind immer noch Blumen, Beeren vorne: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> v5{<span class="hljs-string"><span class="hljs-string">"hi"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// [“hi”, “world”] std::vector v6("hi", "world"); // ??</span></span></code> </pre> <br><p>  <em>v5</em> wird erwartungsgemäß vom Typ <code>std::vector&lt;const char*&gt;</code> und mit zwei Elementen initialisiert, aber die nächste Zeile macht etwas völlig anderes.  Für einen Vektor gibt es nur einen Konstruktor, der zwei Parameter desselben Typs akzeptiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Allocator</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alloc</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Allocator</span></span></span><span class="hljs-class">() );</span></span></code> </pre> <br><p>  Dank der <em>Ableitungsanleitung</em> für <code>std::vector</code> "hi" und "world" als Iteratoren behandelt, und alle "dazwischen" liegenden Elemente werden einem Vektor vom Typ <code>std::vector&lt;char&gt;</code> hinzugefügt.  Wenn wir Glück haben und diese beiden Zeichenfolgenkonstanten hintereinander im Speicher sind, fallen drei Elemente in den Vektor: 'h', 'i', '\ x00', aber höchstwahrscheinlich führt ein solcher Code zu einer Verletzung des Speicherschutzes und zum Absturz des Programms. </p><br><h2 id="ispolzuemye-materialy">  Verwendete Materialien </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwurf Standard C ++ 17</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CTAD</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CppCon 2018: Stephan T. Lavavej "Klassenvorlagenargumentabzug für alle"</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461963/">https://habr.com/ru/post/de461963/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461941/index.html">Massieren Sie es</a></li>
<li><a href="../de461945/index.html">Die Zusammenfassung der Ereignisse für HR-Fachkräfte im Bereich IT für August 2019</a></li>
<li><a href="../de461949/index.html">AppCode 2019.2: Swift 5.1, Analyse der Codeabdeckung durch Tests, Anzeige von zerlegtem Code und mehr</a></li>
<li><a href="../de461951/index.html">Veeam-Plug-In zur Sicherung und Wiederherstellung von SAP-HANA-Datenbanken</a></li>
<li><a href="../de461955/index.html">Tauschen Sie Token aus oder wie Sie das Krypto-Portfolio im Jahr 2019 stärken können</a></li>
<li><a href="../de461965/index.html">Web-MVC-Anwendung ohne Frameworks und Servlets</a></li>
<li><a href="../de461967/index.html">Antiquitäten: Funktionsbandgerät</a></li>
<li><a href="../de461971/index.html">Die Leistung von Oracle SQL</a></li>
<li><a href="../de461973/index.html">Probefahrt Audi e-tron</a></li>
<li><a href="../de461975/index.html">Unser Service ist sowohl gefährlich als auch schwierig, oder Zyxel ATP500</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>