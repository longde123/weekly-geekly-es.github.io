<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§° ‚ÜôÔ∏è üë®üèæ‚Äçüíª Arquivo descritor do Linux com exemplos üññüèΩ üõí üíÖüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uma vez, em uma entrevista, eles me perguntaram o que voc√™ faria se encontrar um servi√ßo que n√£o est√° funcionando porque o disco ficou sem espa√ßo? 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arquivo descritor do Linux com exemplos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471038/"> Uma vez, em uma entrevista, eles me perguntaram o que voc√™ faria se encontrar um servi√ßo que n√£o est√° funcionando porque o disco ficou sem espa√ßo? <br><br>  Obviamente, respondi que veria o que esse lugar estava ocupado e, se poss√≠vel, limparia o local. <br>  Em seguida, o entrevistador perguntou: e se n√£o houver espa√ßo livre na se√ß√£o, mas voc√™ tamb√©m n√£o v√™ os arquivos que ocupariam todo o lugar? <br><br>  Para isso, eu disse que voc√™ sempre pode examinar os descritores de arquivos abertos, por exemplo, com o comando lsof e entender qual aplicativo ocupa todo o espa√ßo dispon√≠vel e, em seguida, voc√™ pode prosseguir de acordo com as circunst√¢ncias, dependendo da necessidade dos dados. <br><br>  O entrevistador me interrompeu na √∫ltima palavra, adicionando minha pergunta: "Suponha que n√£o precisamos dos dados, √© apenas um log de depura√ß√£o, mas o aplicativo n√£o funciona porque n√£o pode gravar a depura√ß√£o"? <br><br>  "Ok", respondi, "podemos desativar a depura√ß√£o na configura√ß√£o do aplicativo e reinici√°-la". <br>  O entrevistador objetou: ‚ÄúN√£o, n√£o podemos reiniciar o aplicativo, dados importantes ainda est√£o armazenados em nossa mem√≥ria e clientes importantes est√£o conectados ao pr√≥prio servi√ßo, que n√£o podemos for√ßar a reconectar‚Äù. <br><br>  "Bem", eu disse, "se n√£o podemos reiniciar o aplicativo e os dados n√£o s√£o importantes para n√≥s, podemos simplesmente limpar esse arquivo aberto atrav√©s do descritor de arquivos, mesmo que n√£o o possamos ver no comando ls no sistema de arquivos". <br><br>  O entrevistador ficou satisfeito, mas eu n√£o. <br><br>  Ent√£o pensei: por que a pessoa que est√° testando meu conhecimento n√£o se aprofunda?  Mas e se os dados ainda forem importantes?  E se n√£o pudermos reiniciar o processo e, ao mesmo tempo, esse processo gravar no sistema de arquivos em uma se√ß√£o na qual n√£o haja espa√ßo livre?  E se n√£o pudermos perder n√£o apenas os dados j√° gravados, mas tamb√©m os dados que esse processo grava ou tenta gravar? <br><a name="habracut"></a><br><h3>  Tuzik </h3><br>  No in√≠cio da minha carreira, tentei criar um pequeno aplicativo no qual era necess√°rio armazenar informa√ß√µes sobre os usu√°rios.  E ent√£o pensei: como posso mapear o usu√°rio para seus dados.  Por exemplo, eu tenho Ivan Ivanov Ivanich, e ele tem alguns dados, mas como fazer amizade com eles?  Eu posso indicar diretamente que o cachorro chamado "Tuzik" pertence a esse mesmo Ivan.  Mas e se ele mudar de nome e, em vez de Ivan, se tornar, por exemplo, Olya?  Acontece que nosso Olya Ivanovna Ivanova n√£o ter√° mais um cachorro e nosso Tuzik ainda pertencer√° ao inexistente Ivan.  Esse banco de dados foi ajudado por um banco de dados que forneceu a cada usu√°rio um identificador exclusivo (ID), e meu Tuzik foi anexado a esse ID, que, de fato, era apenas um n√∫mero ordinal.  Assim, o propriet√°rio do tuzik estava com o n√∫mero de identifica√ß√£o 2 e, em algum momento, Ivan estava com esse ID e, em seguida, Olya se tornou o mesmo ID.  O problema da humanidade e da cria√ß√£o de animais foi praticamente resolvido. <br><br><h3>  Descritor de arquivo </h3><br>  O problema do arquivo e do programa que trabalha com esse arquivo √© quase o mesmo do nosso c√£o e pessoa.  Suponha que eu abri um arquivo com o nome ivan.txt e comecei a escrever a palavra tuzik nele, mas consegui escrever apenas a primeira letra ‚Äút‚Äù no arquivo, e esse arquivo foi renomeado por algu√©m, por exemplo, olya.txt.  Mas o arquivo permaneceu o mesmo, e eu ainda quero escrever meu √°s nele.  Cada vez que abro um arquivo com a chamada de sistema aberta em qualquer linguagem de programa√ß√£o, recebo um ID exclusivo que me indica um arquivo, esse ID √© um descritor de arquivo.  E n√£o importa o que algu√©m fa√ßa a seguir com esse arquivo, eles podem exclu√≠-lo, renome√°-lo, alterar o propriet√°rio ou tirar permiss√µes de leitura e grava√ß√£o, ainda terei acesso a ele, porque no momento em que o arquivo √© aberto, Eu tinha o direito de ler e / ou escrever e consegui come√ßar a trabalhar com ele, o que significa que devo continuar fazendo isso. <br><br>  No Linux, a biblioteca libc √© aberta para cada arquivo descritor do aplicativo em execu√ß√£o (processo) 3, com n√∫meros 0,1,2.  Voc√™ pode encontrar mais informa√ß√µes nos links <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">man stdio</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">man stdout</a> <br><br><ul><li>  O descritor de arquivo 0 √© chamado STDIN e est√° associado √† entrada de dados do aplicativo </li><li>  O descritor de arquivo 1 √© chamado STDOUT e √© usado por aplicativos para gerar dados, por exemplo, comandos de impress√£o </li><li>  O descritor de arquivo 2 √© chamado STDERR e √© usado por aplicativos para gerar dados de relat√≥rio de erros. </li></ul><br>  Se voc√™ abrir um arquivo para leitura ou grava√ß√£o em seu programa, provavelmente obter√° o primeiro ID gratuito e este ser√° o n√∫mero 3. <br><br>  Uma lista de arquivos descritores pode ser visualizada a partir de qualquer processo, se voc√™ souber seu PID. <br><br>  Por exemplo, abra um console com bash e veja o PID do nosso processo <br><br><pre><code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ 15771</code> </pre> <br>  No segundo console, execute <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -lah /proc/15771/fd/ total 0 dr-x------ 2 user user 0 Oct 7 15:42 . dr-xr-xr-x 9 user user 0 Oct 7 15:42 .. lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21</code> </pre><br>  Voc√™ pode ignorar com seguran√ßa o descritor de arquivo n√∫mero 255 na estrutura deste artigo; ele foi aberto para suas necessidades pelo pr√≥prio bash e n√£o por uma biblioteca vinculada. <br><br>  Agora, todos os tr√™s arquivos descritores est√£o associados ao dispositivo pseudo-terminal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">/ dev / pts</a> , mas ainda podemos manipul√°-los, por exemplo, para rodar no segundo console <br><br><pre> <code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello world"</span></span> &gt; /proc/15771/fd/0</code> </pre><br>  E no primeiro console veremos <br><br><pre> <code class="bash hljs">[user@localhost ]$ hello world</code> </pre><br><h3>  Redirecionar e canalizar </h3><br>  √â poss√≠vel substituir facilmente esses tr√™s arquivos de descritor em qualquer processo, inclusive no bash, por exemplo, atrav√©s de um canal que conecta dois processos, consulte <br><br><pre> <code class="bash hljs">[user@localhost ]$ cat /dev/zero | sleep 10000</code> </pre><br>  Voc√™ pode executar esse comando com <i>strace -f</i> e ver o que acontece por dentro, mas eu vou lhe dizer brevemente. <br><br>  Nosso processo pai bash com PID 15771 analisa nosso comando e entende exatamente quantos comandos queremos executar, no nosso caso, existem dois deles: gato e sono.  Bash sabe que ele precisa criar dois processos filhos e combin√°-los com um canal.  O bash total precisar√° de 2 processos filho e um pipe. <br><br>  Antes de criar os processos filho, o bash inicia a chamada do sistema de canal e recebe novos descritores de arquivo para o buffer de canal tempor√°rio, mas esse buffer ainda n√£o vincula nossos dois processos filhos. <br><br>  Para o processo pai, parece que o pipe j√° existe e ainda n√£o h√° processos filhos: <br><br><pre> <code class="bash hljs">PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 15771 bash lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21</code> </pre><br>  Em seguida, usando uma chamada de sistema, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">clone</a> bash cria dois processos filhos e nossos tr√™s processos ter√£o a seguinte apar√™ncia: <br><br><pre> <code class="bash hljs">PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 15771 bash lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21 PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 9004 bash lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 255 -&gt; /dev/pts/21 PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 9005 bash lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 255 -&gt; /dev/pts/21</code> </pre><br>  N√£o esque√ßa que o clone clona o processo junto com todos os descritores de arquivo, portanto eles ser√£o os mesmos no processo pai e nos filhos.  A tarefa do processo pai com o PID 15771 √© monitorar os processos filhos, portanto, apenas aguarda uma resposta dos processos filhos. <br><br>  Portanto, ele n√£o precisa de pipe e fecha os descritores de arquivo com os n√∫meros 3 e 4. <br><br>  No primeiro processo filho do bash com PID 9004, a chamada do sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dup2</a> altera nosso descritor de arquivo STDOUT com o n√∫mero 1 para um descritor de arquivo apontando para pipe, no nosso caso, √© o n√∫mero 3. Assim, tudo o que o primeiro processo filho com o PID 9004 gravar√° no STDOUT cair√° automaticamente no buffer do tubo. <br><br>  No segundo processo filho com o PID 9005, o bash altera o descritor de arquivo STDIN com o n√∫mero 0. Agora, tudo o que nosso segundo bash com o PID 9005 ler, ser√° lido no pipe. <br><br>  Depois disso, os descritores com os n√∫meros 3 e 4 tamb√©m s√£o fechados em processos filhos, pois n√£o s√£o mais utilizados. <br><br>  Eu deliberadamente ignoro o descritor de arquivo 255, ele usa o bash para necessidades internas e tamb√©m ser√° fechado em processos filho. <br><br>  Al√©m disso, no primeiro processo filho do PID 9004, o bash inicia o arquivo execut√°vel especificado na linha de comando com a chamada de sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exec</a> , no nosso caso, √© / usr / bin / cat. <br><br>  No segundo processo filho com o PID 9005, o bash inicia o segundo arquivo execut√°vel especificado, no nosso caso, √© / usr / bin / sleep. <br><br>  A chamada do sistema exec n√£o fecha os descritores de arquivo se eles n√£o foram abertos com o sinalizador O_CLOEXEC durante a chamada de abertura.  No nosso caso, ap√≥s a execu√ß√£o dos arquivos execut√°veis, todos os descritores de arquivos atuais ser√£o salvos. <br><br>  Verifique no console: <br><br><pre> <code class="bash hljs">[user@localhost ]$ pgrep -P 15771 9004 9005 [user@localhost ]$ ls -lah /proc/15771/fd/ total 0 dr-x------ 2 user user 0 Oct 7 15:42 . dr-xr-xr-x 9 user user 0 Oct 7 15:42 .. lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21 [user@localhost ]$ ls -lah /proc/9004/fd total 0 dr-x------ 2 user user 0 Oct 7 15:57 . dr-xr-xr-x 9 user user 0 Oct 7 15:57 .. lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 l-wx------ 1 user user 64 Oct 7 15:57 1 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lr-x------ 1 user user 64 Oct 7 15:57 3 -&gt; /dev/zero [user@localhost ]$ ls -lah /proc/9005/fd total 0 dr-x------ 2 user user 0 Oct 7 15:57 . dr-xr-xr-x 9 user user 0 Oct 7 15:57 .. lr-x------ 1 user user 64 Oct 7 15:57 0 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 [user@localhost ]$ ps -up 9004 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 9004 0.0 0.0 107972 620 pts/21 S+ 15:57 0:00 cat /dev/zero [user@localhost ]$ ps -up 9005 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 9005 0.0 0.0 107952 360 pts/21 S+ 15:57 0:00 sleep 10000</code> </pre><br>  Como voc√™ pode ver, o n√∫mero √∫nico de nossos tubos √© o mesmo nos dois processos.  Portanto, temos uma conex√£o entre dois processos diferentes com um pai. <br><br>  Para aqueles que n√£o est√£o familiarizados com as chamadas do sistema que o bash usa, eu recomendo executar os comandos atrav√©s do strace e ver o que acontece dentro, por exemplo, desta forma: <br><br><pre> <code class="bash hljs">strace -s 1024 -f bash -c <span class="hljs-string"><span class="hljs-string">"ls | grep hello"</span></span></code> </pre><br>  Vamos voltar ao nosso problema com falta de espa√ßo em disco e tentando salvar dados sem reiniciar o processo.  Vamos escrever um pequeno programa que ir√° gravar no disco cerca de 1 megabyte por segundo.  Al√©m disso, se por algum motivo n√£o pudemos gravar dados no disco, simplesmente os ignoramos e tentamos gravar os dados novamente ap√≥s um segundo.  No exemplo que eu uso Python, voc√™ pode usar qualquer outra linguagem de programa√ß√£o. <br><br><pre> <code class="python hljs">[user@localhost ]$ cat openforwrite.py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time mystr=<span class="hljs-string"><span class="hljs-string">"a"</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>+<span class="hljs-string"><span class="hljs-string">"\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: f.write(str(datetime.datetime.now())) f.write(mystr) f.flush() time.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  Execute o programa e veja os descritores de arquivo <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py &amp; [1] 3762 [user@localhost ]$ ps axuf | grep [o]penforwrite user 3762 0.0 0.0 128600 5744 pts/22 S+ 16:28 0:00 | \_ python openforwrite.py [user@localhost ]$ ls -la /proc/3762/fd total 0 dr-x------ 2 user user 0 Oct 7 16:29 . dr-xr-xr-x 9 user user 0 Oct 7 16:29 .. lrwx------ 1 user user 64 Oct 7 16:29 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 7 16:29 3 -&gt; /home/user/123.txt</code> </pre><br>  Como voc√™ pode ver, temos nossos tr√™s descritores de arquivo padr√£o e outro que abrimos.  Verifique o tamanho do arquivo: <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 user user 117M Oct 7 16:30 123.txt</code> </pre><br>  dados est√£o sendo gravados, tente alterar as permiss√µes do arquivo: <br><br><pre> <code class="bash hljs">[user@localhost ]$ sudo chown root: 123.txt [user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 root root 168M Oct 7 16:31 123.txt [user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 root root 172M Oct 7 16:31 123.txt</code> </pre><br>  Vemos que os dados ainda est√£o sendo gravados, embora nosso usu√°rio n√£o tenha o direito de gravar no arquivo.  Vamos tentar remov√™-lo: <br><br><pre> <code class="bash hljs">[user@localhost ]$ sudo rm 123.txt [user@localhost ]$ ls 123.txt ls: cannot access 123.txt: No such file or directory</code> </pre><br>  Onde est√£o os dados gravados?  E eles est√£o escritos?  Verificamos: <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -la /proc/3762/fd total 0 dr-x------ 2 user user 0 Oct 7 16:29 . dr-xr-xr-x 9 user user 0 Oct 7 16:29 .. lrwx------ 1 user user 64 Oct 7 16:29 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 7 16:29 3 -&gt; /home/user/123.txt (deleted)</code> </pre><br>  Sim, nosso arquivo descritor ainda existe e podemos trabalhar com esse arquivo descritor, assim como com nosso arquivo antigo, podemos ler, limpar e copi√°-lo. <br><br>  Observamos o tamanho do arquivo: <br><br><pre> <code class="bash hljs">[user@localhost ]$ lsof | grep 123.txt python 31083 user 3w REG 8,5 19923457 2621522 /home/user/123.txt</code> </pre><br>  Tamanho do arquivo 19923457. Tentando limpar o arquivo: <br><br><pre> <code class="bash hljs">[user@localhost ]$ truncate -s 0 /proc/31083/fd/3 [user@localhost ]$ lsof | grep 123.txt python 31083 user 3w REG 8,5 136318390 2621522 /home/user/123.txt</code> </pre><br>  Como voc√™ pode ver, o tamanho do arquivo est√° aumentando apenas e nosso trankate n√£o funcionou.  Consulte a documenta√ß√£o para a chamada de sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aberta</a> .  Se usarmos o sinalizador O_APPEND ao abrir um arquivo, sempre que o sistema operacional verificar o tamanho do arquivo e gravar dados no final do arquivo, ele far√° isso de maneira at√¥mica.  Isso permite que v√°rios threads ou processos gravem no mesmo arquivo.  Mas em nosso c√≥digo, n√£o usamos esse sinalizador.  Podemos ver um tamanho de arquivo diferente em lsof ap√≥s trankate somente se abrirmos o arquivo para grava√ß√£o adicional, o que significa que, em vez de em nosso c√≥digo <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  n√≥s temos que colocar <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  Verificando com a bandeira "w" <br><br><pre> <code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3</code> </pre><br>  e com a bandeira "a" <br><br><pre> <code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, O_WRONLY|O_CREAT|O_APPEND, 0666) = 3</code> </pre><br><h3>  Programar um processo j√° em execu√ß√£o </h3><br>  Frequentemente, os programadores usam depuradores (por exemplo, GDB) ou v√°rios n√≠veis de logon no aplicativo ao criar e testar programas.  O Linux fornece a capacidade de realmente escrever e alterar um programa j√° em execu√ß√£o, por exemplo, alterando os valores das vari√°veis, definindo o ponto de interrup√ß√£o etc. <br><br>  Voltando √† pergunta original, com pouco espa√ßo em disco para gravar o arquivo, tentaremos emular o problema. <br><br>  Crie um arquivo para nossa parti√ß√£o, que montaremos como um disco separado: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=~/tempfile_for_article.dd bs=1M count=10 10+0 records <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 10+0 records out 10485760 bytes (10 MB) copied, 0.00525929 s, 2.0 GB/s [user@localhost ~]$</code> </pre><br>  Crie um sistema de arquivos: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ mkfs.ext4 ~/tempfile_for_article.dd mke2fs 1.42.9 (28-Dec-2013) /home/user/tempfile_for_article.dd is not a block special device. Proceed anyway? (y,n) y ... Writing superblocks and filesystem accounting information: <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> [user@localhost ~]$</code> </pre><br>  Monte o sistema de arquivos: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ sudo mount ~/tempfile_for_article.dd /mnt/ [sudo] password <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> user: [user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 172K 7.9M 3% /mnt</code> </pre><br>  Crie um diret√≥rio com nosso propriet√°rio: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ sudo mkdir /mnt/logs [user@localhost ~]$ sudo chown user: /mnt/logs</code> </pre><br>  Abrimos o arquivo para grava√ß√£o apenas em nosso programa: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"/mnt/logs/123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  Lan√ßamos <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py</code> </pre><br>  Esperando alguns segundos <br><br><pre> <code class="bash hljs">[user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 8.0M 0 100% /mnt</code> </pre><br>  Portanto, temos o problema descrito no in√≠cio deste artigo.  Espa√ßo livre 0, ocupado 100%. <br><br>  Lembramos que, de acordo com as condi√ß√µes da tarefa, estamos tentando registrar dados muito importantes que n√£o podem ser perdidos.  E, ao mesmo tempo, precisamos reparar o servi√ßo sem reiniciar o processo. <br><br>  Suponha que ainda tenhamos espa√ßo em disco, mas em uma parti√ß√£o diferente, por exemplo, em / home. <br><br>  Vamos tentar "reprogramar em tempo real" nosso c√≥digo. <br><br>  Observamos o PID do nosso processo, que consumiu todo o espa√ßo em disco: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]penfor user 10078 27.2 0.0 128600 5744 pts/22 R+ 11:06 0:02 | \_ python openforwrite.py</code> </pre><br>  N√≥s nos conectamos ao processo via gdb <br><br><pre> <code class="bash hljs">[user@localhost ~]$ gdb -p 10078 ... (gdb)</code> </pre><br>  Examinamos os descritores de arquivos abertos: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /mnt/logs/123.txt</code> </pre><br>  Examinamos as informa√ß√µes sobre o descritor de arquivo com o n√∫mero 3, que nos interessam <br><br><pre> <code class="bash hljs">(gdb) shell cat /proc/10078/fdinfo/3 pos: 8189952 flags: 0100001 mnt_id: 482</code> </pre><br>  Lembrando que tipo de chamada de sistema o Python faz (veja acima, onde executamos o strace e encontramos a chamada aberta), processando nosso c√≥digo para abrir o arquivo, fazemos o mesmo em nosso pr√≥prio nome, mas precisamos dos bits O_WRONLY | O_CREAT | O_TRUNC substitua por um valor num√©rico.  Para fazer isso, abra as fontes do kernel, por exemplo, <a href="">aqui</a> e veja quais sinalizadores s√£o respons√°veis ‚Äã‚Äãpor quais <br><br>  #define O_WRONLY 00000001 <br>  #define O_CREAT 00000100 <br>  #define O_TRUNC 00001000 <br><br>  Combinamos todos os valores em um, obtemos 00001101 <br><br>  Execute nossa chamada do gdb <br><br><pre> <code class="bash hljs">(gdb) call open(<span class="hljs-string"><span class="hljs-string">"/home/user/123.txt"</span></span>, 00001101,0666) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 4</code> </pre><br>  Portanto, temos um novo arquivo descritor com o n√∫mero 4 e um novo arquivo aberto em outra se√ß√£o, verifique: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /mnt/logs/123.txt l-wx------ 1 user user 64 Oct 8 11:15 4 -&gt; /home/user/123.txt</code> </pre><br>  Lembramos do exemplo de canal - como o bash altera os descritores de arquivo e j√° aprendemos a chamada do sistema dup2. <br><br>  Tentamos substituir um descritor de arquivo por outro <br><br><pre> <code class="bash hljs">(gdb) call dup2(4,3) <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = 3</code> </pre><br>  Verificamos: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /home/user/123.txt l-wx------ 1 user user 64 Oct 8 11:15 4 -&gt; /home/user/123.txt</code> </pre><br>  Encerramos o descritor de arquivo 4, pois n√£o precisamos dele: <br><br><pre> <code class="bash hljs">(gdb) call close (4) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 0</code> </pre><br>  E saia do gdb <br><br><pre> <code class="bash hljs">(gdb) quit A debugging session is active. Inferior 1 [process 10078] will be detached. Quit anyway? (y or n) y Detaching from program: /usr/bin/python2.7, process 10078</code> </pre><br>  Verifique o novo arquivo: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /home/user/123.txt -rw-rw-r-- 1 user user 5.1M Oct 8 11:18 /home/user/123.txt [user@localhost ~]$ ls -lah /home/user/123.txt -rw-rw-r-- 1 user user 7.1M Oct 8 11:18 /home/user/123.txt</code> </pre><br>  Como voc√™ pode ver, os dados s√£o gravados em um novo arquivo, verificamos o antigo: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/123.txt -rw-rw-r-- 1 user user 7.9M Oct 8 11:08 /mnt/logs/123.txt</code> </pre><br>  Os dados n√£o s√£o perdidos, o aplicativo funciona, os logs s√£o gravados em um novo local. <br><br><h3>  Vamos complicar um pouco a tarefa </h3><br>  Imagine que os dados s√£o importantes para n√≥s, mas n√£o temos espa√ßo em disco em nenhuma das se√ß√µes e n√£o podemos conectar o disco. <br><br>  O que podemos fazer √© redirecionar nossos dados em algum lugar, por exemplo, para canalizar, e os dados do canal, por sua vez, redirecionam para a rede atrav√©s de algum programa, por exemplo, netcat. <br>  Podemos criar um pipe nomeado com o comando mkfifo.  Ele criar√° um pseudo arquivo no sistema de arquivos, mesmo se n√£o houver espa√ßo livre nele. <br><br>  Reiniciamos o aplicativo e verificamos: <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py [user@localhost ~]$ ps axuf | grep [o]pen user 5946 72.9 0.0 128600 5744 pts/22 R+ 11:27 0:20 | \_ python openforwrite.py [user@localhost ~]$ ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt [user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 8.0M 0 100% /mnt</code> </pre><br>  N√£o h√° espa√ßo em disco, mas criamos com √™xito um pipe nomeado l√°: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ mkfifo /mnt/logs/megapipe [user@localhost ~]$ ls -lah /mnt/logs/megapipe prw-rw-r-- 1 user user 0 Oct 8 11:28 /mnt/logs/megapipe</code> </pre><br>  Agora, de alguma forma, precisamos agrupar todos os dados que entram nesse canal em outro servidor pela rede, para isso tudo o que o netcat far√°. <br><br>  No servidor remote-server.example.com, execute <br><br><pre> <code class="bash hljs">[user@localhost ~]$ nc -l 7777 &gt; 123.txt</code> </pre><br>  No nosso servidor com problemas, execute em um terminal separado <br><br><pre> <code class="bash hljs">[user@localhost ~]$ nc remote-server.example.com 7777 &lt; /mnt/logs/megapipe</code> </pre><br>  Agora, todos os dados que entram no canal ser√£o automaticamente enviados para stdin no netcat, que os enviar√° para a rede na porta 7777. <br><br>  Tudo o que precisamos fazer √© come√ßar a gravar nossos dados nesse pipe nomeado. <br><br>  J√° temos um aplicativo em execu√ß√£o: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]pen user 5946 99.8 0.0 128600 5744 pts/22 R+ 11:27 169:27 | \_ python openforwrite.py [user@localhost ~]$ ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt</code> </pre><br>  De todos os sinalizadores, precisamos apenas de O_WRONLY, pois o arquivo j√° existe e n√£o precisamos limp√°-lo <br><br><pre> <code class="bash hljs">[user@localhost ~]$ gdb -p 5946 ... (gdb) call open(<span class="hljs-string"><span class="hljs-string">"/mnt/logs/megapipe"</span></span>, 00000001,0666) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 4 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt l-wx------ 1 user user 64 Oct 8 14:20 4 -&gt; /mnt/logs/megapipe (gdb) call dup2(4,3) <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = 3 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/megapipe l-wx------ 1 user user 64 Oct 8 14:20 4 -&gt; /mnt/logs/megapipe (gdb) call close(4) <span class="hljs-variable"><span class="hljs-variable">$3</span></span> = 0 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/megapipe (gdb) quit A debugging session is active. Inferior 1 [process 5946] will be detached. Quit anyway? (y or n) y Detaching from program: /usr/bin/python2.7, process 5946</code> </pre><br>  Verificando o servidor remoto remote-server.example.com <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah 123.txt -rw-rw-r-- 1 user user 38M Oct 8 14:21 123.txt</code> </pre><br>  Os dados v√£o, verificamos um servidor com problema <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/ total 7.9M drwxr-xr-x 2 user user 1.0K Oct 8 11:28 . drwxr-xr-x 4 root root 1.0K Oct 8 10:55 .. -rw-rw-r-- 1 user user 7.9M Oct 8 14:17 123.txt prw-rw-r-- 1 user user 0 Oct 8 14:22 megapipe</code> </pre><br>  Dados salvos, problema resolvido. <br><br>  Aproveito esta oportunidade para expressar meus cumprimentos aos meus colegas da Degiro. <br>  Ou√ßa os podcasts da Radio T. <br><br>  Bom para todos. <br><br>  Como li√ß√£o de casa, proponho pensar sobre o que estar√° nos descritores de arquivo do processo cat e sleep se voc√™ executar este comando: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ cat /dev/zero 2&gt;/dev/null| sleep 10000</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471038/">https://habr.com/ru/post/pt471038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471026/index.html">TypeScript Poder nunca</a></li>
<li><a href="../pt471028/index.html">Carrinho de caminh√£o ROS. Parte 6. Odometria com codificadores de roda, mapa da sala, lidar</a></li>
<li><a href="../pt471032/index.html">Foto invis√≠vel</a></li>
<li><a href="../pt471034/index.html">Entrevista com Pornhub Web Developer</a></li>
<li><a href="../pt471036/index.html">Viva e aprenda. Parte 5. Auto-educa√ß√£o: se recomponha</a></li>
<li><a href="../pt471040/index.html">[marcador] Vers√£o em PDF e ePUB do manual React</a></li>
<li><a href="../pt471042/index.html">Solu√ß√£o de problemas com pwnable.kr 25 - otp. Limite de tamanho de arquivo do Linux</a></li>
<li><a href="../pt471044/index.html">Sass MediaScreen - Definindo dispositivos CSS</a></li>
<li><a href="../pt471046/index.html">Stylish Avalonia</a></li>
<li><a href="../pt471048/index.html">React + Mobx: qual √© o objetivo?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>