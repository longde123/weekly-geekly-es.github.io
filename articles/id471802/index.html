<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📭 👌🏻 👘 Singkatnya tentang hak istimewa Linux (kemampuan) ▫️ 🕯️ 🎍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan artikel disiapkan khusus untuk siswa kursus Administrator Linux . 

 Kemampuan yang digunakan semakin banyak berkat sebagian besar untuk Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Singkatnya tentang hak istimewa Linux (kemampuan)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/471802/">  <i>Terjemahan artikel disiapkan khusus untuk siswa kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Administrator Linux</a> .</i> <br><hr><br>  Kemampuan yang digunakan semakin banyak berkat sebagian besar untuk SystemD, Docker, dan orkestra seperti Kubernetes.  Tetapi, bagi saya, dokumentasinya agak rumit untuk dipahami, dan beberapa bagian dari implementasi privilege bagi saya ternyata agak membingungkan, jadi saya memutuskan untuk membagikan pengetahuan saya saat ini dalam artikel singkat ini. <br><br><img src="https://habrastorage.org/webt/mn/gs/zm/mngszmci_2-ufeepev7nfzd3fo8.png"><br><br>  Tautan hak istimewa yang paling penting adalah halaman manual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kapabilitas (7)</a> .  Tapi dia tidak cocok untuk kenalan awal. <a name="habracut"></a><br><br><h3>  Kemampuan proses </h3><br>  Hak pengguna biasa sangat terbatas, sementara hak pengguna "root" sangat luas.  Meskipun proses yang berjalan sebagai "root" seringkali tidak memerlukan semua hak akses root. <br><br>  Untuk mengurangi hak akses root, izin POSIX menyediakan cara untuk membatasi grup operasi sistem yang diistimewakan sehingga proses dan turunannya diizinkan untuk melakukan.  Intinya, mereka membagi semua hak "root" menjadi satu set hak istimewa yang terpisah.  Gagasan kapabilitas dijelaskan pada tahun 1997 dalam konsep POSIX 1003.1e. <br><br>  Di Linux, setiap proses (tugas) memiliki <a href="">lima angka 64-bit</a> (set) yang mengandung bit izin (sebelum Linux 2.6.25 jumlahnya 32-bit), yang dapat dilihat dalam <pre>  / proc / &lt;pid&gt; / status </pre>  . <br><br><pre><code class="bash hljs">CapInh: 00000000000004c0 CapPrm: 00000000000004c0 CapEff: 00000000000004c0 CapBnd: 00000000000004c0 CapAmb: 0000000000000000</code> </pre> <br>  Angka-angka ini (ditampilkan di sini dalam notasi heksadesimal) adalah bitmap di mana set izin diwakili.  Berikut nama lengkap mereka: <br><br><ul><li>  <b>Warisan</b> - Izin yang bisa diwariskan oleh keturunan </li><li>  <b>Diizinkan</b> - Izin yang dapat digunakan oleh tugas. </li><li>  <b>Efektif</b> - izin efektif saat ini </li><li>  <b>Bounding</b> - Sebelum Linux 2.6.25, set pembatas adalah atribut seluruh sistem yang umum untuk semua utas, dirancang untuk menggambarkan set di luar yang izin tidak dapat diperluas.  Saat ini satu set untuk setiap tugas dan hanya bagian dari logika eksekusi, detail di bawah ini. </li><li>  <b>Ambient</b> (eksternal sejak Linux 4.3) - ditambahkan untuk memudahkan memberikan izin non-root kepada pengguna, tanpa menggunakan setuid atau izin file (lebih lanjut tentang itu nanti). </li></ul><br>  Jika suatu tugas meminta operasi istimewa (misalnya, mengikat ke port &lt;1024), kernel memeriksa set batas saat ini untuk <a href="">CAP_NET_BIND_SERVICE</a> .  Jika sudah diinstal, maka operasi berlanjut.  Kalau tidak, operasi ditolak dengan EPERM (operasi tidak diizinkan).  <code>CAP_</code> dalam kode sumber kernel dan diberi nomor secara berurutan, jadi <code>CAP_NET_BIND_SERVICE</code> , sama dengan 10, berarti bit 1 &lt;&lt; 10 = 0x400 (ini adalah digit heksadesimal “4” dalam contoh saya sebelumnya). <br><br>  Daftar hak istimewa yang dapat dibaca oleh manusia yang saat ini didefinisikan dapat ditemukan di halaman manual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemampuan</a> saat ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(7)</a> (daftar di sini hanya untuk referensi). <br><br>  Selain itu, ada perpustakaan libcap untuk menyederhanakan pemeriksaan manajemen dan otorisasi.  Selain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API perpustakaan</a> , paket menyertakan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">capsh</a> , yang, di antaranya, memungkinkan Anda untuk menunjukkan kredensial Anda. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># capsh --print Current: = cap_setgid,cap_setuid,cap_net_bind_service+eip Bounding set = cap_setgid,cap_setuid,cap_net_bind_service Ambient set = Securebits: 00/0x0/1'b0 secure-noroot: no (unlocked) secure-no-suid-fixup: no (unlocked) secure-keep-caps: no (unlocked) secure-no-ambient-raise: no (unlocked) uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)</span></span></code> </pre> <br>  Ada beberapa poin membingungkan di sini: <br><br><ul><li>  <b>Current</b> - menampilkan hak istimewa yang efektif, warisan dan tersedia dari proses capsh dalam format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cap_to_text (3)</a> .  Dalam format ini, hak terdaftar sebagai grup izin <code>“capability[,capability…]+(e|i|p)”</code> , di mana <code>“e”</code> berarti efektif, <code>“i”</code> diwariskan, dan <code>“p”</code> tersedia.  Daftar ini tidak dipisahkan oleh simbol <code>“,”</code> , seperti yang mungkin Anda tebak <code>(cap_setgid+eip, cap_setuid+eip)</code> .  Koma membagi izin dalam satu grup tindakan.  Daftar grup tindakan yang sebenarnya kemudian dipisahkan oleh spasi.  Contoh lain dengan dua grup tindakan adalah <code>“= cap_sys_chroot+ep cap_net_bind_service+eip”</code> .  Dan juga dua grup tindakan berikut <code>“= cap_net_bind_service+e cap_net_bind_service+ip”</code> akan menyandikan nilai yang sama dengan satu <code>“cap_net_bind_service+eip”</code> . </li><li>  <b>Bounding set / Ambient set</b> .  Untuk lebih membingungkan, dua baris ini hanya berisi daftar izin yang ditentukan dalam set ini, dipisahkan oleh spasi.  Format cap_to_text tidak digunakan di sini, karena tidak mengandung set izin yang tersedia, efektif dan diwariskan, tetapi hanya satu set (terikat / ambient). </li><li>  <b>Securebits</b> : menampilkan flag <a href="">securebits</a> dari tugas dalam format desimal / heksadesimal / dalam Verilog (ya, semua orang mengharapkannya di sini, dan ini sangat jelas dari <a href="">titik</a> bahwa setiap administrator sistem memprogram <code>FPGA</code> dan <code>ASIC</code> mereka sendiri).  Berikut ini adalah status keamanan.  Bendera sebenarnya didefinisikan sebagai <code>SECBIT_*</code> di <a href="">securebits.h</a> , dan juga dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemampuan (7)</a> . </li><li>  Utilitas ini tidak memiliki tampilan <b>informasi "NoNewPrivs"</b> , yang dapat dilihat di <pre>  / proc / &lt;pid&gt; / status </pre>  .  Ini disebutkan hanya dalam prctl (2), meskipun secara langsung mempengaruhi hak ketika digunakan bersama dengan izin file (lebih terinci di bawah).  NoNewPrivs dideskripsikan sebagai berikut: <i><i>“Dengan <code>no_new_privs</code> ke 1, execve (2) berjanji untuk tidak memberikan hak istimewa kepada apa yang tidak dapat dilakukan tanpa memanggil execve (2) (misalnya, memproses bit <code>set-user-ID</code> , bit <code>set-group-ID</code> dan menonaktifkan pemrosesan izin file)</i> .</i>  <i>Setelah instalasi, atribut <code>no_new_privs</code> tidak dapat diatur ulang.</i>  <i>Nilai dari atribut ini diwarisi oleh keturunan yang dibuat melalui fork (2) dan clone (2) dan disimpan melalui execve (2). "</i>  Kubernetes menetapkan flag ini ke 1 ketika allowPrivilegeEscalation salah di dalam konteks securityContext. </li></ul><br><br>  Ketika memulai proses baru melalui execve (2), izin untuk proses anak dikonversi menggunakan rumus yang ditentukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemampuan (7)</a> : <br><br><pre> <code class="bash hljs">P<span class="hljs-string"><span class="hljs-string">'(ambient) = (file is privileged) ? 0 : P(ambient) P'</span></span>(permitted) = (P(inheritable) &amp; F(inheritable)) | (F(permitted) &amp; P(bounding)) | P<span class="hljs-string"><span class="hljs-string">'(ambient) P'</span></span>(effective) = F(effective) ? P<span class="hljs-string"><span class="hljs-string">'(permitted) : P'</span></span>(ambient) P<span class="hljs-string"><span class="hljs-string">'(inheritable) = P(inheritable) [ie, unchanged] P'</span></span>(bounding) = P(bounding) [ie, unchanged] <span class="hljs-built_in"><span class="hljs-built_in">where</span></span>: P() denotes the value of a thread capability <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> before the execve(2) -      execve(2) P<span class="hljs-string"><span class="hljs-string">'() denotes the value of a thread capability set after the execve(2) -      execve(2) F() denotes a file capability set -  </span></span></code> </pre> <br><br>  Aturan-aturan ini menjelaskan tindakan yang dilakukan untuk setiap bit di semua set izin (ambient / diizinkan / efektif / inherit / terikat).  Sintaks C standar digunakan (&amp; - untuk logika AND, | - untuk logika OR).  P 'adalah proses anak.  P adalah proses saat ini memanggil execve (2).  F adalah apa yang disebut "izin file" dari file yang diluncurkan melalui execve. <br><br>  Selain itu, suatu proses dapat secara program mengubah set yang diwarisi, diakses, dan efisien dengan libcap setiap saat sesuai dengan aturan berikut: <br><br><ul><li>  Jika penelepon tidak memiliki <code>CAP_SETPCAP</code> , set yang <b>diwarisi</b> baru harus menjadi subset dari P (diwarisi) &amp; P (tersedia) </li><li>  (dengan Linux 2.6.25) Set yang <b>diwarisi</b> baru harus menjadi subset dari P (diwarisi) &amp; P (membatasi) </li><li>  Set yang <b>tersedia</b> baru harus menjadi bagian dari P (tersedia) </li><li>  Set <b>efisien</b> baru harus menjadi bagian dari P (efektif) </li></ul><br><br><h3>  Izin file </h3><br>  Terkadang pengguna dengan serangkaian hak terbatas perlu menjalankan file yang membutuhkan lebih banyak hak istimewa.  Sebelumnya ini dicapai dengan mengatur bit setuid ( <code>chmod + s ./executable</code> ) dalam file biner.  File seperti itu, jika itu milik root, akan memiliki hak root penuh ketika dijalankan oleh pengguna mana pun. <br><br>  Tetapi mekanisme ini memberikan terlalu banyak hak istimewa untuk sebuah file, jadi izin POSIX telah menerapkan konsep yang disebut "izin file".  Mereka disimpan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">atribut file yang diperluas yang</a> disebut "security.capability", jadi Anda memerlukan sistem file dengan dukungan untuk atribut yang diperluas (ext *, XFS, Raiserfs, Brtfs, overlay2, ...).  Untuk mengubah atribut ini, <code>CAP_SETFCAP</code> izin <code>CAP_SETFCAP</code> (dalam set izin proses yang tersedia). <br><br><pre> <code class="bash hljs">$ getfattr -m - -d `<span class="hljs-built_in"><span class="hljs-built_in">which</span></span> ping` <span class="hljs-comment"><span class="hljs-comment"># file: usr/bin/ping security.capability=0sAQAAAgAgAAAAAAAAAAAAAAAAAAA= $ getcap `which ping` /usr/bin/ping = cap_net_raw+ep</span></span></code> </pre> <br><br><h3>  Kasus dan komentar khusus </h3><br>  Tentu saja, dalam kenyataannya, semuanya tidak begitu sederhana, dan ada beberapa kasus khusus yang dijelaskan dalam halaman manual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemampuan (7)</a> .  Mungkin yang paling penting dari mereka adalah: <br><br><ul><li>  <b>Bit setuid dan izin file diabaikan jika NoNewPrivs diinstal</b> atau sistem file di-mount dengan nosuid atau proses panggilan execve dilacak oleh ptrace.  Izin file juga diabaikan ketika kernel melakukan boot dengan opsi <code>no_file_caps</code> . </li><li>  <b>File "bodoh" (kapabilitas-bisu)</b> adalah file biner yang dikonversi dari file setuid ke file dengan izin file, tetapi tanpa mengubah kode sumbernya.  File-file semacam itu sering diperoleh dengan menyetel izin + ep padanya, misalnya, <code>“setcap cap_net_bind_service+ep ./binary”</code> .  Bagian yang penting adalah "e" - efektif.  Setelah dieksekusi, izin ini akan ditambahkan ke yang tersedia dan yang sudah ada, sehingga yang dapat dieksekusi akan siap untuk menggunakan operasi istimewa.  Sebaliknya, file <b>"kapabilitas-cerdas"</b> yang menggunakan libcap atau fungsi serupa dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cap_set_proc (3)</a> (atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">capset</a> ) untuk mengatur bit "efektif" atau "diwariskan" kapan saja jika izin itu sudah ada di " kit ”yang terjangkau.  Oleh karena itu, " <code>setcap cap_net_bind_service+p ./binary”</code> akan cukup untuk file "pintar", karena itu akan dapat mengatur izin yang diperlukan dalam set yang efektif sendiri sebelum menjalankan operasi istimewa.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode contoh</a> . </li><li>  <b>File dengan setuid-root</b> terus berfungsi, memberikan semua hak istimewa root saat pengguna memulai sebagai non-root.  Tetapi jika mereka memiliki izin file yang ditetapkan, maka hanya mereka yang akan diberikan.  Anda juga dapat membuat file setuid dengan set izin kosong, yang akan membuatnya berjalan sebagai pengguna dengan UID 0 tanpa izin apa pun.  Ada kasus-kasus khusus untuk pengguna root ketika menjalankan file dengan setuid-root dan pengaturan berbagai bendera keamanan (lihat man). </li><li>  Set terikat membatasi izin yang tersedia, tetapi tidak yang diwariskan.  Ingat P '(tersedia) = F (tersedia) &amp; P (membatasi).  Jika streaming memiliki <b>izin di set</b> yang <b>diwarisi</b> yang tidak di set yang membatasi, maka ia masih bisa <b>mendapatkan izin ini di</b> set yang <b>tersedia</b> dengan menjalankan file yang memiliki izin di set yang diwarisi - P '(tersedia) = P ( diwarisi) &amp; F (diwarisi). </li><li>  Menjalankan program yang mengubah UID atau GID melalui bit set-user-ID, set-group-ID, atau menjalankan program yang <b>mengatur</b> izin file apa pun <b>akan menghapus set ambient</b> .  Izin ditambahkan ke <b>set sekitarnya</b> menggunakan <code>PR_CAP_AMBIENT</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prctl</a> .  Izin ini harus sudah ada dalam <b>set</b> proses yang <b>dapat diakses dan diwariskan</b> . </li><li>  Jika suatu proses dengan <b>UID selain 0 dijalankan mengeksekusi (2)</b> , maka semua hak dalam set yang tersedia dan aktif akan dihapus. </li><li>  Jika <code>SECBIT_KEEP_CAPS</code> (atau <code>SECBIT_NO_SETUID_FIXUP</code> lebih luas) tidak disetel, dan <b>mengubah UID dari 0 menjadi bukan nol menghapus semua izin dari set yang diwarisi, dapat diakses, dan efektif</b> . </li></ul><br><br><h3>  Jadi ... </h3><br>  Jika wadah nginx resmi, ingress-nginx atau Anda sendiri berhenti atau memulai kembali dengan kesalahan: <br><br> <code>bind() to 0.0.0.0:80 failed (13: Permission denied)</code> <br> <br>  ... ini berarti ada upaya untuk mendengarkan pada port 80 sebagai pengguna (bukan 0) yang tidak memiliki hak, dan tidak ada <code>CAP_NET_BIND_SERVICE</code> dalam <code>CAP_NET_BIND_SERVICE</code> izin saat ini.  Untuk mendapatkan hak-hak ini, Anda harus menggunakan xattr dan set (menggunakan <code>setcap</code> ) untuk izin file nginx setidaknya <code>cap_net_bind_service+ie</code> .  Izin file ini akan digabungkan dengan set lawas (ditentukan dengan set pembatas dari pod SecurityContext / kapabilitas / tambahkan / NET_BIND_SERVICE), dan juga akan ditempatkan dalam set izin yang tersedia.  Hasilnya adalah <code>cap_net_bind_service+pie</code> . <br><br>  Ini semua berfungsi selama securityContext / allowPrivilegeEscalation disetel ke true dan driver penyimpanan buruh pelabuhan / rkt (lihat dokumentasi buruh pelabuhan) mendukung xattrs. <br><br>  Jika nginx pintar sehubungan dengan izin, maka <code>cap_net_bind_service+i</code> akan cukup.  Kemudian dia bisa menggunakan libcap untuk memperluas hak dari set yang tersedia menjadi efektif.  Setelah menerima <code>cap_net_bind_service+pie</code> hasilnya. <br><br>  Selain menggunakan xattr, satu-satunya cara untuk mendapatkan <code>cap_net_bind_service</code> dalam wadah non-root adalah membiarkan Docker mengatur kemampuan eksternal (kemampuan ambient).  Tetapi pada April 2019, ini belum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dilaksanakan</a> . <br><br><h3>  Contoh kode </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut adalah contoh kode</a> menggunakan libcap untuk menambahkan <code>CAP_NET_BIND_SERVICE</code> ke set izin yang efisien.  Dibutuhkan <code>CAP_BIND_SERVICE+p</code> izin untuk file biner. <br><br>  Referensi (bahasa Inggris): <br><br><ul><li>  halaman manual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemampuan (7)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber kernel Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode Sumber Libcap</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FAQ Kemampuan Lama</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471802/">https://habr.com/ru/post/id471802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471776/index.html">Laravel: jelaskan konsep dasarnya. Bagian Dua: Berlatih</a></li>
<li><a href="../id471778/index.html">Memecah Micosoft Lunix di HackQuest 2019</a></li>
<li><a href="../id471792/index.html">Dari mana datangnya Wizard dari "Ordinary Miracle"</a></li>
<li><a href="../id471794/index.html">Era mikrofon plafon datar</a></li>
<li><a href="../id471796/index.html">Sedikit pengalaman - banyak wawancara: bagaimana melakukan wawancara tim</a></li>
<li><a href="../id471806/index.html">Bagaimana pencahayaan memengaruhi desain game dan pengalaman bermain game</a></li>
<li><a href="../id471808/index.html">Relay GSM mandiri dengan inverter dari komponen yang dibuat sebelumnya</a></li>
<li><a href="../id471810/index.html">Bandingkan alat untuk mengaudit perubahan di Active Directory: Quest Change Auditor dan Netwrix Auditor</a></li>
<li><a href="../id471812/index.html">Perpustakaan Mesin Wolfram Gratis untuk Pengembang Perangkat Lunak</a></li>
<li><a href="../id471814/index.html">WolframClientForPython | Perpustakaan Klien Bahasa Wolfram Baru untuk Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>