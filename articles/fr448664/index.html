<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∑üèº üì¢ üåÖ Cr√©er des cartes comme Tinder sur Swift üîô üàÅ üèπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tinder - nous savons tous qu'il s'agit d'une application de rencontres o√π vous pouvez simplement rejeter ou accepter quelqu'un en balayant vers la gau...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©er des cartes comme Tinder sur Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448664/"><img src="https://habrastorage.org/getpro/habr/post_images/2b7/15f/817/2b715f8176b64a1ccc7ec9afd35f7028.png" alt="image"><br><br>  Tinder - nous savons tous qu'il s'agit d'une application de rencontres o√π vous pouvez simplement rejeter ou accepter quelqu'un en balayant vers la gauche ou la droite.  Cette id√©e de lecteur de carte est maintenant utilis√©e dans des tonnes d'applications.  Cette fa√ßon d'afficher les donn√©es est pour vous si vous en avez assez d'utiliser les vues de table et de collection.  Il existe de nombreux manuels sur ce sujet, mais ce projet m'a pris beaucoup de temps. <br><a name="habracut"></a><br>  Vous pouvez voir le projet complet sur mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . <br><br>  Tout d'abord, je voudrais rendre hommage √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publication de</a> Phill Farrugia sur ce sujet, puis √† la s√©rie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">YouTube</a> du studio Big Mountain sur un sujet similaire.  Alors, comment faisons-nous cette interface?  J'ai obtenu de l'aide pour publier Phil sur ce sujet.  Essentiellement, l'id√©e est de cr√©er des UIViews et de les ins√©rer en tant que sous-vues dans la vue du conteneur.  Ensuite, en utilisant l'index, nous donnerons √† chaque UIView une insertion horizontale et verticale et changerons l√©g√®rement sa largeur.  De plus, lorsque nous faisons glisser un doigt sur une carte, tous les cadres des vues sont r√©organis√©s conform√©ment √† la nouvelle valeur d'index. <br><br>  Nous allons commencer par cr√©er une vue conteneur dans un simple ViewController. <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//MARK: - Properties var viewModelData = [CardsDataModel(bgColor: UIColor(red:0.96, green:0.81, blue:0.46, alpha:1.0), text: "Hamburger", image: "hamburger"), CardsDataModel(bgColor: UIColor(red:0.29, green:0.64, blue:0.96, alpha:1.0), text: "Puppy", image: "puppy"), CardsDataModel(bgColor: UIColor(red:0.29, green:0.63, blue:0.49, alpha:1.0), text: "Poop", image: "poop"), CardsDataModel(bgColor: UIColor(red:0.69, green:0.52, blue:0.38, alpha:1.0), text: "Panda", image: "panda"), CardsDataModel(bgColor: UIColor(red:0.90, green:0.99, blue:0.97, alpha:1.0), text: "Subway", image: "subway"), CardsDataModel(bgColor: UIColor(red:0.83, green:0.82, blue:0.69, alpha:1.0), text: "Robot", image: "robot")] var stackContainer : StackContainerView! //MARK: - Init override func loadView() { view = UIView() view.backgroundColor = UIColor(red:0.93, green:0.93, blue:0.93, alpha:1.0) stackContainer = StackContainerView() view.addSubview(stackContainer) configureStackContainer() stackContainer.translatesAutoresizingMaskIntoConstraints = false configureNavigationBarButtonItem() } override func viewDidLoad() { super.viewDidLoad() title = "Expense Tracker" stackContainer.dataSource = self } //MARK: - Configurations func configureStackContainer() { stackContainer.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true stackContainer.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: -60).isActive = true stackContainer.widthAnchor.constraint(equalToConstant: 300).isActive = true stackContainer.heightAnchor.constraint(equalToConstant: 400).isActive = true }</span></span></code> </pre> <br>  Comme vous pouvez le voir, j'ai cr√©√© ma propre classe appel√©e SwipeContainerView et viens de configurer stackViewContainer √† l'aide de contraintes automatiques.  Rien √† craindre.  La taille de SwipeContainerView sera de 300 x 400, et elle sera centr√©e sur l'axe X et √† seulement 60 pixels au-dessus du milieu de l'axe Y. <br><br>  Maintenant que nous avons configur√© stackContainer, nous allons passer √† la sous-classe de StackContainerView et y charger toutes sortes de cartes.  Avant cela, nous allons cr√©er un protocole qui aura trois m√©thodes: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwipeCardsDataSource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">numberOfCardsToShow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">card</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emptyView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> }</code> </pre> <br>  Consid√©rez ce protocole comme une TableViewDataSource.  La conformit√© de notre classe ViewController avec ce protocole permettra de transf√©rer des informations sur nos donn√©es √† la classe SwipeCardContainer.  Il a trois m√©thodes: <br><br><ol><li>  <code>numberOfCardsToShow () -&gt; Int</code> : Renvoie le nombre de cartes que nous devons montrer.  Ce n'est qu'un compteur de tableau de donn√©es. </li><li>  <code>card(at index: Int) -&gt; SwipeCardView</code> : retourne SwipeCardView (nous allons cr√©er cette classe en un instant) </li><li>  <code>EmptyView</code> -&gt; Nous ne ferons rien avec, mais d√®s que toutes les cartes seront supprim√©es, l'appel de cette m√©thode d√©l√©gu√©e renverra une vue vide avec un message (je n'impl√©menterai pas cela dans cette le√ßon sp√©cifique, essayez-le vous-m√™me) </li></ol><br>  Alignez le contr√¥leur de vue avec ce protocole: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwipeCardsDataSource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">numberOfCardsToShow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewModelData.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">card</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> card = <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span>() card.dataSource = viewModelData[index] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> card } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emptyView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  La premi√®re m√©thode renvoie le nombre d'√©l√©ments dans le tableau de donn√©es.  Dans la deuxi√®me m√©thode, cr√©ez une nouvelle instance SwipeCardView () et envoyez les donn√©es du tableau pour cet index, puis renvoyez l'instance SwipeCardView. <br><br>  SwipeCardView est une sous-classe de UIView qui a UIImage, UILabel et un identificateur de mouvement.  Plus d'informations √† ce sujet plus tard.  Nous utiliserons ce protocole pour communiquer avec la pr√©sentation du conteneur. <br><br><pre> <code class="swift hljs">stackContainer.dataSource = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span></code> </pre> <br>  Lorsque le code ci-dessus se d√©clenche, la fonction reloadData est appel√©e, qui appelle ensuite ces fonctions de source de donn√©es. <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Class</span></span> <span class="hljs-type"><span class="hljs-type">StackViewContainer</span></span>: <span class="hljs-type"><span class="hljs-type">UIView</span></span> { . . <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataSource: <span class="hljs-type"><span class="hljs-type">SwipeCardsDataSource?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { reloadData() } } ....</code> </pre> <br>  Fonction ReloadData: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reloadData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> datasource = dataSource <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } setNeedsLayout() layoutIfNeeded() numberOfCardsToShow = datasource.numberOfCardsToShow() remainingcards = numberOfCardsToShow <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(numberOfCardsToShow,cardsToBeVisible) { addCardView(cardView: datasource.card(at: i), atIndex: i ) } }</code> </pre> <br>  Dans la fonction reloadData, nous obtenons d'abord le nombre de cartes et le stockons dans la variable numberOfCardsToShow.  Ensuite, nous attribuons cela √† une autre variable nomm√©e restantCartes.  Dans la boucle for, nous cr√©ons une carte qui est une instance de SwipeCardView en utilisant la valeur d'index. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(numberOfCardsToShow,cardsToBeVisible) { addCardView(cardView: datasource.card(at: i), atIndex: i ) }</code> </pre> <br>  En fait, nous voulons que moins de 3 cartes apparaissent √† la fois.  Par cons√©quent, nous utilisons la fonction min.  CardsToBeVisible est une constante √©gale √† 3. Si numberOfToShow est sup√©rieur √† 3, alors seulement trois cartes seront affich√©es.  Nous cr√©ons ces cartes √† partir du protocole: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">card</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span></code> </pre> <br>  La fonction addCardView () est simplement utilis√©e pour ins√©rer des cartes en tant que sous-vues. <br><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addCardView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cardView: SwipeCardView, atIndex index: Int)</span></span></span></span> { cardView.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addCardFrame(index: index, cardView: cardView) cardViews.append(cardView) insertSubview(cardView, at: <span class="hljs-number"><span class="hljs-number">0</span></span>) remainingcards -= <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Dans cette fonction, nous ajoutons cardView √† la hi√©rarchie des vues, et en ajoutant des cartes comme sous-vue, nous r√©duisons les cartes restantes de 1. D√®s que nous ajoutons cardView en tant que sous-vue, nous d√©finissons le cadre de ces cartes.  Pour ce faire, nous utilisons une autre fonction addCardFrame (): <br><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addCardFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index: Int, cardView: SwipeCardView)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cardViewFrame = bounds <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> horizontalInset = (<span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(index) * <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.horizontalInset) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> verticalInset = <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(index) * <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.verticalInset cardViewFrame.size.width -= <span class="hljs-number"><span class="hljs-number">2</span></span> * horizontalInset cardViewFrame.origin.x += horizontalInset cardViewFrame.origin.y += verticalInset cardView.frame = cardViewFrame }</code> </pre> <br>  Cette logique addCardFrame () est tir√©e directement de la publication de Phil.  Ici, nous d√©finissons le cadre de la carte en fonction de son index.  La premi√®re carte avec l'index 0 aura un cadre, tout comme un conteneur.  Ensuite, nous modifions l'origine du cadre et la largeur de la carte en fonction de l'insert.  Ainsi, nous ajoutons la carte un peu √† droite de la carte ci-dessus, r√©duisons sa largeur et tirons √©galement n√©cessairement les cartes vers le bas pour cr√©er l'impression que les cartes sont empil√©es les unes sur les autres. <br><br>  Une fois cela fait, vous verrez que les cartes sont empil√©es les unes sur les autres.  Assez bien! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bee/8f0/83e/bee8f083e7dfc5e9dbc70ed6a95d398a.png" alt="image"><br><br>  Cependant, nous devons maintenant ajouter un geste de balayage √† la vue de la carte.  Tournons maintenant notre attention vers la classe SwipeCardView. <br><br><h3>  SwipeCardView </h3><br>  La classe swipeCardView est une sous-classe r√©guli√®re d'UIView.  Cependant, pour des raisons connues uniquement des ing√©nieurs d'Apple, il est incroyablement difficile d'ajouter des ombres √† une UIView avec un coin arrondi.  Pour ajouter des ombres aux vues de carte, je cr√©e deux UIViews.  L'un d'eux est shadowView, puis swipeView.  En substance, shadowView a une ombre et c'est tout.  SwipeView a des coins arrondis.  Sur swipeView, j'ai ajout√© UIImageView, un UILabel pour pr√©senter les donn√©es et les images. <br><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> swipeView : <span class="hljs-type"><span class="hljs-type">UIView!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shadowView : <span class="hljs-type"><span class="hljs-type">UIView!</span></span></code> </pre> <br>  D√©finition de shadowView et de swipeView: <br><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureShadowView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { shadowView = <span class="hljs-type"><span class="hljs-type">UIView</span></span>() shadowView.backgroundColor = .clear shadowView.layer.shadowColor = <span class="hljs-type"><span class="hljs-type">UIColor</span></span>.black.cgColor shadowView.layer.shadowOffset = <span class="hljs-type"><span class="hljs-type">CGSize</span></span>(width: <span class="hljs-number"><span class="hljs-number">0</span></span>, height: <span class="hljs-number"><span class="hljs-number">0</span></span>) shadowView.layer.shadowOpacity = <span class="hljs-number"><span class="hljs-number">0.8</span></span> shadowView.layer.shadowRadius = <span class="hljs-number"><span class="hljs-number">4.0</span></span> addSubview(shadowView) shadowView.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal"><span class="hljs-literal">false</span></span> shadowView.leftAnchor.constraint(equalTo: leftAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> shadowView.rightAnchor.constraint(equalTo: rightAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> shadowView.bottomAnchor.constraint(equalTo: bottomAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> shadowView.topAnchor.constraint(equalTo: topAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureSwipeView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { swipeView = <span class="hljs-type"><span class="hljs-type">UIView</span></span>() swipeView.layer.cornerRadius = <span class="hljs-number"><span class="hljs-number">15</span></span> swipeView.clipsToBounds = <span class="hljs-literal"><span class="hljs-literal">true</span></span> shadowView.addSubview(swipeView) swipeView.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal"><span class="hljs-literal">false</span></span> swipeView.leftAnchor.constraint(equalTo: shadowView.leftAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> swipeView.rightAnchor.constraint(equalTo: shadowView.rightAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> swipeView.bottomAnchor.constraint(equalTo: shadowView.bottomAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> swipeView.topAnchor.constraint(equalTo: shadowView.topAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  J'ai ensuite ajout√© un identificateur de gestes √† ce type de carte et la fonction de s√©lection est appel√©e reconnaissance.  Cette fonction de s√©lection a beaucoup de logique pour le d√©filement, l'inclinaison, etc.  Voyons voir: <br><br><pre> <code class="swift hljs"> <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handlePanGesture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sender: UIPanGestureRecognizer)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> card = sender.view <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = sender.translation(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> centerOfParentContainer = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.height / <span class="hljs-number"><span class="hljs-number">2</span></span>) card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x, y: centerOfParentContainer.y + point.y) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> sender.state { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .ended: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.center.x) &gt; <span class="hljs-number"><span class="hljs-number">400</span></span> { delegate?.swipeDidEnd(on: card) <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x + <span class="hljs-number"><span class="hljs-number">200</span></span>, y: centerOfParentContainer.y + point.y + <span class="hljs-number"><span class="hljs-number">75</span></span>) card.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> card.center.x &lt; -<span class="hljs-number"><span class="hljs-number">65</span></span> { delegate?.swipeDidEnd(on: card) <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x - <span class="hljs-number"><span class="hljs-number">200</span></span>, y: centerOfParentContainer.y + point.y + <span class="hljs-number"><span class="hljs-number">75</span></span>) card.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.transform = .identity card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.height / <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .changed: <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rotation = tan(point.x / (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width * <span class="hljs-number"><span class="hljs-number">2.0</span></span>)) card.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(rotationAngle: rotation) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } }</code> </pre> <br>  Les quatre premi√®res lignes du code ci-dessus: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> card = sender.view <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = sender.translation(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> centerOfParentContainer = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.height / <span class="hljs-number"><span class="hljs-number">2</span></span>) card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x, y: centerOfParentContainer.y + point.y)</code> </pre> <br>  Nous avons d'abord l'id√©e par laquelle le geste a √©t√© tenu.  Ensuite, nous utilisons la m√©thode de transfert pour savoir combien de fois l'utilisateur a frapp√© la carte.  La troisi√®me ligne obtient essentiellement le milieu du conteneur parent.  La derni√®re ligne o√π nous installons card.center.  Lorsque l'utilisateur glisse un doigt sur la carte, le centre de la carte est augment√© de la valeur traduite de x et de la valeur traduite de y.  Pour obtenir ce comportement d'accrochage, nous changeons consid√©rablement le point central de la carte √† partir de coordonn√©es fixes.  Une fois la traduction des gestes termin√©e, nous la renvoyons √† card.center. <br><br>  Dans le cas de state.ended: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.center.x) &gt; <span class="hljs-number"><span class="hljs-number">400</span></span> { delegate?.swipeDidEnd(on: card) <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x + <span class="hljs-number"><span class="hljs-number">200</span></span>, y: centerOfParentContainer.y + point.y + <span class="hljs-number"><span class="hljs-number">75</span></span>) card.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> card.center.x &lt; -<span class="hljs-number"><span class="hljs-number">65</span></span> { delegate?.swipeDidEnd(on: card) <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x - <span class="hljs-number"><span class="hljs-number">200</span></span>, y: centerOfParentContainer.y + point.y + <span class="hljs-number"><span class="hljs-number">75</span></span>) card.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  Nous v√©rifions si card.center.x est sup√©rieur √† 400 ou si card.center.x est inf√©rieur √† -65.  Si c'est le cas, nous d√©faussons ces cartes, en changeant le centre. <br><br>  Si vous glissez vers la droite: <br><br><pre> <code class="plaintext hljs">card.center = CGPoint(x: centerOfParentContainer.x + point.x + 200, y: centerOfParentContainer.y + point.y + 75)</code> </pre> <br>  Si balayez vers la gauche: <br><br><pre> <code class="plaintext hljs">card.center = CGPoint(x: centerOfParentContainer.x + point.x - 200, y: centerOfParentContainer.y + point.y + 75)</code> </pre> <br>  Si l'utilisateur termine le geste au milieu entre 400 et -65, nous r√©initialiserons le centre de la carte.  Nous appelons √©galement la m√©thode d√©l√©gu√©e √† la fin du balayage.  Plus d'informations √† ce sujet plus tard. <br><br>  Pour obtenir cette inclinaison lorsque vous faites glisser la carte;  Je serai brutalement honn√™te.  J'ai utilis√© un peu de g√©om√©trie et utilis√© diff√©rentes valeurs de la perpendiculaire et de la base, puis j'ai utilis√© la fonction bronzage pour obtenir l'angle de rotation.  Encore une fois, ce n'√©tait que des essais et des erreurs.  L'utilisation de point.x et de la largeur du conteneur comme deux p√©rim√®tres semblait bien fonctionner.  N'h√©sitez pas √† exp√©rimenter ces valeurs. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .changed: <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rotation = tan(point.x / (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width * <span class="hljs-number"><span class="hljs-number">2.0</span></span>)) card.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(rotationAngle: rotation)</code> </pre> <br>  Parlons maintenant de la fonction d√©l√©gu√©e.  Nous utiliserons la fonction d√©l√©gu√©e pour communiquer entre SwipeCardView et ContainerView. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwipeCardsDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swipeDidEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(on view: SwipeCardView)</span></span></span></span> }</code> </pre> <br>  Cette fonction prendra en compte le type dans lequel le balayage s'est produit, et nous prendrons plusieurs mesures pour le supprimer des sous-vues, puis refaire tous les cadres pour les cartes en dessous.  Voici comment: <br><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swipeDidEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(on view: SwipeCardView)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> datasource = dataSource <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } view.removeFromSuperview() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> remainingcards &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIndex = datasource.numberOfCardsToShow() - remainingcards addCardView(cardView: datasource.card(at: newIndex), atIndex: <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cardIndex, cardView) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visibleCards.reversed().enumerated() { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>, animations: { cardView.center = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.center <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addCardFrame(index: cardIndex, cardView: cardView) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() }) } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cardIndex, cardView) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visibleCards.reversed().enumerated() { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>, animations: { cardView.center = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.center <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addCardFrame(index: cardIndex, cardView: cardView) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() }) } } }</code> </pre> <br>  Supprimez d'abord cette vue de la super vue.  Une fois cela fait, v√©rifiez s'il reste une carte.  Si tel est le cas, nous cr√©erons un nouvel index pour la carte √† cr√©er.  Nous allons cr√©er newIndex en soustrayant le nombre total de cartes √† afficher avec le reste des cartes.  Ensuite, nous ajouterons la carte en tant que sous-vue.  Cependant, cette nouvelle carte sera la plus basse, donc les 2 que nous enverrons garantiront essentiellement que la trame que vous ajoutez correspond √† l'index 2 ou au plus bas. <br><br>  Pour animer les cadres des cartes restantes, nous utiliserons l'index de sous-vue.  Pour ce faire, nous allons cr√©er un tableau visibleCards, qui contiendra toutes les sous-vues du conteneur sous forme de tableau. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visibleCards: [<span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> subviews <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? [<span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span>] ?? [] }</code> </pre> <br>  Le probl√®me, cependant, est que le tableau visibleCards aura un index de sous-vue invers√©.  Ainsi, la premi√®re carte sera troisi√®me, la seconde restera en deuxi√®me position et la troisi√®me sera en premi√®re position.  Pour √©viter que cela ne se produise, nous ex√©cuterons le tableau visibleCards dans l'ordre inverse pour obtenir l'index de sous-vue r√©el, et non la fa√ßon dont ils se trouvent dans le tableau visibleCards. <br><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cardIndex, cardView) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visibleCards.reversed().enumerated() { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>, animations: { cardView.center = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.center <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addCardFrame(index: cardIndex, cardView: cardView) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() }) }</code> </pre> <br>  Alors maintenant, nous mettrons √† jour les cadres du reste de cardViews. <br><br>  C‚Äôest tout.  C'est un moyen id√©al pour pr√©senter une petite quantit√© de donn√©es. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448664/">https://habr.com/ru/post/fr448664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448652/index.html">Mozilla WebThings sur Raspberry Pi - pour commencer</a></li>
<li><a href="../fr448654/index.html">Mozilla WebThings - Configuration de la passerelle</a></li>
<li><a href="../fr448656/index.html">Big Brother regarde ... lui-m√™me ou une carte avec l'historique des mouvements dans HomeAssistant</a></li>
<li><a href="../fr448658/index.html">Que peut-on faire via le connecteur OBD dans la voiture</a></li>
<li><a href="../fr448662/index.html">"Russia 404": une option non visible</a></li>
<li><a href="../fr448668/index.html">Agile: le plus gros probl√®me id√©ologique en informatique</a></li>
<li><a href="../fr448670/index.html">Conception d'interface embarqu√©e</a></li>
<li><a href="../fr448672/index.html">Webinaire - Authentification √† deux facteurs et ES dans l'infrastructure VMware Horizon View √† l'aide des produits Aladdin R.D.</a></li>
<li><a href="../fr448674/index.html">Mousse et mammouths (partie 2)</a></li>
<li><a href="../fr448676/index.html">Surveillance de la m√©t√©o √† Grafana</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>