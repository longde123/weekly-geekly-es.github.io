<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöï üå•Ô∏è üìî Architekturvorlage ‚ÄûMakro-Shared-Transaktionen f√ºr Microservices‚Äú üëåüèø üßóüèΩ üë∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gepostet von Denis Tsyplakov , Solution Architect, DataArt 

 Erkl√§rung des Problems 
 Eines der Probleme beim Erstellen von Microservice-Architekture...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Architekturvorlage ‚ÄûMakro-Shared-Transaktionen f√ºr Microservices‚Äú</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dataart/blog/446288/"><img src="https://habrastorage.org/webt/wn/ge/nc/wngencs0zvmck2rkwblk1hxldms.png"><br><br>  <i>Gepostet von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Denis Tsyplakov</a> , Solution Architect, DataArt</i> <br><br><h2>  Erkl√§rung des Problems </h2><br>  Eines der Probleme beim Erstellen von Microservice-Architekturen und insbesondere beim Migrieren einer monolithischen Architektur zu Microservices sind h√§ufig Transaktionen.  Jeder Mikrodienst ist f√ºr seine eigene Gruppe von Funktionen verantwortlich, steuert m√∂glicherweise die dieser Gruppe zugeordneten Daten und kann Benutzeranforderungen entweder autonom oder durch Senden von Anforderungen an andere Mikrodienste bedienen.  All dies funktioniert einwandfrei, bis wir die Konsistenz der Daten sicherstellen m√ºssen, die von verschiedenen Microservices gesteuert werden. <a name="habracut"></a><br><br>  Zum Beispiel funktioniert unsere Anwendung in einem gro√üen Online-Shop.  Unter anderem haben wir drei separate, schwach miteinander verbundene Gesch√§ftsbereiche: <br><br><ol><li>  Lager - was, wo, wie und wie lange es gelagert wurde, wie viele Waren eines bestimmten Typs derzeit auf Lager sind usw. </li><li>  Versand von Waren - Verpackung, Versand, Sendungsverfolgung, Analyse von Beschwerden √ºber die Verz√∂gerung usw. </li><li>  Durchf√ºhrung einer Zollberichterstattung √ºber den Warenverkehr, wenn die Waren ins Ausland geschickt werden (tats√§chlich wei√ü ich nicht, ob in diesem Fall etwas Besonderes erstellt werden muss, aber ich werde die staatlichen Dienste dennoch mit dem Prozess verbinden, um Drama hinzuzuf√ºgen). </li></ol><br>  Jeder dieser drei Bereiche enth√§lt viele disjunkte Funktionen und kann als mehrere Mikrodienste dargestellt werden. <br><br>  Es gibt ein Problem.  Angenommen, eine Person hat ein Produkt gekauft, verpackt und per Kurier verschickt.  Unter anderem m√ºssen wir darauf hinweisen, dass sich eine Wareneinheit weniger im Lager befindet, um festzustellen, dass der Prozess der Warenlieferung begonnen hat, und wenn die Waren beispielsweise nach China geschickt werden, um die Papiere f√ºr den Zoll zu erledigen.  Wenn die Anwendung in der zweiten oder dritten Phase des Prozesses abst√ºrzt (z. B. ein Knoten abst√ºrzt), werden unsere Daten in einen inkonsistenten Zustand versetzt, und nur wenige solcher Fehler k√∂nnen zu recht unangenehmen Problemen f√ºr das Unternehmen f√ºhren (z. B. ein Besuch von Zollbeamten). <br><br>  In einer klassischen monolithischen Architektur dieser Art wird das Problem einfach und elegant durch Transaktionen in der Datenbank gel√∂st.  Aber was ist, wenn wir Microservices verwenden?  Selbst wenn wir von allen Diensten dieselbe Datenbank verwenden (was nicht sehr elegant ist, aber in unserem Fall m√∂glich ist), stammt die Arbeit mit dieser Datenbank aus verschiedenen Prozessen, und wir k√∂nnen die Transaktion zwischen den Prozessen nicht verl√§ngern. <br><br><h2>  L√∂sungen </h2><br>  Das Problem hat mehrere L√∂sungen: <br><br><ol><li>  Seltsamerweise kann das Problem manchmal ignoriert werden.  Wenn wir wissen, dass ein Fehler nicht mehr als einmal im Monat auftritt und die manuelle Beseitigung der Folgen f√ºr das Unternehmen akzeptables Geld kostet, k√∂nnen Sie das Problem nicht ber√ºcksichtigen, egal wie h√§sslich es aussehen mag.  Ich wei√ü nicht, ob es m√∂glich ist, die Forderungen des Zolldienstes zu ignorieren, aber es kann davon ausgegangen werden, dass dies auch unter bestimmten Umst√§nden m√∂glich ist. </li><li> Die Entsch√§digung (hier geht es nicht um eine finanzielle Entsch√§digung des Zolls, zum Beispiel, wenn Sie eine Geldstrafe gezahlt haben) ist eine Gruppe verschiedener Arten von Schritten, die die Verarbeitungssequenz komplizieren, es Ihnen jedoch erm√∂glichen, einen fehlgeschlagenen Prozess zu erkennen und zu verarbeiten.  Zum Beispiel schreiben wir vor Beginn des Vorgangs an einen speziellen Dienst, dass wir den Versandvorgang starten, und am Ende markieren wir, dass alles gut geendet hat.  Anschlie√üend √ºberpr√ºfen wir regelm√§√üig, ob ausstehende Vorg√§nge vorhanden sind, und versuchen, die Daten in einen konsistenten Zustand zu versetzen, wenn alle drei Datenbanken untersucht werden.  Dies ist eine vollst√§ndig funktionierende Methode, die jedoch die Verarbeitungslogik erheblich verkompliziert, und dies f√ºr jede Operation ist ziemlich schmerzhaft. </li><li>  Genau genommen ist die XA + -Spezifikation, mit der Sie Transaktionen erstellen k√∂nnen, die relativ zu Anwendungen verteilt sind, ein sehr schwerer Mechanismus, den nur wenige Benutzer m√∂gen und, was noch wichtiger ist, nur wenige Benutzer konfigurieren k√∂nnen.  Dar√ºber hinaus ist es mit leichten Mikrodiensten ideologisch schwach kompatibel. </li><li>  Im Prinzip ist eine Transaktion ein Sonderfall des Konsensproblems, und zahlreiche verteilte Konsenssysteme k√∂nnen verwendet werden, um das Problem zu l√∂sen (grob gesagt, alles, was mit den Schl√ºsselw√∂rtern paxos, raft, zookeeper usw., consul googelt).  In der praktischen Anwendung f√ºr umfangreiche und verzweigte Daten der Lageraktivit√§t sieht dies jedoch noch komplizierter aus als bei zweiphasigen Transaktionen. </li><li>  Warteschlangen und eventuelle Konsistenz (Konsistenz auf lange Sicht) - Wir teilen die Aufgabe in drei asynchrone Aufgaben auf, verarbeiten die Daten nacheinander, √ºbergeben sie zwischen den Diensten von der Warteschlange an die Warteschlange und verwenden den √úbermittlungsbest√§tigungsmechanismus.  In diesem Fall ist der Code nicht sehr kompliziert, aber es gibt einige Punkte zu beachten: <br><ul><li>  Die Warteschlange garantiert die Zustellung "einmal oder mehrmals", dh bei erneuter Zustellung derselben Nachricht muss der Dienst diese Situation korrekt behandeln und darf die Waren nicht zweimal versenden.  Dies kann beispielsweise √ºber die eindeutige UUID der Bestellung erfolgen. </li><li>  Die Daten zu einem bestimmten Zeitpunkt sind leicht inkonsistent.  Das hei√üt, die Ware verschwindet zuerst aus dem Lager und erst dann wird mit einer leichten Verz√∂gerung eine Bestellung f√ºr den Versand erstellt.  Sp√§ter werden die Zolldaten verarbeitet.  In unserem Beispiel ist dies v√∂llig normal und verursacht keine Probleme f√ºr das Unternehmen. Es gibt jedoch F√§lle, in denen ein solches Datenverhalten sehr unangenehm sein kann. </li><li>  Wenn der allererste Dienst infolgedessen einige Daten an den Benutzer zur√ºckgeben muss, kann die Reihenfolge der Aufrufe, die die Daten letztendlich an den Browser des Benutzers liefern, nicht trivial sein.  Das Hauptproblem besteht darin, dass der Browser Anforderungen synchron sendet und normalerweise eine synchrone Antwort erwartet.  Wenn Sie eine asynchrone Anforderungsverarbeitung durchf√ºhren, m√ºssen Sie eine asynchrone √úbermittlung der Antwort an den Browser erstellen.  Klassischerweise erfolgt dies entweder √ºber Web-Sockets oder durch regelm√§√üige Anfragen nach neuen Ereignissen vom Browser an den Server.  Es gibt Mechanismen wie beispielsweise SocksJS, die einige Aspekte des Aufbaus dieser Verbindung vereinfachen, aber es wird immer noch zus√§tzliche Komplexit√§t geben. </li></ul></li></ol><br>  In den meisten F√§llen ist die letztere Option am akzeptabelsten.  Die Verarbeitungsanforderung wird zwar nicht sehr kompliziert, obwohl sie mehrmals l√§nger funktioniert. In der Regel ist dies f√ºr diese Art von Vorgang jedoch akzeptabel.  Es erfordert auch eine etwas komplexere Datenorganisation, um wiederholte Anforderungen auszuschlie√üen, aber auch daran ist nichts besonders Kompliziertes. <br><br>  Schematisch kann eine der Optionen f√ºr die Verarbeitung von Transaktionen mithilfe von Warteschlangen und eventueller Konsistenz folgenderma√üen aussehen: <br><br><ol><li>  Der Benutzer hat einen Kauf get√§tigt, eine Nachricht dar√ºber wird an die Warteschlange gesendet (z. B. ein RabbitMQ-Cluster oder, wenn wir in der Google Cloud Platform arbeiten - Pub / Sub).  Die Warteschlange ist persistent, garantiert die Zustellung ein- oder mehrmals und ist transaktional. Wenn der Dienst, der die Nachricht verarbeitet, pl√∂tzlich unterbrochen wird, geht die Nachricht nicht verloren, sondern wird erneut an eine neue Instanz des Dienstes √ºbermittelt. </li><li>  Die Nachricht kommt beim Service an, der die Waren im Lager als versandbereit kennzeichnet und die Nachricht ‚ÄûDie Waren sind versandbereit‚Äú an die Warteschlange sendet. </li><li>  Im n√§chsten Schritt erh√§lt der f√ºr den Versand zust√§ndige Dienst eine Nachricht √ºber die Versandbereitschaft, erstellt eine Versandaufgabe und sendet dann die Nachricht ‚ÄûDer Versand der Ware ist geplant‚Äú. </li><li>  Der n√§chste Dienst, der eine Nachricht erhalten hat, dass der Versand geplant ist, startet den Papierkram f√ºr den Zoll. </li></ol><br>  Dar√ºber hinaus wird jede vom Dienst empfangene Nachricht auf Eindeutigkeit √ºberpr√ºft, und wenn eine Nachricht mit einer solchen UUID bereits verarbeitet wurde, wird sie ignoriert. <br><br>  Hier befinden sich die Datenbankbasis (en) zu jedem Zeitpunkt in einem leicht inkonsistenten Zustand, dh die Waren im Lager sind bereits als im Lieferprozess befindlich markiert, aber die Lieferaufgabe selbst ist noch nicht vorhanden. Sie wird in ein oder zwei Sekunden angezeigt.  Gleichzeitig haben wir 99,999% (tats√§chlich entspricht diese Zahl dem Zuverl√§ssigkeitsgrad des Warteschlangendienstes), dass die sendende Aufgabe angezeigt wird.  F√ºr die meisten Unternehmen ist dies akzeptabel. <br><br><h2>  Worum geht es dann in dem Artikel? </h2><br>  In dem Artikel m√∂chte ich √ºber einen anderen Weg sprechen, um das Transaktionsproblem in Microservice-Anwendungen zu l√∂sen.  Trotz der Tatsache, dass Microservices am besten funktionieren, wenn jeder Dienst √ºber eine eigene Datenbank verf√ºgt, passen alle Daten f√ºr kleine und mittlere Systeme in der Regel problemlos in eine moderne relationale Datenbank.  Dies gilt f√ºr fast jedes interne Unternehmenssystem.  Das hei√üt, wir m√ºssen h√§ufig keine Daten zwischen verschiedenen physischen Maschinen austauschen.  Wir k√∂nnen Daten von verschiedenen Mikrodiensten in nicht verwandten Gruppen von Tabellen derselben Datenbank speichern.  Dies ist besonders praktisch, wenn Sie eine alte monolithische Anwendung in Dienste aufteilen und den Code bereits aufgeteilt haben, die Daten jedoch weiterhin in derselben Datenbank gespeichert sind.  Das Problem der Transaktionsaufteilung bleibt jedoch weiterhin bestehen - die Transaktion ist fest mit der Netzwerkverbindung und dementsprechend mit dem Prozess verbunden, der diese Verbindung ge√∂ffnet hat, und wir haben separate Prozesse.  Wie man ist <br><br>  Oben habe ich verschiedene g√§ngige Methoden zur L√∂sung des Problems beschrieben. Dar√ºber hinaus m√∂chte ich f√ºr einen speziellen Fall eine andere M√∂glichkeit anbieten, wenn sich alle Daten in derselben Datenbank befinden.  Ich <b>empfehle nicht,</b> diese Methode <b>in diesem Projekt zu implementieren</b> , aber es ist neugierig genug <b>,</b> sie im Artikel zu pr√§sentieren.  Nun, pl√∂tzlich wird es in einem besonderen Fall n√ºtzlich sein. <br><br>  Sein Wesen ist sehr einfach.  Eine Transaktion ist mit einer Netzwerkverbindung verkn√ºpft, und die Datenbank wei√ü nicht genau, wer an diesem Ende der offenen Netzwerkverbindung sitzt.  Es ist ihr egal, Hauptsache, dass die richtigen Befehle am Socket ankommen.  Es ist klar, dass ein Socket normalerweise ausschlie√ülich zu einem Prozess auf der Clientseite geh√∂rt, aber ich sehe mindestens drei M√∂glichkeiten, um dies zu umgehen. <br><br><h3>  1. √Ñndern Sie den Datenbankcode </h3><br>  Auf der Ebene des Datenbankcodes f√ºr Datenbanken, deren Code wir √§ndern k√∂nnen, indem wir unsere eigene Datenbankassemblierung erstellen, implementieren wir den Mechanismus zum √úbertragen von Transaktionen zwischen Verbindungen.  Wie es aus Sicht des Kunden funktionieren kann: <br><br><ol><li>  Wir starten die Transaktion, nehmen einige √Ñnderungen vor, es ist Zeit, die Transaktion zum n√§chsten Service zu √ºbertragen. </li><li>  Wir weisen die DB an, uns die UUID der Transaktion zu geben und N Sekunden zu warten.  Wenn w√§hrend dieser Zeit keine andere Verbindung mit dieser UUID hergestellt wird, setzen Sie die Transaktion zur√ºck. Wenn dies der Fall ist, √ºbertragen Sie alle mit der Transaktion verkn√ºpften Datenstrukturen auf die neue Verbindung und arbeiten Sie weiter damit. </li><li>  Wir √ºbergeben die UUID an den n√§chsten Dienst (d. H. An einen anderen Prozess, m√∂glicherweise an eine andere VM). </li><li>  √ñffnen Sie darin eine Verbindung und geben Sie den DB-Befehl ein - setzen Sie die Transaktion mit der angegebenen UUID fort. </li><li>  Wir arbeiten weiterhin mit der Datenbank als Teil einer Transaktion, die von einem anderen Prozess gestartet wurde. </li></ol><br>  Diese Methode ist am leichtesten zu verwenden, erfordert jedoch eine √Ñnderung des Datenbankcodes. Anwendungsprogrammierer tun dies normalerweise nicht. Sie erfordern viele spezielle F√§higkeiten.  H√∂chstwahrscheinlich wird es notwendig sein, Daten zwischen den Datenbankprozessen und Datenbanken zu √ºbertragen, deren Code wir im Gro√üen und Ganzen sicher √§ndern k√∂nnen - One - PostgreSQL.  Dar√ºber hinaus funktioniert dies nur f√ºr nicht verwaltete Server. In RDS oder Cloud SQL ist dies nicht der Fall. <br><br>  Schematisch sieht es so aus: <br><br><img src="https://habrastorage.org/webt/lc/ok/ia/lcokianx0usjlvmfjo9wnlc1vhy.png"><br><br><h3>  2. Manipulation von Steckdosen </h3><br>  Das zweite, was mir in den Sinn kommt, ist die subtile Manipulation von Datenbankverbindungen durch Sockets.  Wir k√∂nnen einen "Reverse-Socket-Proxy" erstellen, der die von mehreren Clients kommenden Befehle an einen bestimmten Port in einem Befehlsstrom an die Datenbank weiterleitet. <br><br>  Tats√§chlich ist diese Anwendung pgBouncer sehr √§hnlich, nur dass sie zus√§tzlich zu ihrer Standardfunktionalit√§t einige Manipulationen mit dem Bytestream von Clients vornimmt und auf Befehl einen Client anstelle eines anderen ersetzen kann. <br><br>  Ich mag diese Methode √ºberhaupt nicht, f√ºr ihre Implementierung ist es notwendig, die zwischen dem Server und den Clients zirkulierenden Bin√§rpakete zu bereinigen.  Und es erfordert immer noch viel Systemprogrammierung.  Ich habe es nur der Vollst√§ndigkeit halber mitgebracht. <br><br><h3>  3. Gateway JDBC </h3><br>  Wir k√∂nnen einen Gateway-JDBC-Treiber erstellen - wir verwenden den Standard-JDBC-Treiber f√ºr eine bestimmte Datenbank, sei es PostgreSQL.  Wir verpacken die Klasse und erstellen HTTP-Schnittstellen zu allen externen Methoden (nicht HTTP, aber der Unterschied ist gering).  Als n√§chstes erstellen wir einen weiteren JDBC-Treiber - eine Fassade, die alle Methodenaufrufe an das JDBC-Gateway umleitet.  Das hei√üt, wir teilen den vorhandenen Treiber in zwei H√§lften und verbinden diese H√§lften √ºber das Netzwerk.  Wir erhalten folgendes Komponentendiagramm: <br><br><img src="https://habrastorage.org/webt/zo/f4/z9/zof4z9dt8p2segieoslko79fc_0.png"><br><br>  <i>NB!: Wie wir sehen k√∂nnen, sind alle drei Optionen √§hnlich. Der einzige Unterschied besteht darin, auf welcher Ebene wir die Verbindung √ºbertragen und welche Tools wir daf√ºr verwenden.</i> <i><br></i> <br><br>  Danach bringen wir unserem Treiber bei, im Wesentlichen denselben Trick mit der in Methode 1 beschriebenen UUID-Transaktion auszuf√ºhren. <br><br>  Im Java-Anwendungscode k√∂nnte die Verwendung dieser Methode folgenderma√üen aussehen. <br><br><h3>  Service A - Beginn der Transaktion </h3><br>  Unten finden Sie den Code f√ºr einen Dienst, der eine Transaktion startet, √Ñnderungen an der Datenbank vornimmt und diese an einen anderen Dienst weiterleitet, um sie abzuschlie√üen.  Im Code verwenden wir die direkte Arbeit mit JDBC-Klassen.  Nat√ºrlich tut dies 2019 niemand, aber der Einfachheit halber wird der Code vereinfacht. <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    , ,  ‚Äú‚Äù //   Class.forName("org.postgresql.FacadeDriver"); var connection = DriverManager.getConnection( "jdbc:postgresqlfacade://hostname:port/dbname","username", "password"); //  -    statement = dbConnection.createStatement(); var statement.executeUpdate(‚Äúinsert ...‚Äù); /* ,        . transactionUUID(int)  -,     ,   JDBC gateway-.  ResultSet        Varchar,  UUID.            .   ,         UUID.  60 ‚Äî  ,    .        , , JDBCTemplate.      ResultSet */ var rs = statement.executeQuery(‚Äúselect transactionUUID(60)‚Äù); String uuid = extractUUIDFromResultSet(rs); //      remoteServiceProxy.continueProcessing(uuid, otherParams); //          //     . closeEverything(); return;</span></span></code> </pre> <br><h3>  Service B - Transaktionsabschluss </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,     // remoteServiceProxy.continueProcessing(...) //     . Class.forName("org.postgresql.FacadeDriver"); var connection = DriverManager.getConnection( "jdbc:postgresqlfacade://hostname:port/dbname","username", "password"); //     Gateway JDBC,    // .  continue transaction    ,   // gateway JDBC statement = dbConnection.createStatement(); statement.executeUpdate(‚Äúcontinue transaction ‚Äù+uuid); // ,    ,      //      statement.executeUpdate(‚Äúupdate ..."); //   connection.commit(); return;</span></span></code> </pre> <br><h2>  Interaktion mit anderen Komponenten und Frameworks </h2><br>  Ber√ºcksichtigen Sie die m√∂glichen Nebenwirkungen einer solchen architektonischen L√∂sung. <br><br><h3>  Verbindungspool </h3><br>  Da wir in Wirklichkeit einen echten Verbindungspool innerhalb des JDBC-Gateways haben, ist es besser, die Verbindungspools in Diensten zu deaktivieren, da sie eine Verbindung innerhalb des Dienstes erfassen und halten, die von einem anderen Dienst verwendet werden k√∂nnte. <br><br>  Nachdem die UUID empfangen und auf die √úbertragung zu einem anderen Prozess gewartet wurde, wird die Verbindung im Wesentlichen funktionsunf√§hig. Aus Sicht des Frontend-JDBC wird sie automatisch geschlossen. Aus Sicht des Gateway-JDBC muss sie gehalten werden, ohne dass jemand anderem als wem etwas gegeben wird wird mit der gew√ºnschten UUID geliefert. <br><br>  Mit anderen Worten, die doppelte Verwaltung des Verbindungspools im Gateway-JDBC und in jedem der Dienste kann zu subtilen, unangenehmen Fehlern f√ºhren. <br><br><h3>  Jpa </h3><br>  Bei JPA sehe ich zwei m√∂gliche Probleme: <br><br><ol><li>  Transaktionsmanagement.  Beim Festschreiben eines JPA glaubt die Engine m√∂glicherweise, dass alle Daten gespeichert wurden, obwohl sie nicht gespeichert wurden.  Die manuelle Transaktionsverwaltung und flush () vor der √úbertragung der Transaktion sollten das Problem h√∂chstwahrscheinlich l√∂sen. </li><li>  Der Cache der zweiten Ebene funktioniert wahrscheinlich nicht richtig, aber in verteilten Systemen ist seine Verwendung in jedem Fall eingeschr√§nkt. </li></ol><br><h3>  Fr√ºhlingstransaktionen </h3><br>  Der Transaktionsverwaltungsmechanismus von Spring kann m√∂glicherweise nicht aktiviert werden, und Sie m√ºssen sie manuell verwalten.  Ich bin mir fast sicher, dass es erweitert werden kann - zum Beispiel um einen benutzerdefinierten Bereich zu schreiben -, aber um sicher zu sein, m√ºssen wir untersuchen, wie die Spring Transactions-Erweiterung dort angeordnet ist, aber ich habe dort noch nicht nachgesehen. <br><br><h2>  Vorteile und Nachteile </h2><br><h3>  Vorteile </h3><br><ul><li>  Praktisch erfordert keine √Ñnderung des vorhandenen monolithischen Codes beim S√§gen. </li><li>  Sie k√∂nnen komplexe server√ºbergreifende Transaktionen praktisch ohne Codekomplexit√§t schreiben. </li><li>  Erm√∂glicht die dienst√ºbergreifende Ablaufverfolgung der Transaktionsausf√ºhrung. </li><li>  Die L√∂sung ist sehr flexibel. Sie k√∂nnen klassische Transaktionen verwenden, bei denen keine Verteilung erforderlich ist, und die Transaktion nur f√ºr Vorg√§nge freigeben, bei denen eine dienst√ºbergreifende Interaktion erforderlich ist. </li><li>  Das Projektteam muss neue Technologien nicht zwangsweise beherrschen.  Neue Technologien sind nat√ºrlich gut, aber die Aufgabe - es ist zwingend und dringend (bis gestern!), 20 Entwicklern das Konzept des Aufbaus reaktiver Systeme beizubringen - kann sehr trivial sein.  Es gibt jedoch keine Garantie daf√ºr, dass alle 20 Personen die Schulung p√ºnktlich abschlie√üen. </li></ul><br><h3>  Nachteile </h3><br><ul><li>  Nicht skalierbar und im Gegensatz zu einer L√∂sung in der Warteschlange auf Datenbankebene nicht modular.  Sie haben noch eine Datenbank, in der alle Abfragen und die gesamte Last zusammenlaufen.  In diesem Sinne ist die L√∂sung eine Sackgasse: Wenn Sie sp√§ter die Last erh√∂hen oder die L√∂sung gem√§√ü den Daten modular gestalten m√∂chten, m√ºssen Sie alles wiederholen. </li><li>  Sie m√ºssen beim √úbertragen einer Transaktion zwischen Prozessen, insbesondere in in Frameworks geschriebenen Prozessen, sehr vorsichtig sein.  Sitzungen haben ihre eigenen Einstellungen, und bei verschiedenen Frameworks kann eine pl√∂tzliche √Ñnderung der Verbindung mit der Datenbank zu Fehlfunktionen f√ºhren.  Siehe beispielsweise Sitzungseinstellungen und Transaktionen f√ºr PostgreSQL. </li><li>  Als ich die Idee im Chat unseres lokalen Architekten √ºber DataArt erz√§hlte, fragten mich meine Kollegen als erstes, ob ich trinke (nein, nicht trinken!).  Aber ich gebe zu, dass die Idee, sagen wir, nicht die am weitesten verbreitete ist, und wenn Sie sie in Ihrem Projekt implementieren, wird sie f√ºr die anderen Teilnehmer sehr ungew√∂hnlich aussehen. </li><li>  Ben√∂tigt einen benutzerdefinierten JDBC-Treiber.  Das Schreiben braucht Zeit, Sie m√ºssen es debuggen, nach Fehlern suchen, einschlie√ülich solcher, die durch Netzwerkkommunikationsfehler usw. verursacht wurden. </li></ul><br><h2>  Warnung </h2><br>  Ich warne Sie noch einmal: <b>Versuchen</b> Sie <b>nicht, diesen Trick</b> <s>zu Hause</s> in diesem Projekt <b>zu wiederholen</b> , es sei denn, Sie haben eine sehr klare Erkl√§rung, warum Sie ihn brauchen, und √ºberzeugende Beweise daf√ºr, dass es √ºberhaupt keinen anderen Weg gibt. <br><br>  Alles ab dem 1. April! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446288/">https://habr.com/ru/post/de446288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446276/index.html">Die Chang'e-4-Mission ist der vierte Mondtag f√ºr den Lander und den Yutu-2-Rover. √úber Kameras und Controller auf Ger√§ten</a></li>
<li><a href="../de446278/index.html">Die Rolle des IGF-1-Systems bei der Langlebigkeitsmodulation: Widerspr√ºche und ein neues Verst√§ndnis aus der Sicht der Hundertj√§hrigen</a></li>
<li><a href="../de446280/index.html">Wissenschaftsabteilung bei DUMP: Erweitern Sie Ihren Horizont</a></li>
<li><a href="../de446282/index.html">Wie kann HotSpot schnell mit den Anforderungen der Gesetze der Russischen F√∂deration bereitgestellt werden?</a></li>
<li><a href="../de446284/index.html">Was ist ein Teamleiter?</a></li>
<li><a href="../de446292/index.html">Sie haben dort einfach nicht gesucht: Wie finden Sie Mitarbeiter f√ºr das Projekt im technischen Support?</a></li>
<li><a href="../de446296/index.html">Biologische Unsterblichkeit, Kolonisierung von Mars, Amish, EC1863 und Texterstellung. Kapitel 1. Und das Herz des Cyborg schl√§gt</a></li>
<li><a href="../de446298/index.html">Ein einfaches Werkzeug, um KI f√ºr die Entscheidungsfindung zu verwenden</a></li>
<li><a href="../de446300/index.html">Wie koordiniert man den Flug der Sonde in die Stratosph√§re (was wir beim Start in der Praxis erleben werden)?</a></li>
<li><a href="../de446302/index.html">9 Zitate aus dem Habraseminar 2019 f√ºr Blogger, Unternehmer und HR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>