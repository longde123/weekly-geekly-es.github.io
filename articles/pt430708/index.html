<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úùÔ∏è üë®üèø‚Äçü§ù‚Äçüë®üèæ ‚¨úÔ∏è Tic Tac Toe ‚ÄúSem Fronteiras‚Äù üë©üèæ‚Äçü§ù‚Äçüë®üèΩ üö¢ ü§òüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jogo da velha ... todos jogaram, tenho certeza. O jogo √© atraente em sua simplicidade, especialmente quando voc√™ arrasta o rel√≥gio em algum lugar da l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tic Tac Toe ‚ÄúSem Fronteiras‚Äù</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430708/"> Jogo da velha ... todos jogaram, tenho certeza.  O jogo √© atraente em sua simplicidade, especialmente quando voc√™ arrasta o rel√≥gio em algum lugar da li√ß√£o, alguns, e n√£o h√° nada em m√£os, exceto uma folha de caderno e um l√°pis simples.  Eu n√£o sei quem foi o primeiro que adivinhou desenhar cruzes e c√≠rculos em 9 quadrados, mas desde ent√£o o jogo n√£o perdeu muito, especialmente porque as pessoas criaram muitas varia√ß√µes. <br><br><img src="https://habrastorage.org/webt/pd/gx/-c/pdgx-cibc6880fmwfxt90nxmi-k.jpeg"><br><br>  Este artigo √© sobre o processo de desenvolvimento de IA em javascript para reproduzir uma dessas varia√ß√µes do jogo da velha: tenho muito material, mas o dilu√≠ com anima√ß√£o e imagens.  De qualquer forma, pelo menos vale a pena tentar reproduzi-lo. <br>  As diferen√ßas entre esta vers√£o do jogo e o original s√£o as seguintes: <br><br><ol><li>  <b>O campo</b> pode ser arbitrariamente <b>grande</b> (quanto tempo durar√° o notebook) </li><li>  O vencedor √© aquele que coloca <b>5 pe√ßas</b> (se voc√™ puder cham√°-las assim) em uma fileira. </li></ol><br>  Tudo √© simples ... e ao mesmo tempo complicado: o resultado do jogo n√£o pode ser calculado com anteced√™ncia, como no cl√°ssico anal√≥gico.  Essa "pequena proje√ß√£o" levou muito do meu tempo e nervosismo.  Espero que voc√™ ache interessante. <a name="habracut"></a><br><br><h3>  Antes de come√ßarmos </h3><br>  For√ßado a pedir desculpas antecipadamente pelo volume do artigo e, em alguns lugares, uma apresenta√ß√£o n√£o muito intelig√≠vel do pensamento, no entanto, n√£o consegui espremer o rebanho sem perda de conte√∫do e qualidade. <br>  Eu recomendo que voc√™ se familiarize primeiro com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">resultado</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo</a> <br><br>  Teclas de atalho e comandos: <br><br><ul><li>  <b>D</b> - AI far√° um movimento para voc√™ </li><li>  <b>T</b> - veja peso celular </li><li>  Escreva <b>SHOW_WEIGHTS = true</b> no console para visualizar os pesos de todas as c√©lulas analisadas. </li></ul><br><h3>  Vamos come√ßar </h3><br>  Voc√™ precisa come√ßar com a implementa√ß√£o do jogo em si, ou seja,  escreva uma aplica√ß√£o para dois jogadores, at√© agora sem um bot.  Para meus prop√≥sitos, decidi usar javascript + jquery + bootstrap4, embora praticamente n√£o seja usado l√°, mas √© melhor deix√°-lo - ou a tabela flutuar√°.  N√£o h√° nada de especial para contar, h√° muito material sobre js, jquery e bootstrap.  S√≥ posso dizer que usei o MVC.  De qualquer forma, n√£o vou explicar absolutamente todo o c√≥digo - j√° existe muito material. <br><br>  Ent√£o, o campo de jogo estava pronto.  Voc√™ pode definir formas nas c√©lulas.  Mas a vit√≥ria de qualquer um dos jogadores n√£o foi fixada de forma alguma. <br><br><h3>  Verifica√ß√£o de final de jogo </h3><br>  O jogo termina quando um dos jogadores coloca <b>5 pe√ßas</b> seguidas.  "√â simples!"  Eu pensei.  E ele come√ßou a escanear absolutamente todas as c√©lulas do campo: primeiro todas as horizontais, depois as verticais e finalmente as diagonais. <br><br>  Essa √© uma maneira idiota, mas funcionou.  No entanto, poderia ser significativamente melhorado, o que eu fiz: A maioria das c√©lulas permanecer√° vazia durante o jogo - o campo de jogo √© muito grande para ser preenchido completamente.  Como era necess√°rio digitaliz√°-lo a cada movimento e apenas uma pe√ßa √© colocada em um movimento, voc√™ pode se concentrar apenas nessa pe√ßa (c√©lula): digitalize apenas uma horizontal, vertical e duas diagonais da c√©lula que possui a mesma c√©lula. <br><br>  Al√©m disso, voc√™ n√£o precisa digitalizar todas as linhas de c√©lulas.  Como o final do jogo √© de 5 pe√ßas seguidas, as pe√ßas separadas por 6 c√©lulas n√£o s√£o do nosso interesse.  Basta escanear cinco c√©lulas de cada lado.  N√£o entende?  Veja a anima√ß√£o abaixo. <br><br><img src="https://habrastorage.org/webt/nt/fj/wu/ntfjwuj6nfabfj2qtedcs4g-fp0.gif"><br><br><div class="spoiler">  <b class="spoiler_title">Ver c√≥digo</b> <div class="spoiler_text"><pre><code class="javascript hljs">checkWin( cellX, cellY ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newFig = getFig(cellX,cellY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! newFig ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res; res = res || checkLine( cellX, cellY, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//horizontal res = res || checkLine( cellX, cellY, 0, 1 ); //vertical res = res || checkLine( cellX, cellY, 1, 1 ); //diagonal 45 res = res || checkLine( cellX, cellY, 1, -1 ); //diagonal 135 return res; function getFig( x, y ){ return Model.Field[x] &amp;&amp; Model.Field[x][y] ? Model.Field[x][y] : 'b'; } function checkLine( x, y, dx, dy ){ x = +x; y = +y; var score = 0; while( getFig( x - dx, y - dy ) == newFig ){ x -= dx; y -= dy; } while( getFig( x, y ) == newFig ){ x += dx; y += dy; score++; } if( score &gt;= 5 ) return true; return false; } }</span></span></code> </pre> <br></div></div><br><h3>  Vamos direto ao bot </h3><br>  Ent√£o, n√≥s j√° escrevemos uma p√°gina com tic-tac-toe.  Passamos para a tarefa principal - AI. <br>  Voc√™ n√£o pode simplesmente pegar e escrever c√≥digo, se n√£o souber: precisa pensar na l√≥gica do bot. <br><br>  A linha inferior √© analisar o campo de jogo, pelo menos parte dele, e calcular o <b>pre√ßo (peso) de</b> cada c√©lula no campo.  A c√©lula com o maior peso - o mais promissor - o bot colocar√° uma figura l√°.  A principal dificuldade est√° no c√°lculo do peso de uma c√©lula. <br><br><h3>  Terminologia </h3><br>  <b>Cruzes e dedos</b> s√£o figuras. <br>  <b>Um ataque</b> ser√° chamado de v√°rias figuras id√™nticas, lado a lado na mesma linha.  De fato, isso √© muito.  O n√∫mero de pe√ßas em um ataque √© o seu <b>poder</b> .  Uma pe√ßa separada tamb√©m √© um ataque (poder 1). <br><br>  Nas c√©lulas de ataque adjacentes (nas extremidades), pode haver c√©lulas vazias ou pe√ßas inimigas.  √â l√≥gico pensar que um ataque com duas c√©lulas vazias nas extremidades pode ser desenvolvido em duas dire√ß√µes, o que o torna mais promissor.  O n√∫mero de c√©lulas vazias nas "extremidades" do ataque ser√° chamado de <b>potencial</b> .  O potencial pode ser 0, 1 ou 2. <br>  Denotamos ataques da seguinte forma: <b>[poder de ataque, potencial]</b> .  Por exemplo, um <b>ataque [4: 1]</b> . <br><br><img src="https://habrastorage.org/webt/1_/pk/e3/1_pke3kve1yjbf6cjjzg3hnnzvm.jpeg"><br>  <i>Figura 1. Ataque [4: 1]</i> <br><br>  No decorrer da an√°lise, avaliaremos todas as c√©lulas que entram em uma √°rea espec√≠fica.  Cada c√©lula ir√° calcular seu <b>peso</b> .  √â calculado com base nos pesos de todos os ataques que essa c√©lula afeta. <br><br><h3>  A ess√™ncia da an√°lise </h3><br>  Imagine que no campo de jogo j√° existem v√°rios ataques de um e do segundo jogador.  Um dos jogadores faz um movimento (deixe as cruzes).  Naturalmente, ele faz uma mudan√ßa para uma c√©lula vazia - e, assim, ele pode: <br><br><ol><li>  Desenvolva seu ataque, e talvez mais de um, aumentando seu poder.  Pode lan√ßar um novo ataque, etc. </li><li>  Impe√ßa o desenvolvimento de um ataque inimigo ou bloqueie-o completamente. </li></ol><br>  Ou seja, nosso protagonista pode atacar e defender.  Ou talvez de uma s√≥ vez.  Para ele, o primeiro e o segundo s√£o importantes. <br><br>  A ess√™ncia da an√°lise √© a seguinte: <br><br><ol><li>  O bot substitui as figuras na c√©lula verificada: primeiro uma cruz, depois um zero. </li><li>  Em seguida, ele procura todos os ataques que foram recebidos por esses movimentos e resume seus pesos. </li><li>  A quantidade recebida √© o peso da c√©lula. </li><li>  Um algoritmo semelhante √© realizado para todas as c√©lulas do campo de jogo. </li></ol><br><img src="https://habrastorage.org/webt/ur/rc/qz/urrcqzyrjrnp9oupxjoqc1iu6wg.gif"><br><br>  De fato, verificamos com esse algoritmo o que acontecer√° se formos por esse caminho ... e o que acontecer√° se o oponente for por esse caminho.  Esperamos um passo adiante e selecionamos a c√©lula mais adequada - com o peso mais alto. <br><br>  Se uma c√©lula tem mais peso que outra, isso leva √† cria√ß√£o de ataques mais perigosos ou ao bloqueio de fortes ataques inimigos.  Tudo √© l√≥gico ... parece-me. <br>  Se voc√™ for para a p√°gina e escrever no console SHOW_WEIGHTS = true, poder√° sentir visualmente a opera√ß√£o do algoritmo (os pesos das c√©lulas ser√£o mostrados). <br><br><h3>  Pesos de Ataque </h3><br>  Revisei meu c√©rebro e trouxe essa correspond√™ncia de ataques e pesos: <br><br><pre> <code class="javascript hljs">ATTACK_WEIGHT = [[],[],[],[],[],[]]; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">6</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.25</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre><br>  Empiricamente selecionado - talvez essa n√£o seja a melhor op√ß√£o. <br><br>  Eu adicionei um poder de ataque 5 com peso proibitivamente grande ao array.  Isso pode ser explicado pelo fato de o bot analisar o jogo, observando um passo √† frente (substituindo a figura na c√©lula).  Ignorar tal ataque n√£o passa de uma derrota.  Bem, ou vit√≥ria ... dependendo de quem. <br><br>  Os ataques com alto potencial s√£o mais valorizados. <br><br>  Ataque [4: 2] na maioria dos casos decide o resultado do jogo.  Se o jogador conseguiu criar um ataque assim, o oponente n√£o poder√° mais bloque√°-lo.  No entanto, isso n√£o √© uma vit√≥ria.  O inimigo pode terminar o jogo mais r√°pido, mesmo que tenhamos um ataque [4: 2] em campo, ent√£o seu peso √© menor que o dos ataques com uma pot√™ncia de 5. Veja um exemplo abaixo. <br><br><img src="https://habrastorage.org/webt/pk/4u/mm/pk4ummarchcw9j4lpkujlmj_iig.jpeg"><br>  <i>Figura 2. Ataque [4: 2]</i> <br><br><h3>  Ataques rasgados </h3><br>  O c√≥digo n√£o √© apresentado neste par√°grafo.  Aqui, apresentamos o conceito de um divisor de ataques e explicamos a ess√™ncia dos <b>"ataques rasgados"</b> . <br><br>  Considere a seguinte situa√ß√£o: ao substituir uma figura para remover v√°rias c√©lulas vazias, mas n√£o mais que 5, mais uma est√° localizada. <br><br>  E, ao que parece, duas figuras id√™nticas, na mesma linha ... visualmente, parece um ataque, mas na verdade n√£o.  N√£o √© uma ordem, pois esses ataques "rasgados" tamb√©m trazem uma amea√ßa em potencial. <br><br>  Especialmente nesses casos, para cada ataque calcularemos o divisor.  Inicialmente, seu valor √© 1. <br><br><ol><li>  Apresentamos o ataque "rasgado" como v√°rias </li><li>  Contamos o n√∫mero de c√©lulas vazias entre o ataque central e o lado </li><li>  Para cada c√©lula vazia, o divisor √© aumentado em 1 </li><li>  Calculamos o peso do ataque central, como de costume, o peso dos ataques laterais - divididos pelo divisor </li></ol><br><img src="https://habrastorage.org/webt/dc/w9/62/dcw9629rd4zdhomn6q2uwi5yxkg.jpeg"><br>  <i>Fig 3. An√°lise de "ataque rasgado".</i>  <i>Uma c√©lula com uma cruz amarela √© digitalizada.</i> <br><br>  Assim, ataques rasgados tamb√©m ser√£o levados em considera√ß√£o pela IA.  De fato, ser√£o ataques comuns, mas quanto mais eles estiverem na c√©lula digitalizada, menor a influ√™ncia que ter√£o nela e, consequentemente, ter√£o menos peso (gra√ßas ao divisor). <br><br><h3>  Algoritmo de pesquisa de ataque </h3><br>  Primeiro, crie <b>uma classe de</b> ataque.  O ataque ter√° tr√™s atributos, sobre os quais escrevi anteriormente: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attack</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( cap = 0, pot = 0, div = 1 ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability = cap; <span class="hljs-comment"><span class="hljs-comment">// this.potential = pot; // this.divider = div; // }</span></span></code> </pre><br>  E um <b>m√©todo</b> que retornar√° o peso de um determinado ataque: <br><br><pre> <code class="javascript hljs">countWeigth(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ATTACK_WEIGHT[ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.potential ] / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.divider } }</code> </pre><br>  Pr√≥ximo.  Dividiremos a pesquisa de todos os ataques de uma c√©lula em: <br><br><ol><li>  Pesquisa Horizontal </li><li>  Pesquisa vertical </li><li>  Pesquisa na diagonal de 45 graus </li><li>  Pesquisa na diagonal de 135 graus </li></ol><br>  Todas essas s√£o <b>linhas</b> , e o algoritmo para procurar ataques nessas linhas pode ser generalizado: <b>a classe checkLine</b> . <br><br>  No entanto, n√£o precisamos verificar a linha inteira.  O poder m√°ximo de ataque que nos interessa √© 5. √â claro que √© poss√≠vel criar um ataque com um poder de, digamos, 6.  Mas para uma IA que analisa a situa√ß√£o do jogo da pr√≥xima jogada, √© igual a 6 ou 5. A perspectiva de receber um desses ataques indica o final do jogo na pr√≥xima jogada.  Consequentemente, o peso da c√©lula analisada ser√° o mesmo em ambos os casos. <br><br>  Atributos de classe: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">checkLine</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">//,        this.subFig = "√ó"; //     .    ¬´0¬ª - . this.Attacks = []; //  this.curAttack = new Attack; // (      ) this.iter = 1; //,     this.checkEdge = false;</span></span></code> </pre><br>  √â necess√°rio parar por aqui, pois a pergunta pode surgir: por que verificar a 6¬™ c√©lula se a pot√™ncia m√°xima de ataque √© 5. A resposta √© determinar o potencial remoto do centro de ataque. <br><br>  Aqui est√° um exemplo: um ataque com uma pot√™ncia de 1 na imagem est√° localizado na borda da √°rea digitalizada.  Para descobrir o potencial desse ataque, voc√™ precisa "procurar no exterior". <br><br><img src="https://habrastorage.org/webt/cg/hb/0r/cghb0ryfnk7kgmaqhw-67emn0qc.jpeg"><br>  <i>Fig.</i>  <i>3. Digitalizando 6¬™ c√©lulas.</i>  <i>Se voc√™ n√£o varrer a 6¬™ c√©lula, poder√° determinar incorretamente o potencial de ataque.</i> <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   this.attackplace = 1; }</span></span></code> </pre><br>  Simplesmente pode n√£o haver espa√ßo suficiente para concluir alguns ataques.  Depois de contar o local do ataque, podemos entender com anteced√™ncia qual dos ataques √© pouco promissor. <br><br><img src="https://habrastorage.org/webt/ww/fy/n4/wwfyn4tolymet3ylnf53hax6gju.jpeg"><br>  <i>Fig.</i>  <i>4. Lugar para atacar</i> <br><br>  O algoritmo √© o seguinte: <br><br>  1) Vamos come√ßar com a c√©lula central.  Deveria estar vazio (vamos fazer uma mudan√ßa, certo? Mas n√£o esquecemos que nossa IA deve substituir figuras nesta c√©lula pela an√°lise do pr√≥ximo movimento. A figura que substitu√≠mos √© <b>this.subfig</b> - o padr√£o √© uma cruz. Como a c√©lula central inicialmente conter√° alguma forma ap√≥s a substitui√ß√£o, ela pertencer√° a algum ataque <b>this.curAttack</b> : <br><br><ul><li>  seu poder n√£o ser√° menor que 1 (uma figura na c√©lula central) </li><li>  divisor - 1, porque  √© um ataque central (pertence √† c√©lula digitalizada); </li><li>  o potencial ainda n√£o √© conhecido - o padr√£o √© 0; </li></ul><br><br>  Exibimos todos esses pontos nos valores padr√£o do construtor - veja o c√≥digo acima. <br><br>  2) Em seguida, reduzindo o iterador, itera mais de 5 c√©lulas em um lado do digitalizado.  A fun√ß√£o <b>getAttacks (cellX, cellY, subFig, dx, dy)</b> √© respons√°vel por isso, onde: <br><br>  <b>cellX, cellY</b> - coordenadas da c√©lula marcada <br>  <b>subFig</b> - a figura que substitu√≠mos na c√©lula marcada <br>  <b>dx, dy</b> - altera√ß√µes nas coordenadas xey em ciclos - √© assim que definimos a dire√ß√£o da pesquisa: <br><br><ul><li>  Horizontal (dx = 1, dy = 0) </li><li>  Vertical (dx = 0, dy = 1) </li><li>  Diagonal 45 (dx = 1, dy = -1) </li><li>  Diagonal 135 (dx = 1, dy = 1) </li></ul><br>  De certa forma, esse √© um vetor paralelo √† linha de pesquisa.  Assim, uma fun√ß√£o poder√° pesquisar em 4 dire√ß√µes e n√£o violaremos o princ√≠pio DRY novamente. <br><br>  C√≥digo da fun√ß√£o: <br><br><pre> <code class="javascript hljs">getAttacks( cellX, cellY, subFig, dx, dy ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.substitudeFigure( subFig ); <span class="hljs-comment"><span class="hljs-comment">//  ‚Äì  ... for( var x = cellX - dx, y = cellY - dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x -= dx, y -= dy ) if( this.checkCell( x, y ) ) break; //: //    (  ) this.turnAround(); //  -    ... for( var x = cellX + dx, y = cellY + dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x += dx, y += dy ) if( this.checkCell( x, y ) ) break; return this.Attacks; }</span></span></code> </pre><br>  Observe que, se checkCell () retornar algo, o loop ser√° interrompido. <br><br>  3) Verificamos as figuras dessas c√©lulas. <br>  A fun√ß√£o <b>checkCell (x, y)</b> √© respons√°vel por isso: <br><br>  Primeiro, escreva a forma na vari√°vel <b>fig</b> : <br>  <b>Model.Field</b> √© o nosso campo de jogo. <br><br><pre> <code class="javascript hljs">checkCell( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fig = Model.Field[x] &amp;&amp; Model.Field[x][y] !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ? Model.Field[x][y] : <span class="hljs-string"><span class="hljs-string">'b'</span></span>;</code> </pre><br>  <b>fig</b> pode ser 'x', 'o', 'b' (borda), 0 (c√©lula vazia). <br><br><ul><li>  Se tal figura coincidir com a figura da c√©lula central ( <b>this.subFig</b> ), continuaremos o algoritmo - isso significa que continuamos examinando o ataque, est√° tudo bem, continuamos com o mesmo esp√≠rito.  Uma pe√ßa extra no ataque √© uma vantagem ao seu poder ( <b>this.curAttack.capability</b> ) e local ( <b>this.attackplace</b> ). <br><br>  (Veja o c√≥digo no pr√≥ximo par√°grafo) </li><li>  Se essa √© uma figura diferente, o ataque que examinamos antes (this.curAttack) √© bloqueado desse lado.  N√£o alteramos nada nos par√¢metros de ataque, escrevemos no conjunto de ataques e ca√≠mos fora do circuito. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'‚óã'</span></span> || fig == <span class="hljs-string"><span class="hljs-string">'√ó'</span></span> ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig != fig ){ <span class="hljs-comment"><span class="hljs-comment">//  this.Attacks.push( this.curAttack ); //  return fig; //      } else{ //    this.curAttack.capability++; // +   this.attackplace++; // +   } }</span></span></code> </pre><br></li><li>  Se n√£o houver tal c√©lula, isso significa que eles ca√≠ram fora dos limites do campo, o que significa que o ataque est√° bloqueado.  N√≥s o escrevemos em uma matriz de todos os ataques e sa√≠mos do loop. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'b'</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">// this.Attacks.push( this.curAttack ); return 'b'; }</span></span></code> </pre><br></li><li>  Se voc√™ pegar uma gaiola vazia, significa que o ataque atual terminou ou estamos lidando com um "ataque rasgado".  Al√©m do potencial e do local para atacar (porque o ataque n√£o est√° bloqueado).  No entanto, n√£o sa√≠mos do circuito - talvez este seja um "ataque destru√≠do" - apenas escrevemos this.curAttack na matriz de todos os ataques da linha this.Attacks [].  Crie um novo ataque "atual" e aumente seu divisor em 1 (este √© um ataque lateral). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  if( this.curAttack.capability ){ this.curAttack.potential++; this.Attacks.push( this.curAttack ); this.curAttack = new Attack; this.curAttack.potential++; } this.curAttack.divider++; this.attackplace++; }</span></span></code> </pre><br></li></ul><br><br>  4) Se na quinta c√©lula a figura coincidir com a c√©lula central, o ataque "repousar√°" contra a borda e, para determinar o potencial de ataque, voc√™ ter√° que "verificar a borda" ( <b>this.checkEdge = true</b> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter == <span class="hljs-number"><span class="hljs-number">4</span></span> &amp;&amp; fig == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig ) <span class="hljs-comment"><span class="hljs-comment">// 5-  this.checkEdge = true; else if( this.iter == 5 ){ if( this.checkEdge ){ if( fig == this.curFig || fig == 0 ) this.curAttack.potential++; this.Attacks.push( this.curAttack ) } return 0; } this.iter++</span></span></code> </pre><br>  A fun√ß√£o <b>checkCell</b> est√° pronta.  No entanto, continuamos a trabalhar na classe <b>checkLine</b> . <br><br>  5) Depois de concluir o primeiro ciclo, voc√™ precisa "virar".  Traduzimos o iterador para o centro e o ataque central, com o √≠ndice 0, o removemos da matriz de ataques e o definimos como o atual. <br><br><pre> <code class="javascript hljs">turnAround(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkEdge = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curAttack = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre><br>  6) Em seguida, v√° para o outro lado da c√©lula atual, aumentando o iterador. <br>  Absolutamente a mesma verifica√ß√£o de n√∫meros.  (C√≥digo j√° gravado - fun√ß√£o <b>getAttacks</b> ) <br><br>  7) Tudo, reunimos todos os ataques que estavam em jogo em uma √∫nica matriz. <br>  √â isso com a classe <b>checkLine ...</b> tudo √© feito. <br><br>  Bem, ent√£o tudo √© simples - crie um objeto <b>checkLine</b> para cada uma das linhas (2 diagonais, horizontal e vertical) e chame a fun√ß√£o <b>getAttacks</b> .  Ou seja, para cada linha - seu pr√≥prio objeto <b>checkLine</b> e, consequentemente, seu pr√≥prio conjunto de ataques. <br><br>  Deixe a fun√ß√£o <b>getAllAttacks ()</b> ser respons√°vel por tudo isso - j√° separadamente das classes descritas acima; <br><br><pre> <code class="javascript hljs">getAllAttacks( cellX, cellY ){ <span class="hljs-comment"><span class="hljs-comment">// ,  , //       if( Model.Field[ cellX ][ cellY ] ) return false var cX = []; var cO = []; //   ... cX['0'] = this.getAttacksLine( cellX, cellY, '√ó', 1, 0 ); cX['90'] = this.getAttacksLine( cellX, cellY, '√ó', 0, 1 ); cX['45'] = this.getAttacksLine( cellX, cellY, '√ó', 1, -1 ); cX['135'] = this.getAttacksLine( cellX, cellY, '√ó', 1, 1 ); //  ... cO['0'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, 0 ); cO['90'] = this.getAttacksLine( cellX, cellY, '‚óã', 0, 1 ); cO['45'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, -1 ); cO['135'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, 1 ); return { //     'x': cX, 'o': cO } } getAttacksLine( cellX, cellY, subFig, dx, dy ){ //      var C = new checkLine; C.getAttacks( cellX, cellY, subFig, dx, dy ); return this.filterAttacks( C ) //   }</span></span></code> </pre><br>  Na sa√≠da, temos um objeto com todos os ataques para a c√©lula testada <br><br>  No entanto, voc√™ pode ter notado algum tipo de fun√ß√£o de filtro.  Sua tarefa √© filtrar ataques "f√∫teis": <br><br><ul><li>  Com pot√™ncia zero (voc√™ nunca sabe se eles entram no array) </li><li>  Ataques que n√£o t√™m espa√ßo (local de ataque &lt;5) </li><li>  Com potencial zero. </li></ul><br>  No entanto, se o ataque tiver um poder maior que 5, o filtro o ignorar√°.  O bot deve ver esses ataques, a triagem deles levar√° a batentes no final do jogo. <br><br><pre> <code class="javascript hljs">filterAttacks( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( attackLine.attackplace &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) attackLine.Attacks.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &amp;&amp; a.potential || a.capability &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) res.push( a ) }) attackLine.Attacks = res; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res }</code> </pre><br><h3>  Pontos de interrup√ß√£o </h3><br>  Sim ... novamente, desculpe!  Ent√£o, chamaremos a situa√ß√£o no jogo, quando um movimento errado decidir o resultado do jogo. <br><br>  Por exemplo, um ataque [3: 2] √© um ponto de interrup√ß√£o.  Se o oponente n√£o o bloquear colocando uma pe√ßa ao lado, ent√£o na pr√≥xima jogada, j√° temos um ataque [4: 2] no campo de jogo - bem, o resultado do jogo √© decidido, o que quer que se diga (na grande maioria dos casos). <br><br>  Ou um ataque [4: 1].  Um bocejo - e o jogo pode ser facilmente conclu√≠do. <br><br><img src="https://habrastorage.org/webt/bd/vc/d0/bdvcd0jzf2wiiqqm9wupccpgmn4.jpeg"><br>  <i>Figura 5. Ponto de interrup√ß√£o</i> <br><br>  Tudo √© claro e compreens√≠vel, e o algoritmo descrito acima j√° √© capaz de levar em conta pontos de interrup√ß√£o e bloque√°-los em tempo h√°bil.  O bot est√° ansioso.  Ele ver√° que, no pr√≥ximo turno, o oponente √© capaz de criar um ataque [5: 1], por exemplo, cujo peso √© 200 - o que significa que o nerd esperto vai at√© aqui. <br><br>  No entanto, imagine uma situa√ß√£o em que um dos jogadores consiga 2 pontos de interrup√ß√£o no campo.  E isso, obviamente, n√£o deixa chance para o oponente, porque  de uma s√≥ vez, podemos bloquear apenas um ponto de interrup√ß√£o.  Como ensinar nossa IA a bloquear esses ataques? <br><br><img src="https://habrastorage.org/webt/bh/qu/79/bhqu79lupldi6d3pshuan0lxcmg.jpeg"><br>  <i>Figura 6. 2 pontos de interrup√ß√£o</i> <br><br>  √â simples: ao analisar uma c√©lula, ao substituir uma pe√ßa nela, contaremos o n√∫mero de pontos de interrup√ß√£o que obteremos no pr√≥ximo turno (o bot olha para o avan√ßo, n√£o se esque√ßa).  Contando 2 pontos de interrup√ß√£o, aumentamos o peso da c√©lula em 100. <br><br>  E agora, o bot n√£o apenas impedir√° tais situa√ß√µes de jogo, mas tamb√©m poder√° cri√°-las, o que o torna agora um oponente mais formid√°vel. <br><br><h3>  Como entender que um ataque √© um ponto de interrup√ß√£o </h3><br>  Vamos come√ßar pelo √≥bvio: qualquer ataque com um poder de 4 √© um ponto de interrup√ß√£o.  Apenas uma jogada perdida nos d√° a oportunidade de concluir o jogo, ou seja,  coloque 5 pe√ßas seguidas. <br><br>  Al√©m disso, se o potencial de ataque for 2, gastaremos 1 turno a mais para bloquear esse ataque, o que significa que h√° um ponto de interrup√ß√£o com pot√™ncia de 3. Mas existe apenas um ponto de interrup√ß√£o - este √© um ataque [3: 2]. <br><br>  E ainda mais dif√≠cil - <b>"ataques rasgados"</b> . <br>  Consideraremos apenas ataques com uma c√©lula vazia no meio - n√£o mais.  Isso ocorre porque, para concluir o ataque com duas c√©lulas vazias no meio, voc√™ precisa gastar pelo menos 2 movimentos - isso claramente n√£o √© um ponto de interrup√ß√£o. <br><br>  Como lembramos, consideramos os ataques divididos como v√°rios convencionais: um ataque central e ataques laterais.  O ataque central pertence √† c√©lula digitalizada, o divisor lateral possui mais de 1 - isso foi descrito acima. <br><br>  Algoritmo para encontrar um ponto de interrup√ß√£o (mais f√°cil, leia abaixo): <br><br><ol><li>  Introduzimos a <b>pontua√ß√£o</b> vari√°vel </li><li>  Tomamos o ataque central, consideramos o poder </li><li>  Tomamos um dos lados se o seu divisor n√£o for superior a 2x. </li><li>  <b>Pontua√ß√£o</b> - a soma do poder dos ataques central e lateral </li><li>  Se o potencial dos ataques central e lateral for 2, para bloquear um ataque desse tipo, voc√™ precisar√° passar mais um turno.  Portanto, a pontua√ß√£o √© aumentada em 1 </li><li>  Se <b>pontua√ß√£o</b> &gt; = 4, ent√£o este √© um ponto de interrup√ß√£o <br>  De fato, os pontos de interrup√ß√£o poderiam ser simplesmente enumerados, n√£o existem muitos, mas eu n√£o entendi imediatamente. </li></ol><br><pre> <code class="javascript hljs">isBreakPoint( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attackLine || ! attackLine.length ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> centAtk; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">1</span></span> ) centAtk = a; }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.potential == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> score = centAtk.capability; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">//side attack if( centAtk.potential == 2 &amp;&amp; a.potential == 2 ) score++; if( score + a.capability &gt;= 4 ){ res = true; return; } } }) return res; }</span></span></code> </pre><br><h3>  Sim, finalmente vamos juntar tudo </h3><br>  Ent√£o, o principal inferno por tr√°s √© descrito acima.  √â hora de moldar algo que funcione a partir dele.  A fun√ß√£o <b>countWeight (x, y)</b> - pega as coordenadas da c√©lula como uma entrada e retorna seu peso.  O que h√° sob o capuz dela? <br><br>  Primeiro, obtemos uma matriz de todos os ataques aos quais a c√©lula pertence.  ( <b>getAllAttacks (x, y)</b> ).  Atravessando todas as linhas, contamos o n√∫mero de pontos de interrup√ß√£o.  Se houver 2 pontos de interrup√ß√£o, lembramos que essa situa√ß√£o pode decidir o resultado do jogo e aumentar o peso da c√©lula em 100. <br>  No entanto, todos os pontos de interrup√ß√£o devem pertencer a um jogador, ent√£o eu tive que implementar uma verifica√ß√£o em 2 etapas: primeiro cruze e depois zeros. <br><br>  Como n√£o <b>forneci</b> ataques com pot√™ncia de 6 ou mais na variedade de pesos de ataque ( <b>ATTACK_WEIGHTS []</b> ), tive que substitu√≠-los por ataques com pot√™ncia de 5. N√£o faz diferen√ßa - todos eles levam ao final do jogo. <br><br>  Bem, resumimos os pesos de ataque - isso √© tudo. <br><br>  Outro pequeno ponto: para que o bot n√£o seja est√∫pido no final do jogo, quando j√° construiu um ataque com pot√™ncia de 4 e pensa no movimento atual, √© necess√°rio aumentar significativamente o peso da c√©lula para concluir esse ataque.  Sem isso, a IA, simplesmente, pode come√ßar a se defender dos ataques "perigosos" do oponente, embora o jogo pare√ßa ter sido vencido.  A √∫ltima jogada √© importante. <br><br><pre> <code class="javascript hljs">countWeight( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attacks = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getAttacks( x, y ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attacks ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.x, <span class="hljs-string"><span class="hljs-string">'√ó'</span></span> ); sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.o, <span class="hljs-string"><span class="hljs-string">'‚óã'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> atks, curFig </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weight = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> breakPoints = <span class="hljs-number"><span class="hljs-number">0</span></span>; [ <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"45"</span></span>, <span class="hljs-string"><span class="hljs-string">"90"</span></span>, <span class="hljs-string"><span class="hljs-string">"135"</span></span> ].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> p </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isBreakPoint( atks[p] ) ){ debug( <span class="hljs-string"><span class="hljs-string">"Break point"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ++breakPoints == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; debug( <span class="hljs-string"><span class="hljs-string">"Good cell"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } atks[p].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ) a.capability = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability == <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; curFig == Model.whoPlays.char ) weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; weight += a.getWeight(); }); }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weight } }</code> </pre><br>  Agora, ao chamar essa fun√ß√£o para uma c√©lula espec√≠fica, obteremos seu peso.  Realizamos esta opera√ß√£o para todas as c√©lulas e selecionamos as melhores (com o maior peso).  L√° e v√°) <br><br>  Voc√™ pode encontrar o restante do c√≥digo no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> .  J√° existe bastante material, e sua apresenta√ß√£o, como ainda n√£o tentei, deixa muito a desejar.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mas se voc√™ pudesse ler at√© este ponto, caro leitor, ent√£o eu sou grato a voc√™. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Minha opini√£o sobre o resultado </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des√ßa! </font><font style="vertical-align: inherit;">Sim, voc√™ pode venc√™-lo, mas faz√™-lo √© um pouco problem√°tico para mim pessoalmente. </font><font style="vertical-align: inherit;">Talvez eu n√£o seja cuidadoso o suficiente. </font><font style="vertical-align: inherit;">Tente sua for√ßa tamb√©m. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu sei que √© mais f√°cil, mas n√£o sei como. </font><font style="vertical-align: inherit;">Eu gostaria de ouvir pessoas que conhecem ou observam outras implementa√ß√µes desse bot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu sei o que pode ser melhor. </font><font style="vertical-align: inherit;">Sim ... voc√™ pode usar algoritmos conhecidos, como o minimax, mas para isso voc√™ precisa ter alguma base de conhecimento no campo da teoria dos jogos, da qual infelizmente n√£o posso me gabar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No futuro, pretendo adicionar a an√°lise de pontos de interrup√ß√£o v√°rios passos adiante, o que tornar√° o bot um rival ainda mais s√©rio. </font><font style="vertical-align: inherit;">No entanto, agora n√£o tenho uma id√©ia clara sobre a implementa√ß√£o disso; </font><font style="vertical-align: inherit;">S√≥ tenho a pr√≥xima sess√£o e um diploma incompleto - o que me entristece. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obrigado se voc√™ ler at√© o fim.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430708/">https://habr.com/ru/post/pt430708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430694/index.html">Um pequeno guia para aprender C ++: o que, quando e sobre o que criar</a></li>
<li><a href="../pt430700/index.html">Um sistema unificado para gravar visualiza√ß√µes de filmes on-line come√ßar√° a funcionar na R√∫ssia</a></li>
<li><a href="../pt430702/index.html">Treinamento muito estranho</a></li>
<li><a href="../pt430704/index.html">Como as tecnologias de intelig√™ncia artificial ajudam a Aviasales a crescer: sete exemplos</a></li>
<li><a href="../pt430706/index.html">Nova teoria da evolu√ß√£o</a></li>
<li><a href="../pt430710/index.html">O que fazer se a Black Friday for amanh√£ e seus servidores n√£o estiverem prontos</a></li>
<li><a href="../pt430712/index.html">NeurIPS: Como conquistar a melhor confer√™ncia de ML</a></li>
<li><a href="../pt430714/index.html">VMware compra Heptio - o que isso significa para o Kubernetes</a></li>
<li><a href="../pt430718/index.html">Para quais objetos vale a pena usar a vigil√¢ncia por v√≠deo na nuvem?</a></li>
<li><a href="../pt430720/index.html">Intel RealSense D435i: pequena atualiza√ß√£o e breve digress√£o hist√≥rica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>