<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôìÔ∏è üéÅ üîÇ Ausnahmesituationen: Teil 1 von 4 üìñ üó£Ô∏è üë∏üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Es ist Zeit, √ºber Ausnahmen oder eher Ausnahmesituationen zu sprechen. Bevor wir beginnen, schauen wir uns die Definition an. Was ist e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ausnahmesituationen: Teil 1 von 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/454630/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a> </p><br><h2 id="introduction">  Einf√ºhrung </h2><br><p>  Es ist Zeit, √ºber Ausnahmen oder eher Ausnahmesituationen zu sprechen.  Bevor wir beginnen, schauen wir uns die Definition an.  Was ist eine Ausnahmesituation? </p><br><p>  Dies ist eine Situation, die die Ausf√ºhrung des aktuellen oder nachfolgenden Codes falsch macht.  Ich meine anders als es entworfen oder beabsichtigt war.  Eine solche Situation beeintr√§chtigt die Integrit√§t einer Anwendung oder ihres Teils, z. B. eines Objekts.  Es bringt die Anwendung in einen au√üergew√∂hnlichen oder au√üergew√∂hnlichen Zustand. </p><br><p>  Aber warum m√ºssen wir diese Terminologie definieren?  Weil es uns in einigen Grenzen halten wird.  Wenn wir uns nicht an die Terminologie halten, k√∂nnen wir zu weit von einem entworfenen Konzept entfernt sein, was zu vielen mehrdeutigen Situationen f√ºhren kann.  Sehen wir uns einige praktische Beispiele an: <br><br></p><br><pre><code class="plaintext hljs">struct Number { public static Number Parse(string source) { // ... if(!parsed) { throw new ParsingException(); } // ... } public static bool TryParse(string source, out Number result) { // .. return parsed; } }</code> </pre> <br><p>  Dieses Beispiel scheint ein wenig seltsam, und das hat einen Grund.  Ich habe diesen Code leicht k√ºnstlich gemacht, um die Wichtigkeit der darin auftretenden Probleme zu verdeutlichen.  Schauen wir uns zun√§chst die <code>Parse</code> Methode an.  Warum sollte es eine Ausnahme ausl√∂sen? </p><a name="habracut"></a><br><ul><li>  Da der akzeptierte Parameter eine Zeichenfolge ist, ist seine Ausgabe eine Zahl, die ein Werttyp ist.  Diese Zahl kann nicht die G√ºltigkeit von Berechnungen anzeigen: Sie existiert nur.  Mit anderen Worten, das Verfahren hat keine Mittel in seiner Schnittstelle, um ein potentielles Problem zu kommunizieren. </li><li>  Andererseits erwartet die Methode eine korrekte Zeichenfolge, die eine Zahl und keine redundanten Zeichen enth√§lt.  Wenn es nicht enth√§lt, gibt es ein Problem bei den Voraussetzungen f√ºr die Methode: Der Code, der unsere Methode aufruft, hat falsche Daten √ºbergeben. </li></ul><br><p>  Daher ist die Situation, in der diese Methode eine Zeichenfolge mit falschen Daten erh√§lt, au√üergew√∂hnlich, da die Methode weder einen korrekten Wert noch irgendetwas zur√ºckgeben kann.  Der einzige Weg ist also, eine Ausnahme auszul√∂sen. </p><br><p>  Die zweite Variante der Methode kann auf einige Probleme mit Eingabedaten hinweisen: Der R√ºckgabewert ist hier <code>boolean</code> was auf eine erfolgreiche Ausf√ºhrung der Methode hinweist.  Diese Methode muss keine Ausnahmen verwenden, um Probleme anzuzeigen: Sie werden alle durch den <code>false</code> R√ºckgabewert abgedeckt. </p><br><h2 id="overview">  √úbersicht </h2><br><p>  Die Behandlung von Ausnahmen sieht m√∂glicherweise so einfach aus wie ABC: Wir m√ºssen nur <code>try-catch</code> Bl√∂cke platzieren und auf entsprechende Ereignisse warten.  Diese Einfachheit wurde jedoch durch die enorme Arbeit der CLR- und CoreCLR-Teams m√∂glich, die alle Fehler, die aus allen Richtungen und Quellen in die CLR kommen, vereinheitlichten.  Um zu verstehen, wor√ºber wir als n√§chstes sprechen werden, schauen wir uns ein Diagramm an: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e12/163/521/e121635214ad6b5b5675ba4231eb85e7.png"></p><br><p>  Wir k√∂nnen sehen, dass es in big .NET Framework zwei Welten gibt: alles, was zu CLR geh√∂rt, und alles, was nicht, einschlie√ülich aller m√∂glichen Fehler, die in Windows und anderen Teilen der unsicheren Welt auftreten. </p><br><ul><li>  Die strukturierte Ausnahmebehandlung (SEH) ist eine Standardmethode, mit der Windows Ausnahmen behandelt.  Wenn <code>unsafe</code> Methoden aufgerufen und Ausnahmen ausgel√∂st werden, erfolgt die unsichere &lt;-&gt; CLR-Konvertierung von Ausnahmen in beide Richtungen: von unsicher zu CLR und r√ºckw√§rts.  Dies liegt daran, dass CLR eine unsichere Methode aufrufen kann, die wiederum eine CLR-Methode aufrufen kann. </li><li>  Vectored Exception Handling (VEH) ist eine Wurzel von SEH und erm√∂glicht es Ihnen, Ihre Handler an Orten zu platzieren, an denen Ausnahmen ausgel√∂st werden k√∂nnen.  Insbesondere wurde es zum Platzieren von <code>FirstChanceException</code> . </li><li>  COM + -Ausnahmen werden angezeigt, wenn die Ursache eines Problems eine COM-Komponente ist.  In diesem Fall muss eine Ebene zwischen COM und einer .NET-Methode einen COM-Fehler in eine .NET-Ausnahme konvertieren. </li><li>  Und nat√ºrlich Wrapper f√ºr HRESULT.  Sie werden eingef√ºhrt, um ein WinAPI-Modell (ein Fehlercode ist in einem R√ºckgabewert enthalten, w√§hrend R√ºckgabewerte mithilfe von Methodenparametern erhalten werden) in ein Ausnahmemodell zu konvertieren, da dies eine Ausnahme ist, die f√ºr .NET Standard ist. </li></ul><br><p>  Andererseits gibt es Sprachen oberhalb der CLI, von denen jede mehr oder weniger Funktionen zur Behandlung von Ausnahmen hat.  Beispielsweise verf√ºgte VB.NET oder F # k√ºrzlich √ºber eine umfassendere Ausnahmebehandlungsfunktion, die in einer Reihe von Filtern ausgedr√ºckt wurde, die in C # nicht vorhanden waren. </p><br><h2 id="return-codes-vs-exception">  R√ºckkehrcodes vs.  Ausnahme </h2><br><p>  Separat sollte ich ein Modell zur Behandlung von Anwendungsfehlern unter Verwendung von R√ºckkehrcodes erw√§hnen.  Die Idee, einfach einen Fehler zur√ºckzugeben, ist klar und deutlich.  Wenn wir Ausnahmen als <code>goto</code> Operator behandeln, wird die Verwendung von R√ºckkehrcodes au√üerdem sinnvoller: In diesem Fall sieht der Benutzer einer Methode die M√∂glichkeit von Fehlern und kann verstehen, welche Fehler auftreten k√∂nnen.  Lassen Sie uns jedoch nicht raten, was besser und wof√ºr ist, sondern das Problem der Wahl anhand einer gut begr√ºndeten Theorie diskutieren. </p><br><p>  Nehmen wir an, dass alle Methoden Schnittstellen haben, um Fehler zu behandeln.  Dann w√ºrden alle Methoden so aussehen: </p><br><pre> <code class="plaintext hljs">public bool TryParseInteger(string source, out int result); public DialogBoxResult OpenDialogBox(...); public WebServiceResult IWebService.GetClientsList(...); public class DialogBoxResult : ResultBase { ... } public class WebServiceResult : ResultBase { ... }</code> </pre> <br><p>  Und ihre Verwendung w√ºrde aussehen wie: </p><br><pre> <code class="plaintext hljs">public ShowClientsResult ShowClients(string group) { if(!TryParseInteger(group, out var clientsGroupId)) return new ShowClientsResult { Reason = ShowClientsResult.Reason.ParsingFailed }; var webResult = _service.GetClientsList(clientsGroupId); if(!webResult.Successful) { return new ShowClientsResult { Reason = ShowClientsResult.Reason.ServiceFailed, WebServiceResult = webResult }; } var dialogResult = _dialogsService.OpenDialogBox(webResult.Result); if(!dialogResult.Successful) { return new ShowClientsResult { Reason = ShowClientsResult.Reason.DialogOpeningFailed, DialogServiceResult = dialogResult }; } return ShowClientsResult.Success(); }</code> </pre> <br><p>  M√∂glicherweise ist dieser Code mit der Fehlerbehandlung √ºberladen.  Ich m√∂chte jedoch, dass Sie Ihre Position √ºberdenken: Alles hier ist eine Emulation eines Mechanismus, der Ausnahmen ausl√∂st und behandelt. </p><br><p>  Wie kann eine Methode ein Problem melden?  Dies kann mithilfe einer Schnittstelle zum Melden von Fehlern erfolgen.  In der <code>TryParseInteger</code> Methode wird eine solche Schnittstelle beispielsweise durch einen R√ºckgabewert dargestellt: Wenn alles in Ordnung ist, gibt die Methode <code>true</code> .  Wenn es nicht in Ordnung ist, wird <code>false</code> .  Hier gibt es jedoch einen Nachteil: Der reale Wert wird √ºber <code>out int result</code> .  Der Nachteil ist, dass der R√ºckgabewert einerseits logisch ist und nach Wahrnehmung mehr "R√ºckgabewert" als der Parameter <code>out</code> . Andererseits k√ºmmern wir uns nicht immer um Fehler. In der Tat, wenn eine Zeichenfolge f√ºr vorgesehen ist Die Analyse stammt von einem Dienst, der diese Zeichenfolge generiert hat. Wir m√ºssen sie nicht auf Fehler √ºberpr√ºfen: Die Zeichenfolge ist immer korrekt und gut f√ºr die Analyse geeignet. Nehmen wir jedoch an, wir verwenden eine andere Implementierung der Methode: </p><br><pre> <code class="plaintext hljs">public int ParseInt(string source);</code> </pre> <br><p>  Dann gibt es eine Frage: Wenn eine Zeichenfolge Fehler enth√§lt, was sollte die Methode tun?  Sollte es Null zur√ºckgeben?  Dies ist nicht korrekt: Die Zeichenfolge enth√§lt keine Null.  In diesem Fall liegt ein Interessenkonflikt vor: Die erste Variante enth√§lt zu viel Code, w√§hrend die zweite Variante keine M√∂glichkeit hat, Fehler zu melden.  Es ist jedoch tats√§chlich einfach zu entscheiden, wann R√ºckkehrcodes und wann Ausnahmen verwendet werden sollen. </p><br><blockquote>  Wenn es normal ist, einen Fehler zu erhalten, w√§hlen Sie einen R√ºckkehrcode.  Beispielsweise ist es normal, wenn ein Textanalyse-Algorithmus auf Fehler in einem Text st√∂√üt. Wenn jedoch ein anderer Algorithmus, der mit einer analysierten Zeichenfolge arbeitet, einen Fehler von einem Parser erh√§lt, kann dies kritisch oder mit anderen Worten au√üergew√∂hnlich sein. </blockquote><br><h2 id="try-catch-finally-in-brief">  Versuchen Sie es kurz </h2><br><p>  Ein <code>try</code> Block deckt einen Abschnitt ab, in dem ein Programmierer eine kritische Situation erwartet, die von externem Code als Norm behandelt wird.  Mit anderen Worten, wenn ein Code seinen internen Status aufgrund einiger Regeln als inkonsistent betrachtet und eine Ausnahme ausl√∂st, kann ein externes System, das eine breitere Sicht auf dieselbe Situation hat, diese Ausnahme mithilfe eines <code>catch</code> Blocks <code>catch</code> und die Ausf√ºhrung des Anwendungscodes normalisieren .  Daher <em>legalisieren Sie Ausnahmen in diesem Codeabschnitt, indem Sie sie abfangen</em> .  Ich denke, es ist eine wichtige Idee, die das Verbot rechtfertigt, alle <code>try-catch(Exception ex){ ...}</code> <em>f√ºr alle F√§lle zu</em> <code>try-catch(Exception ex){ ...}</code> . </p><br><p>  Es bedeutet nicht, dass das Fangen von Ausnahmen einer Ideologie widerspricht.  Ich sage, dass Sie nur die Fehler abfangen sollten, die Sie von einem bestimmten Codeabschnitt erwarten.  Beispielsweise k√∂nnen Sie nicht alle Arten von Ausnahmen erwarten, die von <code>ArgumentException</code> geerbt wurden, oder Sie k√∂nnen keine <code>NullReferenceException</code> , da dies h√§ufig bedeutet, dass ein Problem eher in <em>Ihrem</em> Code als in einem aufgerufenen liegt.  Es ist jedoch zu erwarten, dass Sie eine beabsichtigte Datei nicht √∂ffnen k√∂nnen.  Auch wenn Sie zu 200% sicher sind, dass Sie in der Lage sind, vergessen Sie nicht, dies zu √ºberpr√ºfen. </p><br><p>  Der <code>finally</code> Block ist ebenfalls bekannt.  Es ist f√ºr alle F√§lle geeignet, die von <code>try-catch</code> Bl√∂cken abgedeckt werden.  Mit Ausnahme einiger seltener <em>besonderer</em> Situationen funktioniert dieser Block <em>immer</em> .  Warum wurde eine solche Leistungsgarantie eingef√ºhrt?  Bereinigen der Ressourcen und Gruppen von Objekten, die im <code>try</code> Block zugewiesen oder erfasst wurden und f√ºr die dieser Block verantwortlich ist. </p><br><p>  Dieser Block wird h√§ufig ohne <code>catch</code> Block verwendet, wenn es uns egal ist, welcher Fehler einen Algorithmus besch√§digt hat, wir jedoch alle f√ºr diesen Algorithmus zugewiesenen Ressourcen bereinigen m√ºssen.  Schauen wir uns ein einfaches Beispiel an: Ein Algorithmus zum Kopieren von Dateien ben√∂tigt zwei ge√∂ffnete Dateien und einen Speicherbereich f√ºr einen Geldpuffer.  Stellen Sie sich vor, wir haben Speicher zugewiesen und eine Datei ge√∂ffnet, aber keine andere.  Um alles atomar in eine "Transaktion" zu packen, haben wir alle drei Operationen in einem einzigen <code>try</code> Block (als Variante der Implementierung) zusammengefasst, wobei die Ressourcen <code>finally</code> bereinigt wurden. Es mag wie ein vereinfachtes Beispiel erscheinen, aber das Wichtigste ist, das Wesentliche zu zeigen. </p><br><p>  Was C # tats√§chlich fehlt, ist ein <code>fault</code> , der aktiviert wird, wenn ein Fehler auftritt.  Es ist wie <code>finally</code> auf Steroiden.  Wenn wir dies h√§tten, k√∂nnten wir zum Beispiel einen einzelnen Einstiegspunkt erstellen, um Ausnahmesituationen zu protokollieren: </p><br><pre> <code class="plaintext hljs">try { //... } fault exception { _logger.Warn(exception); }</code> </pre><br><p>  Eine andere Sache, die ich in dieser Einf√ºhrung ansprechen sollte, sind Ausnahmefilter.  Es ist keine neue Funktion auf der .NET-Plattform, aber C # -Entwickler sind m√∂glicherweise neu darin: Die Ausnahmefilterung wurde nur in Version 4 angezeigt.  6.0.  Filter sollten eine Situation normalisieren, in der es einen einzigen Ausnahmetyp gibt, der mehrere Fehlertypen kombiniert.  Es sollte uns helfen, wenn wir uns mit einem bestimmten Szenario befassen m√∂chten, aber zuerst die gesamte Fehlergruppe erfassen und sp√§ter filtern m√ºssen.  Nat√ºrlich meine ich den Code des folgenden Typs: </p><br><pre> <code class="plaintext hljs">try { //... } catch (ParserException exception) { switch(exception.ErrorCode) { case ErrorCode.MissingModifier: // ... break; case ErrorCode.MissingBracket: // ... break; default: throw; } }</code> </pre> <br><p>  Nun k√∂nnen wir diesen Code jetzt richtig umschreiben: </p><br><pre> <code class="plaintext hljs">try { //... } catch (ParserException exception) when (exception.ErrorCode == ErrorCode.MissingModifier) { // ... } catch (ParserException exception) when (exception.ErrorCode == ErrorCode.MissingBracket) { // ... }</code> </pre> <br><p>  Die Verbesserung liegt hier nicht im Fehlen eines <code>switch</code> .  Ich glaube, dieses neue Konstrukt ist in mehreren Punkten besser: </p><br><ul><li>  <code>when</code> wir zum Filtern verwenden, fangen wir genau das, was wir wollen, und es ist ideologisch richtig. </li><li>  Der Code wird in dieser neuen Form besser lesbar.  Durch das Durchsuchen des Codes kann unser Gehirn Bl√∂cke f√ºr die leichtere Behandlung von Fehlern identifizieren, da es zun√§chst nach dem <code>catch</code> und nicht nach dem <code>switch-case</code> sucht. </li><li>  das letzte aber nicht zuletzt: ein vorl√§ufiger Vergleich ist VOR dem Betreten des Fangblocks.  Dies bedeutet, dass dieses Konstrukt schneller funktioniert als ein <code>switch</code> , wenn wir erneut eine Ausnahme ausl√∂sen, wenn wir falsche Vermutungen √ºber m√∂gliche Situationen anstellen. </li></ul><br><p>  Viele Quellen sagen, dass das Besondere an diesem Code ist, dass die Filterung <em>vor dem</em> Abrollen des Stapels erfolgt.  Sie k√∂nnen dies in Situationen sehen, in denen keine anderen Anrufe als √ºblich zwischen dem Ort, an dem eine Ausnahme ausgel√∂st wird, und dem Ort, an dem die Filterpr√ºfung erfolgt, stattfinden. </p><br><pre> <code class="plaintext hljs">static void Main() { try { Foo(); } catch (Exception ex) when (Check(ex)) { ; } } static void Foo() { Boo(); } static void Boo() { throw new Exception("1"); } static bool Check(Exception ex) { return ex.Message == "1"; }</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/e41/c44/c6b/e41c44c6b41164af3aff1aa9489f417f.png" alt="Stapeln ohne sich abzuwickeln"></p><br><p>  Sie k√∂nnen dem Bild entnehmen, dass die Stapelverfolgung nicht nur den ersten Aufruf von <code>Main</code> als Punkt zum Abfangen einer Ausnahme enth√§lt, sondern den gesamten Stapel vor dem Ausl√∂sen einer Ausnahme sowie den zweiten, der √ºber nicht verwalteten Code in <code>Main</code> eingeht.  Wir k√∂nnen annehmen, dass dieser Code genau der Code zum Ausl√∂sen von Ausnahmen ist, der sich in der Phase des Filterns und Ausw√§hlens eines endg√ºltigen Handlers befindet.  Es k√∂nnen jedoch <em>nicht alle Aufrufe verarbeitet werden, ohne dass der Stapel abgewickelt wird</em> .  Ich glaube, dass eine √ºberm√§√üige Einheitlichkeit der Plattform zu viel Vertrauen in sie schafft.  Wenn beispielsweise eine Dom√§ne eine Methode von einer anderen Dom√§ne aufruft, ist sie hinsichtlich des Codes absolut transparent.  Die Art und Weise, wie Methoden Arbeit aufrufen, ist jedoch eine v√∂llig andere Geschichte.  Wir werden im n√§chsten Teil dar√ºber sprechen. </p><br><h3 id="serialization">  Serialisierung </h3><br><p>  Beginnen wir mit den Ergebnissen der Ausf√ºhrung des folgenden Codes (ich habe die √úbertragung eines Anrufs √ºber die Grenze zwischen zwei Anwendungsdom√§nen hinzugef√ºgt). </p><br><pre> <code class="plaintext hljs"> class Program { static void Main() { try { ProxyRunner.Go(); } catch (Exception ex) when (Check(ex)) { ; } } static bool Check(Exception ex) { var domain = AppDomain.CurrentDomain.FriendlyName; // -&gt; TestApp.exe return ex.Message == "1"; } public class ProxyRunner : MarshalByRefObject { private void MethodInsideAppDomain() { throw new Exception("1"); } public static void Go() { var dom = AppDomain.CreateDomain("PseudoIsolated", null, new AppDomainSetup { ApplicationBase = AppDomain.CurrentDomain.BaseDirectory }); var proxy = (ProxyRunner) dom.CreateInstanceAndUnwrap(typeof(ProxyRunner).Assembly.FullName, typeof(ProxyRunner).FullName); proxy.MethodInsideAppDomain(); } } }</code> </pre><br><p>  Wir k√∂nnen sehen, dass das Abrollen des Stapels erfolgt, bevor wir mit dem Filtern beginnen.  Schauen wir uns Screenshots an.  Die erste wird vor der Generierung einer Ausnahme erstellt: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bda/8d8/792/bda8d87928516a8213cafdf953d029b6.png" alt="Stackunnroll"></p><br><p>  Der zweite ist danach: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c2b/f45/dee/c2bf45dee3a13091259468415719dbea.png" alt="Stackacknroll2"></p><br><p>  Lassen Sie uns die Anrufverfolgung untersuchen, bevor und nachdem Ausnahmen gefiltert werden.  Was passiert hier?  Wir k√∂nnen sehen, dass Plattformentwickler etwas gemacht haben, das auf den ersten Blick wie der Schutz einer Subdomain aussieht.  Die Ablaufverfolgung wird nach der letzten Methode in der Aufrufkette unterbrochen, und dann erfolgt die √úbertragung an eine andere Dom√§ne.  Aber ich finde das seltsam.  Um zu verstehen, warum dies geschieht, erinnern wir uns an die Hauptregel f√ºr Typen, die die Interaktion zwischen Dom√§nen organisieren.  Diese Typen sollten <code>MarshalByRefObject</code> erben und serialisierbar sein.  Trotz der Strenge von C # k√∂nnen Ausnahmetypen beliebiger Art sein.  Was bedeutet das  Dies bedeutet, dass Situationen auftreten k√∂nnen, in denen eine Ausnahme innerhalb einer Unterdom√§ne in einer √ºbergeordneten Dom√§ne abgefangen werden kann.  Wenn ein Datenobjekt, das in eine Ausnahmesituation geraten kann, √ºber einige Methoden verf√ºgt, die hinsichtlich der Sicherheit gef√§hrlich sind, k√∂nnen sie in einer √ºbergeordneten Dom√§ne aufgerufen werden.  Um dies zu vermeiden, wird die Ausnahme zuerst serialisiert und √ºberschreitet dann die Grenze zwischen Anwendungsdom√§nen und wird erneut mit einem neuen Stapel angezeigt.  Lassen Sie uns diese Theorie √ºberpr√ºfen: </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Explicit)] class Cast { [FieldOffset(0)] public Exception Exception; [FieldOffset(0)] public object obj; } static void Main() { try { ProxyRunner.Go(); Console.ReadKey(); } catch (RuntimeWrappedException ex) when (ex.WrappedException is Program) { ; } } static bool Check(Exception ex) { var domain = AppDomain.CurrentDomain.FriendlyName; // -&gt; TestApp.exe return ex.Message == "1"; } public class ProxyRunner : MarshalByRefObject { private void MethodInsideAppDomain() { var x = new Cast {obj = new Program()}; throw x.Exception; } public static void Go() { var dom = AppDomain.CreateDomain("PseudoIsolated", null, new AppDomainSetup { ApplicationBase = AppDomain.CurrentDomain.BaseDirectory }); var proxy = (ProxyRunner)dom.CreateInstanceAndUnwrap(typeof(ProxyRunner).Assembly.FullName, typeof(ProxyRunner).FullName); proxy.MethodInsideAppDomain(); } }</code> </pre> <br><p>  Da C # -Code eine Ausnahme von jedem Typ ausl√∂sen kann (ich m√∂chte Sie nicht mit MSIL qu√§len), habe ich in diesem Beispiel einen Trick ausgef√ºhrt, bei dem ein Typ in einen nicht vergleichbaren Typ umgewandelt wurde, sodass wir eine Ausnahme von jedem Typ au√üer dem √úbersetzer ausl√∂sen k√∂nnen w√ºrde denken, dass wir den <code>Exception</code> verwenden.  Wir erstellen eine Instanz des <code>Program</code> , die mit Sicherheit nicht serialisierbar ist, und l√∂sen eine Ausnahme aus, indem wir diesen Typ als Workload verwenden.  Die gute Nachricht ist, dass Sie einen Wrapper f√ºr Nicht-Ausnahme-Ausnahmen von <code>RuntimeWrappedException</code> dem eine Instanz unseres <code>Program</code> Objekts <code>RuntimeWrappedException</code> wird und wir diese Ausnahme abfangen k√∂nnen.  Es gibt jedoch schlechte Nachrichten, die unsere Idee unterst√ºtzen: Aufruf von <code>proxy.MethodInsideAppDomain();</code>  generiert eine <code>SerializationException</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1ad/ace/7f1/1adace7f1c21e2ad7edc51b36f343dc9.png"></p><br><p>  Daher k√∂nnen Sie eine solche Ausnahme nicht zwischen Dom√§nen √ºbertragen, da eine Serialisierung nicht m√∂glich ist.  Dies bedeutet wiederum, dass die Verwendung von Ausnahmefiltern zum Umschlie√üen von Methodenaufrufen in anderen Dom√§nen ohnehin zum Abrollen des Stapels f√ºhrt, obwohl die Serialisierung mit den <code>FullTrust</code> Einstellungen einer Subdom√§ne nicht <code>FullTrust</code> zu sein scheint. </p><br><blockquote>  Wir sollten dem Grund, warum eine Serialisierung zwischen Dom√§nen so notwendig ist, zus√§tzliche Aufmerksamkeit widmen.  In unserem k√ºnstlichen Beispiel erstellen wir eine Subdomain, die keine Einstellungen hat.  Dies bedeutet, dass es auf FullTrust-Weise funktioniert.  CLR vertraut voll und ganz seinem Inhalt und f√ºhrt keine zus√§tzlichen √úberpr√ºfungen durch.  Wenn Sie jedoch mindestens eine Sicherheitseinstellung einf√ºgen, verschwindet die volle Vertrauensw√ºrdigkeit und CLR steuert alles, was in einer Subdomain geschieht.  Wenn Sie also eine vollst√§ndig vertrauensw√ºrdige Domain haben, ben√∂tigen Sie keine Serialisierung.  Gib zu, wir m√ºssen uns nicht sch√ºtzen.  Serialisierung existiert aber nicht nur zum Schutz.  Jede Dom√§ne l√§dt alle erforderlichen Assemblys ein zweites Mal und erstellt ihre Kopien.  Auf diese Weise werden Kopien aller Typen und aller VMTs erstellt.  Wenn Sie ein Objekt von Dom√§ne zu Dom√§ne √ºbergeben, erhalten Sie nat√ºrlich dasselbe Objekt.  Die VMTs sind jedoch keine eigenen und dieses Objekt kann nicht in einen anderen Typ umgewandelt werden.  Mit anderen Worten, wenn wir eine Instanz eines <code>Boo</code> Typs erstellen und in einer anderen Dom√§ne <code>(Boo)boo</code> , funktioniert das Casting von <code>(Boo)boo</code> nicht.  In diesem Fall wird das Problem durch Serialisierung und Deserialisierung gel√∂st, da das Objekt gleichzeitig in zwei Dom√§nen vorhanden ist.  Es wird mit all seinen Daten vorhanden sein, in denen es erstellt wurde, und es wird im Verwendungsbereich als Proxy-Objekt vorhanden sein, um sicherzustellen, dass Methoden eines urspr√ºnglichen Objekts aufgerufen werden. </blockquote><p>  Durch das √úbertragen eines serialisierten Objekts zwischen Dom√§nen erhalten Sie eine vollst√§ndige Kopie des Objekts von einer Dom√§ne in eine andere, w√§hrend Sie einige Abgrenzungen im Speicher behalten.  Diese Abgrenzung ist jedoch fiktiv.  Es wird nur f√ºr Typen verwendet, die nicht in <code>Shared AppDomain</code> .  Wenn Sie also ausnahmsweise etwas nicht serialisierbares <code>Shared AppDomain</code> , aber von <code>Shared AppDomain</code> , wird kein Serialisierungsfehler <code>Shared AppDomain</code> (wir k√∂nnen versuchen, <code>Action</code> anstelle von <code>Program</code> <code>Shared AppDomain</code> ).  In diesem Fall kommt es jedoch trotzdem zum Abrollen des Stapels: Beide Varianten sollten standardm√§√üig funktionieren.  Damit niemand verwirrt wird. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieses Kapitel wurde vom Autor und von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">professionellen √úbersetzern</a> gemeinsam aus dem Russischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der √úbersetzung von Russisch oder Englisch in eine andere Sprache helfen, haupts√§chlich ins Chinesische oder Deutsche. <br><br>  Wenn Sie sich bei uns bedanken m√∂chten, k√∂nnen Sie dies am besten tun, indem Sie uns einen Stern auf Github geben oder das Repository teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454630/">https://habr.com/ru/post/de454630/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454618/index.html">Produktivit√§tsgrube: Wie locker unser Workflow schadet</a></li>
<li><a href="../de454620/index.html">#NoDeployFriday: hilft oder schadet?</a></li>
<li><a href="../de454622/index.html">Kreisel EVEX 910e: historisches Modell - neues Leben</a></li>
<li><a href="../de454626/index.html">DevOops gestern und heute</a></li>
<li><a href="../de454628/index.html">Aufbau eines automatischen Nachrichtenmoderationssystems</a></li>
<li><a href="../de454634/index.html">Sicherheitswoche 23: Notepad-Sicherheitsl√ºcke, eine Million Systeme mit nicht gepatchten RDP</a></li>
<li><a href="../de454640/index.html">Remote-Microservice-Debugging √ºber SSH unter VPN in 4 Runden</a></li>
<li><a href="../de454642/index.html">"Machen Sie eine Anwendung f√ºr Menschen" - dies ist nicht auf das Knie zu kritzeln ": √ºber die mobile Entwicklung in der CFT</a></li>
<li><a href="../de454644/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 8. Setup wechseln</a></li>
<li><a href="../de454646/index.html">@ Pythonetc-Zusammenstellung, Mai 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>