<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚úàÔ∏è ‚õ©Ô∏è ü§¨ Tentang komposisi fungsi dalam JavaScript üë©üèº‚Äç‚öñÔ∏è ü§≥üèª ü§∑üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mari berfantasi tentang topik komposisi fungsional, serta mengklarifikasi makna operator komposisi / pipa. 


 TL; DR 
 Menulis fungsi seperti bos: 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang komposisi fungsi dalam JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432196/"><p>  Mari berfantasi tentang topik komposisi fungsional, serta mengklarifikasi makna operator komposisi / pipa. </p><br><p> TL; DR <br>  Menulis fungsi seperti bos: <br><img src="https://habrastorage.org/getpro/habr/post_images/57a/0a6/0a0/57a0a60a0d56aa2b5c54e460812190b4.png" alt="gambar"><br>  Implementasi populer <code>compose</code> - ketika dipanggil, mereka menciptakan fungsi baru dan baru berdasarkan rekursi, apa kerugiannya dan bagaimana menyiasatinya. </p><a name="habracut"></a><br><p>  Anda dapat mempertimbangkan fungsi tulis sebagai fungsi murni yang hanya bergantung pada argumen.  Jadi, menyusun fungsi yang sama dalam urutan yang sama, kita harus mendapatkan fungsi yang identik, tetapi di dunia JavaScript tidak demikian.  Setiap panggilan untuk menulis - mengembalikan fungsi baru, ini mengarah pada penciptaan lebih banyak fungsi baru di memori, serta masalah memoisasi mereka, perbandingan dan debugging. <br>  Sesuatu harus dilakukan. </p><br><h3 id="motivaciya">  Motivasi </h3><br><ul><li>  Dapatkan identitas asosiatif: </li></ul><br><p>  Sangat disarankan untuk tidak membuat objek baru dan menggunakan kembali hasil fungsi penulisan sebelumnya.  Salah satu masalah pengembang React adalah penerapan shallowCompare, yang berfungsi dengan hasil komposisi fungsi.  Misalnya, komposisi pengiriman acara dengan panggilan balik akan selalu membuat fungsi baru, yang akan mengarah pada pembaruan nilai properti. </p><br><p>  Implementasi populer komposisi tidak memiliki identitas nilai balik. <br>  Secara parsial, masalah identitas lagu dapat diatasi dengan memoise argumen.  Namun, pertanyaan tentang identitas asosiatif tetap: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {memoize} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ramda'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoCompose = memoize(compose) memoCompose(a, b) === memoCompose(a, b) <span class="hljs-comment"><span class="hljs-comment">// ,   memoCompose(memoCompose(a, b), c) === memoCompose(a, memoCompose(b, c)) // ,       </span></span></code> </pre> <br><ul><li>  Sederhanakan komposisi debug: </li></ul><br><p>  Tentu saja, menggunakan fungsi ketuk membantu dalam fungsi debugging yang memiliki ekspresi tunggal di tubuh.  Namun, diinginkan untuk memiliki setumpuk panggilan serata mungkin untuk debugging. </p><br><ul><li>  Singkirkan overhead terkait rekursi: </li></ul><br><p>  Implementasi rekursif dari komposisi fungsional memiliki overhead, menciptakan elemen-elemen baru dalam tumpukan panggilan.  Saat Anda memanggil komposisi 5 fungsi atau lebih, ini jelas terlihat.  Dan dengan menggunakan pendekatan fungsional dalam pengembangan, perlu untuk membangun komposisi dari banyak fungsi yang sangat sederhana. </p><br><h3 id="reshenie">  Solusi </h3><br><p>  Buat monoid (atau semigroupoid dengan dukungan untuk spesifikasi kategori) dalam hal tanah fantasi: </p><br><pre> <code class="plaintext hljs">import compose, {identity} from 'lazy-compose' import {add} from 'ramda' const a = add(1) const b = add(2) const c = add(3) test('Laws', () =&gt; { compose(a, compose(b, c)) === compose(compose(a, b), c) //  compose(a, identity) === a //right identity compose(identity, a) === a //left identity }</code> </pre><br><h3 id="varianty-ispolzovaniya">  Gunakan kasing </h3><br><ul><li>  Berguna dalam memoisasi komposisi komposit ketika bekerja dengan editor.  Misalnya untuk redux / mapStateToProps dan <br>  pilih kembali. </li><li>  Komposisi lensa. </li></ul><br><p>  Anda dapat membuat dan menggunakan kembali lensa yang sederajat dengan fokus pada tempat yang sama. </p><br><pre> <code class="plaintext hljs"> import {lensProp, memoize} from 'ramda' import compose from 'lazy-compose' const constantLens = memoize(lensProp) const lensA = constantLens('a') const lensB = constantLens('b') const lensC = constantLens('c') const lensAB = compose(lensB, lensA) console.log( compose(lensC, lensAB) === compose(lensC, lensB, lensA) )</code> </pre><br><ul><li>  Memoized callbacks, dengan kemampuan untuk menyusun hingga fungsi akhir pengiriman suatu acara. </li></ul><br><p>  Dalam contoh ini, panggilan balik yang sama akan dikirim ke item daftar. </p><br><pre> <code class="plaintext hljs">```jsx import {compose, constant} from './src/lazyCompose' // constant - returns the same memoized function for each argrum // just like React.useCallback import {compose, constant} from 'lazy-compose' const List = ({dispatch, data}) =&gt; data.map( id =&gt; &lt;Button key={id} onClick={compose(dispatch, makeAction, contsant(id))} /&gt; ) const Button = React.memo( props =&gt; &lt;button {...props} /&gt; ) const makeAction = payload =&gt; ({ type: 'onClick', payload, }) ```</code> </pre> <br><ul><li><p>  Komposisi komponen React yang malas tanpa membuat komponen tingkat tinggi.  Dalam hal ini, komposisi malas akan menciutkan susunan fungsi, tanpa membuat penutupan tambahan.  Pertanyaan ini mengkhawatirkan banyak pengembang yang menggunakan pustaka komposisi ulang. </p><br><pre> <code class="plaintext hljs">import {memoize, mergeRight} from 'ramda' import {constant, compose} from './src/lazyCompose' const defaultProps = memoize(mergeRight) const withState = memoize( defaultState =&gt; props =&gt; { const [state, setState] = React.useState(defaultState) return {...props, state, setState} } ) const Component = ({value, label, ...props)) =&gt; &lt;label {...props}&gt;{label} : {value}&lt;/label&gt; const withCounter = compose( ({setState, state, ...props}) =&gt; ({ ...props value: state, onClick: compose(setState, constant(state + 1)) }), withState(0), ) const Counter = compose( Component, withCounter, defaultProps({label: 'Clicks'}), )</code> </pre><br></li><li><p>  Monad dan aplikatif (dalam hal tanah fantasi) dengan kesetaraan yang ketat melalui caching hasil komposisi.  Jika Anda mengakses kamus objek yang sebelumnya dibuat di dalam konstruktor tipe, Anda mendapatkan yang berikut: </p><br></li></ul><br><pre> <code class="plaintext hljs"> type Info = { age?: number } type User = { info?: Info } const mayBeAge = LazyMaybe&lt;Info&gt;.of(identity) .map(getAge) .contramap(getInfo) const age = mayBeAge.ap(data) const maybeAge2 = LazyMaybe&lt;User&gt;.of(compose(getAge, getInfo)) console.log(maybeAge === maybeAge2) //   ,      //          </code> </pre> <br><p>  Saya telah menggunakan pendekatan ini untuk waktu yang lama, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya merancang repositori di sini</a> . <br>  Paket NPM: <code>npm i lazy-compose</code> . </p><br><p>  Sangat menarik untuk mendapatkan umpan balik tentang penutupan cache fungsi yang dibuat dalam runtime tergantung pada penutupan. </p><br><p>  UPD <br>  Saya melihat pertanyaan yang jelas: <br>  Ya, Anda dapat mengganti Peta dengan WeakMap. <br>  Ya, Anda harus memungkinkan untuk menghubungkan cache pihak ketiga sebagai middleware. <br>  Anda seharusnya tidak mengatur debat tentang topik cache, tidak ada strategi cache yang ideal. <br>  Mengapa ekor dan kepala, jika semuanya ada dalam daftar - ekor dan kepala, bagian dari implementasi dengan memoisasi berdasarkan bagian komposisi, dan tidak masing-masing fungsi secara terpisah. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432196/">https://habr.com/ru/post/id432196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432184/index.html">Identitas Masalah Di Antara Penguji</a></li>
<li><a href="../id432186/index.html">Menggunakan STP untuk membuat saluran p2p</a></li>
<li><a href="../id432188/index.html">Peretas APT28 menyerang kotak email ratusan pegawai kementerian Ceko</a></li>
<li><a href="../id432190/index.html">Prediksi fisika sisi klien dalam Unity</a></li>
<li><a href="../id432192/index.html">4 tanda bahwa Anda belum siap untuk mengimplementasikan solusi manajemen proyek</a></li>
<li><a href="../id432198/index.html">Delivery Manager - Peran Baru di Dunia Agile</a></li>
<li><a href="../id432200/index.html">Bagaimana Ivan menyelidiki konversi tegakan</a></li>
<li><a href="../id432202/index.html">Menghasilkan jenis karakter dengan cepat (atau gila dengan Rust)</a></li>
<li><a href="../id432204/index.html">Seminar ‚Äú20 hal kecil yang akan membuat pekerjaan di pusat data benar-benar nyaman‚Äù, 13 Desember, Moskow</a></li>
<li><a href="../id432206/index.html">Analisis terperinci tentang apa yang ditunjukkan Google di konferensi FlutterLive (dan apa artinya bagi Dart dan dunia)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>