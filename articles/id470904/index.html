<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏿 🙌🏿 🙋🏽 Jalur terlembut dan paling berbulu di Machine Learning dan Deep Neural Networks 🤶🏻 👩🏿‍🚀 💔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pembelajaran mesin modern memungkinkan Anda melakukan hal-hal luar biasa. Jaringan saraf berfungsi untuk kepentingan masyarakat: mereka menemukan penj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jalur terlembut dan paling berbulu di Machine Learning dan Deep Neural Networks</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/470904/">  Pembelajaran mesin modern memungkinkan Anda melakukan hal-hal luar biasa.  Jaringan saraf berfungsi untuk kepentingan masyarakat: mereka menemukan penjahat, mengenali ancaman, membantu mendiagnosis penyakit dan membuat keputusan sulit.  Algoritma dapat melampaui seseorang dalam kreativitas: mereka melukis gambar, menulis lagu dan membuat karya dari gambar biasa.  Dan mereka yang mengembangkan algoritma ini sering disajikan sebagai ilmuwan karikatur. <br><br>  Tidak semuanya menakutkan!  Siapa pun yang agak terbiasa dengan pemrograman dapat membangun jaringan saraf dari model dasar.  Dan bahkan tidak perlu mempelajari Python, semuanya dapat dilakukan dalam JavaScript asli.  Sangat mudah untuk memulai dan mengapa pembelajaran mesin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">diperlukan</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">vendor</a> front-end, kata <strong>Aleksey Okhrimenko</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">obenjiro</a> ) di FrontendConf, dan kami mentransfernya ke teks sehingga nama arsitektur dan tautan yang berguna tersedia. <br><br><h2>  Spoiler.  Peringatan! </h2><br>  Cerita ini: <br><br><ul><li> <strong>Bukan untuk mereka yang sudah</strong> bekerja dengan Machine Learning.  Sesuatu yang menarik akan terjadi, tetapi tidak mungkin bahwa di bawah potongan Anda sedang menunggu pembukaan. </li><li>  <strong>Bukan Tentang Transfer Pembelajaran.</strong>  Kami tidak akan berbicara tentang cara menulis jaringan saraf dengan Python, dan kemudian bekerja dengannya dari JavaScript.  Tanpa curang - kami akan menulis jaringan saraf yang dalam khusus di JS. </li><li>  <strong>Tidak semua detailnya.</strong>  Secara umum, semua konsep tidak akan masuk ke dalam satu artikel, tetapi tentu saja kami akan menganalisis yang diperlukan. </li></ul><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BX2M8t5BA3s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara:</strong> Alexei Okhrimenko bekerja di Avito di departemen Arsitektur Frontend, dan dalam waktu luangnya mengadakan Pertemuan Angular Moskow dan merilis "Lima Menit Angular".  Selama karirnya yang panjang, ia telah mengembangkan pola desain MALEVICH, pengurai tata bahasa PEG SimplePEG.  Alexey CSSComb maintainer secara teratur berbagi pengetahuan tentang teknologi baru di konferensi dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran telegram</a> pembelajaran mesin JS-nya. <br><br><h2>  Pembelajaran mesin sangat populer. </h2><br>  Asisten suara, Siri, Asisten Google, Alice, sangat populer dan sering ditemukan dalam kehidupan kita.  Banyak produk telah beralih dari pemrosesan data algoritmik konvensional ke pembelajaran mesin.  Contoh yang mencolok adalah Google Translate. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z3/cg/uz/z3cguzzlmogpjxmymmqhok5xw50.jpeg"></div><br>  Semua inovasi dan chip paling keren di smartphone didasarkan pada pembelajaran mesin. <br><br><img src="https://habrastorage.org/webt/qd/2m/1g/qd2m1gmmouw29qcfbytgd5gdcoc.jpeg"><br><br>  Misalnya, Google NightSight menggunakan pembelajaran mesin.  Foto-foto keren yang kami lihat tidak diperoleh dengan lensa, sensor, atau stabilisasi, tetapi dengan bantuan pembelajaran mesin.  Mesin akhirnya mengalahkan orang-orang di DOTA2, yang berarti bahwa kita memiliki sedikit peluang untuk mengalahkan kecerdasan buatan.  Karena itu, kita harus menguasai pembelajaran mesin secepat mungkin. <br><br><h2>  Mari kita mulai dengan yang sederhana </h2><br>  Apa rutin pemrograman harian kita, bagaimana biasanya kita menulis fungsi? <br><img src="https://habrastorage.org/webt/n1/kn/ss/n1knssbigatyl2zrakkoaazsuai.jpeg"><br>  Kami mengambil data dan algoritme yang kami temukan atau ambil sendiri dari yang sudah jadi, menggabungkan, melakukan sedikit keajaiban dan mendapatkan fungsi yang memberi kami jawaban yang tepat dalam situasi tertentu. <br><br>  Kami terbiasa dengan urutan hal-hal ini, tetapi akan ada kesempatan seperti itu, tanpa mengetahui algoritma, tetapi hanya memiliki data dan jawabannya, dapatkan algoritma dari mereka. <br><br><img src="https://habrastorage.org/webt/tq/6p/4w/tq6p4wwa4ctyhg_j7a4b_t2dhl0.jpeg"><br><br>  Anda dapat mengatakan: "Saya seorang programmer, saya selalu bisa menulis algoritma." <br><br>  Oke, tapi misalnya, algoritma apa yang diperlukan di sini? <br><br><img src="https://habrastorage.org/webt/mq/ey/ce/mqeycerayzppkiqobxr_-o13oka.jpeg"><br><br>  Misalkan kucing memiliki telinga yang tajam, dan telinga anjing itu kusam, kecil, seperti pesek. <br><br><img src="https://habrastorage.org/webt/nv/dp/-h/nvdp-h5hvyset6n3fz-q6ya03hs.jpeg"><br><br>  Mari kita coba memahami siapa yang mendengarnya.  Tetapi pada titik tertentu, kami menemukan bahwa anjing dapat memiliki telinga yang tajam. <br><br><img src="https://habrastorage.org/webt/uk/j2/pr/ukj2prwe9ln0hdjj6x0qa5q9vxw.jpeg"><br><br>  Hipotesis kami tidak baik, kami membutuhkan karakteristik lain.  Seiring waktu, kita akan belajar lebih banyak dan lebih banyak detail, dengan demikian mendemotivasi diri kita sendiri semakin banyak, dan pada titik tertentu kita akan ingin keluar dari bisnis ini sama sekali. <br><br>  Saya membayangkan gambar yang ideal seperti ini: sebelumnya ada jawaban (kita tahu gambar seperti apa itu), ada data (kita tahu bahwa kucing digambar), kita ingin mendapatkan algoritma yang dapat memberi makan data dan mendapatkan jawaban pada output. <br><br>  Ada solusi - ini adalah pembelajaran mesin, yaitu salah satu bagiannya - jaringan saraf yang dalam. <br><br><h2>  Jaringan saraf yang mendalam </h2><br>  Pembelajaran mesin adalah bidang yang sangat luas.  Ini menawarkan sejumlah besar metode, dan masing-masing bagus dengan caranya sendiri. <br><br><img src="https://habrastorage.org/webt/qv/8t/kj/qv8tkjpyrk_qeia-hp4fxkvco7w.jpeg"><br><br>  Salah satunya adalah Deep Neural Networks.  Pembelajaran mendalam memiliki keunggulan yang tak dapat disangkal karena telah menjadi populer. <br><br>  Untuk memahami keunggulan ini, mari kita lihat masalah klasifikasi klasik menggunakan kucing dan anjing sebagai contoh. <br><br>  Ada data: gambar atau foto.  Hal pertama yang harus dilakukan adalah menanamkan (embedding), yaitu mengubah data sehingga mesin nyaman bekerja dengan mereka.  Tidak nyaman bekerja dengan gambar, mobil membutuhkan sesuatu yang lebih sederhana. <br><br>  Pertama, luruskan gambar dan hapus warnanya.  Tidak peduli apa warna anjing atau kucing itu, penting untuk menentukan jenis hewan.  Kemudian kita mengubah gambar menjadi array, di mana, misalnya, 0 gelap, 1 terang. <br><br><img src="https://habrastorage.org/webt/th/st/aq/thstaqtmxfb1jqo-eacmrtlaxym.jpeg"><br><br>  Dengan penyajian data ini, jaringan saraf sudah dapat bekerja. <br><br>  Mari kita membuat dua array lagi dan menggabungkannya menjadi "lapisan" tertentu.  Selanjutnya, kita akan mengalikan masing-masing elemen layer dan array data satu sama lain menggunakan perkalian matriks sederhana, dan mengarahkan hasilnya menjadi dua fungsi aktivasi (nanti kita akan menganalisis apa fungsi-fungsi ini).  Jika fungsi aktivasi menerima sejumlah nilai yang cukup, maka itu "diaktifkan" dan akan menghasilkan hasil: <br><br><ul><li>  fungsi pertama akan mengembalikan 1 jika kucing, dan 0 jika bukan kucing. </li><li>  fungsi kedua akan mengembalikan 1 jika itu anjing, dan 0 jika bukan anjing. </li></ul><br>  Pendekatan pengkodean respons ini disebut <strong>One-Hot Encoding</strong> . <br><br><img src="https://habrastorage.org/webt/bb/-a/x5/bb-ax5li-ngkav87ibjjazse6m4.jpeg"><br><br>  Beberapa fitur jaringan syaraf yang dalam sudah terlihat: <br><br><ul><li>  Untuk bekerja dengan jaringan saraf, Anda perlu menyandikan data pada input dan mendekode pada output. </li><li>  Pengkodean memungkinkan kita untuk abstrak dari data. </li><li>  Dengan mengubah data input, kita dapat menghasilkan jaringan saraf untuk berbagai domain domain.  Bahkan mereka yang kami bukan ahli. </li></ul><br>  Tidak perlu tahu apa itu kucing, apa itu anjing.  Cukup untuk memilih nomor yang diperlukan untuk lapisan tambahan. <br><br>  Sejauh ini, satu-satunya hal yang masih belum jelas adalah mengapa jaringan ini disebut "dalam." <br>  Semuanya sangat sederhana: kita dapat membuat layer lain (array dan fungsi aktivasi mereka).  Dan mentransfer hasil dari satu lapisan ke lapisan lain. <br><br><img src="https://habrastorage.org/webt/9n/8r/qh/9n8rqhrwuewcgwa17oq-beuj7r4.jpeg"><br><br>  Anda dapat berbaring satu sama lain karena banyak lapisan ini dan fungsinya untuk aktivasi.  Menggabungkan arsitektur berlapis, kita mendapatkan jaringan saraf yang dalam.  Kedalamannya adalah banyak lapisan.  Dan secara kolektif disebut <strong>"model</strong> . <strong>"</strong> <br><br>  Sekarang mari kita lihat bagaimana nilai-nilai dipilih untuk semua lapisan ini.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">visualisasi</a> keren yang memungkinkan Anda memahami bagaimana proses pembelajaran terjadi. <br><br><img src="https://habrastorage.org/webt/aw/ot/at/awotatoajim-4vykkxk5wgldodq.jpeg"><br><br>  Di sebelah kiri adalah data, dan di sebelah kanan adalah salah satu lapisan.  Dapat dilihat bahwa mengubah nilai-nilai di dalam array lapisan, kita tampaknya mengubah sistem koordinat.  Sehingga beradaptasi dengan data dan pembelajaran.  Dengan demikian, pembelajaran adalah proses memilih nilai yang tepat untuk layer array.  Nilai-nilai ini disebut bobot atau bobot. <br><br><h2>  Belajar mesin itu sulit </h2><br>  Saya ingin membuat Anda marah, pembelajaran mesin itu sulit.  Semua hal di atas adalah penyederhanaan yang bagus.  Di masa depan, Anda akan menemukan sejumlah besar aljabar linier, dan cukup kompleks.  Sayangnya, tidak ada jalan keluar dari ini. <br><br>  Tentu saja, ada kursus, tetapi bahkan pelatihan tercepat berlangsung beberapa bulan dan tidak murah.  Plus, Anda masih harus mencari tahu sendiri.  Bidang pembelajaran mesin telah tumbuh sangat banyak sehingga melacak segala sesuatu hampir mustahil.  Misalnya, di bawah ini adalah seperangkat model untuk menyelesaikan hanya satu tugas (deteksi objek): <br><br><img src="https://habrastorage.org/webt/tw/bx/rs/twbxrs3-fary0wir6wd-e4x_2_i.jpeg"><br><br>  Secara pribadi, saya sangat kehilangan motivasi.  Saya tidak bisa mendekati jaringan saraf dan mulai bekerja dengan mereka.  Tetapi saya telah menemukan cara dan ingin membaginya dengan Anda.  Ini bukan revolusioner, tidak ada yang seperti itu di dalamnya, Anda sudah terbiasa dengannya. <br><br><h2>  Blackbox - Pendekatan Sederhana </h2><br>  Anda tidak perlu memahami sepenuhnya semua aspek pembelajaran mesin untuk mempelajari cara menerapkan jaringan saraf pada tugas bisnis Anda.  Saya akan menunjukkan beberapa contoh yang semoga menginspirasi Anda. <br><br>  Bagi banyak orang, mobil juga kotak hitam.  Tetapi bahkan jika Anda tidak tahu cara kerjanya, Anda perlu mempelajari aturannya.  Jadi dengan pembelajaran mesin - Anda masih perlu tahu beberapa aturan: <br><br><ul><li>  Pelajari TensorFlow JS (perpustakaan untuk bekerja dengan jaringan saraf). </li><li>  Belajar memilih model. </li></ul><br>  Kami fokus pada tugas-tugas ini dan mulai dengan kode. <br><br><h2>  Belajar dengan membuat kode </h2><br>  Perpustakaan TensorFlow ditulis untuk sejumlah besar bahasa: Python, C / C ++, JavaScript, Go, Java, Swift, C #, Haskell, Julia, R, Scala, Karat, OCaml, Crystal.  Tapi kami pasti akan memilih yang terbaik - JavaScript. <br><br>  TensorFlow dapat dihubungkan ke halaman kami dengan menghubungkan skrip dengan CDN: <br><br><pre><code class="javascript hljs">&lt;script src=<span class="hljs-string"><span class="hljs-string">"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Atau gunakan npm: <br><br><ul><li>  <code>npm install @tensorflow/tfjs-node</code> - untuk proses node (situs web); </li><li>  <code>npm install @tensorflow/tfjs-node-gpu</code> (Linux CUDA) - untuk GPU, tetapi hanya jika mesin Linux dan kartu video mendukung teknologi CUDA.  Pastikan untuk memastikan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kemampuan Komputasi CUDA</a> cocok dengan perpustakaan Anda sehingga tidak terbukti bahwa perangkat keras yang mahal tidak cocok. </li><li>  <code>npm install @tensorflow/tfjs</code> ( <code>npm install @tensorflow/tfjs</code> / Browser) - untuk browser tanpa menggunakan Node.js. </li></ul><br>  Untuk bekerja dengan TensorFlow JS, cukup mengimpor satu dari modul di atas.  Anda akan melihat banyak contoh kode tempat semuanya diimpor.  Tidak perlu melakukan ini, pilih dan impor hanya satu. <br><br><h3>  Tensor </h3><br>  Ketika data awal siap, hal pertama yang harus dilakukan adalah <strong>mengimpor TensorFlow</strong> .  Kami akan menggunakan tensorflow / tfjs-node-gpu untuk mendapatkan akselerasi karena kekuatan kartu video. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  @tensorflow/tfjs-node-gpu  node.js const tf = require('@tensorflow/tfjs'); const a = [[1,2], [3,4]];</span></span></code> </pre> <br>  Ada array data dua dimensi - kami akan bekerja dengannya. <br><br>  Hal penting berikutnya yang harus dilakukan adalah <strong>membuat tensor</strong> .  Dalam hal ini, tensor dibuat dari peringkat 2, yaitu, sebenarnya array dua dimensi.  Kami mentransfer data dan mendapatkan tensor 2x2. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  rank-2  (/) const b = tf.tensor([[1,2], [3,4]]); console.log('shape:', b.shape); b.print()</span></span></code> </pre> <br>  Perhatikan bahwa metode <code>print</code> disebut, bukan <code>console.log</code> , karena <code>b</code> (tensor yang kami buat) bukan objek biasa, yaitu tensor.  Dia memiliki metode dan propertinya sendiri. <br><br>  Anda juga dapat membuat tensor dari array planar dan mengingat bentuknya, katakanlah.  Yaitu, untuk mendeklarasikan bentuk - array dua dimensi - untuk mentransmisikan hanya sebuah array datar dan menunjukkan secara langsung formulir.  Hasilnya akan sama. <br><br>  Karena kenyataan bahwa data dan formulir dapat disimpan secara terpisah, Anda dapat mengubah bentuk tensor.  Kita dapat memanggil metode <code>reshape</code> dan mengubah bentuk dari 2x2 ke 4x1. <br><br>  Langkah penting berikutnya adalah <strong>mengeluarkan data</strong> , mengembalikannya kembali ke dunia nyata. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const g = tf.tensor([[1,2], [3,4]]); g.data().then((raw) =&gt; { console.log('async raw value of g:', raw); }); console.log('raw value of g:', g.dataSync()); console.log('raw multidimensional value of g:', g.arraySync());</span></span></code> </pre> <br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode untuk</a> ketiga langkah.</i> <br><br>  Metode <code>data</code> mengembalikan janji.  Setelah diselesaikan, kami mendapatkan nilai langsung dari nilai mentah, tetapi mendapatkannya secara tidak sinkron.  Jika kita mau, kita bisa mendapatkannya secara sinkron, tetapi ingat bahwa di sini Anda dapat kehilangan kinerja, jadi gunakan metode asinkron bila memungkinkan. <br><br>  Metode <code>dataSync</code> selalu mengembalikan data dalam format array datar.  Dan jika kita ingin mengembalikan data dalam format penyimpanannya, kita perlu memanggil <code>arraySync</code> . <br><br><h3>  Operator </h3><br>  Semua operator di TensorFlow tidak <strong>dapat diubah secara default</strong> , yaitu, dalam setiap operasi tensor baru selalu dikembalikan.  Di atas, ambil saja array kami dan buat persegi semua elemennya. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   Immutable const x = tf.tensor([1,2,3,4]); const y = x.square(); // tf.square(x); y.print();</span></span></code> </pre> <br>  Mengapa kesulitan seperti itu untuk operasi matematika sederhana?  Semua operator yang kita butuhkan - jumlah, median, dll - ada di sana.  Ini diperlukan karena, pada kenyataannya, tensor dan pendekatan ini memungkinkan Anda untuk membuat grafik perhitungan dan melakukan perhitungan tidak segera, tetapi pada WebGL (di browser) atau CUDA (Node.js pada mesin).  Artinya, sebenarnya menggunakan Akselerasi Perangkat Keras tidak terlihat oleh kami dan, jika perlu, melakukan fallback pada CPU.  Yang hebat adalah kita tidak perlu memikirkan apa pun tentang itu.  Kita hanya perlu mempelajari API tfjs. <br><br>  Sekarang yang paling penting adalah modelnya. <br><br><h3>  Model </h3><br>  Cara termudah untuk membuat model adalah Berurutan, yaitu, model berurutan, ketika data dari satu lapisan ditransfer ke lapisan berikutnya, dan dari itu ke lapisan berikutnya.  Lapisan paling sederhana yang digunakan di sini digunakan. <blockquote>  Lapisan itu sendiri hanyalah abstraksi dari tensor dan operator.  Secara kasar, ini adalah fungsi pembantu yang menyembunyikan sejumlah besar matematika dari Anda. </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    const model = tf.sequential({ layers: [ tf.layers.dense({ inputShape: [784], units: 32, activation: 'relu' }), tf.layers.dense({ units: 10, activation: 'softmax' }) ] });</span></span></code> </pre> <br>  Mari kita coba memahami cara bekerja dengan model tanpa masuk ke detail implementasi. <br><br>  Pertama, kami menunjukkan bentuk data yang jatuh ke dalam jaringan saraf - <code>inputShape</code> adalah parameter yang diperlukan.  Kami menunjukkan <code>units</code> - jumlah array multidimensi dan fungsi aktivasi. <br><br>  Fungsi <code>relu</code> luar biasa karena ditemukan secara kebetulan - dicoba, bekerja lebih baik, dan untuk waktu yang sangat lama kemudian mereka mencari penjelasan matematis mengapa hal ini terjadi. <br><br>  Untuk lapisan terakhir, ketika kita membuat kategori, fungsi softmax sering digunakan - sangat cocok untuk menampilkan jawaban dalam format One-Hot Encoding.  Setelah model dibuat, panggil <code>model.summary()</code> untuk memastikan bahwa model tersebut dipasang dengan cara yang benar.  Dalam situasi yang sangat sulit, Anda dapat mendekati pembuatan model menggunakan pemrograman fungsional. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const input = tf.input({ shape: [784] }); const dense1 = tf.layers.dense({ units: 32, activation: 'relu' }).apply(input); const dense2 = tf.layers.dense({ units: 10, activation: 'softmax' }).apply(dense1); const model = tf.model({ inputs: input, outputs: dense2 });</span></span></code> </pre> <br>  Jika Anda perlu membuat model yang sangat kompleks, Anda dapat menggunakan pendekatan fungsional: setiap kali setiap layer adalah variabel baru.  Sebagai contoh, kita secara manual mengambil layer berikutnya dan menerapkan layer sebelumnya, sehingga kita dapat membangun arsitektur yang lebih kompleks.  Saya akan tunjukkan nanti di mana ini bisa berguna. <br><br>  Detail yang sangat penting berikutnya adalah bahwa kita melewatkan lapisan input dan output ke dalam model, yaitu lapisan yang memasuki jaringan saraf dan lapisan yang merupakan lapisan untuk jawabannya. <br><br>  Setelah ini, langkah penting adalah <strong>mengkompilasi model</strong> .  Mari kita coba untuk memahami apa kompilasi dalam hal tfjs. <br><br>  Ingat, kami mencoba menemukan nilai yang tepat di jaringan saraf kami.  Tidak perlu mengambilnya.  Mereka dipilih dengan cara tertentu, seperti fungsi pengoptimal mengatakan. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   (  ) model.compile({ optimizer: 'sgd', loss: 'categoricalCrossentropy', metrics: ['accuracy'] });</span></span></code> </pre> <br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode untuk</a> deskripsi lapisan berurutan dan kompilasi.</i> <br><br>  Saya akan menggambarkan apa itu pengoptimal dan apa fungsi kerugiannya. <br><br><img src="https://habrastorage.org/webt/se/lt/1l/selt1lv8ppxvokzopux387dp0os.png"><br><br>  Pengoptimal adalah seluruh peta.  Ini memungkinkan Anda untuk tidak hanya berjalan secara acak dan mencari nilai, tetapi melakukannya dengan bijak, menurut algoritma tertentu. <br><br>  Fungsi kerugian adalah cara kita mencari nilai optimal (panah hitam kecil).  Ini membantu untuk memahami nilai gradien mana yang digunakan untuk melatih jaringan saraf kita. <br><br>  Di masa depan, ketika Anda menguasai jaringan saraf, Anda akan menulis sendiri fungsi kerugian.  Sebagian besar keberhasilan jaringan saraf tergantung pada seberapa baik fungsi ini ditulis.  Tapi ini cerita lain.  Mari kita mulai dari yang sederhana. <br><br><h4>  Contoh Pembelajaran Jaringan </h4><br>  Kami akan menghasilkan data acak dan jawaban acak (label).  Kami memanggil modul <code>fit</code> , meneruskan data, jawaban, dan beberapa parameter penting: <br><br><ul><li>  <code>epochs</code> - 5 kali, yaitu, kira-kira, 5 kali kita akan melakukan pelatihan penuh; </li><li>  <code>batchSize</code> , yang mengatakan berapa banyak bobot yang dapat diubah pada satu waktu untuk mengangkat - berapa banyak elemen yang diproses pada saat yang sama.  Semakin baik kartu video, semakin banyak memori yang dimilikinya, semakin banyak <code>batchSize</code> dapat diatur. </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const data = tf.randomNormal([100, 784]); const labels = tf.randomNormal([100, 10]); //   model.fit(data, labels, { epochs: 5, batchSize: 32 }).then(info =&gt; { console.log('  :', info.history.acc); })</span></span></code> </pre> <br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode</a> semua langkah terakhir.</i> <br><br>  Metode asinkron <code>Model.fit</code> , mengembalikan janji.  Tetapi Anda dapat menggunakan async / menunggu dan menunggu eksekusi seperti itu. <br><br>  Selanjutnya adalah <strong>penggunaan</strong> .  Kami melatih model kami, lalu kami mengambil data yang ingin kami proses, dan kami menyebut metode <code>predict</code> , kami berkata: "Prediksi apa yang sebenarnya ada di sana?", Dan terima kasih untuk ini kami mendapatkan hasilnya. <br><br><h3>  Struktur standar </h3><br>  Setiap jaringan saraf memiliki tiga file utama: <br><br><ul><li>  index.js - file di mana semua parameter jaringan saraf disimpan; </li><li>  model.js - file di mana model dan arsitekturnya disimpan secara langsung; </li><li>  data.js - file tempat data dikumpulkan, diproses, dan disematkan dalam sistem kami. </li></ul><br>  Jadi, saya berbicara tentang cara belajar TensorFlow.js.  Usaha kecil, tetap <strong>memilih model</strong> . <br><br>  Sayangnya, ini tidak sepenuhnya benar.  Bahkan, setiap kali Anda memilih model, Anda harus mengulangi langkah-langkah tertentu. <br><br><ul><li>  Siapkan data untuk itu, yaitu, buat penyematan, sesuaikan dengan arsitekturnya. </li><li>  Konfigurasikan pengaturan Hyper (Saya akan memberi tahu Anda nanti apa artinya ini). </li><li>  Latih / latih setiap jaringan saraf (masing-masing model mungkin memiliki nuansa sendiri). </li><li>  Terapkan model saraf, dan sekali lagi, Anda bisa menerapkannya dengan berbagai cara. </li></ul><br><h2>  Pilih model </h2><br>  Mari kita mulai dengan opsi dasar yang sering Anda temui. <br><br><h3>  Akal sehat </h3><br>  Ini adalah contoh populer dari jaringan saraf yang dalam.  Semuanya dilakukan dengan cukup sederhana: ada dataset yang tersedia untuk umum - dataset MNIST. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6g/yu/-4/6gyu-4wjgg4zfvf8w7byjx_z5yw.jpeg" width="600"></div><br>  Ini adalah gambar-gambar berlabel dengan angka-angka, atas dasar yang nyaman untuk melatih jaringan saraf. <br><br>  Sesuai dengan arsitektur One-Hot Encoding, kami menyandikan setiap lapisan terakhir.  Digit 10 - dengan demikian, akan ada 10 lapisan terakhir di akhir.  Kami hanya mengirimkan gambar hitam dan putih ke pintu masuk, semua ini sangat mirip dengan apa yang kita bicarakan di awal. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> model = tf.sequential({ <span class="hljs-attr"><span class="hljs-attr">layers</span></span>: [ tf.layers.dense({ <span class="hljs-attr"><span class="hljs-attr">inputShape</span></span>: [<span class="hljs-number"><span class="hljs-number">784</span></span>], <span class="hljs-attr"><span class="hljs-attr">units</span></span>: <span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-attr"><span class="hljs-attr">activation</span></span>: <span class="hljs-string"><span class="hljs-string">'relu'</span></span> }), tf.layers.dense({ <span class="hljs-attr"><span class="hljs-attr">units</span></span>: <span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-attr"><span class="hljs-attr">activation</span></span>: <span class="hljs-string"><span class="hljs-string">'relu'</span></span> }), tf.layers.dense({ <span class="hljs-attr"><span class="hljs-attr">units</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">activation</span></span>: <span class="hljs-string"><span class="hljs-string">'softmax'</span></span> }), ] });</code> </pre> <br>  Kami meluruskan gambar menjadi array satu dimensi, kami mendapatkan 784 elemen.  Dalam satu lapisan, 512 array.  Fungsi aktivasi <code>'relu'</code> . <br><br>  Lapisan array selanjutnya sedikit lebih kecil (256), lapisan aktivasi juga <code>'relu'</code> .  Kami mengurangi jumlah array untuk mencari karakteristik yang lebih umum.  Jaringan saraf harus didorong bagaimana belajar, dan dipaksa untuk membuat keputusan umum yang lebih serius, karena dia sendiri tidak akan melakukannya. <br><br>  Pada akhirnya kami membuat 10 matriks dan menggunakan aktivasi softmax untuk One-Hot Encoding - jenis aktivasi ini bekerja dengan baik dengan jenis pengkodean respons ini. <br><br>  Jaringan yang dalam memungkinkan Anda mengenali 80-90% gambar dengan benar - Saya ingin lebih banyak.  Seseorang mengenali dengan kualitas sekitar 96%.  Dapatkah jaringan saraf menangkap dan menyalip seseorang? <br><br><h3>  CNN (Jaringan Neural Konvolusional) </h3><br>  Jaringan konvolusional bekerja sangat sederhana.  Pada akhirnya, mereka memiliki arsitektur yang sama seperti pada contoh sebelumnya.  Tetapi pada awalnya, sesuatu yang lain terjadi.  Array, alih-alih hanya memberikan beberapa solusi, kurangi gambarnya.  Mereka mengambil bagian dari gambar dan mengurangi, runtuh, menjadi satu digit.  Kemudian mereka dikumpulkan bersama-sama dan sekali lagi dikurangi. <br><img src="https://habrastorage.org/webt/mi/xc/gk/mixcgkl0kgopjxgams8szm0wr2q.jpeg"><br>  Dengan demikian, ukuran gambar berkurang, tetapi pada saat yang sama bagian gambar dikenali lebih baik dan lebih baik.  Jaringan konvolusi bekerja sangat baik untuk pengenalan pola, bahkan lebih baik daripada manusia. <br><blockquote>  Mengenali gambar lebih baik dipercayakan pada mobil daripada seseorang.  Ada penelitian khusus, dan orang itu, sayangnya, hilang. </blockquote>  CNN bekerja sangat sederhana: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> model = tf.sequential({ <span class="hljs-attr"><span class="hljs-attr">layers</span></span>: [ tf.layers.conv2d({ <span class="hljs-attr"><span class="hljs-attr">inputShape</span></span>: [<span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-attr"><span class="hljs-attr">filters</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-attr"><span class="hljs-attr">kernelSize</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">activation</span></span>: <span class="hljs-string"><span class="hljs-string">'relu'</span></span>, }), tf.layers.conv2d({ <span class="hljs-attr"><span class="hljs-attr">filters</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-attr"><span class="hljs-attr">kernelSize</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">activation</span></span>: <span class="hljs-string"><span class="hljs-string">'relu'</span></span>, }), tf.layers.maxPooling2d({<span class="hljs-attr"><span class="hljs-attr">poolSize</span></span>: [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]}), tf.layers.conv2d({ <span class="hljs-attr"><span class="hljs-attr">filters</span></span>: <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-attr"><span class="hljs-attr">kernelSize</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">activation</span></span>: <span class="hljs-string"><span class="hljs-string">'relu'</span></span>, }) tf.layers.flatten(tf.layers.maxPooling2d({ <span class="hljs-attr"><span class="hljs-attr">poolSize</span></span>: [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] })), tf.layers.dense({<span class="hljs-attr"><span class="hljs-attr">units</span></span>: <span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-attr"><span class="hljs-attr">activation</span></span>: <span class="hljs-string"><span class="hljs-string">'relu'</span></span>}), tf.layers.dense({<span class="hljs-attr"><span class="hljs-attr">units</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">activation</span></span>: <span class="hljs-string"><span class="hljs-string">'softmax'</span></span>}) ] });</code> </pre> <br>  Kami memasukkan larik multidimensi tertentu: gambar 28x28 piksel, ditambah satu dimensi untuk kecerahan, dalam hal ini gambarnya hitam dan putih, sehingga dimensi ketiga adalah 1. <br><br>  Selanjutnya, kami menetapkan jumlah <code>filters</code> dan <code>kernelSize</code> - berapa banyak piksel akan menyempit.  Fungsi aktivasi <code>relu</code> mana-mana. <br><br>  Ada <code>maxPooling2d</code> lapisan lain, yang diperlukan untuk mengurangi ukuran lebih efisien.  Jaringan konvolusional mempersempit ukurannya secara bertahap, dan seringkali tidak perlu membuat jaringan konvolusional yang sangat dalam. <br><br>  Saya akan menjelaskan mengapa tidak mungkin untuk melakukan jaringan konvolusi yang sangat dalam nanti, tetapi untuk sekarang, ingat: kadang-kadang mereka perlu digulung sedikit lebih cepat.  Ada lapisan maxPooling terpisah untuk ini. <br><br>  Pada akhirnya ada lapisan padat yang sama.  Artinya, menggunakan jaringan saraf convolutional, kami menarik berbagai tanda dari data, setelah itu kami menggunakan pendekatan standar dan mengkategorikan hasil kami, berkat itu kami mengenali gambar. <br><br><h3>  U net </h3><br>  Model arsitektur ini dikaitkan dengan jaringan konvolusi.  Dengan bantuannya, banyak penemuan telah dibuat dalam bidang pengendalian kanker, misalnya, dalam pengenalan sel kanker dan glaukoma.  Selain itu, model ini dapat menemukan sel-sel ganas tidak lebih buruk daripada seorang profesor di bidang ini. <br><br>  Contoh sederhana: di antara data berisik Anda perlu menemukan sel kanker (lingkaran). <br><br><img src="https://habrastorage.org/webt/hj/9b/yr/hj9byresramxnetrg7t_kenia0a.jpeg"><br><br>  U-Net sangat bagus sehingga dapat menemukan mereka hampir dengan sempurna.  Arsitekturnya sangat sederhana: <br><br><img src="https://habrastorage.org/webt/16/5_/vx/165_vxamsqm5eveub2tdhzxprc8.jpeg"><br><br>  Ada jaringan konvolusi yang sama, seperti halnya MaxPooling, yang mengurangi ukurannya.  Satu-satunya perbedaan: model ini juga menggunakan jaringan <strong>pindai</strong> - <strong>jaringan dekonvolusional</strong> . <br><br>  Selain pemindaian konvolusi, masing-masing lapisan tingkat tinggi digabungkan satu sama lain (mulai dan keluar), karena itu muncul sejumlah besar hubungan.  U-Net seperti itu bekerja dengan baik bahkan pada sejumlah kecil data. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//First part (down climb) const input = buildInput(...IMAGE_INPUT); const conv1 = genConv2D(64).apply(input); const conv2 = genConv2D(64).apply(conv1); const pool1 = geMaxPool2D(2).apply(conv2); const conv3 = genConv2D(128).apply(pool1); const conv4 = genConv2D(128).apply(conv3); const pool2 = geMaxPool2D(2).apply(conv4); const conv5 = genConv2D(256).apply(pool2); const conv6 = genConv2D(256).apply(conv5); const pool3 = geMaxPool2D(2).apply(conv6); const conv7 = genConv2D(512).apply(pool3); const conv8 = genConv2D(512).apply(conv7); const pool4 = geMaxPool2D(2).apply(conv8); const conv9 = genConv2D(1024).apply(pool4); const conv10 = genConv2D(1024).apply(conv9); const up1 = genUp2D().apply(conv10); const merge1 = tf.layers.concatenate({ axis: 3 }).apply([up1, conv8]); //Second part (up climb) const conv11 = genConv2D(512).apply(merge1); const conv12 = genConv2D(512).apply(conv11); const up2 = genUp2D().apply(conv12); const merge2 = tf.layers.concatenate({ axis: 3 }).apply([up2, conv6]); const conv13 = genConv2D(256).apply(merge2); const conv14 = genConv2D(256).apply(conv13); const up3 = genUp2D().apply(conv14); const merge3 = tf.layers.concatenate({ axis: 3 }).apply([up3, conv4]); const conv15 = genConv2D(128).apply(merge3); const conv16 = genConv2D(128).apply(conv15); const up4 = genUp2D().apply(conv16); const merge4 = tf.layers.concatenate({ axis: 3 }).apply([up4, conv2]); const conv17 = genConv2D(64).apply(merge4); const conv18 = genConv2D(64).apply(conv17); const conv19 = tf.layers .conv2d({ kernelSize: [1, 1], activation: "sigmoid", filters: 1, padding: "same" }) .apply(conv18); const model = tf.model({ inputs: input, outputs: conv19 });</span></span></code> </pre> <br>  Kode ini lebih mudah dipelajari di editor.  Secara umum, sejumlah besar jaringan konvolusi dibuat di sini, dan kemudian, untuk menyebarkannya kembali, kami <code>concatenate</code> dan menggabungkan beberapa lapisan.  Ini hanya visualisasi gambar, hanya dalam bentuk kode.  Semuanya cukup sederhana - menyalin dan mereproduksi model seperti itu mudah. <br><br><h2>  LSTM (Memori Jangka Pendek Panjang) </h2><br>  Perhatikan bahwa semua contoh dianggap memiliki satu fitur - format data input diperbaiki.  Input ke jaringan, data harus berukuran sama dan cocok satu sama lain.  Model LSTM berfokus pada bagaimana menghadapi hal ini. <br><br>  Misalnya, ada layanan Yandex.Referats, yang menghasilkan abstrak. <br><br><img src="https://habrastorage.org/webt/_o/g7/mh/_og7mh4hlaz87r6jpbkzjqsgdbc.png"><br><br>  Dia memberikan abracadabra lengkap, tetapi pada saat yang sama sangat mirip dengan kebenaran: <br><br><blockquote>  <strong>Abstrak dalam matematika dengan tema: “Binomial Newton sebagai aksioma”</strong> <br><br>  Menurut pendahulunya, integral permukaan menghasilkan integral lengkung.  Fungsi cembung ke bawah masih diminati. <br><br>  Secara alami dari sini bahwa normal ke permukaan masih dalam permintaan.  Menurut sebelumnya, integral Poisson pada dasarnya menentukan integral trigonometri Poisson. </blockquote><br>  Layanan ini didasarkan pada jaringan saraf Seq-to-Seq.  Arsitektur mereka lebih kompleks. <br><br><img src="https://habrastorage.org/webt/6r/3s/aw/6r3sawht3bnxadqmorz0vjqwzmw.jpeg"><br><br>  Lapisan disusun dalam sistem yang agak rumit.  Tapi jangan khawatir - Anda tidak harus melakukan semua panah ini sendiri.  Jika mau, Anda bisa, tetapi tidak perlu.  Ada penolong yang akan melakukan ini untuk Anda. <br><br>  Hal utama yang harus dipahami adalah bahwa masing-masing bagian ini digabungkan dengan yang sebelumnya.  Dibutuhkan data tidak hanya dari data awal, tetapi juga dari lapisan saraf sebelumnya.  Secara kasar, adalah mungkin untuk membangun semacam memori - untuk menghafal urutan data, mereproduksinya, dan karena pekerjaan ini "urutan ke urutan".  Selain itu, urutannya dapat berbeda ukuran baik pada input maupun pada output. <br><br>  Semuanya terlihat indah dalam kode: <br><br><pre> <code class="javascript hljs">tf.sequential({ <span class="hljs-attr"><span class="hljs-attr">layers</span></span>: [ tf.layers.lstm({ <span class="hljs-attr"><span class="hljs-attr">units</span></span>: <span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-attr"><span class="hljs-attr">returnSequences</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">inputShape</span></span>: [<span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>] }), tf.layers.lstm({ <span class="hljs-attr"><span class="hljs-attr">units</span></span>: <span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-attr"><span class="hljs-attr">returnSequences</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }), tf.layers.dense({ <span class="hljs-attr"><span class="hljs-attr">units</span></span>: <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-attr"><span class="hljs-attr">activation</span></span>: <span class="hljs-string"><span class="hljs-string">'softmax'</span></span> }) ] }) ;</code> </pre> <br>  Ada pembantu khusus yang mengatakan bahwa kita memiliki 512 objek (array).  Selanjutnya, kembalikan urutan dan formulir input ( <code>inputShape: [10000, 64]</code> ).  Selanjutnya kami memperkenalkan lapisan lain, tetapi kami tidak mengembalikan urutan ( <code>returnSequences: false</code> ), karena pada akhirnya kami mengatakan bahwa sekarang kami perlu menggunakan fungsi aktivasi untuk 64 karakter yang berbeda (huruf kecil dan huruf besar).  64 opsi diaktifkan menggunakan One-Hot Encoding. <br><br><h2>  Paling menarik </h2><br>  Sekarang, Anda mungkin bertanya-tanya: “Ini semua, tentu saja, bagus, tetapi mengapa saya membutuhkannya?  "Memerangi kanker itu baik, tetapi mengapa saya membutuhkannya di garis depan?" <br><br>  Dan tarian dengan rebana dimulai: untuk mencari tahu bagaimana menerapkan jaringan saraf untuk tata letak, misalnya. <br><blockquote>  Dengan bantuan jaringan saraf dimungkinkan untuk memecahkan masalah yang sebelumnya tidak mungkin untuk dipecahkan.  Beberapa yang bahkan tidak dapat Anda pikirkan.  Itu semua tergantung pada Anda, imajinasi Anda dan sedikit latihan. </blockquote>  Sekarang saya akan menunjukkan contoh menarik langsung dari penggunaan model yang kami periksa. <br><br><h3>  CNN  Tim audio </h3><br>  Dengan menggunakan jaringan konvolusi, Anda tidak hanya dapat mengenali gambar, tetapi juga perintah audio, dan dengan kualitas pengenalan 97%, yaitu di level Google Assistant dan Yandex-Alice. <br><br>  Di jaringan saja, tentu saja, tidak mungkin mengenali ucapan, kalimat yang lengkap, tetapi Anda dapat membuat asisten suara yang sederhana. <br><br>  Informasi lebih lanjut tentang Alice dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan oleh</a> Nikita Dubko, dan tentang asisten Google, cara bekerja dengan suara di dalamnya, dan tentang standar browser, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Faktanya adalah bahwa kata apa pun, perintah apa pun dapat diubah menjadi spektrogram. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/au/_v/r8/au_vr8gdnqh3k6gkcgyhz0ybwoq.jpeg" width="500"></div><br>  Anda dapat mengubah informasi audio apa pun menjadi spektrogram tersebut.  Dan kemudian Anda dapat menyandikan audio dalam gambar, dan menerapkan CNN ke gambar dan mengenali perintah suara sederhana. <br><br><h3>  U-net.  Pengujian Screenshot </h3><br>  U-Net bermanfaat tidak hanya untuk diagnosis kanker yang berhasil, tetapi juga, misalnya, untuk menguji tangkapan layar.  Untuk perinciannya, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> Lyudmila Mzhachikh, dan saya akan memberi tahu pangkalan itu sendiri. <br><br>  Untuk pengujian dengan tangkapan layar, diperlukan dua tangkapan layar: <br><br><ul><li>  dasar (referensi) yang kami bandingkan; </li><li>  tangkapan layar untuk pengujian. </li></ul><br><img src="https://habrastorage.org/webt/kx/2g/ci/kx2gcib0rilb_zzhohk15dmnoi4.jpeg"><br>  Sayangnya, dalam pengujian tangkapan layar, sering ada banyak jatuh negatif (false positive).  Tapi ini bisa dihindari dengan menerapkan teknologi kontrol kanker canggih ke ujung depan. <br><br>  Ingat, kami menandai gambar pada area di mana ada kanker dan tidak.  Hal yang sama dapat dilakukan di sini. <br><br><img src="https://habrastorage.org/webt/19/kk/uw/19kkuwktd9iv30ffolxasj3_l-k.jpeg"><br><br>  Jika kami melihat gambar dengan tata letak yang baik, maka kami tidak menandainya, dan kami menandai gambar dengan tata letak yang buruk.  Dengan demikian, Anda dapat menguji tata letak dengan satu gambar.   ,     ,   ,    . U-Net     . <br><br>       ,    ,    .  ,          U-Net,  .  ,   . <br><br><h3> LSTM. Twitter —  2000 </h3><br>   ,    ,     ,    . <br><br>       ,     LSTM  .   40     - , : <em>« —     »</em> . <br><br>   ,  : <br><br><img src="https://habrastorage.org/webt/yu/_6/xk/yu_6xkkdkak9jganrrpvxs6vd9g.jpeg"><br><br> -   , ? <br><br>  — .    -   : <br><br><img src="https://habrastorage.org/webt/lk/hz/sf/lkhzsfwyvs42ky2yi-k6m5reu7o.jpeg"><br><br><img src="https://habrastorage.org/webt/ai/a7/jv/aia7jvkjsgw35wpjixbsko4vjwe.jpeg"><br><br>  ,   «»       ,       ,        (,  ). <br><br>  : <em>«    »</em>  <em>«   »</em> . <br><br>       —  . <br><blockquote> «   ». </blockquote><br>      : <br><br><img src="https://habrastorage.org/webt/lv/ud/dp/lvuddp8bnuagbh4kgmsao3j_qvo.jpeg"><br><br><h4> EPOCS 250 </h4><br>    ,     . <br><br>    -   , ,  ,     .   ,      Overfitting — . <br><br>   ,    —       .  , , .   ,   ,         ,         . <br><br>    ,       ,          . <br><br>  ,       . <br><br><img src="https://habrastorage.org/webt/cv/_j/ft/cv_jftct2bzeb2_ik1apzezgjsg.jpeg"><br><br>   , ,        ,        .      ( ,  ),      .          . <br><blockquote>     —    .    . </blockquote>      overfitting.      ,    helper-: Dropout; BatchNormalization. <br><br><h3> LSTM. Prettier </h3><br>  ,     —  Prettier   .       ,     . <br><br>  <code>const a = 1</code> .    : <code>[]c co on ns st</code> ,    ,            : <code>[][] []c co on ns st</code> ,      . <br><br>     ,            ,     . <br><br> ,    ,     .      , ,  0 —  ,      -  ,  - .   . <br><br>            ,      .         . <br><br><h2>  Alih-alih kesimpulan </h2><br> , ,     .   . , ,         Deep Neural Network. <br><br>        .         ,      .      .            .     . <br><br>       JS,       ,     .         ,      .  ,   JavaScript,         .     TensorFlow.js. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em></em></a> <em> ,     .    </em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>telegram-</em></a> <em>    JS.</em> <br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FrontendConf</a>    , 13 .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> 32        . <br><br>    ,    ,           .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  Saint AppsConf,       .      ,  ,    ,     . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470904/">https://habr.com/ru/post/id470904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470884/index.html">Menulis dan membaca data dalam blockchain Bitcoin</a></li>
<li><a href="../id470888/index.html">Undang-undang Rusia dan internasional di bidang perlindungan data pribadi</a></li>
<li><a href="../id470892/index.html">Implementasi sederhana dari CAM kecil pada FPGA</a></li>
<li><a href="../id470894/index.html">Peluru</a></li>
<li><a href="../id470902/index.html">Kinerja tinggi dan partisi asli: Zabbix dengan dukungan TimescaleDB</a></li>
<li><a href="../id470908/index.html">Untuk pertama kalinya di dunia dengan bantuan teknologi aditif, perakitan mesin pesawat terbang berukuran besar diperoleh</a></li>
<li><a href="../id470910/index.html">Apa yang dapat dilakukan dengan anotasi kontrak layanan mikro?</a></li>
<li><a href="../id470916/index.html">Pos pemeriksaan elektronik "termurah" di Rusia dikendalikan dari smartphone</a></li>
<li><a href="../id470918/index.html">F # 9: Opsi Opsi</a></li>
<li><a href="../id470920/index.html">5+ Cara Menghubungkan ke DataLine Cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>