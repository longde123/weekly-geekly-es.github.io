<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèø ü¶ì üêÜ Bombe oublie-moi de m√©morisation üö£üèø üõ¥ üíç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avez-vous entendu parler de la memoization ? C'est une chose super simple, au fait, - m√©morisez simplement le r√©sultat que vous avez obtenu d'un premi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bombe oublie-moi de m√©morisation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446390/"><p><img src="https://habrastorage.org/webt/ym/ok/d7/ymokd7njz99ry_9knpxx9iaz1ja.jpeg"></p><br><p> Avez-vous entendu parler de la <code>memoization</code> ?  C'est une chose super simple, au fait, - m√©morisez simplement le r√©sultat que vous avez obtenu d'un premier appel de fonction, et utilisez-le au lieu de l'appeler la deuxi√®me fois - n'appelez pas de vraies choses sans raison, ne perdez pas votre temps . </p><br><p>  Ignorer certaines op√©rations intensives est une technique d'optimisation tr√®s courante.  Chaque fois que vous ne faites pas quelque chose, ne le faites pas.  Essayez d'utiliser le cache - <code>memcache</code> , <code>file cache</code> <code>local cache</code> - n'importe quel cache!  Un indispensable pour les syst√®mes backend et une partie cruciale de tout syst√®me backend du pass√© et du pr√©sent. </p><a name="habracut"></a><br><p><img src="https://habrastorage.org/webt/j8/4x/u4/j84xu4vrhrsgqu6fc5qdbahwhig.jpeg"></p><br><h1 id="memoization-vscaching">  M√©morisation vs mise en cache </h1><br><blockquote>  La m√©morisation est comme la mise en cache.  Un peu diff√©rent.  Pas de cache, appelons √ßa kashe. </blockquote><p>  Bref, mais la m√©morisation n'est pas un cache, pas un cache persistant.  Il peut s'agir d'un c√¥t√© serveur, mais il ne peut pas et ne doit pas √™tre un cache c√¥t√© client.  Il s'agit davantage des ressources disponibles, des mod√®les d'utilisation et des raisons d'utiliser. </p><br><h2 id="problem-cache-need-a-cachekey">  Probl√®me - Le cache a besoin d'une "cl√© de cache" </h2><br><p>  Le cache stocke et r√©cup√®re des donn√©es √† l'aide d'une <code>key</code> cache de <strong>cha√Æne</strong> .  Construire une cl√© unique et utilisable est d√©j√† un probl√®me, mais vous devez ensuite s√©rialiser et d√©s√©rialiser les donn√©es pour les stocker dans un support bas√© sur des cha√Ænes ... en bref - le cache peut ne pas √™tre aussi rapide que vous le pensez.  Cache sp√©cialement distribu√©. </p><br><h2 id="memoization-does-not-need-any-cachekey">  La m√©morisation n'a pas besoin de cl√© de cache </h2><br><p>  Dans le m√™me temps - aucune cl√© n'est n√©cessaire pour la m√©morisation.  <em>Habituellement, *</em> il utilise les arguments tels quels, n'essaie pas de cr√©er une seule cl√© √† partir d'eux, et n'utilise pas d'objet partag√© disponible globalement pour stocker les r√©sultats, comme le fait habituellement le cache. </p><br><blockquote>  La diff√©rence entre la m√©morisation et le cache r√©side dans l' <strong>API INTERFACE</strong> ! </blockquote><p>  <em>Habituellement, *</em> ne signifie pas toujours.  <a href="">Lodash.memoize</a> , par d√©faut, utilise <code>JSON.stringify</code> pour convertir les arguments pass√©s en cache de cha√Ænes (existe-t-il une autre fa√ßon? Non!).  Tout simplement parce qu'ils vont utiliser cette cl√© pour acc√©der √† un objet interne, contenant une valeur mise en cache.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fast-memoize</a> , "la biblioth√®que de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m√©morisation</a> la plus rapide possible", fait de m√™me.  Les deux biblioth√®ques nomm√©es ne sont pas des biblioth√®ques de m√©morisation, mais des biblioth√®ques de cache. </p><br><blockquote>  Il vaut la peine de mentionner - JSON.stringify pourrait √™tre 10 fois plus lent qu'une fonction, tu vas m√©moriser. </blockquote><p>  De toute √©vidence - la solution simple au probl√®me n'est PAS d'utiliser une cl√© de cache, et PAS d'acc√©der √† un cache interne en utilisant cette cl√©.  Alors - souvenez-vous des derniers arguments avec lesquels vous avez √©t√© appel√©.  Comme faire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m√©moriser</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">res√©lectionner</a> . </p><br><blockquote>  Memoizerific est probablement la seule biblioth√®que de mise en cache g√©n√©rale que vous souhaitez utiliser. </blockquote><br><h1 id="the-cachesize">  La taille du cache </h1><br><p>  La deuxi√®me grande diff√©rence entre toutes les biblioth√®ques concerne la taille du cache et la structure du cache. </p><br><p>  Avez-vous d√©j√† pens√© - pourquoi <code>reselect</code> ou <code>memoize-one</code> ne contient qu'un, dernier r√©sultat?  Pas pour <em>¬´ne pas utiliser la cl√© de cache pour pouvoir stocker plus d'un r√©sultat¬ª</em> , mais parce qu'il n'y a <strong>aucune raison de stocker plus qu'un dernier r√©sultat</strong> . </p><br><p>  ... Il s'agit plus de: </p><br><ul><li>  ressources disponibles - une seule ligne de cache est tr√®s conviviale pour les ressources </li><li>  mod√®les d'utilisation - se souvenir de quelque chose ¬´en place¬ª est un bon mod√®le.  "En place", vous n'avez g√©n√©ralement besoin que d'un dernier r√©sultat. </li><li>  la raison d'utiliser -modularit√©, isolation et s√©curit√© de la m√©moire sont de bonnes raisons.  Ne pas partager le cache avec le reste de votre application est tout simplement plus s√ªr en termes de collisions de cache. </li></ul><br><h1 id="a-singleresult">  Un seul r√©sultat?! </h1><br><p>  Oui - le seul r√©sultat.  Avec un r√©sultat m√©moris√© certaines <strong>choses classiques</strong> , comme la g√©n√©ration de nombre de fibonacci m√©moris√© ( <em>vous pouvez trouver comme exemple dans chaque article sur la m√©morisation</em> ) ne serait <strong>pas possible</strong> .  Mais, d'habitude, vous faites autre chose - qui a besoin d'un fibonacci sur Frontend?  En backend?  Les exemples du monde r√©el sont assez loin <em>des quiz informatiques</em> abstraits. </p><br><p>  Mais encore, il y a deux <strong>gros</strong> probl√®mes √† propos d'un type de m√©morisation √† valeur unique. </p><br><h2 id="problem-1-its-fragile">  Probl√®me 1 - c'est "fragile" </h2><br><p>  Par d√©faut - tous les arguments doivent correspondre, √™tre exactement les m√™mes "===".  Si un argument ne correspond pas - le jeu est termin√©.  M√™me si cela vient de l'id√©e de la m√©morisation - ce n'est peut-√™tre pas quelque chose que vous voulez de nos jours.  Je veux dire - vous voulez m√©moriser autant de choses que possible et aussi souvent que possible. </p><br><blockquote>  M√™me le cache manquant est un tir √† la t√™te de nettoyage du cache. </blockquote><p>  Il y a une petite diff√©rence entre "de nos jours" et "hier" - des structures de donn√©es immuables, utilis√©es par exemple dans Redux. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getSomeDataFromState = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> compute(state.tasks));</code> </pre> <br><p>  Vous cherchez bien?  Vous cherchez bien?  Cependant, l'√©tat peut changer lorsque les t√¢ches ne le sont pas et vous n'avez besoin que de t√¢ches pour correspondre. </p><br><p>  <strong>Les s√©lecteurs structurels</strong> sont l√† pour sauver la situation avec leur guerrier le plus fort - <strong>Reselect</strong> - √† votre disposition et appelez.  Reselect n'est pas seulement une biblioth√®que de m√©morisation, mais sa puissance provient de <strong>cascades</strong> de m√©morisation ou d'objectifs (ce qu'ils ne sont pas, mais consid√©rez les s√©lecteurs comme des lentilles optiques). </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// every time `state` changes, cached value would be rejected const getTasksFromState = createSelector(state =&gt; state.tasks); const getSomeDataFromState = createSelector( // `tasks` "without" `state` getTasksFromState, // &lt;---------- // and this operation would be memoized "more often" tasks =&gt; compute(state.tasks) );</span></span></code> </pre> <br><p>  En cons√©quence, dans le cas de donn√©es immuables - vous devez toujours vous <strong>"concentrer" d'abord</strong> sur la donn√©e dont vous avez vraiment besoin, puis - effectuer des calculs, sinon le cache serait rejet√©, et toute l'id√©e derri√®re la m√©morisation dispara√Ætrait. </p><br><p>  C'est en fait un gros probl√®me, en particulier pour les nouveaux arrivants, mais cela, comme L'id√©e derri√®re des structures de donn√©es immuables, pr√©sente un avantage significatif - <strong>si quelque chose n'est pas chang√© - il n'est pas chang√©.</strong>  <strong>Si quelque chose est chang√© - probablement il est chang√©</strong> .  Cela nous donne une comparaison super rapide, mais avec quelques faux n√©gatifs, comme dans le premier exemple. </p><br><blockquote>  L'id√©e consiste √† "se concentrer" sur les donn√©es dont vous d√©pendez </blockquote><p>  Il y a deux moments que j'aurais d√ª - mentionn√©s: </p><br><ul><li>  <code>lodash.memoize</code> et <code>fast-memoize</code> convertissent vos donn√©es en une cha√Æne √† utiliser comme cl√©.  Cela signifie qu'ils sont 1) pas rapides 2) pas s√ªrs 3) pourraient produire des faux positifs - certaines <strong>donn√©es diff√©rentes</strong> pourraient avoir la <strong>m√™me repr√©sentation sous forme de cha√Æne</strong> .  Cela pourrait am√©liorer le "taux chaud du cache", mais c'est en fait TR√àS MAUVAIS. </li><li>  il existe une approche ES6 Proxy, sur le suivi de toutes les parties de variables utilis√©es donn√©es, et la v√©rification des cl√©s qui comptent.  Bien que je souhaite personnellement cr√©er des myriades de s√©lecteurs de donn√©es - vous pourriez ne pas aimer ou comprendre le processus, mais souhaiteriez avoir une m√©morisation appropri√©e d√®s le d√©part - puis utilisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">memoize-state</a> . </li></ul><br><h2 id="problem-2--its-one-cacheline">  Probl√®me 2- c'est "une ligne de cache" </h2><br><p>  La taille infinie du cache est un tueur.  Tout cache non contr√¥l√© est un tueur, tant que la m√©moire est assez limit√©e.  Donc - toutes les meilleures biblioth√®ques sont ¬´√† une ligne de cache¬ª.  C'est une caract√©ristique et une d√©cision de conception solide.  Je viens d'√©crire √† quel point c'est juste et, croyez-moi - c'est <strong>vraiment</strong> une <strong>bonne chose</strong> , mais c'est toujours un probl√®me.  Un gros probl√®me. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tasks = getTasks(state); <span class="hljs-comment"><span class="hljs-comment">// let's get some data from state1 (function was defined above) getDataFromTask(tasks[0]); // Yep! equal(getDataFromTask(tasks[0]), getDataFromTask(tasks[0])) // Ok! getDataFromTask(tasks[1]); // a different task? What the heck? // oh! That's another argument? How dare you!? // TLDR -&gt; task[0] in the cache got replaced by task[1] you cannot use getDataFromTask to get data from different tasks</span></span></code> </pre> <br><p>  Une fois que le m√™me s√©lecteur doit travailler avec diff√©rentes donn√©es source, avec plus d'un - tout est cass√©.  Et il est facile de rencontrer le probl√®me: </p><br><ul><li>  Tant que nous utilisions des s√©lecteurs pour obtenir des t√¢ches d'un √©tat - nous pouvions utiliser les m√™mes s√©lecteurs pour obtenir quelque chose d'une t√¢che.  Intense vient de l'API elle-m√™me.  Mais cela ne fonctionne pas, vous ne pouvez m√©moriser que le dernier appel, mais vous devez travailler avec plusieurs sources de donn√©es. </li><li>  Le m√™me probl√®me se pose avec plusieurs composants React - ils sont tous les m√™mes, et tous un peu diff√©rents, r√©cup√©rant des t√¢ches diff√©rentes, effa√ßant les r√©sultats les uns des autres. </li></ul><br><p>  Il existe 3 solutions possibles: </p><br><ul><li>  en cas de redux - utilisez l'usine mapStateToProps.  Cela cr√©erait une m√©morisation par instance. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = createSelector(...); <span class="hljs-comment"><span class="hljs-comment">// ^ you have to define per-instance selectors here // usually that's not possible :) return state =&gt; ({ data: selector(data), // a usual mapStateToProps }); }</span></span></code> </pre> </li><li>  la deuxi√®me variante est presque la m√™me (et aussi pour redux) - il s'agit d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">re-reselect</a> .  C'est une biblioth√®que complexe, qui pourrait sauver la situation en distinguant les composants.  Il pourrait simplement comprendre que le nouvel appel a √©t√© effectu√© pour "un autre" composant, et il pourrait conserver le cache pour le "pr√©c√©dent". </li></ul><br><p><img src="https://habrastorage.org/webt/rd/mz/gq/rdmzgqgrj_mjin5jjmsalnxmljm.png"></p><br><p>  Cette biblioth√®que vous aiderait √† "conserver" le cache de m√©morisation, mais pas √† le supprimer.  Surtout parce qu'il impl√©mente 5 (CINQ!) Diff√©rentes strat√©gies de cache pour s'adapter √† tous les cas.  C'est une mauvaise odeur.  Et si vous choisissez le mauvais? <br>  Toutes les donn√©es que vous avez m√©moris√©es - vous devez les oublier, t√¥t ou tard.  Il ne s'agit pas de se souvenir de la derni√®re invocation de fonction - il s'agit de L'OUBLIER au bon moment.  Pas trop t√¥t, et ruiner la m√©morisation, et pas trop tard. </p><br><blockquote>  Vous avez l'id√©e?  Maintenant, oublie √ßa!  Et o√π est la 3√®me variante ?? </blockquote><br><h1 id="let-take-apause">  Laisse faire une pause </h1><br><p>  Arr√™ter  D√©tendez-vous  Respirez profond√©ment.  Et r√©pondez √† une question simple - Quel est l'objectif?  Que devons-nous faire pour atteindre l'objectif?  Qu'est-ce qui sauverait la journ√©e? </p><br><blockquote>  CONSEIL: O√π est cette f *** "cache" SITU√âE! </blockquote><p><img src="https://habrastorage.org/webt/7m/r1/iz/7mr1izrzb89femvq5h-suxxkfnm.jpeg"></p><br><p>  O√π est situ√© ce "cache"?  Oui - c'est la bonne question.  Merci de le demander.  Et la r√©ponse est simple - elle est situ√©e dans une fermeture.  Dans un endroit cach√© √† l'int√©rieur * une fonction m√©moris√©e.  Par exemple - voici le code <code>memoize-one</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastArgs; <span class="hljs-comment"><span class="hljs-comment">// the last arguments let lastResult;// the last result &lt;--- THIS IS THE CACHE // the memoized function const memoizedCall = function(...newArgs) { if (isEqual(newArgs, lastArgs)) { return lastResult; } lastResult = resultFn.apply(this, newArgs); lastArgs = newArgs; return lastResult; }; return memoizedCall; }</span></span></code> </pre> <br><p>  Vous recevrez un <code>memoizedCall</code> , et il tiendra le dernier r√©sultat √† proximit√©, √† l'int√©rieur de sa fermeture locale, non accessible √† personne, sauf memoizedCall.  Un endroit s√ªr.  "ceci" est un endroit s√ªr. </p><br><p>  <code>Reselect</code> fait de m√™me, et la seule fa√ßon de cr√©er un "fork", avec un autre cache - cr√©er une nouvelle fermeture de m√©morisation. </p><br><p>  Mais la (autre) question principale - quand (le cache) serait-il "parti"? </p><br><blockquote>  TLDR: Il serait "disparu" avec une fonction, lorsque l'instance de fonction serait mang√©e par Garbage Collector. </blockquote><p>  Instance?  Instance!  Alors, qu'en est-il de la m√©morisation par instance?  Il y a tout un article √† ce sujet dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation React</a> </p><br><p>  En bref - si vous utilisez des composants React bas√©s sur les classes, vous pouvez faire: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> memoize <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"memoize-one"</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ filter = memoize( <span class="hljs-comment"><span class="hljs-comment">// &lt;-- bound to the instance (list, filterText) =&gt; list.filter(...); // ^ that is "per instance" memoization // we are creating "own" memoization function // with the "own" lastResult render() { // Calculate the latest filtered list. // If these arguments haven't changed since the last render, // `memoize-one` will reuse the last return value. const filteredList = this.filter(something, somehow); return &lt;ul&gt;{filteredList.map(item =&gt; ...}&lt;/ul&gt; } }</span></span></code> </pre> <br><p>  Alors - o√π <strong>"lastResult"</strong> est stock√©?  √Ä l'int√©rieur d'une port√©e locale de <strong>filtre</strong> m√©moris√©, √† l'int√©rieur de cette instance de classe.  Et, quand ce serait "parti"? </p><br><p>  Cette fois, il "serait parti" avec une instance de classe.  Une fois le composant d√©mont√©, il est parti sans laisser de trace.  C'est un v√©ritable "par instance", et vous pouvez utiliser <code>this.lastResult</code> pour conserver un r√©sultat temporel, avec exactement le m√™me effet de "m√©morisation". </p><br><h2 id="whats-about-reacthooks">  √Ä propos de React.Hooks </h2><br><p>  Nous nous rapprochons.  Les hooks Redux ont quelques commandes suspectes, qui concernent probablement la m√©morisation.  Comme - <code>useMemo</code> , <code>useCallback</code> , <code>useRef</code> </p><br><p><img src="https://habrastorage.org/webt/wx/2k/kf/wx2kkfpti6kecbdj4zoohpslkqk.png"></p><br><blockquote>  Mais la question - O it il stocke une valeur m√©moris√©e cette fois? </blockquote><p>  En bref - il le stocke dans des "crochets", √† l'int√©rieur d'une partie sp√©ciale d'un √©l√©ment VDOM appel√© fibre associ√©e √† un √©l√©ment courant.  Au sein d'une structure de donn√©es parall√®le. </p><br><p>  Pas si court - les hooks changent la fa√ßon dont votre programme fonctionne, d√©pla√ßant votre fonction √† l'int√©rieur d'une autre, avec quelques variables dans un <em>endroit cach√© √† l'int√©rieur d'une fermeture parent</em> .  Ces fonctions sont connues sous le nom de fonctions <em>suspendables</em> ou <em>pouvant √™tre reprises</em> - coroutines.  En JavaScript, ils sont g√©n√©ralement appel√©s <code>generators</code> ou <code>async functions</code> . </p><br><p>  Mais c'est un peu extr√™me.  Dans un tr√®s court - useMemo stocke la valeur m√©moris√©e dans cela.  C'est juste un peu diff√©rent "ceci". </p><br><blockquote>  Si nous voulons cr√©er une meilleure biblioth√®que de m√©morisation, nous devons trouver un meilleur "ceci". </blockquote><p>  Zing! </p><br><h1 id="weakmaps">  WeakMaps! </h1><br><p>  Oui!  WeakMaps!  Pour stocker la valeur-cl√©, o√π la cl√© serait celle-ci, tant que WeakMap n'accepte rien d'autre que cela, c'est-√†-dire des "objets". </p><br><p>  Cr√©ons un exemple simple: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createHiddenSpot = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-comment"><span class="hljs-comment">// a hidden "closure" const set = (key, value) =&gt; (map.set(key, value), value); return (key) =&gt; { return map.get(key) || set(key, fn(key)) } } const weakSelect = createHiddenSpot(selector); weakSelect(todos); // create a new entry weakSelect(todos); // return an existing entry weakSelect(todos[0]); // create a new entry weakSelect(todos[1]); // create a new entry weakSelect(todos[0]); // return an existing entry! weakSelect(todos[1]); // return an existing entry!! weakSelect(todos); // return an existing entry!!!</span></span></code> </pre> <br><p>  C'est stupidement simple et tout √† fait "juste".  Alors "quand √ßa serait parti"? </p><br><ul><li>  oublier faibleS√©lectionner et toute une "carte" serait partie </li><li>  oublier todos [0] et leur entr√©e faible serait partie </li><li>  oubliez les todos - et les donn√©es m√©moris√©es auraient disparu! </li></ul><br><blockquote>  Il est clair que quelque chose ¬´dispara√Æt¬ª - seulement quand cela devrait! </blockquote><p>  Magiquement - tous les probl√®mes de res√©lection ont disparu.  Probl√®mes de m√©morisation agressive - √©galement un enfer. </p><br><p>  Cette approche <strong>N'OUBLIEZ</strong> <strong>PAS</strong> les donn√©es jusqu'√† ce qu'il soit temps d' <strong>OUBLIER</strong> .  C'est incroyable, mais pour mieux se souvenir de quelque chose, il faut pouvoir mieux l'oublier. </p><br><p>  La seule chose qui dure - cr√©er une API plus robuste pour ce cas </p><br><h1 id="kashe-is-acache">  Kashe - est une cache </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kashe</a> est une biblioth√®que de m√©morisation bas√©e sur WeakMap, qui pourrait vous sauver la vie. </p><br><p>  Cette biblioth√®que expose 4 fonctions </p><br><ul><li>  <code>kashe</code> -pour la <code>kashe</code> . </li><li>  <code>box</code> - pour la m√©morisation pr√©fix√©e, pour <em>augmenter les</em> chances de m√©morisation. </li><li>  <code>inbox</code> - m√©morisation pr√©fix√©e imbriqu√©e, pour <em>diminuer le</em> changement de m√©morisation </li><li>  <code>fork</code> - to <em>fork</em> (√©videmment) la m√©morisation. </li></ul><br><h2 id="kashefn--memoizedfnargs">  kashe (fn) =&gt; memoizedFn (... args) </h2><br><p>  Il s'agit en fait d'un createHiddenSpot d'un exemple pr√©c√©dent.  Il utilisera un premier argument comme cl√© pour un WeakMap interne. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, prop</span></span></span><span class="hljs-function">) =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">result</span></span>: state[prop]}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoized = kashe(selector); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> old = memoized(state, <span class="hljs-string"><span class="hljs-string">'x'</span></span>) memoized(state, <span class="hljs-string"><span class="hljs-string">'x'</span></span>) === old memoized(state, <span class="hljs-string"><span class="hljs-string">'y'</span></span>) === memoized(state, <span class="hljs-string"><span class="hljs-string">'y'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ^^ another argument // but old !== memoized(state, 'x') // 'y' wiped 'x' cache in `state`</span></span></code> </pre> <br><p>  le premier argument est une cl√©, si vous appelez √† nouveau fonction la m√™me cl√©, mais des arguments diff√©rents - le cache serait remplac√©, c'est toujours une m√©morisation longue d'une ligne de cache.  Pour le faire fonctionner - vous devez fournir diff√©rentes cl√©s pour diff√©rents cas, comme je l'ai fait avec un exemple de faiblesse, pour fournir des r√©sultats diff√©rents.  Res√©lectionnez les cascades A est toujours la chose. <br>  Toutes les fonctions ne sont pas m√©morisables.  Le premier argument doit √™tre un objet, un tableau ou une fonction.  Il devrait √™tre utilisable comme cl√© pour WeakMap. </p><br><h2 id="boxfn--memoizedfn2boxargs">  box (fn) =&gt; memoizedFn2 (box, ... args) </h2><br><p>  c'est la m√™me fonction, juste appliqu√©e deux fois.  Une fois pour fn, une fois pour memoizedFn, en ajoutant une cl√© de t√™te aux arguments.  Cela pourrait rendre n'importe quelle fonction m√©morable. </p><br><blockquote>  C'est assez d√©claratif - h√© fonction!  Je vais stocker les r√©sultats dans cette case. </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// could not be "kashe" memoized const addTwo = (a,b) =&gt; ({ result: a+b }); const bAddTwo = boxed(addTwo); const cacheKey = {}; // any object bAddTwo(cacheKey, 1, 2) === bAddTwo(cacheKey, 1, 2) === { result: 3}</span></span></code> </pre> <br><p>  Si vous encadrez la fonction d√©j√† m√©moris√©e - vous augmentez les chances de m√©morisation, comme la m√©morisation par instance - vous pouvez cr√©er une cascade de m√©morisation. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selectSomethingFromTodo = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, prop</span></span></span><span class="hljs-function">) =&gt;</span></span> ... const selector = kashe(selectSomethingFromTodo); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> boxedSelector = kashe(selector); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render () { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = boxedSelector(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, todos, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.todoId); <span class="hljs-comment"><span class="hljs-comment">// 1. try to find result in `this` // 2. try to find result in `todos` // 3. store in `todos` // 4. store in `this` // if multiple `this`(components) are reading from `todos` - // selector is not working (they are wiping each other) // but data stored in `this` - exists. ... } }</span></span></code> </pre> <br><h2 id="inboxfn--memoizedfn2boxargs">  bo√Æte de r√©ception (fn) =&gt; memoizedFn2 (box, ... args) </h2><br><p>  celui-ci est oppos√© √† la bo√Æte, mais fait presque la m√™me chose, commandant au cache imbriqu√© de stocker les donn√©es dans la bo√Æte fournie.  D'un point de vue - cela r√©duit la probabilit√© de m√©morisation (il n'y a pas de cascade de m√©morisation), mais d'un autre - il supprime les collisions de cache et aide √† isoler les processus s'ils ne doivent pas interf√©rer les uns avec les autres pour quelque raison que ce soit. </p><br><blockquote>  C'est assez d√©claratif - h√©!  Tout le monde √† l'int√©rieur!  Voici une boite √† utiliser </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getAndSet = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task, number</span></span></span><span class="hljs-function">) =&gt;</span></span> task.value + number; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoized = kashe(getAndSet); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inboxed = inbox(getAndSet); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doubleBoxed = inbox(memoized); memoized(task, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ok memoized(task, 2) // previous result wiped inboxed(key1, task, 1) // ok inboxed(key2, task, 2) // ok // inbox also override the cache for any underlaying kashe calls doubleBoxed(key1, task, 1) // ok doubleBoxed(key2, task, 2) // ok</span></span></code> </pre> <br><h2 id="forkkashe-memoized--kashe-memoized">  fork (kashe-memoized) =&gt; kashe-memoized </h2><br><p>  Fork est un vrai fork - il obtient n'importe quelle fonction m√©moris√©e par kashe et retourne la m√™me chose, mais avec une autre entr√©e de cache interne.  Rappelez-vous la m√©thode d'usine redux mapStateToProps? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// const selector = createSelector(...); // const selector = fork(realSelector); // just fork existing selector. Or box it, or don't do anything // kashe is more "stable" than reselect. return state =&gt; ({ data: selector(data), }); }</span></span></code> </pre> <br><h2 id="reselect">  Res√©lectionnez </h2><br><p>  Et il y a encore une chose que vous devez savoir - kashe pourrait remplacer res√©lectionner.  Litt√©ralement. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createSelector } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kashe/reselect'</span></span>;</code> </pre> <br><p>  C'est en fait la m√™me res√©lection, juste cr√©√©e avec kashe comme fonction de m√©morisation. </p><br><h1 id="codesandbox">  Codesandbox </h1><br><p>  Voici un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">petit exemple</a> pour jouer avec.  Vous pouvez √©galement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">v√©rifier les tests</a> - ils sont compacts et solides. <br>  Si vous voulez en savoir plus sur la mise en cache et la m√©morisation - v√©rifiez comment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">j'ai √©crit la biblioth√®que de m√©morisation la plus rapide il y a</a> un an. </p><br><blockquote>  PS: Il convient de mentionner que la version la plus simple de cette approche - faible-m√©morisation - est utilis√©e dans emotion-js pendant un certain temps.  Rien √† redire.  nano-memoize utilise √©galement WeakMaps pour un cas d'argument unique. </blockquote><p>  Vous avez compris?  Une approche plus ¬´faible¬ª vous aiderait √† mieux vous souvenir de quelque chose et √† mieux l'oublier. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/theKashey/kashe</a> </p><br><p>  Ouais, au sujet d'oublier quelque chose, - pourriez-vous s'il vous pla√Æt regarder ici? </p><br><p><img src="https://habrastorage.org/webt/60/d6/9y/60d69ysm9v5hy9dnm1siokafjhu.jpeg"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446390/">https://habr.com/ru/post/fr446390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446372/index.html">Aimer les qu√™tes, aimer et retrouver vos donn√©es personnelles en public</a></li>
<li><a href="../fr446378/index.html">Le probl√®me du passage √† l'heure d'hiver et d'√©t√© pour une seule √©cole Skype</a></li>
<li><a href="../fr446380/index.html">H2 evolution - fonctions de fen√™tre, CTE, JSON / XML dans une base de donn√©es embarqu√©e</a></li>
<li><a href="../fr446384/index.html">Conseils pour d√©velopper de tr√®s gros projets dans Revit</a></li>
<li><a href="../fr446388/index.html">L'industrie p√©troli√®re et gazi√®re comme exemple pour les syst√®mes de cloud p√©riph√©riques</a></li>
<li><a href="../fr446394/index.html">5. Check Point Getting Started R80.20. Gaia & CLI</a></li>
<li><a href="../fr446396/index.html">R√©initialisation du compteur hebdomadaire GPS</a></li>
<li><a href="../fr446400/index.html">Dmitry Dumik, Chatfuel: √Ä propos de Y Combinator, entrepreneuriat technologique, changement de comportement et sensibilisation</a></li>
<li><a href="../fr446402/index.html">Applications multilingues en angulaire</a></li>
<li><a href="../fr446404/index.html">Alternatives modernes au PGP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>