<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîò ‚úãüèº ‚ò∫Ô∏è Escribe todo üèçÔ∏è ü§û ‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 


 Ya tenemos un art√≠culo sobre el desarrollo de la escritura en Ostrovok.ru . Explica por qu√© estamos cambiando de pyContracts a typeg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribe todo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ostrovok/blog/480930/"><p>  Hola a todos! </p><br><p>  Ya tenemos <a href="https://habr.com/ru/company/ostrovok/blog/443470/">un art√≠culo</a> sobre el desarrollo de la escritura en <a href="https://www.habr.com/%3Futm_source%3Dhabr%26utm_medium%3Dpr%26utm_campaign%3Dbogdanova_dec19%26utm_content%3Darticle">Ostrovok.ru</a> .  Explica por qu√© estamos cambiando de pyContracts a typeguard, por qu√© estamos cambiando a typeguard y con qu√© terminamos.  Y hoy les contar√© m√°s sobre c√≥mo ocurre esta transici√≥n. </p><br><img src="https://habrastorage.org/webt/xk/gm/wn/xkgmwnrl0mygmpduhrg879p-nhe.jpeg"><a name="habracut"></a><br><p>  Una declaraci√≥n de funci√≥n con pyContracts generalmente se ve as√≠: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> contracts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> new_contract <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime @new_contract <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isinstance(x, User) @new_contract <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dt_datetime</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isinstance(x, datetime.datetime) @contract <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_list, amount, dt=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" :type user_list: list(User) :type amount: int|float :type dt: dt_datetime|None :rtype: bool """</span></span> ‚Ä¶</code> </pre> <br><p>  Este es un ejemplo abstracto, porque no encontr√© en nuestro proyecto una definici√≥n de una funci√≥n que sea breve y significativa en t√©rminos de la cantidad de casos para la verificaci√≥n de tipo.  Normalmente, las definiciones de pyContracts se almacenan en archivos que no contienen ninguna otra l√≥gica.  Tenga en cuenta que aqu√≠ Usuario es una clase de usuario espec√≠fica y no se importa directamente. </p><br><p>  Y este es el resultado deseado con typeguard: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typechecked <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> typechecked <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> List, Optional, Union <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime @typechecked <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_list: List[User], amount: Union[int, float], dt: Optional[datetime.datetime]=None)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> ...</code> </pre> <br><p>  En general, hay tantas funciones y m√©todos con verificaci√≥n de tipo en el proyecto que si los apilas en una pila, puedes llegar a la luna.  Entonces, traducirlos manualmente de pyContracts a typeguard simplemente no es posible (¬°lo intent√©!).  Entonces decid√≠ escribir un gui√≥n. </p><br><p>  El script se divide en dos partes: una almacena en cach√© las importaciones de nuevos contratos y la segunda trata con la refactorizaci√≥n de c√≥digo. </p><br><p>  Quiero se√±alar que ni uno ni el otro script dicen ser universales.  No ten√≠amos el objetivo de escribir una herramienta para resolver todos los casos requeridos.  Por lo tanto, a menudo omit√≠ el procesamiento autom√°tico de algunos casos especiales, si rara vez se encuentran en el proyecto, es m√°s r√°pido solucionarlo a mano.  Por ejemplo, el script para generar contratos de mapeo e importaciones recolect√≥ el 90% de los valores, el 10% restante es mapeo de elaboraci√≥n artesanal. </p><br><p>  La l√≥gica del script para generar mapeo: </p><br><p>  Paso 1. Revisa todos los archivos del proyecto, l√©elos.  Para cada archivo: </p><br><ul><li>  si la subcadena "@new_contract" no est√° presente, omita este archivo, </li><li>  si es as√≠, divida el archivo por la l√≠nea "@new_contract".  Para cada art√≠culo: <br>  - analizar para su definici√≥n e importaci√≥n, <br>  - si tiene √©xito, escriba en el archivo de √©xito, <br>  - Si no, escriba en el archivo de error. </li></ul><br><p>  Paso 2. Procesar errores manualmente </p><br><p>  Ahora que tenemos los nombres de todos los tipos que utiliza pyContracts (se definieron con el decorador new_contract), y tenemos todas las importaciones necesarias, podemos escribir c√≥digo para refactorizar.  Mientras traduc√≠a de pyContracts a typeguard manualmente, me di cuenta de lo que necesitaba del script: </p><br><ol><li>  Este es un comando que toma el nombre de un m√≥dulo como argumento (se pueden usar varios), en el que se debe reemplazar la sintaxis de las anotaciones de funci√≥n. </li><li>  Revise todos los archivos del m√≥dulo, l√©alos.  Para cada archivo: <br><ul><li>  si no hay una subcadena "@contract", omita este archivo; </li><li>  si es as√≠, convierta el c√≥digo en ast (√°rbol de sintaxis abstracta); </li><li>  encuentre todas las funciones que est√°n bajo el decorador de contrato para cada una: <br><ul><li>  obtener la cadena de acoplamiento, analizar y luego eliminar, </li><li>  cree un diccionario de la forma {arg_name: arg_type}, √∫selo para reemplazar la anotaci√≥n de funci√≥n, </li><li>  recordar nuevas importaciones, </li></ul></li><li>  escribe el √°rbol modificado en un archivo a trav√©s de astunparse; </li><li>  agregar nuevas importaciones a la parte superior del archivo; </li><li>  reemplace las l√≠neas "@contract" con "@typechecked" porque es m√°s f√°cil que a trav√©s de ast. </li></ul></li></ol><br><p>  Resuelva la pregunta "¬øeste nombre ya est√° importado en este archivo?"  No ten√≠a la intenci√≥n desde el principio: con este problema nos enfrentaremos a una ejecuci√≥n adicional de la biblioteca isort. </p><br><p>  Pero despu√©s de ejecutar la primera versi√≥n del script, surgieron preguntas que a√∫n ten√≠an que resolverse.  Result√≥ que 1) ast no es omnipotente, 2) astunparse es m√°s omnipotente de lo que nos gustar√≠a.  Esto se manifest√≥ en lo siguiente: </p><br><ul><li>  en el momento de la transici√≥n al √°rbol de sintaxis, todos los comentarios de una sola l√≠nea desaparecen del c√≥digo; </li><li>  las l√≠neas vac√≠as tambi√©n desaparecen; </li><li>  Para no distinguir entre funciones y m√©todos de la clase, tuvimos que agregar l√≥gica; </li><li>  por el contrario, al pasar de un √°rbol a un c√≥digo, los comentarios de varias l√≠neas en comillas triples se escriben en comillas simples y ocupan una l√≠nea, y los nuevos saltos de l√≠nea se reemplazan por \ n; </li><li>  aparecen corchetes innecesarios, por ejemplo, si A y B y C o D se convierten en if ((A y B y C) o D). </li></ul><br><p>  El c√≥digo pasado a trav√©s de ast y astunparse sigue funcionando, pero se reduce su legibilidad. </p><br><p>  El inconveniente m√°s grave de lo anterior es la desaparici√≥n de los comentarios de una sola l√≠nea (en otros casos, no perdemos nada, solo ganamos, entre par√©ntesis, por ejemplo).  La biblioteca horast basada en ast, astunparse y tokenize promete resolver esto.  Promesas y cumple. </p><br><p>  Ahora las l√≠neas vac√≠as.  Hab√≠a dos posibles soluciones: </p><br><ol><li>  tokenize sabe c√≥mo determinar la "parte del habla" de una pit√≥n, y horast lo aprovecha cuando obtiene tokens de tipo comentario.  Pero tokenize tambi√©n tiene tokens como NewLine y NL.  Por lo tanto, debe ver c√≥mo horast restaura los comentarios y copiar, reemplazando el tipo de token. <br>  <em>- sugiri√≥ Anya, experiencia en el desarrollo de 2 meses</em> </li><li>  Como horast puede restaurar los comentarios, primero reemplazamos todas las l√≠neas vac√≠as con un comentario espec√≠fico, luego saltamos a trav√©s de horast y reemplazamos nuestro comentario con una l√≠nea vac√≠a. <br>  <em>- Se le ocurri√≥ Eugene, experiencia en el desarrollo de 8 a√±os.</em> </li></ol><br><p>  Dir√© un poco m√°s abajo sobre las comillas triples en los comentarios, y fue bastante f√°cil soportar los corchetes adicionales, especialmente porque algunos de ellos se eliminan mediante el formateo autom√°tico. </p><br><p>  En horast usamos dos funciones: parse y unparse, pero ambas no son ideales: el an√°lisis contiene errores internos extra√±os, en casos excepcionales no puede analizar el c√≥digo fuente y no puede escribir algo que tenga tipo de tipo (un tipo que Resulta que si escribes (any_other_type)). </p><br><p>  Decid√≠ no tratar con el an√°lisis, porque la l√≥gica del trabajo es bastante confusa, y las excepciones son raras: el principio de no universalidad funciona aqu√≠. </p><br><p>  Pero unparse funciona de manera muy clara y elegante.  La funci√≥n unparse crea una instancia de la clase Unparser, que en <strong>init</strong> procesa el √°rbol y luego lo escribe en un archivo.  Horast.Unparser se hereda sucesivamente de muchos otros Unparsers, donde la clase m√°s b√°sica es astunparse.Unparser.  Todas las clases descendientes simplemente extienden la funcionalidad de la clase base, pero la l√≥gica del trabajo sigue siendo la misma, as√≠ que considere astunparse.Unparser.  Tiene cinco m√©todos importantes: </p><br><ol><li>  escribir: solo escribe algo en un archivo. </li><li>  fill: utiliza la escritura en funci√≥n del n√∫mero de sangr√≠as (el n√∫mero de sangr√≠as se almacena como un campo de clase). </li><li>  enter: aumenta la sangr√≠a. </li><li>  licencia: reduce la sangr√≠a. </li><li>  despacho: determina el tipo de nodo del √°rbol (digamos T), llama al m√©todo correspondiente por el nombre del tipo de nodo, pero con gui√≥n bajo (es decir, _T).  Este es un meta m√©todo. </li></ol><br><p>  Todos los dem√°s m√©todos son m√©todos de la forma _T, por ejemplo, _Module o _Str.  En cada uno de estos m√©todos, puede: 1) despachar recursivamente para nodos de sub√°rbol, o 2) usar escribir para escribir el contenido del nodo o agregar caracteres y palabras clave para que el resultado sea una expresi√≥n v√°lida en python. </p><br><p>  Por ejemplo, encontramos un nodo de tipo arg, en el cual ast almacena el nombre del argumento y el nodo de anotaci√≥n.  Luego, dispatch llamar√° al m√©todo _arg, que primero escribir√° el nombre del argumento, luego escribir√° los dos puntos y ejecutar√° el despacho para el nodo de anotaci√≥n, donde se analizar√° el sub√°rbol de anotaci√≥n, y se seguir√° llamando a despacho y escritura para este sub√°rbol. </p><br><p>  Volvamos a nuestro problema de la imposibilidad de procesar el tipo de tipo.  Ahora que comprende c√≥mo funciona el an√°lisis, es f√°cil crear su tipo.  Vamos a crear alg√∫n tipo: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewType</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, t)</span></span></span><span class="hljs-function">:</span></span> self.s = ts</code> </pre> <br><p>  Almacena una cadena en s√≠ misma, y ‚Äã‚Äãno solo as√≠: necesitamos tipificar argumentos de funci√≥n, y obtenemos los tipos de argumentos en forma de cadenas desde el acoplamiento.  Por lo tanto, reemplacemos las anotaciones de argumentos no con los tipos que requerimos, sino con un objeto NewType que almacena solo el nombre del tipo deseado en su interior. </p><br><p>  Para hacer esto, expanda horast.Unparser: escriba su UnparserWithType, herede de horast.Unparser y agregue el procesamiento de nuestro nuevo tipo. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnparserWithType</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(horast.Unparser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_NewType</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, t)</span></span></span><span class="hljs-function">:</span></span> self.write(ts)</code> </pre> <br><p>  Esto se combina con el esp√≠ritu de la biblioteca.  Los nombres de las variables est√°n hechos al estilo de ast, y es por eso que consisten en una letra, y no porque no se me ocurran nombres.  Creo que t es la abreviatura de tree y s para string.  Por cierto, NewType no es una cadena.  Si quisi√©ramos que se interpretara como un tipo de cadena, entonces tendr√≠amos que escribir comillas antes y despu√©s de la llamada de escritura. </p><br><p>  Y ahora <del>  la magia </del>  parche de mono: reemplace horast.Unparser con nuestro UnparserWithType. </p><br><p>  C√≥mo funciona ahora: tenemos un √°rbol de sintaxis, tiene alguna funci√≥n, las funciones tienen argumentos, los argumentos tienen anotaciones de tipo, una aguja est√° oculta en la anotaci√≥n de tipo y la muerte de Koshcheev est√° oculta en ella.  Anteriormente, no hab√≠a ning√∫n nodo de anotaci√≥n, los creamos, y cualquier nodo es una instancia de NewType.  Llamamos a la funci√≥n no analizada para nuestro √°rbol, y para cada nodo llama despacho, que clasifica ese nodo y llama a su funci√≥n correspondiente.  Tan pronto como la funci√≥n de despacho recibe el nodo del argumento, escribe el nombre del argumento, luego mira para ver si hay una anotaci√≥n (sol√≠a ser None, pero colocamos NewType all√≠), si es as√≠, escribe dos puntos y llama al despacho para la anotaci√≥n, que llama a nuestro _NewType, que solo escribe la cadena que almacena; este es el nombre del tipo.  Como resultado, obtenemos el argumento escrito: tipo. </p><br><p>  En realidad, esto no es del todo legal.  Desde el punto de vista del compilador, escribimos las anotaciones de los argumentos con algunas palabras que no est√°n definidas en ning√∫n lado, por lo que cuando unparse termina su trabajo, obtenemos el c√≥digo incorrecto: necesitamos importaciones.  Simplemente formo una l√≠nea con el formato correcto y la agrego al comienzo del archivo, y luego agrego el resultado para que se analice, aunque podr√≠a agregar importaciones como nodos al √°rbol de sintaxis, ya que ast admite los nodos Importar e Importar de. </p><br><p>  Resolver el problema de las comillas triples no es m√°s dif√≠cil que agregar un nuevo tipo.  Crearemos la clase StrType y el m√©todo _StrType.  El m√©todo no es diferente del m√©todo _NewType utilizado para anotar tipos, pero la definici√≥n de la clase ha cambiado: almacenaremos no solo la cadena en s√≠, sino tambi√©n el nivel de tabulaci√≥n en el que deber√≠a escribirse.  El n√∫mero de sangr√≠a se define de la siguiente manera: si esta l√≠nea se encuentra en una funci√≥n, entonces una, si es en un m√©todo, luego dos, y no hay casos en que la funci√≥n se defina en el cuerpo de otra funci√≥n y se decore al mismo tiempo, en nuestro proyecto. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrType</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, s, indent)</span></span></span><span class="hljs-function">:</span></span> self.s = s self.indent = indent <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'"""\n'</span></span> + self.s + <span class="hljs-string"><span class="hljs-string">'\n'</span></span> + <span class="hljs-string"><span class="hljs-string">' '</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> * self.indent + <span class="hljs-string"><span class="hljs-string">'"""\n'</span></span></code> </pre> <br><p>  En <strong>repr</strong> definimos c√≥mo deber√≠a ser nuestra l√≠nea.  Creo que esto est√° lejos de ser la √∫nica soluci√≥n, pero funciona.  Uno podr√≠a experimentar con astunparse.fill y astunparse.Unparser.indent, entonces ser√≠a m√°s universal, pero esta idea ya se me ocurri√≥ al momento de escribir este art√≠culo. </p><br><p>  Estas dificultades resueltas terminan.  Despu√©s de ejecutar mi script, a veces surge el problema de las importaciones c√≠clicas, pero esto es una cuesti√≥n de arquitectura.  No encontr√© una soluci√≥n de terceros ya preparada, y manejar estos casos dentro del marco de mi script parece ser una complicaci√≥n seria de la tarea.  Probablemente, con la ayuda de ast es posible detectar y resolver las importaciones c√≠clicas, pero esta idea debe considerarse por separado.  En general, la cantidad insignificante de tales incidentes en nuestro proyecto me permiti√≥ no procesarlos autom√°ticamente. </p><br><p>  Otra dificultad que encontr√© fue la falta de procesamiento de la expresi√≥n en ast desde la importaci√≥n astron√≥mica, ya que un lector cuidadoso ya sabe que el parche de mono es la cura para todas las enfermedades.  Deje que esta sea su tarea para √©l, pero decid√≠ hacer esto: solo agregue tales importaciones al archivo de mapeo, porque generalmente esta construcci√≥n se usa para omitir el conflicto de nombres, y tenemos pocos de ellos. </p><br><p>  A pesar de las imperfecciones encontradas, el gui√≥n hace lo que estaba destinado a hacer.  ¬øCu√°l es el resultado? </p><br><ol><li>  El tiempo de lanzamiento del proyecto se ha reducido de 10 a 3 segundos; </li><li>  El n√∫mero de archivos ha disminuido debido a la eliminaci√≥n de las definiciones new_contract.  Los archivos en s√≠ se redujeron: no med√≠, pero en promedio el git totaliz√≥ n l√≠neas agregadas y 2n borradas; </li><li>  Los IDE inteligentes comenzaron a dar pistas diferentes, porque ahora no son comentarios, sino importaciones honestas; </li><li>  La legibilidad ha mejorado; </li><li>  En alg√∫n lugar aparecieron los corchetes. </li></ol><br><p>  Gracias </p><br><p>  Enlaces utiles: </p><br><ol><li>  <a href="https://docs.python.org/3/library/ast.html">Ast</a> </li><li>  <a href="https://pypi.org/project/horast/">Horast</a> </li><li>  <a href="https://greentreesnakes.readthedocs.io/en/latest/nodes.html">Todos los tipos de nodos ast y lo que se almacena en ellos.</a> </li><li>  <a href="https://python-ast-explorer.com/">Muestra bellamente el √°rbol de sintaxis</a> </li><li>  <a href="https://pypi.org/project/isort/">Isort</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480930/">https://habr.com/ru/post/480930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480920/index.html">Prueba de interruptores TP-Link con PoE de largo alcance. Y un poco sobre actualizaciones de modelos antiguos</a></li>
<li><a href="../480922/index.html">Evgeny Usvitsky: "Todos en el mundo saben d√≥nde obtener geodatos libremente, solo en OSM"</a></li>
<li><a href="../480924/index.html">C√≥mo y por qu√© los creadores del remake de MediEvil redise√±aron al jefe de culto del juego</a></li>
<li><a href="../480926/index.html">Teor√≠a de la probabilidad para la representaci√≥n f√≠sicamente precisa</a></li>
<li><a href="../480928/index.html">Apache Hadoop Code Quality: prueba de producci√≥n VS</a></li>
<li><a href="../480936/index.html">IntelliJ IDEA conversi√≥n r√°pida UPPER_CASE a camelCase</a></li>
<li><a href="../480938/index.html">Criptomoneda a trav√©s de los ojos de los jueces rusos</a></li>
<li><a href="../480940/index.html">Ejecute la prueba de interfaz de usuario de navegador cruzado con Cucumber y Selenoid en Gitlab CI con el informe Allure</a></li>
<li><a href="../480944/index.html">Las 5 principales tendencias en marketing por correo electr√≥nico en 2020</a></li>
<li><a href="../480946/index.html">Inicia sesi√≥n en Kubernetes (y no solo) hoy: expectativas y realidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>