<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🏫 🧔🏻 👨🏾‍🏫 Menggunakan kait operasi untuk membuat cadangan file pada macOS dengan cepat 👩🏾‍🤝‍👩🏼 🚯 😣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Nama saya Denis Kopyrin, dan hari ini saya ingin berbicara tentang bagaimana kami memecahkan masalah cadangan sesuai permintaan di macOS. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan kait operasi untuk membuat cadangan file pada macOS dengan cepat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/484816/">  Halo, Habr!  Nama saya Denis Kopyrin, dan hari ini saya ingin berbicara tentang bagaimana kami memecahkan masalah cadangan sesuai permintaan di macOS.  Bahkan, tugas menarik yang saya temui di institut akhirnya tumbuh menjadi proyek penelitian besar tentang bekerja dengan sistem file.  Semua detail ada di bawah potongan. <br><br> <a href="https://habr.com/ru/company/acronis/blog/484816/"><img src="https://habrastorage.org/getpro/habr/post_images/e81/10c/67b/e8110c67b5fe5edb2a8259a8a68fe632.jpg" alt="gambar"></a> <br><a name="habracut"></a><br>  Saya tidak akan mulai dari jauh, saya hanya bisa mengatakan bahwa itu semua dimulai dengan sebuah proyek di Institut Fisika dan Teknologi Moskow, yang saya kembangkan dengan penyelia saya di departemen dasar Acronis.  Kami dihadapkan dengan tugas mengatur penyimpanan file jarak jauh, atau lebih tepatnya, mempertahankan status cadangan mereka saat ini. <br><br>  Untuk memastikan keamanan data, kami menggunakan ekstensi kernel macOS, yang mengumpulkan informasi tentang peristiwa dalam sistem.  KPI untuk pengembang memiliki API KAUTH, yang memungkinkan Anda menerima pemberitahuan tentang membuka dan menutup file - itu saja.  Jika Anda menggunakan KAUTH, Anda harus benar-benar menyimpan file ketika membukanya untuk menulis, karena peristiwa penulisan ke file tidak tersedia untuk pengembang.  Informasi seperti itu tidak cukup untuk tugas kami.  Memang, untuk menambah salinan data cadangan secara permanen, Anda harus memahami persis di mana pengguna (atau malware) menulis data baru ke file tersebut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d12/250/d5e/d12250d5e699b0841d0059eb5ba8846c.png" alt="gambar"><br><br>  Tapi siapa dari pengembang yang takut dengan pembatasan OS?  Jika API kernel tidak memungkinkan Anda untuk mendapatkan informasi tentang operasi penulisan, maka Anda harus menemukan cara Anda sendiri untuk menyadap melalui alat kernel lainnya. <br><br>  Pada awalnya, kami tidak ingin menambal inti dan strukturnya.  Sebagai gantinya, mereka mencoba membuat volume virtual keseluruhan yang memungkinkan kami mencegat semua permintaan baca dan tulis yang melewatinya.  Tetapi pada saat yang sama, satu fitur macOS yang tidak menyenangkan ternyata: sistem operasi percaya bahwa ia belum 1, tetapi 2 USB flash drive, dua disk, dan sebagainya.  Dan dari kenyataan bahwa volume kedua berubah ketika bekerja dengan yang pertama, macOS mulai bekerja secara salah dengan drive.  Ada banyak masalah dengan metode ini sehingga saya harus meninggalkannya. <br><br><h3>  Cari solusi lain </h3><br>  Terlepas dari keterbatasan KAUTH, KPI ini memungkinkan Anda mendapatkan pemberitahuan tentang penggunaan file untuk merekam sebelum semua operasi.  Pengembang diberikan akses ke abstraksi file BSD di kernel - vnode.  Anehnya, ternyata menambal vnode lebih mudah daripada menggunakan penyaringan volume.  Struktur vnode memiliki tabel fungsi yang menyediakan pekerjaan dengan file nyata.  Karenanya, kami memiliki ide untuk mengganti tabel ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b1/6c7/a9b/6b16c7a9b87a054f0ae5898d043aa91d.png" alt="gambar"><br><br>  Ide itu langsung dianggap sebagai ide yang baik, tetapi untuk implementasinya, perlu untuk menemukan tabel itu sendiri dalam struktur vnode, karena Apple tidak mendokumentasikan lokasinya di mana pun.  Untuk melakukan ini, perlu mempelajari kode mesin kernel, dan juga untuk mencari tahu apakah mungkin untuk menulis ke alamat ini sehingga sistem tidak mati setelah itu. <br><br>  Jika tabel ditemukan, kita cukup menyalinnya ke memori, ganti pointer dan tempel tautan ke tabel baru ke vnode yang ada.  Berkat ini, semua operasi dengan file akan melalui driver kami, dan kami akan dapat mendaftarkan semua permintaan pengguna, termasuk membaca dan menulis.  Karena itu, pencarian meja yang berharga telah menjadi tujuan utama kami. <br><br>  Mengingat bahwa Apple tidak benar-benar menginginkan ini, untuk menyelesaikan masalah Anda perlu mencoba “menebak” lokasi tabel menggunakan heuristik untuk lokasi relatif bidang, atau mengambil fungsi yang sudah diketahui, membongkar dan mencari offset dari informasi ini. <br><br>  <b>Cara mencari offset: cara mudah</b> <br><br>  Cara termudah untuk menemukan offset tabel dalam vnode adalah heuristik berdasarkan lokasi bidang dalam struktur ( <a href="">tautan ke Github</a> ). <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vnode</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (**v_op)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">/* vnode operations vector */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mount_t</span></span> v_mount; <span class="hljs-comment"><span class="hljs-comment">/* ptr to vfs we are in */</span></span> ... }</code> </pre> <br>  Kami akan menggunakan asumsi bahwa bidang v_op yang kami butuhkan persis 8 byte dihapus dari v_mount.  Nilai yang terakhir dapat diperoleh dengan menggunakan KPI publik ( <a href="">tautan ke Github</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mount_t</span></span> vnode_mount(<span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> vp);</code> </pre><br>  Mengetahui nilai v_mount, kita mulai mencari "jarum di tumpukan jerami" - kita akan melihat nilai pointer ke vnode 'vp' sebagai uintptr_t *, nilai vnode_mount (vp) sebagai uintptr_t.  Ini diikuti oleh iterasi ke nilai “wajar” dari i, sampai kondisi 'tumpukan jerami [i] == jarum' terpenuhi.  Dan jika asumsi tentang lokasi bidang sudah benar, offset v_op adalah i-1. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVOPPtr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vnode_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> haystack = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>*) vp; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> needle = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>) vnode_mount(vp); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ATTEMPTCOUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (haystack[i] == needle) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> haystack + (i - <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre><br>  <b>Cara mencari offset: pembongkaran</b> <br><br>  Meskipun kesederhanaannya, metode pertama memiliki kelemahan yang signifikan.  Jika Apple mengubah urutan bidang dalam struktur vnode, metode sederhana akan rusak.  Metode yang lebih universal, tetapi kurang sepele adalah secara dinamis membongkar kernel. <br><br>  Sebagai contoh, perhatikan fungsi kernel yang dibongkar VNOP_CREATE ( <a href="">tautan ke Github</a> ) di macOS 10.14.6.  Instruksi yang menarik bagi kami ditandai dengan panah -&gt;. <br><br> <code>_VNOP_CREATE: <br> 1 push rbp <br> 2 mov rbp, rsp <br> 3 push r15 <br> 4 push r14 <br> 5 push r13 <br> 6 push r12 <br> 7 push rbx <br> 8 sub rsp, 0x48 <br> 9 mov r15, r8 <br> 10 mov r12, rdx <br> 11 mov r13, rsi <br> -&gt; 12 mov rbx, rdi <br> 13 lea rax, qword [___stack_chk_guard] <br> 14 mov rax, qword [rax] <br> 15 mov qword [rbp+-48], rax <br> -&gt; 16 lea rax, qword [_vnop_create_desc] ; _vnop_create_desc <br> 17 mov qword [rbp+-112], rax <br> 18 mov qword [rbp+-104], rdi <br> 19 mov qword [rbp+-96], rsi <br> 20 mov qword [rbp+-88], rdx <br> 21 mov qword [rbp+-80], rcx <br> 22 mov qword [rbp+-72], r8 <br> -&gt; 23 mov rax, qword [rdi+0xd0] <br> -&gt; 24 movsxd rcx, dword [_vnop_create_desc] <br> 25 lea rdi, qword [rbp+-112] <br> -&gt; 26 call qword [rax+rcx*8] <br> 27 mov r14d, eax <br> 28 test eax, eax <br> ….</code> <br> <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">errno_t</span></span> VNOP_CREATE(<span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> dvp, <span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> * vpp, struct componentname * cnp, struct vnode_attr * vap, <span class="hljs-keyword"><span class="hljs-keyword">vfs_context_t</span></span> ctx) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _err; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vnop_create_args</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">;</span></span> a.a_desc = &amp;vnop;_create_desc; a.a_dvp = dvp; a.a_vpp = vpp; a.a_cnp = cnp; a.a_vap = vap; a.a_context = ctx; _err = (*dvp-&gt;v_op[vnop_create_desc.vdesc_offset])(&amp;a;); …</code> </pre><br>  Kami akan memindai instruksi assembler untuk menemukan pergeseran dalam vnode dvp.  "Tujuan" kode assembler adalah untuk memanggil fungsi dari tabel v_op.  Untuk melakukan ini, prosesor harus mengikuti langkah-langkah ini: <br><br><ol><li>  Unggah dvp untuk mendaftar </li><li>  Dereferensi untuk mendapatkan v_op (baris 23) </li><li>  Dapatkan vnop_create_desc.vdesc_offset (baris 24) </li><li>  Panggil fungsi (saluran 26) </li></ol><br>  Jika semuanya jelas dengan langkah 2-4, maka kesulitan muncul dengan langkah pertama.  Bagaimana memahami register dvp mana yang dimuat?  Untuk melakukan ini, kami menggunakan metode meniru fungsi yang memantau pergerakan pointer yang diinginkan.  Menurut konvensi pemanggilan System V x86_64, argumen pertama dilewatkan dalam register rdi.  Oleh karena itu, kami memutuskan untuk melacak semua register yang berisi rdi.  Dalam contoh saya, ini adalah register rbx dan rdi.  Juga, salinan register dapat disimpan di stack, yang ditemukan dalam versi debug kernel. <br><br>  Mengetahui bahwa register rbx dan rdi menyimpan dvp, kita mengetahui bahwa vnode dereferensi baris 23 untuk mendapatkan v_op.  Jadi kita mendapatkan asumsi bahwa perpindahan dalam struktur adalah 0xd0.  Untuk mengkonfirmasi keputusan yang benar, kami terus memindai dan memastikan bahwa fungsi tersebut dipanggil dengan benar (baris 24 dan 26). <br><br>  Metode ini lebih aman, tetapi, sayangnya, ia juga memiliki kelemahan.  Kita harus mengandalkan fakta bahwa pola fungsi (yaitu 4 langkah yang kita bicarakan di atas) akan sama.  Namun, probabilitas mengubah pola fungsi adalah urutan besarnya kurang dari probabilitas mengubah urutan bidang.  Jadi kami memutuskan untuk berhenti pada metode kedua. <br><br><h3>  Ganti pointer dalam tabel </h3><br>  Setelah menemukan v_op, muncul pertanyaan, bagaimana cara menggunakan pointer ini?  Ada dua cara berbeda - menimpa fungsi dalam tabel (panah ketiga pada gambar) atau menimpa tabel dalam vnode (panah kedua pada gambar). <br><br>  Pada awalnya sepertinya opsi pertama lebih menguntungkan, karena kita hanya perlu mengganti satu pointer.  Namun, pendekatan ini memiliki 2 kelemahan signifikan.  Pertama, tabel v_op adalah sama untuk semua vnode dari sistem file yang diberikan (v_op untuk HFS +, v_op untuk APFS, ...), jadi diperlukan penyaringan dengan vnode, yang bisa sangat mahal - Anda harus menyaring vnode tambahan pada setiap operasi penulisan.  Kedua, tabel ditulis pada halaman Read-Only.  Batasan ini dapat dielakkan jika Anda menggunakan rekaman melalui IOMappedWrite64, melewati pemeriksaan sistem.  Juga, jika kext dengan driver sistem file dikirimkan, akan sulit untuk mengetahui cara menghapus tambalan. <br><br>  Opsi kedua ternyata lebih bertarget dan aman - pencegat akan dipanggil hanya untuk vnode yang diperlukan, dan memori vnode pada awalnya memungkinkan operasi Baca-Tulis.  Karena seluruh tabel sedang diganti, perlu untuk mengalokasikan lebih banyak memori (80 fungsi daripada satu).  Dan karena jumlah tabel biasanya sama dengan jumlah sistem file, batas memori benar-benar dapat diabaikan. <br><br>  Itulah sebabnya kext menggunakan metode kedua, meskipun, saya ulangi, sekilas tampaknya opsi ini lebih buruk. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f6/adc/957/0f6adc957cded9d732080d3f32cfa4d1.png" alt="gambar"><br><br>  Akibatnya, pengemudi kami bekerja sebagai berikut: <br><br><ol><li>  API KAUTH menyediakan vnode </li><li>  Kami mengganti tabel vnode.  Jika diperlukan, kami mencegat operasi hanya untuk vnode "menarik", misalnya, dokumen pengguna </li><li>  Saat mencegat, kami memeriksa proses mana yang direkam, kami memfilter "milik kami" </li><li>  Kami mengirimkan permintaan UserSpace yang sinkron kepada klien, yang memutuskan apa yang sebenarnya perlu disimpan. </li></ol><br><h3>  Apa yang terjadi </h3><br>  Hari ini kami memiliki modul eksperimental, yang merupakan perluasan dari kernel macOS dan memperhitungkan setiap perubahan pada sistem file di tingkat granular.  Perlu dicatat bahwa di macOS 10.15 Apple memperkenalkan kerangka kerja baru ( <a href="https://developer.apple.com/documentation/endpointsecurity%3Flanguage%3Dobjc">tautan ke EndpointSecurity</a> ) untuk menerima pemberitahuan perubahan pada sistem file, yang direncanakan untuk digunakan dalam Perlindungan Aktif, oleh karena itu solusi yang dijelaskan dalam artikel tersebut dinyatakan usang. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484816/">https://habr.com/ru/post/id484816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484802/index.html">Mode penghancuran diri: dekomposisi kapsul endoskopi karena cahaya</a></li>
<li><a href="../id484804/index.html">Apa yang harus dienkripsi dalam sistem perusahaan? Dan mengapa melakukan ini?</a></li>
<li><a href="../id484806/index.html">Perbedaan antara cPanel dan Plesk Obsidian</a></li>
<li><a href="../id484812/index.html">Pengalaman saya dengan Plesk</a></li>
<li><a href="../id484814/index.html">6. Fortinet Memulai v6.0. Penyaringan Web dan Kontrol Aplikasi</a></li>
<li><a href="../id484818/index.html">Buku "C ++. Praktek pemrograman multithreaded "</a></li>
<li><a href="../id484820/index.html">FAQ.Net - program pencatatan gratis untuk Windows dengan desain yang diperbarui</a></li>
<li><a href="../id484822/index.html">Blazor: cara mencegah komponen agar tidak sakit atau dua pendekatan untuk memisahkan kode dari markup</a></li>
<li><a href="../id484824/index.html">Perang untuk mematikan lampu</a></li>
<li><a href="../id484826/index.html">Kecerdasan buatan memperburuk kedokteran yang buruk bahkan lebih</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>