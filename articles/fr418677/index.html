<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëô üë©üèø‚Äç‚öñÔ∏è üçß Toute la v√©rit√© sur RTOS. Article # 6. Autres services RTOS üë©üèΩ‚Äçüîß üë¥üèΩ üßó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans les articles pr√©c√©dents, nous avons discut√© de la fonctionnalit√© du noyau en termes de t√¢ches effectu√©es et de l'interaction entre elles. Dans ce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la v√©rit√© sur RTOS. Article # 6. Autres services RTOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418677/"><img src="https://habrastorage.org/webt/zw/8-/qc/zw8-qcoua4iac13tid0bo2ivkrw.jpeg"><br><br>  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les articles pr√©c√©dents,</a> nous avons discut√© de la fonctionnalit√© du noyau en termes de t√¢ches effectu√©es et de l'interaction entre elles.  Dans cet article, nous examinons ce que le noyau peut faire d'autre, ce qui se manifeste largement dans un certain nombre d'autres appels d'API disponibles.  Nous r√©pondrons √©galement √† la question: qu'est-ce qui transforme le noyau en syst√®me d'exploitation? <br><a name="habracut"></a><br>  Articles pr√©c√©dents de la s√©rie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interaction et synchronisation des t√¢ches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches, changement de contexte et interruptions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches et planification</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps r√©el</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> <br><h2>  Gestion des t√¢ches </h2><br>  En plus de la planification des t√¢ches et de l'interaction entre eux, le RTOS comprendra des fonctionnalit√©s (appels API) pour g√©rer les t√¢ches de diff√©rentes mani√®res.  Examinons quelques possibilit√©s. <br><br>  <b>Cr√©er et supprimer des t√¢ches</b> <br><br>  Dans le RTOS "dynamique", il existe des appels de fonction qui vous permettent de cr√©er des t√¢ches (et d'autres objets RTOS) quand elles sont n√©cessaires.  Ces appels incluent un large √©ventail de param√®tres qui d√©finissent la t√¢che, par exemple, le point d'entr√©e, la taille de la pile et la priorit√©.  L'appel d'API de suppression de t√¢che correspondant vous permet de lib√©rer des ressources une fois la t√¢che termin√©e. <br><br>  Dans le RTOS "statique", les param√®tres de d√©finition de la t√¢che sont configur√©s dans une sorte de fichier de configuration lors de l'assemblage. <br><br>  <b>Mettre en pause et reprendre une t√¢che</b> <br><br>  Comme nous l'avons vu, la plupart des RTOS ont le concept d'un √©tat de t√¢ches ¬´suspendu¬ª.  Cela peut √™tre r√©alis√© de diff√©rentes mani√®res.  L'un d'eux est un appel explicite √† la fonction API Suspend Task.  Il peut √™tre caus√© par lui-m√™me ou par une autre t√¢che.  L'appel ¬´Reprendre la t√¢che¬ª correspondant permet √† la t√¢che de faire √† nouveau la queue pour la planification. <br><br>  <b>√âtat de veille des t√¢ches</b> <br><br>  Pour un syst√®me en temps r√©el, le contr√¥le du temps est une exigence importante et peut prendre diverses formes.  Une vue simple est la capacit√© de la t√¢che √† "s'endormir", c'est-√†-dire que la t√¢che est suspendue pendant un certain temps.  Lorsque le temps est √©coul√©, la t√¢che se "r√©veille" et est √† nouveau mise en file d'attente pour la planification.  Un appel API sera g√©n√©ralement disponible √† cet effet.  Bien entendu, cette fonctionnalit√© d√©pend de la disponibilit√© de la minuterie. <br><br>  <b>Exemption</b> <br><br>  Lors de l'utilisation de l'ordonnanceur Round Robin ("carrousel"), une t√¢che peut refuser de contr√¥ler le processeur pour la prochaine t√¢che de la cha√Æne.  Pour ce faire, la fonction API ¬´Release task¬ª sera disponible.  La t√¢che n'est pas suspendue, elle sera disponible pour la planification √† son tour.  Lors de l'utilisation du planificateur de tranche de temps, il est possible qu'une t√¢che puisse lib√©rer une partie de son intervalle de temps si elle n'a pas de travail important √† faire imm√©diatement.  La lib√©ration d'une t√¢che n'a aucune signification logique lors de l'ex√©cution des planificateurs Ex√©cuter jusqu'√† la fin ou Priorit√©. <br><br>  <b>Ach√®vement de la t√¢che</b> <br><br>  Dans un article pr√©c√©dent, nous avons constat√© qu'en plus des √©tats ¬´Pr√™t¬ª ou ¬´Suspendu¬ª, le RTOS peut prendre en charge d'autres √©tats de t√¢che.  La t√¢che peut √™tre ¬´termin√©e¬ª, ce qui signifie que sa fonction principale vient de quitter: aucun appel API sp√©cial n'est requis.  Une t√¢che peut √™tre ¬´Termin√©e¬ª, ce qui signifie qu'elle n'est pas disponible pour la planification et doit √™tre r√©initialis√©e pour redevenir disponible pour le lancement, voir ¬´R√©initialisation d'une t√¢che¬ª ci-dessous.  Cela n√©cessite un appel API sp√©cial.  La disponibilit√© de ces √©tats de t√¢che suppl√©mentaires, la terminologie utilis√©e et leurs d√©finitions exactes varient en fonction du RTOS. <br><br>  <b>R√©initialisation de la t√¢che</b> <br><br>  De nombreux RTOS proposent un appel √† la fonction API ¬´Reset Task¬ª, qui vous permet de ramener la t√¢che √† son √©tat d'origine.  Elle peut √™tre suspendue et exiger l'ex√©cution de la fonction ¬´Reprendre la t√¢che¬ª afin de faire la queue pour la planification. <br><br>  <b>T√¢ches prioritaires, etc.</b> <br><br>  Dans un RTOS ¬´dynamique¬ª, des appels d'API peuvent √™tre disponibles pour configurer plusieurs param√®tres de t√¢che au moment de l'ex√©cution.  Les exemples incluent la priorit√© et la dur√©e de l'intervalle de temps. <br><br><h2>  Informations syst√®me </h2><br>  Dans RTOS, il y aura un certain nombre d'appels d'API pour fournir au syst√®me des informations sur la t√¢che, notamment: <br>  <b>Informations sur les t√¢ches</b> .  Combien de t√¢ches se trouvent dans le syst√®me, leur configuration et leur √©tat actuel. <br>  <b>Informations sur d'autres objets du noyau.</b>  Le nombre d'objets de chaque type dans le syst√®me, leur configuration et les informations sur l'√©tat actuel.  Par exemple: <br><br><ul><li>  Quelle est la capacit√© actuelle de la file d'attente? Puis-je ajouter d'autres messages? </li><li>  combien de t√¢ches sont suspendues sur une bo√Æte aux lettres particuli√®re? </li></ul>  <b>Informations sur la version RTOS</b> .  Un appel API peut fournir des donn√©es similaires. <br><br><h2>  Allocation de m√©moire </h2><br>  Dans de nombreuses applications, il est important que le programme puisse capturer dynamiquement de la m√©moire lorsqu'elle est n√©cessaire et la lib√©rer lorsqu'elle n'est plus n√©cessaire.  La m√™me chose se produit dans le firmware.  Cependant, les approches conventionnelles sont sujettes √† des probl√®mes qui sont peu probables ou incommodes dans les applications de bureau, mais elles peuvent √™tre d√©sastreuses pour un syst√®me embarqu√©.  N√©anmoins, il existe des moyens de mettre en ≈ìuvre de tels services, m√™me dans un RTOS statique. <br><br><h2>  Probl√®mes avec les fonctions malloc () et free () </h2><br>  Dans un programme C de bureau, une fonction peut appeler <b>malloc ()</b> , indiquant la quantit√© de m√©moire requise, et r√©cup√©rer un pointeur vers la zone de stockage.  En utilisant la m√©moire, elle peut √™tre lib√©r√©e en appelant <b>free ()</b> .  La m√©moire est allou√©e √† partir d'une zone appel√©e tas.  Le probl√®me avec cette approche est qu'avec une s√©quence non coordonn√©e d'appels √† ces fonctions, la zone de tas peut facilement devenir fragment√©e, puis l'allocation de m√©moire √©chouera m√™me si suffisamment de m√©moire est disponible, car  les zones adjacentes ne sont pas assez grandes.  Certains syst√®mes (tels que Java et Visual Basic) utilisent des sch√©mas sophistiqu√©s de ¬´garbage collection¬ª pour d√©fragmenter.  Le probl√®me est que ces sch√©mas peuvent entra√Æner des retards impr√©visibles importants dans l'ex√©cution et la n√©cessit√© d'utiliser des pointeurs indirects (qui ne fonctionne pas en C). <br><br>  Si <b>malloc ()</b> et <b>free ()</b> √©taient impl√©ment√©s de mani√®re r√©entrante (g√©n√©ralement pas) et utilis√©s par les t√¢ches RTOS, la fragmentation se produira tr√®s rapidement et une d√©faillance du syst√®me sera presque in√©vitable.  En C ++, il existe de <b>nouveaux</b> op√©rateurs de <b>suppression</b> qui ex√©cutent g√©n√©ralement les m√™mes fonctions que malloc () et free ().  Ils sont soumis aux m√™mes limitations et probl√®mes. <br><br><h2>  Sections de m√©moire </h2><br>  Pour fournir un syst√®me en temps r√©el avec une m√©moire accessible dynamiquement, une approche par blocs de la gestion de la m√©moire peut √™tre utilis√©e.  Ces blocs sont commun√©ment appel√©s "partitions";  les partitions peuvent √™tre allou√©es √† partir du "pool de partitions". <br><br>  Le pool de partitions contient un certain nombre de blocs, chacun ayant la m√™me taille.  Le nombre et la taille des blocs d'une partition sont d√©termin√©s lors de la cr√©ation du pool de partitions.  Cela peut √™tre dynamique si le syst√®me lui-m√™me le permet, ou statiquement pendant l'assemblage.  En r√®gle g√©n√©rale, une application peut inclure plusieurs pools de partitions offrant des blocs de tailles diff√©rentes. <br><br>  Si une t√¢che a besoin de m√©moire, elle appelle une API qui demande un bloc √† partir d'un pool sp√©cifique.  Si cet appel r√©ussit, la t√¢che recevra un pointeur vers le bloc s√©lectionn√©.  Si l'appel √©choue parce que  il n'y a pas de partitions disponibles dans le pool indiqu√©, la t√¢che peut recevoir une r√©ponse d'erreur.  Alternativement, la t√¢che peut √™tre bloqu√©e (suspendue) jusqu'√† ce qu'une autre t√¢che lib√®re le blocage dans la section. <br><br>  En r√®gle g√©n√©rale, une t√¢che passe simplement un pointeur vers un bloc de m√©moire dans n'importe quel code qui utilise le bloc.  Cela conduit √† un probl√®me lorsque le bloc n'est plus n√©cessaire.  Si le code n'a qu'un pointeur sur un bloc, comment peut-il indiquer au RTOS via un appel d'API, √† partir de quel pool de partitions veut-il lib√©rer de la m√©moire?  La r√©ponse est que la plupart des RTOS prennent en charge des donn√©es suppl√©mentaires dans un bloc d√©di√© (g√©n√©ralement un d√©calage n√©gatif par rapport au pointeur) qui fournissent les informations requises.  Ainsi, pour appeler l'API pour lib√©rer un bloc, seule son adresse est requise. <br><br>  L'article suivant contiendra plus d'informations sur les partitions de m√©moire. <br><br><h2>  Le temps </h2><br>  Les fonctionnalit√©s associ√©es √† l'utilisation et au contr√¥le du temps sont susceptibles d'√™tre disponibles dans le syst√®me d'exploitation en temps r√©el.  Les opportunit√©s varieront en fonction du RTOS, mais nous consid√©rerons celles disponibles publiquement.  Dans tous les cas, le temporisateur en temps r√©el est un √©l√©ment indispensable au fonctionnement de l'un de ces services. <br><br>  <b>Heure syst√®me</b> <br><br>  L'heure syst√®me simple, ou "horloge", est presque toujours disponible.  Il s'agit simplement d'un compteur (g√©n√©ralement 32 bits), qui est incr√©ment√© √† l'aide de la routine de service d'interruption en temps r√©el et peut √™tre d√©fini et lu via des appels d'API. <br><br>  <b>D√©lais d'attente des appels de service</b> <br><br>  En r√®gle g√©n√©rale, un RTOS permet de bloquer les appels d'API, c'est-√†-dire que la t√¢che d'appel est suspendue (bloqu√©e) jusqu'√† ce que le service demand√© soit fourni.  Habituellement, ce verrou est vague, mais certains RTOS offrent un d√©lai pendant lequel l'appel revient √† l'expiration du d√©lai si le service continue d'√™tre indisponible.  Les d√©lais d'expiration des appels API ne sont pas pris en charge par tous les RTOS. <br><br>  <b>√âtat de veille des t√¢ches</b> <br><br>  En r√®gle g√©n√©rale, les t√¢ches ont la possibilit√© de s'interrompre pendant une p√©riode de temps fixe.  Cela a √©t√© discut√© pr√©c√©demment dans la section Gestion des t√¢ches. <br><br>  <b>Minuteries logicielles</b> <br><br>  Pour que les t√¢ches du programme ex√©cutent des fonctions de comptage du temps, la plupart des RTOS proposent des objets de temporisation.  Ce sont des temporisateurs ind√©pendants mis √† jour par le gestionnaire d'interruption de temporisateur en temps r√©el, qui peuvent √™tre contr√¥l√©s par des appels d'API.  Ces appels configurent, contr√¥lent et contr√¥lent le fonctionnement du temporisateur.  En r√®gle g√©n√©rale, ils peuvent √™tre d√©finis pour un seul actionnement ou red√©marrage automatique.  Une routine d'expiration est √©galement g√©n√©ralement prise en charge, une fonction qui s'ex√©cute chaque fois qu'une minuterie termine un cycle.  Le prochain article fournira plus d'informations sur les temporisateurs logiciels et une description de leur impl√©mentation. <br><br><h2>  Interruptions, pilotes et E / S </h2><br>  La mesure dans laquelle les RTOS sont associ√©s aux interruptions et aux E / S est tr√®s diff√©rente.  De m√™me, certains RTOS ont une structure tr√®s claire pour les pilotes de p√©riph√©riques, ce qui peut ajouter des probl√®mes lors du choix d'un produit sp√©cifique. <br><br>  <b>Interruptions</b> <br><br>  Les interruptions pr√©sentent un probl√®me pour RTOS pour deux raisons. <br><br><ul><li>  Sans aucune pr√©caution, le gestionnaire d'interruption (ISR) ¬´volera¬ª le temps processeur, perturbant ainsi le comportement RTOS en temps r√©el. </li><li>  Si l'ISR effectue des appels d'API qui affectent la planification des t√¢ches, cela doit √™tre surveill√© et le RTOS doit pouvoir ex√©cuter son algorithme de planification. </li></ul>  Un exemple d'un tel appel API est la proc√©dure pour r√©veiller une t√¢che avec une priorit√© plus √©lev√©e que celle qui a √©t√© lanc√©e lorsque l'interruption s'est produite. <br><br>  Certains RTOS contr√¥lent enti√®rement toutes les interruptions.  Une s√©rie d'appels API sont disponibles pour "enregistrer" les programmes ISR.  Cette approche permet au planificateur de d√©terminer quand les interruptions sont activ√©es et facilite l'utilisation de la plupart des appels d'API √† partir de l'ISR. <br><br>  Par exemple, Nucleus RTOS impl√©mente le concept de gestionnaires d'interruptions ¬´basse priorit√©¬ª et ¬´haute priorit√©¬ª, qui fournit une gestion fiable des interruptions sans surcharge inutile (c'est-√†-dire une augmentation du d√©lai d'interruption). <br><br>  D'autres RTOS peuvent utiliser le mode automatique ¬´sans intervention¬ª pour les interruptions, ce qui offre aux d√©veloppeurs plus d'options pour s'assurer que les gestionnaires d'interruption fonctionnent correctement.  En r√®gle g√©n√©rale, un pr√©fixe ISR suppl√©mentaire (prologue) et un suffixe (√©pilogue) sont fournis pour prot√©ger les appels d'API qui y sont effectu√©s. <br>  Nucleus SE utilise une routine d'interruption l√©g√®re, qui sera d√©crite dans un futur article. <br><br>  <b>Pilotes</b> <br><br>  La plupart des RTOS d√©terminent la structure du pilote de p√©riph√©rique.  Les d√©tails peuvent varier en fonction du RTOS, mais le pilote se compose g√©n√©ralement de deux composants en interaction: le code int√©gr√© (appels API) et ISR.  En r√®gle g√©n√©rale, d'autres appels API seront disponibles pour g√©rer et enregistrer les pilotes. <br><br>  <b>Entr√©e / sortie</b> <br><br>  Actuellement, la plupart des RTOS sur le march√© ne se soucient pas des entr√©es / sorties de niveau sup√©rieur, mais certains d'entre eux d√©finissent un flux d'entr√©e / sortie, qui √©tablit essentiellement une connexion entre les pilotes de p√©riph√©rique correspondants et les fonctions du langage C standard, telles que printf (). <br>  Historiquement, le RTOS supportait souvent la ¬´console¬ª, l'interface utilisateur du RTOS via un canal s√©rie.  Cela a √©t√© principalement utilis√© pour les diagnostics et le d√©bogage.  L'utilisation de d√©bogueurs modernes qui prennent en charge le d√©bogage d'applications avec RTOS √©limine le besoin de tels objets. <br><br><h2>  Diagnostics </h2><br>  En r√®gle g√©n√©rale, RTOS n√©cessite des performances maximales avec un encombrement m√©moire minimal.  Par cons√©quent, la v√©rification d'int√©grit√© n'est pas une priorit√© √©lev√©e.  Avec l'aide de technologies de d√©bogage modernes qui prennent en compte les fonctionnalit√©s du RTOS, la plupart des contr√¥les peuvent √™tre effectu√©s en dehors du RTOS lui-m√™me. <br><br><h2>  V√©rification des param√®tres d'appel d'API </h2><br>  Les appels d'API peuvent avoir de nombreux param√®tres complexes.  Cela peut provoquer des erreurs.  De nombreux RTOS fournissent une v√©rification des param√®tres d'ex√©cution avec le retour d'un code d'erreur en cas de param√®tre incorrect.  √âtant donn√© que cela n√©cessite du code suppl√©mentaire et que les v√©rifications elles-m√™mes affectent n√©gativement les performances, il est pr√©f√©rable de v√©rifier les param√®tres lors de l'assemblage ou de la configuration. <br><br><h2>  V√©rification de la pile </h2><br>  Pour la plupart des types de planificateurs (sauf Run to Completion), chaque t√¢che a sa propre pile, dont la taille est d√©termin√©e individuellement.  Dans certains RTOS, le noyau a une pile distincte, dans d'autres, la pile de t√¢ches est ¬´emprunt√©e¬ª lors d'un appel d'API.  De toute √©vidence, l'int√©grit√© de la pile est importante pour la fiabilit√© globale du syst√®me.  Par cons√©quent, les RTOS offrent souvent des outils pour v√©rifier l'int√©grit√© de la pile au moment de l'ex√©cution.  Il existe plusieurs options: <br><br><ul><li>  Un appel d'API qui renvoie la quantit√© d'espace de pile pour la t√¢che actuelle ou sp√©cifi√©e. </li><li>  Les param√®tres de d√©limitation de la pile.  On leur attribue une valeur unique (g√©n√©ralement impaire et non nulle), qui est p√©riodiquement v√©rifi√©e pour la r√©√©criture. </li></ul><br><br><h2>  Diagnostic d'application </h2><br>  Malgr√© le fait que cette fonction n'est pas directement prise en charge dans le RTOS, une t√¢che d'application peut √™tre allou√©e pour v√©rifier l'int√©grit√© de l'ensemble du syst√®me.  Une telle t√¢che peut √™tre responsable de la r√©initialisation du temporisateur de surveillance.  Une t√¢che peut recevoir des donn√©es d'entr√©e p√©riodiques (par exemple, des param√®tres de signal) de chaque t√¢che critique.  La r√©initialisation de la minuterie du chien de garde (qui emp√™chera le red√©marrage du syst√®me) ne sera effectu√©e qu'apr√®s l'arriv√©e des donn√©es de toutes les t√¢ches. <br><br><h2>  Services non noyaux </h2><br>  Le RTOS est plus que le noyau sur lequel nous nous sommes concentr√©s jusqu'√† pr√©sent.  Ce syst√®me d'exploitation de bureau est consid√©rablement diff√©rent du RTOS int√©gr√©.  En r√®gle g√©n√©rale, dans un syst√®me d'exploitation de bureau, tous les composants suppl√©mentaires sont regroup√©s ou peuvent √™tre install√©s (tous les PC de bureau ont une interface utilisateur graphique et seuls quelques-uns d'entre eux n'ont pas acc√®s au r√©seau).  Le PC de bureau n'a pas de r√©elles limites de ressources: il y a toujours de la m√©moire libre, de l'espace disque dur et des ressources CPU inutilis√©es.  Dans un monde de syst√®mes embarqu√©s avec des ressources limit√©es, des composants suppl√©mentaires tels que des cartes vid√©o, des composants r√©seau et des syst√®mes de fichiers peuvent √™tre n√©cessaires, mais ils doivent √™tre d√©connectables et √©volutifs pour minimiser l'empreinte m√©moire. <br><br>  <b>Fonctionnalit√©s de mise en r√©seau</b> <br><br>  La plupart des syst√®mes embarqu√©s sont en quelque sorte li√©s aux r√©seaux.  Ainsi, il est pr√©vu qu'il existe un int√©r√™t important pour les solutions de mise en r√©seau pour les syst√®mes embarqu√©s, en raison de laquelle il existe un grand nombre de produits sur le march√©. <br><br>  <b>TCP / IP</b> est un protocole standard qui est largement utilis√© et est le choix √©vident pour de nombreuses applications.  En r√®gle g√©n√©rale, TCP / IP est utilis√© pour le protocole Ethernet (IEEE802.3), qui fournit une vitesse moyenne de 10 Mb / s.  Aujourd'hui, 100 Mb / s sont assez courants, et √† l'approche 1 Gb / s.  De plus, TCP / IP peut √™tre utilis√© pour d'autres protocoles.  Par exemple, PPP (Point-to-Point Protocol) est une impl√©mentation TCP / IP pour le transfert de donn√©es s√©rie qui a √©t√© adapt√©e pour les connexions Internet √† large bande. <br><br>  Jusqu'√† r√©cemment, la version v4 du protocole IP (IPv4) √©tait utilis√©e.  Cependant, il devient obsol√®te √† mesure que les adresses libres s'√©puisent.  La solution est IPv6, augmentant consid√©rablement le nombre d'adresses possibles et fournissant des outils plus efficaces pour la maintenance et la s√©curit√©.  IPv6 est largement disponible et utilis√© dans les √©quipements de nombreux pays, ainsi que dans les syst√®mes militaires du monde entier. <br>  Une alternative est le protocole UDP (User Datagram Protocol).  Ce protocole est utilis√© pour des performances maximales.  UDP n'offre pas la m√™me fiabilit√© et coh√©rence que TCP, mais il est l√©ger et tr√®s efficace. <br><br>  <b>L'USB</b> est le bus s√©rie universel, largement utilis√© dans les appareils pour la connexion aux ordinateurs de bureau.  Il fournit une interface plug-and-play tr√®s facile √† utiliser qui cache des logiciels assez sophistiqu√©s.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un p√©riph√©rique int√©gr√© qui doit √™tre connect√© √† un PC doit √™tre impl√©ment√© en tant que fonction USB, ce qui n√©cessite un ensemble sp√©cifique de composants logiciels. Si l'appareil doit g√©rer d'autres appareils connect√©s via USB (comme un PC ordinaire), il a besoin d'un ensemble de logiciels de type h√¥te. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IEEE1394</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une autre norme d'interface s√©rie utilis√©e pour transf√©rer rapidement de grandes quantit√©s de donn√©es entre les appareils (par exemple, pour la transmission de donn√©es vid√©o), √©galement connue sous le nom de FireWire et i.Link.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocoles sans fil - la commodit√© et la pr√©valence de diverses technologies sans fil chez les consommateurs ont entra√Æn√© une forte demande de capacit√©s sans fil dans les appareils int√©gr√©s. Le Wi-Fi (ensemble de normes IEEE802.11) fournit un ensemble complet de capacit√©s r√©seau, vous permettant de mettre en ≈ìuvre des topologies homologues et d'infrastructure √† une distance suffisante. L'int√©r√™t pour la s√©curit√© des donn√©es dans de tels r√©seaux augmente, ce qui signifie que cela devrait affecter les logiciels. D'autres technologies radio, notamment Bluetooth et ZigBee, fournissent des communications sans fil point √† point √† courte port√©e. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√©rification du protocole</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les opportunit√©s de r√©seautage √©tant tr√®s demand√©es, de nombreux fournisseurs proposent leurs solutions. Les clients sont confront√©s au d√©fi de v√©rifier la qualit√© des produits disponibles. Contrairement au noyau RTOS, une v√©rification compl√®te des fonctionnalit√©s et des performances de la pile de protocoles n'est pas une t√¢che facile. Heureusement, des bo√Ætes √† outils sont disponibles pour v√©rifier les protocoles (bien qu'√† un prix important), et un acheteur potentiel peut s'informer aupr√®s du fournisseur de l'ensemble qu'il a utilis√© pour v√©rifier. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphisme</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une interface graphique devient de plus en plus courante parmi les appareils embarqu√©s. Il peut s'agir d'un petit √©cran LCD monochromatique tr√®s simple (comme sur les anciens t√©l√©phones, lecteurs MP3, alarmes, etc.). D'un autre c√¥t√©, un r√©cepteur de t√©l√©vision num√©rique peut avoir son propre √©cran HDTV haute r√©solution. Un tel √©cran n√©cessite un support logiciel enti√®rement int√©gr√© au noyau RTOS. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que l'√©cran poss√®de g√©n√©ralement une sorte de p√©riph√©rique d'entr√©e, la prise en charge de ces p√©riph√©riques est souvent incluse dans le package graphique. Un tel package peut prendre en charge des p√©riph√©riques de pointage (par exemple, une souris), des √©crans tactiles, des claviers et des claviers complets.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les graphiques peuvent √™tre utilis√©s de diff√©rentes mani√®res. Il peut simplement fournir des informations (par exemple, comme un tableau de bord √©lectronique). Ou l'affichage peut faire partie d'une interface utilisateur graphique avec des menus, des fen√™tres, des ic√¥nes et des √©l√©ments similaires. Dans tous les cas, un ensemble de logiciels assez sp√©cifique est requis, et le package graphique fourni avec le RTOS devrait fournir la flexibilit√© n√©cessaire sans augmenter de mani√®re significative la quantit√© de m√©moire utilis√©e. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syst√®mes de fichiers</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'une application int√©gr√©e doit stocker et traiter des quantit√©s importantes de donn√©es, il est √©vident qu'il est logique d'organiser ces donn√©es dans une sorte de syst√®me de fichiers. </font><font style="vertical-align: inherit;">Les donn√©es peuvent √™tre dans la RAM, dans la m√©moire flash int√©gr√©e, sur un lecteur flash USB, sur un disque dur ordinaire ou sur un disque optique (CD-ROM ou DVD-ROM). </font><font style="vertical-align: inherit;">Encore une fois, une telle opportunit√© devrait avoir un support logiciel enti√®rement int√©gr√© dans le RTOS. </font><font style="vertical-align: inherit;">Le syst√®me de fichiers doit √™tre soigneusement con√ßu pour r√©pondre aux exigences r√©entrantes d'un syst√®me multit√¢che. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La conformit√© est particuli√®rement importante pour les syst√®mes de fichiers. </font><font style="vertical-align: inherit;">Par exemple, l'utilisation du format de disque compatible MS-DOS permet aux d√©veloppeurs d'utiliser l'architecture bien √©tablie et offre un √©change de donn√©es √† part enti√®re avec les syst√®mes de bureau.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418677/">https://habr.com/ru/post/fr418677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418665/index.html">Adaptation du projet MR pour HoloLens</a></li>
<li><a href="../fr418667/index.html">Analyse comparative de HDFS 3 avec HDFS 2</a></li>
<li><a href="../fr418669/index.html">Security Week 28: NetSpectre, attaque sur des canaux tiers sur le r√©seau</a></li>
<li><a href="../fr418673/index.html">Pourquoi le march√© ERP se d√©veloppe: statistiques et tendances</a></li>
<li><a href="../fr418675/index.html">Comment je suis all√© √† Droidcon Berlin</a></li>
<li><a href="../fr418679/index.html">Nous √©crivons un composant avec des boutons ¬´mat√©riel¬ª pour Svelte</a></li>
<li><a href="../fr418681/index.html">Journ√©e de l'amiti√© - 50% de r√©duction sur tous les IDE JetBrains pour nos amis</a></li>
<li><a href="../fr418683/index.html">Cr√©ation d'une machine d'arcade d'√©mulation. 2e partie</a></li>
<li><a href="../fr418685/index.html">G√©n√©ration de niveau proc√©dural</a></li>
<li><a href="../fr418687/index.html">R√©volution 3,5 ": d√©tails d'un petit boom de disquettes avec vapeurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>