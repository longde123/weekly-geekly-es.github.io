<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👙 👩🏿‍⚖️ 🍧 Toute la vérité sur RTOS. Article # 6. Autres services RTOS 👩🏽‍🔧 👴🏽 🧗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans les articles précédents, nous avons discuté de la fonctionnalité du noyau en termes de tâches effectuées et de l'interaction entre elles. Dans ce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la vérité sur RTOS. Article # 6. Autres services RTOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418677/"><img src="https://habrastorage.org/webt/zw/8-/qc/zw8-qcoua4iac13tid0bo2ivkrw.jpeg"><br><br>  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les articles précédents,</a> nous avons discuté de la fonctionnalité du noyau en termes de tâches effectuées et de l'interaction entre elles.  Dans cet article, nous examinons ce que le noyau peut faire d'autre, ce qui se manifeste largement dans un certain nombre d'autres appels d'API disponibles.  Nous répondrons également à la question: qu'est-ce qui transforme le noyau en système d'exploitation? <br><a name="habracut"></a><br>  Articles précédents de la série: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interaction et synchronisation des tâches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches, changement de contexte et interruptions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches et planification</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps réel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> <br><h2>  Gestion des tâches </h2><br>  En plus de la planification des tâches et de l'interaction entre eux, le RTOS comprendra des fonctionnalités (appels API) pour gérer les tâches de différentes manières.  Examinons quelques possibilités. <br><br>  <b>Créer et supprimer des tâches</b> <br><br>  Dans le RTOS "dynamique", il existe des appels de fonction qui vous permettent de créer des tâches (et d'autres objets RTOS) quand elles sont nécessaires.  Ces appels incluent un large éventail de paramètres qui définissent la tâche, par exemple, le point d'entrée, la taille de la pile et la priorité.  L'appel d'API de suppression de tâche correspondant vous permet de libérer des ressources une fois la tâche terminée. <br><br>  Dans le RTOS "statique", les paramètres de définition de la tâche sont configurés dans une sorte de fichier de configuration lors de l'assemblage. <br><br>  <b>Mettre en pause et reprendre une tâche</b> <br><br>  Comme nous l'avons vu, la plupart des RTOS ont le concept d'un état de tâches «suspendu».  Cela peut être réalisé de différentes manières.  L'un d'eux est un appel explicite à la fonction API Suspend Task.  Il peut être causé par lui-même ou par une autre tâche.  L'appel «Reprendre la tâche» correspondant permet à la tâche de faire à nouveau la queue pour la planification. <br><br>  <b>État de veille des tâches</b> <br><br>  Pour un système en temps réel, le contrôle du temps est une exigence importante et peut prendre diverses formes.  Une vue simple est la capacité de la tâche à "s'endormir", c'est-à-dire que la tâche est suspendue pendant un certain temps.  Lorsque le temps est écoulé, la tâche se "réveille" et est à nouveau mise en file d'attente pour la planification.  Un appel API sera généralement disponible à cet effet.  Bien entendu, cette fonctionnalité dépend de la disponibilité de la minuterie. <br><br>  <b>Exemption</b> <br><br>  Lors de l'utilisation de l'ordonnanceur Round Robin ("carrousel"), une tâche peut refuser de contrôler le processeur pour la prochaine tâche de la chaîne.  Pour ce faire, la fonction API «Release task» sera disponible.  La tâche n'est pas suspendue, elle sera disponible pour la planification à son tour.  Lors de l'utilisation du planificateur de tranche de temps, il est possible qu'une tâche puisse libérer une partie de son intervalle de temps si elle n'a pas de travail important à faire immédiatement.  La libération d'une tâche n'a aucune signification logique lors de l'exécution des planificateurs Exécuter jusqu'à la fin ou Priorité. <br><br>  <b>Achèvement de la tâche</b> <br><br>  Dans un article précédent, nous avons constaté qu'en plus des états «Prêt» ou «Suspendu», le RTOS peut prendre en charge d'autres états de tâche.  La tâche peut être «terminée», ce qui signifie que sa fonction principale vient de quitter: aucun appel API spécial n'est requis.  Une tâche peut être «Terminée», ce qui signifie qu'elle n'est pas disponible pour la planification et doit être réinitialisée pour redevenir disponible pour le lancement, voir «Réinitialisation d'une tâche» ci-dessous.  Cela nécessite un appel API spécial.  La disponibilité de ces états de tâche supplémentaires, la terminologie utilisée et leurs définitions exactes varient en fonction du RTOS. <br><br>  <b>Réinitialisation de la tâche</b> <br><br>  De nombreux RTOS proposent un appel à la fonction API «Reset Task», qui vous permet de ramener la tâche à son état d'origine.  Elle peut être suspendue et exiger l'exécution de la fonction «Reprendre la tâche» afin de faire la queue pour la planification. <br><br>  <b>Tâches prioritaires, etc.</b> <br><br>  Dans un RTOS «dynamique», des appels d'API peuvent être disponibles pour configurer plusieurs paramètres de tâche au moment de l'exécution.  Les exemples incluent la priorité et la durée de l'intervalle de temps. <br><br><h2>  Informations système </h2><br>  Dans RTOS, il y aura un certain nombre d'appels d'API pour fournir au système des informations sur la tâche, notamment: <br>  <b>Informations sur les tâches</b> .  Combien de tâches se trouvent dans le système, leur configuration et leur état actuel. <br>  <b>Informations sur d'autres objets du noyau.</b>  Le nombre d'objets de chaque type dans le système, leur configuration et les informations sur l'état actuel.  Par exemple: <br><br><ul><li>  Quelle est la capacité actuelle de la file d'attente? Puis-je ajouter d'autres messages? </li><li>  combien de tâches sont suspendues sur une boîte aux lettres particulière? </li></ul>  <b>Informations sur la version RTOS</b> .  Un appel API peut fournir des données similaires. <br><br><h2>  Allocation de mémoire </h2><br>  Dans de nombreuses applications, il est important que le programme puisse capturer dynamiquement de la mémoire lorsqu'elle est nécessaire et la libérer lorsqu'elle n'est plus nécessaire.  La même chose se produit dans le firmware.  Cependant, les approches conventionnelles sont sujettes à des problèmes qui sont peu probables ou incommodes dans les applications de bureau, mais elles peuvent être désastreuses pour un système embarqué.  Néanmoins, il existe des moyens de mettre en œuvre de tels services, même dans un RTOS statique. <br><br><h2>  Problèmes avec les fonctions malloc () et free () </h2><br>  Dans un programme C de bureau, une fonction peut appeler <b>malloc ()</b> , indiquant la quantité de mémoire requise, et récupérer un pointeur vers la zone de stockage.  En utilisant la mémoire, elle peut être libérée en appelant <b>free ()</b> .  La mémoire est allouée à partir d'une zone appelée tas.  Le problème avec cette approche est qu'avec une séquence non coordonnée d'appels à ces fonctions, la zone de tas peut facilement devenir fragmentée, puis l'allocation de mémoire échouera même si suffisamment de mémoire est disponible, car  les zones adjacentes ne sont pas assez grandes.  Certains systèmes (tels que Java et Visual Basic) utilisent des schémas sophistiqués de «garbage collection» pour défragmenter.  Le problème est que ces schémas peuvent entraîner des retards imprévisibles importants dans l'exécution et la nécessité d'utiliser des pointeurs indirects (qui ne fonctionne pas en C). <br><br>  Si <b>malloc ()</b> et <b>free ()</b> étaient implémentés de manière réentrante (généralement pas) et utilisés par les tâches RTOS, la fragmentation se produira très rapidement et une défaillance du système sera presque inévitable.  En C ++, il existe de <b>nouveaux</b> opérateurs de <b>suppression</b> qui exécutent généralement les mêmes fonctions que malloc () et free ().  Ils sont soumis aux mêmes limitations et problèmes. <br><br><h2>  Sections de mémoire </h2><br>  Pour fournir un système en temps réel avec une mémoire accessible dynamiquement, une approche par blocs de la gestion de la mémoire peut être utilisée.  Ces blocs sont communément appelés "partitions";  les partitions peuvent être allouées à partir du "pool de partitions". <br><br>  Le pool de partitions contient un certain nombre de blocs, chacun ayant la même taille.  Le nombre et la taille des blocs d'une partition sont déterminés lors de la création du pool de partitions.  Cela peut être dynamique si le système lui-même le permet, ou statiquement pendant l'assemblage.  En règle générale, une application peut inclure plusieurs pools de partitions offrant des blocs de tailles différentes. <br><br>  Si une tâche a besoin de mémoire, elle appelle une API qui demande un bloc à partir d'un pool spécifique.  Si cet appel réussit, la tâche recevra un pointeur vers le bloc sélectionné.  Si l'appel échoue parce que  il n'y a pas de partitions disponibles dans le pool indiqué, la tâche peut recevoir une réponse d'erreur.  Alternativement, la tâche peut être bloquée (suspendue) jusqu'à ce qu'une autre tâche libère le blocage dans la section. <br><br>  En règle générale, une tâche passe simplement un pointeur vers un bloc de mémoire dans n'importe quel code qui utilise le bloc.  Cela conduit à un problème lorsque le bloc n'est plus nécessaire.  Si le code n'a qu'un pointeur sur un bloc, comment peut-il indiquer au RTOS via un appel d'API, à partir de quel pool de partitions veut-il libérer de la mémoire?  La réponse est que la plupart des RTOS prennent en charge des données supplémentaires dans un bloc dédié (généralement un décalage négatif par rapport au pointeur) qui fournissent les informations requises.  Ainsi, pour appeler l'API pour libérer un bloc, seule son adresse est requise. <br><br>  L'article suivant contiendra plus d'informations sur les partitions de mémoire. <br><br><h2>  Le temps </h2><br>  Les fonctionnalités associées à l'utilisation et au contrôle du temps sont susceptibles d'être disponibles dans le système d'exploitation en temps réel.  Les opportunités varieront en fonction du RTOS, mais nous considérerons celles disponibles publiquement.  Dans tous les cas, le temporisateur en temps réel est un élément indispensable au fonctionnement de l'un de ces services. <br><br>  <b>Heure système</b> <br><br>  L'heure système simple, ou "horloge", est presque toujours disponible.  Il s'agit simplement d'un compteur (généralement 32 bits), qui est incrémenté à l'aide de la routine de service d'interruption en temps réel et peut être défini et lu via des appels d'API. <br><br>  <b>Délais d'attente des appels de service</b> <br><br>  En règle générale, un RTOS permet de bloquer les appels d'API, c'est-à-dire que la tâche d'appel est suspendue (bloquée) jusqu'à ce que le service demandé soit fourni.  Habituellement, ce verrou est vague, mais certains RTOS offrent un délai pendant lequel l'appel revient à l'expiration du délai si le service continue d'être indisponible.  Les délais d'expiration des appels API ne sont pas pris en charge par tous les RTOS. <br><br>  <b>État de veille des tâches</b> <br><br>  En règle générale, les tâches ont la possibilité de s'interrompre pendant une période de temps fixe.  Cela a été discuté précédemment dans la section Gestion des tâches. <br><br>  <b>Minuteries logicielles</b> <br><br>  Pour que les tâches du programme exécutent des fonctions de comptage du temps, la plupart des RTOS proposent des objets de temporisation.  Ce sont des temporisateurs indépendants mis à jour par le gestionnaire d'interruption de temporisateur en temps réel, qui peuvent être contrôlés par des appels d'API.  Ces appels configurent, contrôlent et contrôlent le fonctionnement du temporisateur.  En règle générale, ils peuvent être définis pour un seul actionnement ou redémarrage automatique.  Une routine d'expiration est également généralement prise en charge, une fonction qui s'exécute chaque fois qu'une minuterie termine un cycle.  Le prochain article fournira plus d'informations sur les temporisateurs logiciels et une description de leur implémentation. <br><br><h2>  Interruptions, pilotes et E / S </h2><br>  La mesure dans laquelle les RTOS sont associés aux interruptions et aux E / S est très différente.  De même, certains RTOS ont une structure très claire pour les pilotes de périphériques, ce qui peut ajouter des problèmes lors du choix d'un produit spécifique. <br><br>  <b>Interruptions</b> <br><br>  Les interruptions présentent un problème pour RTOS pour deux raisons. <br><br><ul><li>  Sans aucune précaution, le gestionnaire d'interruption (ISR) «volera» le temps processeur, perturbant ainsi le comportement RTOS en temps réel. </li><li>  Si l'ISR effectue des appels d'API qui affectent la planification des tâches, cela doit être surveillé et le RTOS doit pouvoir exécuter son algorithme de planification. </li></ul>  Un exemple d'un tel appel API est la procédure pour réveiller une tâche avec une priorité plus élevée que celle qui a été lancée lorsque l'interruption s'est produite. <br><br>  Certains RTOS contrôlent entièrement toutes les interruptions.  Une série d'appels API sont disponibles pour "enregistrer" les programmes ISR.  Cette approche permet au planificateur de déterminer quand les interruptions sont activées et facilite l'utilisation de la plupart des appels d'API à partir de l'ISR. <br><br>  Par exemple, Nucleus RTOS implémente le concept de gestionnaires d'interruptions «basse priorité» et «haute priorité», qui fournit une gestion fiable des interruptions sans surcharge inutile (c'est-à-dire une augmentation du délai d'interruption). <br><br>  D'autres RTOS peuvent utiliser le mode automatique «sans intervention» pour les interruptions, ce qui offre aux développeurs plus d'options pour s'assurer que les gestionnaires d'interruption fonctionnent correctement.  En règle générale, un préfixe ISR supplémentaire (prologue) et un suffixe (épilogue) sont fournis pour protéger les appels d'API qui y sont effectués. <br>  Nucleus SE utilise une routine d'interruption légère, qui sera décrite dans un futur article. <br><br>  <b>Pilotes</b> <br><br>  La plupart des RTOS déterminent la structure du pilote de périphérique.  Les détails peuvent varier en fonction du RTOS, mais le pilote se compose généralement de deux composants en interaction: le code intégré (appels API) et ISR.  En règle générale, d'autres appels API seront disponibles pour gérer et enregistrer les pilotes. <br><br>  <b>Entrée / sortie</b> <br><br>  Actuellement, la plupart des RTOS sur le marché ne se soucient pas des entrées / sorties de niveau supérieur, mais certains d'entre eux définissent un flux d'entrée / sortie, qui établit essentiellement une connexion entre les pilotes de périphérique correspondants et les fonctions du langage C standard, telles que printf (). <br>  Historiquement, le RTOS supportait souvent la «console», l'interface utilisateur du RTOS via un canal série.  Cela a été principalement utilisé pour les diagnostics et le débogage.  L'utilisation de débogueurs modernes qui prennent en charge le débogage d'applications avec RTOS élimine le besoin de tels objets. <br><br><h2>  Diagnostics </h2><br>  En règle générale, RTOS nécessite des performances maximales avec un encombrement mémoire minimal.  Par conséquent, la vérification d'intégrité n'est pas une priorité élevée.  Avec l'aide de technologies de débogage modernes qui prennent en compte les fonctionnalités du RTOS, la plupart des contrôles peuvent être effectués en dehors du RTOS lui-même. <br><br><h2>  Vérification des paramètres d'appel d'API </h2><br>  Les appels d'API peuvent avoir de nombreux paramètres complexes.  Cela peut provoquer des erreurs.  De nombreux RTOS fournissent une vérification des paramètres d'exécution avec le retour d'un code d'erreur en cas de paramètre incorrect.  Étant donné que cela nécessite du code supplémentaire et que les vérifications elles-mêmes affectent négativement les performances, il est préférable de vérifier les paramètres lors de l'assemblage ou de la configuration. <br><br><h2>  Vérification de la pile </h2><br>  Pour la plupart des types de planificateurs (sauf Run to Completion), chaque tâche a sa propre pile, dont la taille est déterminée individuellement.  Dans certains RTOS, le noyau a une pile distincte, dans d'autres, la pile de tâches est «empruntée» lors d'un appel d'API.  De toute évidence, l'intégrité de la pile est importante pour la fiabilité globale du système.  Par conséquent, les RTOS offrent souvent des outils pour vérifier l'intégrité de la pile au moment de l'exécution.  Il existe plusieurs options: <br><br><ul><li>  Un appel d'API qui renvoie la quantité d'espace de pile pour la tâche actuelle ou spécifiée. </li><li>  Les paramètres de délimitation de la pile.  On leur attribue une valeur unique (généralement impaire et non nulle), qui est périodiquement vérifiée pour la réécriture. </li></ul><br><br><h2>  Diagnostic d'application </h2><br>  Malgré le fait que cette fonction n'est pas directement prise en charge dans le RTOS, une tâche d'application peut être allouée pour vérifier l'intégrité de l'ensemble du système.  Une telle tâche peut être responsable de la réinitialisation du temporisateur de surveillance.  Une tâche peut recevoir des données d'entrée périodiques (par exemple, des paramètres de signal) de chaque tâche critique.  La réinitialisation de la minuterie du chien de garde (qui empêchera le redémarrage du système) ne sera effectuée qu'après l'arrivée des données de toutes les tâches. <br><br><h2>  Services non noyaux </h2><br>  Le RTOS est plus que le noyau sur lequel nous nous sommes concentrés jusqu'à présent.  Ce système d'exploitation de bureau est considérablement différent du RTOS intégré.  En règle générale, dans un système d'exploitation de bureau, tous les composants supplémentaires sont regroupés ou peuvent être installés (tous les PC de bureau ont une interface utilisateur graphique et seuls quelques-uns d'entre eux n'ont pas accès au réseau).  Le PC de bureau n'a pas de réelles limites de ressources: il y a toujours de la mémoire libre, de l'espace disque dur et des ressources CPU inutilisées.  Dans un monde de systèmes embarqués avec des ressources limitées, des composants supplémentaires tels que des cartes vidéo, des composants réseau et des systèmes de fichiers peuvent être nécessaires, mais ils doivent être déconnectables et évolutifs pour minimiser l'empreinte mémoire. <br><br>  <b>Fonctionnalités de mise en réseau</b> <br><br>  La plupart des systèmes embarqués sont en quelque sorte liés aux réseaux.  Ainsi, il est prévu qu'il existe un intérêt important pour les solutions de mise en réseau pour les systèmes embarqués, en raison de laquelle il existe un grand nombre de produits sur le marché. <br><br>  <b>TCP / IP</b> est un protocole standard qui est largement utilisé et est le choix évident pour de nombreuses applications.  En règle générale, TCP / IP est utilisé pour le protocole Ethernet (IEEE802.3), qui fournit une vitesse moyenne de 10 Mb / s.  Aujourd'hui, 100 Mb / s sont assez courants, et à l'approche 1 Gb / s.  De plus, TCP / IP peut être utilisé pour d'autres protocoles.  Par exemple, PPP (Point-to-Point Protocol) est une implémentation TCP / IP pour le transfert de données série qui a été adaptée pour les connexions Internet à large bande. <br><br>  Jusqu'à récemment, la version v4 du protocole IP (IPv4) était utilisée.  Cependant, il devient obsolète à mesure que les adresses libres s'épuisent.  La solution est IPv6, augmentant considérablement le nombre d'adresses possibles et fournissant des outils plus efficaces pour la maintenance et la sécurité.  IPv6 est largement disponible et utilisé dans les équipements de nombreux pays, ainsi que dans les systèmes militaires du monde entier. <br>  Une alternative est le protocole UDP (User Datagram Protocol).  Ce protocole est utilisé pour des performances maximales.  UDP n'offre pas la même fiabilité et cohérence que TCP, mais il est léger et très efficace. <br><br>  <b>L'USB</b> est le bus série universel, largement utilisé dans les appareils pour la connexion aux ordinateurs de bureau.  Il fournit une interface plug-and-play très facile à utiliser qui cache des logiciels assez sophistiqués.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un périphérique intégré qui doit être connecté à un PC doit être implémenté en tant que fonction USB, ce qui nécessite un ensemble spécifique de composants logiciels. Si l'appareil doit gérer d'autres appareils connectés via USB (comme un PC ordinaire), il a besoin d'un ensemble de logiciels de type hôte. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IEEE1394</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une autre norme d'interface série utilisée pour transférer rapidement de grandes quantités de données entre les appareils (par exemple, pour la transmission de données vidéo), également connue sous le nom de FireWire et i.Link.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocoles sans fil - la commodité et la prévalence de diverses technologies sans fil chez les consommateurs ont entraîné une forte demande de capacités sans fil dans les appareils intégrés. Le Wi-Fi (ensemble de normes IEEE802.11) fournit un ensemble complet de capacités réseau, vous permettant de mettre en œuvre des topologies homologues et d'infrastructure à une distance suffisante. L'intérêt pour la sécurité des données dans de tels réseaux augmente, ce qui signifie que cela devrait affecter les logiciels. D'autres technologies radio, notamment Bluetooth et ZigBee, fournissent des communications sans fil point à point à courte portée. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vérification du protocole</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les opportunités de réseautage étant très demandées, de nombreux fournisseurs proposent leurs solutions. Les clients sont confrontés au défi de vérifier la qualité des produits disponibles. Contrairement au noyau RTOS, une vérification complète des fonctionnalités et des performances de la pile de protocoles n'est pas une tâche facile. Heureusement, des boîtes à outils sont disponibles pour vérifier les protocoles (bien qu'à un prix important), et un acheteur potentiel peut s'informer auprès du fournisseur de l'ensemble qu'il a utilisé pour vérifier. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphisme</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une interface graphique devient de plus en plus courante parmi les appareils embarqués. Il peut s'agir d'un petit écran LCD monochromatique très simple (comme sur les anciens téléphones, lecteurs MP3, alarmes, etc.). D'un autre côté, un récepteur de télévision numérique peut avoir son propre écran HDTV haute résolution. Un tel écran nécessite un support logiciel entièrement intégré au noyau RTOS. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que l'écran possède généralement une sorte de périphérique d'entrée, la prise en charge de ces périphériques est souvent incluse dans le package graphique. Un tel package peut prendre en charge des périphériques de pointage (par exemple, une souris), des écrans tactiles, des claviers et des claviers complets.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les graphiques peuvent être utilisés de différentes manières. Il peut simplement fournir des informations (par exemple, comme un tableau de bord électronique). Ou l'affichage peut faire partie d'une interface utilisateur graphique avec des menus, des fenêtres, des icônes et des éléments similaires. Dans tous les cas, un ensemble de logiciels assez spécifique est requis, et le package graphique fourni avec le RTOS devrait fournir la flexibilité nécessaire sans augmenter de manière significative la quantité de mémoire utilisée. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systèmes de fichiers</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'une application intégrée doit stocker et traiter des quantités importantes de données, il est évident qu'il est logique d'organiser ces données dans une sorte de système de fichiers. </font><font style="vertical-align: inherit;">Les données peuvent être dans la RAM, dans la mémoire flash intégrée, sur un lecteur flash USB, sur un disque dur ordinaire ou sur un disque optique (CD-ROM ou DVD-ROM). </font><font style="vertical-align: inherit;">Encore une fois, une telle opportunité devrait avoir un support logiciel entièrement intégré dans le RTOS. </font><font style="vertical-align: inherit;">Le système de fichiers doit être soigneusement conçu pour répondre aux exigences réentrantes d'un système multitâche. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La conformité est particulièrement importante pour les systèmes de fichiers. </font><font style="vertical-align: inherit;">Par exemple, l'utilisation du format de disque compatible MS-DOS permet aux développeurs d'utiliser l'architecture bien établie et offre un échange de données à part entière avec les systèmes de bureau.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418677/">https://habr.com/ru/post/fr418677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418665/index.html">Adaptation du projet MR pour HoloLens</a></li>
<li><a href="../fr418667/index.html">Analyse comparative de HDFS 3 avec HDFS 2</a></li>
<li><a href="../fr418669/index.html">Security Week 28: NetSpectre, attaque sur des canaux tiers sur le réseau</a></li>
<li><a href="../fr418673/index.html">Pourquoi le marché ERP se développe: statistiques et tendances</a></li>
<li><a href="../fr418675/index.html">Comment je suis allé à Droidcon Berlin</a></li>
<li><a href="../fr418679/index.html">Nous écrivons un composant avec des boutons «matériel» pour Svelte</a></li>
<li><a href="../fr418681/index.html">Journée de l'amitié - 50% de réduction sur tous les IDE JetBrains pour nos amis</a></li>
<li><a href="../fr418683/index.html">Création d'une machine d'arcade d'émulation. 2e partie</a></li>
<li><a href="../fr418685/index.html">Génération de niveau procédural</a></li>
<li><a href="../fr418687/index.html">Révolution 3,5 ": détails d'un petit boom de disquettes avec vapeurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>