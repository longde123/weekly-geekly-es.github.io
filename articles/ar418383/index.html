<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌊 👦 🌛 الرسوم المتحركة الروبوت على أساس Kotlin و RxJava 🆑 🕴🏾 🕷️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مرحبا يا هبر! في العام الماضي ، تحدث Ivan Škori PS من PSPDFKit في MBLT DEV بتقرير حول إنشاء رسوم متحركة في Android استنادًا إلى Kotlin ومكتبة RxJava. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>الرسوم المتحركة الروبوت على أساس Kotlin و RxJava</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/418383/" style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><img src="https://habrastorage.org/webt/2g/5z/pi/2g5zpitzszs5lxzgdighjoo14u4.png"></a> <br><br>  مرحبا يا هبر!  في العام الماضي ، تحدث Ivan Škori PS من PSPDFKit في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">MBLT DEV</a> بتقرير حول إنشاء رسوم متحركة في Android استنادًا إلى Kotlin ومكتبة RxJava. <br><br>  أستخدم الآن تقنيات التقرير في العمل على مشروعي ، فهي تساعد كثيرًا.  تحت النص هو نص التقرير والفيديو ، يمكنك الآن الاستفادة من هذه الحيل. <a name="habracut"></a><br><br><h2 style=";text-align:right;direction:rtl">  الرسوم المتحركة </h2><br>  في Android ، هناك 4 فئات تنطبق كما لو بشكل افتراضي: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <b>ValueAnimator</b> - توفر هذه الفئة آلية مزامنة بسيطة لتشغيل الرسوم المتحركة التي تحسب القيم المتحركة <b>وتضبطها للعرض</b> . </li><li style=";text-align:right;direction:rtl">  <b>ObjectAnimator</b> هي فئة فرعية من ValueAnimator تسمح لك بدعم الرسوم المتحركة لخصائص الكائن. </li><li style=";text-align:right;direction:rtl">  يتم استخدام <b>AnimatorSet</b> لإنشاء تسلسل للرسوم المتحركة.  على سبيل المثال ، لديك سلسلة من الرسوم المتحركة: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  عرض الأوراق على يسار الشاشة. </li><li style=";text-align:right;direction:rtl">  بعد إكمال الرسم المتحرك الأول ، نريد تنفيذ رسم متحرك لمظهر آخر ، وما إلى ذلك. </li></ol></li><li style=";text-align:right;direction:rtl">  <b>ViewPropertyAnimator</b> - يتم تشغيل الرسوم المتحركة وتحسينها تلقائيًا لخاصية العرض المحددة.  سنستخدمها بشكل رئيسي.  لذلك ، سنستخدم واجهة برمجة التطبيقات هذه ثم نضعها في RxJava كجزء من البرمجة التفاعلية. </li></ol><br><cut></cut><br><h3 style=";text-align:right;direction:rtl">  ValueAnimator </h3><br>  دعونا <b>نحلل</b> إطار <b>ValueAnimator</b> .  يتم استخدامه لتغيير القيمة.  يمكنك تحديد نطاق من القيم من خلال <b>ValueAnimator.ofFloat</b> لنوع العوامة البدائي من 0 إلى 100. حدد قيمة <b>Duration</b> وابدأ الرسم المتحرك. <br>  فكر في مثال: <br><br><pre style=";text-align:right;direction:rtl"><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animator = ValueAnimator.ofFloat(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">100f</span></span>) animator.duration = <span class="hljs-number"><span class="hljs-number">1000</span></span> animator.start() animator.addUpdateListener(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ValueAnimator.AnimatorUpdateListener { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ValueAnimator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animatedValue = animation.animatedValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> textView.translationX = animatedValue } })</code> </pre> <br>  نضيف هنا <b>UpdateListener</b> ومع كل تحديث <b>سننقل</b> عرضنا أفقيًا ونغير موضعه من 0 إلى 100 ، على الرغم من أن هذه ليست طريقة جيدة جدًا لإجراء هذه العملية. <br><br><h3 style=";text-align:right;direction:rtl">  ObjectAnimator </h3><br>  مثال آخر لتطبيق الرسوم المتحركة هو ObjectAnimator: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">val objectAnimator = ObjectAnimator.ofFloat(textView, "translationX", <span class="hljs-number"><span class="hljs-number">100</span></span>f) objectAnimator.duration = <span class="hljs-number"><span class="hljs-number">1000</span></span> objectAnimator.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>()</code> </pre> <br>  نعطيه أمرًا لتغيير معلمة العرض المحددة إلى القيمة المحددة إلى طريقة العرض المطلوبة وتعيين الوقت باستخدام طريقة <b>setDuration</b> .  خلاصة القول هي أنه يجب أن يكون <b>لفصلك</b> طريقة <b>setTranslationX</b> ، ثم سيجد النظام هذه الطريقة من خلال الانعكاس ، وبعد ذلك سيتم عرض طريقة العرض المتحركة.  المشكلة هي أن التفكير يستخدم هنا. <br><br><h3 style=";text-align:right;direction:rtl">  مجموعة الرسوم المتحركة </h3><br>  الآن فكر في فئة <b>AnimatorSet</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">val bouncer = AnimatorSet() bouncer.play(bounceAnim).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(squashAnim1) bouncer.play(squashAnim1).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(squashAnim2) val fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", <span class="hljs-number"><span class="hljs-number">1</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>f) fadeAnim.duration = <span class="hljs-number"><span class="hljs-number">250</span></span> val animatorSet = AnimatorSet() animatorSet.play(bouncer).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(fadeAnim) animatorSet.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>()</code> </pre> <br>  في الواقع ، إنه ليس مناسبًا للاستخدام ، خاصةً لعدد كبير من الأشياء.  إذا كنت ترغب في إنشاء رسوم متحركة أكثر تعقيدًا - على سبيل المثال ، قم بتعيين تأخير بين مظهر الرسوم المتحركة ، والمزيد من الرسوم المتحركة التي تريد تنفيذها ، كلما كان من الصعب التحكم فيها. <br><br><h3 style=";text-align:right;direction:rtl">  ViewPropertyAnimator </h3><br>  الفئة الأخيرة هي <b>ViewPropertyAnimator</b> .  إنها واحدة من أفضل الفئات لعرض الرسوم المتحركة.  هذه واجهة برمجة تطبيقات رائعة لتقديم سلسلة من الرسوم المتحركة التي تقوم بتشغيلها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs kotlin">ViewCompat.animate(textView) .translationX(<span class="hljs-number"><span class="hljs-number">50f</span></span>) .translationY(<span class="hljs-number"><span class="hljs-number">100f</span></span>) .setDuration(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .setInterpolator(AccelerateDecelerateInterpolator()) .setStartDelay(<span class="hljs-number"><span class="hljs-number">50</span></span>) .setListener(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Animator.AnimatorListener { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationRepeat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationCancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} })</code> </pre><br>  نبدأ طريقة <b>ViewCompat.animate</b> ، التي تُرجع <b>ViewPropertyAnimator</b> ، <b>ولترجمة</b> الرسوم المتحركة <b>X</b> ، <b>نقوم</b> بتعيين القيمة 50 للمعلمة <b>translatonY</b> - 100. ثم نحدد مدة الرسم المتحرك ، بالإضافة إلى interpolator.  يحدد interpolator التسلسل الذي تظهر فيه الرسوم المتحركة.  يستخدم هذا المثال مُحَقِّق يعمل على تسريع بداية الرسم المتحرك ويضيف تباطؤًا في النهاية.  نضيف أيضًا تأخيرًا لبدء الرسوم المتحركة.  بالإضافة إلى ذلك ، لدينا <b>AnimatorListener</b> .  باستخدامه ، يمكنك الاشتراك في أحداث معينة تحدث أثناء الرسوم المتحركة.  تحتوي هذه الواجهة على 4 طرق: <b>onAnimationStart</b> ، <b>onAnimationCancel</b> ، <b>onAnimationEnd</b> ، <b>onAnimationRepeat</b> . <br><br>  كقاعدة ، نحن مهتمون فقط بإكمال الرسوم المتحركة.  في مستوى API 16 <br>  أضيفت معإنداكشن: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">.withEndAction({ //API <span class="hljs-number"><span class="hljs-number">16</span></span>+ //<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something here <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> animation ends })</code> </pre> <br>  في ذلك ، يمكنك تحديد واجهة <b>Runnable</b> ، وبعد الانتهاء من عرض رسوم متحركة معينة ، يتم تنفيذ إجراء. <br><br>  الآن بعض التعليقات حول عملية إنشاء الرسوم المتحركة بشكل عام: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  طريقة <b>start ()</b> اختيارية: بمجرد استدعاء طريقة <b>animate ()</b> ، يتم تقديم سلسلة من الرسوم المتحركة.  عندما يتم تكوين <b>ViewPropertyAnimator</b> ، سيبدأ النظام الرسوم المتحركة بمجرد أن يصبح جاهزًا للقيام بذلك. </li><li style=";text-align:right;direction:rtl">  يمكن لفئة <b>ViewPropertyAnimator</b> واحدة فقط تحريك طريقة عرض معينة فقط.  لذلك ، إذا كنت ترغب في تنفيذ العديد من الرسوم المتحركة ، على سبيل المثال ، تريد نقل شيء ما ، وفي نفس الوقت زيادة الحجم ، فأنت بحاجة إلى تحديد ذلك في أحد الرسوم المتحركة. </li></ol><br><h3 style=";text-align:right;direction:rtl">  لماذا اخترنا RxJava؟ </h3><br>  لنبدأ بمثال بسيط.  لنفترض أننا أنشأنا طريقة fadeIn: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animationSubject = CompletableSubject.create() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> animationSubject.doOnSubscribe { ViewCompat.animate(view) .setDuration(duration) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .withEndAction { animationSubject.onComplete() } } }</code> </pre> <br>  هذا حل بدائي إلى حد ما ، ومن أجل تطبيقه على مشروعك ، ستحتاج إلى مراعاة بعض الفروق الدقيقة. <br><br>  سنقوم بإنشاء مشروع <b>CompletableSubject</b> ، والذي <b>سنستخدمه</b> لانتظار اكتمال الرسوم المتحركة ، ثم استخدام طريقة <b>onComplete</b> لإرسال رسائل إلى المشتركين.  لتشغيل الرسوم المتحركة بالتسلسل ، تحتاج إلى بدء الرسوم المتحركة ليس على الفور ، ولكن بمجرد اشتراك شخص ما فيها.  بهذه الطريقة ، يمكن تشغيل العديد من الرسوم المتحركة ذات النمط التفاعلي بالتسلسل. <br><br>  خذ بعين الاعتبار الرسوم المتحركة نفسها.  ننقل فيه العرض ، الذي سيتم تنفيذ الرسوم المتحركة عليه ، ونشير أيضًا إلى مدة الرسوم المتحركة.  وبما أن هذه الرسوم المتحركة هي مظهر ، يجب أن نشير إلى الشفافية 1. <br><br>  دعونا نحاول استخدام أسلوبنا وإنشاء رسوم متحركة بسيطة.  لنفترض أن لدينا 4 أزرار على الشاشة ، ونريد أن نضيف لهم صورة متحركة لمظهر مدته ثانية واحدة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs go">val durationMs = <span class="hljs-number"><span class="hljs-number">1000</span></span>L button1.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button2.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button3.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button4.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> fadeIn(button1, durationMs) .andThen(fadeIn(button2, durationMs)) .andThen(fadeIn(button3, durationMs)) .andThen(fadeIn(button4, durationMs)) .subscribe()</code> </pre><br>  والنتيجة هي مثل هذا الرمز المختصر.  باستخدام عامل التشغيل <b>andThen</b> ، <b>يمكنك</b> تشغيل الرسوم المتحركة بالتتابع.  عندما نشترك فيه ، سيرسل حدث <b>doOnSubscribe</b> إلى <b>Completable</b> ، وهو الأول في قائمة انتظار التنفيذ.  بعد اكتماله ، سيشترك في السلسلة الثانية والثالثة وهكذا في السلسلة.  لذلك ، إذا حدث خطأ في مرحلة ما ، فإن التسلسل بأكمله يطرح خطأ.  يجب أيضًا تحديد alpha 0 قبل بدء الرسم المتحرك بحيث تكون الأزرار غير مرئية.  هكذا ستبدو: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/sq/-m/02/sq-m02uv2i1uu85udver9fwzqww.gif"></div><br>  باستخدام <b>Kotlin</b> ، يمكننا استخدام الامتدادات: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animationSubject = CompletableSubject.create() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> animationSubject.doOnSubscribe { ViewCompat.animate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setDuration(duration) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .withEndAction { animationSubject.onComplete() } } }</code> </pre> <br>  بالنسبة لفئة العرض ، تمت إضافة وظيفة ملحق.  في المستقبل ، ليست هناك حاجة لتمرير الوسيطة عرض إلى أسلوب fadeIn.  الآن يمكنك استبدال جميع المكالمات للعرض بهذه الكلمة الرئيسية داخل الطريقة.  هذا ما يستطيع <b>كوتلن</b> القيام به <b>.</b> <br><br>  دعونا نرى كيف تغيرت الدعوة لهذه الوظيفة في سلسلة الرسوم المتحركة لدينا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre><br>  الآن يبدو الرمز أكثر قابلية للفهم.  تنص بوضوح على أننا نريد تطبيق الرسوم المتحركة بمدة معينة على الشاشة المطلوبة.  باستخدام عامل التشغيل <b>andThen</b> ، <b>نقوم</b> بإنشاء سلسلة متتابعة من الرسوم المتحركة للزر الثاني والثالث وما إلى ذلك. <br><br>  نشير دائمًا إلى مدة الرسوم المتحركة ، وهذه القيمة هي نفسها لجميع الشاشات - 1000 مللي ثانية.  يأتي <b>Kotlin</b> إلى الإنقاذ مرة أخرى.  يمكننا أن نجعل قيمة الوقت الافتراضية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">L)</span></span></span></span>:</code> </pre> <br>  إذا لم تحدد معلمة <b>المدة</b> ، فسيتم ضبط الوقت تلقائيًا على ثانية واحدة.  ولكن إذا أردنا أن يزيد الزر الموجود في الرقم 2 هذه المرة إلى ثانيتين ، فإننا ببساطة نحدد هذه القيمة في الطريقة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs erlang">button1.fadeIn() .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button2.fadeIn(duration = <span class="hljs-number"><span class="hljs-number">2000</span></span>L)) .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button3.fadeIn()) .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button4.fadeIn()) .subscribe()</code> </pre><br><h3 style=";text-align:right;direction:rtl">  تشغيل اثنين من الرسوم المتحركة </h3><br>  تمكنا من تشغيل سلسلة من الرسوم المتحركة باستخدام عامل التشغيل ثم.  ماذا لو كنت بحاجة إلى تشغيل رسمين متحركين في نفس الوقت؟  للقيام بذلك ، هناك عامل <b>MergeWith</b> في <b>RxJava</b> يسمح لك بدمج العناصر <b>الكاملة</b> بطريقة يتم إطلاقها في وقت واحد.  يبدأ هذا البيان جميع العناصر وينتهي بعد عرض العنصر الأخير.  إذا <b>تغيرنا وبعد ذلك للدمج</b> مع ، نحصل على رسم متحرك تظهر فيه جميع الأزرار في نفس الوقت ، لكن الزر 2 سيظهر لفترة أطول قليلاً من الأزرار الأخرى: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(2000)) <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/jd/fw/xb/jdfwxbgedu3gnufrsrfqezc46ga.gif"></div><br>  الآن يمكننا تجميع الرسوم المتحركة.  دعونا نحاول تعقيد المهمة: على سبيل المثال ، نريد أن يظهر الزر 1 والزر 2 في نفس الوقت ، ثم الزر 3 والزر 4: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs css">(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>())) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>())) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre> <br>  نقوم بدمج الزرين الأول والثاني مع عامل التشغيل <b>mergeWith</b> ، ونكرر الإجراء <b>للعامل</b> الثالث والرابع ، ونبدأ هذه المجموعات بالتتابع مع عامل التشغيل ثم ثم.  الآن سنقوم بتحسين الكود بإضافة طريقة <b>fadeInTogether</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeInTogether</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first.fadeIn() .mergeWith(second.fadeIn()) }</code> </pre> <br>  سيسمح لك بتشغيل الرسوم المتحركة fadeIn لعرضين في نفس الوقت.  كيف تغيرت سلسلة الرسوم المتحركة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeInTogether</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(button1, button2)</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">andThen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fadeInTogether(button3, button4))</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  والنتيجة هي الرسوم المتحركة التالية: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/hk/xw/pe/hkxwpemdtbmksyv_r7mq2qx3bcw.gif"></div><br>  فكر في مثال أكثر تعقيدًا.  لنفترض أننا بحاجة إلى عرض رسوم متحركة مع بعض التأخير.  سيساعدك بيان <b>الفاصل الزمني</b> على: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> timeObservable = Observable.interval(<span class="hljs-number"><span class="hljs-number">100</span></span>, TimeUnit.MILLISECONDS) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> btnObservable = Observable.just(button1, button2, button3, button4) }</code> </pre> <br>  ستولد قيمًا كل 100 مللي ثانية.  سيظهر كل زر بعد 100 مللي ثانية.  بعد ذلك ، نشير إلى ملاحظة أخرى يمكن أن تنبعث منها الأزرار.  في هذه الحالة ، لدينا 4 أزرار.  نستخدم عامل التشغيل <b>المضغوط</b> . <br><br><img src="https://habrastorage.org/webt/g5/qq/yi/g5qqyih178patmj5cjpfyoevkkw.png" alt="الصورة"><br><br>  أمامنا تيارات الأحداث: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs mel">Observable.zip(timeObservable, btnObservable, BiFunction&lt;Long, View, Disposable&gt; { _, <span class="hljs-keyword"><span class="hljs-keyword">button</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">button</span></span>.fadeIn().subscribe() })</code> </pre> <br>  الأول يتوافق مع <b>timeObservable</b> .  هذا <b>الملاحظ يمكن</b> أن يولد أرقام على فترات منتظمة.  لنفترض أنه سيكون 100 مللي ثانية. <br><br>  سوف يولد <b>Second Observable</b> وجهة نظر.  ينتظر عامل التشغيل <b>zip</b> حتى يظهر الكائن الأول في السلسلة الأولى ، ويربطه بالكائن الأول من مؤشر الترابط الثاني.  على الرغم من حقيقة أن جميع هذه الكائنات الأربعة في الخيط الثاني ستظهر على الفور ، فإنه سينتظر حتى تبدأ الكائنات في الظهور في الخيط الأول.  وبالتالي ، سيتصل الكائن الأول من الدفق الأول بالكائن الأول من الثاني في شكل رؤيتنا ، وبعد 100 مللي ثانية لاحقًا ، عندما يظهر كائن جديد ، سيدمجه العامل مع الكائن الثاني.  لذلك ، سيظهر العرض بتأخير معين. <br><br>  دعونا <b>نتعامل</b> مع <b>BiFinction</b> في <b>RxJava</b> .  تستقبل هذه الوظيفة كائنين كمدخل ، وتقوم ببعض العمليات عليها ، وترجع كائنًا ثالثًا.  نريد أن نأخذ الوقت <b>ونشاهد الأشياء ونستعمل</b> <b>مرة واحدة</b> لأننا نسمي الرسوم المتحركة <b>fadeIn</b> والاشتراك <b>للاشتراك</b> .  قيمة الوقت ليست مهمة بالنسبة لنا.  ونتيجة لذلك ، نحصل على هذه الرسوم المتحركة: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/8q/wa/1z/8qwa1z75xolp2jb-hsznqzncykw.gif"></div><br><h3 style=";text-align:right;direction:rtl">  Vanogogh </h3><br>  سأخبرك عن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المشروع</a> الذي بدأ إيفان في تطويره لـ MBLT DEV 2017. <br><br>  تقدم المكتبة التي طورها إيفان قذائف متنوعة للرسوم المتحركة.  لقد نظرنا بالفعل في هذا أعلاه.  كما يحتوي على رسوم متحركة جاهزة يمكنك استخدامها.  تحصل على مجموعة معممة من الأدوات لإنشاء الرسوم المتحركة الخاصة بك.  ستوفر لك هذه المكتبة مكونات أكثر قوة للبرمجة التفاعلية. <br><br>  خذ بعين الاعتبار المكتبة باستخدام مثال: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : AnimationCompletable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnimationBuilder.forView(view) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .duration(<span class="hljs-number"><span class="hljs-number">2000L</span></span>) .build().toCompletable() }</code> </pre> <br>  افترض أنك تريد إنشاء رسم متحرك يظهر ، ولكن هذه المرة تظهر <b>AnimationCompletable</b> بدلاً من الكائن <b>Completable</b> .  ترث هذه الفئة من <b>Completable</b> ، لذلك تظهر الآن المزيد من الوظائف.  كانت إحدى السمات المهمة للرمز السابق أنه كان من المستحيل إلغاء الرسوم المتحركة.  يمكنك الآن إنشاء كائن <b>AnimationCompletable</b> يجعل الرسوم المتحركة تتوقف بمجرد إلغاء الاشتراك منه. <br><br>  إنشاء الرسوم المتحركة الناشئة باستخدام <b>AnimationBuilder</b> - أحد فئات المكتبة.  حدد العرض الذي سيتم تطبيق الرسوم المتحركة عليه.  في الأساس ، ينسخ هذا الفصل سلوك <b>ViewPropertyAnimator</b> ، ولكن مع الاختلاف في أن الناتج هو دفق. <br><br>  بعد ذلك ، قم بتعيين alpha 1f والمدة هي ثانيتان.  ثم نجمع الرسوم المتحركة.  بمجرد <b>استدعاء</b> بيان <b>البناء</b> ، تظهر الرسوم المتحركة.  نحن نخصص الرسوم المتحركة خاصية كائن غير قابل للتغيير ، لذلك سيحفظ هذه الخصائص عند إطلاقه.  لكن الرسوم المتحركة نفسها لن تبدأ. <br><br>  Call <b>toCompletable</b> ، الذي سينشئ <b>AnimationCompletable</b> .  ستلف معلمات هذا الرسم المتحرك في نوع من الصدفة للبرمجة التفاعلية ، وبمجرد الاشتراك فيه ، سيبدأ الرسم المتحرك.  إذا قمت بإيقاف تشغيله قبل اكتمال العملية ، فسينتهي الرسم المتحرك.  يمكنك الآن أيضًا إضافة وظيفة رد اتصال.  يمكنك كتابة العوامل <b>doOnAnimationReady</b> و <b>doOnAnimationStart</b> و <b>doOnAnimationEnd</b> وما شابه: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : AnimationCompletable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnimationBuilder.forView(view) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .duration(<span class="hljs-number"><span class="hljs-number">2000L</span></span>) .buildCompletable() .doOnAnimationReady { view.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> } }</code> </pre> <br>  في هذا المثال ، أظهرنا مدى ملاءمة استخدام <b>AnimationBuilder</b> ، وقمنا بتغيير حالة العرض قبل بدء الرسوم المتحركة. <br><br><h3 style=";text-align:right;direction:rtl">  تقرير الفيديو </h3><br>  نظرنا في أحد الخيارات لإنشاء الرسوم المتحركة وتأليفها وتعديلها باستخدام Kotlin و RxJava.  هنا رابط <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لمشروع</a> يصف الرسوم المتحركة والأمثلة الأساسية لهم ، بالإضافة إلى الأصداف الرئيسية للعمل مع الرسوم المتحركة. <br><br>  بالإضافة إلى فك التشفير ، أشارك مقطع فيديو للتقرير: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Yv80bdUnJgw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3 style=";text-align:right;direction:rtl">  مكبرات الصوت MBLT DEV 2018 </h3><br>  قبل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">MBLT DEV 2018</a> ، بقي أكثر من شهرين بقليل.  سيكون لدينا العروض التالية: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لورا مورينيجو ، خبيرة مطوري Google </li><li style=";text-align:right;direction:rtl">  Kaushik Gopal ، مؤلف كتاب بودكاست المجزأ </li><li style=";text-align:right;direction:rtl">  أرتيوم رودوي ، بادو </li><li style=";text-align:right;direction:rtl">  دينا سيدوروفا وجوجل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وغيرها</a> . </li></ul><br>  غدا سيتغير سعر التذكرة.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">سجل</a> اليوم. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar418383/">https://habr.com/ru/post/ar418383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar418371/index.html">Microtask للمبرمجين وطريقة بديلة للعملات المشفرة</a></li>
<li><a href="../ar418375/index.html">نظرة عامة على Uniz Slash + 3D Photo-Printer</a></li>
<li><a href="../ar418377/index.html">Kotlin: ملعقتين من القطران في برميل عسل</a></li>
<li><a href="../ar418379/index.html">بدلة الأطفال الكهربائية الحيوية. الجزء 2</a></li>
<li><a href="../ar418381/index.html">الميزات الجديدة في DevTools في إصدار Chrome 68</a></li>
<li><a href="../ar418385/index.html">كيف جمعت جهاز كمبيوتر للألعاب القديمة</a></li>
<li><a href="../ar418387/index.html">حوار الفيزيائيين حول الروح</a></li>
<li><a href="../ar418389/index.html">RabbitMQ مقابل كافكا: استخدام كافكا في التطبيقات الموجهة نحو الحدث</a></li>
<li><a href="../ar418391/index.html">OSPF (الجزء الأول)</a></li>
<li><a href="../ar418393/index.html">[الجمعة] كيف رأينا الويب ثلاثي الأبعاد</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>