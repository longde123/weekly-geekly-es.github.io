<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📛 🧑🏼‍🤝‍🧑🏻 🕷️ Mustervergleich in C # 7 🈶 🌓 🎅🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C # 7 hat endlich eine lang erwartete Funktion namens Pattern Matching. Wenn Sie mit funktionalen Sprachen wie F # vertraut sind, kann Sie diese Funkt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mustervergleich in C # 7</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423229/">  C # 7 hat endlich eine lang erwartete Funktion namens Pattern Matching.  Wenn Sie mit funktionalen Sprachen wie F # vertraut sind, kann Sie diese Funktion in der Form, in der sie derzeit vorhanden ist, leicht enttäuschen.  Aber auch heute kann es den Code in einer Vielzahl von Fällen vereinfachen.  Weitere Details unter dem Schnitt! <br><br><img src="https://habrastorage.org/webt/tw/bk/ck/twbkckursaas-xb76976szvpmm0.jpeg"><a name="habracut"></a><br><br>  Jede neue Funktion kann für den Entwickler gefährlich sein, wenn er die Anwendung erstellt, für die die Leistung entscheidend ist.  Neue Abstraktionsebenen sind gut, aber um sie effektiv zu nutzen, müssen Sie verstehen, wie sie tatsächlich funktionieren.  Dieser Artikel beschreibt die Mustervergleichsfunktion und ihre Funktionsweise. <br><br>  Ein Beispiel in C # kann sowohl in einem is-Ausdruck als auch im case-Block einer switch-Anweisung verwendet werden. <br>  Es gibt drei Arten von Proben: <br><br><ul><li>  Probenkonstante; </li><li>  Typ Probe; </li><li>  Beispielvariable. </li></ul><br><h2>  Musterabgleich in ist Ausdrücke </h2><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExpressions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Alternative way checking for null if (o is null) Console.WriteLine("o is null"); // Const pattern can refer to a constant value const double value = double.NaN; if (o is value) Console.WriteLine("o is value"); // Const pattern can use a string literal if (o is "o") Console.WriteLine("o is \"o\""); // Type pattern if (o is int n) Console.WriteLine(n); // Type pattern and compound expressions if (o is string s &amp;&amp; s.Trim() != string.Empty) Console.WriteLine("o is not blank"); }</span></span></code> </pre> <br>  Mit dem Ausdruck is können Sie überprüfen, ob der Wert konstant ist, und mit der Typprüfung können Sie zusätzlich die Beispielvariable bestimmen. <br><br>  Wenn Sie den Mustervergleich in is-Ausdrücken verwenden, sollten Sie einige interessante Punkte beachten: <br><br><ul><li>  Die von der if-Anweisung eingegebene Variable wird an den äußeren Bereich gesendet. </li><li>  Die von der if-Anweisung eingegebene Variable wird nur explizit zugewiesen, wenn das Muster übereinstimmt. </li><li>  Die derzeitige Implementierung des Mustervergleichs in Ausdrücken ist nicht sehr effizient. </li></ul><br>  Betrachten Sie zunächst die ersten beiden Fälle: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScopeAndDefiniteAssigning</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s &amp;&amp; s.Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"o is not empty string"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// Can't use 's' any more. 's' is already declared in the current scope. if (o is int n || (o is string s2 &amp;&amp; int.TryParse(s2, out n))) { Console.WriteLine(n); } }</span></span></code> </pre> <br>  Die erste if-Anweisung führt die Variable s ein, die in der gesamten Methode sichtbar ist.  Dies ist sinnvoll, verkompliziert jedoch die Logik, wenn andere if-Anweisungen im selben Block versuchen, denselben Namen wiederzuverwenden.  Verwenden Sie in diesem Fall einen anderen Namen, um Konflikte zu vermeiden. <br><br>  Die im Ausdruck is eingegebene Variable wird nur dann explizit zugewiesen, wenn das Prädikat wahr ist.  Dies bedeutet, dass die Variable n in der zweiten if-Anweisung nicht im richtigen Operanden zugewiesen ist. Da sie jedoch bereits deklariert ist, können wir sie als out-Variable in der int.TryParse-Methode verwenden. <br><br>  Der dritte oben erwähnte Punkt ist der wichtigste.  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BoxTwice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"n is 42"</span></span>); }</code> </pre> <br>  In den meisten Fällen wird der Ausdruck in object.Equals (Konstante, Variable) konvertiert [obwohl die Merkmale besagen, dass der Operator == für einfache Typen verwendet werden sollte]: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BoxTwice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.Equals(<span class="hljs-number"><span class="hljs-number">42</span></span>, n)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"n is 42"</span></span>); } }</code> </pre> <br>  Dieser Code ruft zwei Paketkonvertierungsprozesse auf, die die Leistung erheblich beeinträchtigen können, wenn sie in einem kritischen Anwendungspfad verwendet werden.  Früher war der Ausdruck o ein Null-Ausdruck, der als Verpackung bezeichnet wurde, wenn die Variable o vom Typ nullable war (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suboptimaler Code für e ist null</a> ), aber es besteht die Hoffnung, dass dies behoben wird (hier ist die entsprechende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anforderung auf Github</a> ). <br><br>  Wenn die Variable n vom Typ Objekt ist, verursacht der Ausdruck o is 42 einen "Packing-Conversion" -Prozess (für Literal 42), obwohl ein ähnlicher Code, der auf der switch-Anweisung basiert, nicht dazu führen würde. <br><br><h2>  Beispielvariable in ist Ausdruck </h2><br>  Ein variables Muster ist eine spezielle Art von Mustertyp mit einem großen Unterschied: Das Muster stimmt mit jedem Wert überein, sogar mit Null. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsVar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"x: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre> <br>  Der Ausdruck o is object ist wahr, wenn o nicht null ist, aber der Ausdruck o is var x ist immer wahr.  Daher schließt der Compiler im Release-Modus * if-Anweisungen vollständig aus und verlässt einfach den Console-Methodenaufruf.  Leider warnt der Compiler im folgenden Fall nicht vor der Nichtverfügbarkeit des Codes: if (! (O ist var x)) Console.WriteLine ("Unreachable").  Es besteht die Hoffnung, dass dies auch behoben wird. <br><br>  <i>* Es ist unklar, warum sich das Verhalten nur im Release-Modus unterscheidet.</i>  <i>Es scheint, dass die Wurzel aller Probleme dieselbe ist: Die anfängliche Implementierung der Funktion ist nicht optimal.</i>  <i>Nach <a href="">diesem Kommentar von</a> Neal Gafter wird sich jedoch bald alles ändern: „Der Code für den Abgleich mit dem Beispiel wird von Grund auf neu geschrieben (um auch rekursive Beispiele zu unterstützen).</i>  <i>Ich denke, die meisten Verbesserungen, über die Sie sprechen, werden im neuen Code implementiert und sind kostenlos verfügbar.</i>  <i>Dies wird jedoch einige Zeit dauern. “</i> <br><br>  Das Fehlen einer Nullprüfung macht diese Situation besonders und potenziell gefährlich.  Wenn Sie jedoch genau wissen, wie dieses Beispiel funktioniert, kann es hilfreich sein.  Es kann verwendet werden, um eine temporäre Variable in den Ausdruck einzufügen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VarPattern</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s.FirstOrDefault(o =&gt; o != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.TryParse(v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n)) { Console.WriteLine(n); } }</code> </pre> <br><h2>  Ist Ausdruck und Elvis Aussage </h2><br>  Es gibt einen anderen Fall, der sich als nützlich erweisen kann.  Ein Beispieltyp stimmt nur dann mit einem Wert überein, wenn er nicht null ist.  Wir können diese "Filter" -Logik mit einem nullverteilten Operator verwenden, um den Code besser lesbar zu machen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithNullPropagation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s?.FirstOrDefault(str =&gt; str.Length &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>)?.Length <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length) { Console.WriteLine(length); } <span class="hljs-comment"><span class="hljs-comment">// Similar to if (s?.FirstOrDefault(str =&gt; str.Length &gt; 10)?.Length is var length2 &amp;&amp; length2 != null) { Console.WriteLine(length2); } // And similar to var length3 = s?.FirstOrDefault(str =&gt; str.Length &gt; 10)?.Length; if (length3 != null) { Console.WriteLine(length3); } }</span></span></code> </pre> <br>  Beachten Sie, dass dasselbe Muster sowohl für Werttypen als auch für Referenztypen verwendet werden kann. <br><br><h2>  Mustervergleich in Fallblöcken </h2><br>  Die Funktionalität der switch-Anweisung wurde in C # 7 erweitert, sodass jetzt Muster in case-Klauseln verwendet werden können: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IEnumerable&lt;T&gt; e) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ICollection&lt;T&gt; c: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.Count; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IReadOnlyCollection&lt;T&gt; c: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.Count; <span class="hljs-comment"><span class="hljs-comment">// Matches concurrent collections case IProducerConsumerCollection&lt;T&gt; pc: return pc.Count; // Matches if e is not null case IEnumerable&lt;T&gt; _: return e.Count(); // Default case is handled when e is null default: return 0; } }</span></span></code> </pre> <br>  Dieses Beispiel zeigt die ersten Änderungen an der switch-Anweisung. <br><br><ol><li>  Mit der switch-Anweisung kann eine Variable eines beliebigen Typs verwendet werden. </li><li>  Mit der case-Klausel können Sie ein Muster angeben. </li><li>  Die Reihenfolge der Fallklauseln ist wichtig.  Der Compiler gibt einen Fehler aus, wenn der vorherige Satz dem Basistyp und der nächste dem abgeleiteten Satz entspricht. </li><li>  Benutzerdefinierte Angebote werden implizit auf null ** geprüft.  Im obigen Beispiel ist die letzte case-Klausel gültig, da sie nur übereinstimmt, wenn das Argument nicht null ist. </li></ol><br>  <i>** Der letzte Satz des Falls zeigt eine weitere in C # 7 hinzugefügte Funktion - Beispiele einer leeren Variablen.</i>  <i>Der spezielle Name _ teilt dem Compiler mit, dass die Variable nicht benötigt wird.</i>  <i>Das Typbeispiel in der case-Klausel erfordert einen Alias.</i>  <i>Aber wenn Sie es nicht brauchen, können Sie _ verwenden.</i> <br><br>  Das folgende Snippet zeigt eine weitere Funktion des Mustervergleichs basierend auf der switch-Anweisung - die Möglichkeit, Prädikate zu verwenden: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FizzBuzz</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s when s.Contains(<span class="hljs-string"><span class="hljs-string">"Fizz"</span></span>) || s.Contains(<span class="hljs-string"><span class="hljs-string">"Buzz"</span></span>): Console.WriteLine(s); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n when n % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; n % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n when n % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Fizz"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n when n % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Buzz"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n: Console.WriteLine(n); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  Dies ist eine seltsame Version der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FizzBuzz-</a> Aufgabe, die ein Objekt verarbeitet, nicht nur eine Zahl. <br><br>  Eine switch-Anweisung kann mehrere case-Klauseln desselben Typs enthalten.  In diesem Fall kombiniert der Compiler alle Typprüfungen, um unnötige Berechnungen zu vermeiden: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FizzBuzz</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// All cases can match only if the value is not null if (o != null) { if (o is string s &amp;&amp; (s.Contains("Fizz") || s.Contains("Buzz"))) { Console.WriteLine(s); return; } bool isInt = o is int; int num = isInt ? ((int)o) : 0; if (isInt) { // The type check and unboxing happens only once per group if (num % 5 == 0 &amp;&amp; num % 3 == 0) { Console.WriteLine("FizzBuzz"); return; } if (num % 5 == 0) { Console.WriteLine("Fizz"); return; } if (num % 3 == 0) { Console.WriteLine("Buzz"); return; } Console.WriteLine(num); } } }</span></span></code> </pre> <br>  Es sind jedoch zwei Dinge zu beachten: <br><br>  1. Der Compiler kombiniert nur sequentielle Typprüfungen. Wenn Sie Case-Klauseln mit verschiedenen Typen mischen, wird ein Code mit geringerer Qualität generiert: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-comment"><span class="hljs-comment">// The generated code is less optimal: // If o is int, then more than one type check and unboxing operation // may happen. case int n when n == 1: return 1; case string s when s == "": return 2; case int n when n == 2: return 3; default: return -1; }</span></span></code> </pre> <br>  Der Compiler konvertiert es wie folgt: <br><br>  if (o ist int n &amp;&amp; n == 1) return 1; <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s &amp;&amp; s == <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n2 &amp;&amp; n2 == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre> <br>  2. Der Compiler unternimmt alles, um typische Sequenzierungsprobleme zu vermeiden. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Error: The switch case has already been handled by a previous case. case int n when n == 1: return 2; }</span></span></code> </pre> <br>  Der Compiler kann jedoch nicht feststellen, dass ein Prädikat stärker als ein anderes ist, und ersetzt effektiv die folgenden case-Klauseln: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n when n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Will never match, but the compiler won't warn you about it case int n when n &gt; 1: return 2; }</span></span></code> </pre> <br><h2>  Muster-Matching-Brief </h2><br><ul><li>  Die folgenden Muster wurden in C # 7 angezeigt: ein konstantes Muster, ein Typmuster, ein variables Muster und ein leeres variables Muster. </li><li>  Beispiele können in is-Ausdrücken und in case-Blöcken verwendet werden. </li><li>  Die Implementierung des konstanten Musters im Ausdruck für Werttypen ist hinsichtlich der Leistung alles andere als ideal. </li><li>  Stichproben einer Variablen stimmen immer überein, man muss vorsichtig mit ihnen sein. </li><li>  Mit der switch-Anweisung können Typprüfungen mit zusätzlichen Prädikaten in when-Klauseln festgelegt werden. </li></ul><br><h2>  Unity Event in Moskau - Unity Moscow Meetup 2018.1 </h2><br>  Am Donnerstag, dem 11. Oktober, findet an der Higher School of Economics das Unity Moscow Meetup 2018.1 statt.  Dies ist das erste Treffen der Unity-Entwickler in dieser Saison in Moskau.  Das Thema des ersten Mitaps wird AR / VR sein.  Sie finden interessante Berichte, Kommunikation mit Branchenfachleuten sowie eine spezielle Demo-Zone von MSI. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Details</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423229/">https://habr.com/ru/post/de423229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423215/index.html">Wo ist mein Geld, Mann? Worüber schweigt Steam?</a></li>
<li><a href="../de423217/index.html">Zurück in die Zukunft: Praktische Bestätigung der Tomonaga-Luttinger-Theorie nach fast 56 Jahren</a></li>
<li><a href="../de423219/index.html">Zur Verbesserung des Kernbrennstoffs</a></li>
<li><a href="../de423221/index.html">Interview mit Liz Parrish, CEO von BioViva</a></li>
<li><a href="../de423225/index.html">Jeff Bezos Foundation Day One</a></li>
<li><a href="../de423231/index.html">Frango Anomalie, Höhepunkt</a></li>
<li><a href="../de423233/index.html">Künstliche Intelligenz in der realen Welt</a></li>
<li><a href="../de423235/index.html">Von Dribbble zu Android Motion</a></li>
<li><a href="../de423237/index.html">Ein einfacher, aber raffinierter Roboterarm</a></li>
<li><a href="../de423239/index.html">Erstellen Sie Pakete für Kubernetes mit Helm: Diagrammstruktur und Vorlagen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>