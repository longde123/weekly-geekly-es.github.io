<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游뱖 游늮 游 Hacemos que Shrimp sea a칰n m치s 칰til: agregue la transcodificaci칩n de im치genes a otros formatos 九뫮잺 游끡游 游댞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desde principios de 2017, nuestro peque침o equipo ha estado desarrollando la biblioteca RESTinio OpenSource para incrustar un servidor HTTP en aplicaci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hacemos que Shrimp sea a칰n m치s 칰til: agregue la transcodificaci칩n de im치genes a otros formatos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420353/"><img src="https://habrastorage.org/webt/7w/iy/b5/7wiyb5u0fpwa1duglcppwofjloa.jpeg"><br><br>  Desde principios de 2017, nuestro peque침o equipo ha estado desarrollando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca RESTinio OpenSource</a> para incrustar un servidor HTTP en aplicaciones C ++.  Para nuestra gran sorpresa, de vez en cuando recibimos preguntas de la categor칤a "쯏 por qu칠 podr칤a ser necesario un servidor HTTP C ++ incrustado?"  Desafortunadamente, las preguntas simples son las m치s dif칤ciles de responder.  A veces la mejor respuesta es el c칩digo de muestra. <br><br>  Hace un par de meses comenzamos un peque침o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto de demostraci칩n, Shrimp</a> , que demuestra claramente un escenario t칤pico, bajo el cual nuestra biblioteca se "afila".  El proyecto de demostraci칩n es un servicio web simple que recibe solicitudes para escalar im치genes almacenadas en el servidor y que devuelve una imagen del tama침o que necesita el usuario. <br><br>  Este proyecto de demostraci칩n es bueno porque, en primer lugar, requiere integraci칩n con c칩digo escrito y funcionando correctamente hace mucho tiempo en C o C ++ (en este caso, ImageMagick).  Por lo tanto, debe quedar claro por qu칠 tiene sentido incrustar el servidor HTTP en una aplicaci칩n C ++. <br><br>  Y, en segundo lugar, en este caso, se requiere un procesamiento as칤ncrono de las solicitudes para que el servidor HTTP no se bloquee mientras se escala la imagen (y esto puede llevar cientos de milisegundos o incluso segundos).  Y comenzamos el desarrollo de RESTinio precisamente porque no pudimos encontrar un servidor integrado C ++ cuerdo enfocado espec칤ficamente en el procesamiento de solicitudes as칤ncronas. <br><br>  Construimos el trabajo en camarones de forma iterativa: primero, se hizo y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">describi칩</a> la versi칩n m치s simple, que solo escalaba las im치genes.  Luego arreglamos una serie de deficiencias de la primera versi칩n y lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">describimos en el segundo art칤culo</a> .  Finalmente, pudimos ampliar la funcionalidad de Shrimp una vez m치s: se agreg칩 la conversi칩n de im치genes de un formato a otro.  Sobre c칩mo se hizo esto y se discutir치 en este art칤culo. <br><a name="habracut"></a><br><h1>  Soporte de formato de destino </h1><br>  Entonces, en la pr칩xima versi칩n de Shrimp, agregamos la capacidad de dar una imagen a escala en un formato diferente.  Entonces, si emite una solicitud de camarones del formulario: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920"</span></span></code> </pre> <br>  entonces Shrimp representar치 la imagen en el mismo formato JPG que la imagen original. <br><br>  Pero si agrega el par치metro de formato de destino a la URL, entonces Shrimp convierte la imagen al formato de destino especificado.  Por ejemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920&amp;target-format=webp"</span></span></code> </pre> <br>  En este caso, Shrimp representar치 la imagen en formato webp. <br><br>  Shrimp actualizado admite cinco formatos de imagen: jpg, png, gif, webp y heic (tambi칠n conocido como HEIF).  Puede experimentar con varios formatos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en una p치gina web especial</a> : <br><br><img src="https://habrastorage.org/webt/99/ab/ke/99abkec8ode-lxyxufceqjmwxt8.png"><br><br>  (en esta p치gina no hay forma de seleccionar el formato heic, porque los navegadores de escritorio normales no admiten este formato de forma predeterminada). <br><br>  Para admitir el formato de destino en Shrimp, fue necesario modificar ligeramente el c칩digo de Shrimp (lo cual nos sorprendi칩 a nosotros mismos, porque realmente hubo pocos cambios).  Pero por otro lado, tuve que jugar con el ensamblaje de ImageMagick, que nos sorprendi칩 a칰n m치s, ya que  Anteriormente, tuvimos que lidiar con esta cocina, por una afortunada coincidencia.  Pero hablemos de todo en orden. <br><br><h2>  ImageMagick debe comprender diferentes formatos </h2><br>  ImageMagick utiliza bibliotecas externas para codificar / decodificar im치genes: libjpeg, libpng, libgif, etc.  Estas bibliotecas deben instalarse en el sistema antes de configurar y construir ImageMagick. <br><br>  Lo mismo deber칤a suceder para que ImageMagick admita formatos webp y heic: primero debe compilar e instalar libwebp y libheif, luego configurar e instalar ImageMagick.  Y si todo es simple con libwebp, entonces alrededor de libheif tuve que bailar con una pandereta.  Aunque despu칠s de un tiempo, despu칠s de que todo finalmente se hab칤a reunido y funcionado, ya no estaba claro: 쯣or qu칠 tuviste que recurrir a una pandereta, todo parece ser trivial?  ;) <br><br>  En general, si alguien quiere hacerse amigo de heic e ImageMagick, deber치 instalar: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">x265 de videolan.org</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libde265</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libheif</a> </li></ul><br>  Est치 en este orden (puede que tenga que instalar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nasm</a> para que x265 funcione a la velocidad m치xima).  Luego, al emitir el comando <i>./configure</i> , ImageMagick podr치 encontrar todo lo que necesita para admitir archivos .heic. <br><br><h2>  Soporte para formato de destino en la cadena de consulta de solicitudes entrantes </h2><br>  Despu칠s de que nos hicimos amigos de ImageMagick con los formatos webp y heic, es hora de modificar el c칩digo de Shrimp.  En primer lugar, debemos aprender a reconocer el argumento del formato de destino en las solicitudes HTTP entrantes. <br><br>  Desde el punto de vista RESTinio, esto no es un problema en absoluto.  Bueno, otro argumento apareci칩 en la cadena de consulta, 쯫 qu칠?  Pero desde el punto de vista de Shrimp, la situaci칩n result칩 ser algo m치s complicada, por lo que el c칩digo de la funci칩n responsable de analizar la solicitud HTTP se volvi칩 m치s complicado. <br><br>  El hecho es que antes era necesario distinguir solo dos situaciones: <br><br><ul><li>  vino una solicitud de la forma "/filename.ext" sin ning칰n otro par치metro.  Entonces solo necesita dar al archivo "filename.ext" tal como est치; </li><li>  Se recibi칩 una solicitud con el formato "/filename.ext?op=resize &amp; ...".  En este caso, debe escalar la imagen del archivo "filename.ext". </li></ul><br>  Pero despu칠s de agregar el formato de destino, necesitamos distinguir entre cuatro situaciones: <br><br><ul><li>  vino una solicitud de la forma "/filename.ext" sin ning칰n otro par치metro.  Por lo tanto, solo necesita dar al archivo "filename.ext" tal como est치, sin escalar y sin transcodificar a otro formato; </li><li>  vino una solicitud de la forma "/filename.ext?target-format=fmt" sin ning칰n otro par치metro.  Significa tomar una imagen del archivo "filename.ext" y transcodificarla al formato "fmt" mientras se conservan los tama침os originales; </li><li>  lleg칩 una solicitud de la forma "/filename.ext?op=resize &amp; ..." pero sin formato de destino.  En este caso, necesita escalar la imagen del archivo "filename.ext" y darle el formato original; </li><li>  Se recibi칩 una solicitud con el formato "/filename.ext?op=resize&amp;...&amp;target-format=fmt".  En este caso, debe realizar el escalado y luego transcodificar el resultado al formato "fmt". </li></ul><br>  Como resultado, la funci칩n para determinar los par치metros de consulta tom칩 la <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">siguiente forma</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> add_transform_op_handler( const app_params_t &amp; app_params, http_req_router_t &amp; router, so_5::mbox_t req_handler_mbox ) { router.http_get( R"(/:path(.*)\.:ext(.{3,4}))", restinio::path2regex::options_t{}.<span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ), [req_handler_mbox, &amp;app_params]( auto req, auto params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( has_illegal_path_components( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().path() ) ) { //     . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } //   . const auto qp = restinio::parse_query( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().query() ); const auto target_format = qp.get_param( "target-format"sv ); //        // .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>,    //   .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>  // ,    ,  //    . const auto image_format = try_detect_target_image_format( params[ "ext" ], target_format ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !image_format ) { //     .   . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !qp.size() ) { //    ,    . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serve_as_regular_file( app_params.m_storage.m_root_dir, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ), *image_format ); } const auto operation = qp.get_param( "op"sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( operation &amp;&amp; "resize"sv != *operation ) { //    ,     resize. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !operation &amp;&amp; !target_format ) { //      op=resize, //   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=something. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } handle_resize_op_request( req_handler_mbox, *image_format, qp, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } ); }</code> </pre> <br>  En la versi칩n anterior de Shrimp, donde no era necesario transcodificar la imagen, trabajar con los par치metros de solicitud <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/3e8beeeb8935f84e492af188dd6fc6f2ba785657/dev/shrimp/">parec칤a un poco m치s f치cil</a> . <br><br><h2>  Solicite la cola y la cach칠 de im치genes adaptadas al formato de destino </h2><br>  El siguiente punto en la implementaci칩n del soporte de formato de destino fue el trabajo en la cola de solicitudes en espera y un cach칠 de im치genes preparadas en el agente a_transform_manager.  Hablamos de estas cosas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con</a> m치s detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el art칤culo anterior</a> , pero recordemos un poco de qu칠 se trataba. <br><br>  Cuando llega una solicitud de conversi칩n de imagen, puede resultar que la imagen terminada con dichos par치metros ya est칠 en el cach칠.  En este caso, no necesita hacer nada, solo env칤e la imagen desde el cach칠 en respuesta.  Si la imagen necesita ser transformada, puede resultar que no hay trabajadores libres en este momento y que debe esperar hasta que aparezca.  Para hacer esto, la informaci칩n de la solicitud debe estar en cola.  Pero al mismo tiempo, es necesario verificar la unicidad de las solicitudes: si tenemos tres solicitudes id칠nticas en espera de procesamiento (es decir, necesitamos convertir la misma imagen de la misma manera), entonces solo debemos procesar la imagen una vez y dar el resultado del procesamiento en respuesta a estas tres solicitudes.  Es decir  En la cola de espera, se deben agrupar solicitudes id칠nticas. <br><br>  Anteriormente en Shrimp, utilizamos una clave compuesta simple para buscar en el cach칠 de im치genes y la cola de espera: una <a href="">combinaci칩n del nombre del archivo original y las opciones de cambio de tama침o de la imagen</a> .  Ahora, dos nuevos factores tuvieron que ser tomados en cuenta: <br><br><ul><li>  en primer lugar, el formato de la imagen de destino (es decir, la imagen original puede estar en jpg y la imagen resultante puede estar en png); </li><li>  en segundo lugar, el hecho de que escalar la imagen puede no ser necesario.  Esto sucede en una situaci칩n en la que el cliente solicita solo la conversi칩n de la imagen de un formato a otro, pero con el tama침o original de la imagen preservado. </li></ul><br>  Debo decir que aqu칤 seguimos el camino m치s simple, sin tratar de optimizar de alguna manera nada.  Por ejemplo, uno podr칤a intentar hacer dos cach칠s: uno almacenar칤a im치genes en el formato original, pero escalado al tama침o deseado, y en el segundo, las im치genes escaladas convertidas al formato de destino. <br><br>  쯇or qu칠 se necesitar칤a tal doble cach칠?  El hecho es que al transformar im치genes, las dos operaciones m치s costosas en el tiempo son cambiar el tama침o y serializar la imagen al formato de destino.  Por lo tanto, si recibimos una solicitud para escalar la imagen example.jpg a un tama침o de 1920 de ancho y transformarla en formato webp, entonces podr칤amos almacenar dos im치genes en nuestra memoria: example_1920px_width.jpg y example_1920px_width.webp.  Dar칤amos una imagen example_1920px_width.webp cuando recibimos una segunda solicitud.  Pero la imagen example_1920px_width.jpg podr칤a usarse al recibir solicitudes para escalar example.jpg a un tama침o de 1920 de ancho y transformarlo en formato heic.  Podr칤amos omitir la operaci칩n de cambio de tama침o y hacer solo la conversi칩n de formato (es decir, la imagen terminada example_1920px_width.jpg se transcodificar칤a al formato heic). <br><br>  Otra oportunidad potencial: cuando llega una solicitud para transcodificar una imagen a otro formato sin cambiar el tama침o, puede determinar el tama침o real de la imagen y usar este tama침o dentro de la clave compuesta.  Por ejemplo, deje que example.jpg tenga un tama침o de 3000x2000 p칤xeles.  Si luego recibimos una solicitud para escalar example.jpg a 2000px de altura, entonces podemos determinar de inmediato que ya tenemos una imagen de este tama침o. <br><br>  En teor칤a, todas estas consideraciones merecen atenci칩n.  Pero desde un punto de vista pr치ctico, no est치 claro qu칠 tan alta es la probabilidad de tal desarrollo de eventos.  Es decir  쯖on qu칠 frecuencia recibiremos una solicitud para escalar example.jpg a 1920px con conversi칩n a webp, y luego una solicitud para la misma escala de la misma imagen, pero con conversi칩n a png?  No tener estad칤sticas reales es dif칤cil de decir.  Por lo tanto, decidimos no complicarnos la vida en nuestro proyecto de demostraci칩n, sino ir primero por el camino m치s simple.  Con la expectativa de que si alguien necesita esquemas de almacenamiento en cach칠 m치s avanzados, esto se puede agregar m치s tarde, a partir de escenarios reales, no ficticios, para usar Shrimp. <br><br>  Como resultado, en la versi칩n actualizada de Shrimp, expandimos ligeramente la clave, agregando tambi칠n un par치metro como el formato de destino: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resize_request_key_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_path; <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> m_format; <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> m_params; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format, <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params ) : m_path{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(path) } , m_format{ format } , m_params{ params } {} [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> &amp; o ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( m_path, m_format, m_params ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( o.m_path, o.m_format, o.m_params ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_path; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_format; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_params; } };</code> </pre> <br>  Es decir  solicitud de cambio de tama침o example.jpg hasta 1920px con conversi칩n a png difiere del mismo cambio de tama침o, pero con conversi칩n a webp o heic. <br><br>  Pero el foco principal se esconde <a href="">en la nueva implementaci칩n de la clase resize_params_t</a> , que determina los nuevos tama침os de la imagen escalada.  <a href="">Anteriormente, esta clase</a> admit칤a tres opciones: solo se configuraba el ancho, solo se ajustaba la altura o se configuraba el lado largo (la altura o el ancho est치n determinados por el tama침o de imagen actual).  En consecuencia, el <a href="">m칠todo resize_params_t :: value ()</a> siempre devolvi칩 alg칰n valor real (qu칠 valor fue determinado por el <a href="">m칠todo resize_params_t :: mode ()</a> ). <br><br>  Pero en el nuevo Shrimp, se agreg칩 otro modo: keep_original, lo que significa que no se realiza el escalado y la imagen se representa en su tama침o original.  Para admitir este modo, resize_params_t tuvo que hacer algunos cambios.  En primer lugar, ahora el <a href="">m칠todo resize_params_t :: make ()</a> determina si se usa el modo keep_original (se considera que este modo se usa si no se especifica ninguno de los par치metros ancho, alto y m치ximo en la cadena de consulta de la solicitud entrante).  Esto nos permiti칩 no reescribir la funci칩n <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">handle_resize_op_request ()</a> , que empuja la solicitud para escalar la imagen que se ejecutar치. <br><br>  En segundo lugar, el <a href="">m칠todo resize_params_t :: value ()</a> ahora puede llamarse no siempre, sino solo cuando el modo de escala difiere de keep_original. <br><br>  Pero lo m치s importante es que <a href="">resize_params_t :: operator &lt;()</a> continu칩 funcionando seg칰n lo previsto. <br><br>  Gracias a todos estos cambios en a_transform_manager, tanto el cach칠 de im치genes escaladas como la cola de solicitudes en espera se han mantenido igual.  Pero ahora, la informaci칩n sobre varias consultas se almacena en estas estructuras de datos.  Por lo tanto, la clave {"example.jpg", "jpg", keep_original} diferir치 tanto de la clave {"example.jpg", "png", keep_original}, como de la clave {"example.jpg", "jpg", ancho = 1920px}. <br><br>  Result칩 que habiendo estropeado un poco la definici칩n de estructuras de datos tan simples como resize_params_t y resize_params_key_t, evitamos alterar estructuras m치s complejas como el cach칠 de im치genes resultantes y la cola de solicitudes en espera. <br><br><h2>  Soporte para formato de destino en a_transformer </h2><br>  Bueno, el paso final para admitir el formato de destino es expandir la l칩gica del agente a_transformer para que la imagen, posiblemente ya escalada, se convierta al formato de destino. <br><br>  Result칩 ser el m치s f치cil de hacer, todo lo que se necesitaba era expandir el c칩digo del <a href="">m칠todo a_transform_t :: handle_resize_request ()</a> : <br><br><pre> <code class="hljs pgsql">[[nodiscard]] a_transform_manager_t::resize_result_t::result_t a_transformer_t::handle_resize_request( const <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_request_key_t &amp; key ) { try { m_logger-&gt;trace( "transformation started; request_key={}", key ); auto image = load_image( key.path() ); const auto resize_duration = measure_duration( [&amp;]{ //       //    keep_original. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_params_t::mode_t::keep_original != key.params().mode() ) { <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize( key.params(), total_pixel_count, image ); } } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "resize finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( resize_duration).count() ); image.magick( magick_from_image_format( key.format() ) ); datasizable_blob_shared_ptr_t blob; const auto serialize_duration = measure_duration( [&amp;] { blob = make_blob( image ); } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "serialization finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( serialize_duration).count() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::successful_resize_t{ std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(blob), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( resize_duration), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( serialize_duration) }; } catch( const std::<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> &amp; x ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::failed_resize_t{ x.what() }; } }</code> </pre> <br>  En comparaci칩n <a href="">con la versi칩n anterior,</a> hay dos adiciones fundamentales. <br><br>  En primer lugar, llamar al m칠todo image.magick () verdaderamente m치gico despu칠s de cambiar el tama침o.  Este m칠todo le dice a ImageMagick el formato de imagen resultante.  Al mismo tiempo, la representaci칩n de la imagen en la memoria no cambia: ImageMagick contin칰a almacen치ndola como le conviene.  Pero luego el valor establecido por el m칠todo magick () se tendr치 en cuenta durante la llamada posterior a Image :: write (). <br><br>  En segundo lugar, la versi칩n actualizada registra el tiempo que lleva serializar la imagen al formato especificado.  La nueva versi칩n de Shrimp ahora repara por separado el tiempo dedicado a escalar y el tiempo dedicado a la conversi칩n al formato de destino. <br><br>  El resto del agente a_transformer_t no ha sufrido ning칰n cambio. <br><br><h1>  Paralelizaci칩n de ImageMagick </h1><br>  Por defecto, ImageMagic est치 construido con soporte OpenMP.  Es decir  Es posible paralelizar operaciones en im치genes que realiza ImageMagick.  Puede controlar la cantidad de flujos de trabajo que ImageMagick usa en este caso utilizando la variable de entorno MAGICK_THREAD_LIMIT. <br><br>  Por ejemplo, en mi m치quina de prueba con el valor MAGICK_THREAD_LIMIT = 1 (es decir, sin paralelizaci칩n real), obtengo los siguientes resultados: <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1323</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1086.72</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">236.276</span></span></code> </pre><br>  El tiempo dedicado al cambio de tama침o se indica en el encabezado Shrimp-Resize-Time.  En este caso, es 1086.72ms. <br><br>  Pero si configura MAGICK_THREAD_LIMIT = 3 en la misma m치quina y ejecuta Shrimp, obtenemos valores diferentes: <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">779.901</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">558.246</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">221.655</span></span></code> </pre> <br>  Es decir  El tiempo de cambio de tama침o se redujo a 558.25ms. <br><br>  En consecuencia, dado que ImageMagick brinda la capacidad de paralelizar los c치lculos, puede aprovechar esta oportunidad.  Pero al mismo tiempo, es deseable poder controlar cu치ntos hilos de trabajo toma Shrimp para s칤 mismo.  En versiones anteriores de Shrimp, no era posible influir en cu치ntos flujos de trabajo crea Shrimp.  Y en la versi칩n actualizada de Shrimp, esto se puede hacer.  O a trav칠s de variables de entorno, por ejemplo: <br><br><pre> <code class="hljs tex">SHRIMP_IO_THREADS=1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>SHRIMP_WORKER_THREADS=3 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>MAGICK_THREAD_LIMIT=4 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>shrimp.app -p 8080 -i ...</code> </pre> <br>  O a trav칠s de argumentos de l칤nea de comando, por ejemplo: <br><br><pre> <code class="hljs powershell">MAGICK_THREAD_LIMIT=<span class="hljs-number"><span class="hljs-number">4</span></span> \ shrimp.app <span class="hljs-literal"><span class="hljs-literal">-p</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-literal"><span class="hljs-literal">-i</span></span> ... -<span class="hljs-literal"><span class="hljs-literal">-io</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-literal"><span class="hljs-literal">-worker</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Los valores especificados a trav칠s de la l칤nea de comando tienen una prioridad m치s alta. <br><br>  Cabe destacar que MAGICK_THREAD_LIMIT afecta solo a aquellas operaciones que ImageMagick realiza por s칤 mismo.  Por ejemplo, el cambio de tama침o lo realiza ImageMagick.  Pero la conversi칩n de un formato a otro ImageMagick delega a bibliotecas externas.  Y c칩mo se paralelizan las operaciones en estas bibliotecas externas es un tema separado que no entendimos. <br><br><h1>  Conclusi칩n </h1><br>  Quiz치s, en esta versi칩n de Shrimp, llevamos nuestro proyecto de demostraci칩n a un estado aceptable.  Aquellos que quieran ver y experimentar pueden encontrar los textos fuente de Shrimp en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BitBucket</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> .  Tambi칠n puede encontrar el Dockerfile all칤 para construir camarones para sus experimentos. <br><br>  En general, hemos logrado nuestros objetivos que nos propusimos al comenzar este proyecto de demostraci칩n.  Aparecieron varias ideas para el desarrollo posterior de RESTinio y SObjectizer, y algunas de ellas ya han encontrado su forma de realizaci칩n.  Por lo tanto, si el camar칩n se desarrollar치 en alg칰n lugar m치s completamente depende de preguntas y deseos.  Si los hay, entonces los camarones pueden expandirse.  De lo contrario, Shrimp seguir치 siendo un proyecto de demostraci칩n y un campo de entrenamiento para experimentar con nuevas versiones de RESTinio y SObjectizer. <br><br>  En conclusi칩n, me gustar칤a expresar un agradecimiento especial a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">aensidhe</a> por su ayuda y asesoramiento, sin los cuales nuestros bailes con pandereta ser칤an mucho m치s largos y tristes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420353/">https://habr.com/ru/post/es420353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420343/index.html">L치mparas LED OK</a></li>
<li><a href="../es420345/index.html">Descripci칩n general del centro de datos IXcellerate (la sala de m치quinas m치s grande de la Federaci칩n de Rusia)</a></li>
<li><a href="../es420347/index.html">Aprende a crear tus propios comandos bash en menos de 4 minutos</a></li>
<li><a href="../es420349/index.html">Lista de verificaci칩n de outsourcing de TI: trabajar sin riesgos</a></li>
<li><a href="../es420351/index.html">C칩mo hacer b칰squedas de usuarios en GitHub usando Vue</a></li>
<li><a href="../es420355/index.html">Reloj inteligente Pebble: c칩mo convertirse en una rareza de la noche a la ma침ana</a></li>
<li><a href="../es420357/index.html">Vuex: estructurando grandes proyectos y trabajando con m칩dulos</a></li>
<li><a href="../es420359/index.html">Var, let o const? Problemas de alcance variable y ES6</a></li>
<li><a href="../es420361/index.html">Error al ejecutar TextBox.GetLineText en .NET WPF</a></li>
<li><a href="../es420363/index.html">Seminarios web de HPE en agosto-octubre: nuevos temas (+ SHD, pr치ctica de IA, almacenamiento de petabytes llave en mano)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>