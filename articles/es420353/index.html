<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤫 📃 📒 Hacemos que Shrimp sea aún más útil: agregue la transcodificación de imágenes a otros formatos ✡️ 🏂🏿 🔣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desde principios de 2017, nuestro pequeño equipo ha estado desarrollando la biblioteca RESTinio OpenSource para incrustar un servidor HTTP en aplicaci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hacemos que Shrimp sea aún más útil: agregue la transcodificación de imágenes a otros formatos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420353/"><img src="https://habrastorage.org/webt/7w/iy/b5/7wiyb5u0fpwa1duglcppwofjloa.jpeg"><br><br>  Desde principios de 2017, nuestro pequeño equipo ha estado desarrollando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca RESTinio OpenSource</a> para incrustar un servidor HTTP en aplicaciones C ++.  Para nuestra gran sorpresa, de vez en cuando recibimos preguntas de la categoría "¿Y por qué podría ser necesario un servidor HTTP C ++ incrustado?"  Desafortunadamente, las preguntas simples son las más difíciles de responder.  A veces la mejor respuesta es el código de muestra. <br><br>  Hace un par de meses comenzamos un pequeño <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto de demostración, Shrimp</a> , que demuestra claramente un escenario típico, bajo el cual nuestra biblioteca se "afila".  El proyecto de demostración es un servicio web simple que recibe solicitudes para escalar imágenes almacenadas en el servidor y que devuelve una imagen del tamaño que necesita el usuario. <br><br>  Este proyecto de demostración es bueno porque, en primer lugar, requiere integración con código escrito y funcionando correctamente hace mucho tiempo en C o C ++ (en este caso, ImageMagick).  Por lo tanto, debe quedar claro por qué tiene sentido incrustar el servidor HTTP en una aplicación C ++. <br><br>  Y, en segundo lugar, en este caso, se requiere un procesamiento asíncrono de las solicitudes para que el servidor HTTP no se bloquee mientras se escala la imagen (y esto puede llevar cientos de milisegundos o incluso segundos).  Y comenzamos el desarrollo de RESTinio precisamente porque no pudimos encontrar un servidor integrado C ++ cuerdo enfocado específicamente en el procesamiento de solicitudes asíncronas. <br><br>  Construimos el trabajo en camarones de forma iterativa: primero, se hizo y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">describió</a> la versión más simple, que solo escalaba las imágenes.  Luego arreglamos una serie de deficiencias de la primera versión y lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">describimos en el segundo artículo</a> .  Finalmente, pudimos ampliar la funcionalidad de Shrimp una vez más: se agregó la conversión de imágenes de un formato a otro.  Sobre cómo se hizo esto y se discutirá en este artículo. <br><a name="habracut"></a><br><h1>  Soporte de formato de destino </h1><br>  Entonces, en la próxima versión de Shrimp, agregamos la capacidad de dar una imagen a escala en un formato diferente.  Entonces, si emite una solicitud de camarones del formulario: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920"</span></span></code> </pre> <br>  entonces Shrimp representará la imagen en el mismo formato JPG que la imagen original. <br><br>  Pero si agrega el parámetro de formato de destino a la URL, entonces Shrimp convierte la imagen al formato de destino especificado.  Por ejemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920&amp;target-format=webp"</span></span></code> </pre> <br>  En este caso, Shrimp representará la imagen en formato webp. <br><br>  Shrimp actualizado admite cinco formatos de imagen: jpg, png, gif, webp y heic (también conocido como HEIF).  Puede experimentar con varios formatos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en una página web especial</a> : <br><br><img src="https://habrastorage.org/webt/99/ab/ke/99abkec8ode-lxyxufceqjmwxt8.png"><br><br>  (en esta página no hay forma de seleccionar el formato heic, porque los navegadores de escritorio normales no admiten este formato de forma predeterminada). <br><br>  Para admitir el formato de destino en Shrimp, fue necesario modificar ligeramente el código de Shrimp (lo cual nos sorprendió a nosotros mismos, porque realmente hubo pocos cambios).  Pero por otro lado, tuve que jugar con el ensamblaje de ImageMagick, que nos sorprendió aún más, ya que  Anteriormente, tuvimos que lidiar con esta cocina, por una afortunada coincidencia.  Pero hablemos de todo en orden. <br><br><h2>  ImageMagick debe comprender diferentes formatos </h2><br>  ImageMagick utiliza bibliotecas externas para codificar / decodificar imágenes: libjpeg, libpng, libgif, etc.  Estas bibliotecas deben instalarse en el sistema antes de configurar y construir ImageMagick. <br><br>  Lo mismo debería suceder para que ImageMagick admita formatos webp y heic: primero debe compilar e instalar libwebp y libheif, luego configurar e instalar ImageMagick.  Y si todo es simple con libwebp, entonces alrededor de libheif tuve que bailar con una pandereta.  Aunque después de un tiempo, después de que todo finalmente se había reunido y funcionado, ya no estaba claro: ¿por qué tuviste que recurrir a una pandereta, todo parece ser trivial?  ;) <br><br>  En general, si alguien quiere hacerse amigo de heic e ImageMagick, deberá instalar: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">x265 de videolan.org</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libde265</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libheif</a> </li></ul><br>  Está en este orden (puede que tenga que instalar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nasm</a> para que x265 funcione a la velocidad máxima).  Luego, al emitir el comando <i>./configure</i> , ImageMagick podrá encontrar todo lo que necesita para admitir archivos .heic. <br><br><h2>  Soporte para formato de destino en la cadena de consulta de solicitudes entrantes </h2><br>  Después de que nos hicimos amigos de ImageMagick con los formatos webp y heic, es hora de modificar el código de Shrimp.  En primer lugar, debemos aprender a reconocer el argumento del formato de destino en las solicitudes HTTP entrantes. <br><br>  Desde el punto de vista RESTinio, esto no es un problema en absoluto.  Bueno, otro argumento apareció en la cadena de consulta, ¿y qué?  Pero desde el punto de vista de Shrimp, la situación resultó ser algo más complicada, por lo que el código de la función responsable de analizar la solicitud HTTP se volvió más complicado. <br><br>  El hecho es que antes era necesario distinguir solo dos situaciones: <br><br><ul><li>  vino una solicitud de la forma "/filename.ext" sin ningún otro parámetro.  Entonces solo necesita dar al archivo "filename.ext" tal como está; </li><li>  Se recibió una solicitud con el formato "/filename.ext?op=resize &amp; ...".  En este caso, debe escalar la imagen del archivo "filename.ext". </li></ul><br>  Pero después de agregar el formato de destino, necesitamos distinguir entre cuatro situaciones: <br><br><ul><li>  vino una solicitud de la forma "/filename.ext" sin ningún otro parámetro.  Por lo tanto, solo necesita dar al archivo "filename.ext" tal como está, sin escalar y sin transcodificar a otro formato; </li><li>  vino una solicitud de la forma "/filename.ext?target-format=fmt" sin ningún otro parámetro.  Significa tomar una imagen del archivo "filename.ext" y transcodificarla al formato "fmt" mientras se conservan los tamaños originales; </li><li>  llegó una solicitud de la forma "/filename.ext?op=resize &amp; ..." pero sin formato de destino.  En este caso, necesita escalar la imagen del archivo "filename.ext" y darle el formato original; </li><li>  Se recibió una solicitud con el formato "/filename.ext?op=resize&amp;...&amp;target-format=fmt".  En este caso, debe realizar el escalado y luego transcodificar el resultado al formato "fmt". </li></ul><br>  Como resultado, la función para determinar los parámetros de consulta tomó la <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">siguiente forma</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> add_transform_op_handler( const app_params_t &amp; app_params, http_req_router_t &amp; router, so_5::mbox_t req_handler_mbox ) { router.http_get( R"(/:path(.*)\.:ext(.{3,4}))", restinio::path2regex::options_t{}.<span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ), [req_handler_mbox, &amp;app_params]( auto req, auto params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( has_illegal_path_components( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().path() ) ) { //     . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } //   . const auto qp = restinio::parse_query( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().query() ); const auto target_format = qp.get_param( "target-format"sv ); //        // .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>,    //   .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>  // ,    ,  //    . const auto image_format = try_detect_target_image_format( params[ "ext" ], target_format ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !image_format ) { //     .   . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !qp.size() ) { //    ,    . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serve_as_regular_file( app_params.m_storage.m_root_dir, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ), *image_format ); } const auto operation = qp.get_param( "op"sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( operation &amp;&amp; "resize"sv != *operation ) { //    ,     resize. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !operation &amp;&amp; !target_format ) { //      op=resize, //   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=something. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } handle_resize_op_request( req_handler_mbox, *image_format, qp, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } ); }</code> </pre> <br>  En la versión anterior de Shrimp, donde no era necesario transcodificar la imagen, trabajar con los parámetros de solicitud <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/3e8beeeb8935f84e492af188dd6fc6f2ba785657/dev/shrimp/">parecía un poco más fácil</a> . <br><br><h2>  Solicite la cola y la caché de imágenes adaptadas al formato de destino </h2><br>  El siguiente punto en la implementación del soporte de formato de destino fue el trabajo en la cola de solicitudes en espera y un caché de imágenes preparadas en el agente a_transform_manager.  Hablamos de estas cosas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con</a> más detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el artículo anterior</a> , pero recordemos un poco de qué se trataba. <br><br>  Cuando llega una solicitud de conversión de imagen, puede resultar que la imagen terminada con dichos parámetros ya esté en el caché.  En este caso, no necesita hacer nada, solo envíe la imagen desde el caché en respuesta.  Si la imagen necesita ser transformada, puede resultar que no hay trabajadores libres en este momento y que debe esperar hasta que aparezca.  Para hacer esto, la información de la solicitud debe estar en cola.  Pero al mismo tiempo, es necesario verificar la unicidad de las solicitudes: si tenemos tres solicitudes idénticas en espera de procesamiento (es decir, necesitamos convertir la misma imagen de la misma manera), entonces solo debemos procesar la imagen una vez y dar el resultado del procesamiento en respuesta a estas tres solicitudes.  Es decir  En la cola de espera, se deben agrupar solicitudes idénticas. <br><br>  Anteriormente en Shrimp, utilizamos una clave compuesta simple para buscar en el caché de imágenes y la cola de espera: una <a href="">combinación del nombre del archivo original y las opciones de cambio de tamaño de la imagen</a> .  Ahora, dos nuevos factores tuvieron que ser tomados en cuenta: <br><br><ul><li>  en primer lugar, el formato de la imagen de destino (es decir, la imagen original puede estar en jpg y la imagen resultante puede estar en png); </li><li>  en segundo lugar, el hecho de que escalar la imagen puede no ser necesario.  Esto sucede en una situación en la que el cliente solicita solo la conversión de la imagen de un formato a otro, pero con el tamaño original de la imagen preservado. </li></ul><br>  Debo decir que aquí seguimos el camino más simple, sin tratar de optimizar de alguna manera nada.  Por ejemplo, uno podría intentar hacer dos cachés: uno almacenaría imágenes en el formato original, pero escalado al tamaño deseado, y en el segundo, las imágenes escaladas convertidas al formato de destino. <br><br>  ¿Por qué se necesitaría tal doble caché?  El hecho es que al transformar imágenes, las dos operaciones más costosas en el tiempo son cambiar el tamaño y serializar la imagen al formato de destino.  Por lo tanto, si recibimos una solicitud para escalar la imagen example.jpg a un tamaño de 1920 de ancho y transformarla en formato webp, entonces podríamos almacenar dos imágenes en nuestra memoria: example_1920px_width.jpg y example_1920px_width.webp.  Daríamos una imagen example_1920px_width.webp cuando recibimos una segunda solicitud.  Pero la imagen example_1920px_width.jpg podría usarse al recibir solicitudes para escalar example.jpg a un tamaño de 1920 de ancho y transformarlo en formato heic.  Podríamos omitir la operación de cambio de tamaño y hacer solo la conversión de formato (es decir, la imagen terminada example_1920px_width.jpg se transcodificaría al formato heic). <br><br>  Otra oportunidad potencial: cuando llega una solicitud para transcodificar una imagen a otro formato sin cambiar el tamaño, puede determinar el tamaño real de la imagen y usar este tamaño dentro de la clave compuesta.  Por ejemplo, deje que example.jpg tenga un tamaño de 3000x2000 píxeles.  Si luego recibimos una solicitud para escalar example.jpg a 2000px de altura, entonces podemos determinar de inmediato que ya tenemos una imagen de este tamaño. <br><br>  En teoría, todas estas consideraciones merecen atención.  Pero desde un punto de vista práctico, no está claro qué tan alta es la probabilidad de tal desarrollo de eventos.  Es decir  ¿con qué frecuencia recibiremos una solicitud para escalar example.jpg a 1920px con conversión a webp, y luego una solicitud para la misma escala de la misma imagen, pero con conversión a png?  No tener estadísticas reales es difícil de decir.  Por lo tanto, decidimos no complicarnos la vida en nuestro proyecto de demostración, sino ir primero por el camino más simple.  Con la expectativa de que si alguien necesita esquemas de almacenamiento en caché más avanzados, esto se puede agregar más tarde, a partir de escenarios reales, no ficticios, para usar Shrimp. <br><br>  Como resultado, en la versión actualizada de Shrimp, expandimos ligeramente la clave, agregando también un parámetro como el formato de destino: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resize_request_key_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_path; <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> m_format; <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> m_params; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format, <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params ) : m_path{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(path) } , m_format{ format } , m_params{ params } {} [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> &amp; o ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( m_path, m_format, m_params ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( o.m_path, o.m_format, o.m_params ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_path; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_format; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_params; } };</code> </pre> <br>  Es decir  solicitud de cambio de tamaño example.jpg hasta 1920px con conversión a png difiere del mismo cambio de tamaño, pero con conversión a webp o heic. <br><br>  Pero el foco principal se esconde <a href="">en la nueva implementación de la clase resize_params_t</a> , que determina los nuevos tamaños de la imagen escalada.  <a href="">Anteriormente, esta clase</a> admitía tres opciones: solo se configuraba el ancho, solo se ajustaba la altura o se configuraba el lado largo (la altura o el ancho están determinados por el tamaño de imagen actual).  En consecuencia, el <a href="">método resize_params_t :: value ()</a> siempre devolvió algún valor real (qué valor fue determinado por el <a href="">método resize_params_t :: mode ()</a> ). <br><br>  Pero en el nuevo Shrimp, se agregó otro modo: keep_original, lo que significa que no se realiza el escalado y la imagen se representa en su tamaño original.  Para admitir este modo, resize_params_t tuvo que hacer algunos cambios.  En primer lugar, ahora el <a href="">método resize_params_t :: make ()</a> determina si se usa el modo keep_original (se considera que este modo se usa si no se especifica ninguno de los parámetros ancho, alto y máximo en la cadena de consulta de la solicitud entrante).  Esto nos permitió no reescribir la función <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">handle_resize_op_request ()</a> , que empuja la solicitud para escalar la imagen que se ejecutará. <br><br>  En segundo lugar, el <a href="">método resize_params_t :: value ()</a> ahora puede llamarse no siempre, sino solo cuando el modo de escala difiere de keep_original. <br><br>  Pero lo más importante es que <a href="">resize_params_t :: operator &lt;()</a> continuó funcionando según lo previsto. <br><br>  Gracias a todos estos cambios en a_transform_manager, tanto el caché de imágenes escaladas como la cola de solicitudes en espera se han mantenido igual.  Pero ahora, la información sobre varias consultas se almacena en estas estructuras de datos.  Por lo tanto, la clave {"example.jpg", "jpg", keep_original} diferirá tanto de la clave {"example.jpg", "png", keep_original}, como de la clave {"example.jpg", "jpg", ancho = 1920px}. <br><br>  Resultó que habiendo estropeado un poco la definición de estructuras de datos tan simples como resize_params_t y resize_params_key_t, evitamos alterar estructuras más complejas como el caché de imágenes resultantes y la cola de solicitudes en espera. <br><br><h2>  Soporte para formato de destino en a_transformer </h2><br>  Bueno, el paso final para admitir el formato de destino es expandir la lógica del agente a_transformer para que la imagen, posiblemente ya escalada, se convierta al formato de destino. <br><br>  Resultó ser el más fácil de hacer, todo lo que se necesitaba era expandir el código del <a href="">método a_transform_t :: handle_resize_request ()</a> : <br><br><pre> <code class="hljs pgsql">[[nodiscard]] a_transform_manager_t::resize_result_t::result_t a_transformer_t::handle_resize_request( const <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_request_key_t &amp; key ) { try { m_logger-&gt;trace( "transformation started; request_key={}", key ); auto image = load_image( key.path() ); const auto resize_duration = measure_duration( [&amp;]{ //       //    keep_original. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_params_t::mode_t::keep_original != key.params().mode() ) { <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize( key.params(), total_pixel_count, image ); } } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "resize finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( resize_duration).count() ); image.magick( magick_from_image_format( key.format() ) ); datasizable_blob_shared_ptr_t blob; const auto serialize_duration = measure_duration( [&amp;] { blob = make_blob( image ); } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "serialization finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( serialize_duration).count() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::successful_resize_t{ std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(blob), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( resize_duration), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( serialize_duration) }; } catch( const std::<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> &amp; x ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::failed_resize_t{ x.what() }; } }</code> </pre> <br>  En comparación <a href="">con la versión anterior,</a> hay dos adiciones fundamentales. <br><br>  En primer lugar, llamar al método image.magick () verdaderamente mágico después de cambiar el tamaño.  Este método le dice a ImageMagick el formato de imagen resultante.  Al mismo tiempo, la representación de la imagen en la memoria no cambia: ImageMagick continúa almacenándola como le conviene.  Pero luego el valor establecido por el método magick () se tendrá en cuenta durante la llamada posterior a Image :: write (). <br><br>  En segundo lugar, la versión actualizada registra el tiempo que lleva serializar la imagen al formato especificado.  La nueva versión de Shrimp ahora repara por separado el tiempo dedicado a escalar y el tiempo dedicado a la conversión al formato de destino. <br><br>  El resto del agente a_transformer_t no ha sufrido ningún cambio. <br><br><h1>  Paralelización de ImageMagick </h1><br>  Por defecto, ImageMagic está construido con soporte OpenMP.  Es decir  Es posible paralelizar operaciones en imágenes que realiza ImageMagick.  Puede controlar la cantidad de flujos de trabajo que ImageMagick usa en este caso utilizando la variable de entorno MAGICK_THREAD_LIMIT. <br><br>  Por ejemplo, en mi máquina de prueba con el valor MAGICK_THREAD_LIMIT = 1 (es decir, sin paralelización real), obtengo los siguientes resultados: <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1323</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1086.72</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">236.276</span></span></code> </pre><br>  El tiempo dedicado al cambio de tamaño se indica en el encabezado Shrimp-Resize-Time.  En este caso, es 1086.72ms. <br><br>  Pero si configura MAGICK_THREAD_LIMIT = 3 en la misma máquina y ejecuta Shrimp, obtenemos valores diferentes: <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">779.901</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">558.246</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">221.655</span></span></code> </pre> <br>  Es decir  El tiempo de cambio de tamaño se redujo a 558.25ms. <br><br>  En consecuencia, dado que ImageMagick brinda la capacidad de paralelizar los cálculos, puede aprovechar esta oportunidad.  Pero al mismo tiempo, es deseable poder controlar cuántos hilos de trabajo toma Shrimp para sí mismo.  En versiones anteriores de Shrimp, no era posible influir en cuántos flujos de trabajo crea Shrimp.  Y en la versión actualizada de Shrimp, esto se puede hacer.  O a través de variables de entorno, por ejemplo: <br><br><pre> <code class="hljs tex">SHRIMP_IO_THREADS=1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>SHRIMP_WORKER_THREADS=3 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>MAGICK_THREAD_LIMIT=4 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>shrimp.app -p 8080 -i ...</code> </pre> <br>  O a través de argumentos de línea de comando, por ejemplo: <br><br><pre> <code class="hljs powershell">MAGICK_THREAD_LIMIT=<span class="hljs-number"><span class="hljs-number">4</span></span> \ shrimp.app <span class="hljs-literal"><span class="hljs-literal">-p</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-literal"><span class="hljs-literal">-i</span></span> ... -<span class="hljs-literal"><span class="hljs-literal">-io</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-literal"><span class="hljs-literal">-worker</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Los valores especificados a través de la línea de comando tienen una prioridad más alta. <br><br>  Cabe destacar que MAGICK_THREAD_LIMIT afecta solo a aquellas operaciones que ImageMagick realiza por sí mismo.  Por ejemplo, el cambio de tamaño lo realiza ImageMagick.  Pero la conversión de un formato a otro ImageMagick delega a bibliotecas externas.  Y cómo se paralelizan las operaciones en estas bibliotecas externas es un tema separado que no entendimos. <br><br><h1>  Conclusión </h1><br>  Quizás, en esta versión de Shrimp, llevamos nuestro proyecto de demostración a un estado aceptable.  Aquellos que quieran ver y experimentar pueden encontrar los textos fuente de Shrimp en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BitBucket</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> .  También puede encontrar el Dockerfile allí para construir camarones para sus experimentos. <br><br>  En general, hemos logrado nuestros objetivos que nos propusimos al comenzar este proyecto de demostración.  Aparecieron varias ideas para el desarrollo posterior de RESTinio y SObjectizer, y algunas de ellas ya han encontrado su forma de realización.  Por lo tanto, si el camarón se desarrollará en algún lugar más completamente depende de preguntas y deseos.  Si los hay, entonces los camarones pueden expandirse.  De lo contrario, Shrimp seguirá siendo un proyecto de demostración y un campo de entrenamiento para experimentar con nuevas versiones de RESTinio y SObjectizer. <br><br>  En conclusión, me gustaría expresar un agradecimiento especial a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">aensidhe</a> por su ayuda y asesoramiento, sin los cuales nuestros bailes con pandereta serían mucho más largos y tristes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420353/">https://habr.com/ru/post/es420353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420343/index.html">Lámparas LED OK</a></li>
<li><a href="../es420345/index.html">Descripción general del centro de datos IXcellerate (la sala de máquinas más grande de la Federación de Rusia)</a></li>
<li><a href="../es420347/index.html">Aprende a crear tus propios comandos bash en menos de 4 minutos</a></li>
<li><a href="../es420349/index.html">Lista de verificación de outsourcing de TI: trabajar sin riesgos</a></li>
<li><a href="../es420351/index.html">Cómo hacer búsquedas de usuarios en GitHub usando Vue</a></li>
<li><a href="../es420355/index.html">Reloj inteligente Pebble: cómo convertirse en una rareza de la noche a la mañana</a></li>
<li><a href="../es420357/index.html">Vuex: estructurando grandes proyectos y trabajando con módulos</a></li>
<li><a href="../es420359/index.html">Var, let o const? Problemas de alcance variable y ES6</a></li>
<li><a href="../es420361/index.html">Error al ejecutar TextBox.GetLineText en .NET WPF</a></li>
<li><a href="../es420363/index.html">Seminarios web de HPE en agosto-octubre: nuevos temas (+ SHD, práctica de IA, almacenamiento de petabytes llave en mano)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>