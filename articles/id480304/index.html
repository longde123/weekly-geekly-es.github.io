<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëº üëêüèª üßìüèΩ Ketik inferensi dalam jscodeshift dan TypeScript üï¢ üçç üç™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketik inferensi dalam jscodeshift dan TypeScript 


 Dimulai dengan versi 6.0, jscodeshift mendukung kerja dengan TypeScript (TS). Dalam proses penuli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ketik inferensi dalam jscodeshift dan TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480304/"><h1 id="vyvod-tipov-v-jscodeshift-i-typescript">  Ketik inferensi dalam jscodeshift dan TypeScript </h1><br><p> Dimulai dengan versi 6.0, <a href="https://github.com/facebook/jscodeshift" rel="nofollow">jscodeshift</a> mendukung kerja dengan TypeScript (TS).  Dalam proses penulisan kode kode (transformasi), Anda mungkin perlu mengetahui jenis variabel yang tidak memiliki anotasi eksplisit.  Sayangnya, jscodeshift tidak menyediakan sarana untuk menyimpulkan tipe dari kotak. </p><a name="habracut"></a><br><p>  Pertimbangkan sebuah contoh.  Misalkan kita ingin menulis transformasi yang menambahkan tipe pengembalian eksplisit untuk fungsi dan metode kelas.  Yaitu  memiliki di pintu masuk: </p><br><pre><code class="plaintext hljs">function foo(x: number) { return x; }</code> </pre> <br><p>  Kami ingin mendapatkan output: </p><br><pre> <code class="plaintext hljs">function foo(x: number): number { return x; }</code> </pre> <br><p>  Sayangnya, dalam kasus umum, solusi untuk masalah seperti itu sangat tidak penting.  Berikut ini beberapa contohnya: </p><br><pre> <code class="plaintext hljs">function toString(x: number) { return '' + x; } function toInt(str: string) { return parseInt(str); } function toIntArray(strings: string[]) { return strings.map(Number.parseInt); } class Foo1 { constructor(public x = 0) { } getX() { return this.x; } } class Foo2 { x: number; constructor(x = 0) { this.x = x; } getX() { return this.x; } } function foo1(foo: Foo1) { return foo.getX(); } function foo2(foo: Foo2) { return foo.getX(); }</code> </pre> <br><p>  Untungnya, masalah tipe inferensi telah diselesaikan di dalam kompiler TS.  <a href="https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API" rel="nofollow">API kompiler</a> menyediakan cara jenis inferensi yang dapat Anda gunakan untuk menulis transformasi. </p><br><p>  Namun, Anda tidak bisa hanya mengambil dan menggunakan kompiler TS dengan mengganti parser jscodeshift.  Faktanya adalah bahwa jscodeshift mengharapkan pohon sintaksis abstrak (AST) dari parser eksternal dalam format <a href="https://github.com/estree/estree" rel="nofollow">ESTree</a> .  Dan AST kompiler TS tidak. </p><br><p>  Tentu saja, seseorang dapat menggunakan kompiler TS tanpa menggunakan jscodeshift, menulis transformasi dari awal.  Atau gunakan salah satu alat yang ada di komunitas TS, misalnya, <a href="https://github.com/dsherret/ts-morph" rel="nofollow">ts-morph</a> .  Tetapi bagi banyak orang, jscodeshift akan menjadi solusi yang lebih akrab dan ekspresif.  Karena itu, kami akan mempertimbangkan lebih lanjut bagaimana mengatasi batasan ini. </p><br><p>  Idenya adalah untuk mendapatkan pemetaan dari AST parser jscodeshift (selanjutnya ESTree) ke AST kompiler TS (selanjutnya TSTree), dan kemudian menggunakan alat inferensi tipe kompiler TS.  Selanjutnya, kami akan mempertimbangkan dua cara untuk mengimplementasikan ide ini. </p><br><h2 id="otobrazhenie-s-ispolzovaniem-nomerov-strok-i-stolbcov">  Tampilan Menggunakan Nomor Baris dan Kolom </h2><br><p>  Metode pertama menggunakan nomor baris dan kolom (posisi) node untuk menemukan pemetaan dari TSTree ke ESTree.  Terlepas dari kenyataan bahwa dalam kasus umum posisi node mungkin tidak bersamaan, hampir selalu mungkin untuk menemukan tampilan yang diinginkan dalam setiap kasus tertentu. </p><br><p>  Jadi, mari kita menulis transformasi yang akan melakukan tugas menambahkan anotasi eksplisit.  Biarkan saya mengingatkan Anda, pada output kita harus mendapatkan yang berikut: </p><br><pre> <code class="plaintext hljs">function toString(x: number): number { return '' + x; } function toInt(str: string): number { return parseInt(str); } function toIntArray(strings: string[]): number[] { return strings.map(Number.parseInt); } class Foo1 { constructor(public x = 0) { } getX(): number { return this.x; } } class Foo2 { x: number; constructor(x = 0) { this.x = x; } getX(): number { return this.x; } } function foo1(foo: Foo1): number { return foo.getX(); } function foo2(foo: Foo2): number { return foo.getX(); }</code> </pre> <br><p>  Pertama, kita perlu membangun TSTree dan mendapatkan <code>typeChecker</code> compiler <code>typeChecker</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compilerOptions = { <span class="hljs-attr"><span class="hljs-attr">target</span></span>: ts.ScriptTarget.Latest }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> program = ts.createProgram([path], compilerOptions); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sourceFile = program.getSourceFile(path); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> typeChecker = program.getTypeChecker();</code> </pre> <br><p>  Selanjutnya, buat pemetaan dari ESTree ke TSTree menggunakan posisi awal.  Untuk melakukan ini, kita akan menggunakan <code>Map</code> dua tingkat (level pertama untuk baris, level kedua untuk kolom, hasilnya adalah simpul TSTree): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> locToTSNodeMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> esTreeNodeToTSNode = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ loc: { start: { line, column } } }</span></span></span><span class="hljs-function">) =&gt;</span></span> locToTSNodeMap.has(line) ? locToTSNodeMap.get(line).get(column) : <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildLocToTSNodeMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart(sourceFile)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nextLine = line + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!locToTSNodeMap.has(nextLine)) locToTSNodeMap.set(nextLine, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>()); locToTSNodeMap.get(nextLine).set(character, node); ts.forEachChild(node, buildLocToTSNodeMap); }(sourceFile));</code> </pre> <br><p>  Perlu untuk menyesuaikan nomor baris, seperti  di TSTree, nomor baris mulai dari nol, dan di ESTree, dari satu. </p><br><p>  Selanjutnya, kita perlu melihat-lihat semua fungsi dan metode kelas, memeriksa jenis kembali dan jika itu <code>null</code> , tambahkan anotasi jenis: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ast = j(source); ast .find(j.FunctionDeclaration) .forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ value }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.returnType === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) value.returnType = getReturnType(esTreeNodeToTSNode(value)); }); ast .find(j.ClassMethod, { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'method'</span></span> }) .forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ value }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.returnType === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) value.returnType = getReturnType(esTreeNodeToTSNode(value).parent); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ast.toSource();</code> </pre> <br><p>  Saya harus menyesuaikan kode untuk mendapatkan node metode kelas, karena  pada posisi awal node metode di ESTree di TSTree adalah node dari metode identifier (oleh karena itu kami menggunakan <code>parent</code> ). </p><br><p>  Akhirnya, kami menulis kode untuk menerima anotasi dari tipe pengembalian: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReturnTypeFromString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">typeString</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ret; j(<span class="hljs-string"><span class="hljs-string">`function foo(): </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${typeString}</span></span></span><span class="hljs-string"> { }`</span></span>) .find(j.FunctionDeclaration) .some(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ value: { returnType } }</span></span></span><span class="hljs-function">) =&gt;</span></span> ret = returnType); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReturnType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getReturnTypeFromString( typeChecker.typeToString( typeChecker.getReturnTypeOfSignature( typeChecker.getSignatureFromDeclaration(node) ) ) ); }</code> </pre> <br><p>  Daftar lengkap: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typescript'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ source, path }, { j }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compilerOptions = { <span class="hljs-attr"><span class="hljs-attr">target</span></span>: ts.ScriptTarget.Latest }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> program = ts.createProgram([path], compilerOptions); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sourceFile = program.getSourceFile(path); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> typeChecker = program.getTypeChecker(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> locToTSNodeMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> esTreeNodeToTSNode = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ loc: { start: { line, column } } }</span></span></span><span class="hljs-function">) =&gt;</span></span> locToTSNodeMap.has(line) ? locToTSNodeMap.get(line).get(column) : <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">function</span></span></span></span><span class="hljs-function"><span class="hljs-params"> buildLocToTSNodeMap(node</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line</span></span></span><span class="hljs-function">, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">character</span></span></span><span class="hljs-function"> } = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sourceFile</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getLineAndCharacterOfPosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node.getStart(sourceFile</span></span></span><span class="hljs-function">)); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nextLine</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line</span></span></span><span class="hljs-function"> + 1; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">!locToTSNodeMap.has(nextLine</span></span></span><span class="hljs-function">)) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locToTSNodeMap</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">set</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nextLine, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Map</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">)); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locToTSNodeMap</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nextLine</span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">set</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">character, node</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ts</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">forEachChild</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node, buildLocToTSNodeMap</span></span></span><span class="hljs-function">); }(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sourceFile</span></span></span><span class="hljs-function">)); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getReturnTypeFromString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">typeString</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">let</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ret</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">j</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`function foo(): </span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${typeString}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"> { }`</span></span></span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">find</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">j.FunctionDeclaration</span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">some</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ value: { returnType } }</span></span></span><span class="hljs-function">) =&gt;</span></span> ret = returnType); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReturnType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getReturnTypeFromString( typeChecker.typeToString( typeChecker.getReturnTypeOfSignature( typeChecker.getSignatureFromDeclaration(node) ) ) ); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ast = j(source); ast .find(j.FunctionDeclaration) .forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ value }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.returnType === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) value.returnType = getReturnType(esTreeNodeToTSNode(value)); }); ast .find(j.ClassMethod, { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'method'</span></span> }) .forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ value }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.returnType === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) value.returnType = getReturnType(esTreeNodeToTSNode(value).parent); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ast.toSource(); } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parser = <span class="hljs-string"><span class="hljs-string">'ts'</span></span>;</code> </pre> <br><h2 id="ispolzovanie-parsera-typescript-eslint">  Menggunakan parser typescript-eslint </h2><br><p>  Seperti yang ditunjukkan di atas, meskipun tampilan menggunakan posisi node berfungsi, itu tidak memberikan hasil yang tepat dan kadang-kadang membutuhkan "penyetelan manual".  Solusi yang lebih umum adalah menulis pemetaan eksplisit ESTree node ke TSTree.  Ini adalah cara kerja parser proyek <a href="https://github.com/typescript-eslint/typescript-eslint" rel="nofollow">typescript-eslint</a> .  Kami akan menggunakannya. </p><br><p>  Pertama, kita perlu mengganti <a href="https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/typescript-estree" rel="nofollow">parser</a> <a href="https://github.com/facebook/jscodeshift" rel="nofollow">jscodeshift</a> built-in <a href="https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/typescript-estree" rel="nofollow">ke parser typescript-eslint</a> .  Dalam kasus paling sederhana, kode ini terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parser = { parse(source) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typescriptEstree.parse(source); } };</code> </pre> <br><p>  Namun, kita harus sedikit menyulitkan kode untuk mendapatkan pemetaan node ESTree ke TSTree dan <code>typeChecker</code> .  Untuk ini, typescript-eslint menggunakan fungsi <code>parseAndGenerateServices</code> .  Agar semuanya berfungsi, kita harus meneruskan path ke file <code>.ts</code> dan path ke file konfigurasi <code>tsconfig.json</code> .  Karena tidak ada cara langsung untuk melakukan ini, Anda harus menggunakan variabel global (oh!): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parserState = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseWithServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">j, source, path, projectPath</span></span></span><span class="hljs-function">) </span></span>{ parserState.options = { <span class="hljs-attr"><span class="hljs-attr">filePath</span></span>: path, <span class="hljs-attr"><span class="hljs-attr">project</span></span>: projectPath }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">ast</span></span>: j(source), <span class="hljs-attr"><span class="hljs-attr">services</span></span>: parserState.services }; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parser = { parse(source) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parserState.options !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = parserState.options; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> parserState.options; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ast, services } = typescriptEstree.parseAndGenerateServices(source, options); parserState.services = services; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ast; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typescriptEstree.parse(source); } };</code> </pre> <br><p>  Setiap kali kita ingin mendapatkan seperangkat alat pengurai typescript-eslint yang diperluas, kita memanggil fungsi <code>parseWithServices</code> , di mana kita melewati parameter yang diperlukan (dalam kasus lain, kita masih menggunakan fungsi <code>j</code> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ast, <span class="hljs-attr"><span class="hljs-attr">services</span></span>: { program, esTreeNodeToTSNodeMap } } = parseWithServices(j, source, path, tsConfigPath); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> typeChecker = program.getTypeChecker(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> esTreeNodeToTSNode = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ original }</span></span></span><span class="hljs-function">) =&gt;</span></span> esTreeNodeToTSNodeMap.get(original);</code> </pre> <br><p>  Tinggal menulis kode untuk mem-bypass dan memodifikasi fungsi dan metode kelas: </p><br><pre> <code class="javascript hljs">ast .find(j.FunctionDeclaration) .forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ value }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.returnType === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) value.returnType = getReturnType(esTreeNodeToTSNode(value)); }); ast .find(j.MethodDefinition, { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'method'</span></span> }) .forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ value }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.value.returnType === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) value.value.returnType = getReturnType(esTreeNodeToTSNode(value)); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ast.toSource();</code> </pre> <br><p>  Perlu dicatat bahwa kita harus mengganti selektor <code>ClassMethod</code> dengan <code>ClassMethod</code> untuk mem-bypass metode kelas (kode akses ke nilai balik metode juga sedikit berubah).  Ini adalah spesifik dari parser naskah-skrip eslint.  <code>getReturnType</code> fungsi <code>getReturnType</code> identik dengan yang digunakan sebelumnya. </p><br><p>  Daftar lengkap: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> typescriptEstree <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@typescript-eslint/typescript-estree'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ source, path }, { j }, { tsConfigPath }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ast, <span class="hljs-attr"><span class="hljs-attr">services</span></span>: { program, esTreeNodeToTSNodeMap } } = parseWithServices(j, source, path, tsConfigPath); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> typeChecker = program.getTypeChecker(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> esTreeNodeToTSNode = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ original }</span></span></span><span class="hljs-function">) =&gt;</span></span> esTreeNodeToTSNodeMap.get(original); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReturnTypeFromString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">typeString</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ret; j(<span class="hljs-string"><span class="hljs-string">`function foo(): </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${typeString}</span></span></span><span class="hljs-string"> { }`</span></span>) .find(j.FunctionDeclaration) .some(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ value: { returnType } }</span></span></span><span class="hljs-function">) =&gt;</span></span> ret = returnType); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReturnType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getReturnTypeFromString( typeChecker.typeToString( typeChecker.getReturnTypeOfSignature( typeChecker.getSignatureFromDeclaration(node) ) ) ); } ast .find(j.FunctionDeclaration) .forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ value }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.returnType === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) value.returnType = getReturnType(esTreeNodeToTSNode(value)); }); ast .find(j.MethodDefinition, { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'method'</span></span> }) .forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ value }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.value.returnType === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) value.value.returnType = getReturnType(esTreeNodeToTSNode(value)); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ast.toSource(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parserState = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseWithServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">j, source, path, projectPath</span></span></span><span class="hljs-function">) </span></span>{ parserState.options = { <span class="hljs-attr"><span class="hljs-attr">filePath</span></span>: path, <span class="hljs-attr"><span class="hljs-attr">project</span></span>: projectPath }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">ast</span></span>: j(source), <span class="hljs-attr"><span class="hljs-attr">services</span></span>: parserState.services }; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parser = { parse(source) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parserState.options !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = parserState.options; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> parserState.options; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ast, services } = typescriptEstree.parseAndGenerateServices(source, options); parserState.services = services; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ast; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typescriptEstree.parse(source); } };</code> </pre> <br><h2 id="plyusy-i-minusy-podhodov">  Pro dan kontra pendekatan </h2><br><h3 id="podhod-s-nomerami-strok-i-stolbcov">  Pendekatan Baris dan Kolom </h3><br><p>  Pro: </p><br><ul><li>  Itu tidak perlu mengesampingkan parser built-in jscodeshift. </li><li>  Fleksibilitas mentransfer konfigurasi dan teks sumber (Anda dapat mentransfer file dan baris / objek dalam memori, lihat di bawah). </li></ul><br><p>  Cons: </p><br><ul><li>  Tampilan node berdasarkan posisi tidak akurat dan dalam beberapa kasus memerlukan penyesuaian. </li></ul><br><h3 id="podhod-s-parserom-typescript-eslint">  Parser mendekati naskah-eslint </h3><br><p>  Pro: </p><br><ul><li>  Pemetaan node yang akurat dari satu AST ke yang lain. </li></ul><br><p>  Cons: </p><br><ul><li>  Struktur AST dari parser typescript-eslint sedikit berbeda dari parser bawaan jscodeshift. </li><li>  Kebutuhan untuk menggunakan file untuk mentransfer konfigurasi dan sumber TS. </li></ul><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Pendekatan pertama mudah ditambahkan ke proyek yang ada, karena  itu tidak memerlukan redefinisi parser, tetapi pemetaan node AST cenderung membutuhkan penyesuaian. </p><br><p>  Keputusan tentang pendekatan kedua sebaiknya dibuat terlebih dahulu, jika tidak, Anda mungkin harus menghabiskan waktu men-debug kode karena struktur AST yang berubah.  Di sisi lain, Anda akan memiliki pemetaan penuh dari beberapa node ke yang lain (dan sebaliknya). </p><br><h2 id="ps">  PS </h2><br><p>  Disebutkan di atas bahwa ketika menggunakan parser TS, Anda dapat mentransfer konfigurasi dan sumber teks baik dalam bentuk file dan dalam bentuk objek di memori.  Transfer konfigurasi sebagai objek dan transfer teks sumber sebagai file dipertimbangkan dalam contoh.  Berikut ini adalah kode fungsi yang memungkinkan Anda membaca konfigurasi dari file: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TsDiagnosticError</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(err) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(err) ? err.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> e.messageText).join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) : err.messageText); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.diagnostic = err; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tsGetCompilerOptionsFromConfigFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tsConfigPath, basePath = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'.'</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { config, error } = ts.readConfigFile(tsConfigPath, ts.sys.readFile); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TsDiagnosticError(error); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { options, errors } = ts.parseJsonConfigFileContent(config, tsGetCompilerOptionsFromConfigFile.host, basePath); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errors.length !== <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TsDiagnosticError(errors); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> options; } tsGetCompilerOptionsFromConfigFile.host = { <span class="hljs-attr"><span class="hljs-attr">fileExists</span></span>: ts.sys.fileExists, <span class="hljs-attr"><span class="hljs-attr">readFile</span></span>: ts.sys.readFile, <span class="hljs-attr"><span class="hljs-attr">readDirectory</span></span>: ts.sys.readDirectory, <span class="hljs-attr"><span class="hljs-attr">useCaseSensitiveFileNames</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> };</code> </pre> <br><p>  Dan buat program TS dari baris: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tsCreateStringSourceCompilerHost</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mockPath, source, compilerOptions, setParentNodes</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> host = ts.createCompilerHost(compilerOptions, setParentNodes); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getSourceFileOriginal = host.getSourceFile.bind(host); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> readFileOriginal = host.readFile.bind(host); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fileExistsOriginal = host.fileExists.bind(host); host.getSourceFile = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName, languageVersion, onError, shouldCreateNewSourceFile</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fileName === mockPath ? ts.createSourceFile(fileName, source, languageVersion) : getSourceFileOriginal(fileName, languageVersion, onError, shouldCreateNewSourceFile); }; host.readFile = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fileName === mockPath ? source : readFileOriginal(fileName); }; host.fileExists = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fileName === mockPath ? <span class="hljs-literal"><span class="hljs-literal">true</span></span> : fileExistsOriginal(fileName); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> host; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tsCreateStringSourceProgram</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">source, compilerOptions, mockPath = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'_source.ts'</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ts.createProgram([mockPath], compilerOptions, tsCreateStringSourceCompilerHost(mockPath, source, compilerOptions)); }</code> </pre> <br><h2 id="ssylki">  Referensi </h2><br><ul><li>  <a href="https://github.com/facebook/jscodeshift" rel="nofollow">jscodeshift</a> </li><li>  <a href="https://github.com/microsoft/TypeScript" rel="nofollow">TypeScript</a> </li><li>  <a href="https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API" rel="nofollow">Menggunakan Kompiler API</a> </li><li>  <a href="https://github.com/typescript-eslint/typescript-eslint" rel="nofollow">typescript-eslint</a> </li><li>  <a href="https://stackoverflow.com/questions/53804566/how-to-get-compileroptions-from-tsconfig-json" rel="nofollow"><code>How to get CompilerOptions</code> dari <code>tsconfig.json</code></a> </li><li>  <a href="https://stackoverflow.com/questions/53733138/how-do-i-type-check-a-snippet-of-typescript-code-in-memory" rel="nofollow">Bagaimana cara saya mengetikkan potongan kode TypeScript di memori?</a> </li><li>  <a href="https://stackoverflow.com/questions/49355257/use-compiler-api-for-type-inference" rel="nofollow">Gunakan kompiler API untuk inferensi tipe</a> </li><li>  <a href="https://stackoverflow.com/questions/47215069/how-to-use-typescript-compiler-api-to-get-normal-function-info-eg-returntype-p" rel="nofollow">bagaimana cara menggunakan Compiler API skrip untuk mendapatkan info fungsi normal, misalnya: returnType / parameter?</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480304/">https://habr.com/ru/post/id480304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480288/index.html">Apakah mungkin untuk mengirim dan menerima informasi tanpa batasan jarak dan kecepatan cahaya?</a></li>
<li><a href="../id480290/index.html">Laptop buatan rumah ZedRipper pada enam belas Z80</a></li>
<li><a href="../id480294/index.html">Visi alat berat berkecepatan tinggi di perangkat penyortiran suku cadang LEGO serbaguna</a></li>
<li><a href="../id480296/index.html">Pengembangan reaktif bot Telegram</a></li>
<li><a href="../id480300/index.html">Pada 2011, masalah apakah Nginx milik Igor Sysoev atau Rambler</a></li>
<li><a href="../id480306/index.html">Mengapa mengalahkan pintu yang tertutup?</a></li>
<li><a href="../id480310/index.html">Detektif Habra: rahasia editor berita</a></li>
<li><a href="../id480316/index.html">Cara mengurangi konsumsi modul wifi hingga sepuluh kali atau lebih</a></li>
<li><a href="../id480318/index.html">Pilihan acara gratis mendatang untuk pengembang di Moskow # 3 (16-24 Desember)</a></li>
<li><a href="../id480320/index.html">Sepuluh tahun ONYX di Rusia - bagaimana teknologi, pembaca, dan pasar telah berubah selama ini</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>