<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔡 👨🏼‍🚀 👨🏻 Nahtlose (fast) Migration zwischen wichtigen PostgreSQL-Versionen mithilfe der logischen Replikation 🏉 🍀 👨🏻‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In True Engineering musste bei einem Projekt die Version von PostgreSQL von 9.6 auf 11.1 geändert werden. 

 Warum? Die Datenbank des Projekts ist ber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nahtlose (fast) Migration zwischen wichtigen PostgreSQL-Versionen mithilfe der logischen Replikation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/437318/">  In True Engineering musste bei einem Projekt die Version von PostgreSQL von 9.6 auf 11.1 geändert werden. <br><br>  Warum?  Die Datenbank des Projekts ist bereits 1,5 TB groß und wächst.  Die Leistung ist eine der Hauptanforderungen an das System.  Und die Datenstruktur selbst entwickelt sich weiter: Neue Spalten werden hinzugefügt, vorhandene geändert.  Die neue Version von Postgres hat gelernt, wie man effizient arbeitet, indem neue Spalten mit einem Standardwert hinzugefügt werden, sodass keine benutzerdefinierten Krücken auf Anwendungsebene eingezäunt werden müssen.  Selbst in der neuen Version wurden mehrere neue Möglichkeiten zum Partitionieren von Tabellen hinzugefügt, was auch unter Bedingungen einer großen Datenmenge äußerst nützlich ist. <br><br>  Es wird also entschieden, dass wir migrieren.  Natürlich können Sie eine neue Version des PostgreSQL-Servers parallel zur alten Version erstellen, die Anwendung stoppen, die Datenbank mit dump / restore (oder pg_upgrade) verschieben und die Anwendung neu starten.  Diese Lösung passte aufgrund der Größe der Basis nicht zu uns. Außerdem arbeitet die Anwendung im Kampfmodus und es gibt nur wenige Minuten bis zur Ausfallzeit. <br><br>  Aus diesem Grund haben wir uns entschlossen, die Migration mithilfe der logischen Replikation in PostgreSQL mithilfe eines Plugins eines Drittanbieters namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pglogical zu versuchen</a> . <br><br>  Während des "Prozess" -Prozesses stießen wir auf eine sehr fragmentarische Dokumentation dieses Prozesses (und auf Russisch überhaupt nicht) sowie auf einige Fallstricke und nicht offensichtliche Nuancen.  In diesem Artikel möchten wir unsere Erfahrungen in Form eines Tutorials präsentieren. <br><br><img src="https://habrastorage.org/webt/cp/i7/oi/cpi7oixtsenmioqdrcyyotgagyk.png"><br><br>  <b>TL; DR</b> <br><br><ul><li>  Alles stellte sich heraus (nicht ohne Krücken, ein Artikel darüber). </li><li>  Sie können innerhalb der PostgreSQL-Version von 9.4 auf 11.x von jeder Version auf eine beliebige Version nach unten oder oben migrieren. </li><li>  Die Ausfallzeit entspricht der Zeit, die Ihre Anwendung benötigt, um die Verbindung zum neuen Datenbankserver wiederherzustellen (in unserem Fall war dies ein Neustart der gesamten Anwendung, in der Wildnis jedoch offensichtlich „mögliche Optionen“). </li></ul><a name="habracut"></a><br><h3>  Warum passte die "Stirn" -Lösung nicht zu uns? </h3><br>  Wie bereits erwähnt, besteht der einfachste Ausweg darin, die neue Version des PostgreSQL-Servers parallel zur alten Version zu erstellen, die Anwendung zu stoppen, die Datenbank mit dump / restore (oder pg_upgrade) zu verschieben und die Anwendung erneut zu starten.  Für Datenbanken mit kleinem Volumen ist dies im Prinzip eine durchaus geeignete Option (oder im Allgemeinen ist das Volumen unwichtig, wenn Sie die Möglichkeit haben, die Anwendung für den Zeitraum der "Transfusion" der Datenbank vom alten auf den neuen Server zu verlängern, unabhängig davon, wie lange diese Zeit dauert).  In unserem Fall benötigt die Datenbank jedoch etwa 1,5 TB auf der Festplatte, und das Verschieben ist keine Frage von Minuten, sondern von mehreren Stunden.  Die Anwendung arbeitet wiederum im Kampfmodus, und ich wollte Ausfallzeiten unbedingt länger als ein paar Minuten vermeiden. <br><br>  Gegen diese Option war auch die Tatsache, dass wir die Master-Slave-Replikation verwenden und den Slave-Server nicht sicher aus dem Workflow ausschalten können.  Um die Anwendung nach der Migration des Master-Servers von der alten Version von PostgreSQL auf die neue Version umzustellen, muss vor dem Starten der Anwendung ein neuer Slave-Server vorbereitet werden.  Und dies sind noch einige Stunden Ausfallzeit, bis der Slave erstellt wird (obwohl viel weniger als die Migration des Masters). <br><br>  Aus diesem Grund haben wir uns entschlossen, die Migration mithilfe der logischen Replikation in PostgreSQL mithilfe eines Plugins eines Drittanbieters namens pglogical zu versuchen. <br><br><h3>  allgemeine Informationen </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pglogical</a> ist ein logisches Replikationssystem, das die native logische Dekodierung in PostgreSQL verwendet und als PostgreSQL-Erweiterung implementiert ist.  Ermöglicht die Konfiguration der selektiven Replikation mithilfe des Abonnement- / Veröffentlichungsmodells.  Es ist nicht erforderlich, Trigger in der Datenbank zu erstellen oder externe Dienstprogramme für die Replikation zu verwenden. <br><br>  Die Erweiterung funktioniert mit jeder Version von PostgreSQL ab 9.4 (seit Logical Decoding erstmals in 9.4 veröffentlicht wurde) und ermöglicht Ihnen die Migration zwischen unterstützten Versionen von PostgreSQL in jede Richtung. <br><br>  Das manuelle Einrichten der Replikation mithilfe von pglogical manuell ist nicht sehr trivial, obwohl dies im Prinzip durchaus möglich ist.  Glücklicherweise gibt es ein Drittanbieter-Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pgrepup</a> zur Automatisierung des Konfigurationsprozesses, das wir verwenden werden. <br><br><h3>  Speicherplatz Memo </h3><br>  Da wir planen, die neue Version von PostgreSQL parallel zur alten Version auf denselben Servern zu aktualisieren, verdoppeln sich die Festplattenanforderungen für die Datenbank auf den Master- und Slave-Servern.  Es scheint, dass dies offensichtlich ist, aber ... Achten Sie einfach auf genügend freien Speicherplatz, bevor Sie mit der Replikation beginnen, um die ziellos verbrachten Jahre nicht zu bereuen. <br><br>  In unserem Fall waren Datenbankänderungen erforderlich, und das Speicherformat während der Migration zwischen 9.6 und 11 „schwillt“ nicht zugunsten der neuesten Version an, sodass der Speicherplatz nicht um 2, sondern um das 2,2-fache erhöht werden musste.  Lob LVM, dies kann im Zuge der Migration im laufenden Betrieb erfolgen. <br><br>  Im Allgemeinen kümmern Sie sich darum. <br><br><h3>  Installieren Sie PostgreSQL 11 auf dem Master </h3><br><blockquote>  Hinweis: Wir verwenden Oracle Linux. Alle folgenden Elemente werden für diese Distribution geschärft.  Es ist möglich, dass andere Linux-Distributionen eine kleine Überarbeitung einer Datei erfordern, aber es ist unwahrscheinlich, dass dies von Bedeutung ist. </blockquote><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   yum install https://download.postgresql.org/pub/repos/yum/11/redhat/rhel-7-x86_64/pgdg-oraclelinux11-11-2.noarch.rpm #   postgresql11 yum install postgresql11 postgresql11-devel postgresql11-server postgresql11-contrib #   /usr/pgsql-11/bin/postgresql-11-setup initdb</span></span></code> </pre> <br>  Das alte Datenverzeichnis befindet sich in <b>/var/lib/pgsql/9.6/data</b> , das neue in <b>/ var / lib / pgsql / 11 / data</b> <br><br>  Kopieren Sie die Zugriffseinstellungen ( <b>pg_hba.conf</b> ) und <b>Servereinstellungen</b> ( <b>postgresql.conf</b> ) von 9.6 auf 11. <br><br>  Um zwei PostgreSQL-Server auf demselben Computer <b>auszuführen</b> , ändern Sie in der Konfigurationskonfiguration <b>postgresql.conf</b> 11 den Port in 15432 (port = 15432). <br><br>  Hier müssen Sie sorgfältig <b>überlegen,</b> was Sie in der neuen Version von PostgreSQL in Ihrem Fall noch tun müssen, damit es mit Ihrer <b>postgresql.conf</b> beginnt (und Ihre Anwendung möglicherweise damit funktioniert).  In unserem Fall mussten die von uns in der neuen Version verwendeten PostgreSQL-Erweiterungen installiert werden.  Dies würde den Rahmen des Artikels sprengen. Lassen Sie das neue PostgreSQL einfach starten, funktionieren und ganz zu Ihnen passen :) <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  ,  ,  shared libraries, whatever... # .... #  systemctl enable postgresql-11 systemctl start postgresql-11</span></span></code> </pre> <br>  Wir schauen in <b>/ var / lib / pgsql / 11 / data / pg_log /</b> .  Alles ist gut?  Wir machen weiter! <br><br><h3>  Installieren und konfigurieren Sie pgrepup </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  python yum install python yum install python2-pip #  pgrepup pip install pgrepup #   pgrepup config</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/zg/xz/9o/zgxz9oct5l-qglkxyeyrqejh4we.png"><br><br>  Nuancen: <br><br><ol><li>  Als <b>app_owner geben wir</b> den Benutzer an, unter dem die PostgreSQL-Server ausgeführt werden. </li><li>  <b>Geben Sie</b> für <b>Datenbank</b> <b>template1 an</b> . </li><li>  <b>Benutzername</b> und <b>Passwort</b> - Daten für den Superuser-Zugriff.  In unserem Fall wurde die <b>Vertrauensmethode</b> in <b>pg_hba.conf</b> für lokale Verbindungen des <b>Postgres-</b> Benutzers angegeben, sodass Sie ein beliebiges Kennwort angeben können. </li></ol><br><h3>  Konfigurieren Sie die Replikation </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   pgrepup check</span></span></code> </pre><br>  Wir erhalten die Ausgabe einer Liste vieler Parameter, die nach Bedarf konfiguriert werden müssen. <br><br>  Beispiel für Überprüfungsergebnisse: <br><br><img src="https://habrastorage.org/webt/h3/wu/zm/h3wuzmcevo7idf-xlyrz3ae8av8.png"><br><br><img src="https://habrastorage.org/webt/58/zh/bb/58zhbbubdbfvzzgat051bviywqy.png"><br><br>  Alle Fehler während der Überprüfung müssen beseitigt werden.  In den Einstellungen beider Server sollten <b>wal_level = LOGICAL</b> (damit die logische Dekodierung funktioniert) festgelegt werden, die erforderlichen Einstellungen für die Replikations-Engine (Anzahl der Slots und <b>wal_senders</b> ).  Die Hinweise des Dienstprogramms pgrepup sind recht informativ, Fragen sollten in den meisten Punkten nicht auftauchen. <br><br>  Wir nehmen alle notwendigen Einstellungen vor, die pgrepup verlangt. <br><br>  In beiden Dateien <b>pg_hba.conf</b> fügen wir an der Eingabeaufforderung pgrepup Berechtigungen für den Benutzer hinzu, der die Replikation durchführen soll: <br><br><pre> <code class="bash hljs">host replication pgrepup_replication 127.0.0.1/32 md5 host all pgrepup_replication 127.0.0.1/32 md5</code> </pre> <br><h3>  Primärschlüssel hinzufügen </h3><br>  Damit die Replikation funktioniert, muss in allen Tabellen ein Primärschlüssel definiert sein. <br><br>  In unserem Fall war PK nicht überall, daher müssen Sie es zum Zeitpunkt der Replikation hinzufügen und am Ende der Replikation gegebenenfalls löschen. <br><br>  Eine Liste von Tabellen ohne PK erzeugt unter anderem eine <code>pgrepup check</code> .  Für alle Tabellen aus dieser Liste müssen Sie einen Primärschlüssel hinzufügen, der zu Ihnen passt.  In unserem Fall war es so etwas wie: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> %s <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> temporary_pk <span class="hljs-type"><span class="hljs-type">BIGSERIAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span></code> </pre> <br>  Das Dienstprogramm pgrepup verfügt über einen integrierten Befehl zum Ausführen dieses Vorgangs ( <code>pgrepup fix</code> ). Wenn es verwendet wird, wird sogar impliziert, dass diese temporären Spalten bei erfolgreicher Replikation automatisch gelöscht werden.  Leider war diese Funktionalität auf großen Basen so illusorisch und bezaubernd fehlerhaft, dass wir beschlossen, sie nicht zu verwenden, sondern diesen Vorgang manuell durchzuführen, da dies für uns praktisch ist. <br><br><h3>  Installieren Sie die pglogische Erweiterung </h3><br>  Anweisungen zur Installation der Erweiterung finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Die Erweiterung muss auf beiden Servern installiert sein. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#       curl https://access.2ndquadrant.com/api/repository/dl/default/release/9.6/rpm | bash curl https://access.2ndquadrant.com/api/repository/dl/default/release/11/rpm | bash #   yum install postgresql96-pglogical postgresql11-pglogical</span></span></code> </pre> <br>  Fügen Sie die Bibliothekslast in der <b>postgresql.conf</b> beider Server hinzu: <br><br><pre> <code class="bash hljs">shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pglogical'</span></span></code> </pre> <br><h3>  Installieren Sie die Erweiterung pgl_ddl_deploy </h3><br>  Dies ist eine Hilfserweiterung, die pgrepup für die logische DDL-Replikation verwendet. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      git clone https://github.com/enova/pgl_ddl_deploy.git #       PATH=/usr/pgsql-9.6/bin/:$PATH USE_PGXS=1 make USE_PGXS=1 make install make clean #       PATH=/usr/pgsql-11/bin/:$PATH make CLANG=true make install</span></span></code> </pre> <br>  Fügen Sie die Bibliothekslast in der <b>postgresql.conf</b> beider Server hinzu: <br><br><pre> <code class="bash hljs">shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pglogical,pgl_ddl_deploy'</span></span></code> </pre> <br><h3>  Änderungen überprüfen </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   postgresql systemctl restart postgresql-11</span></span></code> </pre> <br>  Jetzt <code>pgrepup check</code> Sie mit <code>pgrepup check</code> sicherstellen, dass mit dem Zielserver alles in Ordnung ist und alle Kommentare zum Zielserver vollständig entfernt wurden. <br><br>  Wenn alles in Ordnung ist, können Sie den alten Server neu starten.  Hier müssen Sie überlegen, wie Ihre Anwendung auf den Neustart des Datenbankservers reagiert. Vielleicht sollten Sie ihn zuerst stoppen. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  systemctl restart postgresql-9.6 #  pgrepup check</span></span></code> </pre> <br>  In der Ausgabe des Befehls sollten nun alle Elemente als OK markiert werden. <br><br>  Es scheint, dass Sie mit der Migration beginnen können, aber ... <br><br><h3>  Beheben Sie pgrepup-Fehler </h3><br>  In der aktuellen Version von pgrepup gibt es mehrere Fehler, die eine Migration unmöglich machen.  Pull-Anforderungen wurden gesendet, aber leider werden sie ignoriert, sodass Sie Korrekturen manuell vornehmen müssen. <br><br>  Wir gehen zum Installationsordner von pgrepup (unser Fall ist <b>/usr/lib/python2.7/site-packages/pgrepup/commands/</b> ). <br><br>  Mach es einmal.  <code>**kwargs</code> in jeder <b>* .py-</b> Datei die fehlenden <code>**kwargs</code> in die Funktionsbeschreibung ein.  Ein Bild ist besser als tausend Worte: <br><br><img src="https://habrastorage.org/webt/l3/zc/uo/l3zcuo2exe8lq_0u3gwv_nq8jty.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier verpflichten</a> . <br><br>  Mach zwei.  In <b>setup.py suchen</b> wir nach "sh -c", zwei Einträgen, alle mehrzeiligen Shell-Befehle müssen einzeilig sein. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier verpflichten</a> . <br><br><h3>  Starten Sie die Migration </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  pgrepup setup</span></span></code> </pre> <br>  Mit diesem Befehl bereitet pgrepup beide Server auf den Start der Replikation vor, erstellt einen Benutzer, konfiguriert pglogical und überträgt das Datenbankschema. <br><br><img src="https://habrastorage.org/webt/ww/km/jd/wwkmjdmmpmwyvgbdqyktohnhmmy.png"><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   pgrepup start</span></span></code> </pre> <br>  Er sagte: "Lass uns gehen!"  und winkte mit der Hand: <br><br><img src="https://habrastorage.org/webt/3k/xc/_r/3kxc_rgde-t7q6yuhtvwkol5acs.png"><br><br>  Die Replikation wird ausgeführt.  Die aktuelle Situation kann mit dem Befehl <code>pgrepup status</code> : <br><br><img src="https://habrastorage.org/webt/ig/gs/wb/iggswbqldii-c6cd5a1y7qyqawu.png"><br><br>  Hier sehen wir, dass zwei Datenbanken bereits verschoben wurden und die Replikation ausgeführt wird und eine noch verschoben wird.  Jetzt müssen Sie nur noch Kaffee trinken und warten, bis das gesamte Volumen der ursprünglichen Datenbank gepumpt ist. <br><br>  Unterwegs können Sie tiefer in die Pgrepup-Fassade schauen und sehen, was unter der Haube passiert.  Hier ist eine Liste von Fragen als Ausgangspunkt für anfragende Köpfe: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_replication_origin_status <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> remote_lsn <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *,pg_xlog_location_diff(s.sent_location,s.replay_location) byte_lag <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_replication s; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> query <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> application_name=<span class="hljs-string"><span class="hljs-string">'subscription_copy'</span></span></code> </pre> <br>  Wenn wir viel Kaffee trinken (auf dem Testserver beim Schreiben dieses Artikels dauerte die Migration von ~ 700 GB Daten ungefähr einen Tag), sehen wir endlich das folgende Bild: <br><br><img src="https://habrastorage.org/webt/ep/2e/q2/ep2eq2c_mtywxboftk4ocb0e_1c.png"><br><br>  Und das heißt, es ist Zeit, einen neuen Sklaven vorzubereiten. <br><br><h3>  Installieren Sie PostgreSQL 11 auf Slave </h3><br>  Hier ist alles einfach und laut Lehrbuch keine Nuancen. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   yum install https://download.postgresql.org/pub/repos/yum/11/redhat/rhel-7-x86_64/pgdg-oraclelinux11-11-2.noarch.rpm #  postgresql 11 yum install postgresql11 postgresql11-devel postgresql11-server postgresql11-contrib #      su - postgres pg_basebackup -h db-master.hostname -p 15432 -D /var/lib/pgsql/11/data/ -R -P -U replication -X stream -c fast</span></span></code> </pre> <br>  Kopieren Sie die Zugriffseinstellungen ( <b>pg_hba.conf</b> ) und <b>Servereinstellungen</b> ( <b>postgresql.conf</b> ) von 9.6 auf 11. <b>Ändern Sie</b> in der <b>Konfigurationskonfiguration postgresql.conf</b> 11 den Port in 15432 (port = 15432). <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  systemctl enable postgresql-11 systemctl start postgresql-11</span></span></code> </pre> <br><pre> <code class="pgsql hljs">#     Master <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *,pg_wal_lsn_diff(s.sent_lsn,s.replay_lsn) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> byte_lag <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_replication s; #     Slave <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> now()-pg_last_xact_replay_timestamp();</code> </pre><br><h3>  Zwischensummen </h3><br>  Nach all diesen Prozeduren erhalten wir dieses knifflige Replikationsschema: <br><br><img src="https://habrastorage.org/webt/70/ns/ej/70nsejcslxlccih_yktvesptqjg.png"><br><br>  Als letzte Überprüfung (und am Ende ist es einfach wunderschön) können Sie hier ein UPDATE in der 9.6-Master-Datenbank durchführen und beobachten, wie es auf die anderen drei Server repliziert wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c0/c42/89e/7c0c4289e8a00b100f58ce751bd9209e.png" alt="Bild"><br><br><h3>  Umstellung der Anwendung auf die neue Version von PostgreSQL </h3><br>  Bisher hat unsere Anwendung nichts von der neuen Version von PostgreSQL vermutet. Es ist an der Zeit, dies zu beheben.  Die Optionen hier hängen grundsätzlich nur von zwei Dingen ab: <br>  Werden Sie die neuen Dienste an denselben Ports überwiegen, an denen die alten gearbeitet haben? <br>  und ob Ihre Anwendung beim Neustart des Datenbankservers einen Neustart erfordert. <br><br>  Zum Spaß werden wir beide Fragen mit „Ja“ beantworten und fortfahren. <br><br>  Wir stoppen die Anwendung. <br><br><pre> <code class="pgsql hljs"># ,   , : <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity;</code> </pre> <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    #       sequences. pgrepup stop</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/cz/hc/2t/czhc2t8k6pjk-6ivvilidj5k9xq.png"><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      pgrepup uninstall</span></span></code> </pre><br><img src="https://habrastorage.org/webt/2w/ud/dq/2wuddqovqbninwwz9rx9fia8psa.png"><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  master: #    systemctl disable postgresql-9.6 #   ,  ,  . systemctl stop postgresql-9.6 systemctl stop postgresql-11 #  slave: #    systemctl disable postgresql-9.6 #   ,  ,  . systemctl stop postgresql-9.6 systemctl stop postgresql-11</span></span></code> </pre> <br>  Wir geben den Standardport in der <b>postgresql.conf-</b> Konfiguration der neuen Version an Master und Slave zurück. <br><br>  Auf dem neuen Slave ändern wir auch den Port auf den Standardport in <b>recovery.conf</b> . <br><br>  Auf dem Weg gibt es einen Vorschlag von sin, den Port für die inaktive alte Version weiter zu ändern: <br>  Wir stellen den nicht standardmäßigen Port in der <b>postgresql.conf der</b> alten Version Master und Slave zur Verfügung. <br>  Auf dem alten Slave ändern wir auch den Port in der <b>Datei recovery.conf</b> in einen nicht standardmäßigen. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   master systemctl enable postgresql-11 systemctl start postgresql-11 #   slave: systemctl enable postgresql-11 systemctl start postgresql-11</span></span></code> </pre> <br>  Überprüfen Sie die Protokolle. <br><br>  Überprüfen Sie den Replikationsstatus auf dem Master. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *,pg_wal_lsn_diff(s.sent_lsn,s.replay_lsn) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> byte_lag <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_replication s;</code> </pre> <br>  Wir starten die Anwendung.  Wir freuen uns für eine halbe Stunde. <br><br>  <b>Und schließlich nützliche Literatur zum Thema:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pglogisch</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Installationsanleitung für pglogical</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pglogische Dokumente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Upgrade von PostgreSQL von 9.4 auf 10.3 mit pglogical</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pgrepup - Aktualisieren Sie PostgreSQL mithilfe der logischen Replikation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pgrepup - PostgreSQL REPlicate und UPgrade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Upgrade von PostgreSQL von 9.6 auf 10 mit minimalen Ausfallzeiten mithilfe von pglogical</a> </li></ul><br>  Viel Glück! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437318/">https://habr.com/ru/post/de437318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437308/index.html">SDL 2.0-Unterrichtszyklus: Lektion 4 - Behandeln von Ereignissen</a></li>
<li><a href="../de437310/index.html">CSS-Verlaufsgrenzen</a></li>
<li><a href="../de437312/index.html">Implementierung eines Hot-Reloads von C ++ - Code unter Linux und MacOS: tiefer gehen</a></li>
<li><a href="../de437314/index.html">Italienisches Rätsel: OMI-Kryptografiemaschinen</a></li>
<li><a href="../de437316/index.html">Das Internet Development Institute hat Websites benannt, die seit dem 1. Februar möglicherweise nicht mehr mit RuNet verbunden sind</a></li>
<li><a href="../de437320/index.html">2018 Media Sphere Development Index: Stagnation des Fernsehens, erhöhtes Vertrauen in informelle Medien</a></li>
<li><a href="../de437322/index.html">Der Staat ist an BigDate beteiligt</a></li>
<li><a href="../de437324/index.html">Blutiger Kuss: Vasorelaxationseigenschaften des Speichels von Vampirfledermäusen</a></li>
<li><a href="../de437326/index.html">Zum Thema Multiplikation, Quadratwurzelextraktion, Importsubstitution und der Firma Milander</a></li>
<li><a href="../de437330/index.html">devleads - über Burnout sprechen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>