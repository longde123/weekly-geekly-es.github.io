<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî° üë®üèº‚ÄçüöÄ üë®üèª Nahtlose (fast) Migration zwischen wichtigen PostgreSQL-Versionen mithilfe der logischen Replikation üèâ üçÄ üë®üèª‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In True Engineering musste bei einem Projekt die Version von PostgreSQL von 9.6 auf 11.1 ge√§ndert werden. 

 Warum? Die Datenbank des Projekts ist ber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nahtlose (fast) Migration zwischen wichtigen PostgreSQL-Versionen mithilfe der logischen Replikation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/437318/">  In True Engineering musste bei einem Projekt die Version von PostgreSQL von 9.6 auf 11.1 ge√§ndert werden. <br><br>  Warum?  Die Datenbank des Projekts ist bereits 1,5 TB gro√ü und w√§chst.  Die Leistung ist eine der Hauptanforderungen an das System.  Und die Datenstruktur selbst entwickelt sich weiter: Neue Spalten werden hinzugef√ºgt, vorhandene ge√§ndert.  Die neue Version von Postgres hat gelernt, wie man effizient arbeitet, indem neue Spalten mit einem Standardwert hinzugef√ºgt werden, sodass keine benutzerdefinierten Kr√ºcken auf Anwendungsebene eingez√§unt werden m√ºssen.  Selbst in der neuen Version wurden mehrere neue M√∂glichkeiten zum Partitionieren von Tabellen hinzugef√ºgt, was auch unter Bedingungen einer gro√üen Datenmenge √§u√üerst n√ºtzlich ist. <br><br>  Es wird also entschieden, dass wir migrieren.  Nat√ºrlich k√∂nnen Sie eine neue Version des PostgreSQL-Servers parallel zur alten Version erstellen, die Anwendung stoppen, die Datenbank mit dump / restore (oder pg_upgrade) verschieben und die Anwendung neu starten.  Diese L√∂sung passte aufgrund der Gr√∂√üe der Basis nicht zu uns. Au√üerdem arbeitet die Anwendung im Kampfmodus und es gibt nur wenige Minuten bis zur Ausfallzeit. <br><br>  Aus diesem Grund haben wir uns entschlossen, die Migration mithilfe der logischen Replikation in PostgreSQL mithilfe eines Plugins eines Drittanbieters namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pglogical zu versuchen</a> . <br><br>  W√§hrend des "Prozess" -Prozesses stie√üen wir auf eine sehr fragmentarische Dokumentation dieses Prozesses (und auf Russisch √ºberhaupt nicht) sowie auf einige Fallstricke und nicht offensichtliche Nuancen.  In diesem Artikel m√∂chten wir unsere Erfahrungen in Form eines Tutorials pr√§sentieren. <br><br><img src="https://habrastorage.org/webt/cp/i7/oi/cpi7oixtsenmioqdrcyyotgagyk.png"><br><br>  <b>TL; DR</b> <br><br><ul><li>  Alles stellte sich heraus (nicht ohne Kr√ºcken, ein Artikel dar√ºber). </li><li>  Sie k√∂nnen innerhalb der PostgreSQL-Version von 9.4 auf 11.x von jeder Version auf eine beliebige Version nach unten oder oben migrieren. </li><li>  Die Ausfallzeit entspricht der Zeit, die Ihre Anwendung ben√∂tigt, um die Verbindung zum neuen Datenbankserver wiederherzustellen (in unserem Fall war dies ein Neustart der gesamten Anwendung, in der Wildnis jedoch offensichtlich ‚Äûm√∂gliche Optionen‚Äú). </li></ul><a name="habracut"></a><br><h3>  Warum passte die "Stirn" -L√∂sung nicht zu uns? </h3><br>  Wie bereits erw√§hnt, besteht der einfachste Ausweg darin, die neue Version des PostgreSQL-Servers parallel zur alten Version zu erstellen, die Anwendung zu stoppen, die Datenbank mit dump / restore (oder pg_upgrade) zu verschieben und die Anwendung erneut zu starten.  F√ºr Datenbanken mit kleinem Volumen ist dies im Prinzip eine durchaus geeignete Option (oder im Allgemeinen ist das Volumen unwichtig, wenn Sie die M√∂glichkeit haben, die Anwendung f√ºr den Zeitraum der "Transfusion" der Datenbank vom alten auf den neuen Server zu verl√§ngern, unabh√§ngig davon, wie lange diese Zeit dauert).  In unserem Fall ben√∂tigt die Datenbank jedoch etwa 1,5 TB auf der Festplatte, und das Verschieben ist keine Frage von Minuten, sondern von mehreren Stunden.  Die Anwendung arbeitet wiederum im Kampfmodus, und ich wollte Ausfallzeiten unbedingt l√§nger als ein paar Minuten vermeiden. <br><br>  Gegen diese Option war auch die Tatsache, dass wir die Master-Slave-Replikation verwenden und den Slave-Server nicht sicher aus dem Workflow ausschalten k√∂nnen.  Um die Anwendung nach der Migration des Master-Servers von der alten Version von PostgreSQL auf die neue Version umzustellen, muss vor dem Starten der Anwendung ein neuer Slave-Server vorbereitet werden.  Und dies sind noch einige Stunden Ausfallzeit, bis der Slave erstellt wird (obwohl viel weniger als die Migration des Masters). <br><br>  Aus diesem Grund haben wir uns entschlossen, die Migration mithilfe der logischen Replikation in PostgreSQL mithilfe eines Plugins eines Drittanbieters namens pglogical zu versuchen. <br><br><h3>  allgemeine Informationen </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pglogical</a> ist ein logisches Replikationssystem, das die native logische Dekodierung in PostgreSQL verwendet und als PostgreSQL-Erweiterung implementiert ist.  Erm√∂glicht die Konfiguration der selektiven Replikation mithilfe des Abonnement- / Ver√∂ffentlichungsmodells.  Es ist nicht erforderlich, Trigger in der Datenbank zu erstellen oder externe Dienstprogramme f√ºr die Replikation zu verwenden. <br><br>  Die Erweiterung funktioniert mit jeder Version von PostgreSQL ab 9.4 (seit Logical Decoding erstmals in 9.4 ver√∂ffentlicht wurde) und erm√∂glicht Ihnen die Migration zwischen unterst√ºtzten Versionen von PostgreSQL in jede Richtung. <br><br>  Das manuelle Einrichten der Replikation mithilfe von pglogical manuell ist nicht sehr trivial, obwohl dies im Prinzip durchaus m√∂glich ist.  Gl√ºcklicherweise gibt es ein Drittanbieter-Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pgrepup</a> zur Automatisierung des Konfigurationsprozesses, das wir verwenden werden. <br><br><h3>  Speicherplatz Memo </h3><br>  Da wir planen, die neue Version von PostgreSQL parallel zur alten Version auf denselben Servern zu aktualisieren, verdoppeln sich die Festplattenanforderungen f√ºr die Datenbank auf den Master- und Slave-Servern.  Es scheint, dass dies offensichtlich ist, aber ... Achten Sie einfach auf gen√ºgend freien Speicherplatz, bevor Sie mit der Replikation beginnen, um die ziellos verbrachten Jahre nicht zu bereuen. <br><br>  In unserem Fall waren Datenbank√§nderungen erforderlich, und das Speicherformat w√§hrend der Migration zwischen 9.6 und 11 ‚Äûschwillt‚Äú nicht zugunsten der neuesten Version an, sodass der Speicherplatz nicht um 2, sondern um das 2,2-fache erh√∂ht werden musste.  Lob LVM, dies kann im Zuge der Migration im laufenden Betrieb erfolgen. <br><br>  Im Allgemeinen k√ºmmern Sie sich darum. <br><br><h3>  Installieren Sie PostgreSQL 11 auf dem Master </h3><br><blockquote>  Hinweis: Wir verwenden Oracle Linux. Alle folgenden Elemente werden f√ºr diese Distribution gesch√§rft.  Es ist m√∂glich, dass andere Linux-Distributionen eine kleine √úberarbeitung einer Datei erfordern, aber es ist unwahrscheinlich, dass dies von Bedeutung ist. </blockquote><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   yum install https://download.postgresql.org/pub/repos/yum/11/redhat/rhel-7-x86_64/pgdg-oraclelinux11-11-2.noarch.rpm #   postgresql11 yum install postgresql11 postgresql11-devel postgresql11-server postgresql11-contrib #   /usr/pgsql-11/bin/postgresql-11-setup initdb</span></span></code> </pre> <br>  Das alte Datenverzeichnis befindet sich in <b>/var/lib/pgsql/9.6/data</b> , das neue in <b>/ var / lib / pgsql / 11 / data</b> <br><br>  Kopieren Sie die Zugriffseinstellungen ( <b>pg_hba.conf</b> ) und <b>Servereinstellungen</b> ( <b>postgresql.conf</b> ) von 9.6 auf 11. <br><br>  Um zwei PostgreSQL-Server auf demselben Computer <b>auszuf√ºhren</b> , √§ndern Sie in der Konfigurationskonfiguration <b>postgresql.conf</b> 11 den Port in 15432 (port = 15432). <br><br>  Hier m√ºssen Sie sorgf√§ltig <b>√ºberlegen,</b> was Sie in der neuen Version von PostgreSQL in Ihrem Fall noch tun m√ºssen, damit es mit Ihrer <b>postgresql.conf</b> beginnt (und Ihre Anwendung m√∂glicherweise damit funktioniert).  In unserem Fall mussten die von uns in der neuen Version verwendeten PostgreSQL-Erweiterungen installiert werden.  Dies w√ºrde den Rahmen des Artikels sprengen. Lassen Sie das neue PostgreSQL einfach starten, funktionieren und ganz zu Ihnen passen :) <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  ,  ,  shared libraries, whatever... # .... #  systemctl enable postgresql-11 systemctl start postgresql-11</span></span></code> </pre> <br>  Wir schauen in <b>/ var / lib / pgsql / 11 / data / pg_log /</b> .  Alles ist gut?  Wir machen weiter! <br><br><h3>  Installieren und konfigurieren Sie pgrepup </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  python yum install python yum install python2-pip #  pgrepup pip install pgrepup #   pgrepup config</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/zg/xz/9o/zgxz9oct5l-qglkxyeyrqejh4we.png"><br><br>  Nuancen: <br><br><ol><li>  Als <b>app_owner geben wir</b> den Benutzer an, unter dem die PostgreSQL-Server ausgef√ºhrt werden. </li><li>  <b>Geben Sie</b> f√ºr <b>Datenbank</b> <b>template1 an</b> . </li><li>  <b>Benutzername</b> und <b>Passwort</b> - Daten f√ºr den Superuser-Zugriff.  In unserem Fall wurde die <b>Vertrauensmethode</b> in <b>pg_hba.conf</b> f√ºr lokale Verbindungen des <b>Postgres-</b> Benutzers angegeben, sodass Sie ein beliebiges Kennwort angeben k√∂nnen. </li></ol><br><h3>  Konfigurieren Sie die Replikation </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   pgrepup check</span></span></code> </pre><br>  Wir erhalten die Ausgabe einer Liste vieler Parameter, die nach Bedarf konfiguriert werden m√ºssen. <br><br>  Beispiel f√ºr √úberpr√ºfungsergebnisse: <br><br><img src="https://habrastorage.org/webt/h3/wu/zm/h3wuzmcevo7idf-xlyrz3ae8av8.png"><br><br><img src="https://habrastorage.org/webt/58/zh/bb/58zhbbubdbfvzzgat051bviywqy.png"><br><br>  Alle Fehler w√§hrend der √úberpr√ºfung m√ºssen beseitigt werden.  In den Einstellungen beider Server sollten <b>wal_level = LOGICAL</b> (damit die logische Dekodierung funktioniert) festgelegt werden, die erforderlichen Einstellungen f√ºr die Replikations-Engine (Anzahl der Slots und <b>wal_senders</b> ).  Die Hinweise des Dienstprogramms pgrepup sind recht informativ, Fragen sollten in den meisten Punkten nicht auftauchen. <br><br>  Wir nehmen alle notwendigen Einstellungen vor, die pgrepup verlangt. <br><br>  In beiden Dateien <b>pg_hba.conf</b> f√ºgen wir an der Eingabeaufforderung pgrepup Berechtigungen f√ºr den Benutzer hinzu, der die Replikation durchf√ºhren soll: <br><br><pre> <code class="bash hljs">host replication pgrepup_replication 127.0.0.1/32 md5 host all pgrepup_replication 127.0.0.1/32 md5</code> </pre> <br><h3>  Prim√§rschl√ºssel hinzuf√ºgen </h3><br>  Damit die Replikation funktioniert, muss in allen Tabellen ein Prim√§rschl√ºssel definiert sein. <br><br>  In unserem Fall war PK nicht √ºberall, daher m√ºssen Sie es zum Zeitpunkt der Replikation hinzuf√ºgen und am Ende der Replikation gegebenenfalls l√∂schen. <br><br>  Eine Liste von Tabellen ohne PK erzeugt unter anderem eine <code>pgrepup check</code> .  F√ºr alle Tabellen aus dieser Liste m√ºssen Sie einen Prim√§rschl√ºssel hinzuf√ºgen, der zu Ihnen passt.  In unserem Fall war es so etwas wie: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> %s <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> temporary_pk <span class="hljs-type"><span class="hljs-type">BIGSERIAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span></code> </pre> <br>  Das Dienstprogramm pgrepup verf√ºgt √ºber einen integrierten Befehl zum Ausf√ºhren dieses Vorgangs ( <code>pgrepup fix</code> ). Wenn es verwendet wird, wird sogar impliziert, dass diese tempor√§ren Spalten bei erfolgreicher Replikation automatisch gel√∂scht werden.  Leider war diese Funktionalit√§t auf gro√üen Basen so illusorisch und bezaubernd fehlerhaft, dass wir beschlossen, sie nicht zu verwenden, sondern diesen Vorgang manuell durchzuf√ºhren, da dies f√ºr uns praktisch ist. <br><br><h3>  Installieren Sie die pglogische Erweiterung </h3><br>  Anweisungen zur Installation der Erweiterung finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Die Erweiterung muss auf beiden Servern installiert sein. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#       curl https://access.2ndquadrant.com/api/repository/dl/default/release/9.6/rpm | bash curl https://access.2ndquadrant.com/api/repository/dl/default/release/11/rpm | bash #   yum install postgresql96-pglogical postgresql11-pglogical</span></span></code> </pre> <br>  F√ºgen Sie die Bibliothekslast in der <b>postgresql.conf</b> beider Server hinzu: <br><br><pre> <code class="bash hljs">shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pglogical'</span></span></code> </pre> <br><h3>  Installieren Sie die Erweiterung pgl_ddl_deploy </h3><br>  Dies ist eine Hilfserweiterung, die pgrepup f√ºr die logische DDL-Replikation verwendet. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      git clone https://github.com/enova/pgl_ddl_deploy.git #       PATH=/usr/pgsql-9.6/bin/:$PATH USE_PGXS=1 make USE_PGXS=1 make install make clean #       PATH=/usr/pgsql-11/bin/:$PATH make CLANG=true make install</span></span></code> </pre> <br>  F√ºgen Sie die Bibliothekslast in der <b>postgresql.conf</b> beider Server hinzu: <br><br><pre> <code class="bash hljs">shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pglogical,pgl_ddl_deploy'</span></span></code> </pre> <br><h3>  √Ñnderungen √ºberpr√ºfen </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   postgresql systemctl restart postgresql-11</span></span></code> </pre> <br>  Jetzt <code>pgrepup check</code> Sie mit <code>pgrepup check</code> sicherstellen, dass mit dem Zielserver alles in Ordnung ist und alle Kommentare zum Zielserver vollst√§ndig entfernt wurden. <br><br>  Wenn alles in Ordnung ist, k√∂nnen Sie den alten Server neu starten.  Hier m√ºssen Sie √ºberlegen, wie Ihre Anwendung auf den Neustart des Datenbankservers reagiert. Vielleicht sollten Sie ihn zuerst stoppen. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  systemctl restart postgresql-9.6 #  pgrepup check</span></span></code> </pre> <br>  In der Ausgabe des Befehls sollten nun alle Elemente als OK markiert werden. <br><br>  Es scheint, dass Sie mit der Migration beginnen k√∂nnen, aber ... <br><br><h3>  Beheben Sie pgrepup-Fehler </h3><br>  In der aktuellen Version von pgrepup gibt es mehrere Fehler, die eine Migration unm√∂glich machen.  Pull-Anforderungen wurden gesendet, aber leider werden sie ignoriert, sodass Sie Korrekturen manuell vornehmen m√ºssen. <br><br>  Wir gehen zum Installationsordner von pgrepup (unser Fall ist <b>/usr/lib/python2.7/site-packages/pgrepup/commands/</b> ). <br><br>  Mach es einmal.  <code>**kwargs</code> in jeder <b>* .py-</b> Datei die fehlenden <code>**kwargs</code> in die Funktionsbeschreibung ein.  Ein Bild ist besser als tausend Worte: <br><br><img src="https://habrastorage.org/webt/l3/zc/uo/l3zcuo2exe8lq_0u3gwv_nq8jty.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier verpflichten</a> . <br><br>  Mach zwei.  In <b>setup.py suchen</b> wir nach "sh -c", zwei Eintr√§gen, alle mehrzeiligen Shell-Befehle m√ºssen einzeilig sein. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier verpflichten</a> . <br><br><h3>  Starten Sie die Migration </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  pgrepup setup</span></span></code> </pre> <br>  Mit diesem Befehl bereitet pgrepup beide Server auf den Start der Replikation vor, erstellt einen Benutzer, konfiguriert pglogical und √ºbertr√§gt das Datenbankschema. <br><br><img src="https://habrastorage.org/webt/ww/km/jd/wwkmjdmmpmwyvgbdqyktohnhmmy.png"><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   pgrepup start</span></span></code> </pre> <br>  Er sagte: "Lass uns gehen!"  und winkte mit der Hand: <br><br><img src="https://habrastorage.org/webt/3k/xc/_r/3kxc_rgde-t7q6yuhtvwkol5acs.png"><br><br>  Die Replikation wird ausgef√ºhrt.  Die aktuelle Situation kann mit dem Befehl <code>pgrepup status</code> : <br><br><img src="https://habrastorage.org/webt/ig/gs/wb/iggswbqldii-c6cd5a1y7qyqawu.png"><br><br>  Hier sehen wir, dass zwei Datenbanken bereits verschoben wurden und die Replikation ausgef√ºhrt wird und eine noch verschoben wird.  Jetzt m√ºssen Sie nur noch Kaffee trinken und warten, bis das gesamte Volumen der urspr√ºnglichen Datenbank gepumpt ist. <br><br>  Unterwegs k√∂nnen Sie tiefer in die Pgrepup-Fassade schauen und sehen, was unter der Haube passiert.  Hier ist eine Liste von Fragen als Ausgangspunkt f√ºr anfragende K√∂pfe: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_replication_origin_status <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> remote_lsn <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *,pg_xlog_location_diff(s.sent_location,s.replay_location) byte_lag <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_replication s; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> query <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> application_name=<span class="hljs-string"><span class="hljs-string">'subscription_copy'</span></span></code> </pre> <br>  Wenn wir viel Kaffee trinken (auf dem Testserver beim Schreiben dieses Artikels dauerte die Migration von ~ 700 GB Daten ungef√§hr einen Tag), sehen wir endlich das folgende Bild: <br><br><img src="https://habrastorage.org/webt/ep/2e/q2/ep2eq2c_mtywxboftk4ocb0e_1c.png"><br><br>  Und das hei√üt, es ist Zeit, einen neuen Sklaven vorzubereiten. <br><br><h3>  Installieren Sie PostgreSQL 11 auf Slave </h3><br>  Hier ist alles einfach und laut Lehrbuch keine Nuancen. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   yum install https://download.postgresql.org/pub/repos/yum/11/redhat/rhel-7-x86_64/pgdg-oraclelinux11-11-2.noarch.rpm #  postgresql 11 yum install postgresql11 postgresql11-devel postgresql11-server postgresql11-contrib #      su - postgres pg_basebackup -h db-master.hostname -p 15432 -D /var/lib/pgsql/11/data/ -R -P -U replication -X stream -c fast</span></span></code> </pre> <br>  Kopieren Sie die Zugriffseinstellungen ( <b>pg_hba.conf</b> ) und <b>Servereinstellungen</b> ( <b>postgresql.conf</b> ) von 9.6 auf 11. <b>√Ñndern Sie</b> in der <b>Konfigurationskonfiguration postgresql.conf</b> 11 den Port in 15432 (port = 15432). <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  systemctl enable postgresql-11 systemctl start postgresql-11</span></span></code> </pre> <br><pre> <code class="pgsql hljs">#     Master <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *,pg_wal_lsn_diff(s.sent_lsn,s.replay_lsn) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> byte_lag <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_replication s; #     Slave <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> now()-pg_last_xact_replay_timestamp();</code> </pre><br><h3>  Zwischensummen </h3><br>  Nach all diesen Prozeduren erhalten wir dieses knifflige Replikationsschema: <br><br><img src="https://habrastorage.org/webt/70/ns/ej/70nsejcslxlccih_yktvesptqjg.png"><br><br>  Als letzte √úberpr√ºfung (und am Ende ist es einfach wundersch√∂n) k√∂nnen Sie hier ein UPDATE in der 9.6-Master-Datenbank durchf√ºhren und beobachten, wie es auf die anderen drei Server repliziert wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c0/c42/89e/7c0c4289e8a00b100f58ce751bd9209e.png" alt="Bild"><br><br><h3>  Umstellung der Anwendung auf die neue Version von PostgreSQL </h3><br>  Bisher hat unsere Anwendung nichts von der neuen Version von PostgreSQL vermutet. Es ist an der Zeit, dies zu beheben.  Die Optionen hier h√§ngen grunds√§tzlich nur von zwei Dingen ab: <br>  Werden Sie die neuen Dienste an denselben Ports √ºberwiegen, an denen die alten gearbeitet haben? <br>  und ob Ihre Anwendung beim Neustart des Datenbankservers einen Neustart erfordert. <br><br>  Zum Spa√ü werden wir beide Fragen mit ‚ÄûJa‚Äú beantworten und fortfahren. <br><br>  Wir stoppen die Anwendung. <br><br><pre> <code class="pgsql hljs"># ,   , : <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity;</code> </pre> <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    #       sequences. pgrepup stop</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/cz/hc/2t/czhc2t8k6pjk-6ivvilidj5k9xq.png"><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      pgrepup uninstall</span></span></code> </pre><br><img src="https://habrastorage.org/webt/2w/ud/dq/2wuddqovqbninwwz9rx9fia8psa.png"><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  master: #    systemctl disable postgresql-9.6 #   ,  ,  . systemctl stop postgresql-9.6 systemctl stop postgresql-11 #  slave: #    systemctl disable postgresql-9.6 #   ,  ,  . systemctl stop postgresql-9.6 systemctl stop postgresql-11</span></span></code> </pre> <br>  Wir geben den Standardport in der <b>postgresql.conf-</b> Konfiguration der neuen Version an Master und Slave zur√ºck. <br><br>  Auf dem neuen Slave √§ndern wir auch den Port auf den Standardport in <b>recovery.conf</b> . <br><br>  Auf dem Weg gibt es einen Vorschlag von sin, den Port f√ºr die inaktive alte Version weiter zu √§ndern: <br>  Wir stellen den nicht standardm√§√üigen Port in der <b>postgresql.conf der</b> alten Version Master und Slave zur Verf√ºgung. <br>  Auf dem alten Slave √§ndern wir auch den Port in der <b>Datei recovery.conf</b> in einen nicht standardm√§√üigen. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   master systemctl enable postgresql-11 systemctl start postgresql-11 #   slave: systemctl enable postgresql-11 systemctl start postgresql-11</span></span></code> </pre> <br>  √úberpr√ºfen Sie die Protokolle. <br><br>  √úberpr√ºfen Sie den Replikationsstatus auf dem Master. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *,pg_wal_lsn_diff(s.sent_lsn,s.replay_lsn) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> byte_lag <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_replication s;</code> </pre> <br>  Wir starten die Anwendung.  Wir freuen uns f√ºr eine halbe Stunde. <br><br>  <b>Und schlie√ülich n√ºtzliche Literatur zum Thema:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pglogisch</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Installationsanleitung f√ºr pglogical</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pglogische Dokumente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Upgrade von PostgreSQL von 9.4 auf 10.3 mit pglogical</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pgrepup - Aktualisieren Sie PostgreSQL mithilfe der logischen Replikation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pgrepup - PostgreSQL REPlicate und UPgrade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Upgrade von PostgreSQL von 9.6 auf 10 mit minimalen Ausfallzeiten mithilfe von pglogical</a> </li></ul><br>  Viel Gl√ºck! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437318/">https://habr.com/ru/post/de437318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437308/index.html">SDL 2.0-Unterrichtszyklus: Lektion 4 - Behandeln von Ereignissen</a></li>
<li><a href="../de437310/index.html">CSS-Verlaufsgrenzen</a></li>
<li><a href="../de437312/index.html">Implementierung eines Hot-Reloads von C ++ - Code unter Linux und MacOS: tiefer gehen</a></li>
<li><a href="../de437314/index.html">Italienisches R√§tsel: OMI-Kryptografiemaschinen</a></li>
<li><a href="../de437316/index.html">Das Internet Development Institute hat Websites benannt, die seit dem 1. Februar m√∂glicherweise nicht mehr mit RuNet verbunden sind</a></li>
<li><a href="../de437320/index.html">2018 Media Sphere Development Index: Stagnation des Fernsehens, erh√∂htes Vertrauen in informelle Medien</a></li>
<li><a href="../de437322/index.html">Der Staat ist an BigDate beteiligt</a></li>
<li><a href="../de437324/index.html">Blutiger Kuss: Vasorelaxationseigenschaften des Speichels von Vampirflederm√§usen</a></li>
<li><a href="../de437326/index.html">Zum Thema Multiplikation, Quadratwurzelextraktion, Importsubstitution und der Firma Milander</a></li>
<li><a href="../de437330/index.html">devleads - √ºber Burnout sprechen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>