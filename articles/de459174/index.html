<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© üï∫üèΩ üëàüèø Rx-Ereignisquellenreferenz ü§ù üëÄ ü§öüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RxJava wird in einer gro√üen Anzahl von Android-Anwendungen verwendet, aber gleichzeitig kennen viele andere Ereignisquellen nicht, au√üer Observable un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rx-Ereignisquellenreferenz</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/459174/"><img src="https://habrastorage.org/webt/5u/bh/bo/5ubhboeipdbjg8iw7pwxhhbnyhy.png"><br><br>  RxJava wird in einer gro√üen Anzahl von Android-Anwendungen verwendet, aber gleichzeitig kennen viele andere Ereignisquellen nicht, au√üer Observable und m√∂glicherweise Flowable.  Sie vergessen die speziellen Klassen Single, Maybe und Completable, die dem Code h√§ufig mehr Klarheit verleihen k√∂nnen. <br><br>  Unter der Katze finden Sie einen Spickzettel zu den Ereignisquellen in RxJava. <br><a name="habracut"></a><br>  <u>Completable ist</u> eigentlich ein Rx-Analogon von Runnable.  Es ist eine Operation, die ausgef√ºhrt werden kann oder nicht.  Wenn wir eine Analogie mit Kotlin ziehen, dann macht dies <i>Spa√ü ()</i> aus der Welt von Rx.  Dementsprechend m√ºssen Sie onComplete und onError implementieren, um es zu abonnieren.  Es kann nicht aus dem Wert (Observable # just, ...) erstellt werden, da es nicht daf√ºr ausgelegt ist. <br><br>  <u>Single</u> - reactive Callable, da hier das Ergebnis der Operation zur√ºckgegeben werden kann.  Wenn wir den Vergleich mit Kotlin fortsetzen, k√∂nnen wir sagen, dass Single Spa√ü macht single (): T {}.  Um es zu abonnieren, m√ºssen Sie onSuccess (T) und onError implementieren. <br><br>  <u>Vielleicht</u> - eine Kreuzung zwischen Single und Completable, weil es einen Wert unterst√ºtzt, keine Werte und Fehler.  Es ist schwieriger, eine eindeutige Parallele zu den Methoden zu ziehen, aber ich denke, vielleicht macht es vielleicht Spa√ü (): T?  {}, die null zur√ºckgibt, wenn kein Ergebnis vorliegt.  Es ist leicht zu erraten, dass Sie f√ºr ein Abonnement onSuccess (T), onComplete und onError definieren m√ºssen. <br><blockquote>  Es ist wichtig zu beachten, dass sich onSuccess (T) und onComplete gegenseitig ausschlie√üen.  Das hei√üt,  Wenn Sie den ersten anrufen, k√∂nnen Sie nicht auf den zweiten warten. </blockquote>  <u>Observable</u> ist aufgrund seiner Vielseitigkeit die h√§ufigste Quelle.  Er wei√ü, wie man Ereignisse √ºberhaupt nicht produziert und viele davon generiert, sodass er immer dann verwendet werden kann, wenn andere Optionen nicht geeignet sind.  Trotzdem hat Observable einen Nachteil - es wei√ü nicht, wie es mit Gegendruck umgehen soll.  Um es zu abonnieren, ben√∂tigen Sie onNext (T), onError und onComplete. <br><br><blockquote>  Gegendruck - eine Situation, in der neue Ereignisse viel schneller eintreffen als Zeit f√ºr die Verarbeitung haben und sich im Puffer ansammeln und √ºberlaufen.  Dies kann zu Problemen wie OutOfMemoryError f√ºhren.  Weitere Details finden Sie <a href="">hier</a> . </blockquote><br>  <u>ConnectableObservable</u> - eine beheizte Version von Observable.  Alle Datenquellen beginnen zum Zeitpunkt des Abonnements mit der Ausgabe ihres Ereignisstroms.  Aber nicht dieser Typ.  Zu diesem Zweck wartet ConnectableObservable auf die Verbindung eines Anrufs.  Dies geschieht, damit mehrere Beobachter einen Ereignisstrom √ºberpr√ºfen k√∂nnen, ohne ihn bei jedem Abonnement neu zu starten.  Zur Veranschaulichung gebe ich Ihnen den folgenden Ausschnitt: <br><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> observable = Observable.fromCallable { Log.d(<span class="hljs-string"><span class="hljs-string">"RxLogs"</span></span>, <span class="hljs-string"><span class="hljs-string">"observable fromCallable executed"</span></span>) Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>) }.subscribeOn(Schedulers.computation()) observable.subscribe() observable.subscribe() observable.subscribe() observable.subscribe()</code> </pre>  In der Konsole wird sein: <br>  beobachtbar vonCallable ausgef√ºhrt <br>  beobachtbar vonCallable ausgef√ºhrt <br>  beobachtbar vonCallable ausgef√ºhrt <br>  beobachtbar vonCallable ausgef√ºhrt <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connectedObservable = Observable.fromCallable { Log.d(<span class="hljs-string"><span class="hljs-string">"RxLogs"</span></span>, <span class="hljs-string"><span class="hljs-string">"connectedObservable fromCallable executed"</span></span>) Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>) }.subscribeOn(Schedulers.computation()) .publish() connectedObservable.subscribe() connectedObservable.subscribe() connectedObservable.subscribe() connectedObservable.subscribe() connectedObservable.connect()</code> </pre><br>  Und in diesem Fall: beobachtbar von Callable ausgef√ºhrt <br><br>  <u>Flowable</u> - eine Quelle, die zus√§tzliche Bediener f√ºr die Verarbeitung des Gegendrucks bereitstellt.  Wenn Sie mehr als 10.000 Ereignisse verarbeiten m√ºssen, die schnell nacheinander auftreten, wird empfohlen, sie anstelle von Observable zu verwenden. <br><br>  Letzteres kann ein ConnectableFlowable erstellen und die gleichen M√∂glichkeiten wie ConnectableObservable er√∂ffnen. <br><br>  Wenn man √ºber Ereignisgeneratoren spricht, kann man nur Betreff und Prozessor erw√§hnen. <br><br>  <u>Betreff</u> - eine Klasse, die sowohl eine Quelle als auch ein Browser sein kann.  Auf diese Weise k√∂nnen Sie es beispielsweise in verschiedenen Arten von Controllern verwenden, die es als Observable nach au√üen und als Observer nach innen benachrichtigen.  Als n√§chstes werden wir verschiedene Implementierungen dieser Klasse durchgehen. <br><br>  <u>AsyncSubject / AsyncProcessor</u> h√§lt das letzte Ereignis, bis der Thread korrekt beendet wurde, und sendet es dann an Abonnenten.  Wenn ein Fehler auftritt, werden keine Ereignisse weitergeleitet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e03/424/6ad/e034246ad488aa7f1309ee9870f2243c.png" alt="Bild"><br><br>  <u>PublishSubject / PublishProcessor leitet eingehende</u> Ereignisse weiter, bis ein Terminalsignal eintrifft.  Nach dem Ende des Streams oder Fehlers werden die entsprechenden Ereignisse zur√ºckgegeben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d7/5b5/399/6d75b53991a4ae2e84818b64149a01db.png" alt="Bild"><br><br>  <u>BehaviorSubject / BehaviorProcessor</u> funktioniert √§hnlich wie PublishSubject / PublishProcessor, gibt jedoch beim Abonnement das letzte Ereignis zur√ºck, falls vorhanden, und wenn Subject nicht in den Terminalstatus √ºbergegangen ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/540/bfd/11b540bfdda812ae611cac4bbcdbee6c.png" alt="Bild"><br><br>  <u>ReplaySubject / ReplayProcessor</u> - BehaviourSubject / BehaviorProcessor f√ºr Steroide.  Es gibt nicht ein letztes Ereignis zur√ºck, sondern so viel, wie die Seele w√ºnscht.  Wenn Sie ein abgeschlossenes ReplaySubject oder einen ReplayProcessor abonnieren, werden alle gesammelten Daten empfangen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c75/4b5/19e/c754b519e08d98fed504fac2cf637d61.png" alt="Bild"><br><blockquote>  Daher funktionieren ReplaySubject.createWithSize (1) und BehaviourSubject.create () nach dem √úbergang in den Terminalstatus unterschiedlich.  W√§hrend des Abonnements gibt das erste das letzte Ereignis zur√ºck und das zweite nicht.  Dies gilt auch f√ºr ReplayProcessor. </blockquote>  <u>CompletableSubject</u> , <u>MaybeSubject</u> und <u>SingleSubject</u> funktionieren √§hnlich wie PublishSubject und sind nur f√ºr die Verwendung mit Completable, Maybe und Single vorgesehen. <br><br>  <u>UnicastSubject / UnicastProcessor</u> ist eigentlich ein ReplaySubject, das sicherstellt, dass es nur einen Abonnenten hat.  Beim erneuten Abonnieren wird eine IllegalStateException ausgel√∂st. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6b/f38/46a/e6bf3846a454ef45c5b217bb58568f85.png" alt="Bild"><br><br>  Das hei√üt,  n√§chster Ausschnitt <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> subject = UnicastSubject.create&lt;String&gt;(<span class="hljs-number"><span class="hljs-number">3</span></span>) repeat(<span class="hljs-number"><span class="hljs-number">3</span></span>) { subject.onNext(it.toString()) } subject.onComplete() subject.subscribe({ Log.d(<span class="hljs-string"><span class="hljs-string">"RxLogs"</span></span>, it) }, { }, { Log.d(<span class="hljs-string"><span class="hljs-string">"RxLogs"</span></span>, <span class="hljs-string"><span class="hljs-string">"complete"</span></span>) })</code> </pre><br>  wird in das Protokoll ausgegeben <br>  0 <br>  1 <br>  2 <br>  vollst√§ndig <br><br>  <u>MulticastProcessor</u> funktioniert √§hnlich wie PublishProcessor, mit Ausnahme einer kleinen Funktion.  Er wei√ü, wie man mit Gegendruck f√ºr den eingehenden Strom umgeht.  Mit MulticastProcessor k√∂nnen Sie die Gr√∂√üe des Puffers festlegen, bei dem Elemente vom Upstream f√ºr zuk√ºnftige Abonnenten vorab abgefragt werden. <br><br>  In der folgenden Abbildung wird ein Prozessor mit Speicher f√ºr 2 Elemente erstellt, den er sofort von seiner Quelle anfordert.  Wenn der erste Beobachter es abonniert, gibt er daher sofort den Inhalt des Puffers aus, der sofort mit neuen Ereignissen gef√ºllt wird.  Nach dem Terminalereignis l√∂scht MulticastProcessor seinen Speicher und neue Abonnenten erhalten sofort die Fertigstellung des Streams. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce5/28c/d0f/ce528cd0fa322e90765069652321a57c.png" alt="Bild"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459174/">https://habr.com/ru/post/de459174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459160/index.html">Wie w√§hlen Sie Produkte in Gesch√§ften aus?</a></li>
<li><a href="../de459162/index.html">"Um die Meisterschaft zu gewinnen, muss das Team im Einklang atmen." Interview mit Moskauer Workshops ICPC Trainer</a></li>
<li><a href="../de459166/index.html">Was sind Sie, Schlie√üungen in JavaScript?</a></li>
<li><a href="../de459168/index.html">Billig und fr√∂hlich mit Windows Defender umgehen: Meterpreter-Sitzung √ºber Python</a></li>
<li><a href="../de459172/index.html">Top 13 Scala-Bibliotheken f√ºr die Datenanalyse</a></li>
<li><a href="../de459176/index.html">Stabile Hochspannungsversorgung f√ºr PMT</a></li>
<li><a href="../de459180/index.html">TheOutloud - Sprechen Sie und teilen Sie Ihre Lieblingsartikel und -geschichten. Teil 2</a></li>
<li><a href="../de459182/index.html">GitLab: Mit der Ver√∂ffentlichung von Version 12.1 h√∂ren wir auf, MySQL zu unterst√ºtzen</a></li>
<li><a href="../de459184/index.html">Grundlegende Einheitsf√§higkeiten</a></li>
<li><a href="../de459188/index.html">Debian 10 Buster und Linux 5.2 ver√∂ffentlicht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>