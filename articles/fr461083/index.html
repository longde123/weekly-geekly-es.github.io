<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìî üêøÔ∏è üëÜüèΩ Logiciel d'√©criture avec la fonctionnalit√© des utilitaires client-serveur Windows, partie 02 üò∞ üë©üèº‚Äçüîß ü§ôüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Poursuivant la s√©rie d'articles sur les impl√©mentations personnalis√©es des utilitaires de console dans Windows, TFTP (Trivial File Transfer Protocol) ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Logiciel d'√©criture avec la fonctionnalit√© des utilitaires client-serveur Windows, partie 02</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461083/">  Poursuivant la s√©rie d'articles sur les impl√©mentations personnalis√©es des utilitaires de console dans Windows, TFTP (Trivial File Transfer Protocol) est un simple protocole de transfert de fichiers. <br><br>  Comme la derni√®re fois, nous passons bri√®vement en revue la th√©orie, voyons un code qui impl√©mente une fonctionnalit√© similaire √† celle requise, et l'analysons.  En savoir plus - sous la coupe <a name="habracut"></a><br><br>  Je ne copierai pas les informations de r√©f√©rence, dont les liens se trouvent traditionnellement √† la fin de l'article, je dirai simplement que TFTP est essentiellement une variante simplifi√©e du protocole FTP dans lequel le param√®tre de contr√¥le d'acc√®s est supprim√©, et en fait il n'y a rien ici, sauf les commandes pour recevoir et transf√©rer le fichier .  Cependant, afin de rendre notre mise en ≈ìuvre un peu plus √©l√©gante et adapt√©e aux principes actuels de l'√©criture de code, la syntaxe est l√©g√®rement modifi√©e - elle ne change pas les principes de travail, mais l'interface, √† mon humble avis, devient un peu plus logique et combine les aspects positifs de FTP et TFTP. <br><br>  En particulier, au d√©marrage, le client demande l'adresse IP du serveur et le port sur lequel TFTP personnalis√© est ouvert (en raison d'une incompatibilit√© avec le protocole standard, j'ai jug√© appropri√© de laisser l'option de s√©lectionner le port √† l'utilisateur), apr√®s quoi une connexion se produit, √† la suite de laquelle le client peut envoyer l'une des commandes - get or put, pour recevoir ou envoyer un fichier au serveur.  Tous les fichiers sont envoy√©s en mode binaire - afin de simplifier la logique. <br><br>  Pour la mise en ≈ìuvre du protocole, j'ai traditionnellement utilis√© 4 classes: <br><br><ul><li>  TFTPClient </li><li>  TFTPServer </li><li>  TFTPClientTester </li><li>  TFTPServerTester </li></ul><br>  √âtant donn√© que les classes de test existent uniquement pour d√©boguer les principales, je ne les analyserai pas, mais le code sera dans le r√©f√©rentiel, un lien vers celui-ci peut √™tre trouv√© √† la fin de l'article.  Et maintenant je vais comprendre les classes principales. <br><br><h4>  TFTPClient </h4><br>  La t√¢che de cette classe est de se connecter au serveur distant par son adresse IP et son num√©ro de port, de lire une commande du flux d'entr√©e (dans ce cas, le clavier), de l'analyser, de la transf√©rer sur le serveur, et selon que vous souhaitez transf√©rer ou recevoir le fichier, le transf√©rer ou recevoir. <br><br>  Le code de lancement client pour se connecter au serveur et attendre une commande du flux d'entr√©e ressemble √† ceci.  Un certain nombre de variables globales utilis√©es ici sont d√©crites en dehors de l'article, dans le texte int√©gral du programme.  En raison de leur trivialit√©, je ne cite pas afin de ne pas surcharger l'article. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ip = ip; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.port = port; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { inicialization(); Scanner keyboard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scanner(System.in); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isRunning) { getAndParseInput(keyboard); sendCommand(); selector(); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.println(e.getMessage()); } }</code> </pre> <br>  Passons en revue les m√©thodes appel√©es dans ce bloc de code: <br><br>  Ici, le fichier est envoy√© - en utilisant le scanner, nous pr√©sentons le contenu du fichier sous forme de tableau d'octets, que nous √©crivons dans le socket un par un, puis le fermons et le rouvrons (pas la solution la plus √©vidente, mais il garantit la lib√©ration des ressources), apr√®s quoi nous affichons un message sur le succ√®s transmission. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String sourcePath, String destPath)</span></span></span><span class="hljs-function"> </span></span>{ File src = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(sourcePath); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { InputStream scanner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(src); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = scanner.readAllBytes(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> b : bytes) sout.write(b); sout.close(); inicialization(); System.out.println(<span class="hljs-string"><span class="hljs-string">"\nDone\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.println(e.getMessage()); } }</code> </pre> <br>  Ce fragment de code d√©crit la r√©ception de donn√©es du serveur.  Tout est √† nouveau banal, seul le premier bloc de code est int√©ressant.  Afin de comprendre exactement combien d'octets vous devez lire √† partir du socket, vous devez savoir combien p√®se le fichier transf√©r√©.  La taille du fichier sur le serveur semble √™tre un entier long, donc 4 octets sont accept√©s ici, qui sont ensuite convertis en un seul nombre.  Ce n'est pas une approche tr√®s Java, c'est assez similaire pour SI, mais √ßa r√©sout son probl√®me. <br><br>  Ensuite, tout est trivial - nous obtenons le nombre connu d'octets du socket et les √©crivons dans un fichier, apr√®s quoi nous affichons un message de r√©ussite. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String sourcePath, String destPath)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sizeOfFile = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] sizeBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[Long.SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt; Long.SIZE/Byte.SIZE; i++) { sizeBytes[i] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)sin.read(); sizeOfFile*=<span class="hljs-number"><span class="hljs-number">256</span></span>; sizeOfFile+=sizeBytes[i]; } FileOutputStream writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(destPath)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sizeOfFile; i++) { writer.write(sin.read()); } writer.close(); System.out.println(<span class="hljs-string"><span class="hljs-string">"\nDONE\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ System.out.println(e.getMessage()); } }</code> </pre> <br>  Si une commande autre que get ou put a √©t√© entr√©e dans la fen√™tre client, la fonction showErrorMessage sera appel√©e, indiquant l'inexactitude de l'entr√©e.  En raison de la trivialit√© - je ne cite pas.  Un peu plus int√©ressant est la fonction d'obtenir et de diviser la cha√Æne d'entr√©e.  Nous lui passons un scanner, √† partir duquel nous nous attendons √† recevoir une ligne s√©par√©e par deux espaces et contenant une commande, une adresse source et une adresse de destination. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAndParseInput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scanner scanner)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { input = scanner.nextLine().split(<span class="hljs-string"><span class="hljs-string">" "</span></span>); typeOfCommand = input[<span class="hljs-number"><span class="hljs-number">0</span></span>]; sourcePath = input[<span class="hljs-number"><span class="hljs-number">1</span></span>]; destPath = input[<span class="hljs-number"><span class="hljs-number">2</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bad input"</span></span>); } }</code> </pre> <br>  Envoi de commande - envoyer la commande entr√©e du scanner vers le socket et la forcer √† √™tre envoy√©e <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : input) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch : str.toCharArray()) { sout.write(ch); } sout.write(<span class="hljs-string"><span class="hljs-string">' '</span></span>); } sout.write(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.print(e.getMessage()); } }</code> </pre> <br>  Un s√©lecteur est une fonction qui d√©termine les actions d'un programme en fonction de la cha√Æne d'entr√©e.  Tout n'est pas tr√®s beau ici et l'astuce pas si bonne pour forcer le bloc de code √† √™tre utilis√© est utilis√©e, mais la principale raison en est l'absence en Java de certaines choses, comme les d√©l√©gu√©s en C #, les pointeurs vers une fonction en C ++, ou au moins un goto effrayant et terrible, qui laissez-vous le r√©aliser magnifiquement.  Si vous savez comment rendre le code un peu plus √©l√©gant, j'attends les critiques dans les commentaires.  Il me semble qu'un dictionnaire String-delegate est n√©cessaire ici, mais il n'y a pas de d√©l√©gu√© ... <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">selector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeOfCommand.equals(<span class="hljs-string"><span class="hljs-string">"get"</span></span>)){ get(sourcePath, destPath); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeOfCommand.equals(<span class="hljs-string"><span class="hljs-string">"put"</span></span>)){ put(sourcePath, destPath); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } showErrorMessage(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } }</code> </pre> <br><h4>  TFTPServer </h4><br>  La fonctionnalit√© du serveur diff√®re de la fonctionnalit√© du client dans l'ensemble uniquement en ce que les commandes qui lui sont transmises ne proviennent pas du clavier, mais de la prise.  Certaines m√©thodes co√Øncident, donc je ne les donnerai pas; je ne mentionnerai que les diff√©rences. <br><br>  Pour commencer ici, la m√©thode d'ex√©cution est utilis√©e, qui re√ßoit un port d'entr√©e et traite les donn√©es d'entr√©e de la socket dans un cycle √©ternel. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.port = port; incialization(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { getAndParseInput(); selector(); } }</code> </pre> <br>  La m√©thode put, qui est un wrapper de la m√©thode writeToFileFromSocket, qui ouvre le flux d'√©criture dans un fichier et √©crit tous les octets d'entr√©e √† partir du socket, une fois l'enregistrement termin√©, affiche un message sur la r√©ussite du transfert. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String source, String dest)</span></span></span></span>{ writeToFileFromSocket(); System.out.print(<span class="hljs-string"><span class="hljs-string">"\nDone\n"</span></span>); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeToFileFromSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { FileOutputStream writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(destPath)); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = sin.readAllBytes(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> b : bytes) { writer.write(b); } writer.close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ System.out.println(e.getMessage()); } }</code> </pre> <br>  La m√©thode get fournit un fichier serveur.  Comme d√©j√† mentionn√© dans la section sur le c√¥t√© client du programme, pour r√©ussir le transfert d'un fichier, vous devez conna√Ætre sa taille, stock√©e dans un entier long, donc je le divise en un tableau de 4 octets, les transf√®re vers l'octet de socket, puis, apr√®s les avoir re√ßus et collect√©s sur le client retour au num√©ro, je transf√®re tous les octets qui composent le fichier, lus √† partir du flux d'entr√©e du fichier. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String source, String dest)</span></span></span></span>{ File sending = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(source); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { FileInputStream readFromFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(sending); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] arr = readFromFile.readAllBytes(); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = ByteBuffer.allocate(Long.SIZE / Byte.SIZE).putLong(sending.length()).array(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;Long.SIZE / Byte.SIZE; i++) sout.write(bytes[i]); sout.flush(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> b : arr) sout.write(b); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ System.out.println(e.getMessage()); } };</code> </pre> <br>  La m√©thode getAndParseInput est la m√™me que dans le client, la seule diff√©rence √©tant qu'elle lit les donn√©es depuis le socket et non depuis le clavier.  Le code dans le r√©f√©rentiel, comme s√©lecteur. <br>  Dans ce cas, l'initialisation est effectu√©e dans un bloc de code s√©par√©, car  dans le cadre de cette impl√©mentation, une fois le transfert termin√©, les ressources sont √† nouveau lib√©r√©es et r√©occup√©es, toujours dans le but d'assurer une protection contre les fuites de m√©moire. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { serverSocket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServerSocket(port); socket = serverSocket.accept(); sin = socket.getInputStream(); sout = socket.getOutputStream(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.print(e.getMessage()); } }</code> </pre> <br>  En r√©sum√©: <br><br>  Nous venons d'√©crire notre variante sur un protocole de transfert de donn√©es simple et avons compris comment cela devrait fonctionner.  En principe, je n'ai pas d√©couvert l'Am√©rique et je n'ai pas √©crit grand-chose de nouveau, mais - il n'y avait pas d'articles similaires sur Habr√©, et dans le cadre de la r√©daction d'une s√©rie d'articles sur les utilitaires cmd, il √©tait impossible de ne pas le toucher. <br><br>  R√©f√©rences: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©p√¥t de code source</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">En bref sur TFTP</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">M√™me chose, mais en russe</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461083/">https://habr.com/ru/post/fr461083/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461073/index.html">Nous connectons des cartes en ligne au navigateur sur le smartphone. Partie 3 - OverpassTurbo</a></li>
<li><a href="../fr461075/index.html">Intelligence d'affaires. Objets informatiques, composants, outils</a></li>
<li><a href="../fr461077/index.html">Comment les pentesters sont-ils cuits? Test d'entr√©e pour les stagiaires en s√©curit√© num√©rique</a></li>
<li><a href="../fr461079/index.html">Ville sans embouteillage</a></li>
<li><a href="../fr461081/index.html">Le jour o√π Dodo IS s'est arr√™t√©. Script asynchrone</a></li>
<li><a href="../fr461085/index.html">Changer de langue dans l'application Android</a></li>
<li><a href="../fr461087/index.html">G√©n√©rer des donjons et des grottes pour mon jeu</a></li>
<li><a href="../fr461091/index.html">Lampes LED Camelion</a></li>
<li><a href="../fr461093/index.html">Nouvelles du monde d'OpenStreetMap n ¬∞ 469 (07/09/2019 - 07/07/2019)</a></li>
<li><a href="../fr461095/index.html">Apollo Guidance Computer - logiciel d'architecture et de syst√®me. Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>