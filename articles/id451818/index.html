<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¥ üìØ ü§ôüèæ Benteng atau bukan Benteng - itulah pertanyaannya üìõ üßëüèΩ‚Äçü§ù‚Äçüßëüèª üöµüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Awal bulan ini, 3 Mei, rilis utama "sistem manajemen untuk gudang data terdistribusi di Kubernetes" diumumkan - Rook 1.0.0 . Lebih dari setahun yang l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Benteng atau bukan Benteng - itulah pertanyaannya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/451818/"><img src="https://habrastorage.org/webt/pp/71/45/pp7145_00rhowbftvzhds-h7bkk.png"><br><br>  Awal bulan ini, 3 Mei, rilis utama "sistem manajemen untuk gudang data terdistribusi di Kubernetes" diumumkan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Rook 1.0.0</b></a> .  Lebih dari setahun yang lalu, kami sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerbitkan</a> tinjauan umum tentang Rook.  Kemudian kami diminta untuk berbicara tentang pengalaman <b>penggunaannya dalam praktik</b> - dan sekarang, pada waktunya untuk tonggak sejarah yang signifikan dalam sejarah proyek, kami dengan senang hati membagikan kesan-kesan kami yang terakumulasi. <br><br>  Singkatnya, Rook adalah seperangkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">operator</a> untuk Kubernetes yang mengambil kendali penuh atas penyebaran, manajemen, dan pemulihan otomatis solusi penyimpanan seperti Ceph, EdgeFS, Minio, Cassandra, CockroachDB. <a name="habracut"></a><br><br>  Pada saat ini, solusi yang paling berkembang (dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hanya</a> dalam tahap <b>stabil</b> ) adalah <a href="">operator rook-ceph</a> . <br><br>  <i><b>Catatan</b> : Di antara perubahan signifikan dalam rilis Rook 1.0.0 terkait dengan Ceph, dukungan Ceph Nautilus dan kemampuan untuk menggunakan NFS untuk bucket CephFS atau RGW dapat dicatat.</i>  <i>Antara lain, "jatuh tempo" dukungan EdgeFS ke tingkat beta menonjol.</i> <br><br>  Jadi, dalam artikel ini kita: <br><br><ul><li>  jawab pertanyaan tentang keuntungan apa yang kita lihat dalam menggunakan Rook untuk menyebarkan Ceph di kluster Kubernetes; </li><li>  berbagi pengalaman dan kesan menggunakan Rook dalam produksi; </li><li>  Kami akan memberi tahu Anda mengapa kami mengatakan "Ya!" Kepada Rook dan rencana kami untuknya. </li></ul><br>  Mari kita mulai dengan konsep dan teori umum. <br><br><h2>  "Aku punya keuntungan dalam satu Benteng!"  (pemain catur yang tidak dikenal) </h2><br><img src="https://habrastorage.org/webt/qb/su/7j/qbsu7jt4qtrayeg5vg21-wilmrw.png"><br><br>  Salah satu keuntungan utama Rook adalah interaksi dengan gudang data dilakukan melalui mekanisme Kubernetes.  Ini berarti Anda tidak perlu lagi menyalin perintah untuk mengkonfigurasi Ceph dari leaflet ke konsol. <br><br>  <i>- Ingin menggunakan dalam cluster CephFS?</i>  <i>Cukup tulis file yaml!</i> <i><br></i>  <i>- Apa?</i>  <i>Ingin menggunakan objek store dengan API S3?</i>  <i>Cukup tulis file yaml kedua!</i> <br><br>  Benteng dibuat oleh semua aturan operator biasa.  Interaksi dengannya terjadi dengan bantuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRD (Custom Resource Definition)</a> , di mana kami menggambarkan karakteristik entitas Ceph yang kami butuhkan <i>(karena ini adalah satu-satunya implementasi yang stabil, secara default artikel akan berbicara tentang Ceph, kecuali dinyatakan secara eksplisit sebaliknya)</i> .  Menurut parameter yang ditentukan, operator akan secara otomatis menjalankan perintah yang diperlukan untuk pengaturan. <br><br>  Mari kita lihat secara spesifik menggunakan contoh membuat Object Store, atau lebih tepatnya <code>CephObjectStoreUser</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: ceph.rook.io/v1 kind: CephObjectStore metadata: name: {{ .Values.s3.crdName }} namespace: kube-rook spec: metadataPool: failureDomain: host replicated: size: 3 dataPool: failureDomain: host erasureCoded: dataChunks: 2 codingChunks: 1 gateway: type: s3 sslCertificateRef: port: 80 securePort: instances: 1 allNodes: false --- apiVersion: ceph.rook.io/v1 kind: CephObjectStoreUser metadata: name: {{ .Values.s3.crdName }} namespace: kube-rook spec: store: {{ .Values.s3.crdName }} displayName: {{ .Values.s3.username }}</code> </pre> <br>  Parameter yang ditunjukkan dalam daftar cukup standar dan tidak membutuhkan komentar, tetapi Anda harus memberikan perhatian khusus kepada mereka yang disorot dalam variabel template. <br><br>  Skema umum pekerjaan datang ke fakta bahwa melalui file YAML kita "memesan" sumber daya, yang mana operator mengeksekusi perintah yang diperlukan dan mengembalikan kita rahasia "tidak nyata", yang dengannya kita dapat terus bekerja <i>(lihat di bawah)</i> .  Dan dari variabel yang ditunjukkan di atas, perintah dan nama rahasia akan disusun. <br><br>  Tim macam apa ini?  Saat membuat pengguna untuk penyimpanan objek, pernyataan Rook di dalam pod akan melakukan hal berikut: <br><br><pre> <code class="plaintext hljs">radosgw-admin user create --uid="rook-user" --display-name="{{ .Values.s3.username }}"</code> </pre> <br>  Hasil dari perintah ini adalah struktur JSON: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"rook-user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"display_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{ .Values.s3.username }}"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"keys"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"rook-user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"access_key"</span></span>: <span class="hljs-string"><span class="hljs-string">"NRWGT19TWMYOB1YDBV1Y"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"secret_key"</span></span>: <span class="hljs-string"><span class="hljs-string">"gr1VEGIV7rxcP3xvXDFCo4UDwwl2YoNrmtRlIAty"</span></span> } ], ... }</code> </pre> <br>  <code>Keys</code> adalah apa yang dibutuhkan aplikasi masa depan untuk mengakses penyimpanan objek melalui API S3.  Operator Rook dengan baik hati memilih mereka dan menempatkan mereka ke dalam namespace-nya sebagai rahasia dengan nama <code>rook-ceph-object-user-{{ $.Values.s3.crdName }}-{{ $.Values.s3.username }}</code> . <br><br>  Untuk menggunakan data dari rahasia ini, cukup tambahkan ke wadah sebagai variabel lingkungan.  Sebagai contoh, saya akan memberikan templat untuk Pekerjaan, di mana kami secara otomatis membuat keranjang untuk setiap lingkungan pengguna: <br><br><pre> <code class="plaintext hljs">{{- range $bucket := $.Values.s3.bucketNames }} apiVersion: batch/v1 kind: Job metadata: name: create-{{ $bucket }}-bucket-job annotations: "helm.sh/hook": post-install "helm.sh/hook-weight": "2" spec: template: metadata: name: create-{{ $bucket }}-bucket-job spec: restartPolicy: Never initContainers: - name: waitdns image: alpine:3.6 command: ["/bin/sh", "-c", "while ! getent ahostsv4 rook-ceph-rgw-{{ $.Values.s3.crdName }}; do sleep 1; done" ] - name: config image: rook/ceph:v1.0.0 command: ["/bin/sh", "-c"] args: ["s3cmd --configure --access_key=$(ACCESS-KEY) --secret_key=$(SECRET-KEY) -s --no-ssl --dump-config | tee /config/.s3cfg"] volumeMounts: - name: config mountPath: /config env: - name: ACCESS-KEY valueFrom: secretKeyRef: name: rook-ceph-object-user-{{ $.Values.s3.crdName }}-{{ $.Values.s3.username }} key: AccessKey - name: SECRET-KEY valueFrom: secretKeyRef: name: rook-ceph-object-user-{{ $.Values.s3.crdName }}-{{ $.Values.s3.username }} key: SecretKey containers: - name: create-bucket image: rook/ceph:v1.0.0 command: - "s3cmd" - "mb" - "--host=rook-ceph-rgw-{{ $.Values.s3.crdName }}" - "--host-bucket= " - "s3://{{ $bucket }}" ports: - name: s3-no-sll containerPort: 80 volumeMounts: - name: config mountPath: /root volumes: - name: config emptyDir: {} --- {{- end }}</code> </pre> <br>  Semua aktivitas yang tercantum dalam Pekerjaan ini dilakukan tanpa melampaui Kubernetes.  Struktur yang dijelaskan dalam file YAML dilipat ke dalam repositori Git dan digunakan kembali berulang kali.  Dalam hal ini kita melihat nilai tambah yang besar untuk insinyur DevOps dan proses CI / CD secara keseluruhan. <br><br><h2>  Dengan Rook dan Rados to Joy </h2><br>  Menggunakan sekelompok Ceph + RBD memberlakukan batasan tertentu pada volume pemasangan ke pod. <br><br>  Secara khusus, namespace harus memiliki rahasia untuk mengakses Ceph sehingga aplikasi stateful dapat berfungsi.  Tidak apa-apa jika Anda memiliki 2-3 lingkungan di ruang nama Anda: Anda bisa pergi dan menyalin rahasia secara manual.  Tetapi bagaimana jika setiap fitur pengembang menciptakan lingkungan yang terpisah dengan namespace-nya sendiri? <br><br>  Kami memecahkan masalah ini dengan bantuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">operator shell</a> , yang secara otomatis menyalin rahasia ke namespace baru (contoh kait seperti itu dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> ). <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#! /bin/bash if [[ $1 == ‚Äú--config‚Äù ]]; then cat &lt;&lt;EOF {"onKubernetesEvent":[ {"name": "OnNewNamespace", "kind": "namespace", "event": ["add"] } ]} EOF else NAMESPACE=$(kubectl get namespace -o json | jq '.items | max_by( .metadata.creationTimestamp ) | .metadata.name') kubectl -n ${CEPH_SECRET_NAMESPACE} get secret ${CEPH_SECRET_NAME} -o json | jq ".metadata.namespace=\"${NAMESPACE}\"" | kubectl apply -f - fi</span></span></code> </pre> <br>  Namun, ketika menggunakan Rook, masalah ini tidak ada.  Proses pemasangan berlangsung menggunakan driver Anda sendiri berdasarkan <a href="">Flexvolume</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CSI</a> (masih dalam versi beta) dan karenanya tidak memerlukan rahasia. <br><br>  Rook secara otomatis memecahkan banyak masalah, yang mendorong kita untuk menggunakannya dalam proyek-proyek baru. <br><br><h2>  Pengepungan Benteng </h2><br>  Kami menyelesaikan bagian praktis dengan penyebaran Rook dan Ceph untuk kemungkinan melakukan percobaan kami sendiri.  Untuk menyerbu menara yang tak tertembus ini, lebih mudah, para pengembang telah menyiapkan paket Helm.  Mari kita unduh: <br><br><pre> <code class="bash hljs">$ helm fetch rook-master/rook-ceph --untar --version 1.0.0</code> </pre> <br>  <code>rook-ceph/values.yaml</code> dapat menemukan banyak pengaturan berbeda di file <code>rook-ceph/values.yaml</code> .  Yang paling penting, tentukan toleransi untuk agen dan pencarian.  Mengapa Anda dapat menggunakan mekanisme noda / toleransi, kami jelaskan secara rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> . <br><br>  Singkatnya, kami tidak ingin pod dengan aplikasi klien ditempatkan di node yang sama di mana disk untuk penyimpanan data berada.  Alasannya sederhana: dengan cara ini kerja agen Rook tidak akan memengaruhi aplikasi itu sendiri. <br><br>  Jadi, buka file <code>rook-ceph/values.yaml</code> editor favorit <code>rook-ceph/values.yaml</code> dan tambahkan blok berikut di akhir: <br><br><pre> <code class="plaintext hljs">discover: toleration: NoExecute tolerationKey: node-role/storage agent: toleration: NoExecute tolerationKey: node-role/storage mountSecurityMode: Any</code> </pre> <br>  Untuk setiap node yang dicadangkan untuk penyimpanan data, tambahkan noda yang sesuai: <br><br><pre> <code class="bash hljs">$ kubectl taint node <span class="hljs-variable"><span class="hljs-variable">${NODE_NAME}</span></span> node-role/storage=<span class="hljs-string"><span class="hljs-string">""</span></span>:NoExecute</code> </pre> <br>  Kemudian instal Helm-chart dengan perintah: <br><br><pre> <code class="bash hljs">$ helm install --namespace <span class="hljs-variable"><span class="hljs-variable">${ROOK_NAMESPACE}</span></span> ./rook-ceph</code> </pre> <br>  Sekarang Anda perlu membuat cluster dan menunjukkan lokasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OSD</a> : <br><br><pre> <code class="plaintext hljs">apiVersion: ceph.rook.io/v1 kind: CephCluster metadata: clusterName: "ceph" finalizers: - cephcluster.ceph.rook.io generation: 1 name: rook-ceph spec: cephVersion: image: ceph/ceph:v13 dashboard: enabled: true dataDirHostPath: /var/lib/rook/osd mon: allowMultiplePerNode: false count: 3 network: hostNetwork: true rbdMirroring: workers: 1 placement: all: tolerations: - key: node-role/storage operator: Exists storage: useAllNodes: false useAllDevices: false config: osdsPerDevice: "1" storeType: filestore resources: limits: memory: "1024Mi" requests: memory: "1024Mi" nodes: - name: host-1 directories: - path: "/mnt/osd" - name: host-2 directories: - path: "/mnt/osd" - name: host-3 directories: - path: "/mnt/osd"</code> </pre> <br>  Periksa status Ceph - harap lihat <code>HEALTH_OK</code> : <br><br><pre> <code class="bash hljs">$ kubectl -n <span class="hljs-variable"><span class="hljs-variable">${ROOK_NAMESPACE}</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> $(kubectl -n <span class="hljs-variable"><span class="hljs-variable">${ROOK_NAMESPACE}</span></span> get pod -l app=rook-ceph-operator -o name -o jsonpath=<span class="hljs-string"><span class="hljs-string">'{.items[0].metadata.name}'</span></span>) -- ceph -s</code> </pre> <br>  Pada saat yang sama, periksa apakah pod dengan aplikasi klien tidak sampai ke node yang disediakan untuk Ceph: <br><br><pre> <code class="bash hljs">$ kubectl -n <span class="hljs-variable"><span class="hljs-variable">${APPLICATION_NAMESPACE}</span></span> get pods -o custom-columns=NAME:.metadata.name,NODE:.spec.nodeName</code> </pre> <br>  Komponen opsional lebih lanjut dikonfigurasikan.  Informasi lebih lanjut tentang mereka ditunjukkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> .  Untuk administrasi, kami sangat menyarankan untuk menginstal dasbor dan kotak peralatan. <br><br><h2>  Benteng dan pengait: apakah Benteng cukup untuk semuanya? </h2><br>  Seperti yang Anda lihat, pengembangan Rook sedang berjalan lancar.  Tetapi masih ada masalah yang tidak memungkinkan kita untuk sepenuhnya meninggalkan konfigurasi manual Ceph: <br><br><ul><li>  Tidak ada driver Rook yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat</a> mengekspor metrik pada penggunaan blok yang dipasang, yang menghalangi kita memantau. </li><li>  Flexvolume dan CSI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak tahu cara</a> mengubah ukuran volume (tidak seperti RBD yang sama), jadi Rook kehilangan Alat yang berguna (dan terkadang sangat penting!). </li><li>  Benteng masih tidak sefleksibel Ceph biasa.  Jika kita ingin mengonfigurasi kumpulan metadata CephFS untuk disimpan di SSD, dan data itu sendiri di HDD, kita perlu mendaftarkan kelompok perangkat yang terpisah secara manual di peta CRUSH. </li><li>  Terlepas dari kenyataan bahwa rook-ceph-operator dianggap stabil, saat ini ada masalah tertentu ketika memperbarui Ceph dari versi 13 ke 14. </li></ul><br><h2>  Kesimpulan </h2><br>  <i>"Sekarang Rook ditutup dari dunia luar oleh pion, tapi kami percaya bahwa suatu hari dia akan memainkan peran yang menentukan dalam pesta!"</i>  <i>(kutipan diciptakan khusus untuk artikel ini)</i> <br><br>  Proyek Rook tidak diragukan lagi telah memenangkan hati kami - kami percaya bahwa [dengan semua kelebihan dan kekurangannya] itu pasti patut Anda perhatikan. <br><br>  Rencana kami selanjutnya adalah menjadikan rook-ceph sebagai modul untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">addon-operator</a> , yang akan membuatnya digunakan di banyak kluster Kubernet kami yang lebih sederhana dan lebih nyaman. <br><br><h2>  PS </h2><br>  Baca juga di blog kami: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rook adalah" gudang data mandiri untuk Kubernetes</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami membuat penyimpanan yang persisten dengan penyediaan di Kubernet berdasarkan Ceph</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Database dan Kubernetes (review dan laporan video)</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memperkenalkan operator-shell: membuat operator untuk Kubernet lebih mudah</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Operator untuk Kubernetes: Cara Menjalankan Aplikasi Stateful</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451818/">https://habr.com/ru/post/id451818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451802/index.html">Komunitas .Net dari Raiffeisenbank mengundang ke Broadcast mitap UPD</a></li>
<li><a href="../id451806/index.html">iOS Digest No. 5 (27 April - 16 Mei)</a></li>
<li><a href="../id451812/index.html">Sekarang pengembang yang baik diukur oleh pandangan dan pelanggan - dan ini buruk</a></li>
<li><a href="../id451814/index.html">Pembayaran RBKmoney di bawah tenda - infrastruktur platform pembayaran</a></li>
<li><a href="../id451816/index.html">Fuzzing gaya 2000 pada aplikasi Windows 10 modern</a></li>
<li><a href="../id451820/index.html">Tematik Habramitap # 1: pengembangan backend</a></li>
<li><a href="../id451822/index.html">Pekerjakan dan libatkan: jawab pertanyaan dari dua sisi</a></li>
<li><a href="../id451826/index.html">Meningkatkan Absurditas Pemasaran: Kasus yang Terbukti</a></li>
<li><a href="../id451828/index.html">Rahasia utama Google I / O 2019, yang tidak dapat ditemukan di Internet</a></li>
<li><a href="../id451830/index.html">Secara singkat dengan implementasi AES 128 ECB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>