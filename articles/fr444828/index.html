<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèø ‚ú® üç¨ Une explication simple des algorithmes de recherche de chemin et A * üìë ‚ûó üë∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partie 1. Algorithme de recherche g√©n√©ral 
 Pr√©sentation 
 Trouver un chemin est l'un de ces sujets qui sont g√©n√©ralement les plus difficiles pour les...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Une explication simple des algorithmes de recherche de chemin et A *</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444828/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif" alt="image"></div><br><h2>  Partie 1. Algorithme de recherche g√©n√©ral </h2><br><h2>  Pr√©sentation </h2><br>  Trouver un chemin est l'un de ces sujets qui sont g√©n√©ralement les plus difficiles pour les d√©veloppeurs de jeux.  Les gens comprennent particuli√®rement mal l'algorithme <strong>A *</strong> , et beaucoup pensent qu'il s'agit d'une sorte de magie incompr√©hensible. <br><br>  Le but de cet article est d'expliquer la recherche du chemin en g√©n√©ral et de <strong>A *</strong> en particulier d'une mani√®re tr√®s compr√©hensible et accessible, mettant ainsi un terme √† l'id√©e fausse r√©pandue que ce sujet est complexe.  Avec la bonne explication, tout est assez simple. <br><br>  Veuillez noter que dans l'article, nous consid√©rerons la recherche d'un moyen <em>pour les jeux</em> ;  contrairement aux articles plus acad√©miques, nous omettons les algorithmes de recherche tels que Depth-First ou Breadth-First.  Au lieu de cela, nous allons essayer de passer de z√©ro √† <strong>A * le</strong> plus rapidement possible. <br><a name="habracut"></a><br>  Dans la premi√®re partie, nous expliquerons les concepts les plus simples pour trouver un chemin.  En comprenant ces concepts de base, vous vous rendrez compte que <strong>A *</strong> est √©tonnamment √©vident. <br><br><h2>  Circuit simple </h2><br>  Bien que vous puissiez appliquer ces concepts √† des environnements 3D complexes arbitraires, commen√ßons par un sch√©ma extr√™mement simple: une grille carr√©e de 5 x 5. Pour plus de commodit√©, j'ai marqu√© chaque cellule avec une lettre majuscule. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2d/66c/ed8/e2d66ced82a4c1d4ed739583bd782245.png"></div><br>  <i>Maille simple.</i> <br><br>  La toute premi√®re chose que nous ferons est d'imaginer cet environnement sous forme de graphique.  Je ne vais pas expliquer en d√©tail ce qu'est un graphique;  Autrement dit, il s'agit d'un ensemble de cercles reli√©s par des fl√®ches.  Les cercles sont appel√©s <em>¬´n≈ìuds¬ª</em> et les fl√®ches sont <em>appel√©es ¬´bords¬ª</em> . <br><br>  Chaque n≈ìud repr√©sente un <em>¬´√©tat¬ª</em> dans lequel le personnage peut √™tre.  Dans notre cas, l'√©tat du personnage est sa position, nous cr√©ons donc un n≈ìud pour chaque cellule de la grille: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/d4b/4db/68ad4b4db470c1ce34434e6489a5a986.png"></div><br>  <i>N≈ìuds repr√©sentant les cellules de la grille.</i> <br><br>  Maintenant, ajoutez les c√¥tes.  Ils indiquent les √©tats qui peuvent √™tre <em>"atteints" √†</em> partir de chaque √©tat donn√©;  dans notre cas, nous pouvons passer de n'importe quelle cellule √† la suivante, √† l'exception des cellules bloqu√©es: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f73/56c/9be/f7356c9be0171d61c31e3e4c21bf9385.png"></div><br>  <i>Les arcs indiquent les mouvements autoris√©s entre les cellules de la grille.</i> <br><br>  Si nous pouvons passer de <strong>A</strong> √† <strong>B</strong> , alors nous disons que <strong>B</strong> est un <em>¬´voisin¬ª</em> du n≈ìud <strong>A.</strong> <br><br>  Il convient de noter que les c√¥tes ont une <em>direction</em> ;  nous avons besoin d'ar√™tes de <strong>A</strong> √† <strong>B</strong> et de <strong>B</strong> √† <strong>A.</strong>  Cela peut sembler superflu, mais pas lorsque des ¬´conditions¬ª plus complexes peuvent survenir.  Par exemple, un personnage peut tomber du toit au sol, mais ne peut pas sauter du sol au toit.  Vous pouvez passer de l'√©tat "vivant" √† l'√©tat "mort", mais pas l'inverse.  Et ainsi de suite. <br><br><h2>  Exemple </h2><br>  Supposons que nous voulons passer de <strong>A</strong> √† <strong>T.</strong>  Nous commen√ßons par <strong>A.</strong>  Vous pouvez faire exactement deux actions: aller en <strong>B</strong> ou aller en <strong>F.</strong> <br><br>  Disons que nous sommes pass√©s √† <strong>B.</strong>  Maintenant, nous pouvons faire deux choses: revenir √† <strong>A</strong> ou aller √† <strong>C.</strong>  Nous nous souvenons que nous √©tions d√©j√† en <strong>A</strong> et avons consid√©r√© les options l√†-bas, donc cela n'a aucun sens de le faire √† nouveau (sinon nous pouvons passer toute la journ√©e √† d√©placer <strong>A</strong> ‚Üí <strong>B</strong> ‚Üí <strong>A</strong> ‚Üí <strong>B</strong> ...).  Nous allons donc passer √† <strong>C.</strong> <br><br>  √âtant en <strong>C</strong> , nous n'avons nulle part o√π aller.  Revenir √† <strong>B est</strong> inutile, c'est-√†-dire que c'est une impasse.  Choisir la transition vers <strong>B</strong> quand nous √©tions en <strong>A</strong> √©tait une mauvaise id√©e;  vous devriez peut-√™tre essayer <strong>F √† la</strong> place? <br><br>  Nous r√©p√©tons simplement ce processus jusqu'√† ce que nous nous retrouvions en <strong>T.</strong>  √Ä ce moment, nous recr√©ons simplement le chemin √† partir de <strong>A</strong> , en revenant dans nos pas.  Nous sommes en <strong>T</strong> ;  comment en sommes-nous arriv√©s l√†?  De <strong>o</strong> ?  Autrement dit, la fin du chemin a la forme <strong>O</strong> ‚Üí <strong>T.</strong>  Comment sommes-nous arriv√©s √† <strong>O</strong> ?  Et ainsi de suite. <br><br>  Gardez √† l'esprit que nous ne bougeons pas vraiment;  tout cela n'√©tait qu'un processus de r√©flexion.  Nous continuons de nous tenir en <strong>A</strong> , et nous n'en sortirons pas avant d'avoir trouv√© tout le chemin.  Quand je dis ¬´d√©m√©nag√© en <strong>B</strong> ¬ª, je veux dire ¬´imaginez que nous avons d√©m√©nag√© en <strong>B</strong> ¬ª. <br><br><h2>  Algorithme g√©n√©ral </h2><br>  <strong>Cette section est la partie la plus importante de tout l'article</strong> .  Vous <em>devez</em> absolument le comprendre afin de pouvoir r√©aliser la recherche du chemin;  le reste (y compris <strong>A *</strong> ) ne sont que des d√©tails.  Dans cette section, vous comprendrez jusqu'√† ce que vous en <em>compreniez le sens</em> . <br><br>  De plus, cette section est incroyablement simple. <br><br>  Essayons de formaliser notre exemple, en le transformant en pseudo-code. <br><br>  Nous devons suivre les n≈ìuds que nous savons atteindre depuis le n≈ìud de d√©part.  Au d√©but, ce n'est que le n≈ìud de d√©part, mais dans le processus d '¬´exploration¬ª de la grille, nous apprendrons comment acc√©der √† d'autres n≈ìuds.  Appelons cette liste de n≈ìuds <code>reachable</code> : <br><br><pre> <code class="python hljs">reachable = [start_node]</code> </pre> <br>  Nous devons √©galement suivre les n≈ìuds d√©j√† examin√©s afin de ne pas les reconsid√©rer.  <code>explored</code> les <code>explored</code> : <br><br><pre> <code class="python hljs">explored = []</code> </pre> <br>  <strong>Ensuite, je d√©crirai le c≈ìur de l'algorithme</strong> : √† chaque √©tape de la recherche, nous s√©lectionnons l'un des n≈ìuds que nous savons atteindre et regardons quels nouveaux n≈ìuds nous pouvons en tirer.  Si nous d√©terminons comment atteindre le n≈ìud final (cible), le probl√®me est r√©solu!  Sinon, nous poursuivons la recherche. <br><br>  Si simple, qu'est-ce qui d√©√ßoit m√™me?  Et c'est vrai.  Mais c'est tout l'algorithme.  √âcrivons-le √©tape par √©tape avec un pseudo-code. <br><br>  Nous continuons √† chercher jusqu'√† ce que nous arrivions au n≈ìud final (dans ce cas, nous trouvons le chemin du n≈ìud initial au n≈ìud final), ou jusqu'√† ce que nous manquions de n≈ìuds dans lesquels vous pouvez rechercher (dans ce cas, il n'y a aucun moyen entre les n≈ìuds de d√©but et de fin) . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty:</code> </pre> <br>  Nous choisissons l'un des n≈ìuds vers lesquels nous savons arriver et qui n'a pas encore √©t√© √©tudi√©: <br><br><pre> <code class="python hljs"> node = choose_node(reachable)</code> </pre> <br>  Si nous venons d'apprendre √† se rendre au n≈ìud final, la t√¢che est termin√©e!  Nous avons juste besoin de construire le chemin en suivant les liens <code>previous</code> vers le n≈ìud de d√©part: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == goal_node: path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(node) node = node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Cela n'a aucun sens d'examiner le n≈ìud plus d'une fois, nous allons donc suivre ceci: <br><br><pre> <code class="python hljs"> reachable.remove(node) explored.add(node)</code> </pre> <br>  Nous identifions des n≈ìuds que nous ne pouvons pas atteindre d'ici.  Nous commen√ßons par une liste de n≈ìuds adjacents au n≈ìud actuel et supprimons ceux que nous avons d√©j√† examin√©s: <br><br><pre> <code class="python hljs"> new_reachable = get_adjacent_nodes(node) - explored</code> </pre> <br>  Nous prenons chacun d'eux: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_reachable:</code> </pre> <br>  Si nous savons d√©j√† comment atteindre le n≈ìud, ignorez-le.  Sinon, ajoutez-le √† la liste <code>reachable</code> , en suivant comment il y est entr√©: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  Trouver le n≈ìud final est une fa√ßon de quitter la boucle.  La seconde est lorsque l' <code>reachable</code> devient vide: nous n'avons plus de n≈ìuds qui peuvent √™tre explor√©s, et nous n'avons pas atteint le n≈ìud final, c'est-√†-dire qu'il n'y a aucun moyen de passer du n≈ìud initial au n≈ìud final: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Et ... c'est tout.  Il s'agit de l'algorithme entier, et le code de construction du chemin est allou√© dans une m√©thode distincte: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: if adjacent not in reachable adjacent.previous = node # Remember how we got there. reachable.add(adjacent) # If we get here, no path was found :( return None</span></span></code> </pre> <br>  Voici la fonction qui construit le chemin, en suivant les liens <code>previous</code> vers le n≈ìud de d√©part: <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  C‚Äôest tout.  <em>Il s'agit du</em> pseudocode de <em>chaque</em> algorithme de recherche de chemin, y compris <strong>A *</strong> . <br><br>  Relisez cette section jusqu'√† ce que vous compreniez comment tout fonctionne et, plus important encore, <em>pourquoi</em> tout fonctionne.  Il serait id√©al de dessiner un exemple √† la main sur papier, mais vous pouvez √©galement regarder une d√©mo interactive: <br><br><h2>  D√©mo interactive </h2><br>  Voici une d√©mo et un exemple de l'impl√©mentation de l'algorithme montr√© ci-dessus (vous pouvez l'ex√©cuter sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page de l'article original</a> ).  <code>choose_node</code> s√©lectionne simplement un n≈ìud al√©atoire.  Vous pouvez d√©marrer l'algorithme √©tape par √©tape et consulter la liste des <code>explored</code> <code>reachable</code> et <code>explored</code> , ainsi que la destination <code>previous</code> liens <code>previous</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/jk/cb/vtjkcb4tflduq7zu5p-oph2i73s.gif"></div><br>  Notez que la recherche se termine d√®s qu'un chemin est d√©tect√©;  il peut arriver que certains n≈ìuds ne soient m√™me pas pris en compte. <br><br><h2>  Conclusion </h2><br>  L'algorithme pr√©sent√© ici est un algorithme g√©n√©ral pour <em>tout</em> algorithme de recherche de chemin. <br><br>  Mais qu'est-ce qui distingue chaque algorithme d'un autre, pourquoi <strong>A *</strong> est <strong>A *</strong> ? <br><br>  Voici un conseil: si vous ex√©cutez la recherche dans la d√©mo plusieurs fois, vous verrez que l'algorithme ne trouve pas toujours le m√™me chemin.  Il trouve <em>un</em> chemin, et ce chemin n'est pas n√©cessairement le <em>plus court</em> .  Pourquoi? <br><br><h2>  Partie 2. Strat√©gies de recherche </h2><br>  Si vous ne comprenez pas compl√®tement l'algorithme d√©crit dans la section pr√©c√©dente, revenez-y et relisez-le, car il est n√©cessaire pour comprendre d'autres informations.  Lorsque vous le comprendrez, <strong>A * vous</strong> semblera tout √† fait naturel et logique. <br><br><h2>  Ingr√©dient secret </h2><br>  √Ä la fin de la partie pr√©c√©dente, j'ai laiss√© deux questions ouvertes: si chaque algorithme de recherche utilise le m√™me code, pourquoi <strong>A *</strong> se comporte-t-il comme <strong>A *</strong> ?  Et pourquoi la d√©mo trouve-t-elle parfois des chemins diff√©rents? <br><br>  Les r√©ponses aux deux questions sont li√©es les unes aux autres.  Bien que l'algorithme soit bien d√©fini, j'ai laiss√© un aspect non r√©solu, et il s'av√®re que c'est la cl√© pour expliquer le comportement des algorithmes de recherche: <br><br><pre> <code class="python hljs">node = choose_node(reachable)</code> </pre> <br>  C'est cette cha√Æne √† l'allure innocente qui distingue tous les algorithmes de recherche les uns des autres.  <code>choose_node</code> d√©pend de la m√©thode d' <code>choose_node</code> de <code>choose_node</code> . <br><br>  Alors pourquoi la d√©mo trouve-t-elle des chemins diff√©rents?  Parce que sa m√©thode <code>choose_node</code> s√©lectionne un n≈ìud de mani√®re al√©atoire. <br><br><h2>  La longueur compte </h2><br>  Avant de plonger dans les diff√©rences de comportement de la fonction <code>choose_node</code> , nous devons corriger une petite erreur dans l'algorithme d√©crit ci-dessus. <br><br>  Lorsque nous avons consid√©r√© les n≈ìuds adjacents au courant, nous avons ignor√© ceux qui savent d√©j√† comment r√©aliser: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  C'est une erreur: que se passe-t-il si nous venons de d√©couvrir la <em>meilleure</em> fa√ßon de s'y rendre?  Dans ce cas, il est n√©cessaire de modifier le lien de n≈ìud <code>previous</code> pour refl√©ter ce chemin plus court. <br><br>  Pour ce faire, nous devons conna√Ætre la longueur du chemin du n≈ìud de d√©part √† tout n≈ìud accessible.  Nous appellerons cela le co√ªt du chemin.  Pour l'instant, nous supposons que le passage d'un n≈ìud √† l'un des n≈ìuds voisins a un co√ªt constant de <code>1</code> . <br><br>  Avant de commencer la recherche, nous attribuons la valeur de <code>cost</code> de chaque n≈ìud √† l' <code>infinity</code> ;  gr√¢ce √† cela, <em>tout</em> chemin sera plus court que cela.  Nous allons √©galement d√©finir le <code>cost</code> n≈ìud <code>start_node</code> sur <code>0</code> . <br><br>  Voici √† quoi ressemblera le code: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: reachable.add(adjacent) <span class="hljs-comment"><span class="hljs-comment"># If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1</span></span></code> </pre> <br><h2>  M√™me co√ªt de recherche </h2><br>  Jetons maintenant un ≈ìil √† la m√©thode <code>choose_node</code> .  Si nous nous effor√ßons de trouver le chemin le plus court possible, alors choisir un n≈ìud au hasard n'est pas une bonne id√©e. <br><br>  Il est pr√©f√©rable de choisir un n≈ìud que nous pouvons atteindre √† partir du n≈ìud initial le long du chemin le plus court;  gr√¢ce √† cela, nous pr√©f√©rons g√©n√©ralement les chemins plus courts aux plus longs.  Cela ne signifie pas que les chemins plus longs ne seront pas du tout pris en compte, cela signifie que les chemins plus courts seront consid√©r√©s en premier.  Puisque l'algorithme se termine imm√©diatement apr√®s avoir trouv√© un chemin appropri√©, cela devrait nous permettre de trouver des chemins courts. <br><br>  Voici un exemple possible de la fonction <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> best_node == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> best_node.cost &gt; node.cost: best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Intuitivement, la recherche de cet algorithme se d√©veloppe ¬´radialement¬ª √† partir du n≈ìud de d√©but jusqu'√† ce qu'il atteigne le n≈ìud de fin.  Voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une d√©monstration interactive de</a> ce comportement: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nh/fn/jd/nhfnjd_ztdx3fbuqy5v5_am5hxw.gif"></div><br><h2>  Conclusion </h2><br>  Un simple changement dans la m√©thode de choix du n≈ìud consid√©r√© par les √©l√©ments suivants nous a permis d'obtenir un assez bon algorithme: il trouve le chemin le plus court du d√©but au n≈ìud final. <br><br>  Mais cet algorithme, dans une certaine mesure, reste "stupide".  Il continue de chercher partout jusqu'√† ce qu'il tombe sur un n≈ìud terminal.  Par exemple, quel est le point dans l'exemple illustr√© ci-dessus pour rechercher dans la direction <strong>A</strong> , s'il est √©vident que nous nous <em>√©loignons</em> du n≈ìud final? <br><br>  Est-il possible de rendre <code>choose_node</code> plus intelligent?  Pouvons-nous lui faire <em>diriger la recherche vers le n≈ìud final</em> , sans m√™me conna√Ætre √† l'avance le chemin correct? <br><br>  Il s'av√®re que nous pouvons - dans la partie suivante, nous arrivons enfin √† <code>choose_node</code> , qui nous permet de transformer l'algorithme de recherche de chemin g√©n√©ral en <strong>A *</strong> . <br><br><h2>  Partie 3. Retirez le voile du secret de A * </h2><br>  L'algorithme obtenu dans la partie pr√©c√©dente est assez bon: il trouve le chemin le plus court du n≈ìud de d√©part au n≈ìud final.  Cependant, il gaspille son √©nergie: il consid√®re les fa√ßons qu'une personne appelle manifestement erron√©es - elles <em>s'√©loignent</em> g√©n√©ralement du but.  Comment √©viter cela? <br><br><h2>  Algorithme magique </h2><br>  Imaginez que nous ex√©cutions un algorithme de recherche sur un ordinateur sp√©cial avec une puce qui peut faire de la <em>magie</em> .  Gr√¢ce √† cette puce incroyable, nous pouvons exprimer <code>choose_node</code> tr√®s simple, ce qui garantit de cr√©er le chemin le plus court sans perdre de temps √† explorer des chemins partiels qui ne m√®nent nulle part: <br><br><pre> <code class="python hljs">function choose_node (reachable): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> magic(reachable, <span class="hljs-string"><span class="hljs-string">" ,     "</span></span>)</code> </pre> <br>  Cela semble tentant, mais les puces magiques ont toujours besoin d'une sorte de code de bas niveau.  Voici une bonne approximation: <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = magic(node, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  C'est une excellente fa√ßon de s√©lectionner le n≈ìud suivant: vous s√©lectionnez un n≈ìud qui nous donne le chemin le plus court du d√©but au n≈ìud final, ce dont nous avons besoin. <br><br>  Nous avons √©galement minimis√© la quantit√© de magie utilis√©e: nous savons exactement quel est le co√ªt du d√©placement du n≈ìud de d√©part √† chaque n≈ìud (c'est <code>node.cost</code> ), et nous utilisons la magie uniquement pour pr√©dire le co√ªt du d√©placement du n≈ìud au n≈ìud final. <br><br><h2>  Pas magique, mais assez g√©nial A * </h2><br>  Malheureusement, les puces magiques sont nouvelles et nous avons besoin de l'assistance d'un √©quipement obsol√®te.  La plupart du code nous convient, √† l'exception de cette ligne: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Throws MuggleProcessorException cost_node_to_goal = magic(node, "   ")</span></span></code> </pre> <br>  Autrement dit, nous ne pouvons pas utiliser la magie pour d√©couvrir le co√ªt d'un chemin inexplor√©.  Eh bien, faisons une pr√©diction.  Nous serons optimistes et supposerons qu'il n'y a rien entre les n≈ìuds actuels et finaux, et nous pouvons simplement nous d√©placer directement: <br><br><pre> <code class="python hljs">cost_node_to_goal = distance(node, goal_node)</code> </pre> <br>  Notez que le <em>chemin</em> le <em>plus court</em> et la <em>distance minimale sont</em> diff√©rents: la distance minimale implique qu'il n'y a absolument aucun obstacle entre les n≈ìuds actuels et finaux. <br><br>  Cette estimation est assez simple √† obtenir.  Dans nos exemples de grille, il s'agit de la <em>distance des blocs de ville</em> entre deux n≈ìuds (c'est-√†-dire <code>abs(Ax - Bx) + abs(Ay - By)</code> ).  Si nous pouvions nous d√©placer en diagonale, alors la valeur serait <code>sqrt( (Ax - Bx)^2 + (Ay - By)^2 )</code> , et ainsi de suite.  Plus important encore, nous n'obtenons jamais une estimation de valeur <em>trop</em> √©lev√©e. <br><br>  Voici donc une version non <code>choose_node</code> de <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Une fonction qui estime la distance du courant au n≈ìud final est appel√©e <em>heuristique</em> , et cet algorithme de recherche, mesdames et messieurs, est appel√© ... <strong>A *</strong> . <br><br><h2>  D√©mo interactive </h2><br>  Pendant que vous vous remettez du choc caus√© par la prise de conscience que le myst√©rieux <strong>A *</strong> est en fait <em>si simple</em> , vous pouvez regarder la d√©mo (ou l'ex√©cuter dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article original</a> ).  Vous remarquerez que, contrairement √† l'exemple pr√©c√©dent, la recherche passe tr√®s peu de temps √† se d√©placer dans la mauvaise direction. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif"></div><br><h2>  Conclusion </h2><br>  Enfin, nous sommes arriv√©s √† l'algorithme <strong>A *</strong> , qui n'est rien de plus que l'algorithme de recherche g√©n√©ral d√©crit dans la premi√®re partie de l'article avec quelques am√©liorations d√©crites dans la deuxi√®me partie et en utilisant la fonction <code>choose_node</code> , qui s√©lectionne le n≈ìud qui, √† notre avis, nous rapproche de n≈ìud d'extr√©mit√©.  C‚Äôest tout. <br><br>  Voici un pseudo-code complet de la m√©thode principale pour votre r√©f√©rence: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here that we haven't explored before? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: # First time we see this node? if adjacent not in reachable: reachable.add(adjacent) # If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1 # If we get here, no path was found :( return None</span></span></code> </pre> <br>  M√©thode <code>build_path</code> : <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Et voici la m√©thode <code>choose_node</code> , qui la transforme en <strong>A *</strong> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  C‚Äôest tout. <br><br>  Mais pourquoi avons-nous besoin de la <strong>partie 4</strong> ? <br><br>  Maintenant que vous comprenez comment fonctionne <strong>A *</strong> , je veux parler de certains domaines √©tonnants de son application, qui sont loin d'√™tre limit√©s √† trouver des chemins dans une grille de cellules. <br><br><h2>  Partie 4. A * en pratique </h2><br>  Les trois premi√®res parties de l'article commencent par les fondements m√™mes des algorithmes de recherche de chemin et se terminent par une description claire de l'algorithme <strong>A *</strong> .  Tout cela est g√©nial en th√©orie, mais comprendre comment cela est applicable dans la pratique est un sujet compl√®tement diff√©rent. <br><br>  Par exemple, que se passe-t-il si notre monde n'est pas une grille? <br><br>  Que faire si un personnage ne peut pas pivoter instantan√©ment de 90 degr√©s? <br><br>  Comment construire un graphe si le monde est sans fin? <br><br>  Et si nous ne nous soucions pas de la longueur du chemin, mais que nous d√©pendons de l'√©nergie solaire et que nous devons √™tre sous le soleil autant que possible? <br><br>  Comment trouver le chemin le plus court vers l'un des deux n≈ìuds d'extr√©mit√©? <br><br><h2>  Fonction de co√ªt </h2><br>  Dans les premiers exemples, nous avons recherch√© le chemin le plus court entre les n≈ìuds de d√©but et de fin.  Cependant, au lieu de stocker des longueurs de chemin partielles dans la <code>length</code> variable, nous l'avons appel√© <code>cost</code> .  Pourquoi? <br><br>  Nous pouvons faire en sorte que <strong>A *</strong> recherche non seulement le <em>chemin</em> le <em>plus court</em> , mais aussi le <em>meilleur</em> , et la d√©finition du ¬´meilleur¬ª peut √™tre choisie en fonction de nos objectifs.  Lorsque nous avons besoin du chemin le plus court, le co√ªt est la longueur du chemin, mais si nous voulons minimiser, par exemple, la consommation de carburant, nous devons l'utiliser comme co√ªt.  Si nous voulons maximiser le ¬´temps pass√© sous le soleil¬ª, alors le co√ªt est le temps pass√© sans soleil.  Et ainsi de suite. <br><br>  Dans le cas g√©n√©ral, cela signifie que les co√ªts correspondants sont associ√©s √† chaque bord du graphique.  Dans les exemples ci-dessus, la valeur a √©t√© d√©finie implicitement et a toujours √©t√© consid√©r√©e comme √©gale √† <code>1</code> , car nous avons compt√© les √©tapes en cours de route.  Mais nous pouvons changer le co√ªt de la c√¥te selon ce que nous voulons minimiser. <br><br><h2>  Fonction de crit√®re </h2><br>  Disons que notre objet est une voiture et qu'il doit se rendre √† la station-service.  Tout ravitaillement nous conviendra.  Il prend l'itin√©raire le plus court jusqu'√† la station-service la plus proche. <br><br>  L'approche na√Øve consistera √† calculer tour √† tour le chemin le plus court vers chaque ravitaillement et √† s√©lectionner le plus court.  Cela fonctionnera, mais ce sera un processus assez co√ªteux. <br><br>  Et si nous pouvions remplacer un <code>goal_node</code> par une m√©thode qui, sur un n≈ìud donn√©, peut dire s'il est fini ou non.  Gr√¢ce √† cela, nous pouvons rechercher plusieurs objectifs en m√™me temps.  Nous devons √©galement modifier l'heuristique afin qu'elle renvoie le co√ªt estim√© minimum de tous les n≈ìuds d'extr√©mit√© possibles. <br><br>  Selon les sp√©cificit√©s de la situation, nous ne pourrons peut-√™tre pas atteindre l'objectif <em>parfaitement</em> , ou cela co√ªtera trop cher (si nous envoyons le personnage √† travers une demi-carte √©norme, la diff√©rence d'un pouce est-elle importante?), Donc la m√©thode <code>is_goal_node</code> peut retourner <code>true</code> lorsque nous Nous sommes "assez proches". <br><br><h2>  Aucune certitude n'est requise. </h2><br>  Repr√©senter le monde comme une grille discr√®te peut ne pas √™tre suffisant pour de nombreux jeux.  Prenons, par exemple, un jeu de tir √† la premi√®re personne ou un jeu de course.  Le monde est discret, mais il ne peut pas √™tre repr√©sent√© comme une grille. <br><br>  Mais il y a un probl√®me plus grave: et si le monde √©tait sans fin?  Dans ce cas, m√™me si nous pouvons le pr√©senter sous forme de grille, alors nous ne pourrons tout simplement pas construire un graphe correspondant √† la grille, car il doit √™tre infini. <br><br>  Cependant, tout n'est pas perdu.  Bien s√ªr, pour l'algorithme de recherche de graphiques, nous avons certainement besoin d'un graphique.  Mais personne n'a dit que le graphique devait √™tre <em>complet</em> ! <br><br>  Si vous regardez attentivement l'algorithme, vous remarquerez que nous ne faisons rien avec le graphique dans son ensemble;  nous examinons le graphe localement, obtenant des n≈ìuds que nous pouvons atteindre √† partir du n≈ìud en question.  Comme le montre la d√©mo <strong>A *</strong> , certains n≈ìuds du graphique ne sont pas du tout √©tudi√©s. <br><br>  Alors pourquoi ne construisons-nous pas simplement le graphique dans le processus de recherche? <br><br>  Nous faisons de la position actuelle du personnage le n≈ìud de d√©part.  Lors de l'appel √† <code>get_adjacent_nodes</code> il peut d√©terminer les fa√ßons possibles dont le personnage peut se d√©placer √† partir d'un n≈ìud donn√© et cr√©er des n≈ìuds voisins √† la vol√©e. <br><br><h2>  Au-del√† de trois dimensions </h2><br>  M√™me si votre monde est <i>vraiment</i> un maillage 2D, il y a d'autres aspects √† consid√©rer.  Par exemple, que faire si un personnage ne peut pas pivoter instantan√©ment de 90 ou 180 degr√©s, comme c'est g√©n√©ralement le cas? <br><br>  <em>L'√©tat</em> repr√©sent√© par chaque n≈ìud de recherche ne doit pas √™tre simplement une <em>position</em> ;  au contraire, il peut comprendre un ensemble de valeurs arbitrairement complexes.  Par exemple, si les virages √† 90 degr√©s prennent autant de temps que la transition d'une cellule √† une autre, l'√©tat du personnage peut √™tre d√©fini comme <code>[position, heading]</code> .  Chaque n≈ìud peut repr√©senter non seulement la position du personnage, mais aussi la direction de son regard;  et les nouveaux bords du graphique (explicites ou indirects) refl√®tent cela. <br><br>  Si vous revenez √† la grille 5x5 d'origine, la position de recherche initiale peut maintenant √™tre <code>[A, East]</code> .  Les n≈ìuds voisins sont maintenant <code>[B, East]</code> et <code>[A, South]</code> - si nous voulons atteindre <strong>F</strong> , nous devons d'abord ajuster la direction afin que le chemin prenne la forme <code>[A, East]</code> , <code>[A, South]</code> , <code>[F, South]</code> . <br><br>  Tireur √† la premi√®re personne?  Au moins quatre dimensions: <code>[X, Y, Z, Heading]</code> .  Peut-√™tre m√™me <code>[X, Y, Z, Heading, Health, Ammo]</code> . <br><br>  Notez que plus l'√©tat est complexe, plus la fonction heuristique doit √™tre complexe.  <strong>Un * lui</strong> - <strong>m√™me</strong> est simple;  l'art na√Æt souvent d'une bonne heuristique. <br><br><h2>  Conclusion </h2><br>  Le but de cet article est de dissiper une fois pour toutes le mythe selon lequel <strong>A *</strong> est un algorithme mystique qui ne peut √™tre d√©chiffr√©.  Au contraire, j'ai montr√© qu'il n'y a rien de myst√©rieux et qu'en fait on peut tout simplement en d√©duire en partant de z√©ro. <br><br><h3>  Lectures compl√©mentaires </h3><br>  Amit Patel a une excellente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Introduction √† l'algorithme A *¬ª</a> (et ses autres articles sur divers sujets sont √©galement excellents!). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444828/">https://habr.com/ru/post/fr444828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444816/index.html">Menuiserie DIY: attentes et r√©alit√©</a></li>
<li><a href="../fr444818/index.html">Citymobil - un guide pour les startups pour augmenter la stabilit√© en pleine croissance. Partie 1</a></li>
<li><a href="../fr444820/index.html">Mockdown: le moyen le plus rapide pour cr√©er des wireframes</a></li>
<li><a href="../fr444822/index.html">JDK 9 / JEP 280: la concat√©nation de cha√Ænes ne sera plus jamais la m√™me</a></li>
<li><a href="../fr444824/index.html">√Ä quoi ressemblent les robots Amazon et FedEx Courier</a></li>
<li><a href="../fr444830/index.html">Signature √©lectronique cloud en Russie et dans le monde</a></li>
<li><a href="../fr444832/index.html">¬´Pas de d√©ploiement vendredi¬ª et trois autres r√®gles de d√©veloppement tacites</a></li>
<li><a href="../fr444836/index.html">Pas besoin de penser √† la m√©moire, ont-ils dit ... Atelier CLRium # 5: Garbage Collector</a></li>
<li><a href="../fr444838/index.html">Meetup OWASP Russia</a></li>
<li><a href="../fr444840/index.html">3. Check Point Getting Started R80.20. Pr√©paration de la mise en page</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>