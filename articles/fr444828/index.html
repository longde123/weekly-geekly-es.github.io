<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏿 ✨ 🍬 Une explication simple des algorithmes de recherche de chemin et A * 📑 ➗ 👷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partie 1. Algorithme de recherche général 
 Présentation 
 Trouver un chemin est l'un de ces sujets qui sont généralement les plus difficiles pour les...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Une explication simple des algorithmes de recherche de chemin et A *</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444828/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif" alt="image"></div><br><h2>  Partie 1. Algorithme de recherche général </h2><br><h2>  Présentation </h2><br>  Trouver un chemin est l'un de ces sujets qui sont généralement les plus difficiles pour les développeurs de jeux.  Les gens comprennent particulièrement mal l'algorithme <strong>A *</strong> , et beaucoup pensent qu'il s'agit d'une sorte de magie incompréhensible. <br><br>  Le but de cet article est d'expliquer la recherche du chemin en général et de <strong>A *</strong> en particulier d'une manière très compréhensible et accessible, mettant ainsi un terme à l'idée fausse répandue que ce sujet est complexe.  Avec la bonne explication, tout est assez simple. <br><br>  Veuillez noter que dans l'article, nous considérerons la recherche d'un moyen <em>pour les jeux</em> ;  contrairement aux articles plus académiques, nous omettons les algorithmes de recherche tels que Depth-First ou Breadth-First.  Au lieu de cela, nous allons essayer de passer de zéro à <strong>A * le</strong> plus rapidement possible. <br><a name="habracut"></a><br>  Dans la première partie, nous expliquerons les concepts les plus simples pour trouver un chemin.  En comprenant ces concepts de base, vous vous rendrez compte que <strong>A *</strong> est étonnamment évident. <br><br><h2>  Circuit simple </h2><br>  Bien que vous puissiez appliquer ces concepts à des environnements 3D complexes arbitraires, commençons par un schéma extrêmement simple: une grille carrée de 5 x 5. Pour plus de commodité, j'ai marqué chaque cellule avec une lettre majuscule. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2d/66c/ed8/e2d66ced82a4c1d4ed739583bd782245.png"></div><br>  <i>Maille simple.</i> <br><br>  La toute première chose que nous ferons est d'imaginer cet environnement sous forme de graphique.  Je ne vais pas expliquer en détail ce qu'est un graphique;  Autrement dit, il s'agit d'un ensemble de cercles reliés par des flèches.  Les cercles sont appelés <em>«nœuds»</em> et les flèches sont <em>appelées «bords»</em> . <br><br>  Chaque nœud représente un <em>«état»</em> dans lequel le personnage peut être.  Dans notre cas, l'état du personnage est sa position, nous créons donc un nœud pour chaque cellule de la grille: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/d4b/4db/68ad4b4db470c1ce34434e6489a5a986.png"></div><br>  <i>Nœuds représentant les cellules de la grille.</i> <br><br>  Maintenant, ajoutez les côtes.  Ils indiquent les états qui peuvent être <em>"atteints" à</em> partir de chaque état donné;  dans notre cas, nous pouvons passer de n'importe quelle cellule à la suivante, à l'exception des cellules bloquées: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f73/56c/9be/f7356c9be0171d61c31e3e4c21bf9385.png"></div><br>  <i>Les arcs indiquent les mouvements autorisés entre les cellules de la grille.</i> <br><br>  Si nous pouvons passer de <strong>A</strong> à <strong>B</strong> , alors nous disons que <strong>B</strong> est un <em>«voisin»</em> du nœud <strong>A.</strong> <br><br>  Il convient de noter que les côtes ont une <em>direction</em> ;  nous avons besoin d'arêtes de <strong>A</strong> à <strong>B</strong> et de <strong>B</strong> à <strong>A.</strong>  Cela peut sembler superflu, mais pas lorsque des «conditions» plus complexes peuvent survenir.  Par exemple, un personnage peut tomber du toit au sol, mais ne peut pas sauter du sol au toit.  Vous pouvez passer de l'état "vivant" à l'état "mort", mais pas l'inverse.  Et ainsi de suite. <br><br><h2>  Exemple </h2><br>  Supposons que nous voulons passer de <strong>A</strong> à <strong>T.</strong>  Nous commençons par <strong>A.</strong>  Vous pouvez faire exactement deux actions: aller en <strong>B</strong> ou aller en <strong>F.</strong> <br><br>  Disons que nous sommes passés à <strong>B.</strong>  Maintenant, nous pouvons faire deux choses: revenir à <strong>A</strong> ou aller à <strong>C.</strong>  Nous nous souvenons que nous étions déjà en <strong>A</strong> et avons considéré les options là-bas, donc cela n'a aucun sens de le faire à nouveau (sinon nous pouvons passer toute la journée à déplacer <strong>A</strong> → <strong>B</strong> → <strong>A</strong> → <strong>B</strong> ...).  Nous allons donc passer à <strong>C.</strong> <br><br>  Étant en <strong>C</strong> , nous n'avons nulle part où aller.  Revenir à <strong>B est</strong> inutile, c'est-à-dire que c'est une impasse.  Choisir la transition vers <strong>B</strong> quand nous étions en <strong>A</strong> était une mauvaise idée;  vous devriez peut-être essayer <strong>F à la</strong> place? <br><br>  Nous répétons simplement ce processus jusqu'à ce que nous nous retrouvions en <strong>T.</strong>  À ce moment, nous recréons simplement le chemin à partir de <strong>A</strong> , en revenant dans nos pas.  Nous sommes en <strong>T</strong> ;  comment en sommes-nous arrivés là?  De <strong>o</strong> ?  Autrement dit, la fin du chemin a la forme <strong>O</strong> → <strong>T.</strong>  Comment sommes-nous arrivés à <strong>O</strong> ?  Et ainsi de suite. <br><br>  Gardez à l'esprit que nous ne bougeons pas vraiment;  tout cela n'était qu'un processus de réflexion.  Nous continuons de nous tenir en <strong>A</strong> , et nous n'en sortirons pas avant d'avoir trouvé tout le chemin.  Quand je dis «déménagé en <strong>B</strong> », je veux dire «imaginez que nous avons déménagé en <strong>B</strong> ». <br><br><h2>  Algorithme général </h2><br>  <strong>Cette section est la partie la plus importante de tout l'article</strong> .  Vous <em>devez</em> absolument le comprendre afin de pouvoir réaliser la recherche du chemin;  le reste (y compris <strong>A *</strong> ) ne sont que des détails.  Dans cette section, vous comprendrez jusqu'à ce que vous en <em>compreniez le sens</em> . <br><br>  De plus, cette section est incroyablement simple. <br><br>  Essayons de formaliser notre exemple, en le transformant en pseudo-code. <br><br>  Nous devons suivre les nœuds que nous savons atteindre depuis le nœud de départ.  Au début, ce n'est que le nœud de départ, mais dans le processus d '«exploration» de la grille, nous apprendrons comment accéder à d'autres nœuds.  Appelons cette liste de nœuds <code>reachable</code> : <br><br><pre> <code class="python hljs">reachable = [start_node]</code> </pre> <br>  Nous devons également suivre les nœuds déjà examinés afin de ne pas les reconsidérer.  <code>explored</code> les <code>explored</code> : <br><br><pre> <code class="python hljs">explored = []</code> </pre> <br>  <strong>Ensuite, je décrirai le cœur de l'algorithme</strong> : à chaque étape de la recherche, nous sélectionnons l'un des nœuds que nous savons atteindre et regardons quels nouveaux nœuds nous pouvons en tirer.  Si nous déterminons comment atteindre le nœud final (cible), le problème est résolu!  Sinon, nous poursuivons la recherche. <br><br>  Si simple, qu'est-ce qui déçoit même?  Et c'est vrai.  Mais c'est tout l'algorithme.  Écrivons-le étape par étape avec un pseudo-code. <br><br>  Nous continuons à chercher jusqu'à ce que nous arrivions au nœud final (dans ce cas, nous trouvons le chemin du nœud initial au nœud final), ou jusqu'à ce que nous manquions de nœuds dans lesquels vous pouvez rechercher (dans ce cas, il n'y a aucun moyen entre les nœuds de début et de fin) . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty:</code> </pre> <br>  Nous choisissons l'un des nœuds vers lesquels nous savons arriver et qui n'a pas encore été étudié: <br><br><pre> <code class="python hljs"> node = choose_node(reachable)</code> </pre> <br>  Si nous venons d'apprendre à se rendre au nœud final, la tâche est terminée!  Nous avons juste besoin de construire le chemin en suivant les liens <code>previous</code> vers le nœud de départ: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == goal_node: path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(node) node = node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Cela n'a aucun sens d'examiner le nœud plus d'une fois, nous allons donc suivre ceci: <br><br><pre> <code class="python hljs"> reachable.remove(node) explored.add(node)</code> </pre> <br>  Nous identifions des nœuds que nous ne pouvons pas atteindre d'ici.  Nous commençons par une liste de nœuds adjacents au nœud actuel et supprimons ceux que nous avons déjà examinés: <br><br><pre> <code class="python hljs"> new_reachable = get_adjacent_nodes(node) - explored</code> </pre> <br>  Nous prenons chacun d'eux: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_reachable:</code> </pre> <br>  Si nous savons déjà comment atteindre le nœud, ignorez-le.  Sinon, ajoutez-le à la liste <code>reachable</code> , en suivant comment il y est entré: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  Trouver le nœud final est une façon de quitter la boucle.  La seconde est lorsque l' <code>reachable</code> devient vide: nous n'avons plus de nœuds qui peuvent être explorés, et nous n'avons pas atteint le nœud final, c'est-à-dire qu'il n'y a aucun moyen de passer du nœud initial au nœud final: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Et ... c'est tout.  Il s'agit de l'algorithme entier, et le code de construction du chemin est alloué dans une méthode distincte: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: if adjacent not in reachable adjacent.previous = node # Remember how we got there. reachable.add(adjacent) # If we get here, no path was found :( return None</span></span></code> </pre> <br>  Voici la fonction qui construit le chemin, en suivant les liens <code>previous</code> vers le nœud de départ: <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  C’est tout.  <em>Il s'agit du</em> pseudocode de <em>chaque</em> algorithme de recherche de chemin, y compris <strong>A *</strong> . <br><br>  Relisez cette section jusqu'à ce que vous compreniez comment tout fonctionne et, plus important encore, <em>pourquoi</em> tout fonctionne.  Il serait idéal de dessiner un exemple à la main sur papier, mais vous pouvez également regarder une démo interactive: <br><br><h2>  Démo interactive </h2><br>  Voici une démo et un exemple de l'implémentation de l'algorithme montré ci-dessus (vous pouvez l'exécuter sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page de l'article original</a> ).  <code>choose_node</code> sélectionne simplement un nœud aléatoire.  Vous pouvez démarrer l'algorithme étape par étape et consulter la liste des <code>explored</code> <code>reachable</code> et <code>explored</code> , ainsi que la destination <code>previous</code> liens <code>previous</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/jk/cb/vtjkcb4tflduq7zu5p-oph2i73s.gif"></div><br>  Notez que la recherche se termine dès qu'un chemin est détecté;  il peut arriver que certains nœuds ne soient même pas pris en compte. <br><br><h2>  Conclusion </h2><br>  L'algorithme présenté ici est un algorithme général pour <em>tout</em> algorithme de recherche de chemin. <br><br>  Mais qu'est-ce qui distingue chaque algorithme d'un autre, pourquoi <strong>A *</strong> est <strong>A *</strong> ? <br><br>  Voici un conseil: si vous exécutez la recherche dans la démo plusieurs fois, vous verrez que l'algorithme ne trouve pas toujours le même chemin.  Il trouve <em>un</em> chemin, et ce chemin n'est pas nécessairement le <em>plus court</em> .  Pourquoi? <br><br><h2>  Partie 2. Stratégies de recherche </h2><br>  Si vous ne comprenez pas complètement l'algorithme décrit dans la section précédente, revenez-y et relisez-le, car il est nécessaire pour comprendre d'autres informations.  Lorsque vous le comprendrez, <strong>A * vous</strong> semblera tout à fait naturel et logique. <br><br><h2>  Ingrédient secret </h2><br>  À la fin de la partie précédente, j'ai laissé deux questions ouvertes: si chaque algorithme de recherche utilise le même code, pourquoi <strong>A *</strong> se comporte-t-il comme <strong>A *</strong> ?  Et pourquoi la démo trouve-t-elle parfois des chemins différents? <br><br>  Les réponses aux deux questions sont liées les unes aux autres.  Bien que l'algorithme soit bien défini, j'ai laissé un aspect non résolu, et il s'avère que c'est la clé pour expliquer le comportement des algorithmes de recherche: <br><br><pre> <code class="python hljs">node = choose_node(reachable)</code> </pre> <br>  C'est cette chaîne à l'allure innocente qui distingue tous les algorithmes de recherche les uns des autres.  <code>choose_node</code> dépend de la méthode d' <code>choose_node</code> de <code>choose_node</code> . <br><br>  Alors pourquoi la démo trouve-t-elle des chemins différents?  Parce que sa méthode <code>choose_node</code> sélectionne un nœud de manière aléatoire. <br><br><h2>  La longueur compte </h2><br>  Avant de plonger dans les différences de comportement de la fonction <code>choose_node</code> , nous devons corriger une petite erreur dans l'algorithme décrit ci-dessus. <br><br>  Lorsque nous avons considéré les nœuds adjacents au courant, nous avons ignoré ceux qui savent déjà comment réaliser: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  C'est une erreur: que se passe-t-il si nous venons de découvrir la <em>meilleure</em> façon de s'y rendre?  Dans ce cas, il est nécessaire de modifier le lien de nœud <code>previous</code> pour refléter ce chemin plus court. <br><br>  Pour ce faire, nous devons connaître la longueur du chemin du nœud de départ à tout nœud accessible.  Nous appellerons cela le coût du chemin.  Pour l'instant, nous supposons que le passage d'un nœud à l'un des nœuds voisins a un coût constant de <code>1</code> . <br><br>  Avant de commencer la recherche, nous attribuons la valeur de <code>cost</code> de chaque nœud à l' <code>infinity</code> ;  grâce à cela, <em>tout</em> chemin sera plus court que cela.  Nous allons également définir le <code>cost</code> nœud <code>start_node</code> sur <code>0</code> . <br><br>  Voici à quoi ressemblera le code: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: reachable.add(adjacent) <span class="hljs-comment"><span class="hljs-comment"># If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1</span></span></code> </pre> <br><h2>  Même coût de recherche </h2><br>  Jetons maintenant un œil à la méthode <code>choose_node</code> .  Si nous nous efforçons de trouver le chemin le plus court possible, alors choisir un nœud au hasard n'est pas une bonne idée. <br><br>  Il est préférable de choisir un nœud que nous pouvons atteindre à partir du nœud initial le long du chemin le plus court;  grâce à cela, nous préférons généralement les chemins plus courts aux plus longs.  Cela ne signifie pas que les chemins plus longs ne seront pas du tout pris en compte, cela signifie que les chemins plus courts seront considérés en premier.  Puisque l'algorithme se termine immédiatement après avoir trouvé un chemin approprié, cela devrait nous permettre de trouver des chemins courts. <br><br>  Voici un exemple possible de la fonction <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> best_node == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> best_node.cost &gt; node.cost: best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Intuitivement, la recherche de cet algorithme se développe «radialement» à partir du nœud de début jusqu'à ce qu'il atteigne le nœud de fin.  Voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une démonstration interactive de</a> ce comportement: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nh/fn/jd/nhfnjd_ztdx3fbuqy5v5_am5hxw.gif"></div><br><h2>  Conclusion </h2><br>  Un simple changement dans la méthode de choix du nœud considéré par les éléments suivants nous a permis d'obtenir un assez bon algorithme: il trouve le chemin le plus court du début au nœud final. <br><br>  Mais cet algorithme, dans une certaine mesure, reste "stupide".  Il continue de chercher partout jusqu'à ce qu'il tombe sur un nœud terminal.  Par exemple, quel est le point dans l'exemple illustré ci-dessus pour rechercher dans la direction <strong>A</strong> , s'il est évident que nous nous <em>éloignons</em> du nœud final? <br><br>  Est-il possible de rendre <code>choose_node</code> plus intelligent?  Pouvons-nous lui faire <em>diriger la recherche vers le nœud final</em> , sans même connaître à l'avance le chemin correct? <br><br>  Il s'avère que nous pouvons - dans la partie suivante, nous arrivons enfin à <code>choose_node</code> , qui nous permet de transformer l'algorithme de recherche de chemin général en <strong>A *</strong> . <br><br><h2>  Partie 3. Retirez le voile du secret de A * </h2><br>  L'algorithme obtenu dans la partie précédente est assez bon: il trouve le chemin le plus court du nœud de départ au nœud final.  Cependant, il gaspille son énergie: il considère les façons qu'une personne appelle manifestement erronées - elles <em>s'éloignent</em> généralement du but.  Comment éviter cela? <br><br><h2>  Algorithme magique </h2><br>  Imaginez que nous exécutions un algorithme de recherche sur un ordinateur spécial avec une puce qui peut faire de la <em>magie</em> .  Grâce à cette puce incroyable, nous pouvons exprimer <code>choose_node</code> très simple, ce qui garantit de créer le chemin le plus court sans perdre de temps à explorer des chemins partiels qui ne mènent nulle part: <br><br><pre> <code class="python hljs">function choose_node (reachable): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> magic(reachable, <span class="hljs-string"><span class="hljs-string">" ,     "</span></span>)</code> </pre> <br>  Cela semble tentant, mais les puces magiques ont toujours besoin d'une sorte de code de bas niveau.  Voici une bonne approximation: <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = magic(node, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  C'est une excellente façon de sélectionner le nœud suivant: vous sélectionnez un nœud qui nous donne le chemin le plus court du début au nœud final, ce dont nous avons besoin. <br><br>  Nous avons également minimisé la quantité de magie utilisée: nous savons exactement quel est le coût du déplacement du nœud de départ à chaque nœud (c'est <code>node.cost</code> ), et nous utilisons la magie uniquement pour prédire le coût du déplacement du nœud au nœud final. <br><br><h2>  Pas magique, mais assez génial A * </h2><br>  Malheureusement, les puces magiques sont nouvelles et nous avons besoin de l'assistance d'un équipement obsolète.  La plupart du code nous convient, à l'exception de cette ligne: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Throws MuggleProcessorException cost_node_to_goal = magic(node, "   ")</span></span></code> </pre> <br>  Autrement dit, nous ne pouvons pas utiliser la magie pour découvrir le coût d'un chemin inexploré.  Eh bien, faisons une prédiction.  Nous serons optimistes et supposerons qu'il n'y a rien entre les nœuds actuels et finaux, et nous pouvons simplement nous déplacer directement: <br><br><pre> <code class="python hljs">cost_node_to_goal = distance(node, goal_node)</code> </pre> <br>  Notez que le <em>chemin</em> le <em>plus court</em> et la <em>distance minimale sont</em> différents: la distance minimale implique qu'il n'y a absolument aucun obstacle entre les nœuds actuels et finaux. <br><br>  Cette estimation est assez simple à obtenir.  Dans nos exemples de grille, il s'agit de la <em>distance des blocs de ville</em> entre deux nœuds (c'est-à-dire <code>abs(Ax - Bx) + abs(Ay - By)</code> ).  Si nous pouvions nous déplacer en diagonale, alors la valeur serait <code>sqrt( (Ax - Bx)^2 + (Ay - By)^2 )</code> , et ainsi de suite.  Plus important encore, nous n'obtenons jamais une estimation de valeur <em>trop</em> élevée. <br><br>  Voici donc une version non <code>choose_node</code> de <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Une fonction qui estime la distance du courant au nœud final est appelée <em>heuristique</em> , et cet algorithme de recherche, mesdames et messieurs, est appelé ... <strong>A *</strong> . <br><br><h2>  Démo interactive </h2><br>  Pendant que vous vous remettez du choc causé par la prise de conscience que le mystérieux <strong>A *</strong> est en fait <em>si simple</em> , vous pouvez regarder la démo (ou l'exécuter dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article original</a> ).  Vous remarquerez que, contrairement à l'exemple précédent, la recherche passe très peu de temps à se déplacer dans la mauvaise direction. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif"></div><br><h2>  Conclusion </h2><br>  Enfin, nous sommes arrivés à l'algorithme <strong>A *</strong> , qui n'est rien de plus que l'algorithme de recherche général décrit dans la première partie de l'article avec quelques améliorations décrites dans la deuxième partie et en utilisant la fonction <code>choose_node</code> , qui sélectionne le nœud qui, à notre avis, nous rapproche de nœud d'extrémité.  C’est tout. <br><br>  Voici un pseudo-code complet de la méthode principale pour votre référence: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here that we haven't explored before? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: # First time we see this node? if adjacent not in reachable: reachable.add(adjacent) # If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1 # If we get here, no path was found :( return None</span></span></code> </pre> <br>  Méthode <code>build_path</code> : <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Et voici la méthode <code>choose_node</code> , qui la transforme en <strong>A *</strong> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  C’est tout. <br><br>  Mais pourquoi avons-nous besoin de la <strong>partie 4</strong> ? <br><br>  Maintenant que vous comprenez comment fonctionne <strong>A *</strong> , je veux parler de certains domaines étonnants de son application, qui sont loin d'être limités à trouver des chemins dans une grille de cellules. <br><br><h2>  Partie 4. A * en pratique </h2><br>  Les trois premières parties de l'article commencent par les fondements mêmes des algorithmes de recherche de chemin et se terminent par une description claire de l'algorithme <strong>A *</strong> .  Tout cela est génial en théorie, mais comprendre comment cela est applicable dans la pratique est un sujet complètement différent. <br><br>  Par exemple, que se passe-t-il si notre monde n'est pas une grille? <br><br>  Que faire si un personnage ne peut pas pivoter instantanément de 90 degrés? <br><br>  Comment construire un graphe si le monde est sans fin? <br><br>  Et si nous ne nous soucions pas de la longueur du chemin, mais que nous dépendons de l'énergie solaire et que nous devons être sous le soleil autant que possible? <br><br>  Comment trouver le chemin le plus court vers l'un des deux nœuds d'extrémité? <br><br><h2>  Fonction de coût </h2><br>  Dans les premiers exemples, nous avons recherché le chemin le plus court entre les nœuds de début et de fin.  Cependant, au lieu de stocker des longueurs de chemin partielles dans la <code>length</code> variable, nous l'avons appelé <code>cost</code> .  Pourquoi? <br><br>  Nous pouvons faire en sorte que <strong>A *</strong> recherche non seulement le <em>chemin</em> le <em>plus court</em> , mais aussi le <em>meilleur</em> , et la définition du «meilleur» peut être choisie en fonction de nos objectifs.  Lorsque nous avons besoin du chemin le plus court, le coût est la longueur du chemin, mais si nous voulons minimiser, par exemple, la consommation de carburant, nous devons l'utiliser comme coût.  Si nous voulons maximiser le «temps passé sous le soleil», alors le coût est le temps passé sans soleil.  Et ainsi de suite. <br><br>  Dans le cas général, cela signifie que les coûts correspondants sont associés à chaque bord du graphique.  Dans les exemples ci-dessus, la valeur a été définie implicitement et a toujours été considérée comme égale à <code>1</code> , car nous avons compté les étapes en cours de route.  Mais nous pouvons changer le coût de la côte selon ce que nous voulons minimiser. <br><br><h2>  Fonction de critère </h2><br>  Disons que notre objet est une voiture et qu'il doit se rendre à la station-service.  Tout ravitaillement nous conviendra.  Il prend l'itinéraire le plus court jusqu'à la station-service la plus proche. <br><br>  L'approche naïve consistera à calculer tour à tour le chemin le plus court vers chaque ravitaillement et à sélectionner le plus court.  Cela fonctionnera, mais ce sera un processus assez coûteux. <br><br>  Et si nous pouvions remplacer un <code>goal_node</code> par une méthode qui, sur un nœud donné, peut dire s'il est fini ou non.  Grâce à cela, nous pouvons rechercher plusieurs objectifs en même temps.  Nous devons également modifier l'heuristique afin qu'elle renvoie le coût estimé minimum de tous les nœuds d'extrémité possibles. <br><br>  Selon les spécificités de la situation, nous ne pourrons peut-être pas atteindre l'objectif <em>parfaitement</em> , ou cela coûtera trop cher (si nous envoyons le personnage à travers une demi-carte énorme, la différence d'un pouce est-elle importante?), Donc la méthode <code>is_goal_node</code> peut retourner <code>true</code> lorsque nous Nous sommes "assez proches". <br><br><h2>  Aucune certitude n'est requise. </h2><br>  Représenter le monde comme une grille discrète peut ne pas être suffisant pour de nombreux jeux.  Prenons, par exemple, un jeu de tir à la première personne ou un jeu de course.  Le monde est discret, mais il ne peut pas être représenté comme une grille. <br><br>  Mais il y a un problème plus grave: et si le monde était sans fin?  Dans ce cas, même si nous pouvons le présenter sous forme de grille, alors nous ne pourrons tout simplement pas construire un graphe correspondant à la grille, car il doit être infini. <br><br>  Cependant, tout n'est pas perdu.  Bien sûr, pour l'algorithme de recherche de graphiques, nous avons certainement besoin d'un graphique.  Mais personne n'a dit que le graphique devait être <em>complet</em> ! <br><br>  Si vous regardez attentivement l'algorithme, vous remarquerez que nous ne faisons rien avec le graphique dans son ensemble;  nous examinons le graphe localement, obtenant des nœuds que nous pouvons atteindre à partir du nœud en question.  Comme le montre la démo <strong>A *</strong> , certains nœuds du graphique ne sont pas du tout étudiés. <br><br>  Alors pourquoi ne construisons-nous pas simplement le graphique dans le processus de recherche? <br><br>  Nous faisons de la position actuelle du personnage le nœud de départ.  Lors de l'appel à <code>get_adjacent_nodes</code> il peut déterminer les façons possibles dont le personnage peut se déplacer à partir d'un nœud donné et créer des nœuds voisins à la volée. <br><br><h2>  Au-delà de trois dimensions </h2><br>  Même si votre monde est <i>vraiment</i> un maillage 2D, il y a d'autres aspects à considérer.  Par exemple, que faire si un personnage ne peut pas pivoter instantanément de 90 ou 180 degrés, comme c'est généralement le cas? <br><br>  <em>L'état</em> représenté par chaque nœud de recherche ne doit pas être simplement une <em>position</em> ;  au contraire, il peut comprendre un ensemble de valeurs arbitrairement complexes.  Par exemple, si les virages à 90 degrés prennent autant de temps que la transition d'une cellule à une autre, l'état du personnage peut être défini comme <code>[position, heading]</code> .  Chaque nœud peut représenter non seulement la position du personnage, mais aussi la direction de son regard;  et les nouveaux bords du graphique (explicites ou indirects) reflètent cela. <br><br>  Si vous revenez à la grille 5x5 d'origine, la position de recherche initiale peut maintenant être <code>[A, East]</code> .  Les nœuds voisins sont maintenant <code>[B, East]</code> et <code>[A, South]</code> - si nous voulons atteindre <strong>F</strong> , nous devons d'abord ajuster la direction afin que le chemin prenne la forme <code>[A, East]</code> , <code>[A, South]</code> , <code>[F, South]</code> . <br><br>  Tireur à la première personne?  Au moins quatre dimensions: <code>[X, Y, Z, Heading]</code> .  Peut-être même <code>[X, Y, Z, Heading, Health, Ammo]</code> . <br><br>  Notez que plus l'état est complexe, plus la fonction heuristique doit être complexe.  <strong>Un * lui</strong> - <strong>même</strong> est simple;  l'art naît souvent d'une bonne heuristique. <br><br><h2>  Conclusion </h2><br>  Le but de cet article est de dissiper une fois pour toutes le mythe selon lequel <strong>A *</strong> est un algorithme mystique qui ne peut être déchiffré.  Au contraire, j'ai montré qu'il n'y a rien de mystérieux et qu'en fait on peut tout simplement en déduire en partant de zéro. <br><br><h3>  Lectures complémentaires </h3><br>  Amit Patel a une excellente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Introduction à l'algorithme A *»</a> (et ses autres articles sur divers sujets sont également excellents!). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444828/">https://habr.com/ru/post/fr444828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444816/index.html">Menuiserie DIY: attentes et réalité</a></li>
<li><a href="../fr444818/index.html">Citymobil - un guide pour les startups pour augmenter la stabilité en pleine croissance. Partie 1</a></li>
<li><a href="../fr444820/index.html">Mockdown: le moyen le plus rapide pour créer des wireframes</a></li>
<li><a href="../fr444822/index.html">JDK 9 / JEP 280: la concaténation de chaînes ne sera plus jamais la même</a></li>
<li><a href="../fr444824/index.html">À quoi ressemblent les robots Amazon et FedEx Courier</a></li>
<li><a href="../fr444830/index.html">Signature électronique cloud en Russie et dans le monde</a></li>
<li><a href="../fr444832/index.html">«Pas de déploiement vendredi» et trois autres règles de développement tacites</a></li>
<li><a href="../fr444836/index.html">Pas besoin de penser à la mémoire, ont-ils dit ... Atelier CLRium # 5: Garbage Collector</a></li>
<li><a href="../fr444838/index.html">Meetup OWASP Russia</a></li>
<li><a href="../fr444840/index.html">3. Check Point Getting Started R80.20. Préparation de la mise en page</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>