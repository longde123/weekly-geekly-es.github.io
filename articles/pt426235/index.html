<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍✈️ 😞 ☝🏻 Fiasco. A história de uma IoT caseira 🏜️ 🖨️ 🍽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A maioria dos artigos é escrita com o princípio "eu / nós fizemos / e, olha que legal!". A mesma publicação é dedicada a um projeto com falha. Bem-vin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fiasco. A história de uma IoT caseira</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426235/">  A maioria dos artigos é escrita com o princípio "eu / nós fizemos / e, olha que legal!".  A mesma publicação é dedicada a um projeto com falha.  Bem-vindo ao gato… <br><a name="habracut"></a><br><p>  Esta é uma continuação da minha publicação.O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">desenvolvimento de dispositivos inteligentes no exemplo de um controlador de piso aquecido no ESP8266</a> </p><br><h1>  Vamos começar de longe </h1><br><p>  Eu moro em uma casa pequena, que foi construída de acordo com o meu projeto.  Layout - grade do euro, corredor, cozinha, sala no térreo, banheiro, quarto das crianças e quarto no segundo.  De paredes não convencionais - arbolit, fundação UShP, aquecendo exclusivamente TP.  Ao mesmo tempo, os pisos são de madeira, no segundo andar há um piso flutuante, TP - na placa GVL.  No primeiro andar, existem 3 laços de tubos TP (na verdade um quarto), no segundo - também três, mas cada loop é responsável por um quarto (quarto, banheiro, quarto das crianças) .A caldeira a gás de parede de 14 kW é responsável pelo calor.  A caldeira é controlada por um termostato sem fio programável semanalmente em chinês.  Em cada dia da semana, há quatro períodos, em cada período você pode definir a temperatura desejada.  Cérebros na bateria, o relé está oculto.  Isso funciona muito bem.  Mas muitas vezes preciso de mais do que tenho.  Eu queria controle da temperatura ambiente.  Eu olhei para as soluções propostas, eu não gostei de nada.  E a palavra "Arduino" chamou minha atenção.  E por profissão sou programador.  E lá vamos nós ... <br></p><br><h1>  Ferro </h1><br><p>  Eu não sou forte em ferro.  Soldar uma placa de desenvolvimento é o auge das minhas habilidades.  Mas o Arduino é uma coisa tão simples que eu percebi - mesmo com meu conhecimento em eletrônica, sou capaz de fazer um controlador de temperatura na casa que me convém. <br></p><br><h2>  Sensores de temperatura </h2><br><p>  Não gosto de fios no interior.  Tento excluí-los ou ocultá-los, se não puder excluí-los.  E de uma maneira um tanto sinuosa, passei a usar sensores sem fio de estações meteorológicas chinesas como sensores de temperatura ambiente.  Os sensores operam com baterias por um longo tempo e transmitem a uma frequência de 433 MHz.  É muito bom, você pode escolher cores diferentes, com e sem uma tela.  Olhando para o futuro, direi que cada fabricante de uma estação meteorológica inventa seu próprio protocolo para transmitir dados com um sensor.  Durante os experimentos, analisei os protocolos de 5 tipos de sensores - todos eles têm diferentes formatos de transferência de dados.  Eu desenvolvi uma biblioteca que recebe dados de 4 tipos de sensores.  Não entrei em contato com o quinto - seu protocolo não é semelhante aos outros devido à falta de limites de pacotes.  A principal ferramenta para análise de dados tornou-se um analisador de lógica chinesa.  Sem essa ferramenta, a análise de protocolo é praticamente impossível.  Custa um pouco, é fácil de usar - eu recomendo que você o obtenha em todos os arduinos. <br><br>  Eu implementei a biblioteca com o princípio de amostragem, frequência 10kHz.  Essa abordagem nos permitiu nivelar o ruído no ar e reduzir a carga no processador, em comparação com a abordagem com interrupções quando o nível no pino do receptor muda.  Para depuração, um analisador lógico foi usado: <br><br></p><div class="spoiler">  <b class="spoiler_title">Sinal de depuração</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jv/b-/9x/jvb-9xsuwfff_jzqssndoueqtuy.png"><br>  3 ... 6 canais - dados para depuração <br></div></div><br>  Vou dar exemplos de sensores e suas características. <br><br><ul><li>  Tipo 1: transferência de dados a cada 35 segundos.  O período não muda e isso é um problema ao usar 3 ou mais sensores - as horas nos sensores são um pouco diferentes, às vezes os sinais se sobrepõem e um ou dois sensores perdem a conexão por uma hora, duas ou três vezes por semana ou duas.  6 pacotes de dados em 0.8sec.  O ID do sensor muda cada vez que é ligado.  Não há dados de status da bateria. <br><br><div class="spoiler">  <b class="spoiler_title">Aparência</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/73/q4/hq/73q4hqy2kt2e1g6kskwknlxqgog.jpeg"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Dados</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/s3/tv/li/s3tvlign-mrzalbwnxgpetpsuze.png"><br>  Dados do receptor superior, as setas indicam interferência <br>  Abaixo estão os dados do transmissor. <br></div></div></li><li>  Tipo 2: Período de transmissão de dados - 40 ... 80 segundos, dependendo do canal.  O melhor protocolo na minha opinião é de 15 pacotes de dados em 0,6 segundos, existe uma soma de verificação.  O ID do sensor muda quando é ligado; há uma transmissão dos dados de status da bateria.  O transmissor mais fraco - quando você coloca o receptor em uma caixa, a qualidade da recepção piora visivelmente.  Provavelmente tratado com uma antena externa para o receptor. <br><br><div class="spoiler">  <b class="spoiler_title">Aparência</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/a-/74/mq/a-74mqp0kbs1rjamxutkfrch5ze.jpeg"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Dados</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hs/ad/pi/hsadpizjgluvzpbbmatcs8uxd1k.png"><br>  sem interferência <br></div></div></li><li>  Tipo 3: período de transferência de dados de 50 a 55 segundos, dependendo do canal.  7 pacotes em 0,6 seg.  O ID muda quando ativado, há uma transmissão de dados de status da bateria.  Boa escolha. <br><br><div class="spoiler">  <b class="spoiler_title">Aparência</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/s4/fe/qs/s4feqsvtxzspdzeh17diggowihi.jpeg"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Dados</b> <div class="spoiler_text">  Quase idêntico ao tipo 1 <br></div></div></li><li>  Tipo 4: Período de transmissão de dados 56 ... 76 segundos, dependendo do canal.  Não há tela.  O ID mutável quando ativado não é detectado.  Existem diferenças no ID entre diferentes instâncias? Não sei, tenho um desses sensores.  Dados sobre o estado da bateria - é.  Sinal poderoso, transmissão pulando quase nunca observada. <br><br><div class="spoiler">  <b class="spoiler_title">Aparência</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/g0/_x/ox/g0_xoxr4b9alivfg0u0cnycmj2c.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Dados</b> <div class="spoiler_text">  não preservado <br></div></div></li><li>  Tipo 5: não medi o período de transmissão, não há comutador de canal, não analisei profundamente o protocolo. <br><br><div class="spoiler">  <b class="spoiler_title">Aparência</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/6x/gl/gg/6xglggiwxyoraek8bzsfkwhn1bw.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Dados</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/-d/ar/ak/-darakisubee19ofjj-ywhqukt0.png"><br></div></div></li></ul><br><p>  Como resultado, a unidade receptora foi implementada no Arduino Pro Mini com transferência de dados via escravo i2c. <br></p><br><h2>  Arduino mega </h2><br><p>  Esta é a primeira plataforma na qual eu fiz o controlador.  Meu controlador tinha uma interface de comando, controlada por comandos inseridos via UART.  Nessa fase, planejei fazer uma interface WEB no ESP8266 e comunicá-la com o Mega no UART.  Eu tenho uma placa Robotdyn Mega combinada com uma ESP8266 e planejava construir esse desenvolvimento nesta placa.  Uma vantagem particular da placa é um grande número de portas externas.  Mas, no processo de conhecer o ESP8266, percebi que esse pequeno chip é capaz de combinar as funções do controlador e da interface. <br></p><br><h2>  ESP8266 </h2><br><p>  Usei a opção de miniplaca WeMos D1, que possui pequenas dimensões e um número suficiente de pinos para mim - levando em consideração o uso de um expansor de porta.  Há um grande número de bibliotecas para este fórum.  Por exemplo, me-no-dev / ESPAsyncWebServer é uma excelente biblioteca de servidores da Web com suporte para soquetes da Web.  Eu montei o controlador nesta placa.  Desenvolvi uma interface web.  Tudo funciona lindamente.  Mas, por uma razão incompreensível para mim, o tempo de atividade não passa de um dia.  Ou eu fiz algo torto ou algumas das bibliotecas usadas estão tortas.  Além disso, há um limite de 5 conexões simultâneas.  Se excedido - reinicie ou até mesmo congele (apesar do cão de guarda existente. Eu lutei com os trava usando um cão de guarda externo).  Considerando que minha interface da Web consiste em quase uma dúzia de arquivos e os navegadores carregam páginas em 5 fluxos paralelos, é fácil conseguir uma reinicialização.  Por mim, decidi - este fórum só pode ser usado como cliente.  Comecei a procurar outras soluções. <br><br></p><div class="spoiler">  <b class="spoiler_title">Capturas de tela da interface</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1l/ou/xa/1louxawbn02i_s0bo29nkf3bf-y.png"><br><br><img src="https://habrastorage.org/webt/gt/rs/qv/gtrsqvdpsbhca9mhutpqqwj5fy4.png"><br><br><img src="https://habrastorage.org/webt/gc/4v/kq/gc4vkq-nvkjd8iqa8w3tsnhavlm.png"><br><br><img src="https://habrastorage.org/webt/vi/id/gk/viidgkepui5yqftwgqx3u_kshfy.png"><br><br><img src="https://habrastorage.org/webt/ka/qv/ul/kaqvultuwafymejfaaa_qk8wvg8.png"><br></div></div><br><br><h2>  ESP32 </h2><br><p>  É como o herdeiro do ESP8266.  O ESP32 tem mais - frequência, memória, pernas, ... Mas o problema é - a biblioteca me-no-dev / ESPAsyncWebServer não funciona em termos de soquetes da web.  Absolutamente.  Crashes.  Algo relacionado ao multithreading.  Não encontrei outra biblioteca de servidores da Web com suporte para soquetes da Web. <br></p><br><h1>  SOC </h1><br><p>  Nesse estágio, eu decidi usar a placa com linux - não criei nada mais adequado. <br></p><br><p>  Meus requisitos do conselho.  Parece que não há muitos deles: <br></p><br><br><ul><li>  Eu não preciso de uma tela. </li><li>  Devido à falta de uma tela para a configuração inicial, a placa deve poder trabalhar no modo de ponto de acesso. </li><li>  Eu preciso de um mínimo de funcionalidade do sistema operacional. </li></ul><br><h2>  Orange Pi i96 </h2><br><p>  Esta placa foi adequada em todos os aspectos - não há saída de vídeo, WiFi, memória flash embutida, slot para cartão SD.  Você pode colocar o Ubuntu ou DietPi na memória interna.  Mas o problema com esta placa é seu software.  Você não pode criar um ponto de acesso.  Bem, o maior problema - quando você reinicia, o endereço MAC muda e nada foi feito com isso.  No forno.  (No momento da redação deste artigo, em w3bsit3-dns.com, no segmento dedicado ao analógico deste quadro (2g IOT), apareceu uma mensagem dizendo que é possível derrotar a mudança de MAC) <br></p><br><h2>  Onion Omega 2+ </h2><br><p>  Documentação elegante.  Com o firmware pronto para uso, tudo foi iniciado, a tela não é necessária, o UART não é necessário.  O SSH está ativado por padrão.  O Node.js foi entregue (versão 4.x, mas isso não importa para mim).  As bibliotecas sqlite e i2c para Node.js foram entregues (usando um pandeiro) <br>  Além do i2c, não preciso mais de nenhuma interface de hardware.  Comparado à minha variante de desenvolvimento, um controlador Arduino Pro Mini foi adicionado ao ESP8266 para analisar os dados do receptor de dados do sensor de temperatura.  O controlador do receptor está conectado ao Omega como um escravo i2c.  Sensores com fio com uma interface de 1 fio são conectados através de uma ponte de 1 fio &lt;-&gt; i2c (DS2482-100).  Existe uma biblioteca para node.js para essa ponte, mas não funcionou para mim em termos de pesquisa de sensores.  Eu não entendi, eu portado para js essa biblioteca DS2482 que funcionava no ESP8266. <br><br>  Mas o problema é que o WiFi no Omega-2 não funciona de forma estável, não é reconectado após a reinicialização do roteador.  Esse problema foi resolvido pela versão de firmware 2, não está no status da versão, mas funciona.  Tornou-se muito melhor.  Mas o problema acabou - algumas vezes a placa cai do roteador Zyxel e se reconecta após a reinicialização do roteador ou após uma hora, duas ou três sem reiniciar o roteador.  Ou ele começa a ficar muito entorpecido - esse problema desapareceu depois de mudar o esquema de energia (a placa realmente gosta de 3,3v ou um pouco mais alta) e adicionar uma antena externa - o ômega ficou muito feliz com isso.  Assim, em princípio, estou satisfeito com a placa - o fato de que às vezes não há acesso não me incomoda muito - como interface principal, usei um smartphone antigo no dock conectado ao ponto de acesso Omega.  E o acesso remoto será muito necessário - eu posso reiniciar remotamente o roteador.  Isso causa mal-entendidos - o Omega-2 tem dois pinos RST - um deve ser enviado +, pelo que entendi, isso é processado programaticamente.  O que arquivar para o segundo e como conectar um cão de guarda externo que se alimenta - ainda não sei. <br><br></p><div class="spoiler">  <b class="spoiler_title">Interface no interior</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vc/5c/ax/vc5caxnocdaa4-td43zrfjlp-qk.jpeg"><br></div></div><br><h1>  Lógica do controlador </h1><p>  Já descrevi a arquitetura do software do controlador - ela não mudou (ou seja, gerenciando comandos de texto transmitidos por um soquete da web).  A interface da web foi migrada com o ESP8266 com alterações cosméticas.  Muitos procedimentos / funções do código do controlador foram simplesmente traduzidos de C ++ para JS.  Outra coisa é que a presença do linux (OpenWRT) me deu a oportunidade de usar o banco de dados SQL - sqlite.  Assim, organizei toda a lógica nas consultas SQL.  Esta é realmente a minha primeira experiência com sqlite.  Gostei especialmente da possibilidade de usar o banco de dados na memória - coloquei todos os dados temporários e atuais nesse banco de dados (por exemplo, dados do sensor, dados sobre a temperatura necessária atual, ...). <br><br></p><div class="spoiler">  <b class="spoiler_title">Código fonte</b> <div class="spoiler_text">  Geralmente compartilho idéias, não códigos-fonte.  Parece-me que isso estimula a atividade mental, minha e dos leitores.  Deseja obter a fonte - escreva de forma pessoal. <br></div></div><br><h1>  Assembléia </h1><p>  Coletei tudo em ferro, arrumado em uma caixa.  Testes de recursos adicionais.  Após uma semana de atividade, decidi que o teste havia sido aprovado.  É possível instalar. <br><br></p><div class="spoiler">  <b class="spoiler_title">Box</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/0_/mh/xa/0_mhxabqxjznpida6ihqrktupby.jpeg"><br></div></div><br><h1>  Instalação </h1><br><p>  Esta etapa foi muito bem sucedida.  Pendurei a caixa ao lado do coletor, instalei e conectei as cabeças térmicas.  Fiquei muito satisfeito com a minha ideia de armazenar todos os dados, configurações e parâmetros em um banco de dados - na hora eu consegui configurar os relés e zonas de uma maneira que não foi planejada, ou seja, três relés por zona e mover todos os outros relés (o original a ideia era uma zona - um relé).  O projeto incluiu o uso de um conjunto de sensores de serviço DS18B20, para monitorar a temperatura do meio de aquecimento no suprimento, no retorno de cada loop do piso quente, e a temperatura total de retorno - esses sensores também foram conectados e configurados com sucesso (todas as configurações - indicam o nome compreensível do sensor). <br></p><br><p>  Liguei o relé da caldeira. <br></p><br><h1>  Lançamento </h1><br><p>  O controlador funcionou como planejado. <br></p><br><p>  Para o teste, decidi aumentar levemente a temperatura em uma das salas do segundo andar. <br></p><br><p>  A caldeira começou a superaquecer e desligar. <br></p><br><p>  E então os sensores de serviço foram úteis.  Verificou-se que a temperatura da água na saída da alça desta sala é apenas um par de décimos de grau a menos do que na entrada!  A água não esfria!  Isso significa que ele não desiste de calor.  E a casa inteira está quente a qualquer temperatura no mar (o objetivo era diminuir um pouco a temperatura no segundo andar).  Assim, o primeiro andar fornece todo o calor, e o TP no segundo andar mal aquece o chão.  Como resultado, não é possível regular o aquecimento de sala em sala nessas condições. <br></p><br><h1>  Conclusão </h1><br><p>  Assim, a influência das características físicas e de design da minha casa pôs fim ao meu desenvolvimento.  Apesar do fato de o próprio controlador funcionar perfeitamente, não posso usá-lo no sistema de aquecimento da minha casa.  Talvez eu o faça rebaixar para que ele controle o clima na casa como um termostato chinês - de acordo com um sensor, mas até agora não entendi o motivo. <br></p><br><p>  No entanto, o projeto como um todo não é bem-sucedido, durante o processo de desenvolvimento, eu me familiarizei com muitas tecnologias com as quais eu quase não estava familiarizado: <br><br></p><ul><li>  Programação do controlador </li><li>  Eu aprendi sobre os barramentos de dados 1wire, i2c, uart, ... </li><li>  Obteve algum conhecimento no dispositivo do servidor web </li><li>  Parece ser uma boa compreensão do desenvolvimento de front-end da Web: html, JavaScript, vue.js </li><li>  Ele dominou o desenvolvimento de back-end da Web: node.js </li></ul><br><br><p>  Assim, adquiri muita experiência em um projeto com falha, o que pode ser útil em outros projetos. <br><br>  Quem leu este lugar pode ver o que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aconteceu</a> . <br>  (as três últimas configurações estão bloqueadas) </p><br><h1>  PS placa ideal para DIY </h1><br>  No processo de redação do artigo, outro problema com o Omega-2 foi descoberto - o módulo começou a congelar.  Difícil, redefinir não ajuda, basta desligar a energia.  Qual é o problema - ainda não sei.  Talvez ele não goste do aumento de potência - agora ele é alimentado com 3,8V.  Vou tentar substituir o módulo de energia.  Apesar do projeto não cumprir suas funções, agora o deixarei no modo termômetro (como se costuma dizer, não faça nada no Arduino - você terá uma estação meteorológica).  Mas, em qualquer caso, o tópico é interessante para mim, quero atingir 100% de disponibilidade do sistema 24/7.  Se a substituição da fonte de alimentação não ajudar, tentarei o sistema LinkIt Smart 7688. Parece idêntico ao hardware do Omega.  Pode ser mais estável. <br>  Além disso: depois de substituir o estabilizador linear 5-&gt; 3.3v por um pulso, o Onion Omega 2+ não teve problemas com o WiFi - operação estável por uma semana.  Então ele escreveu este suplemento. <br><br>  Com base nisso - ainda não encontrei a placa de opção ideal para produtos caseiros :( <br><br>  Provavelmente, como o cérebro do próximo projeto, tentarei usar um smartphone no Android - você precisará conectar sensores a ele via wifi, mas praticamente não há problemas com a estabilidade dos telefones de marca.  E o node.js parece ser colocado no telefone. <br><br>  Ficaria muito grato se você compartilhar sua visão sobre a escolha de uma placa para DIY. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426235/">https://habr.com/ru/post/pt426235/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426223/index.html">Desenvolvimento Android e solução de problemas de desenvolvimento</a></li>
<li><a href="../pt426227/index.html">Como "cultivar" o Kaggle</a></li>
<li><a href="../pt426229/index.html">Código de Conduta: Por que os desenvolvedores de kernel Linux ameaçaram remover seu código - Entendendo o conflito</a></li>
<li><a href="../pt426231/index.html">Grã-Bretanha quer regular a Internet - quais novas leis afetarão</a></li>
<li><a href="../pt426233/index.html">Estudo: grandes parques eólicos podem aquecer o solo, o que afeta o clima</a></li>
<li><a href="../pt426237/index.html">Como determinar o tamanho mínimo necessário para uma pasta temporária de replicação DFSR</a></li>
<li><a href="../pt426241/index.html">Conferência BLACK HAT USA. Botnet de um milhão de navegadores. Parte 1</a></li>
<li><a href="../pt426243/index.html">Como entrar no Inferno por causa do Helm, mas pegue um canudo</a></li>
<li><a href="../pt426245/index.html">Melhorando os programas da Internet</a></li>
<li><a href="../pt426249/index.html">Controle de dispositivo Bluetooth</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>