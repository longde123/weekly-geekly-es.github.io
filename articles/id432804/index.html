<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüéì üåÑ üò´ Seluruh kebenaran tentang RTOS. Artikel # 24. Antrian: layanan tambahan dan struktur data üë®üèº üë©üèª‚Äç‚öñÔ∏è ‚õ©Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, kami akan terus mempertimbangkan antrian. 

 Layanan Antrian Sekunder 
 Nucleus RTOS memiliki empat panggilan API yang menyediakan f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang RTOS. Artikel # 24. Antrian: layanan tambahan dan struktur data</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432804/"><img src="https://habrastorage.org/webt/j7/rf/kj/j7rfkj7abgipgl8ohotufkmukwa.jpeg"><br><br>  Pada artikel ini, kami akan terus mempertimbangkan antrian. <br><br><h2>  Layanan Antrian Sekunder </h2><br>  Nucleus RTOS memiliki empat panggilan API yang menyediakan fungsi tambahan yang terkait dengan antrian: mengatur ulang antrian, menerima informasi antrian, mendapatkan jumlah antrian dalam suatu aplikasi, dan mendapatkan pointer ke semua antrian dalam suatu aplikasi.  Tiga fungsi pertama diimplementasikan dalam Nucleus SE. <br><a name="habracut"></a><br>  Artikel sebelumnya dalam seri: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antrian: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Surat: Layanan Tambahan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Surat: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semaphores: Layanan Tambahan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semaphores: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Layanan Pembantu dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sinyal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Partisi Memori: Layanan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian memori: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur data tugas dan panggilan API yang tidak didukung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan untuk bekerja dengan tugas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas: konfigurasi dan pengantar API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: fitur canggih dan pelestarian konteks</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Desain dan Penyebaran Internal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan RTOS lainnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interaksi tugas dan sinkronisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas, pengalihan konteks, dan interupsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas dan Perencanaan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: Struktur dan mode waktu-nyata</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: pengantar.</a> <br><br><h3>  Reset Antrian </h3><br>  Panggilan API ini mengatur ulang antrian ke kondisi aslinya, yang tidak digunakan.  Pesan apa pun yang disimpan dalam antrian akan hilang.  Tugas apa pun yang dijeda dalam antrian akan dilanjutkan dengan kode pengembalian <b>NUSE_QUEUE_WAS_RESET</b> . <br><br>  <b><i>Atur Ulang Antrian di Nucleus RTOS</i></b> <br>  Prototipe panggilan layanan: <br>  <b>STATUS NU_Reset_Queue (NU_QUEUE * antrian);</b> <br><br>  Parameter: <br>  <b>queue</b> - pointer ke blok kontrol antrian yang disediakan oleh pengguna. <br><br>  Nilai pengembalian: <br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_QUEUE</b> - penunjuk antrian tidak valid. <br><br>  <b><i>Atur Ulang Antrian di Nucleus SE</i></b> <br>  Panggilan utilitas ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NUSE_Queue_Reset (antrian NUSE_QUEUE);</b> <br><br>  Parameter: <br>  <b>antrian</b> - indeks (ID) dari antrian yang dibuang. <br><br>  Nilai pengembalian: <br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_INVALID_QUEUE</b> - indeks antrian tidak valid. <br><br>  <b><i>Menerapkan Reset Antrian di Nucleus SE</i></b> <br>  Kode fungsi <b>NUSE_Queue_Reset</b> (setelah memeriksa parameter) cukup sederhana.  Indeks kepala dan ekor antrian, serta penghitung pesan dalam antrian, diberi nilai nol. <br><br>  Jika penguncian tugas diaktifkan, kode tambahan bertanggung jawab untuk mengembalikan tugas yang ditangguhkan: <br><br><pre><code class="plaintext hljs">while (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this queue */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_QUEUE_WAS_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Queue_Blocking_Count[queue]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  Setiap tugas yang dijeda dalam antrian diberi status "siap" dengan kode pengembalian <b>NUSE_QUEUE_WAS_RESET</b> .  Setelah proses ini selesai, jika penjadwal Prioritas digunakan, fungsi <b>NUSE_Reschedule () dipanggil</b> , karena satu atau lebih tugas dengan prioritas tinggi dapat siap untuk dieksekusi. <br><br><h3>  Mendapatkan Informasi Antrian </h3><br>  Panggilan layanan ini menyediakan informasi antrian.  Implementasi panggilan ini dalam Nucleus SE berbeda dari Nucleus RTOS dalam hal ia mengembalikan lebih sedikit informasi karena penamaan objek, panjang pesan variabel, dan urutan jeda tugas tidak didukung, dan penguncian tugas dapat dinonaktifkan. <br><br>  <b><i>Panggilan untuk Informasi Antrian di Nucleus RTOS</i></b> <br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NU_Queue_Information (NU_QUEUE * antrian, CHAR * nama, VOID ** start_address, UNSIGNED * queue_size, UNSIGNED * tersedia, pesan UNSIGNED *, OPSI * message_type, UNSIGNED * message_size, OPTION * suspend_type, UNDKA_taskded_t_taskht_t_t_t_type, tanpa tanda kutip)</b> <br><br>  Parameter: <br><br>  <b>queue</b> - pointer ke blok kontrol antrian yang disediakan oleh pengguna; <br>  <b>name</b> - penunjuk ke wilayah 8 karakter untuk nama pesan dalam antrian; <br>  <b>start_address</b> - pointer ke pointer ke mana alamat awal area data antrian akan ditulis; <br>  <b>queue_size</b> - pointer ke variabel untuk menyimpan jumlah elemen <b>UNSIGNED</b> dalam antrian; <br>  <b>available</b> - pointer ke variabel untuk menyimpan jumlah elemen <b>UNSIGNED yang</b> tersedia dalam antrian; <br>  pesan - penunjuk ke variabel untuk menyimpan jumlah pesan saat ini dalam antrian; <br>  <b>message_type</b> - pointer ke variabel untuk menyimpan jenis pesan yang didukung oleh antrian.  Nilai yang valid adalah <b>NU_FIXED_SIZE</b> dan <b>NU_VARIABLE</b> ; <br>  <b>message_size</b> - pointer ke variabel untuk menyimpan jumlah elemen data <b>TANDA TANGAN</b> di setiap pesan dari antrian.  Jika antrian mendukung pesan panjang variabel, nomor ini menunjukkan panjang pesan maksimum; <br>  <b>suspend_type</b> - pointer ke variabel untuk menyimpan jenis penangguhan tugas.  Nilai yang valid adalah <b>NU_FIFO</b> dan <b>NU_PRIORITY</b> ; <br>  <b>task_waiting</b> - pointer ke variabel untuk menyimpan jumlah tugas yang ditangguhkan dalam antrian ini; <br>  <b>first_task</b> - penunjuk ke penunjuk tugas, tempat penunjuk tugas yang ditangguhkan pertama kali ditempatkan. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_QUEUE</b> - penunjuk antrian tidak valid. <br><br>  <b><i>Panggilan untuk Informasi Antrian di Nucleus SE</i></b> <br>  Panggilan API ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NUSE_Queue_Information (NUSE_QUEUE antrian, ADDR * start_address, U8 * queue_size, U8 * tersedia, pesan U8 *, U8 * tugas_menunggu, NUSE_TASK * first_task);</b> <br><br>  Parameter: <br><br>  <b>antrian</b> - indeks antrian tentang informasi mana yang diminta; <br>  <b>start_address</b> - penunjuk ke variabel tipe <b>ADDR</b> , yang akan menyimpan alamat awal area data antrian; <br>  <b>queue_size</b> - pointer ke variabel tipe <b>U8</b> , yang akan menyimpan jumlah total pesan yang bisa masuk dalam antrian; <br>  <b>tersedia</b> - pointer ke variabel tipe <b>U8</b> , yang akan menyimpan jumlah tempat bebas dalam antrian; <br>  <b>messages</b> - penunjuk ke variabel tipe <b>U8</b> , yang akan menyimpan jumlah pesan saat ini dalam antrian; <br>  <b>task_waiting</b> - pointer ke variabel di mana jumlah tugas yang ditangguhkan pada antrian ini akan disimpan (tidak ada yang dikembalikan jika penguncian tugas dinonaktifkan); <br>  <b>first_task</b> - pointer ke variabel dari tipe <b>NUSE_TASK</b> di mana indeks tugas yang ditangguhkan pertama akan disimpan (tidak ada yang dikembalikan jika kunci tugas dinonaktifkan). <br><br>  Nilai pengembalian: <br><br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_INVALID_QUEUE</b> - indeks antrian tidak valid; <br>  <b>NUSE_INVALID_POINTER</b> - satu atau beberapa parameter pointer salah. <br><br>  <b><i>Menerapkan Tampilan Informasi Antrian di Nucleus SE</i></b> <br><br>  Menerapkan panggilan API ini cukup sederhana: <br><br><pre> <code class="plaintext hljs">*start_address = NUSE_Queue_Data[queue]; *queue_size = NUSE_Queue_Size[queue]; *available = NUSE_Queue_Size[queue] - NUSE_Queue_Items[queue]; *messages = NUSE_Queue_Items[queue]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Queue_Blocking_Count[queue]; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif</code> </pre><br>  Fungsi mengembalikan status antrian.  Kemudian, jika penguncian tugas diaktifkan, jumlah tugas yang tertunda dan indeks yang pertama dikembalikan (jika tidak, kedua parameter ditetapkan ke 0). <br><br><h3>  Mendapatkan jumlah antrian </h3><br>  Panggilan utilitas ini mengembalikan jumlah antrian yang dikonfigurasi dalam aplikasi.  Dalam Nucleus RTOS, jumlah mereka dapat berubah seiring waktu, dan nilai kembali akan menunjukkan jumlah antrian saat ini.  Dalam Nucleus SE, nilai kembali diatur selama fase build dan tidak dapat diubah. <br><br>  <b><i>Memanggil Penghitung Antrian di Nucleus RTOS</i></b> <br>  Prototipe panggilan layanan: <br>  <b>NU_Established_Queues (VOID) UNSIGNED;</b> <br><br>  Parameter: <br>  Tidak ada. <br><br>  Nilai pengembalian: <br>  Jumlah antrian yang dibuat dalam sistem. <br><br>  <b><i>Memanggil Penghitung Antrian di Nucleus SE</i></b> <br>  Panggilan API ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan layanan: <br>  <b>U8 NUSE_Queue_Count (batal);</b> <br><br>  Parameter: <br>  Tidak ada. <br><br>  Nilai pengembalian: <br>  Jumlah antrian yang dikonfigurasi dalam aplikasi. <br><br>  <b><i>Menerapkan Penghitung Antrian di Nucleus SE</i></b> <br>  Implementasi panggilan API ini sangat sederhana: nilai simbol <b>#define</b> <b>NUSE_QUEUE_NUMBER dikembalikan</b> . <br><br><h2>  Struktur data </h2><br>  Antrian menggunakan lima atau enam struktur data (baik dalam RAM atau ROM), yang merupakan kumpulan tabel (seperti objek Nucleus SE lainnya), jumlah dan ukurannya sesuai dengan jumlah antrian dalam aplikasi dan parameter yang dipilih. <br><br><h3>  Data kernel dalam RAM </h3><br>  Data ini memiliki struktur sebagai berikut: <br><br>  <b>NUSE_Queue_Head []</b> adalah array pointer dari tipe <b>U8</b> , memiliki satu entri untuk setiap antrian yang dikonfigurasi, dan menunjuk ke kepala antrian pesan.  Digunakan sebagai indeks alamat di <b>NUSE_Queue_Data []</b> (lihat di bawah); <br>  <b>NUSE_Queue_Tail []</b> adalah larik tipe <b>U8</b> , memiliki satu entri untuk setiap antrian yang dikonfigurasi dalam aplikasi, dan menunjuk ke ujung antrian pesan.  Digunakan sebagai indeks alamat di <b>NUSE_Queue_Data []</b> (lihat di bawah); <br>  <b>NUSE_Queue_Items []</b> adalah larik tipe <b>U8</b> , memiliki satu entri untuk setiap antrian yang dikonfigurasi, dan merupakan penghitung pesan dalam antrian.  Data ini dapat dianggap berlebihan, karena nilai-nilai ini dapat diperoleh melalui indeks awal dan akhir antrian, namun, menyimpan penghitung menyederhanakan kode; <br>  <b>NUSE_Queue_Blocking_Count []</b> - array tipe <b>U8 ini</b> berisi penghitung jumlah tugas yang ditangguhkan pada setiap antrian.  Array ini hanya dibuat jika dukungan kunci tugas diaktifkan. <br><br>  Struktur data ini diinisialisasi ke nol oleh fungsi <b>NUSE_Init_Queue ()</b> ketika Nucleus SE dimulai.  Ini logis, karena semua antrian dibuat kosong (tidak digunakan). <br><br>  Berikut ini adalah definisi dari struktur ini dalam file <b>nuse_init.c</b> : <br><br><pre> <code class="plaintext hljs">RAM U8 NUSE_Queue_Head[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Tail[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Items[NUSE_QUEUE_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Queue_Blocking_Count[NUSE_QUEUE_NUMBER]; #endif</code> </pre><br><h3>  Data pengguna RAM </h3><br>  Pengguna bertanggung jawab untuk menyediakan area RAM untuk menyimpan setiap antrian.  Ukuran area ini harus berisi larik jenis <b>ADDR</b> , di mana setiap catatan sesuai dengan satu pesan dalam antrian <br><br><h3>  Data ROM </h3><br>  Data ini memiliki struktur sebagai berikut: <br><br>  <b>NUSE_Queue_Data []</b> - larik jenis <b>ADDR</b> , memiliki satu entri untuk setiap antrian yang dikonfigurasi dan menunjuk ke area data antrian (lihat. Data RAM pengguna); <br>  <b>NUSE_Queue_Size []</b> - larik tipe <b>U8</b> , memiliki satu entri untuk setiap antrian yang dikonfigurasi dan menunjukkan jumlah maksimum pesan yang dapat diterima setiap antrian. <br><br>  Struktur data ini dideklarasikan dan diinisialisasi (secara statis) dalam file <b>nuse_config.c</b> : <br><br><pre> <code class="plaintext hljs">ROM ADDR *NUSE_Queue_Data[NUSE_QUEUE_NUMBER] = { /* addresses of queue data areas ------ */ }; ROM U8 NUSE_Queue_Size[NUSE_QUEUE_NUMBER] = { /* queue sizes ------ */ };</code> </pre><br><h3>  Jumlah memori untuk antrian </h3><br>  Seperti semua objek kernel Nucleus SE, jumlah memori yang dibutuhkan untuk antrian mudah diprediksi. <br><br>  Jumlah data dalam ROM (dalam byte) untuk semua antrian dalam aplikasi dapat dihitung sebagai berikut: <br>  <b>NUSE_QUEUE_NUMBER * (sizeof (ADDR) + 1)</b> <br><br>  Jumlah data kernel dalam RAM (dalam byte) untuk semua antrian dalam aplikasi dengan penguncian tugas yang diaktifkan dihitung sebagai berikut: <br>  <b>NUSE_QUEUE_NUMBER * 3</b> <br><br>  Jika kunci dinonaktifkan: <br>  <b>NUSE_QUEUE_NUMBER * 4</b> <br><br>  Jumlah data pengguna dalam RAM (dalam byte) untuk antrian dengan indeks <b>antrian</b> : <br>  <b>NUSE_Queue_Size [antrian] * sizeof (ADDR)</b> <br><br><h2>  Panggilan API yang belum direalisasi </h2><br>  Empat panggilan API yang dapat ditemukan di Nucleus RTOS tidak diterapkan di Nucleus SE: <br><br><h3>  Pembuatan antrian </h3><br>  Panggilan API ini membuat antrian; di Nucleus SE, ini tidak perlu, karena antrian dibuat secara statis. <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NU_Create_Queue (NU_QUEUE * antrian, char * nama, VOID * start_address, queue_size TANDA, OPTION message_type, message_size TANDA TANGAN, message_size TANDA TANGAN, OPTION suspend_type);</b> <br><br>  Parameter: <br><br>  <b>queue</b> - penunjuk ke unit kontrol yang disediakan oleh pengguna, digunakan untuk mengelola antrian dalam panggilan API lainnya; <br>  <b>name</b> - pointer ke nama antrian 7 karakter dengan byte terminasi nol; <br>  <b>start_address</b> - alamat awal antrian; <br>  <b>message_type</b> - jenis pesan yang didukung oleh antrian.  Itu dapat mengambil nilai <b>NU_FIXED_SIZE</b> atau <b>NU_VARIABLE_SIZE</b> ; <br>  <b>message_size</b> - jika antrian mendukung pesan dengan panjang tetap, parameter ini menetapkan panjang pasti setiap pesan, jika tidak, antrian mendukung pesan dengan panjang variabel, nilai ini adalah panjang pesan maksimum; <br>  <b>suspend_type</b> - Menentukan jenis tugas yang ditangguhkan dalam antrian.  Ini dapat mengambil nilai <b>NU_FIFO</b> dan <b>NU_PRIORITY</b> , yang berarti prinsip FIFO (First-In-First-Out) atau prinsip prioritas penangguhan tugas masing-masing. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_QUEUE</b> - null pointer ke blok kontrol antrian ( <b>NULL</b> ), atau pointer sudah digunakan; <br>  <b>NU_INVALID_MEMORY</b> - area memori tidak valid yang ditentukan dalam <b>start_address</b> ; <br>  <b>NU_INVALID_MESSAGE</b> - parameter <b>message_type</b> tidak valid; <br>  <b>NU_INVALID_SIZE</b> - antrian tidak mendukung pesan dengan panjang ini, atau ukuran antrian dan / atau panjang pesan adalah 0; <br>  <b>NU_INVALID_SUSPEND</b> - parameter <b>suspend_type</b> tidak valid. <br><br><h3>  Hapus antrian </h3><br>  Panggilan API ini menghapus antrian yang dibuat sebelumnya.  Nucleus SE tidak memerlukan ini karena antrian dibuat secara statis dan tidak dapat dihapus. <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NU_Delete_Queue (NU_QUEUE * antrian);</b> <br><br>  Parameter: <br>  <b>queue</b> - pointer ke blok kontrol antrian. <br><br>  Nilai pengembalian: <br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_QUEUE</b> - penunjuk antrian tidak valid. <br><br><h3>  Pointer Antrian </h3><br>  Panggilan API ini membuat daftar pointer berurutan untuk semua antrian dalam sistem.  Nucleus SE tidak memerlukan ini karena antrian diidentifikasi menggunakan indeks sederhana, bukan pointer. <br><br>  Prototipe panggilan layanan: <br>  <b>NU_Queue_Pointers TIDAK DITANDATANGANI (NU_QUEUE ** pointer_list, maksimum_pointers UNSIGNED);</b> <br><br>  Parameter: <br>  <b>pointer_list</b> - pointer ke array pointer <b>NU_QUEUE</b> .  Array ini akan diisi dengan pointer ke antrian yang dibuat dalam sistem; <br>  <b>maximum_pointers</b> - jumlah maksimum pointer dalam array. <br><br>  Nilai pengembalian: <br>  Jumlah <b>NU_QUEUE</b> pointer dalam array. <br><br><h3>  Antrian (Siaran ke Antrian) </h3><br>  Panggilan API ini meneruskan pesan ke semua tugas yang ditangguhkan dalam antrian yang sedang menunggu pesan dari antrian yang ditentukan.  Fitur ini tidak diterapkan di Nucleus SE karena menambah redundansi. <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NU_Broadcast_To_Queue (NU_QUEUE * antrian, pesan VOID *, ukuran UNSIGNED, suspend UNSIGNED);</b> <br><br>  Parameter: <br><br>  <b>queue</b> - pointer ke blok kontrol antrian; <br>  <b>message</b> - penunjuk ke pesan yang dikirimkan; <br>  <b>size</b> - jumlah elemen <b>TANDA TANGAN</b> dalam pesan.  Jika antrian mendukung pesan panjang variabel, parameter ini harus sama dengan atau kurang dari panjang pesan yang didukung oleh antrian.  Jika antrian mendukung pesan dengan panjang tetap, parameter ini harus sama dengan panjang pesan yang didukung oleh antrian; <br>  <b>suspen</b> - menunjukkan apakah akan menunda tugas panggilan jika antrian sudah penuh.  Ini bisa berupa <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND,</b> atau nilai batas waktu. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_QUEUE</b> - penunjuk antrian tidak valid; <br>  <b>NU_INVALID_POINTER</b> - null pointer ke pesan ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - panjang pesan yang ditentukan tidak kompatibel dengan panjang yang ditentukan saat membuat antrian; <br>  <b>NU_INVALID_SUSPEND</b> - berupaya menjeda tugas dari utas yang tidak terkait dengan tugas; <br>  <b>NU_QUEUE_FULL</b> - tidak ada cukup ruang dalam antrian untuk pesan; <br>  <b>NU_TIMEOUT</b> - antrian masih penuh setelah batas waktu berakhir; <br>  <b>NU_QUEUE_DELETED</b> - antrian dihapus saat tugas ditangguhkan; <br>  <b>NU_QUEUE_RESET</b> - Antrian diatur ulang saat tugas ditangguhkan. <br><br><h2>  Kompatibel dengan RTOS Inti </h2><br>  Seperti semua objek Nucleus SE lainnya, tujuan saya adalah untuk memaksimalkan kompatibilitas kode aplikasi dengan Nucleus RTOS.  Antrian tidak terkecuali dan, dari sudut pandang pengguna, mereka diimplementasikan dengan cara yang sama seperti pada Nucleus RTOS.  Ada juga ketidakcocokan tertentu, yang saya anggap dapat diterima, mengingat bahwa sebagai hasilnya, kode tersebut akan menjadi lebih mudah dimengerti dan lebih efisien dalam hal jumlah memori yang diperlukan.  Jika tidak, panggilan Nucleus RTOS API dapat diangkut hampir secara langsung ke Nucleus SE. <br><br><h3>  Pengidentifikasi Objek </h3><br>  Dalam Nucleus RTOS, semua objek dijelaskan oleh struktur data (unit kontrol) yang memiliki tipe data tertentu.  Penunjuk ke unit kontrol ini adalah pengidentifikasi antrian.  Saya memutuskan bahwa dalam Nucleus SE, diperlukan pendekatan yang berbeda untuk penggunaan memori yang efisien: semua objek kernel dijelaskan oleh seperangkat tabel dalam RAM dan / atau ROM.  Ukuran tabel ini ditentukan oleh jumlah objek yang dikonfigurasi dari setiap jenis.  Pengidentifikasi objek tertentu adalah indeks dalam tabel ini.  Jadi saya mendefinisikan <b>NUSE_QUEUE</b> sebagai setara dengan <b>U8</b> , variabel (bukan pointer) dari tipe ini berfungsi sebagai pengidentifikasi antrian.  Ketidakcocokan sedikit ini mudah ditangani jika kode porting dari Nucleus SE ke Nucleus RTOS dan sebaliknya.  Biasanya, tidak ada operasi yang dilakukan pada pengidentifikasi objek selain memindahkan dan menyimpan. <br><br>  Nucleus RTOS juga mendukung penamaan antrian.  Nama-nama ini hanya digunakan untuk debugging.  Saya mengecualikan mereka dari Nucleus SE untuk menghemat memori. <br><br><h3>  Ukuran dan jenis pesan </h3><br>  Dalam Nucleus RTOS, antrian dapat dikonfigurasi untuk memproses pesan yang terdiri dari sejumlah elemen yang <b>tidak ditandatangani</b> .  Dalam Nucleus SE, Antrian disederhanakan dan hanya mendukung pesan jenis <b>ADDR</b> tunggal.  Saluran data Nucleus SE sedikit lebih fleksibel dan dapat menjadi alternatif yang berguna untuk antrian dalam beberapa kasus.  Saluran akan dibahas dalam dua artikel berikutnya dari seri ini. <br><br>  Nucleus SE juga mendukung antrian pesan panjang variabel, yang hanya menentukan panjang pesan maksimum selama pembuatan.  Panjang pesan variabel tidak didukung oleh Nucleus SE <br><br><h3>  Ukuran Antrian </h3><br>  Dalam Nucleus SE, jumlah maksimum pesan dalam antrian adalah 256, karena semua variabel dan konstanta bertipe <b>U8</b> .  Nucleus RTOS tidak memiliki batasan seperti itu. <br><br><h3>  Panggilan API yang belum direalisasi </h3><br>  Nucleus RTOS mendukung sepuluh panggilan manajemen antrian.  Dari jumlah tersebut, empat tidak diimplementasikan dalam Nucleus SE.  Detail panggilan ini, serta alasan keputusan semacam itu, dapat ditemukan di artikel di atas, di bagian "Panggilan API yang Tidak Direalisasi". <br><br>  Artikel selanjutnya akan membahas saluran transmisi data. <br><br>  <b>Tentang Pengarang:</b> Colin Walls telah bekerja di industri elektronik selama lebih dari tiga puluh tahun, mencurahkan sebagian besar waktunya untuk firmware.  Dia sekarang adalah seorang insinyur firmware di Mentor Embedded (sebuah divisi dari Mentor Graphics).  Colin Walls sering berbicara di konferensi dan seminar, penulis berbagai artikel teknis dan dua buku tentang firmware.  Tinggal di Inggris.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Colin</a> , email: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432804/">https://habr.com/ru/post/id432804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432794/index.html">Bret Victor: Beberapa kata tentang Douglas Engelbart</a></li>
<li><a href="../id432796/index.html">Modul Hitung, Model 2019</a></li>
<li><a href="../id432798/index.html">OS Keamanan Terbaik: Perbandingan Titan</a></li>
<li><a href="../id432800/index.html">Investigasi Insiden Keamanan dengan StaffCop Enterprise 4.4</a></li>
<li><a href="../id432802/index.html">Enam platform pembelajaran pemrograman otomatis gratis</a></li>
<li><a href="../id432806/index.html">Superintelligence: sebuah ide yang menghantui orang pintar</a></li>
<li><a href="../id432808/index.html">Gaji di AI: di mana ada lebih banyak uang dan siapa yang mereka cari di Rusia</a></li>
<li><a href="../id432810/index.html">Denda pertama untuk GDPR: siapa yang sudah dihukum</a></li>
<li><a href="../id432812/index.html">Kami menulis robot perdagangan menggunakan kerangka kerja grafis StockSharp. Bagian 1</a></li>
<li><a href="../id432814/index.html">Integrasi Cake dan TeamCity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>