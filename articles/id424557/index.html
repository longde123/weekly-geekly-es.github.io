<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕹️ 🏘️ 😉 Panduan Node.js, Bagian 8: Protokol HTTP dan WebSocket 👨‍🎨 👨‍✈️ ✴️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Node.js adalah platform server. Tugas utama server adalah untuk memproses permintaan dari klien, khususnya, dari browser, secepat dan seefisien mungki...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan Node.js, Bagian 8: Protokol HTTP dan WebSocket</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424557/">  Node.js adalah platform server.  Tugas utama server adalah untuk memproses permintaan dari klien, khususnya, dari browser, secepat dan seefisien mungkin.  Terjemahan kedelapan dari tutorial Node.js yang kami terbitkan hari ini adalah tentang HTTP dan WebSocket. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Kami menyarankan Anda untuk membaca] Bagian lain dari siklus ini</b> <div class="spoiler_text">  Bagian 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Informasi Umum dan Memulai</a> <br>  Bagian 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaScript, V8, beberapa trik pengembangan</a> <br>  Bagian 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hosting, REPL, bekerja dengan konsol, modul</a> <br>  Bagian 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npm, package.json dan file package-lock.json</a> <br>  Bagian 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npm dan npx</a> <br>  Bagian 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">loop acara, tumpukan panggilan, timer</a> <br>  Bagian 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrograman Asinkron</a> <br>  Bagian 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Node.js, Bagian 8: HTTP dan Protokol WebSocket</a> <br>  Bagian 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Node.js, bagian 9: bekerja dengan sistem file</a> <br>  Bagian 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Node.js, Bagian 10: Modul Standar, Streaming, Database, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDF lengkap dari Node.js Guide</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Apa yang terjadi ketika membuat permintaan HTTP?</font> </h2><br>  Mari kita bicara tentang bagaimana browser membuat permintaan ke server menggunakan protokol HTTP / 1.1. <br><br>  Jika Anda pernah memiliki wawancara di bidang TI, maka Anda mungkin akan ditanya apa yang terjadi ketika Anda mengetik sesuatu di bilah alamat browser Anda dan tekan Enter.  Mungkin ini adalah salah satu pertanyaan paling populer yang terjadi pada wawancara semacam itu.  Siapa pun yang mengajukan pertanyaan seperti itu ingin tahu apakah Anda dapat menjelaskan beberapa konsep yang cukup sederhana dan mencari tahu apakah Anda memahami prinsip-prinsip Internet. <br><br>  Pertanyaan ini menyentuh banyak teknologi, untuk memahami prinsip-prinsip umum yang berarti memahami bagaimana salah satu sistem paling rumit yang pernah dibangun oleh umat manusia dibangun, yang mencakup seluruh dunia. <br><br><h3>  <font color="#3AC1EF">▍ Protokol HTTP</font> </h3><br>  Browser modern dapat membedakan URL asli yang dimasukkan ke dalam bilah alamat mereka dari permintaan pencarian, untuk pemrosesan yang biasanya digunakan oleh mesin pencari standar.  Kami akan berbicara tentang URL.  Jika Anda memasukkan alamat situs web, seperti <code>flaviocopes.com</code> , ke dalam baris peramban, peramban mengonversi alamat ini ke formulir <code>http://flaviocopes.com</code> , berdasarkan asumsi bahwa protokol HTTP akan digunakan untuk bertukar data dengan sumber daya yang ditentukan.  Harap dicatat bahwa pada Windows, apa yang akan kita bicarakan di sini mungkin terlihat sedikit berbeda dari pada macOS dan Linux. <br><br><h3>  <font color="#3AC1EF">▍ Fase pencarian DNS</font> </h3><br>  Jadi, browser, mulai bekerja mengunduh data dari alamat yang diminta oleh pengguna, melakukan operasi Pencarian DNS (Pencarian DNS) untuk mengetahui alamat IP dari server terkait.  Nama simbolis dari sumber daya yang dimasukkan di bilah alamat nyaman untuk orang, tetapi perangkat Internet menyiratkan kemungkinan pertukaran data antara komputer menggunakan alamat IP, yang merupakan kumpulan angka seperti 222.324.3.1 (untuk IPv4). <br><br>  Pertama, mencari tahu alamat IP server, browser melihat ke cache DNS lokal untuk melihat apakah prosedur serupa telah dilakukan baru-baru ini.  Di browser Chrome, misalnya, ada cara mudah untuk melihat cache DNS dengan memasukkan alamat berikut di bilah alamat: <code>chrome://net-internals/#dns</code> . <br><br>  Jika tidak ada yang dapat ditemukan di cache, browser menggunakan panggilan sistem <code>gethostbyname</code> POSIX untuk mengetahui alamat IP server. <br><br><h3>  <font color="#3AC1EF">▍ fungsi gethostbyname</font> </h3><br>  Fungsi <code>gethostbyname</code> pertama-tama memeriksa <code>hosts</code> , yang, pada macOS atau Linux, dapat ditemukan di <code>/etc/hosts</code> untuk mencari tahu apakah informasi lokal dapat ditemukan dengan mencari tahu alamat server. <br><br>  Jika lokal berarti menyelesaikan permintaan untuk mengetahui alamat IP server gagal, sistem melakukan permintaan ke server DNS.  Alamat server tersebut disimpan dalam pengaturan sistem. <br><br>  Berikut adalah beberapa server DNS populer: <br><br><ul><li>  8.8.8.8: Server Google DNS. </li><li>  1.1.1.1: Server CloudFlare DNS. </li></ul><br>  Kebanyakan orang menggunakan server DNS yang disediakan oleh penyedia mereka.  Browser melakukan permintaan DNS menggunakan protokol UDP. <br><br>  TCP dan UDP adalah dua protokol dasar yang digunakan dalam jaringan komputer.  Mereka berada pada level konseptual yang sama, tetapi TCP adalah protokol berorientasi koneksi, dan untuk pertukaran pesan UDP, pemrosesan yang menciptakan beban tambahan kecil pada sistem, prosedur pembentukan koneksi tidak diperlukan.  Kami tidak akan berbicara tentang bagaimana pertukaran data dengan UDP. <br><br>  Alamat IP yang sesuai dengan nama domain yang menarik bagi kami mungkin ada dalam cache server DNS.  Jika ini bukan masalahnya, ia akan menghubungi server DNS root.  Sistem DNS root server terdiri dari 13 server, di mana pengoperasian seluruh Internet tergantung. <br><br>  Perlu dicatat bahwa root DNS server tidak mengetahui korespondensi antara semua nama domain dan alamat IP yang ada di dunia.  Tetapi server yang sama mengetahui alamat server DNS tingkat atas untuk domain seperti .com, .it, .pizza, dan sebagainya. <br><br>  Setelah menerima permintaan, root DNS server mengarahkan ulang ke server DNS dari domain tingkat atas, ke server TLD (dari Top-Level Domain). <br><br>  Misalkan browser sedang mencari alamat IP untuk server <code>flaviocopes.com</code> .  Beralih ke root DNS server, browser akan menerima alamat server TLD untuk zona .com darinya.  Sekarang alamat ini akan disimpan dalam cache, sebagai hasilnya, jika Anda perlu mengetahui alamat IP dari URL lain dari zona .com, Anda tidak perlu menghubungi server DNS root lagi. <br><br>  Server TLD memiliki alamat IP server nama (Name Server, NS), dengan bantuan yang Anda dapat mengetahui alamat IP dari URL yang kami miliki.  Di mana server NS mendapatkan informasi ini?  Faktanya adalah bahwa jika Anda membeli domain, pendaftar domain mengirimkan data tentangnya ke server nama.  Prosedur serupa dilakukan, misalnya, ketika mengubah hosting. <br><br>  Server yang dimaksud biasanya dimiliki oleh penyedia hosting.  Sebagai aturan, untuk melindungi dari kegagalan, beberapa server dibuat.  Misalnya, mereka mungkin memiliki alamat ini: <br><br><ul><li>  ns1.dreamhost.com </li><li>  ns2.dreamhost.com </li><li>  ns3.dreamhost.com </li></ul><br>  Untuk mengetahui alamat IP dengan URL, pada akhirnya, mereka beralih ke server tersebut.  Mereka menyimpan data aktual tentang alamat IP. <br><br>  Sekarang, setelah kami berhasil menemukan alamat IP di belakang URL yang dimasukkan di bilah alamat browser, kami beralih ke langkah selanjutnya dari pekerjaan kami. <br><br><h3>  <font color="#3AC1EF">▍ Membuat koneksi TCP</font> </h3><br>  Setelah mempelajari alamat IP server, klien dapat memulai koneksi TCP ke sana.  Dalam proses membangun koneksi TCP, klien dan server mengirimkan satu sama lain beberapa data layanan, setelah itu mereka dapat bertukar informasi.  Ini berarti bahwa setelah koneksi dibuat, klien akan dapat mengirim permintaan ke server. <br><br><h3>  <font color="#3AC1EF">▍Mengirim permintaan</font> </h3><br>  Permintaan adalah fragmen teks yang disusun sesuai dengan aturan protokol yang digunakan.  Ini terdiri dari tiga bagian: <br><br><ul><li>  String kueri </li><li>  Minta tajuk. </li><li>  Meminta badan. </li></ul><br><h4>  String kueri </h4><br>  String kueri adalah string teks tunggal yang berisi informasi berikut: <br><br><ul><li>  Metode HTTP. </li><li>  Alamat Sumber Daya </li><li>  Versi protokol. </li></ul><br>  Mungkin terlihat, misalnya, seperti ini: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> / HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span></code> </pre> <br><h4>  Minta tajuk </h4><br>  Header permintaan diwakili oleh seperangkat <code>: </code> .  Ada 2 bidang header yang diperlukan, salah satunya adalah <code>Host</code> dan yang kedua adalah <code>Connection</code> .  Kolom yang tersisa adalah opsional. <br><br>  Judulnya mungkin terlihat seperti ini: <br><br><pre> <code class="hljs pgsql">Host: flaviocopes.com <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">close</span></span></code> </pre> <br>  Bidang <code>Host</code> menunjukkan nama domain yang diminati browser.  Bidang <code>Connection</code> , diatur ke <code>close</code> , berarti koneksi antara klien dan server tidak perlu tetap terbuka. <br><br>  Header permintaan yang umum digunakan meliputi: <br><br><ul><li> <code>Origin</code> </li> <li> <code>Accept</code> </li> <li> <code>Accept-Encoding</code> </li> <li> <code>Cookie</code> </li> <li> <code>Cache-Control</code> </li> <li> <code>Dnt</code> </li> </ul><br>  Padahal, masih banyak lagi. <br><br>  Header permintaan berakhir dengan string kosong. <br><br><h4>  Meminta badan </h4><br>  Badan permintaan bersifat opsional, tidak digunakan dalam permintaan GET.  Badan permintaan digunakan dalam permintaan POST, serta dalam permintaan lainnya.  Ini mungkin berisi, misalnya, data dalam format JSON. <br><br>  Karena sekarang kita berbicara tentang permintaan GET, badan permintaan akan kosong, kami tidak akan bekerja dengannya. <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Setelah server menerima permintaan yang dikirim oleh klien, ia memprosesnya dan mengirimkan respons kepada klien. <br><br>  Respons dimulai dengan kode status dan pesan yang sesuai.  Jika permintaan berhasil, awal respons akan terlihat seperti ini: <br><br><pre> <code class="hljs">200 OK</code> </pre> <br>  Jika ada kesalahan, mungkin ada kode lain.  Misalnya, berikut ini: <br><br><ul><li> <code>404 Not Found</code> </li> <li> <code>403 Forbidden</code> </li> <li> <code>301 Moved Permanently</code> </li> <li> <code>500 Internal Server Error</code> </li> <li> <code>304 Not Modified</code> </li> <li> <code>401 Unauthorized</code> </li> </ul><br>  Selanjutnya, respons berisi daftar tajuk HTTP dan isi respons (yang, karena permintaan dieksekusi oleh browser, akan berupa kode HTML). <br><br><h4>  Penguraian HTML </h4><br>  Setelah browser menerima respons dari server, yang bodinya berisi kode HTML, ia mulai menguraikannya, mengulangi proses di atas untuk setiap sumber daya yang diperlukan untuk membentuk halaman.  Sumber daya tersebut meliputi, misalnya, yang berikut: <br><br><ul><li>  File CSS. </li><li>  Gambar </li><li>  Ikon halaman web (favicon). </li><li>  File JavaScript. </li></ul><br>  Bagaimana tepatnya browser menampilkan halaman tidak berlaku untuk percakapan kami.  Hal utama yang menarik bagi kami di sini adalah bahwa proses meminta dan menerima data di atas digunakan tidak hanya untuk kode HTML, tetapi juga untuk objek lain yang ditransfer dari server ke browser menggunakan protokol HTTP. <br><br><h2>  <font color="#3AC1EF">Tentang membuat server sederhana menggunakan Node.js</font> </h2><br>  Sekarang, setelah kami memeriksa proses interaksi antara browser dan server, Anda dapat melihat segar di bagian aplikasi First Node.js dari bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama dari</a> rangkaian materi ini, di mana kami menggambarkan kode untuk server sederhana. <br><br><h2>  <font color="#3AC1EF">Membuat permintaan HTTP dengan Node.js</font> </h2><br>  Untuk melakukan permintaan HTTP menggunakan Node.js, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://nodejs.org/api/">modul yang</a> sesuai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://nodejs.org/api/">digunakan</a> .  Contoh di bawah ini menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://nodejs.org/api/">https</a> .  Faktanya adalah bahwa dalam kondisi modern, bila memungkinkan, perlu untuk menggunakan protokol HTTPS. <br><br><h3>  <font color="#3AC1EF">▍ Mengeksekusi permintaan GET</font> </h3><br>  Berikut adalah contoh menjalankan permintaan GET menggunakan Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span> } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">▍POST eksekusi permintaan</font> </h3><br>  Berikut cara membuat permintaan POST dari Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const data = JSON.stringify({ todo: <span class="hljs-string"><span class="hljs-string">'Buy the milk'</span></span> }) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, headers: {   <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>,   <span class="hljs-string"><span class="hljs-string">'Content-Length'</span></span>: data.length } } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.write(data) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">▍PUT dan HAPUS pertanyaan</font> </h3><br>  Eksekusi permintaan seperti itu terlihat sama dengan eksekusi permintaan POST.  Perbedaan utama, selain konten semantik dari operasi tersebut, adalah nilai properti <code>method</code> dari objek <code>options</code> . <br><br><h3>  <font color="#3AC1EF">▍ Melakukan permintaan HTTP di Node.js menggunakan perpustakaan Axios</font> </h3><br>  Axios adalah pustaka JavaScript yang sangat populer yang berfungsi baik di browser (ini mencakup semua browser modern dan IE, dimulai dengan IE8), dan di lingkungan Node.js, yang dapat digunakan untuk melakukan permintaan HTTP. <br><br>  Perpustakaan ini didasarkan pada janji-janji, ia memiliki beberapa keunggulan dibandingkan mekanisme standar, khususnya, lebih dari API Fetch.  Di antara kelebihannya adalah sebagai berikut: <br><br><ul><li>  Dukungan untuk browser lama (Anda perlu polyfill untuk menggunakan Ambil). </li><li>  Kemampuan untuk menginterupsi permintaan. </li><li>  Dukungan untuk mengatur batas waktu permintaan. </li><li>  Perlindungan bawaan terhadap serangan CSRF. </li><li>  Dukungan untuk mengunggah data dengan ketentuan informasi tentang kemajuan proses ini. </li><li>  Dukungan untuk konversi data JSON. </li><li>  Pekerjaan di Node.js </li></ul><br><h4>  Instalasi </h4><br>  Anda dapat menggunakan npm untuk menginstal Axios: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> axios</code> </pre> <br>  Efek yang sama dapat dicapai dengan benang: <br><br><pre> <code class="hljs cs">yarn <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> axios</code> </pre> <br>  Anda dapat menghubungkan perpustakaan ke halaman menggunakan <code>unpkg.com</code> : <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h4>  API Axios </h4><br>  Anda dapat membuat permintaan HTTP menggunakan objek <code>axios</code> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">axios</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">url</span></span>: <span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'get'</span></span>, data: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br>  Tetapi biasanya lebih nyaman menggunakan metode khusus: <br><br><ul><li> <code>axios.get()</code> </li> <li> <code>axios.post()</code> </li> </ul><br>  Ini mirip dengan bagaimana jQuery menggunakan <code>$.get()</code> dan <code>$.post()</code> alih-alih <code>$.ajax()</code> <code>$.post()</code> . <br><br>  Axios menawarkan metode terpisah untuk mengeksekusi jenis permintaan HTTP lain, yang tidak sepopuler GET dan POST, tetapi masih digunakan: <br><br><ul><li> <code>axios.delete()</code> </li> <li> <code>axios.put()</code> </li> <li> <code>axios.patch()</code> </li> <li> <code>axios.options()</code> </li> </ul><br>  Perpustakaan memiliki metode untuk mengeksekusi permintaan yang dirancang untuk hanya menerima tajuk HTTP, tanpa badan respons: <br><br><ul><li> <code>axios.head()</code> </li> </ul><br><h4>  DAPATKAN permintaan </h4><br>  Axios nyaman digunakan menggunakan sintaksis async / await modern.  Contoh kode berikut, yang dirancang untuk Node.js, menggunakan perpustakaan untuk memuat daftar trah anjing dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dog API</a> .  Di sini metode <code>axios.get()</code> diterapkan dan batuan dihitung: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getBreeds() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (breeds.data.message) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(breeds.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>) } } countBreeds()</code> </pre> <br>  Hal yang sama dapat ditulis ulang tanpa menggunakan async / menunggu, menerapkan janji: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = getBreeds()   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.data.message) {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(         <span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(response.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>       )     }   })   .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)   }) } countBreeds()</code> </pre> <br><h4>  Menggunakan parameter dalam permintaan GET </h4><br>  Permintaan GET dapat berisi parameter yang terlihat seperti ini di URL: <br><br><pre> <code class="hljs objectivec">https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar</span></span></code> </pre> <br>  Saat menggunakan Axios, permintaan semacam ini dapat dilakukan seperti ini: <br><br><pre> <code class="hljs swift">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>('https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar')</span></span></code> </pre> <br>  Efek yang sama dapat dicapai dengan mengatur properti <code>params</code> di objek dengan parameter: <br><br><pre> <code class="hljs cs">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br><h4>  Permintaan POST </h4><br>  Mengeksekusi permintaan POST sangat mirip dengan mengeksekusi permintaan GET, tetapi di sini, alih-alih metode <code>axios.get()</code> , metode <code>axios.post()</code> digunakan: <br><br><pre> <code class="hljs scala">axios.post(<span class="hljs-symbol"><span class="hljs-symbol">'https</span></span>:<span class="hljs-comment"><span class="hljs-comment">//site.com/')</span></span></code> </pre> <br>  Sebagai argumen kedua, metode <code>post</code> menerima objek dengan parameter permintaan: <br><br><pre> <code class="hljs cs">axios.post(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> })</code> </pre> <br><h2>  <font color="#3AC1EF">Menggunakan Protokol WebSocket di Node.js</font> </h2><br>  WebSocket adalah alternatif untuk HTTP, dapat digunakan untuk mengatur pertukaran data dalam aplikasi web.  Protokol ini memungkinkan Anda untuk membuat saluran komunikasi dua arah yang berumur panjang antara klien dan server.  Setelah koneksi dibuat, saluran komunikasi tetap terbuka, yang menempatkan aplikasi pada pembuangan koneksi yang sangat cepat, ditandai dengan latensi rendah dan beban tambahan kecil pada sistem. <br><br>  Protokol WebSocket didukung oleh semua browser modern. <br><br><h3>  <font color="#3AC1EF">▍ Perbedaan HTTP</font> </h3><br>  HTTP dan WebSocket adalah protokol yang sangat berbeda yang menggunakan pendekatan berbeda untuk bertukar data.  HTTP didasarkan pada model "permintaan-respons": server mengirim beberapa data ke klien setelah diminta.  Dalam kasus WebSocket, semuanya diatur secara berbeda.  Yaitu: <br><br><ul><li>  Server dapat mengirim pesan ke klien atas inisiatifnya sendiri, tanpa menunggu permintaan dari klien. </li><li>  Klien dan server dapat bertukar data secara bersamaan. </li><li>  Saat mengirimkan pesan, sejumlah kecil data layanan digunakan.  Ini, khususnya, menyebabkan latensi rendah dalam pengiriman data. </li></ul><br>  Protokol WebSocket sangat cocok untuk komunikasi real-time melalui saluran yang tetap terbuka untuk waktu yang lama.  HTTP, pada gilirannya, sangat baik untuk mengatur sesi komunikasi sesekali yang diprakarsai oleh klien.  Pada saat yang sama, harus dicatat bahwa, dari sudut pandang pemrograman, jauh lebih mudah untuk mengimplementasikan pertukaran data menggunakan protokol HTTP daripada menggunakan protokol WebSocket. <br><br><h3>  <font color="#3AC1EF">▍ Versi protokol WebSocket yang dilindungi</font> </h3><br>  Ada versi yang tidak aman dari protokol WebSocket ( <code>ws://</code> skema URI), yang menyerupai, dalam hal keamanan, protokol <code>http://</code> .  Penggunaan <code>ws://</code> harus dihindari, lebih memilih versi protokol yang aman - <code>wss://</code> . <br><br><h3>  <font color="#3AC1EF">▍Membuat Koneksi WebSocket</font> </h3><br>  Untuk membuat koneksi WebSocket, Anda perlu menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konstruktor yang</a> sesuai: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'wss://myserver.com/something'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(url)</code> </pre> <br>  Setelah koneksi berhasil dibuat, acara <code>open</code> dinaikkan.  Anda dapat mengatur acara ini dengan menetapkan fungsi panggilan balik ke properti <code>onopen</code> dari objek <code>connection</code> : <br><br><pre> <code class="hljs javascript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Untuk menangani kesalahan, pengendali event <code>onerror</code> digunakan: <br><br><pre> <code class="hljs javascript">connection.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`WebSocket error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error}</span></span></span><span class="hljs-string">`</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">▍Mengirim data ke server</font> </h3><br>  Setelah membuka koneksi WebSocket ke server, Anda dapat mengirim data ke sana.  Ini dapat dilakukan, misalnya, dalam <code>onopen</code> : <br><br><pre> <code class="hljs coffeescript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { connection.send(<span class="hljs-string"><span class="hljs-string">'hey'</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">▍Mendapatkan data dari server</font> </h3><br>  Untuk menerima data yang dikirim menggunakan protokol WebSocket dari server, Anda dapat menetapkan <code>onmessage</code> onmessage, yang akan dipanggil ketika acara <code>message</code> diterima: <br><br><pre> <code class="hljs javascript">connection.onmessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e.data) }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Implementasi server WebSocket di lingkungan Node.js</font> </h3><br>  Untuk menerapkan server WebSocket di lingkungan Node.js, Anda dapat menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ws yang</a> populer.  Kami akan menggunakannya untuk pengembangan server, tetapi cocok untuk membuat klien, serta untuk mengatur interaksi antara dua server. <br><br>  Instal pustaka ini dengan pertama-tama menginisialisasi proyek: <br><br><pre> <code class="hljs swift">yarn <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> yarn add ws</code> </pre> <br>  Kode untuk server WebSocket yang perlu kita tulis cukup ringkas: <br><br><pre> <code class="hljs javascript">constWebSocket = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wss = newWebSocket.Server({ <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8080</span></span> }) wss.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, ws =&gt; { ws.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, message =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received message =&gt; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message}</span></span></span><span class="hljs-string">`</span></span>) }) ws.send(<span class="hljs-string"><span class="hljs-string">'ho!'</span></span>) })</code> </pre> <br>  Di sini kita membuat server baru yang mendengarkan pada port standar 8080 untuk protokol WebSocket dan menjelaskan panggilan balik, yang, ketika koneksi dibuat, mengirim pesan ke klien <code>ho!</code>  dan mencetak ke konsol pesan yang diterima dari klien. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah</a> contoh kerja server WebSocket, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berikut</a> adalah klien yang dapat berinteraksi dengannya. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Hari ini kita berbicara tentang mekanisme jaringan yang didukung oleh platform Node.js, menggambar paralel dengan mekanisme serupa yang digunakan di browser.  Topik kita berikutnya adalah menangani file. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan protokol WebSocket di aplikasi web Anda, sisi server yang dibuat menggunakan Node.js? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424557/">https://habr.com/ru/post/id424557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424541/index.html">Kisah kegagalan UGJ 2018: cara membuat game yang tidak disukai siapa pun (jangan lakukan itu!)</a></li>
<li><a href="../id424543/index.html">Java 11 / JDK 11: Ketersediaan Umum</a></li>
<li><a href="../id424551/index.html">Hangat dan tabung: lima balalaika tentang teknologi audio magnetik</a></li>
<li><a href="../id424553/index.html">Panduan Node.js, Bagian 6: Loop Peristiwa, Stack Panggilan, Pengatur Waktu</a></li>
<li><a href="../id424555/index.html">Manual Node.js, Bagian 7: Pemrograman Asinkron</a></li>
<li><a href="../id424559/index.html">Big Data resistance 1 atau Joe yang sulit dipahami. Anonimitas internet, anti-deteksi, anti-pelacakan untuk anti-Anda dan anti-us</a></li>
<li><a href="../id424563/index.html">Langsung menuju detail percakapan ke orang asing</a></li>
<li><a href="../id424565/index.html">Tinjauan umum: Pemindaian 3D dari bangunan real estat</a></li>
<li><a href="../id424567/index.html">Pengalaman memblokir iklan online di jaringan lokal perusahaan</a></li>
<li><a href="../id424569/index.html">Mempekerjakan programmer. Kiat Pemrogram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>