<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßúüèø üçÅ ü§• Meilleures pratiques pour les conteneurs Kubernetes: bilans de sant√© üöí ‚òùüèæ ü§∑üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 


- Pour atteindre une observabilit√© √©lev√©e des conteneurs et des microservices, les magazines et les mesures primaires ne suffisent pas. 
- P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meilleures pratiques pour les conteneurs Kubernetes: bilans de sant√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/467155/"><p><img src="https://habrastorage.org/webt/et/w4/sa/etw4sacz-ttuiwcyyvxx1utukq4.jpeg"></p><br><p>  <strong>TL; DR</strong> </p><br><ul><li>  Pour atteindre une observabilit√© √©lev√©e des conteneurs et des microservices, les magazines et les mesures primaires ne suffisent pas. </li><li>  Pour une r√©cup√©ration plus rapide et une meilleure tol√©rance aux pannes, les applications doivent appliquer le principe de haute observabilit√© (HOP). </li><li>  Au niveau de l'application, la NRA requiert: une journalisation appropri√©e, une surveillance attentive, des contr√¥les d'int√©grit√© et un suivi des performances / transition. </li><li>  Utilisez les contr√¥les <em>readinessProbe</em> et <em>livenessProbe</em> Kubernetes <em>comme</em> √©l√©ment <em>HOP</em> . <a name="habracut"></a></li></ul><br><h3 id="chto-takoe-shablon-proverki-rabotosposobnosti">  Qu'est-ce qu'un mod√®le de bilan de sant√©? </h3><br><p>  Lors de la conception d'une application critique et hautement disponible, il est tr√®s important de penser √† une chose telle que la tol√©rance aux pannes.  Une application est consid√©r√©e comme tol√©rante aux pannes si elle est rapidement restaur√©e apr√®s une d√©faillance.  Une application cloud typique utilise une architecture de microservices - lorsque chaque composant est plac√© dans un conteneur s√©par√©.  Et pour vous assurer que l'application sur k8s est hautement accessible, lorsque vous concevez un cluster, vous devez suivre certains mod√®les.  Parmi eux se trouve le mod√®le de bilan de sant√©.  Il d√©termine la mani√®re dont l'application signale les performances des k8.  Il ne s'agit pas seulement d'informations sur le fonctionnement du pod, mais √©galement sur la fa√ßon dont il accepte les demandes et y r√©pond.  Plus Kubernetes en sait sur les performances d'un pod, plus il prend de d√©cisions intelligentes concernant le routage du trafic et l'√©quilibrage de charge.  Ainsi, le principe de haute observabilit√© de l'application en temps opportun pour r√©pondre aux demandes de renseignements. </p><br><h3 id="princip-vysokoy-nablyudaemosti-nor">  Le principe de la haute observabilit√© (NRA) </h3><br><p> Le principe de haute observabilit√© est l'un des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">principes de conception des applications conteneuris√©es</a> .  Dans l'architecture de microservices, les services ne se soucient pas de la fa√ßon dont leur demande est trait√©e (et √† juste titre), mais il est important de savoir comment obtenir des r√©ponses des services re√ßus.  Par exemple, pour authentifier un utilisateur, un conteneur envoie une autre requ√™te HTTP, en attendant une r√©ponse dans un format sp√©cifique - c'est tout.  PythonJS peut √©galement g√©rer la demande et Python Flask peut r√©pondre.  Les conteneurs les uns pour les autres sont comme des bo√Ætes noires avec du contenu cach√©.  Cependant, le principe de la NRA exige que chaque service divulgue plusieurs points de terminaison API montrant son efficacit√©, ainsi que son √©tat de pr√©paration et sa tol√©rance aux pannes.  Kubernetes demande √† ces mesures de r√©fl√©chir aux prochaines √©tapes de routage et d'√©quilibrage de charge. </p><br><p>  Une application cloud bien con√ßue enregistre ses √©v√©nements cl√©s √† l'aide des flux d'E / S standard STDERR et STDOUT.  Ensuite, un service auxiliaire, par exemple filebeat, logstash ou fluentd, s'ex√©cute, fournissant les journaux √† un syst√®me de surveillance central (par exemple Prometheus) et au syst√®me de collecte de journaux (suite logicielle ELK).  Le diagramme ci-dessous montre comment l'application cloud fonctionne conform√©ment au mod√®le de bilan de sant√© et au principe de haute observabilit√©. </p><br><p><img src="https://habrastorage.org/webt/tz/v1/oi/tzv1oixhe3wj4xdwlc08w9roo0k.jpeg"></p><br><h3 id="kak-primenit-shablon-proverki-rabotosposobnosti-v-kubernetes">  Comment appliquer le mod√®le de bilan de sant√© dans Kubernetes? </h3><br><p>  Pr√™t √† l'emploi, k8s surveille l'√©tat des pods √† l'aide de l'un des contr√¥leurs ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©ploiements</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ReplicaSets</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DaemonSets</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">StatefulSets</a> , etc., etc.).  Apr√®s avoir d√©couvert que le pod est tomb√© pour une raison quelconque, le contr√¥leur essaie de le red√©marrer ou de le d√©placer vers un autre n≈ìud.  Cependant, pod peut signaler qu'il est op√©rationnel et qu'il ne fonctionne pas lui-m√™me.  Voici un exemple: votre application utilise Apache comme serveur web, vous avez install√© le composant sur plusieurs pods du cluster.  √âtant donn√© que la biblioth√®que n'a pas √©t√© configur√©e correctement, toutes les demandes √† l'application r√©pondent avec le code 500 (erreur de serveur interne).  Lors de la v√©rification de la livraison, la v√©rification du statut des pods donne un r√©sultat positif, cependant, les clients pensent diff√©remment.  Nous d√©crivons cette situation ind√©sirable comme suit: </p><br><p><img src="https://habrastorage.org/webt/zw/w-/fi/zww-fiwvktahptnfb2izazwzs6u.png"></p><br><p>  Dans notre exemple, k8s effectue <em>un bilan de sant√©</em> .  Dans ce type de v√©rification, kubelet v√©rifie en permanence l'√©tat du processus dans le conteneur.  Une fois qu'il comprend que le processus a augment√©, il le red√©marre.  Si l'erreur est √©limin√©e en red√©marrant simplement l'application et que le programme est con√ßu pour s'√©teindre en cas d'erreur, vous devez v√©rifier l'op√©rabilit√© du processus pour suivre la NRA et le mod√®le de v√©rification de l'√©tat.  Il est dommage que toutes les erreurs ne soient pas √©limin√©es en red√©marrant.  Dans ce cas, k8s propose 2 m√©thodes plus approfondies de d√©pannage d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">module</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livenessProbe</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">readinessProbe</a> . </p><br><h3 id="livenessprobe">  LivenessProbe </h3><br><p>  Pendant <strong>livenessProbe,</strong> kubelet effectue 3 types de v√©rifications: non seulement il v√©rifie si le pod fonctionne, mais s'il est pr√™t √† recevoir et √† r√©pondre ad√©quatement aux demandes: </p><br><ul><li>  D√©finissez une demande HTTP sur pod.  La r√©ponse doit contenir un code de r√©ponse HTTP compris entre 200 et 399. Ainsi, les codes 5xx et 4xx indiquent que le pod a des probl√®mes, m√™me si le processus est en cours d'ex√©cution. </li><li>  Pour v√©rifier les pods avec des services non HTTP (par exemple, serveur de messagerie Postfix), vous devez √©tablir une connexion TCP. </li><li>  Ex√©cution d'une commande arbitraire pour le pod (en interne).  La v√©rification est consid√©r√©e comme r√©ussie si le code d'exit de commande est 0. </li></ul><br><p>  Un exemple de comment cela fonctionne.  La d√©finition du pod suivant contient une application NodeJS qui donne une erreur de 500 pour les requ√™tes HTTP. Pour nous assurer que le conteneur red√©marre apr√®s avoir re√ßu une telle erreur, nous utilisons le param√®tre livenessProbe: </p><br><pre><code class="plaintext hljs">apiVersion: v1 kind: Pod metadata: name: node500 spec: containers: - image: magalix/node500 name: node500 ports: - containerPort: 3000 protocol: TCP livenessProbe: httpGet: path: / port: 3000 initialDelaySeconds: 5</code> </pre> <br><p>  Ce n'est pas diff√©rent de toute autre d√©finition de <code>.spec.containers.livenessProbe</code> , mais nous ajoutons un objet <code>.spec.containers.livenessProbe</code> .  Le param√®tre <code>httpGet</code> accepte le chemin o√π la requ√™te HTTP GET est envoy√©e (dans notre exemple, c'est <code>/</code> , mais dans les sc√©narios de bataille, il peut √©galement y avoir quelque chose comme <code>/api/v1/status</code> ).  LivenessProbe accepte toujours le param√®tre <code>initialDelaySeconds</code> , qui demande √† l'op√©ration de validation d'attendre un nombre sp√©cifi√© de secondes.  Le d√©lai est n√©cessaire car le conteneur a besoin de temps pour d√©marrer et lorsqu'il red√©marrera, il sera indisponible pendant un certain temps. </p><br><p>  Pour appliquer ce param√®tre √† un cluster, utilisez: </p><br><pre> <code class="plaintext hljs">kubectl apply -f pod.yaml</code> </pre> <br><p>  Apr√®s quelques secondes, vous pouvez v√©rifier le contenu du pod avec la commande suivante: </p><br><pre> <code class="plaintext hljs">kubectl describe pods node500</code> </pre> <br><p>  Recherchez les √©l√©ments suivants √† la fin de la sortie. </p><br><p>  Comme vous pouvez le voir, livenessProbe a lanc√© une requ√™te HTTP GET, le conteneur a g√©n√©r√© une erreur 500 (qui a √©t√© programm√©e pour), kubelet l'a red√©marr√©. </p><br><p>  Si vous √™tes int√©ress√© par la fa√ßon dont l'application NideJS a √©t√© programm√©e, voici les app.js et Dockerfile qui ont √©t√© utilis√©s: </p><br><p>  app.js </p><br><pre> <code class="plaintext hljs">var http = require('http'); var server = http.createServer(function(req, res) { res.writeHead(500, { "Content-type": "text/plain" }); res.end("We have run into an error\n"); }); server.listen(3000, function() { console.log('Server is running at 3000') })</code> </pre> <br><p>  Dockerfile </p><br><pre> <code class="plaintext hljs">FROM node COPY app.js / EXPOSE 3000 ENTRYPOINT [ "node","/app.js" ]</code> </pre> <br><p>  Il est important de faire attention √† ceci: livenessProbe ne red√©marrera le conteneur qu'en cas de panne.  Si le red√©marrage ne corrige pas l'erreur qui interf√®re avec le fonctionnement du conteneur, kubelet ne pourra pas prendre de mesures pour √©liminer le dysfonctionnement. </p><br><h3 id="readinessprobe">  readinessProbe </h3><br><p>  readinessProbe fonctionne de mani√®re similaire aux livenessProbes (requ√™tes GET, communications TCP et ex√©cution de commandes), √† l'exception des actions de d√©pannage.  Le conteneur dans lequel l'√©chec est enregistr√© ne red√©marre pas, mais est isol√© du trafic entrant.  Imaginez que l'un des conteneurs effectue beaucoup de calculs ou soit soumis √† une charge importante, ce qui augmente le temps de r√©ponse aux demandes.  Dans le cas de livenessProbe, un contr√¥le de disponibilit√© de r√©ponse est d√©clench√© (via le param√®tre de contr√¥le timeoutSeconds), apr√®s quoi kubelet red√©marre le conteneur.  Une fois lanc√©, le conteneur commence √† effectuer des t√¢ches gourmandes en ressources et est red√©marr√© √† nouveau.  Cela peut √™tre critique pour les applications soucieuses de la vitesse de r√©ponse.  Par exemple, une voiture en route attend une r√©ponse du serveur, la r√©ponse est retard√©e - et la voiture tombe en panne. </p><br><p>  √âcrivons une d√©finition de readinessProbe qui d√©finit le temps de r√©ponse pour une demande GET √† pas plus de deux secondes, et l'application r√©pondra √† une demande GET dans 5 secondes.  Le fichier pod.yaml devrait ressembler √† ceci: </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Pod metadata: name: nodedelayed spec: containers: - image: afakharany/node_delayed name: nodedelayed ports: - containerPort: 3000 protocol: TCP readinessProbe: httpGet: path: / port: 3000 timeoutSeconds: 2</code> </pre> <br><p>  D√©veloppez le pod avec kubectl: </p><br><pre> <code class="plaintext hljs">kubectl apply -f pod.yaml</code> </pre> <br><p>  Attendez quelques secondes, puis regardez comment fonctionne readinessProbe: </p><br><pre> <code class="plaintext hljs">kubectl describe pods nodedelayed</code> </pre> <br><p>  √Ä la fin de la conclusion, vous pouvez voir que certains √©v√©nements sont similaires <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√† cela</a> . </p><br><p>  Comme vous pouvez le voir, kubectl n'a pas red√©marr√© le pod lorsque le temps d'analyse a d√©pass√© 2 secondes.  Au lieu de cela, il a annul√© la demande.  Les connexions entrantes sont redirig√©es vers d'autres modules fonctionnels. </p><br><p>  Remarque: maintenant que la charge suppl√©mentaire a √©t√© supprim√©e du pod, kubectl lui envoie √† nouveau des requ√™tes: les r√©ponses √† la requ√™te GET ne sont plus retard√©es. </p><br><p>  A titre de comparaison: voici le fichier app.js modifi√©: </p><br><pre> <code class="plaintext hljs">var http = require('http'); var server = http.createServer(function(req, res) { const sleep = (milliseconds) =&gt; { return new Promise(resolve =&gt; setTimeout(resolve, milliseconds)) } sleep(5000).then(() =&gt; { res.writeHead(200, { "Content-type": "text/plain" }); res.end("Hello\n"); }) }); server.listen(3000, function() { console.log('Server is running at 3000') })</code> </pre> <br><p>  <strong>TL; DR</strong> <br>  Avant l'av√®nement des applications bas√©es sur le cloud, les journaux √©taient le principal moyen de surveiller et de v√©rifier l'√©tat des applications.  Cependant, il n'y avait aucun moyen de prendre des mesures de d√©pannage.  Les journaux sont utiles aujourd'hui, ils doivent √™tre collect√©s et envoy√©s au syst√®me d'assemblage des journaux pour l'analyse des situations d'urgence et la prise de d√©cision.  [ <em>tout cela pourrait √™tre fait sans applications cloud utilisant monit, par exemple, mais avec k8s c'est devenu beaucoup plus facile :) - Ed.</em>  ] </p><br><p>  Aujourd'hui, les corrections doivent √™tre effectu√©es presque en temps r√©el, les applications ne devraient donc plus √™tre des bo√Ætes noires.  Non, ils doivent indiquer les points d'extr√©mit√© qui permettent aux syst√®mes de surveillance de demander et de collecter des donn√©es pr√©cieuses sur l'√©tat des processus afin qu'ils puissent r√©pondre instantan√©ment si n√©cessaire.  C'est ce qu'on appelle le mod√®le de conception du bilan de sant√©, qui suit le principe de haute observabilit√© (NRA). </p><br><p>  Par d√©faut, Kubernetes propose 2 types de contr√¥les d'int√©grit√©: readinessProbe et livenessProbe.  Les deux utilisent les m√™mes types de v√©rifications (requ√™tes HTTP GET, communications TCP et ex√©cution de commandes).  Ils diff√®rent dans les d√©cisions qui sont prises en r√©ponse aux probl√®mes dans les gousses.  livenessProbe red√©marre le conteneur dans l'espoir que l'erreur ne se reproduira plus, et readinessProbe isole le pod du trafic entrant jusqu'√† ce que la cause du probl√®me soit r√©solue. </p><br><p>  Une conception d'application appropri√©e doit inclure les deux types de validation et collecter suffisamment de donn√©es, en particulier lorsqu'une exception est cr√©√©e.  Il doit √©galement indiquer les points de terminaison API n√©cessaires qui transmettent des mesures importantes de l'√©tat de sant√© au syst√®me de surveillance (√©galement appel√© Prometheus). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467155/">https://habr.com/ru/post/fr467155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467145/index.html">Pas seulement le trading: comment utiliser l'√©change comme alternative aux d√©p√¥ts bancaires et gagner un revenu</a></li>
<li><a href="../fr467147/index.html">Attaques de masse: caract√©ristiques de la contre-action sur l'exp√©rience de ces derni√®res ann√©es</a></li>
<li><a href="../fr467149/index.html">Antiquit√©s: 1992 dans la presse informatique</a></li>
<li><a href="../fr467151/index.html">Traitement des objections: l'analyse statique occupera une partie du temps de travail</a></li>
<li><a href="../fr467153/index.html">Travailler avec des objections: l'analyse statique fera partie du temps de travail</a></li>
<li><a href="../fr467161/index.html">Application Web sur Kotlin + Spring Boot + Vue.js</a></li>
<li><a href="../fr467163/index.html">Comment migrer vers le cloud en deux heures gr√¢ce √† Kubernetes et √† l'automatisation</a></li>
<li><a href="../fr467165/index.html">Sur les traces du mouvement russe Scala. 2e partie</a></li>
<li><a href="../fr467169/index.html">Le√ßons tir√©es des tests Plus de 200 000 lignes de code d'infrastructure</a></li>
<li><a href="../fr467171/index.html">Ce que j'ai appris en testant 200 000 lignes de code d'infrastructure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>