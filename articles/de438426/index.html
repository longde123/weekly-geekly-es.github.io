<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍒 🌸 👩🏽‍🎨 Zurück zu Microservices mit Istio. Teil 1 🚦 🏇🏻 🚂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Service-Meshes sind definitiv eine relevante Lösung in der modernen Infrastruktur für Anwendungen geworden, die der Microservice-Arch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zurück zu Microservices mit Istio. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/438426/"><img src="https://habrastorage.org/webt/bj/j4/oy/bjj4oyjxqshrbjf5eks9sgsvbeg.png"><br><br>  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Service-Meshes sind definitiv eine relevante Lösung in der modernen Infrastruktur für Anwendungen geworden, die der Microservice-Architektur folgen.</i>  <i>Obwohl Istio von vielen DevOps-Ingenieuren gehört wird, handelt es sich um ein ziemlich neues Produkt, das aufgrund seiner umfassenden Funktionen möglicherweise viel Zeit für die Bekanntschaft benötigt.</i>  <i>Der deutsche Ingenieur Rinor Maloku, der beim Telekommunikationsunternehmen Orange Networks für das Cloud-Computing für Großkunden verantwortlich ist, hat eine bemerkenswerte Reihe von Materialien verfasst, mit denen Sie schnell und tief in Istio eintauchen können.</i>  <i>Er beginnt seine Geschichte damit, was Istio kann und wie Sie es schnell mit eigenen Augen sehen können.</i> <br><br>  <b>Istio</b> ist ein Open Source-Projekt, das in Zusammenarbeit mit Teams von Google, IBM und Lyft entwickelt wurde.  Es löst die Schwierigkeiten, die bei Anwendungen auf der Basis von Mikrodiensten auftreten, wie zum Beispiel: <a name="habracut"></a><br><br><ul><li>  <b>Verkehrsmanagement</b> : Zeitüberschreitungen, Wiederholungsversuche, Lastausgleich; </li><li>  <b>Sicherheit</b> : Authentifizierung und Autorisierung des Endbenutzers; </li><li>  <b>Beobachtbarkeit</b> : Verfolgung, Überwachung, Protokollierung. </li></ul><br>  Alle von ihnen können auf Anwendungsebene gelöst werden, aber danach werden Ihre Dienste nicht mehr "Mikro".  Alle zusätzlichen Anstrengungen zur Lösung dieser Probleme sind eine zusätzliche Verschwendung von Unternehmensressourcen, die direkt für Unternehmenswerte verwendet werden könnten.  Betrachten Sie ein Beispiel: <br><blockquote> Projektmanager: Wie lange muss Feedback hinzugefügt werden? <br>  Entwickler: Zwei Sprints. <br><br>  MP: Was? .. Es ist nur CRUD! <br>  R: CRUD zu erstellen ist ein einfacher Teil der Aufgabe, aber wir müssen Benutzer und Dienste noch authentifizieren und autorisieren.  Da das Netzwerk unzuverlässig ist, müssen Sie wiederholte Anforderungen sowie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistungsschaltermuster</a> in Clients implementieren.  Um sicherzustellen, dass das gesamte System nicht herunterfällt, benötigen Sie Zeitüberschreitungen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schotte</a> <i>(weitere Einzelheiten zu den beiden genannten Mustern finden Sie weiter im Artikel - ca. Übersetzung)</i> . Um Probleme zu erkennen, zu überwachen, zu verfolgen, [...] <br><br>  MP: Oh, dann fügen wir diese Funktion einfach in den Produktservice ein. </blockquote>  Ich denke, die Idee ist klar: Das Volumen der Schritte und Anstrengungen, die erforderlich sind, um einen Dienst hinzuzufügen, ist enorm.  In diesem Artikel werden wir untersuchen, wie Istio alle oben genannten Schwierigkeiten (die nicht auf die Geschäftslogik abzielen) aus den Diensten entfernt. <br><br><img src="https://habrastorage.org/webt/l4/js/7o/l4js7omne2rslxitn0zr_lgusee.png"><br><br>  <b>Hinweis</b> : In diesem Artikel wird davon ausgegangen, dass Sie über praktische Kenntnisse in Kubernetes verfügen.  Ansonsten empfehle ich, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine Einführung in Kubernetes zu</a> lesen und erst danach dieses Material weiterzulesen. <br><br><h2>  Idee Istio </h2><br>  In einer Welt ohne Istio stellt ein Dienst direkte Anforderungen an einen anderen, und im Falle eines Fehlers muss der Dienst diese selbst verarbeiten: einen neuen Versuch unternehmen, eine Zeitüberschreitung bereitstellen, einen Leistungsschalter öffnen usw. <br><br><img src="https://habrastorage.org/webt/ov/uv/g5/ovuvg5sepxqvj7wduhnl3uiixyi.png"><br>  <i>Netzwerkverkehr in Kubernetes</i> <br><br>  Istio bietet auch eine spezialisierte Lösung, die völlig unabhängig von Diensten und Funktionen ist, indem sie die Netzwerkinteraktion stört.  Und so implementiert es: <br><br><ul><li>  <b>Fehlertoleranz</b> : Basierend auf dem Statuscode in der Antwort wird erkannt, ob die Anforderung fehlgeschlagen ist, und erneut ausgeführt. </li><li>  <b>Kanarische Rollouts</b> : <b>Leitet</b> nur einen festen Prozentsatz der Anzahl der Anfragen auf die neue Version des Dienstes um. </li><li>  <b>Überwachung und Metriken</b> : Wie lange hat der Dienst geantwortet? </li><li>  <b>Ablaufverfolgung und Beobachtbarkeit</b> : Fügt jeder Anforderung spezielle Header hinzu und verfolgt sie im Cluster. </li><li>  <b>Sicherheit</b> : Extrahiert JWT-Token, authentifiziert und autorisiert Benutzer. </li></ul><br>  Dies sind nur einige der Möglichkeiten (wirklich nur einige!), Sie zu faszinieren.  Lassen Sie uns nun in die technischen Details eintauchen! <br><br><h2>  Architektur Istio </h2><br>  Istio fängt den gesamten Netzwerkverkehr ab und wendet eine Reihe von Regeln an, wobei in jeden Pod ein intelligenter Proxy in Form eines Beiwagencontainers eingefügt wird.  Proxys, die alle Features aktivieren, bilden eine Datenebene und können mithilfe der <b>Steuerungsebene</b> dynamisch konfiguriert werden. <br><br><h2>  Datenebene </h2><br>  Die in Pods eingefügten Proxys ermöglichen es Istio, die von uns benötigten Anforderungen problemlos zu erfüllen.  Überprüfen Sie beispielsweise die Wiederholungs- und Leistungsschalterfunktionen. <br><br><img src="https://habrastorage.org/webt/8t/7x/xn/8t7xxntkiuakkk5sbn41b4rualg.gif"><br>  <i>Wie Wiederholungsversuche und Unterbrechungen in Envoy implementiert werden</i> <br><br>  Zusammenfassend: <br><br><ol><li>  Gesandter <i>(spricht von einem Proxy in einem Beiwagencontainer, der als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">separates Produkt verteilt wird</a> - ca. Übersetzung)</i> Sendet eine Anfrage an die erste Instanz von Service B, und es tritt ein Fehler auf. </li><li>  <i>Wiederholungsversuche des</i> Gesandtenwagens.  <i>(1)</i> </li><li>  Die fehlgeschlagene Anforderung wird an den Proxy zurückgegeben, der sie aufgerufen hat. </li><li>  Dadurch wird der Leistungsschalter geöffnet und der nächste Dienst für nachfolgende Anforderungen aufgerufen.  <i>(2)</i> </li></ol><br>  Dies bedeutet, dass Sie nicht die nächste Wiederholungsbibliothek verwenden müssen, sondern keine eigene Implementierung von Circuit Breaking und Service Discovery in der Programmiersprache X, Y oder Z durchführen müssen. All dies und vieles mehr ist in Istio sofort verfügbar und erfordert <b>keine</b> Änderungen am Code. <br><br>  Großartig!  Jetzt möchten Sie vielleicht eine Reise mit Istio unternehmen, aber es gibt immer noch einige Zweifel, offene Fragen.  Wenn dies eine universelle Lösung für alle Gelegenheiten im Leben ist, dann haben Sie einen berechtigten Verdacht: Schließlich erweisen sich alle derartigen Entscheidungen in Wirklichkeit für jeden Anlass als ungeeignet. <br><br>  Und schließlich fragen Sie: "Ist es anpassbar?" <br><br>  Jetzt sind Sie bereit für eine Seereise - und machen wir uns mit dem Kontrollflugzeug vertraut. <br><br><h2>  Steuerebene </h2><br>  Es besteht aus drei Komponenten: <b>Pilot</b> , <b>Mixer</b> und <b>Citadel</b> , die zusammenarbeiten, um Gesandte so zu konfigurieren, dass sie den Verkehr weiterleiten, Richtlinien anwenden und Telemetriedaten erfassen.  Schematisch sieht alles so aus: <br><br><img src="https://habrastorage.org/webt/dw/p6/hh/dwp6hh6y5g41oinfxccixuutkyo.png"><br>  <i>Steuerungsebene Interaktion mit Datenebene</i> <br><br>  Gesandte (d. H. Datenebene) werden unter Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes CRD</a> (Custom Resource Definitions) konfiguriert, die von Istio definiert und speziell für diesen Zweck entwickelt wurden.  Für Sie bedeutet dies, dass sie die nächste Ressource in Kubernetes mit vertrauter Syntax zu sein scheinen.  Nach der Erstellung wird diese Ressource von der Steuerebene aufgenommen und auf Gesandte angewendet. <br><br><h2>  Service Ratio für Istio </h2><br>  Wir haben Istios Einstellung zu Dienstleistungen beschrieben, aber nicht das Gegenteil: Wie hängen Dienstleistungen mit Istio zusammen? <br><br>  Ehrlich gesagt weiß Istio über das Vorhandensein von Dienstleistungen und Fischen Bescheid - über Wasser, wenn sie sich fragen: „Was ist Wasser im Allgemeinen?“. <br><br><img src="https://habrastorage.org/webt/re/oi/ff/reoiffespub6tknffwssilkgu7c.jpeg"><br>  <i>Illustration von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Victoria Dimitrakopoulos</a> : - Wie gefällt dir das Wasser?</i>  <i>- Was ist Wasser im Allgemeinen?</i> <br><br>  Auf diese Weise können Sie den Arbeitscluster verwenden. Nach der Bereitstellung der Istio-Komponenten funktionieren die darin enthaltenen Dienste weiterhin. Nach dem Entfernen dieser Komponenten ist wieder alles in Ordnung.  Es ist klar, dass Sie dadurch die von Istio gebotenen Möglichkeiten verlieren. <br><br>  Genug Theorie - lassen Sie uns dieses Wissen in die Praxis umsetzen! <br><br><h2>  Istio in der Praxis </h2><br>  Istio benötigt einen Kubernetes-Cluster, in dem mindestens 4 vCPUs und 8 GB RAM verfügbar sind.  Um den Cluster schnell zu erhöhen und den Anweisungen aus dem Artikel zu folgen, empfehle ich die Verwendung der Google Cloud Platform, die neuen Nutzern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">300 US-Dollar kostenlos</a> bietet. <br><br>  Nachdem Sie einen Cluster erstellt und den Zugriff auf Kubernetes über das Konsolendienstprogramm konfiguriert haben, können Sie Istio über den Helm-Paketmanager installieren. <br><br><h2>  Helminstallation </h2><br>  Installieren Sie den Helm-Client auf Ihrem Computer, wie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation angegeben</a> .  Wir werden es verwenden, um Vorlagen für die Installation von Istio im nächsten Abschnitt zu generieren. <br><br><h2>  Installieren Sie Istio </h2><br>  Laden Sie die Istio-Ressourcen aus der <a href="">neuesten</a> <i>Version herunter (der Link des ursprünglichen Autors zu Version 1.0.5 wurde in die aktuelle Version geändert, dh 1.0.6 - ca. Übersetzung)</i> . Extrahieren Sie den Inhalt in ein Verzeichnis, das ich in Zukunft <code>[istio-resources]</code> werde <code>[istio-resources]</code> . <br><br>  Erstellen Sie den <code>istio-system</code> Namespace im K8s-Cluster, um die Identifizierung von Istio-Ressourcen zu vereinfachen: <br><br><pre> <code class="bash hljs">$ kubectl create namespace istio-system</code> </pre> <br>  <code>[istio-resources]</code> die Installation ab, indem Sie in das <code>[istio-resources]</code> und den folgenden Befehl <code>[istio-resources]</code> : <br><br><pre> <code class="bash hljs">$ helm template install/kubernetes/helm/istio \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> global.mtls.enabled=<span class="hljs-literal"><span class="hljs-literal">false</span></span> \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> tracing.enabled=<span class="hljs-literal"><span class="hljs-literal">true</span></span> \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> kiali.enabled=<span class="hljs-literal"><span class="hljs-literal">true</span></span> \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> grafana.enabled=<span class="hljs-literal"><span class="hljs-literal">true</span></span> \ --namespace istio-system &gt; istio.yaml</code> </pre> <br>  Dieser Befehl gibt die Schlüsselkomponenten von Istio in die Datei <code>istio.yaml</code> .  Wir haben die Standardvorlage für uns selbst geändert und die folgenden Parameter angegeben: <br><br><ul><li>  <code>global.mtls.enabled</code> auf <code>false</code> <i>(d. h. die mTLS-Authentifizierung ist deaktiviert - ca. übersetzt)</i> , um unseren Datierungsprozess zu vereinfachen. </li><li>  <code>tracing.enabled</code> die <code>tracing.enabled</code> mit Jaeger. </li><li>  <code>kiali.enabled</code> installiert Kiali in einem Cluster, um Dienste und Datenverkehr zu visualisieren. </li><li>  <code>grafana.enabled</code> legt Grafana fest, um gesammelte Metriken zu visualisieren. </li></ul><br>  Wir wenden die generierten Ressourcen mit dem Befehl an: <br><br><pre> <code class="bash hljs">$ kubectl apply -f istio.yaml</code> </pre> <br>  Die Installation von Istio im Cluster ist abgeschlossen!  Warten Sie, bis alle Pods im <code>istio-system</code> Namespace ausgeführt oder <code>Completed</code> indem Sie den folgenden Befehl <code>istio-system</code> : <br><br><pre> <code class="bash hljs">$ kubectl get pods -n istio-system</code> </pre> <br>  Jetzt können wir mit dem nächsten Abschnitt fortfahren, in dem wir die Anwendung auslösen und starten. <br><br><h2>  Sentiment Analysis Anwendungsarchitektur </h2><br>  Nehmen wir ein Beispiel für die Microservice-Anwendung Sentiment Analysis, die im bereits erwähnten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführungsartikel in Kubernetes verwendet wird</a> .  Es ist hoch entwickelt genug, um die Fähigkeiten von Istio in der Praxis zu demonstrieren. <br><br>  Die Anwendung besteht aus vier Microservices: <br><br><ol><li>  Service <b>SA-Frontend</b> , das Front-End-Anwendungen auf Reactjs bereitstellt; </li><li>  Ein <b>SA-WebApp-</b> Dienst, der Sentiment Analysis-Anforderungen <b>bearbeitet</b> . </li><li>  Service <b>SA-Logic</b> , der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sentimentale Analysen durchführt</a> ; </li><li>  Service <b>SA-Feedback</b> , das Feedback von Benutzern zur Genauigkeit der Analyse erhält. </li></ol><br><img src="https://habrastorage.org/webt/hi/jv/oc/hijvoc4y7ercttsbopo4jzbo4w4.png"><br><br>  In diesem Diagramm sehen wir neben den Diensten auch den Ingress Controller, der in Kubernetes eingehende Anforderungen an die entsprechenden Dienste weiterleitet.  Istio verwendet ein ähnliches Konzept innerhalb des Ingress Gateway, dessen Details folgen werden. <br><br><h2>  Starten einer Anwendung mit einem Proxy von Istio </h2><br>  Klonen Sie für die im Artikel genannten weiteren Vorgänge das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Istio-Mastery-</a> Repository.  Es enthält die App und Manifeste für Kubernetes und Istio. <br><br><h3>  Beiwageneinsatz </h3><br>  Das Einfügen kann <b>automatisch</b> oder <b>manuell erfolgen</b> .  Um Seitenwagencontainer automatisch einzufügen, müssen Sie <code>istio-injection=enabled</code> Label <code>istio-injection=enabled</code> auf den <code>istio-injection=enabled</code> , was mit dem folgenden Befehl ausgeführt wird: <br><br><pre> <code class="bash hljs">$ kubectl label namespace default istio-injection=enabled namespace/default labeled</code> </pre> <br>  Jetzt erhält jeder Pod, der im Standard-Namespace bereitgestellt wird, seinen Sidecar-Container.  Um dies zu überprüfen, installieren wir eine <code>[istio-mastery]</code> indem wir in das Stammverzeichnis des Repositorys <code>[istio-mastery]</code> und den folgenden Befehl <code>[istio-mastery]</code> : <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/kube persistentvolumeclaim/sqlite-pvc created deployment.extensions/sa-feedback created service/sa-feedback created deployment.extensions/sa-frontend created service/sa-frontend created deployment.extensions/sa-logic created service/sa-logic created deployment.extensions/sa-web-app created service/sa-web-app created</code> </pre> <br>  Nachdem wir die Dienste erweitert haben, überprüfen wir, ob Pods zwei Container haben (mit dem Dienst selbst und seinem Beiwagen), indem <code>kubectl get pods</code> Befehl <code>kubectl get pods</code> ausführen und sicherstellen, dass der Wert <code>2/2</code> in der Spalte <code>READY</code> , was symbolisiert, dass beide Container ausgeführt werden: <br><br><pre> <code class="bash hljs">$ kubectl get pods NAME READY STATUS RESTARTS AGE sa-feedback-55f5dc4d9c-c9wfv 2/2 Running 0 12m sa-frontend-558f8986-hhkj9 2/2 Running 0 12m sa-logic-568498cb4d-2sjwj 2/2 Running 0 12m sa-logic-568498cb4d-p4f8c 2/2 Running 0 12m sa-web-app-599cf47c7c-s7cvd 2/2 Running 0 12m</code> </pre> <br>  Optisch sieht es so aus: <br><br><img src="https://habrastorage.org/webt/x9/kt/lu/x9ktluxxjopen7rn9tchuyvvioi.png"><br>  <i>Gesandte Stellvertreter in einem der Pods</i> <br><br>  Nachdem die Anwendung ausgeführt wird, müssen wir zulassen, dass eingehender Datenverkehr in die Anwendung gelangt. <br><br><h2>  Ingress Gateway </h2><br>  Die beste Vorgehensweise, um dies zu erreichen (um Datenverkehr im Cluster zuzulassen), ist das <b>Ingress Gateway</b> in Istio, das sich an der „Grenze“ des Clusters befindet und es Ihnen ermöglicht, Istio-Funktionen wie Routing, Lastausgleich, Sicherheit und Überwachung für eingehenden Datenverkehr zu aktivieren. <br><br>  Die Ingress Gateway-Komponente und der Dienst, der sie nach außen weiterleitet, wurden während der Installation von Istio im Cluster installiert.  Gehen Sie wie folgt vor, um die externe IP-Adresse eines Dienstes zu ermitteln: <br><br><pre> <code class="bash hljs">$ kubectl get svc -n istio-system -l istio=ingressgateway NAME TYPE CLUSTER-IP EXTERNAL-IP istio-ingressgateway LoadBalancer 10.0.132.127 13.93.30.120</code> </pre> <br>  Wir werden weiterhin über diese IP auf die Anwendung zugreifen (ich werde sie als EXTERNAL-IP bezeichnen), daher werden wir den Wert der Einfachheit halber in eine Variable schreiben: <br><br><pre> <code class="bash hljs">$ EXTERNAL_IP=$(kubectl get svc -n istio-system \ -l app=istio-ingressgateway \ -o jsonpath=<span class="hljs-string"><span class="hljs-string">'{.items[0].status.loadBalancer.ingress[0].ip}'</span></span>)</code> </pre> <br>  Wenn Sie jetzt versuchen, über einen Browser auf diese IP zuzugreifen, wird der Fehler "Dienst nicht verfügbar" angezeigt, da  <b>Standardmäßig blockiert Istio den gesamten eingehenden Datenverkehr,</b> bis ein Gateway definiert ist. <br><br><h2>  Gateway-Ressource </h2><br>  Gateway ist eine CRD (Custom Resource Definition) in Kubernetes, die nach der Installation von Istio in einem Cluster und der Aktivierung der Angabe der Ports, Protokolle und Hosts definiert wird, für die eingehender Datenverkehr zugelassen werden soll. <br><br>  In unserem Fall möchten wir den HTTP-Verkehr für alle Hosts auf Port 80 zulassen.  Die Aufgabe wird durch die folgende Definition <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gist.github.com/rinormaloku/577d0e23590f7a8dfbe56fe2a1f853d7&amp;usg=ALkJrhhUk-okaV80IZkso7LfFtO_S_MxOg#file-">http-gateway.yaml</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gist.github.com/rinormaloku/577d0e23590f7a8dfbe56fe2a1f853d7&amp;usg=ALkJrhhUk-okaV80IZkso7LfFtO_S_MxOg#file-">implementiert</a></i> : <br><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: http-gateway spec: selector: istio: ingressgateway servers: - port: number: 80 name: http protocol: HTTP hosts: - "*"</code> </pre> <br>  Diese Konfiguration bedarf keiner Erläuterung mit Ausnahme des <code>istio: ingressgateway</code> .  Mit diesem Selektor können wir angeben, auf welches Ingress Gateway die Konfiguration angewendet wird.  In unserem Fall ist dies der Ingress Gateway-Controller, der standardmäßig in Istio installiert wurde. <br><br>  Die Konfiguration wird durch Aufrufen des folgenden Befehls angewendet: <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/http-gateway.yaml gateway.networking.istio.io/http-gateway created</code> </pre> <br>  Jetzt ermöglicht das Gateway den Zugriff auf Port 80, hat jedoch keine Ahnung, wohin Anforderungen weitergeleitet werden sollen.  Dies erfordert <b>virtuelle Dienste</b> . <br><br><h2>  VirtualService-Ressource </h2><br>  VirtualService teilt Ingress Gateway mit, wie Anforderungen weitergeleitet werden sollen, die innerhalb des Clusters zulässig sind. <br><br>  Anfragen an unsere Anwendung, die über das http-Gateway eingehen, müssen an die Dienste sa-frontend, sa-web-app und sa-feedback gesendet werden: <br><br><img src="https://habrastorage.org/webt/zi/il/7_/ziil7_-9gfy5ejkhkzzn1wpxkxe.png"><br>  <i>Zu konfigurierende Routen mit VirtualServices</i> <br><br>  Betrachten Sie die Anforderungen, die an SA-Frontend gesendet werden sollten: <br><br><ul><li>  Eine genaue Übereinstimmung auf dem Pfad <code>/</code> sollte an SA-Frontend gesendet werden, um index.html zu erhalten. </li><li>  Pfade mit dem Präfix <code>/static/*</code> müssen an SA-Frontend gesendet werden, um statische Dateien zu empfangen, die im Frontend verwendet werden, z. B. CSS und JavaScript. </li><li>  Pfade, die dem regulären Ausdruck <code>'^.*\.(ico|png|jpg)$'</code> müssen an SA-Frontend gesendet werden  Dies sind die auf der Seite angezeigten Bilder. </li></ul><br>  Die Implementierung wird durch die folgende Konfiguration erreicht <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sa-virtualservice-external.yaml</a> ):</i> <br><br><pre> <code class="plaintext hljs">kind: VirtualService metadata: name: sa-external-services spec: hosts: - "*" gateways: - http-gateway # 1 http: - match: - uri: exact: / - uri: exact: /callback - uri: prefix: /static - uri: regex: '^.*\.(ico|png|jpg)$' route: - destination: host: sa-frontend # 2 port: number: 80</code> </pre> <br>  Wichtige Punkte: <br><br><ol><li>  Dieser VirtualService bezieht sich auf Anforderungen, die über das <b>http-Gateway eingehen</b> . </li><li>  <code>destination</code> definiert den Dienst, an den Anforderungen gesendet werden. </li></ol><br>  <b>Hinweis</b> : Die obige Konfiguration wird in der Datei <code>sa-virtualservice-external.yaml</code> gespeichert, die auch die Einstellungen für das Routing in SA-WebApp und SA-Feedback enthält, wurde jedoch hier im Artikel der Kürze halber gekürzt. <br><br>  Wenden Sie VirtualService an, indem Sie Folgendes aufrufen: <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/sa-virtualservice-external.yaml virtualservice.networking.istio.io/sa-external-services created</code> </pre> <br>  <b>Hinweis</b> : Wenn wir Istio-Ressourcen verwenden, löst der Kubernetes-API-Server ein Ereignis aus, das die Istio-Steuerebene empfängt. Danach wird die neue Konfiguration auf die Envoy-Proxys jedes Pods angewendet.  Der Ingress Gateway-Controller scheint der nächste in der Steuerebene konfigurierte Gesandte zu sein.  Das alles auf dem Diagramm sieht so aus: <br><br><img src="https://habrastorage.org/webt/dz/nz/4b/dznz4bh_wpzcv7tx8jkykkiad9q.png"><br>  <i>Istio-IngressGateway-Konfiguration für das Abfrage-Routing</i> <br><br>  Die Stimmungsanalyse ist unter <code>http://{EXTERNAL-IP}/</code> verfügbar.  Machen Sie sich keine Sorgen, wenn Sie den Status "Nicht gefunden" erhalten: <i>Manchmal dauert es etwas länger, bis die Konfiguration wirksam wird und die Envoy-Caches aktualisiert werden</i> . <br><br>  Bevor Sie fortfahren, arbeiten Sie ein wenig mit der Anwendung, um Datenverkehr zu generieren <i>(deren Vorhandensein ist aus Gründen der Klarheit in den nächsten Schritten erforderlich - ca. Übersetzung)</i> . <br><br><h2>  Kiali: Beobachtbarkeit </h2><br>  Führen Sie den folgenden Befehl aus, um zur Kiali-Verwaltungsoberfläche zu gelangen: <br><br><pre> <code class="bash hljs">$ kubectl port-forward \ $(kubectl get pod -n istio-system -l app=kiali \ -o jsonpath=<span class="hljs-string"><span class="hljs-string">'{.items[0].metadata.name}'</span></span>) \ -n istio-system 20001</code> </pre> <br>  ... und öffnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 20001 /</a> und melden Sie sich als admin / admin an.  Hier finden Sie viele nützliche Funktionen, zum Beispiel zum Überprüfen der Konfiguration von Istio-Komponenten, zum Visualisieren von Diensten anhand von Informationen, die beim Abfangen von Netzwerkanforderungen gesammelt wurden, und zum Erhalten von Antworten auf die Fragen „Wer kontaktiert wen?“, „Welche Version des Dienstes stürzt ab?“.  usw.  Informieren Sie sich im Allgemeinen über die Möglichkeiten von Kiali, bevor Sie mit Grafana Metriken visualisieren. <br><br><img src="https://habrastorage.org/webt/ix/pd/wr/ixpdwrppiekv0dbk3xcbceasft8.png"><br><br><h2>  Grafana: Visualisierung von Metriken </h2><br>  In Istio gesammelte Metriken gelangen in Prometheus und werden mit Grafana visualisiert.  Führen Sie den folgenden Befehl aus, um in die Grafana-Administrationsoberfläche zu gelangen, und öffnen Sie dann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 3000 /</a> : <br><br><pre> <code class="bash hljs">$ kubectl -n istio-system port-forward \ $(kubectl -n istio-system get pod -l app=grafana \ -o jsonpath={.items[0].metadata.name}) 3000</code> </pre> <br>  Beginnen Sie mit dem <b>sa-web-app-Dienst</b> , indem <b>Sie</b> oben links auf das <b>Home-</b> Menü oben links <b>klicken</b> und das <b>Istio-Service-Dashboard</b> auswählen, um die gesammelten <b>Messdaten anzuzeigen</b> : <br><br><img src="https://habrastorage.org/webt/wb/vz/4t/wbvz4tkgi3qgoitxhhwhppk9pu8.png"><br><br>  Hier warten wir auf eine leere und völlig langweilige Leistung - das Management wird dies niemals gutheißen.  Erstellen wir eine kleine Last mit dem folgenden Befehl: <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ curl -i http://<span class="hljs-variable"><span class="hljs-variable">$EXTERNAL_IP</span></span>/sentiment \ -H <span class="hljs-string"><span class="hljs-string">"Content-type: application/json"</span></span> \ -d <span class="hljs-string"><span class="hljs-string">'{"sentence": "I love yogobella"}'</span></span>; \ sleep .8; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Jetzt haben wir viel schönere Diagramme und zusätzlich dazu wunderbare Prometheus-Tools zur Überwachung und Grafana zur Visualisierung von Metriken, mit denen wir mehr über die Leistung, den Gesundheitszustand, Verbesserungen / Verschlechterungen der Dienste im Laufe der Zeit erfahren können. <br><br>  Schauen wir uns zum Schluss die Ablaufverfolgung von Anforderungen in Diensten an. <br><br><h2>  Jaeger: Spur </h2><br>  Wir müssen nachverfolgen, denn je mehr Dienste wir haben, desto schwieriger ist es, die Ursache des Fehlers zu finden.  Schauen wir uns einen einfachen Fall aus dem Bild unten an: <br><br><img src="https://habrastorage.org/webt/dv/8w/iv/dv8wivmvfn20fvmaebzk8wl6h68.png"><br>  <i>Ein typisches Beispiel für eine zufällige fehlgeschlagene Anforderung</i> <br><br>  Die Anfrage kommt, fällt - <i>was ist der Grund?</i>  <i>Erster Service?</i>  <i>Oder der zweite?</i>  In beiden Fällen gibt es Ausnahmen - schauen wir uns die einzelnen Protokolle an.  Wie oft machst du das?  Unsere Arbeit ähnelt eher Software-Detektiven als Entwicklern ... <br><br>  Dies ist ein weit verbreitetes Problem bei Mikrodiensten und wird durch verteilte Ablaufverfolgungssysteme gelöst, in denen Dienste sich gegenseitig einen eindeutigen Header übergeben. Anschließend werden diese Informationen an das Ablaufverfolgungssystem umgeleitet, wo sie den Anforderungsdaten zugeordnet werden.  Hier ist eine Illustration: <br><br><img src="https://habrastorage.org/webt/an/_h/tz/an_htzqnc3b4xxhgkzdqi5my-ki.png"><br>  <i>TraceId wird verwendet, um die Anforderung zu identifizieren.</i> <br><br>  Istio verwendet Jaeger Tracer, der ein herstellerunabhängiges OpenTracing-API-Framework implementiert.  Sie können mit dem folgenden Befehl auf die Jaeger-Benutzeroberfläche zugreifen: <br><br><pre> <code class="bash hljs">$ kubectl port-forward -n istio-system \ $(kubectl get pod -n istio-system -l app=jaeger \ -o jsonpath=<span class="hljs-string"><span class="hljs-string">'{.items[0].metadata.name}'</span></span>) 16686</code> </pre> <br>  Gehen Sie nun zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 16686 /</a> und wählen Sie den Dienst <b>sa-web-app aus</b> .  Wenn der Dienst nicht im Dropdown-Menü angezeigt wird, zeigen / generieren Sie Aktivitäten auf der Seite und aktualisieren Sie die Benutzeroberfläche.  Klicken Sie anschließend auf die Schaltfläche " <b>Spuren</b> suchen", um die neuesten Spuren anzuzeigen. Wählen Sie eine beliebige aus. Es werden detaillierte Informationen zu allen Spuren angezeigt: <br><br><img src="https://habrastorage.org/webt/r8/zx/1q/r8zx1qjxc2a316-4a803l4vmzv4.png"><br><br>  Diese Spur zeigt: <br><br><ol><li>  Die Anfrage kommt zu <b>istio-ingressgateway</b> (dies ist die erste Interaktion mit einem der Dienste, und für die Anfrage wird eine Trace-ID generiert). <b>Danach</b> sendet das Gateway die Anfrage an den <b>sa-web-app-Dienst</b> . </li><li>  Im <b>sa-web-app-Dienst wird die</b> Anfrage vom Envoy-Beiwagen abgeholt, ein „Kind“ wird in der Spanne erstellt (daher sehen wir es in den Traces) und in den <b>sa-web-app-</b> Container umgeleitet.  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Span</a> ist eine logische Arbeitseinheit in Jaeger, die einen Namen, die Zeit, zu der die Operation gestartet wurde, und ihre Dauer hat. Spans können verschachtelt und geordnet werden. Ein gerichteter azyklischer Graph aus Spans bildet eine Spur. - Ca. Transl.)</i> </li><li>  Hier wird die Anfrage von der <b>sentimentAnalysis-</b> Methode verarbeitet.  Diese Spuren werden bereits von der Anwendung erzeugt, d.h.  Sie erforderten Änderungen am Code. </li><li>  Ab diesem Moment wird eine POST-Anfrage an <b>sa-Logik</b> initiiert.  Die Trace-ID muss von der <b>sa-web-app weitergeleitet werden</b> . </li><li>  ... </li></ol><br>  <b>Hinweis</b> : In Schritt 4 sollte die Anwendung die von Istio generierten Header sehen und an nachfolgende Anforderungen weiterleiten, wie in der folgenden Abbildung dargestellt: <br><br><img src="https://habrastorage.org/webt/qg/a9/ai/qga9aibwkynfogbcxfo2cnwqxfm.png"><br>  <i>(A) Istio ist für die Weiterleitung der Header verantwortlich.</i>  <i><b>(B) Services sind für die Header verantwortlich.</b></i> <br><br>  Istio erledigt den Großteil der Arbeit als  generiert Header für eingehende Anfragen, erstellt neue Bereiche in jeder Sidecare und leitet diese weiter.  Ohne die Arbeit mit Headern innerhalb der Dienste geht jedoch der vollständige Pfad der Anforderungsverfolgung verloren. <br><br>  Folgende Überschriften sollten berücksichtigt (weitergeleitet) werden: <br><br><pre> <code class="plaintext hljs">x-request-id x-b3-traceid x-b3-spanid x-b3-parentspanid x-b3-sampled x-b3-flags x-ot-span-context</code> </pre> <br>  Dies ist eine einfache Aufgabe. Um die Implementierung zu vereinfachen, sind jedoch bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele Bibliotheken</a> vorhanden. Beispielsweise leitet der RestTemplate-Client im sa-web-app-Dienst diese Header weiter, wenn Sie einfach die Jaeger- und OpenTracing-Bibliotheken hinzufügen. <br><br>  <i>Beachten Sie, dass die Sentiment Analysis-Anwendung Implementierungen auf Flask, Spring und ASP.NET Core demonstriert.</i> <br><br>  Jetzt, da klar ist, was wir aus der Box bekommen (oder fast "aus der Box"), werden wir Fragen des fein abgestimmten Routings, des Netzwerkverkehrsmanagements, der Sicherheit usw. berücksichtigen! <br><br>  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Lesen Sie darüber in der nächsten Ausgabe von Rinor Malokus Istio, die in naher Zukunft auf unserem Blog verfügbar sein wird.</i>  <i><b>UPDATE</b> (14. März): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der zweite Teil</a> wurde bereits veröffentlicht.</i> <br><br><h2>  PS vom Übersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  "Zurück zu Microservices mit Istio": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2 (Routing, Verkehrskontrolle)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3 (Authentifizierung und Autorisierung)</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Conduit - ein leichtes Service-Mesh für Kubernetes</a> "; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist ein Service-Mesh und warum brauche ich es [für eine Cloud-Anwendung mit Microservices]?</a>  "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein illustrierter Leitfaden zur Vernetzung bei Kubernetes."</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 1 und 2</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie ist dieser Beiwagencontainer hierher gekommen [bei Kubernetes]?"</a>  ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438426/">https://habr.com/ru/post/de438426/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438412/index.html">Analyse von 112654 Testaufgaben und Trends auf dem Arbeitsmarkt von Programmierern im Jahr 2019</a></li>
<li><a href="../de438414/index.html">Frühlingszivilisation, 3/5</a></li>
<li><a href="../de438416/index.html">Über Hormone</a></li>
<li><a href="../de438420/index.html">KI im Jahr 2019: der aktuelle Stand der Dinge</a></li>
<li><a href="../de438422/index.html">Ein Wahlverletzungsprogramm (Teil 2): ​​Longride über Erste Hilfe und Wiederbelebung</a></li>
<li><a href="../de438428/index.html">Regierungsbehörden haben einen Weg gefunden, inländische Software zu sabotieren</a></li>
<li><a href="../de438430/index.html">Ich stecke fest! Oder wie man den Plateaueffekt beim Englischlernen überwindet</a></li>
<li><a href="../de438434/index.html">Hacker Lab: P1. Libssh Auth Bypass</a></li>
<li><a href="../de438436/index.html">Die Idee, Mitarbeitern vorübergehenden Zugriff auf Kundenressourcen zu ermöglichen, ohne erneut Kennwörter zu verwenden</a></li>
<li><a href="../de438438/index.html">Futter für Bitrix Papageien. Wir testen die Leistung, wählen Eisen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>