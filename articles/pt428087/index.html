<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüöí üåò üö¥üèæ ‚ÄúSem bloqueio ou sem bloqueio, eis a quest√£o‚Äù ou ‚ÄúSono saud√°vel √© pior que rabanete amargo‚Äù üôáüèæ ü¶ñ üéñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Os coment√°rios no artigo " Como dormir corretamente e incorretamente " me inspiraram a escrever este artigo. 


 Este artigo se concentrar√° no desenvo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>‚ÄúSem bloqueio ou sem bloqueio, eis a quest√£o‚Äù ou ‚ÄúSono saud√°vel √© pior que rabanete amargo‚Äù</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428087/"><p>  Os coment√°rios no artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como dormir corretamente e incorretamente</a> " me inspiraram a escrever este artigo. </p><br><p>  Este artigo se concentrar√° no desenvolvimento de aplicativos multiencadeados, na aplicabilidade do lock-free em alguns casos decorrentes do processo de trabalho no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LAppS</a> , na fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nanosleep</a> e na viol√™ncia contra o agendador de tarefas. </p><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">NB</span></span>:      <span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>++  <span class="hljs-selector-tag"><span class="hljs-selector-tag">Linux</span></span>,       <span class="hljs-selector-tag"><span class="hljs-selector-tag">POSIX</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1-2008</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> (    ).</code> </pre> <br><p>  Em geral, tudo est√° muito confuso, espero que a linha de pensamento da apresenta√ß√£o seja clara.  Se estiver interessado, pe√ßo um gato. </p><a name="habracut"></a><br><p>  O software orientado a eventos est√° sempre esperando por algo.  Seja uma GUI ou um servidor de rede, eles est√£o aguardando eventos: entrada do teclado, eventos do mouse, pacote de dados que chega pela rede.  Mas todo o software espera de maneira diferente.  Os sistemas sem bloqueio n√£o precisam esperar nada.  Pelo menos o uso de algoritmos sem bloqueio deve ocorrer onde voc√™ n√£o precisa esperar e at√© prejudicial.  Mas estamos falando de sistemas competitivos (multiencadeados) e, curiosamente, algoritmos sem bloqueio tamb√©m est√£o aguardando.  Sim, eles n√£o bloqueiam a execu√ß√£o de encadeamentos paralelos, mas eles mesmos est√£o aguardando a oportunidade de fazer algo sem bloquear. </p><br><p>  O LAppS usa mutexes e sem√°foros muito ativamente.  Ao mesmo tempo, n√£o h√° sem√°foros no padr√£o C ++.  O mecanismo √© muito importante e conveniente, mas o C ++ deve funcionar em sistemas que n√£o possuem suporte a sem√°foros e, portanto, os sem√°foros n√£o est√£o inclu√≠dos no padr√£o.  Al√©m disso, se eu usar sem√°foros, porque eles s√£o convenientes, ent√£o mutexes, porque eu preciso. </p><br><p>  O comportamento do mutex no caso de lock competitivo (), como sem_wait () no Linux, coloca o thread em espera no final da fila do planejador de tarefas e, quando est√° no topo, a verifica√ß√£o √© repetida sem retornar √† √°rea do usu√°rio, o thread √© colocado de volta na fila se o evento esperado ainda n√£o ocorreu.  Este √© um ponto muito importante. </p><br><p>  E decidi verificar se posso recusar os sem√°foros std :: mutex e POSIX, emulando-os com std :: atomic, transferindo a carga principalmente para a terra do usu√°rio.  Na verdade falhou, mas as primeiras coisas primeiro. </p><br><p>  Em primeiro lugar, tenho v√°rias se√ß√µes nas quais esses experimentos podem ser √∫teis: </p><br><ul><li>  bloqueios no LibreSSL (caso 1); </li><li>  bloqueio ao transferir pacotes recebidos da carga √∫til para aplicativos Lua (caso 2); </li><li>  Aguardando eventos de carga √∫til prontos para serem processados ‚Äã‚Äãpelos aplicativos Lua (caso 3). </li></ul><br><p>  Vamos come√ßar com bloqueios sem bloqueio.  Vamos escrever nosso mutex usando atomics, conforme mostrado em alguns discursos de H. Sutter (portanto, n√£o h√° c√≥digo original da mem√≥ria e, portanto, o c√≥digo n√£o coincide com o 100% original, e no Satter esse c√≥digo estava relacionado ao progresso do C ++ 20, portanto, existem diferen√ßas).  E, apesar da simplicidade desse c√≥digo, existem armadilhas nele. </p><br><pre> <code class="hljs kotlin">#include &lt;atomic&gt; #include &lt;pthread.h&gt; namespace test { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutex</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: std::atomic&lt;pthread_t&gt; mLock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: explicit mutex():mLock{<span class="hljs-number"><span class="hljs-number">0</span></span>} { } mutex(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mutex&amp;)=delete; mutex(mutex&amp;)=delete; void lock() { pthread_t locked_by=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  C++20     , .. compare_exchange_strong          while(!mLock.compare_exchange_strong(locked_by,pthread_self())) { locked_by=0; //      } } void unlock() { pthread_t current=pthread_self(); if(!mLock.compare_exchange_strong(current,0)) { throw std::system_error(EACCES, std::system_category(), "An attempt to unlock the mutex owned by other thread"); } } const bool try_lock() { pthread_t unused=0; return mLock.compare_exchange_strong(unused,pthread_self()); } }; }</span></span></code> </pre> <br><p>  Ao contr√°rio de std :: mutex :: unlock (), o comportamento de test :: mutex: unlock () ao tentar desbloquear de outro encadeamento √© determin√≠stico.  Uma exce√ß√£o ser√° lan√ßada.  Isso √© bom, embora n√£o seja consistente com o comportamento padr√£o.  E o que h√° de ruim nessa classe?  A m√° not√≠cia √© que o m√©todo test :: mutex: lock () consome descaradamente recursos da CPU em cotas de tempo alocadas ao encadeamento, na tentativa de assumir o mutex que outro encadeamento j√° possui.  I.e.  um loop em test :: mutex: lock () ser√° um desperd√≠cio de recursos da CPU.  Quais s√£o as nossas op√ß√µes para superar essa situa√ß√£o? </p><br><p>  Podemos usar sched_yield () (conforme sugerido em um dos coment√°rios no artigo acima).  Isso √© simples?  Primeiramente, para usar o sched_yield (), √© necess√°rio que os encadeamentos de execu√ß√£o usem as pol√≠ticas SCHED_RR, SCHED_FIFO para prioriza√ß√£o no agendador de tarefas.  Caso contr√°rio, chamar sched_yield () seria um desperd√≠cio de recursos da CPU.  Em segundo lugar, uma chamada muito frequente para sched_yield () ainda aumentar√° o consumo da CPU.  Al√©m disso, o uso de pol√≠ticas em tempo real no seu aplicativo, e desde que n√£o haja outros aplicativos em tempo real no sistema, limitar√° a fila do agendador com a pol√≠tica selecionada a apenas seus encadeamentos.  Parece que isso √© bom!  N√£o, n√£o √© bom.  Todo o sistema se tornar√° menos responsivo, porque  ocupado com a tarefa priorit√°ria.  O CFQ estar√° na caneta.  Mas existem outros encadeamentos no aplicativo e, muitas vezes, surge uma situa√ß√£o em que o encadeamento que capturou o mutex √© colocado no final da fila (a cota expirou) e o encadeamento que aguarda o lan√ßamento do mutex bem na frente dele.  Nos meus experimentos (caso 2), esse m√©todo deu os mesmos resultados (3,8% piores) que std :: mutex, mas o sistema √© menos responsivo e o consumo de CPU √© aumentado em 5% a 7%. </p><br><p>  Voc√™ pode tentar alterar test :: mutex :: lock () assim (tamb√©m √© ruim): </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> locked_by=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!mLock.compare_exchange_strong(locked_by,pthread_self())) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">thread_local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pause</span></span></span><span class="hljs-class">{</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// -      nanosleep(&amp;pause,nullptr); locked_by=0; } }</span></span></code> </pre> <br><p>  Aqui voc√™ pode experimentar a dura√ß√£o do sono em nanossegundos, os atrasos de 4ns foram √≥timos para minha CPU e a queda de desempenho em rela√ß√£o ao std :: mutex no mesmo caso 2 foi de 1,2%.  N√£o √© o fato de que o nanosleep dormiu 4ns.  De fato, ou mais (no caso geral) ou menos (se interrompido).  A queda (!) No consumo de CPU foi de 12% a 20%.  I.e.  foi um sonho t√£o saud√°vel. </p><br><p>  O OpenSSL e o LibreSSL t√™m duas fun√ß√µes que configuram retornos de chamada para bloquear ao usar essas bibliotecas em um ambiente multithread.  √â assim: </p><br><pre> <code class="hljs pgsql">//  callback <span class="hljs-type"><span class="hljs-type">void</span></span> openssl_crypt_locking_function_callback(<span class="hljs-type"><span class="hljs-type">int</span></span> mode, <span class="hljs-type"><span class="hljs-type">int</span></span> n, const <span class="hljs-type"><span class="hljs-type">char</span></span>* file, const <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-type"><span class="hljs-type">line</span></span>) { static std::vector&lt;std::mutex&gt; locks(CRYPTO_num_locks()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n&gt;=static_cast&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(locks.size())) { <span class="hljs-keyword"><span class="hljs-keyword">abort</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mode &amp; CRYPTO_LOCK) locks[n].<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> locks[n].unlock(); } //  callback-a CRYPTO_set_locking_callback(openssl_crypt_locking_function_callback); //  id CRYPTO_set_id_callback(pthread_self);</code> </pre> <br><p>  E agora o pior √© que o uso do teste acima :: mutex mutex no LibreSSL reduz o desempenho do LAppS em quase 2 vezes.  Al√©m disso, independentemente da op√ß√£o (loop de espera vazio, sched_yield (), nanosleep ()). </p><br><p>  Em geral, exclu√≠mos o caso 2 e o caso 1 e permanecemos com std :: mutex. </p><br><p>  Vamos para sem√°foros.  Existem muitos exemplos de como implementar sem√°foros usando std :: condition_variable.  Todos eles usam std :: mutex tamb√©m.  E esses simuladores de sem√°foro s√£o mais lentos (de acordo com meus testes) do que os sem√°foros do sistema POSIX. </p><br><p>  Portanto, criaremos um sem√°foro nos √°tomos: </p><br><pre> <code class="hljs java"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">semaphore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: std::atomic&lt;bool&gt; mayRun; mutable std::atomic&lt;int64_t&gt; counter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">explicit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">semaphore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> : mayRun</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>},counter{<span class="hljs-number"><span class="hljs-number">0</span></span>} { } semaphore(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> semaphore&amp;)=delete; semaphore(semaphore&amp;)=delete; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ++counter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mayRun.load(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mayRun.load()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(counter.fetch_sub(<span class="hljs-number"><span class="hljs-number">1</span></span>)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++counter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::system_error(ENOENT,std::system_category(),<span class="hljs-string"><span class="hljs-string">"Semaphore is destroyed"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!try_wait()) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> thread_local <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> struct timespec pause{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}; nanosleep(&amp;pause,nullptr); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mayRun.store(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> int64_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrimentOn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size_t value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mayRun.load()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter.fetch_sub(value); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::system_error(ENOENT,std::system_category(),<span class="hljs-string"><span class="hljs-string">"Semaphore is destroyed"</span></span>); } } ~semaphore() { destroy(); } };</code> </pre> <br><p>  Ah, esse sem√°foro √© muitas vezes mais r√°pido que o sem√°foro do sistema.  O resultado de um teste separado desse sem√°foro com um provedor e 20 consamers: </p><br><pre> <code class="hljs bash">OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Started 20 threads waiting on a semaphore Thread(OS): wakes: 500321 Thread(OS): wakes: 500473 Thread(OS): wakes: 501504 Thread(OS): wakes: 502337 Thread(OS): wakes: 498324 Thread(OS): wakes: 502755 Thread(OS): wakes: 500212 Thread(OS): wakes: 498579 Thread(OS): wakes: 499504 Thread(OS): wakes: 500228 Thread(OS): wakes: 499696 Thread(OS): wakes: 501978 Thread(OS): wakes: 498617 Thread(OS): wakes: 502238 Thread(OS): wakes: 497797 Thread(OS): wakes: 498089 Thread(OS): wakes: 499292 Thread(OS): wakes: 498011 Thread(OS): wakes: 498749 Thread(OS): wakes: 501296 OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. 10000000 of posts <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 20 waiting threads have taken 9924 milliseconds OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Post latency: 0.9924ns ======================================= AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Started 20 threads waiting on a semaphore Thread(EmuAtomic) wakes: 492748 Thread(EmuAtomic) wakes: 546860 Thread(EmuAtomic) wakes: 479375 Thread(EmuAtomic) wakes: 534676 Thread(EmuAtomic) wakes: 501014 Thread(EmuAtomic) wakes: 528220 Thread(EmuAtomic) wakes: 496783 Thread(EmuAtomic) wakes: 467563 Thread(EmuAtomic) wakes: 608086 Thread(EmuAtomic) wakes: 489825 Thread(EmuAtomic) wakes: 479799 Thread(EmuAtomic) wakes: 539634 Thread(EmuAtomic) wakes: 479559 Thread(EmuAtomic) wakes: 495377 Thread(EmuAtomic) wakes: 454759 Thread(EmuAtomic) wakes: 482375 Thread(EmuAtomic) wakes: 512442 Thread(EmuAtomic) wakes: 453303 Thread(EmuAtomic) wakes: 480227 Thread(EmuAtomic) wakes: 477375 AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. 10000000 of posts <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 20 waiting threads have taken 341 milliseconds AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Post latency: 0.0341ns</code> </pre><br><p>  Esse sem√°foro com post quase gratuito (), que √© 29 vezes mais r√°pido que o sistema, tamb√©m √© muito r√°pido ao ativar os threads que o esperam: 29325 despertares por milissegundo, contra 1007 despertadores por milissegundo do sistema.  Possui comportamento determin√≠stico com um sem√°foro destru√≠do ou um sem√°foro destrut√≠vel.  E, naturalmente, segfault ao tentar usar um j√° destru√≠do. </p><br><p>  (¬π) Na verdade, muitas vezes em um milissegundo um fluxo n√£o pode ser atrasado e despertado pelo planejador.  Porque  O post () n√£o est√° bloqueando; nesse teste sint√©tico, o wait () geralmente se encontra em uma situa√ß√£o em que voc√™ n√£o precisa dormir.  Ao mesmo tempo, pelo menos 7 threads em paralelo leem o valor do sem√°foro. </p><br><p>  Mas us√°-lo no caso 3 do LAppS leva a perdas de desempenho, independentemente do tempo de sono.  Ele acorda com muita frequ√™ncia para verificar e os eventos no LAppS chegam muito mais lentamente (lat√™ncia da rede, lat√™ncia do lado do cliente gerando a carga, etc.).  E verificar menos frequentemente significa tamb√©m perder desempenho. </p><br><p>  Al√©m disso, o uso do sono nesses casos e de maneira semelhante √© completamente prejudicial, porque  em outro hardware, os resultados podem ser completamente diferentes (como no caso da pausa nas instru√ß√µes do assembler) e, para cada modelo de CPU, voc√™ tamb√©m precisa selecionar o tempo de atraso. </p><br><p>  A vantagem de um mutex e sem√°foro do sistema √© que o encadeamento de execu√ß√£o n√£o √© ativado at√© que ocorra um evento (desbloqueando o mutex ou incrementando o sem√°foro).  Ciclos extras de CPU n√£o s√£o desperdi√ßados - lucro. </p><br><p>  Em geral, tudo, desde este mal, desabilitar o iptables no meu sistema d√° de 12% (com TLS) a 30% (sem TLS) um ganho de desempenho ... </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428087/">https://habr.com/ru/post/pt428087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428077/index.html">React.js: um guia para iniciantes</a></li>
<li><a href="../pt428079/index.html">Aplicando princ√≠pios do SOLID para reagir ao desenvolvimento de aplicativos</a></li>
<li><a href="../pt428081/index.html">Usando o RxJS no React Development para gerenciar o estado do aplicativo</a></li>
<li><a href="../pt428083/index.html">A an√°lise da Web influencia a matriz - o sistema estrat√©gico da Avinash Koshik</a></li>
<li><a href="../pt428085/index.html">Frontend responde: top 10 (?) HolyJS 2018 Piter relat√≥rios</a></li>
<li><a href="../pt428089/index.html">"Calend√°rio do testador" para outubro. Feedback: como acontece</a></li>
<li><a href="../pt428091/index.html">Como um aluno interno criou o videogame mais popular do mundo ou o hist√≥rico de jogos do Windows</a></li>
<li><a href="../pt428095/index.html">Pesquisa de mercado para est√∫dios da web e ag√™ncias digitais</a></li>
<li><a href="../pt428097/index.html">Roteamento recursivo no MikroTik atrav√©s de gateways atribu√≠dos pelo DHCP</a></li>
<li><a href="../pt428099/index.html">O que os vestidos comuns e a pr√≥xima era 5G t√™m em comum?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>