<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèø üåó üç• Implementaci√≥n de nubes volum√©tricas f√≠sicamente correctas como en Horizon Zero Dawn üë©‚Äçüëß‚Äçüë¶ üëçüèΩ üë®üèΩ‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anteriormente, las nubes en los juegos se dibujaban con sprites 2D normales, que siempre se giran en la direcci√≥n de la c√°mara, pero en los √∫ltimos a√±...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementaci√≥n de nubes volum√©tricas f√≠sicamente correctas como en Horizon Zero Dawn</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459948/">  Anteriormente, las nubes en los juegos se dibujaban con sprites 2D normales, que siempre se giran en la direcci√≥n de la c√°mara, pero en los √∫ltimos a√±os, los nuevos modelos de tarjetas de video le permiten dibujar nubes f√≠sicamente correctas sin p√©rdidas de rendimiento notables.  Se cree que las nubes voluminosas en el juego trajeron al estudio Guerrilla Games junto con el juego Horizon Zero Dawn.  Por supuesto, tales nubes pudieron renderizarse antes, pero el estudio form√≥ algo as√≠ como un est√°ndar de la industria para los recursos fuente y los algoritmos utilizados, y ahora cualquier implementaci√≥n de nubes volum√©tricas de alguna manera cumple con este est√°ndar. <br><br><img src="https://habrastorage.org/webt/v9/uq/em/v9uqemwtz5ty7x5uvpppsoonmdu.png"><br><a name="habracut"></a><br>  Todo el proceso de renderizar nubes est√° muy bien dividido en etapas y es importante tener en cuenta que la implementaci√≥n incorrecta, incluso en una de ellas, puede conducir a tales consecuencias que no estar√° claro d√≥nde est√° el error y c√≥mo solucionarlo, por lo tanto, es aconsejable hacer una conclusi√≥n de control del resultado cada vez. <br><br><h2>  Mapeo de tonos, sRGB </h2><br>  Antes de comenzar a trabajar con iluminaci√≥n, es importante hacer dos cosas: <br><br><ol><li>  Antes de mostrar la imagen final en la pantalla, aplique al menos el mapeo de tonos m√°s simple: <br><br><pre><code class="cpp hljs">tunedColor=color/(<span class="hljs-number"><span class="hljs-number">1</span></span>+color)</code> </pre> <br>  Esto es necesario porque los valores de color calculados ser√°n mucho mayores que la unidad. <br></li><li>  Aseg√∫rese de que el framebuffer final en el que est√° dibujando y que se muestra en la pantalla est√© en formato sRGB.  Si la activaci√≥n del modo sRGB es un problema, la conversi√≥n se puede hacer manualmente en el sombreador: <br><br><pre> <code class="cpp hljs">finalColor=<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(color, vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.2</span></span>))</code> </pre> <br>  La f√≥rmula es adecuada para la mayor√≠a de los casos, pero no 100% seg√∫n el monitor.  Es importante que la conversi√≥n sRGB siempre se haga al final. </li></ol><br><h2>  Modelo de iluminaci√≥n </h2><br>  Considere un espacio lleno de materia parcialmente transparente de diferentes densidades.  Cuando un rayo de luz atraviesa dicha sustancia, est√° expuesto a cuatro efectos: absorci√≥n, dispersi√≥n, dispersi√≥n amplificadora y autoradiaci√≥n.  Esto √∫ltimo ocurre en el caso de procesos qu√≠micos en una sustancia, y no se ve afectado aqu√≠. <br><br>  Supongamos que tenemos un rayo de luz que atraviesa la materia desde el punto A hasta el punto B: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_1/1t/9w/_11t9wizftnmwilerlsi5fvcrm4.png"></div><br>  <b>Absorci√≥n</b> <br><br>  La luz que pasa a trav√©s de una sustancia es absorbida por esta misma sustancia.  La fracci√≥n de luz no absorbida se puede encontrar mediante la f√≥rmula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/34c/ec6/56734cec6154e1fab8bb2d1538a8dffa.svg"></div><br>  donde <img src="https://habrastorage.org/getpro/habr/post_images/a3e/204/11f/a3e20411f145906908c5cd2b53a36dbe.svg">  - la luz que queda en el punto despu√©s de la absorci√≥n <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  - apunte en el segmento AB a distancia <img src="https://habrastorage.org/getpro/habr/post_images/2a3/102/4ea/2a31024ea1803c34a47496e24a53a1ef.svg">  de A. <br><br>  <b>Dispersi√≥n</b> <br><br>  Parte de la luz bajo la influencia de part√≠culas de materia cambia su direcci√≥n.  La fracci√≥n de luz que no ha cambiado su direcci√≥n se puede encontrar mediante la f√≥rmula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04b/c17/2f5/04bc172f53fa572aebf0399275b5009f.svg"></div><br>  donde <img src="https://habrastorage.org/getpro/habr/post_images/5e3/0b7/bad/5e30b7badd64b9da62be750e48573c7d.svg">  - fracci√≥n de luz que no ha cambiado de direcci√≥n despu√©s de dispersarse en un punto <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <br><br>  Absorci√≥n y dispersi√≥n deben combinarse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d7/d5a/f1a/8d7d5af1a0506ee776c4c2f850e862a9.svg"></div><br>  Funci√≥n <img src="https://habrastorage.org/getpro/habr/post_images/33f/297/4e9/33f2974e9c84331f8b92d8b7ed5aca97.svg">  llamado atenuaci√≥n o extinci√≥n.  Una funci√≥n <img src="https://habrastorage.org/getpro/habr/post_images/eea/d4d/0d4/eead4d0d4f08873f9aa49b69a7c46fd8.svg">  - Funci√≥n de transferencia.  Muestra cu√°nta luz queda al pasar del punto A al punto B. <br><br>  En cuanto a <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg">  y <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  : <img src="https://habrastorage.org/getpro/habr/post_images/b76/ea9/fd5/b76ea9fd577eb1c2cee545caa4153bd3.svg">  , donde C es una constante constante, que puede tener un valor diferente para cada canal en RGB, <img src="https://habrastorage.org/getpro/habr/post_images/9ee/494/9d2/9ee4949d2897f56ac90e563db1eb96cd.svg">  Es la densidad del medio en el punto <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <br><br>  Ahora vamos a complicar la tarea.  La luz se mueve del punto A al punto B, se extingue durante el movimiento.  En el punto X, parte de la luz se dispersa en diferentes direcciones, una de las direcciones corresponde al observador en el punto O. A continuaci√≥n, una parte de la luz dispersa se mueve desde el punto X al punto O y se desintegra nuevamente.  El camino de la luz AXO nos interesa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/b_/tr/zob_troftvd8-ggp1ga7wesnrlk.png"></div><br>  La p√©rdida de luz al pasar de A a X sabemos: <img src="https://habrastorage.org/getpro/habr/post_images/25d/8c9/f76/25d8c9f76986f59eb045b801f19d4e0a.svg">  , tal como sabemos la p√©rdida de luz de X a O - esto <img src="https://habrastorage.org/getpro/habr/post_images/25b/3a9/8e3/25b3a98e370f0a95b734794b74bee57a.svg">  .  Pero, ¬øqu√© pasa con la fracci√≥n de luz que se dispersar√° en la direcci√≥n del observador? <br><br>  <b>Dispersi√≥n de amplificaci√≥n</b> <br><br>  Si en el caso de la dispersi√≥n ordinaria, la intensidad de la luz disminuye, entonces, en el caso de la dispersi√≥n amplificadora, aumenta debido a la dispersi√≥n de la luz que ha ocurrido en las regiones vecinas.  La f√≥rmula puede encontrar la cantidad total de luz proveniente de regiones vecinas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e4/be1/bd9/7e4be1bd9a1d8f05b9d1d47e1bb27ecc.svg"></div><br>  donde <img src="https://habrastorage.org/getpro/habr/post_images/e63/878/1e4/e638781e456c920d7864e85c8b14a746.svg">  significa tomar la integral sobre la esfera, <img src="https://habrastorage.org/getpro/habr/post_images/1ad/0bb/23e/1ad0bb23eb22871d78d2b5cc67d58292.svg">  - funci√≥n de fase <img src="https://habrastorage.org/getpro/habr/post_images/da9/7bc/3c5/da97bc3c51ddad728182deecd39ba0d0.svg">  - luz procedente de la direcci√≥n <img src="https://habrastorage.org/getpro/habr/post_images/9c6/a44/e8e/9c6a44e8ed4cb10046e00346c6b58b15.svg">  . <br><br>  Es bastante dif√≠cil calcular la luz desde todas las direcciones, sin embargo, sabemos que la porci√≥n original de luz es transportada por nuestro haz AB original.  La f√≥rmula se puede simplificar enormemente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef8/4aa/222/ef84aa22259c648ea9925502712250f6.svg"></div><br>  donde <img src="https://habrastorage.org/getpro/habr/post_images/2cb/bcb/347/2cbbcb347a44c276c1095ac5bb3f8242.svg">  - el √°ngulo entre el haz de luz y el haz de observaci√≥n (es decir, el √°ngulo AXO), <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  - el valor inicial de la intensidad de la luz.  Resumiendo todo lo anterior, obtenemos la f√≥rmula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/fb7/273/642fb727356c245fc6f053dbc9affde8.svg"></div><br>  donde <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  - luz entrante <img src="https://habrastorage.org/getpro/habr/post_images/f7a/fbd/138/f7afbd138efabfc5bf5dad3e26e6c0fb.svg">  - la luz llega al observador. <br><br>  Complicamos la tarea un poco m√°s.  Digamos que la luz es emitida por una luz direccional, es decir.  el sol <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wz/r2/gg/wzr2ggl_1oshhmhn3kkqalhtkoo.png"></div><br>  Todo sucede igual que en el caso anterior, pero muchas veces.  La luz del punto A1 se dispersa en el punto X1 hacia el observador en el punto O, la luz del punto A2 se dispersa en el punto X2 hacia el observador en el punto O, etc.  Vemos que la luz que llega al observador es igual a la suma: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/838/191/24f/83819124f0beb6bdd5adc3644a79653b.svg"></div><br>  O una expresi√≥n integral m√°s precisa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/7b0/5d2/e017b05d2026f311f43bc53da48c130e.svg"></div><br>  Es importante entender que aqu√≠ <img src="https://habrastorage.org/getpro/habr/post_images/e7b/3af/88e/e7b3af88eb6397d1f88774b011fe4cbb.svg">  es decir  El segmento se divide en un n√∫mero infinito de secciones de longitud cero. <br><br><h2>  El cielo </h2><br>  Con una ligera simplificaci√≥n, un rayo de sol que atraviesa la atm√≥sfera se dispersa, es decir, <img src="https://habrastorage.org/getpro/habr/post_images/c79/ce0/055/c79ce005518e112e707da427d7231066.svg">  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k0/mm/tz/k0mmtzjcir3wnqxbcjzsouln4yo.png"></div><br>  Y ni siquiera un tipo de dispersi√≥n, sino dos: dispersi√≥n de Rayleigh y dispersi√≥n de Mi.  La primera es causada por mol√©culas de aire, y la segunda es causada por un aerosol de agua. <br><br>  La densidad total de aire (o aerosol) a trav√©s de la cual pasa un rayo de luz, que se mueve del punto A al punto B: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bc/d80/e5d/0bcd80e5d5b35e43fef8336e6c66cde0.svg"></div>  donde <img src="https://habrastorage.org/getpro/habr/post_images/14b/01a/bf0/14b01abf043545d56ac10d61e69792e8.svg">  - altura de escala, h - altura actual. <br><br>  Una soluci√≥n integral simple ser√≠a: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3f/b07/e75/d3fb07e750a91c2a253fdcf1de74de72.svg"></div><br>  donde dh es el tama√±o del paso con el que se toma la muestra de altura. <br><br>  Ahora mire la figura y use la f√≥rmula derivada en la parte anterior del "modelo de iluminaci√≥n": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gr/n0/fr/grn0fr0f-dly-jjpcjpg_pxof9a.png"></div><br>  El observador mira de O a O '.  Queremos recolectar toda la luz que llega a los puntos X1, X2, ..., Xn, se dispersa en ellos y luego llega al observador: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/c25/470/540c25470466173df2e5cf7880390ff9.svg"></div><br>  donde <img src="https://habrastorage.org/getpro/habr/post_images/c87/cb3/ca4/c87cb3ca4e0a0f0fc9d1a9d5c485c116.svg">  la intensidad de la luz emitida por el sol <img src="https://habrastorage.org/getpro/habr/post_images/6c3/b25/b5f/6c3b25b5f22b9a03c093ef2f25a06339.svg">  - altura en el punto <img src="https://habrastorage.org/getpro/habr/post_images/ee6/2f8/bed/ee62f8bed8d0d0e9b3d3cd2c81841ded.svg">  ;  en el caso del cielo, constante C, que est√° en funci√≥n <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  denotado como <img src="https://habrastorage.org/getpro/habr/post_images/cea/f36/742/ceaf36742def9a68dbd173a0ac9c9aeb.svg">  . <br><br>  La soluci√≥n de la integral puede ser la siguiente: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5be/44a/9fc/5be44a9fcdb92469fee29b924a957556.svg"></div><br>  Esta f√≥rmula es v√°lida tanto para la dispersi√≥n de Rayleigh como para la dispersi√≥n de Mie.  Como resultado, los valores de luz para cada una de las dispersiones simplemente suman: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34f/cb4/a91/34fcb4a9100e4b9c60a7c7eca2c489ec.svg"></div><br>  <b>Dispersi√≥n de Rayleigh</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71e/a55/e80/71ea55e8043a70776eb70f29eb84d877.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/679/03f/8e9/67903f8e987346a525fb22e02e718aad.svg">  (contiene valores para cada canal RGB) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c9/02f/384/4c902f3848ae3cb24347ee0b367132d6.svg"><br><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/xs/8z/nkxs8zt8hyh909tjilktrkrrvri.png"></div><br>  <b>Mi dispersi√≥n</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72b/94b/cc1/72b94bcc19f99b0e164c6a48e4408b44.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9a/52e/00c/c9a52e00c5e6169a8ad778f902e49595.svg">  (los valores para todos los canales RGB son iguales) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/208/fcf/3bf/208fcf3bf216540af2bfa93a186a3a19.svg"><br><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/jv/sb/fujvsbtduq-il-1reylizx1kosa.png"></div><br>  El n√∫mero de muestras por segmento. <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg">  y en el segmento <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg">  Puedes tomar 32 y m√°s.  El radio de la Tierra es de 6371000 m, la atm√≥sfera es de 100000 m. <br><br>  Qu√© hacer con todo esto: <br><br><ol><li>  En cada p√≠xel de la pantalla, calculamos la direcci√≥n del observador V </li><li>  Tomamos la posici√≥n del observador O igual a {0, 6371000, 0} </li><li>  Nos encontramos <img src="https://habrastorage.org/getpro/habr/post_images/28d/cc9/fe7/28dcc9fe786e9216afc4ab3ae2196ebe.svg">  como resultado de la intersecci√≥n del rayo que se origina en el punto O, y la direcci√≥n de V y la esfera centrada en el punto {0,0,0} y un radio de 6471000 </li><li>  Segmento de l√≠nea <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg">  dividir en 32 secciones de igual longitud </li><li>  Para cada secci√≥n, calculamos la dispersi√≥n de Rayleigh y la dispersi√≥n de Mie, y agregamos todo.  Adem√°s, para calcular <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg">  tambi√©n tendremos que dividir el segmento <img src="https://habrastorage.org/getpro/habr/post_images/0e6/fb0/4e8/0e6fb04e8525f5a3448df984993ab3c4.svg">  32 parcelas iguales en cada caso. <img src="https://habrastorage.org/getpro/habr/post_images/60e/970/a20/60e970a20b30f36e7c21fe71c3d4dadb.svg">  se puede leer a trav√©s de una variable, cuyo valor aumenta en cada paso del ciclo. </li></ol><br>  El resultado final: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/gb/tl/nogbtlqbuzffixmq7xmt1w4j_ja.png"></div><br><h2>  Modelo de nube </h2><br>  Necesitaremos varios tipos de ruido en 3D.  El primero es el ruido de movimiento browniano (fBm) al acecho fractal de Perlin: <br><br>  Resultado para un corte 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ld/h6/v6/ldh6v6zglre4jhon_n8qu193o8k.png"></div><br>  El segundo es el ruido de camuflaje fBm de Voronoi. <br><br>  Resultado para un corte 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aa/rc/s2/aarcs2hvles3h89jqfc1lfrufjk.png"></div><br>  Para obtener el ruido fBm de encubrimiento de Vorley, debe invertir el ruido fBm de encubrimiento de Voronoj.  Sin embargo, cambi√© ligeramente los rangos de valores a mi criterio: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fbmTiledWorley3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clamp((<span class="hljs-number"><span class="hljs-number">1.0</span></span>-fbmTiledVoronoi3(...))*<span class="hljs-number"><span class="hljs-number">1.5</span></span><span class="hljs-number"><span class="hljs-number">-0.25</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  El resultado se parece inmediatamente a las estructuras de nubes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ha/pf/em/hapfemxrqrxuqfpckajp53j4zxc.png"></div><br>  Para las nubes, necesita obtener dos texturas especiales.  El primero tiene un tama√±o de 128x128x128 y es responsable del ruido de baja frecuencia, el segundo tiene un tama√±o de 32x32x32 y es responsable del ruido de alta frecuencia.  Cada textura usa solo un canal en formato R8.  En algunos ejemplos, se usan 4 canales de R8G8B8A8 para la primera textura y tres canales de R8G8B8 para la segunda, y luego los canales se mezclan en un sombreador.  No veo el punto, porque la mezcla se puede hacer de antemano, obteniendo as√≠ un mayor √©xito en la coherencia de cach√©. <br><br>  Para mezclar, y tambi√©n en algunos lugares, se utilizar√° la funci√≥n remap (), que escala los valores de un rango a otro: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMinValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMaxValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newMinValue+(value-minValue)/(maxValue-minValue)*(newMaxValue-newMinValue); }</code> </pre> <br>  Comencemos a preparar la textura con ruido de baja frecuencia: <br>  Canal R - ruido fBm de perlin <br>  Canal G - ruido de Vorley fBm en mosaico <br>  Canal B: ruido de fBm Worley m√°s peque√±o con escala m√°s peque√±a <br>  Canal A: ruido fBm taylable de Varley con una escala a√∫n m√°s peque√±a <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/_9/z-/ms_9z-hofvyvya5-zuh6vpi6da0.png"></div><br>  La mezcla se realiza de esta manera: <br><br><pre> <code class="cpp hljs">finalValue=remap(noise.x, (noise.y * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.z*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.w * <span class="hljs-number"><span class="hljs-number">0.125</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Resultado para un corte 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/64/qh/rl/64qhrl3wl2vrsbedao4fk9zr3xg.png"></div><br>  Ahora prepare la textura con ruido de alta frecuencia: <br>  Canal R - ruido de vorley fBm en mosaico <br>  Canal G: ruido Vorley fBm a menor escala <br>  Canal B - Varley taylivaya fBm ruido con escala a√∫n m√°s peque√±a <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/m6/in/oxm6inosejxwrkx2kdz7zv17eea.png"></div><br><pre> <code class="cpp hljs">finalValue=noise.x * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.y*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.z * <span class="hljs-number"><span class="hljs-number">0.125</span></span>;</code> </pre> <br>  Resultado para un corte 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lg/mr/mc/lgmrmc2ohi3ayicwbji49fdhqb4.png"></div><br>  Tambi√©n necesitamos un mapa de clima y texturas 2D que determinar√° la presencia, densidad y forma de las nubes, dependiendo de las coordenadas del espacio.  Est√° pintado por artistas para afinar la cubierta de nubes.  La interpretaci√≥n de los canales de color del mapa meteorol√≥gico puede ser diferente, en la versi√≥n que prest√©, es la siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/oi/m8/fuoim8wbtdzgqoc2lma8g6gb0ow.png"></div><br>  Canal R - nubosidad a baja altitud <br>  Canal G - nubosidad a gran altitud <br>  Canal B - altura m√°xima de la nube <br>  Canal A - densidad de nubes <br><br>  Ahora estamos listos para crear una funci√≥n que devolver√° la densidad de las nubes dependiendo de las coordenadas del espacio 3D. <br><br>  En la entrada, un punto en el espacio con coordenadas en km. <br><br><pre> <code class="cpp hljs">vec3 position</code> </pre> <br>  Agregue inmediatamente el desplazamiento al viento <br><br><pre> <code class="cpp hljs">position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time;</code> </pre> <br>  Obtenga los valores del mapa meteorol√≥gico <br><br><pre> <code class="cpp hljs">vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre>  Obtenemos el porcentaje de altura (de 0 a 1) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position);</code> </pre> <br>  Agregue un peque√±o redondeo de las nubes a continuaci√≥n: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Hacemos una disminuci√≥n lineal de la densidad a 0 con el aumento de la altura de acuerdo con el canal B del mapa meteorol√≥gico: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Combina el resultado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt;</code> </pre> <br>  Nuevamente agregue el redondeo de las nubes a continuaci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Agregue tambi√©n el redondeo de las nubes en la parte superior: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Combinamos el resultado, aqu√≠ agregamos la influencia de la densidad del mapa del tiempo y la influencia de la densidad, que se establece a trav√©s de la interfaz gr√°fica de usuario: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density;</code> </pre> <br>  Combina el ruido de baja frecuencia y alta frecuencia de nuestras texturas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>;</code> </pre> <br>  En todos los documentos que le√≠, la fusi√≥n se lleva a cabo de una manera diferente, pero me gust√≥ esta opci√≥n. <br><br>  Determinamos la cantidad de cobertura (% del cielo ocupado por las nubes), que se establece a trav√©s de la interfaz gr√°fica de usuario, tambi√©n se utilizan los canales R y G del mapa meteorol√≥gico: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Calcule la densidad final: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA;</code> </pre> <br>  Funci√≥n completa: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position)</span></span></span><span class="hljs-function"> </span></span>{ position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time; vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>+vec2(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d; }</code> </pre> <br>  Cu√°l es exactamente esta funci√≥n deber√≠a ser una pregunta abierta, porque ignorar las leyes que las nubes obedecen al establecer par√°metros, puede obtener un resultado muy inusual y hermoso.  Todo depende de la aplicaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/nz/bz/tfnzbzvd2oucw2h_oed9pbm_8ku.png"></div><br><h2>  Integraci√≥n </h2><br>  La atm√≥sfera de la Tierra se divide en dos capas: interna y externa, entre las cuales se pueden ubicar las nubes.  Estas capas se pueden representar por esferas, pero tambi√©n por planos.  Me instal√© en las esferas.  Para la primera capa, tom√© el radio de la esfera de 6415 km, para la segunda capa, el radio de 6435 km.  El radio de la tierra redonde√≥ a 6400 km.  Algunos par√°metros depender√°n del grosor condicional de la parte "nublada" de la atm√≥sfera (20 km). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0z/ir/8r/0zir8r9qtvwlh9xk85i-hznhqa0.png"></div><br><br>  A diferencia del cielo, las nubes son opacas, y la integraci√≥n requiere no solo obtener el color, sino tambi√©n obtener el valor para el canal alfa.  Primero necesita una funci√≥n que devuelva la densidad total de la nube a trav√©s de la cual pasar√° un rayo de luz del sol. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5k/ne/lj/5kneljw4unaofsxxgbq12ealebw.png"></div><br>  Nadie llama la atenci√≥n sobre esto, pero la pr√°ctica ha demostrado que no es necesario tener en cuenta toda la trayectoria del haz, solo se necesita la brecha m√°s extrema.  Suponemos que las nubes sobre un segmento truncado no existen en absoluto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/sr/ly/edsrlyis3-2or1nztj6q-osmats.png"></div><br>  Adem√°s, estamos muy limitados en cuanto al n√∫mero de muestras de densidad que se pueden hacer sin afectar el rendimiento.  Guerrilla Games do 6. Adem√°s, en una de las presentaciones, el desarrollador dijo que esparcen estas muestras dentro del cono, y la √∫ltima muestra se hace especialmente muy lejos del resto para cubrir la mayor cantidad de espacio posible.  Las imprecisiones y el ruido resultantes se suavizar√°n en el contexto de las muestras vecinas, y esto, por el contrario, se convertir√° en una mayor precisi√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/rr/df/5prrdfocofvzsjobvawnairijp0.png"></div><br>  Al final, me decid√≠ por 4 muestras que se encuentran en la misma l√≠nea, pero esta √∫ltima se toma con un aumento de 6 veces.  El tama√±o del escal√≥n es de 20 km * 0.01, que es de 200 m. <br><br>  La funci√≥n es bastante simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDirectDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   float avrStep=(6435.0-6415.0)*0.01; float sumDensity=0.0; for(int i=0;i&lt;4;i++) { float step=avrStep; //      6 if(i==3) step=step*6.0; //  position+=sunDir*step; //  ,  ,   //  float density=cloudSampleDensity(position)*step; sumDensity+=density; } return sumDensity; }</span></span></code> </pre> <br>  Ahora puedes pasar a la parte m√°s dif√≠cil.  Determinamos el observador en la superficie de la Tierra en el punto {0, 6400,0} y encontramos la intersecci√≥n del haz de observaci√≥n con una esfera de radio 6415 km y centro {0,0,0} - obtenemos el punto de partida S. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/25/je/zj/25jezjeea4j3bl51jneypfjetsi.png"></div><br>  A continuaci√≥n se muestra la versi√≥n b√°sica de la funci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { position+=viewDir*step; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); }</code> </pre> <br>  El tama√±o del paso se define como 20 km / 64.  en el caso de la direcci√≥n estrictamente vertical del haz del observador, haremos 64 muestras.  Sin embargo, cuando esta direcci√≥n es m√°s horizontal, las muestras ser√°n un poco m√°s grandes, por lo que no hay 64 pasos en el ciclo, sino 128 con un margen. <br><br>  Al principio, asumimos que el color final es negro y la transparencia es la unidad.  Con cada paso, aumentaremos el valor del color y disminuiremos el valor de la transparencia.  Si la transparencia est√° cerca de 0, puede salir previamente del bucle: <br><br><pre> <code class="cpp hljs">vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//    //      float density=cloudSampleDensity(position)*avrStep; //   ,   //   float sunDensity=cloudSampleDirectDensity(position, sunDir); //      float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*m2*m3; //       color+=sunColor*light*transmittance; transmittance*=exp(-ufmProperties.attenuation*density); ‚Ä¶ return vec4(color, 1.0-transmittance);</span></span></code> </pre> <br>  ufmProperties.attenuation: no hay nada m√°s que C en <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg">  y ufmProperties.attenuation2 es C en <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  .  ufmProperties.sunIntensity: la intensidad de radiaci√≥n del sol.  sunColor: el color del sol. <br><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/ft/z9/vcftz9vsswkxpqoggirezpfpygm.png"></div><br>  Un defecto es inmediatamente evidente: sombreado severo.  Pero ahora corregiremos la falta de iluminaci√≥n amplificada cerca del sol.  Sucedi√≥ porque no agregamos una funci√≥n de fase.  Para calcular la dispersi√≥n de la luz que pasa a trav√©s de las nubes, se utiliza la funci√≥n de fase de Hengy-Greenstein, que la abri√≥ en 1941 para c√°lculos similares en grupos de gases en el espacio: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b0/b2e/33f/4b0b2e33fbd07036b14317d40cb1eac0.svg"></div><br>  Una digresi√≥n debe hacerse aqu√≠.  Seg√∫n el modelo de iluminaci√≥n can√≥nica, la funci√≥n de fase debe ser una.  Sin embargo, en realidad, el resultado obtenido no se adapta a nadie y todos usan funciones de dos fases, e incluso combinan sus valores de una manera especial.  Tambi√©n me concentr√© en funciones de dos fases, pero simplemente sumo sus valores.  La funci√≥n de la primera fase tiene g cerca de 1 y le permite hacer una iluminaci√≥n brillante cerca del sol.  La funci√≥n de la segunda fase tiene g cerca de 0.5 y le permite hacer una disminuci√≥n gradual de la iluminaci√≥n en toda la esfera celeste. <br><br>  C√≥digo actualizado: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// cos(theta) float mu=max(0, dot(viewDir, sunDir)); float m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); float m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*(m11+m12)*m2*m3;</span></span></code> </pre> <br>  ufmProperties.eccentrisy, ufmProperties.eccentrisy2 son valores g <br><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ip/qr/fi/ipqrfivyafyxnmdswnn_nbpvfdk.png"></div><br>  Ahora puedes comenzar la pelea con demasiado sombreado.  Est√° presente porque no tomamos en cuenta la luz de las nubes circundantes y el cielo, que es en la vida real. <br><br>  Resolv√≠ este problema as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(color+ambientColor*ufmProperties.ambient, <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br>  Donde ambientColor es el color del cielo en la direcci√≥n del haz de observaci√≥n, ufmProperties.ambient es el par√°metro de ajuste. <br><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/8h/ji/ct8hjiyk7brz5pv8vuwjeji33bc.png"></div><br>  Queda por resolver el √∫ltimo problema.  En la vida real, cuanto m√°s horizontal es la vista, m√°s vemos cierta niebla o neblina que no nos permite ver objetos muy distantes.  Esto tambi√©n debe reflejarse en el c√≥digo.  Tom√© el coseno habitual del √°ngulo de la mirada y la funci√≥n exponencial.  En base a esto, se calcula un cierto coeficiente de mezcla, que permite la interpolaci√≥n lineal entre el color resultante y el color de fondo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br>  ufmProperties.fog: para la configuraci√≥n manual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/02/td/9h/02td9ho6kelgum68wldvcf-zymu.png"></div><br>  Funci√≥n de resumen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir, vec3 sunColor, vec3 ambientColor)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> density=cloudSampleDensity(position)*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(density&gt;<span class="hljs-number"><span class="hljs-number">0.0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sunDensity=cloudSampleDirectDensity(position, sunDir); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mu=max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, sunDir)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m2=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*sunDensity); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m3=ufmProperties.attenuation2*density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> light=ufmProperties.sunIntensity*(m11+m12)*m2*m3; color+=sunColor*light*transmittance; transmittance*=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*density); } position+=viewDir*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(transmittance&lt;<span class="hljs-number"><span class="hljs-number">0.05</span></span> || length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance); }</code> </pre> <br>  Video de demostraci√≥n: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uPxVgbwThmI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Optimizaci√≥n y posibles mejoras. </h2><br>  Despu√©s de implementar el algoritmo de renderizado b√°sico, el siguiente problema es que funciona muy lentamente.  Mi versi√≥n produjo 25 fps en full hd en la radeon rx 480. Los dos siguientes enfoques para resolver el problema fueron sugeridos por los mismos Guerrilla Games. <br><br>  <b>Dibujamos lo que es realmente visible.</b> <br><br>  La pantalla est√° dividida en mosaicos de 16x16 p√≠xeles de tama√±o.  Primero, se dibuja el entorno 3D habitual.  Resulta que la mayor parte del cielo est√° cubierto por monta√±as u objetos grandes.  En consecuencia, debe realizar el c√°lculo solo en aquellos mosaicos en los que las nubes no est√°n bloqueadas por nada. <br><br>  <b>Reproyecci√≥n</b> <br><br>  Cuando la c√°mara est√° parada, resulta que las nubes en general no se pueden actualizar.  Sin embargo, si la c√°mara se ha movido, esto no significa que debamos actualizar toda la pantalla.  Todo ya est√° dibujado, solo necesita reconstruir la imagen de acuerdo con las nuevas coordenadas.  Encontrar las coordenadas antiguas en las nuevas, a trav√©s de la proyecci√≥n y ver las matrices de los cuadros actuales y anteriores, se llama proyecci√≥n.  Por lo tanto, en el caso de un cambio de c√°mara, simplemente transferimos los colores de acuerdo con las nuevas coordenadas.  En los casos en que estas coordenadas indican fuera de la pantalla, las nubes deben volver a dibujarse honestamente. <br><br>  <b>Actualizaci√≥n parcial</b> <br><br>  No me gusta la idea de la reproyecci√≥n porque con un giro brusco de la c√°mara puede resultar que las nubes tendr√°n que representarse para un tercio de la pantalla, lo que puede causar retraso.  No s√© c√≥mo Guerrilla Games lidi√≥ con esto, pero al menos en Horizon Zero Dawn, cuando se controla el joystick, la c√°mara se mueve suavemente y no hay problemas con saltos bruscos.  Por lo tanto, como experimento, se me ocurri√≥ mi propio enfoque.  Las nubes se dibujan en un mapa c√∫bico, en 5 caras, porque  el fondo no nos interesa.  El lado del mapa c√∫bico tiene una resoluci√≥n reducida igual a ‚Öî de la altura de la pantalla.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada cara del mapa c√∫bico se divide en 8x8 fichas. Cada cuadro en cada cara se actualiza con solo uno de 64 p√≠xeles en cada mosaico. Esto produce artefactos notables durante los cambios repentinos, pero porque las nubes son bastante est√°ticas, entonces ese truco es invisible. Como resultado, la radeon rx 480 produce 500 fps en full hd para el volc√°n y 330 fps para opengl. La serie Radeon hd 5700 produce 109 fps en full hd bajo opengl (vulkan no es compatible). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uso de niveles de mip</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al acceder a texturas con ruido, puede tomar datos del nivel de mip cero solo en las primeras muestras, y luego, cuanto m√°s lejos est√©n las muestras, mayor ser√° el nivel de mip. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nubes altas</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para simular la presencia de altitud de cirrus y nubes de cirroc√∫mulos en Guerrilla Games durante la integraci√≥n, las √∫ltimas muestras no est√°n hechas de las texturas 3D de las que habl√©, sino de una textura 2D especial. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/f2/vj/udf2vjpfht0hhpbf9zptwfmadhg.jpeg"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruido</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de rizo Se utilizan varias texturas adicionales en el ruido de rizo para crear el efecto del viento que sopla las nubes. </font><font style="vertical-align: inherit;">Estas texturas son necesarias para cambiar las coordenadas originales.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-n/qq/pg/-nqqpgmixyogyjxqrdyhm4oxlpc.png"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rayos divinos</font></font></b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qd/wq/xv/qdwqxvzveiwuxgu2v84aw5fhjwo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dichos rayos, que atrapan dramas, se realizan en el posprocesamiento. </font><font style="vertical-align: inherit;">Primero, se dibuja una iluminaci√≥n brillante alrededor del sol, donde no est√° bloqueada por las nubes. </font><font style="vertical-align: inherit;">Entonces esta luz de fondo debe estar radialmente desviada del sol.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/vj/-a/apvj-assr02-vaov3o1k5frfawk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora necesita aplicar suavizado radial. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/lg/1h/jdlg1hp7jajzhlbom4ocmn3vl70.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, hay muchas m√°s mejoras y sutilezas, pero no las verifiqu√© todas, por lo que no puedo decir con confianza sobre ellas. Sin embargo, puedes familiarizarte con ellos t√∫ mismo. La m√°s fuerte, creo, es la documentaci√≥n en la nube del motor Frostbite.</font></font><br><br><h2>  Enlaces utiles </h2><br> <b> Guerrilla Games</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">d1z4o56rleaq4j.cloudfront.net/downloads/assets/Nubis-Authoring-Realtime-Volumetric-Cloudscapes-with-the-Decima-Engine-Final.pdf?mtime=20170807141817</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">killzone.dl.playstation.net/killzone/horizonzerodawn/presentations/Siggraph15_Schneider_Real-Time_Volumetric_Cloudscapes_of_Horizon_Zero_Dawn.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.youtube.com/watch?v=-d8qT5-1LOI</a> <br><br> <b>  GPU Pro 7</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vk.com/doc179245989_437393482?hash=a9af5f665eda4edf58&amp;dl=806d4dbdac0f7a761c</a> <br><br> <b></b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky</a> <br><br> <b> Frostbite</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.shadertoy.com/view/XlBSRz</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459948/">https://habr.com/ru/post/459948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459924/index.html">Ciclo completo de prueba de reacci√≥n. Auto.ru Report</a></li>
<li><a href="../459928/index.html">El camino del estudiante hacia el desarrollo de aplicaciones m√≥viles</a></li>
<li><a href="../459930/index.html">Automatizaci√≥n de importaci√≥n de Python</a></li>
<li><a href="../459934/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 306 (del 8 al 14 de julio)</a></li>
<li><a href="../459936/index.html">9 trucos m√°s para trabajar con Visual Studio</a></li>
<li><a href="../459952/index.html">Una peque√±a experiencia sobre copia de seguridad y almacenamiento</a></li>
<li><a href="../459954/index.html">¬øPor qu√© una de las compa√±√≠as de TI m√°s grandes se uni√≥ a CNCF?</a></li>
<li><a href="../459956/index.html">Implantaci√≥n en ausencia total de dientes, como resultado de visitas prematuras al dentista.</a></li>
<li><a href="../459958/index.html">An√°lisis de tareas de la conferencia Hydra: equilibrio de carga y almacenamiento en memoria</a></li>
<li><a href="../459960/index.html">Desde la idea hasta el lanzamiento. Experiencia detallada en el mercado frontend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>