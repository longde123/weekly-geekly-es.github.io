<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶à ü¶â üë∏üèº Centr√°ndose en la propiedad üë° üèÇüèΩ üñºÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota traductor: el registro est√° fechado el 13 de mayo de 2014, por lo que algunos detalles, incluido el c√≥digo fuente, pueden no corresponder al esta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Centr√°ndose en la propiedad</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418735/"><p>  <em>Nota</em>  <em>traductor: el registro est√° fechado el 13 de mayo de 2014, por lo que algunos detalles, incluido el c√≥digo fuente, pueden no corresponder al estado actual de las cosas.</em>  <em>La respuesta a la pregunta de por qu√© se necesita la traducci√≥n de una publicaci√≥n tan antigua ser√° el valor de su contenido para comprender uno de los conceptos fundamentales del lenguaje Rust, como la fluidez.</em> </p><br><p>  Con el tiempo, me convenc√≠ de que ser√≠a mejor abandonar la distinci√≥n entre variables locales mutables e inmutables en Rust.  Al menos muchas personas son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esc√©pticas</a> sobre este tema.  Quer√≠a expresar mi posici√≥n en p√∫blico.  Voy a dar varios motivos: filos√≥ficos, t√©cnicos y pr√°cticos, as√≠ como a la defensa principal del sistema actual.  (Nota: vi esto como Rust RFC, pero decid√≠ que el tono es mejor para una publicaci√≥n de blog y no tengo tiempo para reescribirlo ahora). </p><a name="habracut"></a><br><h2 id="poyasnenie">  Explicaci√≥n </h2><br><p>  Escrib√≠ este art√≠culo con bastante decisi√≥n y creo que la l√≠nea que defiendo ser√° correcta.  Sin embargo, si no terminamos de admitir el sistema actual, esto no ser√° un desastre o algo as√≠.  Tiene sus ventajas, y en general me parece bastante agradable.  Solo creo que podemos mejorarlo. </p><br><h2 id="odnim-slovom">  En una palabra </h2><br><p> Me gustar√≠a eliminar la distinci√≥n entre variables locales inmutables y mutables y cambiar el nombre de los <code>&amp;mut</code> pointers a <code>&amp;my</code> , <code>&amp;only</code> o <code>&amp;uniq</code> (no me importa).  Si solo no hubiera una palabra clave <code>mut</code> . </p><br><h2 id="filosofskiy-motiv">  Motivo filos√≥fico </h2><br><p>  La raz√≥n principal por la que quiero hacer esto es porque creo que esto har√° que el lenguaje sea m√°s consistente y f√°cil de entender.  Esencialmente, esto nos reorientar√° de hablar de <em>mutabilidad</em> a hablar de <em>usar alias</em> (lo que llamar√© "compartir", ver m√°s abajo). </p><br><p>  La variabilidad se convierte en una consecuencia de la unicidad: "Siempre puede cambiar todo a lo que tenga acceso exclusivo. Los datos compartidos generalmente son inmutables, pero si lo necesita, puede cambiarlos utilizando alg√∫n tipo de tipo de <code>Cell</code> ". </p><br><p>  En otras palabras, con el tiempo, me qued√≥ claro que surgen problemas con las carreras de datos y la seguridad de la memoria cuando se usan alias y mutabilidad.  Un enfoque funcional para resolver este problema es eliminar la mutabilidad.  El enfoque de Rust ser√≠a eliminar el uso de alias.  Esto nos da una historia que se puede contar y que nos ayudar√° a resolverlo. </p><br><p>  Una nota sobre terminolog√≠a: creo que deber√≠amos referirnos al <em>uso de alias</em> como <em>separaci√≥n</em> ( <em>nota del traductor: en adelante, en todas partes en lugar de "aliasing" se usa "compartir" en el significado de "separaci√≥n" o "propiedad compartida", ya que tampoco "uso de alias", ni "seudonimizaci√≥n" da una idea de lo que est√° en juego</em> ).  En el pasado, evitamos esto debido a sus referencias multiproceso.  Sin embargo, si implementamos los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">planes de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paralelizaci√≥n de datos</a> que propuse, esta connotaci√≥n no es del todo inapropiada.  De hecho, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dada la estrecha relaci√≥n</a> entre la seguridad de la memoria y la carrera de datos, realmente quiero promover esta connotaci√≥n. </p><br><h2 id="obrazovatelnyy-motiv">  Motivo educativo </h2><br><p>  Creo que las reglas actuales son m√°s dif√≠ciles de entender de lo que deber√≠an ser.  No es obvio, por ejemplo, que <code>&amp;mut T</code> no implica ninguna propiedad compartida.  Adem√°s, la designaci√≥n <code>&amp;mut T</code> implica que <code>&amp;T</code> no implica ninguna mutabilidad, lo que no es del todo exacto, debido a tipos como <code>Cell</code> .  Y es imposible acordar c√≥mo llamarlos (los "enlaces mutables / inmutables" son los m√°s comunes, pero esto no es del todo correcto). </p><br><p>  En contraste, un tipo como <code>&amp;my T</code> o <code>&amp;only T</code> parece simplificar la explicaci√≥n.  Este es un <em>enlace √∫nico</em> : naturalmente, no puede forzar a dos de ellos a se√±alar al mismo lugar.  Y la <em>mutabilidad</em> es algo ortogonal: proviene de la singularidad, pero tambi√©n es v√°lido para las c√©lulas.  Y el tipo <code>&amp;T</code> es justo lo contrario, un <em>enlace compartido</em> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC PR # 58</a> proporciona una serie de argumentos similares.  No los repetir√© aqu√≠. </p><br><h2 id="prakticheskiy-motiv">  Motivo pr√°ctico </h2><br><p>  Actualmente, existe una brecha entre los punteros prestados, que pueden ser compartidos o mutables + √∫nicos, y las variables locales que siempre son √∫nicas, pero pueden ser mutables o inmutables.  El resultado final de esto es que los usuarios deben publicar anuncios <code>mut</code> sobre cosas que no son directamente editables. </p><br><h3 id="lokalnye-peremennye-ne-mogut-byt-smodelirovany-s-ispolzovaniem-ssylok">  Las variables locales no se pueden modelar utilizando referencias </h3><br><p>  Este fen√≥meno ocurre porque los enlaces no son tan expresivos como las variables locales.  En general, esto impide la abstracci√≥n.  D√©jame darte algunos ejemplos para explicar lo que quiero decir.  Imagine que tengo una estructura de entorno que almacena un puntero a un contador de errores: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span></span> { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Ahora puedo crear instancias de esta estructura (y usarlas): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  OK, ahora imagina que quiero separar el c√≥digo que modifica <code>env.errors</code> en una funci√≥n separada.  Podr√≠a pensar que, dado que la variable <code>env</code> no se declara como mutable, puedo usar el enlace inmutable <code>&amp;</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;env); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helper</span></span></span></span>(env: &amp;Env) { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  } }</span></span></code> </pre> <br><p>  Pero esto no es as√≠.  El problema es que <code>&amp;Env</code> es un tipo de propiedad compartida ( <em>nota del traductor: como usted sabe, puede existir m√°s de una referencia de objeto inmutable a la vez</em> ) y, por <code>env.errors</code> tanto, <code>env.errors</code> aparece en un espacio que permite que el objeto <code>env</code> se <code>env.errors</code> separado.  Para que este c√≥digo funcione, tengo que declarar <code>env</code> como mutable y usar el enlace <code>&amp;mut</code> ( <em>nota del traductor: <code>&amp;mut</code> ) para decirle al compilador que <code>env</code> es √∫nico en su propiedad, ya que solo puede existir una referencia de objeto mutable a la vez y se excluye la carrera de datos, pero <code>mut</code> porque no puedes crear una referencia mutable a un objeto inmutable</em> ): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env);</code> </pre> <br><p>  Este problema surge porque sabemos que las variables locales son √∫nicas, pero no podemos poner este conocimiento en una referencia prestada sin hacerlo mutable. </p><br><p>  Este problema ocurre en varios otros lugares.  Hasta ahora hemos escrito sobre esto de diferentes maneras, pero sigo obsesionado por la sensaci√≥n de que estamos hablando de un descanso, que simplemente no deber√≠a ser. </p><br><h3 id="proverka-tipov-primenitelno-k-zamykaniyam">  Verificaci√≥n de tipo de cierres </h3><br><p>  Tuvimos que sortear esta limitaci√≥n en el caso de los cierres.  Los cierres <em>est√°n</em> abiertos en <em>su mayor√≠a</em> en estructuras como <code>Env</code> , pero no del todo.  Esto se debe a que no quiero exigir que las variables locales se declaren <code>mut</code> si se usan a trav√©s de <code>&amp;mut</code> en un cierre.  En otras palabras, tome un c√≥digo, por ejemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { do_something(|| *errors += <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><p>  Una expresi√≥n que describe el cierre en realidad crear√° una instancia de la estructura <code>Env</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClosureEnv</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt; { errors: &amp;uniq &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Mira el enlace <code>&amp;uniq</code> .  Esto no es algo que el usuario final pueda ingresar.  Significa un puntero "√∫nico pero no necesariamente mutable".  Esto es necesario para pasar la verificaci√≥n de tipo.  Si el usuario intentara escribir esta estructura manualmente, tendr√≠a que escribir <code>&amp;mut &amp;mut usize</code> , lo que a su vez requerir√≠a que el par√°metro de <code>errors</code> se declare como <code>mut errors: &amp;mut usize</code> . </p><br><h3 id="nezapakovannye-zamykaniya-i-procedury">  Cierres y procedimientos desempaquetados </h3><br><p>  Predigo que esta restricci√≥n es un problema para los cierres desempaquetados.  Perm√≠tanme detallar el dise√±o que estaba considerando.  B√°sicamente, la idea era que la expresi√≥n <code>||</code>  es equivalente a alg√∫n nuevo tipo estructural que implementa uno de los rasgos <code>Fn</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fn</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnMut</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnOnce</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); }</code> </pre> <br><p>  El tipo exacto se seleccionar√° de acuerdo con el tipo esperado, a partir de hoy.  En este caso, los consumidores de cierres pueden escribir una de dos cosas: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;&gt;(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: T) { ... }</code> </pre> <br><p>  Nosotros ... probablemente queremos arreglar la sintaxis, quiz√°s agregar az√∫car como <code>FnMut(usize) -&gt; usize</code> , o guardar | usize |  -&gt; usize, etc.  No es tan importante, es importante que pasemos el cierre <em>por valor</em> .  Tenga en cuenta que de acuerdo con las reglas actuales de DST (Tipos de tama√±o din√°mico) est√° permitido pasar un tipo por valor como argumento al <code>FnMut&lt;usize, usize&gt;</code> , por lo tanto, el argumento <code>FnMut&lt;usize, usize&gt;</code> es un DST v√°lido y no es un problema. </p><br><p>  <em>Aparte</em> : este proyecto no est√° completo, y describir√© todos los detalles en un mensaje separado. </p><br><p>  El problema es que se requiere un enlace <code>&amp;mut</code> para llamar a un cierre.  Dado que el cierre se pasa por valor, los usuarios nuevamente tendr√°n que escribir <code>mut</code> donde parece fuera de lugar: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  Este es el mismo problema que en el ejemplo <code>Env</code> anterior: lo que <em>realmente</em> sucede aqu√≠ es que el <code>FnMut</code> solo quiere un enlace <em>√∫nico</em> , pero como no es parte del sistema de tipos, solicita un enlace <em>mutable</em> . </p><br><p>  Ahora quiz√°s podamos solucionar esto de diferentes maneras.  Una opci√≥n que podr√≠amos hacer es <code>||</code>  la sintaxis no se expandir√≠a a un "cierto tipo estructural", sino m√°s bien a un "tipo estructural o un puntero a un tipo estructural, seg√∫n lo dictado por la inferencia de tipos".  En este caso, la persona que llama podr√≠a escribir: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  No quiero decir que este es el fin del mundo.  Pero este es otro paso adelante en las crecientes distorsiones que debemos atravesar para mantener esta brecha entre las variables locales y las referencias. </p><br><h3 id="drugie-chasti-api">  Otras partes API </h3><br><p>  No hice un estudio exhaustivo, pero, por supuesto, esta diferencia se extiende a otra parte.  Por ejemplo, para leer desde <code>Socket</code> , necesito un puntero √∫nico, por lo que tengo que declararlo mutable.  Por lo tanto, a veces esto no funciona: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> socket = Socket::new(); socket.read() <span class="hljs-comment"><span class="hljs-comment">// :   </span></span></code> </pre> <br><p>  Naturalmente, seg√∫n mi sugerencia, ese c√≥digo funcionar√≠a bien.  Seguir√≠a recibiendo un mensaje de error si intentara leer <code>&amp;Socket</code> , pero luego leer√≠a algo como "es imposible crear un enlace √∫nico a un enlace compartido", lo que personalmente considero m√°s comprensible. </p><br><h2 id="no-razve-nam-ne-nuzhen-mut-dlya-bezopasnosti">  ¬øPero no necesitamos <code>mut</code> por seguridad? </h2><br><p>  No, para nada  Los programas Rust ser√≠an igualmente buenos si declarara todos los enlaces como <code>mut</code> .  El compilador es perfectamente capaz de rastrear qu√© variables locales est√°n cambiando en un momento dado, precisamente porque son <em>locales</em> para la funci√≥n actual.  Lo que realmente le importa al sistema de tipos es la singularidad. </p><br><p>  El significado que veo en las reglas actuales de aplicaci√≥n de <code>mut</code> , y no negar√© que tiene valor, es principalmente que ayudan a declarar la intenci√≥n.  Es decir, cuando leo el c√≥digo, s√© qu√© variables se pueden reasignar.  Por otro lado, tambi√©n paso mucho tiempo leyendo c√≥digo C ++ y, francamente, nunca me he dado cuenta de que este es un gran obst√°culo.  (Lo mismo ocurre con el tiempo que pas√© leyendo c√≥digo en Java, JavaScript, Python o Ruby). </p><br><p>  Tambi√©n es cierto que a veces encuentro errores porque declar√≥ la variable como <code>mut</code> y olvid√© cambiarla.  Creo que podr√≠amos obtener beneficios similares con otras comprobaciones m√°s agresivas (por ejemplo, ninguna de las variables utilizadas en la condici√≥n del bucle cambia en el cuerpo del bucle).  Personalmente, no recuerdo haber enfrentado la situaci√≥n opuesta: es decir, si el compilador dice que algo debe ser mutable, b√°sicamente significa que olvid√© la palabra clave <code>mut</code> alguna parte.  (Piense: ¬øcu√°ndo fue la √∫ltima vez que respondi√≥ a un error del compilador sobre un cambio no v√°lido haciendo algo m√°s que reestructurar el c√≥digo para que el cambio sea v√°lido?) </p><br><h2 id="alternativy">  Alternativas </h2><br><p>  Veo tres alternativas al sistema actual: </p><br><ol><li>  La que present√© en la que simplemente descartas la "mutabilidad" y solo rastreas la singularidad. </li><li>  Uno donde tiene tres tipos de referencia: <code>&amp;</code> , <code>&amp;uniq</code> y <code>&amp;mut</code> .  (Como escrib√≠, este es realmente el sistema de tipos que tenemos hoy, al menos desde el punto de vista de un verificador de pr√©stamos). </li><li><p>  Una opci√≥n m√°s rigurosa, en la que las variables que no son mut siempre se consideran separadas.  Esto significar√≠a que tendr√≠a que escribir: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> p = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors; <span class="hljs-comment"><span class="hljs-comment">// ,  `p`   ,  `mut`. *p += 1;</span></span></code> </pre> <br><p>  <code>mut</code> declarar <code>p</code> como <code>mut</code> , porque de lo contrario la variable se considerar√≠a separada, aunque sea una variable local y, por lo tanto, no se permite cambiar <code>*p</code> .  Lo que es extra√±o en este esquema es que la variable local NO permite una propiedad separada, y lo sabemos con certeza, porque cuando intentas crear su alias, se mover√°, el destructor comenzar√° en √©l, etc.  Es decir, todav√≠a tenemos el concepto de "propiedad", que es diferente de "no permite la propiedad separada". </p><br><p>  Por otro lado, si describimos este sistema, diciendo que la mutabilidad se hereda a trav√©s de punteros <code>&amp;mut</code> , sin siquiera tartamudear sobre la propiedad compartida, esto podr√≠a tener sentido. </p><br></li></ol><br><p>  De estos tres, definitivamente prefiero el n√∫mero 1.  Es el m√°s simple, y ahora estoy m√°s interesado en c√≥mo podemos simplificar Rust preservando su car√°cter.  De lo contrario, doy preferencia a la que tenemos ahora. </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  B√°sicamente, encuentro que las reglas actuales con respecto a la mutabilidad tienen alg√∫n valor, pero son caras.  Son una especie de abstracci√≥n fluida: es decir, cuentan una historia simple, que de hecho resulta ser incompleta.  Esto lleva a confusi√≥n cuando las personas pasan de una comprensi√≥n inicial, en la cual <code>&amp;mut</code> refleja c√≥mo funciona la mutabilidad, a una comprensi√≥n completa: a veces <code>mut</code> solo <code>mut</code> necesario para garantizar la unicidad, y a veces la mutabilidad se logra sin la palabra clave <code>mut</code> . </p><br><p>  Adem√°s, debemos actuar con precauci√≥n para mantener la ficci√≥n, que denota mutabilidad, no singularidad.  Hemos agregado casos especiales para que el prestatario verifique los cierres.  Debemos hacer que las reglas sobre mutabilidad <code>&amp;mut</code> m√°s complejas en general.  Debemos agregar <code>mut</code> a los cierres para poder llamarlos, o hacer que la sintaxis de los cierres se abra de una manera menos obvia.  Y as√≠ sucesivamente. </p><br><p>  Al final, todo se convierte en un lenguaje m√°s complejo en su conjunto.  En lugar de solo pensar en la propiedad compartida y la singularidad, el usuario debe pensar en la propiedad compartida y la mutabilidad, y ambos est√°n de alguna manera en mal estado. </p><br><p>  No creo que valga la pena. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418735/">https://habr.com/ru/post/es418735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418723/index.html">Parche AndroidX</a></li>
<li><a href="../es418725/index.html">Constante de magia</a></li>
<li><a href="../es418727/index.html">D√≥nde y c√≥mo entrar en incrustaciones de gr√°ficos</a></li>
<li><a href="../es418729/index.html">Todo lo que siempre has pedido en una versi√≥n: CLion 2018.2</a></li>
<li><a href="../es418733/index.html">Visualizando los comentarios de los canales de YouTube de las comunidades touhou internacionales y locales</a></li>
<li><a href="../es418737/index.html">Ablaci√≥n l√°ser, vidrio telurito y dopante Er2O3</a></li>
<li><a href="../es418739/index.html">Centro de tecnolog√≠a aditiva: impresoras 3D industriales Sistemas 3D, Stratasys, SLM, EOS</a></li>
<li><a href="../es418741/index.html">Agregue cifrado y empuje a SIP normal</a></li>
<li><a href="../es418743/index.html">Historia del primer lugar en ML Boot Camp VI</a></li>
<li><a href="../es418747/index.html">Resoluci√≥n de problemas: ¬øc√≥mo resolver eficazmente los problemas en un equipo?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>