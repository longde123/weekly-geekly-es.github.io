<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñ§ üåö üòÆ Livre "{You Don't Know JS} Types et constructions grammaticales" ‚òπÔ∏è üí™üèº ‚õ∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quelle que soit votre exp√©rience de programmation JavaScript, vous ne comprenez probablement pas parfaitement le langage. Ce guide concis explore les ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Livre "{You Don't Know JS} Types et constructions grammaticales"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/456730/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/un/r1/ll/unr1llifhhvkguhuc2sq4tll6ly.jpeg" align="left" alt="image"></a>  Quelle que soit votre exp√©rience de programmation JavaScript, vous ne comprenez probablement pas parfaitement le langage.  Ce guide concis explore les types plus en profondeur que tous les livres existants: vous apprendrez comment les types fonctionnent, les probl√®mes de leur conversion et apprendrez √† utiliser les nouvelles fonctionnalit√©s. <br><br>  Comme d'autres livres de la s√©rie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´You Don't Know JS¬ª</a> , il montre des aspects non triviaux du langage que les programmeurs JavaScript pr√©f√®rent √©viter (ou supposent qu'ils n'existent pas).  Arm√© de ces connaissances, vous obtiendrez une v√©ritable ma√Ætrise de JavaScript. <br><a name="habracut"></a><br><h3>  Extrait.  L'√©galit√© est stricte et non stricte. </h3><br>  L'√©galit√© non stricte est v√©rifi√©e par l'op√©rateur ==, et l'√©galit√© stricte par l'op√©rateur ===.  Les deux op√©rateurs sont utilis√©s pour comparer deux valeurs pour ¬´√©galit√©¬ª, mais le choix de la forme (stricte / non stricte) conduit √† des diff√©rences de comportement tr√®s importantes, notamment dans la fa√ßon dont la d√©cision est prise sur l'√©galit√©. <br><br>  Il existe une id√©e fausse commune concernant ces deux op√©rateurs: "== v√©rifie l'√©galit√© de valeur et === v√©rifie l'√©galit√© des valeurs et des types."  Cela semble raisonnable <br>  mais inexact.  D'innombrables livres et blogs JavaScript r√©put√©s le disent, mais malheureusement, ils ont tous tort. <br><br>  La description correcte est: "== autorise la conversion de type lors de la v√©rification de l'√©galit√© et === interdit la conversion de type." <br><br><h3>  Performance de v√©rification de l'√©galit√© </h3><br>  Arr√™tez-vous et r√©fl√©chissez √† la fa√ßon dont la premi√®re explication (inexacte) diff√®re de la seconde (exacte). <br>  Dans la premi√®re explication, il semble √©vident que l'op√©rateur === fait plus de travail que == car il doit √©galement v√©rifier le type. <br><br>  Dans la deuxi√®me explication, l'op√©rateur == fait plus de travail, car avec diff√©rents types, il doit passer par la conversion de type. <br><br>  Ne tombez pas dans le pi√®ge dans lequel beaucoup tombent.  Ne pensez pas que cela affectera en quelque sorte la vitesse du programme, et == sera beaucoup plus lent ===.  Bien que la conversion prenne un certain temps, elle prend quelques microsecondes (oui, des millioni√®mes de seconde). <br><br>  Si vous comparez deux valeurs du m√™me type, == et === utilisent le m√™me algorithme, donc si vous ne tenez pas compte des petites diff√©rences dans l'impl√©mentation du moteur, ils doivent en effectuer un <br>  et le m√™me travail. <br><br>  Si vous comparez deux valeurs de types diff√©rents, les performances ne sont pas un facteur important.  Vous devez vous demander autre chose: si je compare deux valeurs, est-ce que je veux que la conversion de type se produise ou non? <br><br>  Si vous avez besoin d'une conversion, utilisez l'√©galit√© non stricte ==, et si la conversion n'est pas souhaitable, utilisez l'√©galit√© stricte ===. <br><br><blockquote>  Les deux op√©rateurs, == et ===, v√©rifient les types de leurs op√©randes.  La diff√©rence est de savoir comment ils r√©agissent √† la non-correspondance de type. </blockquote><br><h3>  V√©rification de l'√©galit√© abstraite </h3><br>  Le comportement de l'op√©rateur == est d√©fini √† la section 11.9.3 de la sp√©cification ES5 (¬´algorithme de contr√¥le d'√©galit√© abstrait¬ª).  Voici un algorithme d√©taill√© mais simple, avec une liste explicite de toutes les combinaisons possibles de types et de m√©thodes de conversion de type (si n√©cessaire) qui devraient √™tre appliqu√©es dans chaque combinaison. <br><br><blockquote> Lorsque quelqu'un condamne la conversion de type (implicite) comme √©tant trop complexe et contenant trop de d√©fauts pour une utilisation pratique utile, il condamne les r√®gles du "contr√¥le d'√©galit√© abstrait".  On dit g√©n√©ralement que ce m√©canisme est trop compliqu√© et artificiel pour une √©tude et une utilisation pratiques, et qu'il cr√©e des erreurs dans les programmes JS plut√¥t que de simplifier la lecture du code. <br><br>  Je crois que c'est une hypoth√®se erron√©e - vous, lecteurs, √™tes des d√©veloppeurs comp√©tents qui √©crivent des algorithmes, c'est-√†-dire du code (et aussi le lisent et le comprennent), toute la journ√©e.  Pour cette raison, je vais essayer d'expliquer le "test d'√©galit√© abstraite" en termes simples.  Cependant, je recommande √©galement de lire la section 11.9.3 de la sp√©cification ES5.  Je pense que cela vous surprendra √† quel point tout est logique. </blockquote><br>  En fait, la premi√®re section (11.9.3.1) indique que si deux valeurs compar√©es sont du m√™me type, elles sont compar√©es de mani√®re simple et naturelle.  Par exemple, 42 n'est que 42 et la cha√Æne ¬´abc¬ª n'est que ¬´abc¬ª. <br><br>  Quelques exceptions mineures √† garder √† l'esprit: <br><br><ul><li>  La valeur de NaN n'est jamais √©gale √† elle-m√™me (voir chapitre 2). </li><li>  +0 et -0 sont √©gaux (voir chapitre 2). </li></ul><br>  La derni√®re section de la section 11.9.3.1 est consacr√©e √† un test rigoureux de == √©galit√© avec les objets (y compris les fonctions et les tableaux).  Deux de ces valeurs ne sont √©gales <i>que</i> si les deux se r√©f√®rent exactement √† la <i>m√™me valeur</i> .  Aucune conversion de type n'est effectu√©e. <br><br><blockquote>  Un contr√¥le d'√©galit√© stricte === est d√©fini de mani√®re identique √† 11.9.3.1, y compris la disposition pour deux valeurs d'objet.  Ce fait est tr√®s peu connu, mais == et === se comportent de mani√®re totalement identique lors de la comparaison de deux objets! </blockquote><br>  Le reste de l'algorithme en 11.9.3 indique que l'√©galit√© non stricte == peut √™tre utilis√©e pour comparer deux types de valeurs diff√©rents, l'un ou les deux n√©cessiteront <br>  conversion implicite.  √Ä la suite de la conversion, les d√©signations sont converties en un seul type, apr√®s quoi elles peuvent √™tre directement compar√©es pour l'√©galit√© par une identit√© simple <br>  valeurs. <br><br><blockquote>  Le fonctionnement d'une faible v√©rification de l'in√©galit√©! = Est d√©termin√© exactement comme on pourrait s'y attendre;  en fait, l'op√©ration == est enti√®rement mise en ≈ìuvre, suivie d'un calcul <br>  d√©ni de r√©sultat.  Il en va de m√™me pour l'op√©ration de v√©rification stricte de l'in√©galit√©! ==. </blockquote><br><h3>  Comparaison: cha√Ænes et nombres </h3><br>  Pour illustrer la conversion de ==, cr√©ez d'abord des exemples de cha√Ænes et de nombres, ce qui a √©t√© fait plus t√¥t dans ce chapitre: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; a === b; <span class="hljs-comment"><span class="hljs-comment">// false a == b; // true</span></span></code> </pre> <br>  Comme pr√©vu, la v√©rification a === b √©choue car la conversion n'est pas autoris√©e et les valeurs 42 et "42" sont diff√©rentes. <br><br>  Cependant, dans la deuxi√®me comparaison a == b, l'√©galit√© non stricte est utilis√©e;  cela signifie que si les types sont diff√©rents, l'algorithme de comparaison effectuera une conversion implicite d'un <br>  ou les deux. <br><br>  Mais quel type de conversion est effectu√© ici?  La valeur a, c'est-√†-dire 42, deviendra-t-elle une cha√Æne ou la valeur b "42" deviendra-t-elle un nombre?  La sp√©cification ES5 dans les sections 11.9.3.4‚Äì5 dit: <br><br><ol><li>  Si Type (x) est de type Number et Type (y) est de type String, retournez le r√©sultat de la comparaison x == ToNumber (y). </li><li>  Si Type (x) est de type String et Type (y) est de type Number, retourne le r√©sultat de la comparaison ToNumber (x) == y. </li></ol><br><blockquote>  Dans la sp√©cification, les noms formels des types Number et String sont utilis√©s, tandis que dans le livre pour les types primitifs, le num√©ro de notation et la cha√Æne sont g√©n√©ralement utilis√©s.  Ne confondez pas la casse du symbole num√©rique dans la sp√©cification avec la fonction int√©gr√©e Number ().  Pour nos besoins, la casse des caract√®res au nom du type ne joue pas de r√¥le - ils signifient la m√™me chose. </blockquote><br>  La sp√©cification indique que la valeur "42" est convertie en un nombre pour comparaison.  √Ä propos de la fa√ßon dont la conversion est effectu√©e, elle a d√©j√† √©t√© d√©crite pr√©c√©demment, et en particulier lors de la description de l'op√©ration abstraite ToNumber.  Dans ce cas, c'est assez √©vident <br>  que les deux valeurs r√©sultantes de 42 sont √©gales. <br><br><h3>  Comparaison: n'importe quoi avec des bool√©ens </h3><br>  L'un des pi√®ges les plus dangereux dans la conversion implicite de type == est rencontr√© lors de la tentative de comparaison directe des valeurs avec vrai ou faux. <br><br>  Un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; a == b; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Attendez, que se passe-t-il ici?  Nous savons que ¬´42¬ª est le vrai sens (voir plus haut dans ce chapitre).  Comment se r√©v√®le-t-il que la comparaison avec vrai avec la d√©claration d'√©galit√© stricte == <br>  ne donne pas vrai? <br><br>  La raison est simple et trompeuse √† la fois.  Il est facile de se m√©prendre, de nombreux d√©veloppeurs JS ne font pas l'effort de le comprendre pleinement. <br><br>  Encore une fois, nous citons la sp√©cification, sections 11.9.3.6‚Äì7: <br><br><ol><li>  Si Type (x) est de type bool√©en, retournez le r√©sultat de la comparaison ToNumber (x) == y. </li><li>  Si Type (y) est de type bool√©en, retournez le r√©sultat de la comparaison x == ToNumber (y). </li></ol><br>  Voyons voir ce qui est ici.  Premi√®re √©tape: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; x == y; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Le type (x) appartient vraiment au type bool√©en, donc l'op√©ration ToNumber (x) est effectu√©e, ce qui convertit true en 1. La condition 1 == ¬´42¬ª est maintenant calcul√©e.  Les types sont toujours diff√©rents, donc (presque r√©cursivement) l'algorithme se r√©p√®te;  comme dans le cas pr√©c√©dent, "42" est converti en 42, et la condition 1 == 42 est √©videmment fausse. <br><br>  Si vous √©changez des op√©randes, le r√©sultat restera le m√™me: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; x == y; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Cette fois, Type (y) est de type bool√©en, donc ToNumber (y) donne 0. La condition "42" == 0 devient r√©cursivement 42 == 0, ce qui, bien s√ªr, est faux. <br><br>  En d'autres termes, la valeur "42" n'est ni == vraie ni == fausse.  √Ä premi√®re vue, cette affirmation semble totalement impensable.  Comment le sens ne peut-il √™tre ni vrai ni faux? <br><br>  Mais c'est √ßa le probl√®me!  Vous posez la mauvaise question.  Bien que ce ne soit pas de votre faute, c'est le cerveau qui vous trompe. <br><br>  La valeur "42" est en effet vraie, mais la construction "42" == true n'effectue pas du tout un test bool√©en / transform, quoi qu'en dise votre cerveau.  "42" ne se convertit pas en bool√©en (vrai);  au lieu de cela, true est converti en 1, puis ¬´42¬ª est converti en 42. <br><br>  Que cela vous plaise ou non, ToBoolean n'est pas utilis√© du tout ici, donc la v√©rit√© ou le mensonge de ¬´42¬ª n'est pas du tout important pour l'op√©ration ==!  Il est important de comprendre comment l'algorithme de comparaison == se comporte dans toutes les diff√©rentes combinaisons de types.  Si la valeur bool√©enne est d'un c√¥t√©, elle est toujours d'abord convertie en nombre. <br><br>  Si cela vous semble √©trange, vous n'√™tes pas seul.  Personnellement, je recommande de ne jamais, jamais, en aucun cas, utiliser == true ou == false.  Jamais. <br><br>  Mais rappelez-vous que je ne parle que de == ici.  Les constructions === true et === false ne permettent pas la conversion de type, elles sont donc prot√©g√©es de la conversion ToNumber cach√©e. <br><br>  Un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  (  !): if (a == true) { // .. } //   (  !): if (a === true) { // .. } //   ( ): if (a) { // .. } //  ( ): if (!!a) { // .. } //   ( ): if (Boolean( a )) { // .. }</span></span></code> </pre> <br>  Si vous √©vitez == true ou == false (√©galit√© l√¢che avec bool√©en) dans votre code, vous n'aurez jamais √† vous soucier de ce pi√®ge v√©rit√© / fausset√©. <br><br><h3>  Comparaison: null avec undefined </h3><br>  Un autre exemple de conversion implicite se produit lorsque vous utilisez l'√©galit√© lax == entre les valeurs nulles et non d√©finies.  Encore une fois, je citerai la sp√©cification ES5, <br>  sections 11.9.3.2-3: <br><br><ol><li>  Si x contient null et y contient undefined, retournez true. </li><li>  Si x contient undefined et y contient null, retourne true. </li></ol><br>  Null et ind√©fini par rapport √† l'op√©rateur non strict == sont √©gaux les uns aux autres (c'est-√†-dire qu'ils sont convertis les uns aux autres), et aucune autre valeur dans la langue enti√®re. <br><br>  Pour nous, cela signifie que null et undefined peuvent √™tre consid√©r√©s comme indiscernables √† des fins de comparaison si vous utilisez l'op√©rateur de test d'√©galit√© non strict ==, qui permet leur conversion implicite mutuelle: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b; a == b; <span class="hljs-comment"><span class="hljs-comment">// true a == null; // true b == null; // true a == false; // false b == false; // false a == ""; // false b == ""; // false a == 0; // false b == 0; // false</span></span></code> </pre> <br>  La conversion entre null et undefined est s√ªre et pr√©visible, et aucune autre valeur ne peut donner de faux positifs pour une telle v√©rification.  Je recommande d'utiliser cette conversion pour que null et undefined ne diff√®rent pas dans le programme et soient interpr√©t√©s comme une valeur unique. <br><br>  Un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. }</span></span></code> </pre> <br>  La v√©rification a == null r√©ussit uniquement si doSomething () renvoie null ou undefined et √©choue pour toute autre valeur (y compris 0, false et ""). <br><br>  La forme explicite de cette v√©rification, qui interdit de telles conversions de type, semble (√† mon avis) beaucoup plus laide et peut fonctionner un peu moins efficacement! <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> || a === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. }</span></span></code> </pre> <br>  Je crois que la forme a == null est un autre exemple d'une situation dans laquelle une conversion implicite facilite la lecture du code, mais le fait de mani√®re fiable et s√ªre. <br><br><h3>  Comparaison: objets et non-objets </h3><br>  Si un objet / une fonction / un tableau est compar√© √† une simple primitive scalaire (cha√Æne, nombre ou bool√©en), la sp√©cification ES5 indique ce qui suit (section 11.9.3.8‚Äì9): <br><br><ol><li>  Si Type (x) est de type String ou Number et Type (y) est de type Object, retournez le r√©sultat de la comparaison x == ToPrimitive (y). </li><li>  Si Type (x) est de type Object et Type (y) est de type String ou Number, retournez le r√©sultat de la comparaison ToPrimitive (x) == y. </li></ol><br><blockquote>  Vous avez peut-√™tre remarqu√© que dans ces sections de la sp√©cification, seuls String et Number sont mentionn√©s, mais pas bool√©ens.  Le fait est que, comme mentionn√© ci-dessus, les sections 11.9.3.6 √† 7 garantissent que tout op√©rande bool√©en est d'abord repr√©sent√© par Number. </blockquote><br>  Un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = [ <span class="hljs-number"><span class="hljs-number">42</span></span> ]; a == b; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Pour la valeur [42], l'op√©ration abstraite ToPrimitive est appel√©e (voir "Op√©rations abstraites"), ce qui donne le r√©sultat "42".  A partir de ce moment, la condition simple "42" == 42 reste, qui, comme nous l'avons d√©j√† d√©couvert, se transforme en 42 == 42, de sorte que a et b sont √©gaux jusqu'√† la conversion de type. <br><br><blockquote>  Comme vous vous en doutez, toutes les fonctionnalit√©s de l'op√©ration ToPrimitive abstraite discut√©es plus haut dans ce chapitre ((toString (), valueOf ()) sont √©galement applicables dans ce cas. Cela peut √™tre tr√®s utile si vous avez une structure de donn√©es complexe et que vous souhaitez lui d√©finir une m√©thode sp√©cialis√©e valueOf (), qui devra fournir une valeur simple aux fins de v√©rification de l'√©galit√©. </blockquote><br>  Le chapitre 3 a examin√© le ¬´d√©ballage¬ª d'un wrapper d'objet autour d'une valeur primitive (comme dans la nouvelle cha√Æne (¬´abc¬ª), par exemple), entra√Ænant le retour de la primitive sous-jacente <br>  valeur ("abc").  Ce comportement est li√© √† la transformation ToPrimitive dans l'algorithme ==: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>( a ); <span class="hljs-comment"><span class="hljs-comment">//  ,  `new String( a )` a === b; // false a == b; // true</span></span></code> </pre> <br>  a == b donne la valeur true car b est converti (ou ¬´d√©compress√©¬ª) par l'op√©ration ToPrimitive en la valeur primitive scalaire simple de base ¬´abc¬ª, qui correspond √† la valeur de a. <br><br>  Il existe certaines valeurs pour lesquelles ce n'est pas le cas en raison d'autres r√®gles de substitution dans l'algorithme ==.  Un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>( a ); <span class="hljs-comment"><span class="hljs-comment">//  ,  `Object()` a == b; // false var c = undefined; var d = Object( c ); //  ,  `Object()` c == d; // false var e = NaN; var f = Object( e ); //  ,  `new Number( e )` e == f; // false</span></span></code> </pre> <br>  Les valeurs nulles et non d√©finies ne peuvent pas √™tre compress√©es (elles n'ont pas de wrapper d'objet √©quivalent), donc Object (null) n'est pas fondamentalement diff√©rent d'Object (): les deux appels cr√©ent l'habituel <br>  aucun objet. <br><br>  NaN peut √™tre empaquet√© dans l'encapsuleur d'objet Number √©quivalent, mais lorsque == provoque le d√©compactage, la comparaison NaN == NaN √©choue car la valeur NaN n'est jamais √©gale √† elle-m√™me (voir chapitre 2). <br><br>  ¬ªPlus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'√©diteur</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <br><br>  25% de r√©duction sur les colporteurs - <b>JavaScript</b> <br><br>  Lors du paiement de la version papier du livre, un livre √©lectronique est envoy√© par e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456730/">https://habr.com/ru/post/fr456730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456712/index.html">Journalisation s√©lective du trafic pour les services SOAP</a></li>
<li><a href="../fr456714/index.html">Comprendre les nombres √† virgule flottante (partie 0)</a></li>
<li><a href="../fr456716/index.html">Pas de tr√®s gros volumes de donn√©es</a></li>
<li><a href="../fr456722/index.html">Recettes PostgreSQL: Planificateur de t√¢ches asynchrones</a></li>
<li><a href="../fr456724/index.html">5 fa√ßons extr√™mement simples d'acc√©l√©rer consid√©rablement votre application VueJS</a></li>
<li><a href="../fr456732/index.html">√ätre mentor</a></li>
<li><a href="../fr456736/index.html">Recettes PostgreSQL: cURL: get, post and ... email</a></li>
<li><a href="../fr456738/index.html">R√©seaux de neurones et apprentissage profond, chapitre 1: utiliser les r√©seaux de neurones pour reconna√Ætre les nombres manuscrits</a></li>
<li><a href="../fr456740/index.html">Immersion dans les r√©seaux de neurones convolutifs. Partie 5/1 - 9</a></li>
<li><a href="../fr456744/index.html">10 probl√®mes que j'ai r√©solus avec des rappels sur mon smartphone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>