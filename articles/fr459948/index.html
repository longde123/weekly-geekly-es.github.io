<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äç‚öïÔ∏è üÖ∞Ô∏è üßó Impl√©mentation de nuages ‚Äã‚Äãvolum√©triques physiquement corrects comme dans Horizon Zero Dawn üíÉüèº ü§ó üë©‚Äçüë©‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auparavant, les nuages ‚Äã‚Äãdans les jeux √©taient dessin√©s avec des sprites 2D ordinaires, qui sont toujours tourn√©s dans le sens de la cam√©ra, mais ces ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Impl√©mentation de nuages ‚Äã‚Äãvolum√©triques physiquement corrects comme dans Horizon Zero Dawn</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459948/">  Auparavant, les nuages ‚Äã‚Äãdans les jeux √©taient dessin√©s avec des sprites 2D ordinaires, qui sont toujours tourn√©s dans le sens de la cam√©ra, mais ces derni√®res ann√©es, de nouveaux mod√®les de cartes vid√©o vous permettent de dessiner des nuages ‚Äã‚Äãphysiquement corrects sans pertes de performances notables.  On pense que des nuages ‚Äã‚Äãvolumineux dans le jeu ont amen√© le studio Guerrilla Games avec le jeu Horizon Zero Dawn.  Bien s√ªr, de tels nuages ‚Äã‚Äãpouvaient √™tre rendus auparavant, mais le studio a form√© quelque chose comme une norme industrielle pour les ressources sources et les algorithmes utilis√©s, et maintenant toute impl√©mentation de nuages ‚Äã‚Äãvolum√©triques est en quelque sorte conforme √† cette norme. <br><br><img src="https://habrastorage.org/webt/v9/uq/em/v9uqemwtz5ty7x5uvpppsoonmdu.png"><br><a name="habracut"></a><br>  L'ensemble du processus de rendu des nuages ‚Äã‚Äãest tr√®s bien divis√© en √©tapes et il est important de noter qu'une mise en ≈ìuvre inexacte, m√™me sur l'une d'entre elles, peut entra√Æner de telles cons√©quences qu'il ne sera pas clair o√π se trouve l'erreur et comment la corriger, il est donc conseill√© de faire une conclusion de contr√¥le du r√©sultat √† chaque fois. <br><br><h2>  Cartographie des tons, sRGB </h2><br>  Avant de commencer √† travailler avec l'√©clairage, il est important de faire deux choses: <br><br><ol><li>  Avant d'afficher l'image finale √† l'√©cran, appliquez au moins le mappage de tons le plus simple: <br><br><pre><code class="cpp hljs">tunedColor=color/(<span class="hljs-number"><span class="hljs-number">1</span></span>+color)</code> </pre> <br>  Cela est n√©cessaire car les valeurs de couleur calcul√©es seront beaucoup plus grandes que l'unit√©. <br></li><li>  Assurez-vous que le tampon d'image final dans lequel vous dessinez et affich√© √† l'√©cran est au format sRGB.  Si l'activation du mode sRGB pose probl√®me, la conversion peut √™tre effectu√©e manuellement dans le shader: <br><br><pre> <code class="cpp hljs">finalColor=<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(color, vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.2</span></span>))</code> </pre> <br>  La formule convient √† la plupart des cas, mais pas √† 100% selon le moniteur.  Il est important que la conversion sRGB soit toujours effectu√©e en dernier. </li></ol><br><h2>  Mod√®le d'√©clairage </h2><br>  Consid√©rons un espace rempli de mati√®re partiellement transparente de diff√©rentes densit√©s.  Lorsqu'un rayon de lumi√®re traverse une telle substance, il est expos√© √† quatre effets: absorption, diffusion, diffusion amplificatrice et auto-rayonnement.  Ce dernier se produit dans le cas de processus chimiques dans une substance et n'est pas affect√© ici. <br><br>  Supposons que nous ayons un rayon de lumi√®re qui traverse la mati√®re d'un point A √† un point B: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_1/1t/9w/_11t9wizftnmwilerlsi5fvcrm4.png"></div><br>  <b>L'absorption</b> <br><br>  La lumi√®re traversant une substance est absorb√©e par cette m√™me substance.  La fraction de lumi√®re non absorb√©e peut √™tre trouv√©e par la formule: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/34c/ec6/56734cec6154e1fab8bb2d1538a8dffa.svg"></div><br>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/a3e/204/11f/a3e20411f145906908c5cd2b53a36dbe.svg">  - la lumi√®re restant au point apr√®s absorption <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  - pointez sur le segment AB √† distance <img src="https://habrastorage.org/getpro/habr/post_images/2a3/102/4ea/2a31024ea1803c34a47496e24a53a1ef.svg">  de A. <br><br>  <b>Diffusion</b> <br><br>  Une partie de la lumi√®re sous l'influence de particules de mati√®re change de direction.  La fraction de lumi√®re qui n'a pas chang√© de direction peut √™tre trouv√©e par la formule: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04b/c17/2f5/04bc172f53fa572aebf0399275b5009f.svg"></div><br>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/5e3/0b7/bad/5e30b7badd64b9da62be750e48573c7d.svg">  - fraction de lumi√®re qui n'a pas chang√© de direction apr√®s diffusion en un point <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <br><br>  L'absorption et la dispersion doivent √™tre combin√©es: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d7/d5a/f1a/8d7d5af1a0506ee776c4c2f850e862a9.svg"></div><br>  Fonction <img src="https://habrastorage.org/getpro/habr/post_images/33f/297/4e9/33f2974e9c84331f8b92d8b7ed5aca97.svg">  appel√© att√©nuation ou extinction.  Une fonction <img src="https://habrastorage.org/getpro/habr/post_images/eea/d4d/0d4/eead4d0d4f08873f9aa49b69a7c46fd8.svg">  - fonction de transfert.  Il montre combien de lumi√®re reste lors du passage du point A au point B. <br><br>  En ce qui concerne <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg">  et <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  : <img src="https://habrastorage.org/getpro/habr/post_images/b76/ea9/fd5/b76ea9fd577eb1c2cee545caa4153bd3.svg">  , o√π C est une certaine constante, qui peut avoir une valeur diff√©rente pour chaque canal en RVB, <img src="https://habrastorage.org/getpro/habr/post_images/9ee/494/9d2/9ee4949d2897f56ac90e563db1eb96cd.svg">  Est la densit√© du milieu au point <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <br><br>  Maintenant, compliquons la t√¢che.  La lumi√®re se d√©place du point A au point B, elle s'√©teint pendant le mouvement.  Au point X, une partie de la lumi√®re est diffus√©e dans diff√©rentes directions, une des directions correspond √† l'observateur au point O. Ensuite, une partie de la lumi√®re diffus√©e se d√©place du point X au point O et s'humidifie √† nouveau.  Le chemin de la lumi√®re AXO nous int√©resse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/b_/tr/zob_troftvd8-ggp1ga7wesnrlk.png"></div><br>  La perte de lumi√®re lors du passage de A √† X, nous savons: <img src="https://habrastorage.org/getpro/habr/post_images/25d/8c9/f76/25d8c9f76986f59eb045b801f19d4e0a.svg">  , tout comme nous savons la perte de lumi√®re de X √† O - ce <img src="https://habrastorage.org/getpro/habr/post_images/25b/3a9/8e3/25b3a98e370f0a95b734794b74bee57a.svg">  .  Mais qu'en est-il de la fraction de lumi√®re qui sera diffus√©e en direction de l'observateur? <br><br>  <b>Dispersion d'amplification</b> <br><br>  Si dans le cas d'une diffusion ordinaire, l'intensit√© lumineuse diminue, alors dans le cas d'une diffusion amplificatrice, elle augmente du fait de la diffusion de la lumi√®re qui s'est produite dans les r√©gions voisines.  La quantit√© totale de lumi√®re provenant des r√©gions voisines peut √™tre trouv√©e par la formule: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e4/be1/bd9/7e4be1bd9a1d8f05b9d1d47e1bb27ecc.svg"></div><br>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/e63/878/1e4/e638781e456c920d7864e85c8b14a746.svg">  signifie prendre l'int√©grale sur la sph√®re, <img src="https://habrastorage.org/getpro/habr/post_images/1ad/0bb/23e/1ad0bb23eb22871d78d2b5cc67d58292.svg">  - fonction de phase <img src="https://habrastorage.org/getpro/habr/post_images/da9/7bc/3c5/da97bc3c51ddad728182deecd39ba0d0.svg">  - lumi√®re venant de la direction <img src="https://habrastorage.org/getpro/habr/post_images/9c6/a44/e8e/9c6a44e8ed4cb10046e00346c6b58b15.svg">  . <br><br>  Il est assez difficile de calculer la lumi√®re de toutes les directions, cependant, nous savons que la partie originale de la lumi√®re est transport√©e par notre faisceau AB d'origine.  La formule peut √™tre grandement simplifi√©e: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef8/4aa/222/ef84aa22259c648ea9925502712250f6.svg"></div><br>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/2cb/bcb/347/2cbbcb347a44c276c1095ac5bb3f8242.svg">  - l'angle entre le faisceau lumineux et le faisceau d'observation (c'est-√†-dire l'angle AXO), <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  - la valeur initiale de l'intensit√© lumineuse.  En r√©sumant tout ce qui pr√©c√®de, nous obtenons la formule: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/fb7/273/642fb727356c245fc6f053dbc9affde8.svg"></div><br>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  - lumi√®re entrante <img src="https://habrastorage.org/getpro/habr/post_images/f7a/fbd/138/f7afbd138efabfc5bf5dad3e26e6c0fb.svg">  - la lumi√®re atteignant l'observateur. <br><br>  Nous compliquons un peu plus la t√¢che.  Disons que la lumi√®re est √©mise par une lumi√®re directionnelle, c'est-√†-dire  le soleil: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wz/r2/gg/wzr2ggl_1oshhmhn3kkqalhtkoo.png"></div><br>  Tout se passe comme dans le cas pr√©c√©dent, mais plusieurs fois.  La lumi√®re du point A1 est diffus√©e au point X1 vers l'observateur au point O, la lumi√®re du point A2 est diffus√©e au point X2 vers l'observateur au point O, etc.  On voit que la lumi√®re atteignant l'observateur est √©gale √† la somme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/838/191/24f/83819124f0beb6bdd5adc3644a79653b.svg"></div><br>  Ou une expression int√©grale plus pr√©cise: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/7b0/5d2/e017b05d2026f311f43bc53da48c130e.svg"></div><br>  Il est important de comprendre qu'ici <img src="https://habrastorage.org/getpro/habr/post_images/e7b/3af/88e/e7b3af88eb6397d1f88774b011fe4cbb.svg">  , c'est-√†-dire  le segment est divis√© en un nombre infini de sections de longueur nulle. <br><br><h2>  Le ciel </h2><br>  Avec une l√©g√®re simplification, un rayon de soleil traversant l'atmosph√®re ne subit que la diffusion, c'est-√†-dire <img src="https://habrastorage.org/getpro/habr/post_images/c79/ce0/055/c79ce005518e112e707da427d7231066.svg">  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k0/mm/tz/k0mmtzjcir3wnqxbcjzsouln4yo.png"></div><br>  Et m√™me pas un type de diffusion, mais deux: la diffusion de Rayleigh et la diffusion Mi.  La premi√®re est caus√©e par des mol√©cules d'air, et la seconde est caus√©e par un a√©rosol d'eau. <br><br>  La densit√© totale de l'air (ou a√©rosol) √† travers lequel passe un rayon de lumi√®re, se d√©pla√ßant du point A au point B: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bc/d80/e5d/0bcd80e5d5b35e43fef8336e6c66cde0.svg"></div>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/14b/01a/bf0/14b01abf043545d56ac10d61e69792e8.svg">  - hauteur d'√©chelle, h - hauteur actuelle. <br><br>  Une solution int√©grale simple serait: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3f/b07/e75/d3fb07e750a91c2a253fdcf1de74de72.svg"></div><br>  o√π dh est la taille de pas avec laquelle l'√©chantillon de hauteur est pr√©lev√©. <br><br>  Regardez maintenant la figure et utilisez la formule d√©riv√©e dans la partie pr√©c√©dente du ¬´mod√®le d'√©clairage¬ª: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gr/n0/fr/grn0fr0f-dly-jjpcjpg_pxof9a.png"></div><br>  L'observateur regarde de O √† O '.  Nous voulons collecter toute la lumi√®re qui atteint les points X1, X2, ..., Xn, qui y est dispers√©e, puis atteint l'observateur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/c25/470/540c25470466173df2e5cf7880390ff9.svg"></div><br>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/c87/cb3/ca4/c87cb3ca4e0a0f0fc9d1a9d5c485c116.svg">  l'intensit√© de la lumi√®re √©mise par le soleil, <img src="https://habrastorage.org/getpro/habr/post_images/6c3/b25/b5f/6c3b25b5f22b9a03c093ef2f25a06339.svg">  - hauteur au point <img src="https://habrastorage.org/getpro/habr/post_images/ee6/2f8/bed/ee62f8bed8d0d0e9b3d3cd2c81841ded.svg">  ;  dans le cas du ciel, constante C, qui est en fonction <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  d√©sign√© comme <img src="https://habrastorage.org/getpro/habr/post_images/cea/f36/742/ceaf36742def9a68dbd173a0ac9c9aeb.svg">  . <br><br>  La solution de l'int√©grale peut √™tre la suivante: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5be/44a/9fc/5be44a9fcdb92469fee29b924a957556.svg"></div><br>  Cette formule est valable pour la diffusion de Rayleigh et la diffusion de Mie.  En cons√©quence, les valeurs lumineuses pour chacune des diffusions s'additionnent simplement: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34f/cb4/a91/34fcb4a9100e4b9c60a7c7eca2c489ec.svg"></div><br>  <b>Rayleigh Dispersion</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71e/a55/e80/71ea55e8043a70776eb70f29eb84d877.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/679/03f/8e9/67903f8e987346a525fb22e02e718aad.svg">  (contient des valeurs pour chaque canal RVB) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c9/02f/384/4c902f3848ae3cb24347ee0b367132d6.svg"><br><br>  R√©sultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/xs/8z/nkxs8zt8hyh909tjilktrkrrvri.png"></div><br>  <b>Mi scatter</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72b/94b/cc1/72b94bcc19f99b0e164c6a48e4408b44.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9a/52e/00c/c9a52e00c5e6169a8ad778f902e49595.svg">  (les valeurs pour tous les canaux RVB sont les m√™mes) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/208/fcf/3bf/208fcf3bf216540af2bfa93a186a3a19.svg"><br><br>  R√©sultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/jv/sb/fujvsbtduq-il-1reylizx1kosa.png"></div><br>  Le nombre d'√©chantillons par segment <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg">  et sur le segment <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg">  Vous pouvez en prendre 32 et plus.  Le rayon de la Terre est de 6371000 m, l'atmosph√®re est de 100000 m. <br><br>  Que faire de tout √ßa: <br><br><ol><li>  Dans chaque pixel de l'√©cran, nous calculons la direction de l'observateur V </li><li>  On prend la position de l'observateur O √©gale √† {0, 6371000, 0} </li><li>  Nous trouvons <img src="https://habrastorage.org/getpro/habr/post_images/28d/cc9/fe7/28dcc9fe786e9216afc4ab3ae2196ebe.svg">  √† la suite de l'intersection du rayon originaire du point O et de la direction de V et de la sph√®re centr√©e au point {0,0,0} et d'un rayon de 6471000 </li><li>  Segment de ligne <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg">  diviser en 32 sections de longueur √©gale </li><li>  Pour chaque section, nous calculons la diffusion Rayleigh et la diffusion Mie, et ajoutons tout.  De plus, pour calculer <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg">  nous devrons √©galement diviser le segment <img src="https://habrastorage.org/getpro/habr/post_images/0e6/fb0/4e8/0e6fb04e8525f5a3448df984993ab3c4.svg">  32 parcelles √©gales dans chaque cas. <img src="https://habrastorage.org/getpro/habr/post_images/60e/970/a20/60e970a20b30f36e7c21fe71c3d4dadb.svg">  peut √™tre lu √† travers une variable dont la valeur augmente √† chaque √©tape du cycle. </li></ol><br>  Le r√©sultat final: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/gb/tl/nogbtlqbuzffixmq7xmt1w4j_ja.png"></div><br><h2>  Mod√®le cloud </h2><br>  Nous aurons besoin de plusieurs types de bruit en 3D.  Le premier est le bruit du mouvement brownien fractal (fBm) de Perlin: <br><br>  R√©sultat pour une tranche 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ld/h6/v6/ldh6v6zglre4jhon_n8qu193o8k.png"></div><br>  Le deuxi√®me est le bruit fBm de camouflage de Voronoi. <br><br>  R√©sultat pour une tranche 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aa/rc/s2/aarcs2hvles3h89jqfc1lfrufjk.png"></div><br>  Pour obtenir le bruit de masquage fBm de Vorley, vous devez inverser le bruit de masquage fBm de Voronoj.  Cependant, j'ai l√©g√®rement modifi√© les plages de valeurs √† ma discr√©tion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fbmTiledWorley3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clamp((<span class="hljs-number"><span class="hljs-number">1.0</span></span>-fbmTiledVoronoi3(...))*<span class="hljs-number"><span class="hljs-number">1.5</span></span><span class="hljs-number"><span class="hljs-number">-0.25</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Le r√©sultat ressemble imm√©diatement aux structures des nuages: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ha/pf/em/hapfemxrqrxuqfpckajp53j4zxc.png"></div><br>  Pour les nuages, vous devez obtenir deux textures sp√©ciales.  Le premier a une taille de 128x128x128 et est responsable du bruit basse fr√©quence, le second a une taille de 32x32x32 et est responsable du bruit haute fr√©quence.  Chaque texture utilise un seul canal au format R8.  Dans certains exemples, 4 canaux de R8G8B8A8 sont utilis√©s pour la premi√®re texture et trois canaux de R8G8B8 pour la seconde, puis les canaux sont m√©lang√©s dans un shader.  Je ne vois pas l‚Äôint√©r√™t, car le mixage peut √™tre fait √† l‚Äôavance, obtenant ainsi un plus grand succ√®s dans la coh√©rence du cache. <br><br>  Pour le mixage, et aussi √† certains endroits, la fonction remap () sera utilis√©e, qui met √† l'√©chelle les valeurs d'une plage √† l'autre: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMinValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMaxValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newMinValue+(value-minValue)/(maxValue-minValue)*(newMaxValue-newMinValue); }</code> </pre> <br>  Commen√ßons √† pr√©parer la texture avec un bruit basse fr√©quence: <br>  Canal R - bruit fBm de Perlin <br>  Canal G - bruit FBm Vorley en mosa√Øque <br>  Canal B - bruit Worley fBm plus petit avec une √©chelle plus petite <br>  Canal A - Bruit fBm variable de Varley avec une √©chelle encore plus petite <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/_9/z-/ms_9z-hofvyvya5-zuh6vpi6da0.png"></div><br>  Le mixage se fait de cette fa√ßon: <br><br><pre> <code class="cpp hljs">finalValue=remap(noise.x, (noise.y * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.z*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.w * <span class="hljs-number"><span class="hljs-number">0.125</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  R√©sultat pour une tranche 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/64/qh/rl/64qhrl3wl2vrsbedao4fk9zr3xg.png"></div><br>  Maintenant, pr√©parez la texture avec un bruit haute fr√©quence: <br>  Canal R - bruit FBm Vorley en mosa√Øque <br>  Canal G - Bruit Vorley fBm √† plus petite √©chelle <br>  Canal B - Bruit Varley taylivaya fBm avec une √©chelle encore plus petite <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/m6/in/oxm6inosejxwrkx2kdz7zv17eea.png"></div><br><pre> <code class="cpp hljs">finalValue=noise.x * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.y*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.z * <span class="hljs-number"><span class="hljs-number">0.125</span></span>;</code> </pre> <br>  R√©sultat pour une tranche 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lg/mr/mc/lgmrmc2ohi3ayicwbji49fdhqb4.png"></div><br>  Nous avons √©galement besoin d'une carte texture-m√©t√©o 2D qui d√©terminera la pr√©sence, la densit√© et la forme des nuages, en fonction des coordonn√©es de l'espace.  Il est peint par des artistes pour affiner la couverture nuageuse.  L'interpr√©tation des canaux de couleur de la carte m√©t√©o peut √™tre diff√©rente, dans la version que j'ai pr√™t√©e, elle est la suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/oi/m8/fuoim8wbtdzgqoc2lma8g6gb0ow.png"></div><br>  Canal R - couverture nuageuse √† basse altitude <br>  Canal G - couverture nuageuse √† haute altitude <br>  Canal B - hauteur maximale des nuages <br>  Canal A - densit√© des nuages <br><br>  Nous sommes maintenant pr√™ts √† cr√©er une fonction qui renverra la densit√© des nuages ‚Äã‚Äãen fonction des coordonn√©es de l'espace 3D. <br><br>  A l'entr√©e, un point dans l'espace avec coordonn√©es en km <br><br><pre> <code class="cpp hljs">vec3 position</code> </pre> <br>  Ajoutez imm√©diatement le d√©calage au vent <br><br><pre> <code class="cpp hljs">position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time;</code> </pre> <br>  Obtenez les valeurs de la carte m√©t√©o <br><br><pre> <code class="cpp hljs">vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre>  On obtient le pourcentage de hauteur (de 0 √† 1) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position);</code> </pre> <br>  Ajoutez un petit arrondi des nuages ‚Äã‚Äãci-dessous: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Nous faisons une diminution lin√©aire de la densit√© √† 0 avec une hauteur croissante selon le canal B de la carte m√©t√©o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Combinez le r√©sultat: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt;</code> </pre> <br>  Ajoutez √† nouveau l'arrondi des nuages ‚Äã‚Äãci-dessous: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Ajoutez √©galement l'arrondi des nuages ‚Äã‚Äãsur le dessus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Nous combinons le r√©sultat, nous ajoutons ici l'influence de la densit√© de la carte m√©t√©o et l'influence de la densit√©, qui est d√©finie via gui: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density;</code> </pre> <br>  Combinez le bruit basse fr√©quence et haute fr√©quence de nos textures: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>;</code> </pre> <br>  Dans tous les documents que j'ai lus, la fusion se d√©roule diff√©remment, mais j'ai bien aim√© cette option. <br><br>  Nous d√©terminons la quantit√© de couverture (% du ciel occup√© par les nuages), qui est d√©finie via gui, les canaux R et G de la carte m√©t√©o sont √©galement utilis√©s: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Calculez la densit√© finale: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA;</code> </pre> <br>  Fonction enti√®re: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position)</span></span></span><span class="hljs-function"> </span></span>{ position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time; vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>+vec2(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d; }</code> </pre> <br>  Quelle doit √™tre exactement cette fonction est une question ouverte, car en ignorant les lois auxquelles les nuages ‚Äã‚Äãob√©issent lors de la d√©finition des param√®tres, vous pouvez obtenir un r√©sultat tr√®s inhabituel et magnifique.  Tout d√©pend de l'application. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/nz/bz/tfnzbzvd2oucw2h_oed9pbm_8ku.png"></div><br><h2>  Int√©gration </h2><br>  L'atmosph√®re de la Terre est divis√©e en deux couches: interne et externe, entre lesquelles les nuages ‚Äã‚Äãpeuvent √™tre situ√©s.  Ces couches peuvent √™tre repr√©sent√©es par des sph√®res, mais aussi par des plans.  Je me suis install√© sur les sph√®res.  Pour la premi√®re couche, j'ai pris le rayon de sph√®re de 6415 km, pour la deuxi√®me couche, le rayon de 6435 km.  Le rayon de la terre arrondi √† 6400 km.  Certains param√®tres d√©pendront de l'√©paisseur conditionnelle de la partie ¬´nuageuse¬ª de l'atmosph√®re (20 km). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0z/ir/8r/0zir8r9qtvwlh9xk85i-hznhqa0.png"></div><br><br>  Contrairement au ciel, les nuages ‚Äã‚Äãsont opaques et l'int√©gration n√©cessite non seulement d'obtenir la couleur, mais √©galement d'obtenir la valeur du canal alpha.  Vous avez d'abord besoin d'une fonction qui renvoie la densit√© totale du nuage √† travers laquelle passera un rayon de lumi√®re du soleil. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5k/ne/lj/5kneljw4unaofsxxgbq12ealebw.png"></div><br>  Personne n'attire l'attention sur cela, mais la pratique a montr√© qu'il n'est pas du tout n√©cessaire de prendre en compte l'int√©gralit√© du trajet du faisceau, seul l'√©cart le plus extr√™me est n√©cessaire.  Nous supposons que les nuages ‚Äã‚Äãau-dessus d'un segment tronqu√© n'existent pas du tout. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/sr/ly/edsrlyis3-2or1nztj6q-osmats.png"></div><br>  De plus, nous sommes tr√®s limit√©s dans le nombre d'√©chantillons de densit√© qui peuvent √™tre r√©alis√©s sans nuire aux performances.  Guerrilla Games do 6. De plus, dans l'une des pr√©sentations, le d√©veloppeur a d√©clar√© qu'ils dispersent ces √©chantillons √† l'int√©rieur du c√¥ne, et le dernier √©chantillon est sp√©cialement con√ßu tr√®s loin du reste pour couvrir autant d'espace que possible.  Les impr√©cisions et le bruit qui en r√©sultent seront toujours liss√©s sur le fond des √©chantillons voisins, et cela, au contraire, se traduira par une pr√©cision accrue. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/rr/df/5prrdfocofvzsjobvawnairijp0.png"></div><br>  Au final, je me suis install√© sur 4 √©chantillons qui se trouvent sur la m√™me ligne, mais cette derni√®re est prise avec un pas multipli√© par 6.  Le pas est de 20 km * 0,01, soit 200 m. <br><br>  La fonction est assez simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDirectDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   float avrStep=(6435.0-6415.0)*0.01; float sumDensity=0.0; for(int i=0;i&lt;4;i++) { float step=avrStep; //      6 if(i==3) step=step*6.0; //  position+=sunDir*step; //  ,  ,   //  float density=cloudSampleDensity(position)*step; sumDensity+=density; } return sumDensity; }</span></span></code> </pre> <br>  Vous pouvez maintenant passer √† la partie la plus difficile.  Nous d√©terminons l'observateur √† la surface de la Terre au point {0, 6400,0} et trouvons l'intersection du faisceau d'observation avec une sph√®re de rayon 6415 km et de centre {0,0,0} - nous obtenons le point de d√©part S. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/25/je/zj/25jezjeea4j3bl51jneypfjetsi.png"></div><br>  Voici la version de base de la fonction: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { position+=viewDir*step; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); }</code> </pre> <br>  La taille de l'√©tape est d√©finie comme 20 km / 64, c'est-√†-dire  dans le cas de la direction strictement verticale du faisceau de l'observateur, nous r√©aliserons 64 √©chantillons.  Cependant, lorsque cette direction est plus horizontale, les √©chantillons seront l√©g√®rement plus grands, il n'y a donc pas 64 √©tapes dans le cycle, mais 128 avec une marge. <br><br>  Au d√©but, nous supposons que la couleur finale est le noir et la transparence est l'unit√©.  √Ä chaque √©tape, nous augmenterons la valeur de couleur et diminuerons la valeur de transparence.  Si la transparence est proche de 0, vous pouvez pr√©-quitter la boucle: <br><br><pre> <code class="cpp hljs">vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//    //      float density=cloudSampleDensity(position)*avrStep; //   ,   //   float sunDensity=cloudSampleDirectDensity(position, sunDir); //      float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*m2*m3; //       color+=sunColor*light*transmittance; transmittance*=exp(-ufmProperties.attenuation*density); ‚Ä¶ return vec4(color, 1.0-transmittance);</span></span></code> </pre> <br>  ufmProperties.attenuation - Il n'y a que C dans <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg">  et ufmProperties.attenuation2 est C dans <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  .  ufmProperties.sunIntensity - l'intensit√© de rayonnement du soleil.  sunColor - la couleur du soleil. <br><br>  R√©sultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/ft/z9/vcftz9vsswkxpqoggirezpfpygm.png"></div><br>  Un d√©faut est imm√©diatement √©vident - un ombrage s√©v√®re.  Mais maintenant, nous allons corriger le manque d'√©clairage amplifi√© pr√®s du soleil.  Cela s'est produit parce que nous n'avons pas ajout√© de fonction de phase.  Pour calculer la diffusion de la lumi√®re traversant les nuages, la fonction de phase de Hengy-Greenstein est utilis√©e, qui l'a ouverte en 1941 pour des calculs similaires dans des amas de gaz dans l'espace: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b0/b2e/33f/4b0b2e33fbd07036b14317d40cb1eac0.svg"></div><br>  Une digression devrait √™tre faite ici.  Selon le mod√®le d'√©clairage canonique, la fonction de phase devrait √™tre une.  Cependant, en r√©alit√©, le r√©sultat obtenu ne convient √† personne et chacun utilise des fonctions √† deux phases, et combine m√™me ses valeurs de mani√®re particuli√®re.  Je me suis √©galement concentr√© sur les fonctions √† deux phases, mais j'additionne simplement leurs valeurs.  La fonction de la premi√®re phase a g proche de 1 et vous permet de faire un √©clairage lumineux pr√®s du soleil.  La fonction de la deuxi√®me phase a g proche de 0,5 et vous permet de diminuer progressivement l'illumination dans toute la sph√®re c√©leste. <br><br>  Code mis √† jour: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// cos(theta) float mu=max(0, dot(viewDir, sunDir)); float m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); float m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*(m11+m12)*m2*m3;</span></span></code> </pre> <br>  ufmProperties.eccentrisy, ufmProperties.eccentrisy2 sont des valeurs g <br><br>  R√©sultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ip/qr/fi/ipqrfivyafyxnmdswnn_nbpvfdk.png"></div><br>  Vous pouvez maintenant commencer le combat avec trop d'ombrage.  Elle est pr√©sente car nous n'avons pas tenu compte de la lumi√®re des nuages ‚Äã‚Äãenvironnants et du ciel, qui est dans la vraie vie. <br><br>  J'ai r√©solu ce probl√®me comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(color+ambientColor*ufmProperties.ambient, <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br>  O√π ambientColor est la couleur du ciel dans la direction du faisceau d'observation, ufmProperties.ambient est le param√®tre de r√©glage. <br><br>  R√©sultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/8h/ji/ct8hjiyk7brz5pv8vuwjeji33bc.png"></div><br>  Reste √† r√©soudre le dernier probl√®me.  Dans la vraie vie, plus la vue est horizontale, plus nous voyons un certain brouillard ou brume qui ne nous permet pas de voir des objets tr√®s √©loign√©s.  Cela doit √©galement se refl√©ter dans le code.  J'ai pris le cosinus habituel de l'angle de regard et de la fonction exponentielle.  Sur cette base, un certain coefficient de fusion est calcul√©, ce qui permet une interpolation lin√©aire entre la couleur r√©sultante et la couleur d'arri√®re-plan. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br>  ufmProperties.fog - pour une configuration manuelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/02/td/9h/02td9ho6kelgum68wldvcf-zymu.png"></div><br>  Fonction r√©capitulative: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir, vec3 sunColor, vec3 ambientColor)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> density=cloudSampleDensity(position)*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(density&gt;<span class="hljs-number"><span class="hljs-number">0.0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sunDensity=cloudSampleDirectDensity(position, sunDir); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mu=max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, sunDir)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m2=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*sunDensity); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m3=ufmProperties.attenuation2*density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> light=ufmProperties.sunIntensity*(m11+m12)*m2*m3; color+=sunColor*light*transmittance; transmittance*=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*density); } position+=viewDir*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(transmittance&lt;<span class="hljs-number"><span class="hljs-number">0.05</span></span> || length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance); }</code> </pre> <br>  Vid√©o de d√©monstration: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uPxVgbwThmI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Optimisation et am√©liorations possibles </h2><br>  Apr√®s avoir impl√©ment√© l'algorithme de rendu de base, le probl√®me suivant est qu'il fonctionne trop lentement.  Ma version a produit 25 fps en full hd sur la radeon rx 480. Les deux approches suivantes pour r√©soudre le probl√®me ont √©t√© sugg√©r√©es par Guerrilla Games lui-m√™me. <br><br>  <b>Nous dessinons ce qui est vraiment visible</b> <br><br>  L'√©cran est divis√© en tuiles de 16 x 16 pixels.  Tout d'abord, l'environnement 3D habituel est dessin√©.  Il s'av√®re que la majeure partie du ciel est couverte de montagnes ou de gros objets.  Par cons√©quent, vous devez effectuer le calcul uniquement dans les tuiles dans lesquelles les nuages ‚Äã‚Äãne sont bloqu√©s par rien. <br><br>  <b>Reprojection</b> <br><br>  Lorsque la cam√©ra est immobile, il s'av√®re que les nuages ‚Äã‚Äãen g√©n√©ral ne peuvent pas √™tre mis √† jour.  Cependant, si la cam√©ra a boug√©, cela ne signifie pas que nous devons mettre √† jour tout l'√©cran.  Tout est d√©j√† dessin√©, il vous suffit de reconstruire l'image en fonction des nouvelles coordonn√©es.  La recherche d'anciennes coordonn√©es sur de nouvelles, √† travers les matrices de projection et de visualisation des images actuelles et pr√©c√©dentes, s'appelle projection.  Ainsi, dans le cas d'un d√©calage de cam√©ra, nous transf√©rons simplement les couleurs en fonction des nouvelles coordonn√©es.  Dans les cas o√π ces coordonn√©es indiquent hors √©cran, les nuages ‚Äã‚Äãdoivent √™tre redessin√©s honn√™tement. <br><br>  <b>Mise √† jour partielle</b> <br><br>  Je n'aime pas l'id√©e de la reprojection, car avec un virage serr√© de la cam√©ra, il peut s'av√©rer que les nuages ‚Äã‚Äãdevront √™tre rendus pour un tiers de l'√©cran, ce qui peut provoquer un d√©calage.  Je ne sais pas comment Guerrilla Games a g√©r√© cela, mais au moins dans Horizon Zero Dawn, lorsque vous contr√¥lez le joystick, la cam√©ra se d√©place en douceur et il n'y a aucun probl√®me avec des sauts brusques.  Par cons√©quent, en tant qu'exp√©rience, j'ai trouv√© ma propre approche.  Les nuages ‚Äã‚Äãsont dessin√©s sur une carte cubique, en 5 faces, car  le fond ne nous int√©resse pas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le c√¥t√© de la carte cubique a une r√©solution r√©duite √©gale aux ‚Öî de la hauteur de l'√©cran. Chaque face de la carte cubique est divis√©e en tuiles 8x8. Chaque image sur chaque face est mise √† jour avec un seul des 64 pixels dans chaque mosa√Øque. Cela donne des artefacts perceptibles lors de changements soudains, mais parce que les nuages ‚Äã‚Äãsont assez statiques, alors une telle astuce est invisible. En cons√©quence, le radeon rx 480 produit 500 fps en full hd pour le volcan et 330 fps pour opengl. La s√©rie Radeon hd 5700 produit 109 images par seconde en full hd sous opengl (vulkan ne prend pas en charge). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation des niveaux de mip</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsque vous acc√©dez √† des textures avec du bruit, vous pouvez prendre des donn√©es du niveau de mip z√©ro uniquement dans les tout premiers √©chantillons, puis plus les √©chantillons que nous faisons sont √©lev√©s, plus le niveau de mip peut √™tre √©lev√©. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuages ‚Äã‚Äã√©lev√©s</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour simuler la pr√©sence de cirrus-altitude et de cirrocumulus dans Guerrilla Games lors de l'int√©gration, les derniers √©chantillons ne sont pas fabriqu√©s √† partir des textures 3D dont j'ai parl√©, mais √† partir d'une texture 2D sp√©ciale. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/f2/vj/udf2vjpfht0hhpbf9zptwfmadhg.jpeg"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bruit</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de courbure Plusieurs textures suppl√©mentaires dans le bruit de courbure sont utilis√©es pour cr√©er l'effet des nuages ‚Äã‚Äãde vent. </font><font style="vertical-align: inherit;">Ces textures sont n√©cessaires pour d√©placer les coordonn√©es d'origine.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-n/qq/pg/-nqqpgmixyogyjxqrdyhm4oxlpc.png"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rayons divins</font></font></b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qd/wq/xv/qdwqxvzveiwuxgu2v84aw5fhjwo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces rayons, captant les drames, sont r√©alis√©s en post-traitement. </font><font style="vertical-align: inherit;">Tout d'abord, un √©clairage brillant est dessin√© autour du soleil, o√π il n'est pas bloqu√© par les nuages. </font><font style="vertical-align: inherit;">Ensuite, ce r√©tro-√©clairage doit √™tre radialement d√©cal√© par rapport au soleil.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/vj/-a/apvj-assr02-vaov3o1k5frfawk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous devez maintenant appliquer un lissage radial. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/lg/1h/jdlg1hp7jajzhlbom4ocmn3vl70.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, il y a beaucoup plus d'am√©liorations et de subtilit√©s, mais je ne les ai pas toutes v√©rifi√©es, donc je ne peux pas les dire avec confiance. Cependant, vous pouvez vous familiariser avec eux. Le plus fort je pense est la documentation cloud du moteur Frostbite.</font></font><br><br><h2>  Liens utiles </h2><br> <b> Guerrilla Games</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d1z4o56rleaq4j.cloudfront.net/downloads/assets/Nubis-Authoring-Realtime-Volumetric-Cloudscapes-with-the-Decima-Engine-Final.pdf?mtime=20170807141817</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">killzone.dl.playstation.net/killzone/horizonzerodawn/presentations/Siggraph15_Schneider_Real-Time_Volumetric_Cloudscapes_of_Horizon_Zero_Dawn.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.youtube.com/watch?v=-d8qT5-1LOI</a> <br><br> <b>  GPU Pro 7</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vk.com/doc179245989_437393482?hash=a9af5f665eda4edf58&amp;dl=806d4dbdac0f7a761c</a> <br><br> <b></b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky</a> <br><br> <b> Frostbite</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.shadertoy.com/view/XlBSRz</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459948/">https://habr.com/ru/post/fr459948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459924/index.html">Cycle d'essai complet de React. Rapport Auto.ru</a></li>
<li><a href="../fr459928/index.html">Parcours de l'√©tudiant vers le d√©veloppement d'applications mobiles</a></li>
<li><a href="../fr459930/index.html">Automatisation de l'importation Python</a></li>
<li><a href="../fr459934/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 306 (du 8 au 14 juillet)</a></li>
<li><a href="../fr459936/index.html">9 astuces suppl√©mentaires pour travailler avec Visual Studio</a></li>
<li><a href="../fr459952/index.html">Un peu d'exp√©rience sur la sauvegarde et le stockage</a></li>
<li><a href="../fr459954/index.html">Pourquoi l'une des plus grandes soci√©t√©s informatiques a rejoint CNCF - un fonds d√©veloppant une infrastructure cloud</a></li>
<li><a href="../fr459956/index.html">Implantation en l'absence totale de dents, suite √† des visites intempestives chez le dentiste</a></li>
<li><a href="../fr459958/index.html">T√¢ches d'analyse de la conf√©rence Hydra - √©quilibrage de charge et stockage en m√©moire</a></li>
<li><a href="../fr459960/index.html">De l'id√©e √† la sortie. Exp√©rience d√©taill√©e du march√© frontal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>