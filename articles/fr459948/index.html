<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍⚕️ 🅰️ 🧗 Implémentation de nuages ​​volumétriques physiquement corrects comme dans Horizon Zero Dawn 💃🏼 🤗 👩‍👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auparavant, les nuages ​​dans les jeux étaient dessinés avec des sprites 2D ordinaires, qui sont toujours tournés dans le sens de la caméra, mais ces ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implémentation de nuages ​​volumétriques physiquement corrects comme dans Horizon Zero Dawn</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459948/">  Auparavant, les nuages ​​dans les jeux étaient dessinés avec des sprites 2D ordinaires, qui sont toujours tournés dans le sens de la caméra, mais ces dernières années, de nouveaux modèles de cartes vidéo vous permettent de dessiner des nuages ​​physiquement corrects sans pertes de performances notables.  On pense que des nuages ​​volumineux dans le jeu ont amené le studio Guerrilla Games avec le jeu Horizon Zero Dawn.  Bien sûr, de tels nuages ​​pouvaient être rendus auparavant, mais le studio a formé quelque chose comme une norme industrielle pour les ressources sources et les algorithmes utilisés, et maintenant toute implémentation de nuages ​​volumétriques est en quelque sorte conforme à cette norme. <br><br><img src="https://habrastorage.org/webt/v9/uq/em/v9uqemwtz5ty7x5uvpppsoonmdu.png"><br><a name="habracut"></a><br>  L'ensemble du processus de rendu des nuages ​​est très bien divisé en étapes et il est important de noter qu'une mise en œuvre inexacte, même sur l'une d'entre elles, peut entraîner de telles conséquences qu'il ne sera pas clair où se trouve l'erreur et comment la corriger, il est donc conseillé de faire une conclusion de contrôle du résultat à chaque fois. <br><br><h2>  Cartographie des tons, sRGB </h2><br>  Avant de commencer à travailler avec l'éclairage, il est important de faire deux choses: <br><br><ol><li>  Avant d'afficher l'image finale à l'écran, appliquez au moins le mappage de tons le plus simple: <br><br><pre><code class="cpp hljs">tunedColor=color/(<span class="hljs-number"><span class="hljs-number">1</span></span>+color)</code> </pre> <br>  Cela est nécessaire car les valeurs de couleur calculées seront beaucoup plus grandes que l'unité. <br></li><li>  Assurez-vous que le tampon d'image final dans lequel vous dessinez et affiché à l'écran est au format sRGB.  Si l'activation du mode sRGB pose problème, la conversion peut être effectuée manuellement dans le shader: <br><br><pre> <code class="cpp hljs">finalColor=<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(color, vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.2</span></span>))</code> </pre> <br>  La formule convient à la plupart des cas, mais pas à 100% selon le moniteur.  Il est important que la conversion sRGB soit toujours effectuée en dernier. </li></ol><br><h2>  Modèle d'éclairage </h2><br>  Considérons un espace rempli de matière partiellement transparente de différentes densités.  Lorsqu'un rayon de lumière traverse une telle substance, il est exposé à quatre effets: absorption, diffusion, diffusion amplificatrice et auto-rayonnement.  Ce dernier se produit dans le cas de processus chimiques dans une substance et n'est pas affecté ici. <br><br>  Supposons que nous ayons un rayon de lumière qui traverse la matière d'un point A à un point B: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_1/1t/9w/_11t9wizftnmwilerlsi5fvcrm4.png"></div><br>  <b>L'absorption</b> <br><br>  La lumière traversant une substance est absorbée par cette même substance.  La fraction de lumière non absorbée peut être trouvée par la formule: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/34c/ec6/56734cec6154e1fab8bb2d1538a8dffa.svg"></div><br>  où <img src="https://habrastorage.org/getpro/habr/post_images/a3e/204/11f/a3e20411f145906908c5cd2b53a36dbe.svg">  - la lumière restant au point après absorption <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  - pointez sur le segment AB à distance <img src="https://habrastorage.org/getpro/habr/post_images/2a3/102/4ea/2a31024ea1803c34a47496e24a53a1ef.svg">  de A. <br><br>  <b>Diffusion</b> <br><br>  Une partie de la lumière sous l'influence de particules de matière change de direction.  La fraction de lumière qui n'a pas changé de direction peut être trouvée par la formule: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04b/c17/2f5/04bc172f53fa572aebf0399275b5009f.svg"></div><br>  où <img src="https://habrastorage.org/getpro/habr/post_images/5e3/0b7/bad/5e30b7badd64b9da62be750e48573c7d.svg">  - fraction de lumière qui n'a pas changé de direction après diffusion en un point <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <br><br>  L'absorption et la dispersion doivent être combinées: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d7/d5a/f1a/8d7d5af1a0506ee776c4c2f850e862a9.svg"></div><br>  Fonction <img src="https://habrastorage.org/getpro/habr/post_images/33f/297/4e9/33f2974e9c84331f8b92d8b7ed5aca97.svg">  appelé atténuation ou extinction.  Une fonction <img src="https://habrastorage.org/getpro/habr/post_images/eea/d4d/0d4/eead4d0d4f08873f9aa49b69a7c46fd8.svg">  - fonction de transfert.  Il montre combien de lumière reste lors du passage du point A au point B. <br><br>  En ce qui concerne <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg">  et <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  : <img src="https://habrastorage.org/getpro/habr/post_images/b76/ea9/fd5/b76ea9fd577eb1c2cee545caa4153bd3.svg">  , où C est une certaine constante, qui peut avoir une valeur différente pour chaque canal en RVB, <img src="https://habrastorage.org/getpro/habr/post_images/9ee/494/9d2/9ee4949d2897f56ac90e563db1eb96cd.svg">  Est la densité du milieu au point <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <br><br>  Maintenant, compliquons la tâche.  La lumière se déplace du point A au point B, elle s'éteint pendant le mouvement.  Au point X, une partie de la lumière est diffusée dans différentes directions, une des directions correspond à l'observateur au point O. Ensuite, une partie de la lumière diffusée se déplace du point X au point O et s'humidifie à nouveau.  Le chemin de la lumière AXO nous intéresse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/b_/tr/zob_troftvd8-ggp1ga7wesnrlk.png"></div><br>  La perte de lumière lors du passage de A à X, nous savons: <img src="https://habrastorage.org/getpro/habr/post_images/25d/8c9/f76/25d8c9f76986f59eb045b801f19d4e0a.svg">  , tout comme nous savons la perte de lumière de X à O - ce <img src="https://habrastorage.org/getpro/habr/post_images/25b/3a9/8e3/25b3a98e370f0a95b734794b74bee57a.svg">  .  Mais qu'en est-il de la fraction de lumière qui sera diffusée en direction de l'observateur? <br><br>  <b>Dispersion d'amplification</b> <br><br>  Si dans le cas d'une diffusion ordinaire, l'intensité lumineuse diminue, alors dans le cas d'une diffusion amplificatrice, elle augmente du fait de la diffusion de la lumière qui s'est produite dans les régions voisines.  La quantité totale de lumière provenant des régions voisines peut être trouvée par la formule: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e4/be1/bd9/7e4be1bd9a1d8f05b9d1d47e1bb27ecc.svg"></div><br>  où <img src="https://habrastorage.org/getpro/habr/post_images/e63/878/1e4/e638781e456c920d7864e85c8b14a746.svg">  signifie prendre l'intégrale sur la sphère, <img src="https://habrastorage.org/getpro/habr/post_images/1ad/0bb/23e/1ad0bb23eb22871d78d2b5cc67d58292.svg">  - fonction de phase <img src="https://habrastorage.org/getpro/habr/post_images/da9/7bc/3c5/da97bc3c51ddad728182deecd39ba0d0.svg">  - lumière venant de la direction <img src="https://habrastorage.org/getpro/habr/post_images/9c6/a44/e8e/9c6a44e8ed4cb10046e00346c6b58b15.svg">  . <br><br>  Il est assez difficile de calculer la lumière de toutes les directions, cependant, nous savons que la partie originale de la lumière est transportée par notre faisceau AB d'origine.  La formule peut être grandement simplifiée: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef8/4aa/222/ef84aa22259c648ea9925502712250f6.svg"></div><br>  où <img src="https://habrastorage.org/getpro/habr/post_images/2cb/bcb/347/2cbbcb347a44c276c1095ac5bb3f8242.svg">  - l'angle entre le faisceau lumineux et le faisceau d'observation (c'est-à-dire l'angle AXO), <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  - la valeur initiale de l'intensité lumineuse.  En résumant tout ce qui précède, nous obtenons la formule: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/fb7/273/642fb727356c245fc6f053dbc9affde8.svg"></div><br>  où <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  - lumière entrante <img src="https://habrastorage.org/getpro/habr/post_images/f7a/fbd/138/f7afbd138efabfc5bf5dad3e26e6c0fb.svg">  - la lumière atteignant l'observateur. <br><br>  Nous compliquons un peu plus la tâche.  Disons que la lumière est émise par une lumière directionnelle, c'est-à-dire  le soleil: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wz/r2/gg/wzr2ggl_1oshhmhn3kkqalhtkoo.png"></div><br>  Tout se passe comme dans le cas précédent, mais plusieurs fois.  La lumière du point A1 est diffusée au point X1 vers l'observateur au point O, la lumière du point A2 est diffusée au point X2 vers l'observateur au point O, etc.  On voit que la lumière atteignant l'observateur est égale à la somme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/838/191/24f/83819124f0beb6bdd5adc3644a79653b.svg"></div><br>  Ou une expression intégrale plus précise: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/7b0/5d2/e017b05d2026f311f43bc53da48c130e.svg"></div><br>  Il est important de comprendre qu'ici <img src="https://habrastorage.org/getpro/habr/post_images/e7b/3af/88e/e7b3af88eb6397d1f88774b011fe4cbb.svg">  , c'est-à-dire  le segment est divisé en un nombre infini de sections de longueur nulle. <br><br><h2>  Le ciel </h2><br>  Avec une légère simplification, un rayon de soleil traversant l'atmosphère ne subit que la diffusion, c'est-à-dire <img src="https://habrastorage.org/getpro/habr/post_images/c79/ce0/055/c79ce005518e112e707da427d7231066.svg">  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k0/mm/tz/k0mmtzjcir3wnqxbcjzsouln4yo.png"></div><br>  Et même pas un type de diffusion, mais deux: la diffusion de Rayleigh et la diffusion Mi.  La première est causée par des molécules d'air, et la seconde est causée par un aérosol d'eau. <br><br>  La densité totale de l'air (ou aérosol) à travers lequel passe un rayon de lumière, se déplaçant du point A au point B: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bc/d80/e5d/0bcd80e5d5b35e43fef8336e6c66cde0.svg"></div>  où <img src="https://habrastorage.org/getpro/habr/post_images/14b/01a/bf0/14b01abf043545d56ac10d61e69792e8.svg">  - hauteur d'échelle, h - hauteur actuelle. <br><br>  Une solution intégrale simple serait: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3f/b07/e75/d3fb07e750a91c2a253fdcf1de74de72.svg"></div><br>  où dh est la taille de pas avec laquelle l'échantillon de hauteur est prélevé. <br><br>  Regardez maintenant la figure et utilisez la formule dérivée dans la partie précédente du «modèle d'éclairage»: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gr/n0/fr/grn0fr0f-dly-jjpcjpg_pxof9a.png"></div><br>  L'observateur regarde de O à O '.  Nous voulons collecter toute la lumière qui atteint les points X1, X2, ..., Xn, qui y est dispersée, puis atteint l'observateur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/c25/470/540c25470466173df2e5cf7880390ff9.svg"></div><br>  où <img src="https://habrastorage.org/getpro/habr/post_images/c87/cb3/ca4/c87cb3ca4e0a0f0fc9d1a9d5c485c116.svg">  l'intensité de la lumière émise par le soleil, <img src="https://habrastorage.org/getpro/habr/post_images/6c3/b25/b5f/6c3b25b5f22b9a03c093ef2f25a06339.svg">  - hauteur au point <img src="https://habrastorage.org/getpro/habr/post_images/ee6/2f8/bed/ee62f8bed8d0d0e9b3d3cd2c81841ded.svg">  ;  dans le cas du ciel, constante C, qui est en fonction <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  désigné comme <img src="https://habrastorage.org/getpro/habr/post_images/cea/f36/742/ceaf36742def9a68dbd173a0ac9c9aeb.svg">  . <br><br>  La solution de l'intégrale peut être la suivante: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5be/44a/9fc/5be44a9fcdb92469fee29b924a957556.svg"></div><br>  Cette formule est valable pour la diffusion de Rayleigh et la diffusion de Mie.  En conséquence, les valeurs lumineuses pour chacune des diffusions s'additionnent simplement: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34f/cb4/a91/34fcb4a9100e4b9c60a7c7eca2c489ec.svg"></div><br>  <b>Rayleigh Dispersion</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71e/a55/e80/71ea55e8043a70776eb70f29eb84d877.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/679/03f/8e9/67903f8e987346a525fb22e02e718aad.svg">  (contient des valeurs pour chaque canal RVB) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c9/02f/384/4c902f3848ae3cb24347ee0b367132d6.svg"><br><br>  Résultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/xs/8z/nkxs8zt8hyh909tjilktrkrrvri.png"></div><br>  <b>Mi scatter</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72b/94b/cc1/72b94bcc19f99b0e164c6a48e4408b44.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9a/52e/00c/c9a52e00c5e6169a8ad778f902e49595.svg">  (les valeurs pour tous les canaux RVB sont les mêmes) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/208/fcf/3bf/208fcf3bf216540af2bfa93a186a3a19.svg"><br><br>  Résultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/jv/sb/fujvsbtduq-il-1reylizx1kosa.png"></div><br>  Le nombre d'échantillons par segment <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg">  et sur le segment <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg">  Vous pouvez en prendre 32 et plus.  Le rayon de la Terre est de 6371000 m, l'atmosphère est de 100000 m. <br><br>  Que faire de tout ça: <br><br><ol><li>  Dans chaque pixel de l'écran, nous calculons la direction de l'observateur V </li><li>  On prend la position de l'observateur O égale à {0, 6371000, 0} </li><li>  Nous trouvons <img src="https://habrastorage.org/getpro/habr/post_images/28d/cc9/fe7/28dcc9fe786e9216afc4ab3ae2196ebe.svg">  à la suite de l'intersection du rayon originaire du point O et de la direction de V et de la sphère centrée au point {0,0,0} et d'un rayon de 6471000 </li><li>  Segment de ligne <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg">  diviser en 32 sections de longueur égale </li><li>  Pour chaque section, nous calculons la diffusion Rayleigh et la diffusion Mie, et ajoutons tout.  De plus, pour calculer <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg">  nous devrons également diviser le segment <img src="https://habrastorage.org/getpro/habr/post_images/0e6/fb0/4e8/0e6fb04e8525f5a3448df984993ab3c4.svg">  32 parcelles égales dans chaque cas. <img src="https://habrastorage.org/getpro/habr/post_images/60e/970/a20/60e970a20b30f36e7c21fe71c3d4dadb.svg">  peut être lu à travers une variable dont la valeur augmente à chaque étape du cycle. </li></ol><br>  Le résultat final: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/gb/tl/nogbtlqbuzffixmq7xmt1w4j_ja.png"></div><br><h2>  Modèle cloud </h2><br>  Nous aurons besoin de plusieurs types de bruit en 3D.  Le premier est le bruit du mouvement brownien fractal (fBm) de Perlin: <br><br>  Résultat pour une tranche 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ld/h6/v6/ldh6v6zglre4jhon_n8qu193o8k.png"></div><br>  Le deuxième est le bruit fBm de camouflage de Voronoi. <br><br>  Résultat pour une tranche 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aa/rc/s2/aarcs2hvles3h89jqfc1lfrufjk.png"></div><br>  Pour obtenir le bruit de masquage fBm de Vorley, vous devez inverser le bruit de masquage fBm de Voronoj.  Cependant, j'ai légèrement modifié les plages de valeurs à ma discrétion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fbmTiledWorley3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clamp((<span class="hljs-number"><span class="hljs-number">1.0</span></span>-fbmTiledVoronoi3(...))*<span class="hljs-number"><span class="hljs-number">1.5</span></span><span class="hljs-number"><span class="hljs-number">-0.25</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Le résultat ressemble immédiatement aux structures des nuages: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ha/pf/em/hapfemxrqrxuqfpckajp53j4zxc.png"></div><br>  Pour les nuages, vous devez obtenir deux textures spéciales.  Le premier a une taille de 128x128x128 et est responsable du bruit basse fréquence, le second a une taille de 32x32x32 et est responsable du bruit haute fréquence.  Chaque texture utilise un seul canal au format R8.  Dans certains exemples, 4 canaux de R8G8B8A8 sont utilisés pour la première texture et trois canaux de R8G8B8 pour la seconde, puis les canaux sont mélangés dans un shader.  Je ne vois pas l’intérêt, car le mixage peut être fait à l’avance, obtenant ainsi un plus grand succès dans la cohérence du cache. <br><br>  Pour le mixage, et aussi à certains endroits, la fonction remap () sera utilisée, qui met à l'échelle les valeurs d'une plage à l'autre: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMinValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMaxValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newMinValue+(value-minValue)/(maxValue-minValue)*(newMaxValue-newMinValue); }</code> </pre> <br>  Commençons à préparer la texture avec un bruit basse fréquence: <br>  Canal R - bruit fBm de Perlin <br>  Canal G - bruit FBm Vorley en mosaïque <br>  Canal B - bruit Worley fBm plus petit avec une échelle plus petite <br>  Canal A - Bruit fBm variable de Varley avec une échelle encore plus petite <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/_9/z-/ms_9z-hofvyvya5-zuh6vpi6da0.png"></div><br>  Le mixage se fait de cette façon: <br><br><pre> <code class="cpp hljs">finalValue=remap(noise.x, (noise.y * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.z*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.w * <span class="hljs-number"><span class="hljs-number">0.125</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Résultat pour une tranche 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/64/qh/rl/64qhrl3wl2vrsbedao4fk9zr3xg.png"></div><br>  Maintenant, préparez la texture avec un bruit haute fréquence: <br>  Canal R - bruit FBm Vorley en mosaïque <br>  Canal G - Bruit Vorley fBm à plus petite échelle <br>  Canal B - Bruit Varley taylivaya fBm avec une échelle encore plus petite <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/m6/in/oxm6inosejxwrkx2kdz7zv17eea.png"></div><br><pre> <code class="cpp hljs">finalValue=noise.x * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.y*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.z * <span class="hljs-number"><span class="hljs-number">0.125</span></span>;</code> </pre> <br>  Résultat pour une tranche 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lg/mr/mc/lgmrmc2ohi3ayicwbji49fdhqb4.png"></div><br>  Nous avons également besoin d'une carte texture-météo 2D qui déterminera la présence, la densité et la forme des nuages, en fonction des coordonnées de l'espace.  Il est peint par des artistes pour affiner la couverture nuageuse.  L'interprétation des canaux de couleur de la carte météo peut être différente, dans la version que j'ai prêtée, elle est la suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/oi/m8/fuoim8wbtdzgqoc2lma8g6gb0ow.png"></div><br>  Canal R - couverture nuageuse à basse altitude <br>  Canal G - couverture nuageuse à haute altitude <br>  Canal B - hauteur maximale des nuages <br>  Canal A - densité des nuages <br><br>  Nous sommes maintenant prêts à créer une fonction qui renverra la densité des nuages ​​en fonction des coordonnées de l'espace 3D. <br><br>  A l'entrée, un point dans l'espace avec coordonnées en km <br><br><pre> <code class="cpp hljs">vec3 position</code> </pre> <br>  Ajoutez immédiatement le décalage au vent <br><br><pre> <code class="cpp hljs">position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time;</code> </pre> <br>  Obtenez les valeurs de la carte météo <br><br><pre> <code class="cpp hljs">vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre>  On obtient le pourcentage de hauteur (de 0 à 1) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position);</code> </pre> <br>  Ajoutez un petit arrondi des nuages ​​ci-dessous: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Nous faisons une diminution linéaire de la densité à 0 avec une hauteur croissante selon le canal B de la carte météo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Combinez le résultat: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt;</code> </pre> <br>  Ajoutez à nouveau l'arrondi des nuages ​​ci-dessous: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Ajoutez également l'arrondi des nuages ​​sur le dessus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Nous combinons le résultat, nous ajoutons ici l'influence de la densité de la carte météo et l'influence de la densité, qui est définie via gui: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density;</code> </pre> <br>  Combinez le bruit basse fréquence et haute fréquence de nos textures: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>;</code> </pre> <br>  Dans tous les documents que j'ai lus, la fusion se déroule différemment, mais j'ai bien aimé cette option. <br><br>  Nous déterminons la quantité de couverture (% du ciel occupé par les nuages), qui est définie via gui, les canaux R et G de la carte météo sont également utilisés: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Calculez la densité finale: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA;</code> </pre> <br>  Fonction entière: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position)</span></span></span><span class="hljs-function"> </span></span>{ position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time; vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>+vec2(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d; }</code> </pre> <br>  Quelle doit être exactement cette fonction est une question ouverte, car en ignorant les lois auxquelles les nuages ​​obéissent lors de la définition des paramètres, vous pouvez obtenir un résultat très inhabituel et magnifique.  Tout dépend de l'application. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/nz/bz/tfnzbzvd2oucw2h_oed9pbm_8ku.png"></div><br><h2>  Intégration </h2><br>  L'atmosphère de la Terre est divisée en deux couches: interne et externe, entre lesquelles les nuages ​​peuvent être situés.  Ces couches peuvent être représentées par des sphères, mais aussi par des plans.  Je me suis installé sur les sphères.  Pour la première couche, j'ai pris le rayon de sphère de 6415 km, pour la deuxième couche, le rayon de 6435 km.  Le rayon de la terre arrondi à 6400 km.  Certains paramètres dépendront de l'épaisseur conditionnelle de la partie «nuageuse» de l'atmosphère (20 km). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0z/ir/8r/0zir8r9qtvwlh9xk85i-hznhqa0.png"></div><br><br>  Contrairement au ciel, les nuages ​​sont opaques et l'intégration nécessite non seulement d'obtenir la couleur, mais également d'obtenir la valeur du canal alpha.  Vous avez d'abord besoin d'une fonction qui renvoie la densité totale du nuage à travers laquelle passera un rayon de lumière du soleil. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5k/ne/lj/5kneljw4unaofsxxgbq12ealebw.png"></div><br>  Personne n'attire l'attention sur cela, mais la pratique a montré qu'il n'est pas du tout nécessaire de prendre en compte l'intégralité du trajet du faisceau, seul l'écart le plus extrême est nécessaire.  Nous supposons que les nuages ​​au-dessus d'un segment tronqué n'existent pas du tout. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/sr/ly/edsrlyis3-2or1nztj6q-osmats.png"></div><br>  De plus, nous sommes très limités dans le nombre d'échantillons de densité qui peuvent être réalisés sans nuire aux performances.  Guerrilla Games do 6. De plus, dans l'une des présentations, le développeur a déclaré qu'ils dispersent ces échantillons à l'intérieur du cône, et le dernier échantillon est spécialement conçu très loin du reste pour couvrir autant d'espace que possible.  Les imprécisions et le bruit qui en résultent seront toujours lissés sur le fond des échantillons voisins, et cela, au contraire, se traduira par une précision accrue. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/rr/df/5prrdfocofvzsjobvawnairijp0.png"></div><br>  Au final, je me suis installé sur 4 échantillons qui se trouvent sur la même ligne, mais cette dernière est prise avec un pas multiplié par 6.  Le pas est de 20 km * 0,01, soit 200 m. <br><br>  La fonction est assez simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDirectDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   float avrStep=(6435.0-6415.0)*0.01; float sumDensity=0.0; for(int i=0;i&lt;4;i++) { float step=avrStep; //      6 if(i==3) step=step*6.0; //  position+=sunDir*step; //  ,  ,   //  float density=cloudSampleDensity(position)*step; sumDensity+=density; } return sumDensity; }</span></span></code> </pre> <br>  Vous pouvez maintenant passer à la partie la plus difficile.  Nous déterminons l'observateur à la surface de la Terre au point {0, 6400,0} et trouvons l'intersection du faisceau d'observation avec une sphère de rayon 6415 km et de centre {0,0,0} - nous obtenons le point de départ S. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/25/je/zj/25jezjeea4j3bl51jneypfjetsi.png"></div><br>  Voici la version de base de la fonction: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { position+=viewDir*step; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); }</code> </pre> <br>  La taille de l'étape est définie comme 20 km / 64, c'est-à-dire  dans le cas de la direction strictement verticale du faisceau de l'observateur, nous réaliserons 64 échantillons.  Cependant, lorsque cette direction est plus horizontale, les échantillons seront légèrement plus grands, il n'y a donc pas 64 étapes dans le cycle, mais 128 avec une marge. <br><br>  Au début, nous supposons que la couleur finale est le noir et la transparence est l'unité.  À chaque étape, nous augmenterons la valeur de couleur et diminuerons la valeur de transparence.  Si la transparence est proche de 0, vous pouvez pré-quitter la boucle: <br><br><pre> <code class="cpp hljs">vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; … <span class="hljs-comment"><span class="hljs-comment">//    //      float density=cloudSampleDensity(position)*avrStep; //   ,   //   float sunDensity=cloudSampleDirectDensity(position, sunDir); //      float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*m2*m3; //       color+=sunColor*light*transmittance; transmittance*=exp(-ufmProperties.attenuation*density); … return vec4(color, 1.0-transmittance);</span></span></code> </pre> <br>  ufmProperties.attenuation - Il n'y a que C dans <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg">  et ufmProperties.attenuation2 est C dans <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  .  ufmProperties.sunIntensity - l'intensité de rayonnement du soleil.  sunColor - la couleur du soleil. <br><br>  Résultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/ft/z9/vcftz9vsswkxpqoggirezpfpygm.png"></div><br>  Un défaut est immédiatement évident - un ombrage sévère.  Mais maintenant, nous allons corriger le manque d'éclairage amplifié près du soleil.  Cela s'est produit parce que nous n'avons pas ajouté de fonction de phase.  Pour calculer la diffusion de la lumière traversant les nuages, la fonction de phase de Hengy-Greenstein est utilisée, qui l'a ouverte en 1941 pour des calculs similaires dans des amas de gaz dans l'espace: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b0/b2e/33f/4b0b2e33fbd07036b14317d40cb1eac0.svg"></div><br>  Une digression devrait être faite ici.  Selon le modèle d'éclairage canonique, la fonction de phase devrait être une.  Cependant, en réalité, le résultat obtenu ne convient à personne et chacun utilise des fonctions à deux phases, et combine même ses valeurs de manière particulière.  Je me suis également concentré sur les fonctions à deux phases, mais j'additionne simplement leurs valeurs.  La fonction de la première phase a g proche de 1 et vous permet de faire un éclairage lumineux près du soleil.  La fonction de la deuxième phase a g proche de 0,5 et vous permet de diminuer progressivement l'illumination dans toute la sphère céleste. <br><br>  Code mis à jour: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// cos(theta) float mu=max(0, dot(viewDir, sunDir)); float m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); float m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*(m11+m12)*m2*m3;</span></span></code> </pre> <br>  ufmProperties.eccentrisy, ufmProperties.eccentrisy2 sont des valeurs g <br><br>  Résultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ip/qr/fi/ipqrfivyafyxnmdswnn_nbpvfdk.png"></div><br>  Vous pouvez maintenant commencer le combat avec trop d'ombrage.  Elle est présente car nous n'avons pas tenu compte de la lumière des nuages ​​environnants et du ciel, qui est dans la vraie vie. <br><br>  J'ai résolu ce problème comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(color+ambientColor*ufmProperties.ambient, <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br>  Où ambientColor est la couleur du ciel dans la direction du faisceau d'observation, ufmProperties.ambient est le paramètre de réglage. <br><br>  Résultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/8h/ji/ct8hjiyk7brz5pv8vuwjeji33bc.png"></div><br>  Reste à résoudre le dernier problème.  Dans la vraie vie, plus la vue est horizontale, plus nous voyons un certain brouillard ou brume qui ne nous permet pas de voir des objets très éloignés.  Cela doit également se refléter dans le code.  J'ai pris le cosinus habituel de l'angle de regard et de la fonction exponentielle.  Sur cette base, un certain coefficient de fusion est calculé, ce qui permet une interpolation linéaire entre la couleur résultante et la couleur d'arrière-plan. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br>  ufmProperties.fog - pour une configuration manuelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/02/td/9h/02td9ho6kelgum68wldvcf-zymu.png"></div><br>  Fonction récapitulative: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir, vec3 sunColor, vec3 ambientColor)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> density=cloudSampleDensity(position)*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(density&gt;<span class="hljs-number"><span class="hljs-number">0.0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sunDensity=cloudSampleDirectDensity(position, sunDir); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mu=max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, sunDir)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m2=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*sunDensity); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m3=ufmProperties.attenuation2*density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> light=ufmProperties.sunIntensity*(m11+m12)*m2*m3; color+=sunColor*light*transmittance; transmittance*=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*density); } position+=viewDir*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(transmittance&lt;<span class="hljs-number"><span class="hljs-number">0.05</span></span> || length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance); }</code> </pre> <br>  Vidéo de démonstration: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uPxVgbwThmI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Optimisation et améliorations possibles </h2><br>  Après avoir implémenté l'algorithme de rendu de base, le problème suivant est qu'il fonctionne trop lentement.  Ma version a produit 25 fps en full hd sur la radeon rx 480. Les deux approches suivantes pour résoudre le problème ont été suggérées par Guerrilla Games lui-même. <br><br>  <b>Nous dessinons ce qui est vraiment visible</b> <br><br>  L'écran est divisé en tuiles de 16 x 16 pixels.  Tout d'abord, l'environnement 3D habituel est dessiné.  Il s'avère que la majeure partie du ciel est couverte de montagnes ou de gros objets.  Par conséquent, vous devez effectuer le calcul uniquement dans les tuiles dans lesquelles les nuages ​​ne sont bloqués par rien. <br><br>  <b>Reprojection</b> <br><br>  Lorsque la caméra est immobile, il s'avère que les nuages ​​en général ne peuvent pas être mis à jour.  Cependant, si la caméra a bougé, cela ne signifie pas que nous devons mettre à jour tout l'écran.  Tout est déjà dessiné, il vous suffit de reconstruire l'image en fonction des nouvelles coordonnées.  La recherche d'anciennes coordonnées sur de nouvelles, à travers les matrices de projection et de visualisation des images actuelles et précédentes, s'appelle projection.  Ainsi, dans le cas d'un décalage de caméra, nous transférons simplement les couleurs en fonction des nouvelles coordonnées.  Dans les cas où ces coordonnées indiquent hors écran, les nuages ​​doivent être redessinés honnêtement. <br><br>  <b>Mise à jour partielle</b> <br><br>  Je n'aime pas l'idée de la reprojection, car avec un virage serré de la caméra, il peut s'avérer que les nuages ​​devront être rendus pour un tiers de l'écran, ce qui peut provoquer un décalage.  Je ne sais pas comment Guerrilla Games a géré cela, mais au moins dans Horizon Zero Dawn, lorsque vous contrôlez le joystick, la caméra se déplace en douceur et il n'y a aucun problème avec des sauts brusques.  Par conséquent, en tant qu'expérience, j'ai trouvé ma propre approche.  Les nuages ​​sont dessinés sur une carte cubique, en 5 faces, car  le fond ne nous intéresse pas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le côté de la carte cubique a une résolution réduite égale aux ⅔ de la hauteur de l'écran. Chaque face de la carte cubique est divisée en tuiles 8x8. Chaque image sur chaque face est mise à jour avec un seul des 64 pixels dans chaque mosaïque. Cela donne des artefacts perceptibles lors de changements soudains, mais parce que les nuages ​​sont assez statiques, alors une telle astuce est invisible. En conséquence, le radeon rx 480 produit 500 fps en full hd pour le volcan et 330 fps pour opengl. La série Radeon hd 5700 produit 109 images par seconde en full hd sous opengl (vulkan ne prend pas en charge). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation des niveaux de mip</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsque vous accédez à des textures avec du bruit, vous pouvez prendre des données du niveau de mip zéro uniquement dans les tout premiers échantillons, puis plus les échantillons que nous faisons sont élevés, plus le niveau de mip peut être élevé. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuages ​​élevés</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour simuler la présence de cirrus-altitude et de cirrocumulus dans Guerrilla Games lors de l'intégration, les derniers échantillons ne sont pas fabriqués à partir des textures 3D dont j'ai parlé, mais à partir d'une texture 2D spéciale. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/f2/vj/udf2vjpfht0hhpbf9zptwfmadhg.jpeg"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bruit</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de courbure Plusieurs textures supplémentaires dans le bruit de courbure sont utilisées pour créer l'effet des nuages ​​de vent. </font><font style="vertical-align: inherit;">Ces textures sont nécessaires pour déplacer les coordonnées d'origine.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-n/qq/pg/-nqqpgmixyogyjxqrdyhm4oxlpc.png"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rayons divins</font></font></b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qd/wq/xv/qdwqxvzveiwuxgu2v84aw5fhjwo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces rayons, captant les drames, sont réalisés en post-traitement. </font><font style="vertical-align: inherit;">Tout d'abord, un éclairage brillant est dessiné autour du soleil, où il n'est pas bloqué par les nuages. </font><font style="vertical-align: inherit;">Ensuite, ce rétro-éclairage doit être radialement décalé par rapport au soleil.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/vj/-a/apvj-assr02-vaov3o1k5frfawk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous devez maintenant appliquer un lissage radial. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/lg/1h/jdlg1hp7jajzhlbom4ocmn3vl70.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, il y a beaucoup plus d'améliorations et de subtilités, mais je ne les ai pas toutes vérifiées, donc je ne peux pas les dire avec confiance. Cependant, vous pouvez vous familiariser avec eux. Le plus fort je pense est la documentation cloud du moteur Frostbite.</font></font><br><br><h2>  Liens utiles </h2><br> <b> Guerrilla Games</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d1z4o56rleaq4j.cloudfront.net/downloads/assets/Nubis-Authoring-Realtime-Volumetric-Cloudscapes-with-the-Decima-Engine-Final.pdf?mtime=20170807141817</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">killzone.dl.playstation.net/killzone/horizonzerodawn/presentations/Siggraph15_Schneider_Real-Time_Volumetric_Cloudscapes_of_Horizon_Zero_Dawn.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.youtube.com/watch?v=-d8qT5-1LOI</a> <br><br> <b>  GPU Pro 7</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vk.com/doc179245989_437393482?hash=a9af5f665eda4edf58&amp;dl=806d4dbdac0f7a761c</a> <br><br> <b></b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky</a> <br><br> <b> Frostbite</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.shadertoy.com/view/XlBSRz</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459948/">https://habr.com/ru/post/fr459948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459924/index.html">Cycle d'essai complet de React. Rapport Auto.ru</a></li>
<li><a href="../fr459928/index.html">Parcours de l'étudiant vers le développement d'applications mobiles</a></li>
<li><a href="../fr459930/index.html">Automatisation de l'importation Python</a></li>
<li><a href="../fr459934/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 306 (du 8 au 14 juillet)</a></li>
<li><a href="../fr459936/index.html">9 astuces supplémentaires pour travailler avec Visual Studio</a></li>
<li><a href="../fr459952/index.html">Un peu d'expérience sur la sauvegarde et le stockage</a></li>
<li><a href="../fr459954/index.html">Pourquoi l'une des plus grandes sociétés informatiques a rejoint CNCF - un fonds développant une infrastructure cloud</a></li>
<li><a href="../fr459956/index.html">Implantation en l'absence totale de dents, suite à des visites intempestives chez le dentiste</a></li>
<li><a href="../fr459958/index.html">Tâches d'analyse de la conférence Hydra - équilibrage de charge et stockage en mémoire</a></li>
<li><a href="../fr459960/index.html">De l'idée à la sortie. Expérience détaillée du marché frontal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>