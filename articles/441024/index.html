<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥ üí± üî¨ Escribimos un rastreador para uno o dos 1.0 ‚ö†Ô∏è üë©‚Äçüë©‚Äçüëß‚Äçüëß üéê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un rastreador web (o ara√±a web) es una parte importante de los motores de b√∫squeda para rastrear p√°ginas web con el fin de ingresar informaci√≥n sobre ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos un rastreador para uno o dos 1.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/441024/">  Un <b>rastreador</b> web (o ara√±a web) es una parte importante de los motores de b√∫squeda para rastrear p√°ginas web con el fin de ingresar informaci√≥n sobre ellas en bases de datos, principalmente para su posterior indexaci√≥n.  Los motores de b√∫squeda (Google, Yandex, Bing), as√≠ como los productos SEO (SEMrush, MOZ, ahrefs) y no solo tienen tal cosa.  Y esto es bastante interesante: tanto en t√©rminos de potencial y casos de uso, como para la implementaci√≥n t√©cnica. <br><br><img src="https://habrastorage.org/webt/vw/pi/-9/vwpi-9jp8-dypdtmlh58qqa1nm0.jpeg"><br><br>  Con este art√≠culo, comenzaremos a crear <b>iterativamente</b> su <s>bicicleta de</s> orugas, analizando muchas caracter√≠sticas y enfrentando dificultades.  Desde una simple funci√≥n recursiva hasta un servicio escalable y extensible.  Debe ser interesante! <br><a name="habracut"></a><br><h3>  Introducci√≥n </h3><br>  Iterativamente: significa que al final de cada lanzamiento se espera una versi√≥n lista para usar del "producto" con las limitaciones, caracter√≠sticas e interfaz acordadas. <br><br>  <b>Se</b> eligieron <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Node.js</a> y <b>JavaScript</b> como plataforma e idioma, porque es simple y as√≠ncrono.  Por supuesto, para el desarrollo industrial, la elecci√≥n de la base tecnol√≥gica debe basarse en los requisitos, expectativas y recursos del negocio.  Como demostraci√≥n y prototipo, esta plataforma es completamente nada (en mi humilde opini√≥n). <br><br><blockquote>  Este es mi rastreador.  Hay muchos de estos rastreadores, pero este es el m√≠o. <br>  Mi rastreador es mi mejor amigo. <br></blockquote><br>  La implementaci√≥n del rastreador es una tarea bastante popular y se puede encontrar incluso en entrevistas t√©cnicas.  Realmente hay muchas soluciones preparadas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apache Nutch</a> ) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">autoescritas</a> para diferentes condiciones y en muchos idiomas.  Por lo tanto, cualquier comentario de experiencia personal en desarrollo o uso es bienvenido y ser√° interesante. <br><br><h3>  Declaraci√≥n del problema. </h3><br>  La tarea para la primera implementaci√≥n (inicial) de nuestro <s>rastreador tyap-blooper</s> ser√° la siguiente: <br><br><blockquote>  <b>One-Two Crawler 1.0</b> <br>  Escriba un script de rastreador que omita los enlaces internos <i>&lt;a href /&gt;</i> de un sitio peque√±o (hasta 100 p√°ginas).  Como resultado, proporcione una lista de URL de p√°ginas con los c√≥digos recibidos y un mapa de sus enlaces.  Se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ignoran las</a> reglas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">robots.txt</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">atributo de</a> enlace <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rel = nofollow</a> . </blockquote><br>  <b>Atencion</b>  Ignorar las reglas de <i>robots.txt</i> es una mala idea por razones obvias.  Vamos a compensar esta omisi√≥n en el futuro.  Mientras tanto, agregue el par√°metro l√≠mite que limita el n√∫mero de p√°ginas a rastrear para que no detenga DoS y pruebe el sitio experimental (es mejor usar su propio "sitio de h√°mster" personal para experimentos). <br><br><h3>  Implementaci√≥n </h3><br>  Para los impacientes, <a href="">aqu√≠ est√°n las fuentes de</a> esta soluci√≥n. <br><br><ol><li>  Cliente HTTP (S) </li><li>  Opciones de respuesta </li><li>  Extracci√≥n de enlaces </li><li>  Preparaci√≥n de enlaces y filtrado </li><li>  Normalizaci√≥n de URL </li><li>  Algoritmo de funci√≥n principal </li><li>  Resultado devuelto </li></ol><br><h4>  1. Cliente HTTP (S) </h4><br>  Lo primero que debemos poder hacer es, de hecho, enviar solicitudes y recibir respuestas a trav√©s de HTTP y HTTPS.  En node.js hay dos clientes coincidentes para esto.  Por supuesto, puede tomar una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitud de cliente ya hecha</a> , pero para nuestra tarea es extremadamente redundante: solo necesitamos enviar una solicitud GET y obtener una respuesta con el cuerpo y los encabezados. <br><br>  La API de los dos clientes que necesitamos es id√©ntica, crearemos un mapa: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clients = { <span class="hljs-string"><span class="hljs-string">'http:'</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>), <span class="hljs-string"><span class="hljs-string">'https:'</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) };</code> </pre> <br>  Declaramos una funci√≥n simple <i>fetch</i> , cuyo √∫nico par√°metro ser√° la URL <b>absoluta</b> de la cadena de recursos web deseada.  Usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el m√≥dulo url,</a> analizaremos la cadena resultante en un objeto URL.  Este objeto tiene un campo con el protocolo (con dos puntos), por el cual elegiremos el cliente apropiado: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dstURL = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(dst); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = clients[dstURL.protocol]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!client) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Could not select a client for '</span></span> + dstURL.protocol); } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  A continuaci√≥n, use el cliente seleccionado y ajuste el resultado de la funci√≥n de <i>b√∫squeda</i> en una promesa: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... let req = client.get(dstURL.href, res =&gt; { // do something with the response }); req.on('error', err =&gt; reject('Failed on the request: ' + err.message)); req.end(); }); }</span></span></code> </pre><br><br>  Ahora podemos recibir una respuesta asincr√≥nica, pero por ahora no estamos haciendo nada con ella. <br><br><h4>  2. Opciones de respuesta </h4><br>  Para rastrear el sitio, es suficiente procesar 3 opciones de respuesta: <br><br><ol><li>  <b>OK</b> : se recibi√≥ un c√≥digo de estado 2xx.  Es necesario guardar el cuerpo de la respuesta como resultado para un procesamiento posterior, extrayendo nuevos enlaces. </li><li>  <b>REDIRECT</b> : se recibi√≥ un c√≥digo de estado 3xx.  Esta es una redirecci√≥n a otra p√°gina.  En este caso, necesitaremos el encabezado de respuesta de <i>ubicaci√≥n</i> , desde donde tomaremos un solo enlace "saliente". </li><li>  <b>NO_DATA</b> : todos los dem√°s casos: 4xx / 5xx y 3xx sin el encabezado <i>Ubicaci√≥n</i> .  No hay ning√∫n lugar para ir m√°s all√° de nuestro rastreador. </li></ol><br>  La funci√≥n de <i>b√∫squeda</i> resolver√° la respuesta procesada que indica su tipo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ft = { <span class="hljs-string"><span class="hljs-string">'OK'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// code (2xx), content 'REDIRECT': 2, // code (3xx), location 'NO_DATA': 3 // code };</span></span></code> </pre><br>  Implementaci√≥n de la estrategia de generar el resultado en las mejores tradiciones de <i>if-else</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code = res.statusCode; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> codeGroup = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(code / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-comment"><span class="hljs-comment">// OK if (codeGroup === 2) { let body = []; res.setEncoding('utf8'); res.on('data', chunk =&gt; body.push(chunk)); res.on('end', () =&gt; resolve({ code, content: body.join(''), type: ft.OK })); } // REDIRECT else if (codeGroup === 3 &amp;&amp; res.headers.location) { resolve({ code, location: res.headers.location, type: ft.REDIRECT }); } // NO_DATA (others) else { resolve({ code, type: ft.NO_DATA }); }</span></span></code> </pre><br>  La funci√≥n de <i>recuperaci√≥n</i> est√° lista para usar: <a href="">el c√≥digo de funci√≥n completo</a> . <br><br><h4>  3. Extracci√≥n de enlaces. </h4><br>  Ahora, dependiendo de la variante de la respuesta recibida, debe poder extraer enlaces de los datos de resultados de la <i>b√∫squeda</i> para un mayor rastreo.  Para hacer esto, definimos la funci√≥n de <i>extracci√≥n</i> , que toma un objeto de resultado como entrada y devuelve una matriz de nuevos enlaces. <br><br>  Si el tipo de resultado es REDIRECTO, la funci√≥n devolver√° una matriz con una sola referencia desde el campo de <i>ubicaci√≥n</i> .  Si NO_DATA, entonces una matriz vac√≠a.  Si est√° bien, entonces necesitamos conectar el analizador para el <i>contenido de</i> texto presentado para la b√∫squeda. <br><br>  Para la tarea de b√∫squeda <i>&lt;a href /&gt;,</i> tambi√©n puede escribir una expresi√≥n regular.  Pero esta soluci√≥n no escala en absoluto, ya que en el futuro al menos prestaremos atenci√≥n a otros atributos ( <i>rel</i> ) del enlace, como m√°ximo, pensaremos en <i>img</i> , <i>enlace</i> , <i>script</i> , <i>audio / video</i> ( <i>fuente</i> ) y otros recursos.  Es mucho m√°s prometedor y m√°s conveniente analizar el texto del documento y construir un √°rbol de sus nodos para evitar los selectores habituales. <br><br>  Usaremos la popular biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JSDOM</a> para trabajar con DOM en node.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { JSDOM } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'jsdom'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSDOM(fetched.content).window.document; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> elements = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'A'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(elements) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.getAttribute(<span class="hljs-string"><span class="hljs-string">'href'</span></span>)) .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">href</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> href === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">href</span></span></span><span class="hljs-function"> =&gt;</span></span> href.trim()) .filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>);</code> </pre><br>  Obtenemos todos los elementos <i>A</i> del documento y luego todos los valores filtrados del atributo <i>href</i> , si no l√≠neas vac√≠as. <br><br><h4>  4. Preparaci√≥n y filtrado de enlaces. </h4><br>  Como resultado del extractor, tenemos un conjunto de enlaces (URL) y dos problemas: 1) la URL puede ser relativa y 2) la URL puede conducir a un recurso externo (ahora solo necesitamos los internos). <br><br>  El primer problema ser√° ayudado por la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">url.resolve</a> , que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">resuelve la</a> URL de la p√°gina de destino en relaci√≥n con la URL de la p√°gina de origen. <br><br>  Para resolver el segundo problema, escribimos una funci√≥n de utilidad simple <i>enScope</i> que verifica el host de la p√°gina de destino con el host de la URL base del rastreo actual: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLowerHost</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(dst)).hostname.toLowerCase(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inScope</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst, base</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dstHost = getLowerHost(dst); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> baseHost = getLowerHost(base); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = dstHost.indexOf(baseHost); <span class="hljs-comment"><span class="hljs-comment">// the same domain or has subdomains return i === 0 || dstHost[i - 1] === '.'; }</span></span></code> </pre><br>  La funci√≥n busca una subcadena ( <i>baseHost</i> ) con una comprobaci√≥n del car√°cter anterior si se encontr√≥ la subcadena: dado que <i>wwwexample.com</i> y <i>example.com</i> son dominios diferentes.  Como resultado, no abandonamos el dominio dado, sino que omitimos sus subdominios. <br><br>  Refinamos la funci√≥n de <i>extracci√≥n</i> agregando "absolutizaci√≥n" y filtrando los enlaces resultantes: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fetched, src, base</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> extractRaw(fetched) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">href</span></span></span><span class="hljs-function"> =&gt;</span></span> url.resolve(src, href)) .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function"> =&gt;</span></span> /^https?\:\/\<span class="hljs-comment"><span class="hljs-comment">//i.test(dst)) .filter(dst =&gt; inScope(dst, base)); }</span></span></code> </pre><br>  Aqu√≠ <i>recuperado</i> es el resultado de la funci√≥n de <i>obtenci√≥n</i> , <i>src</i> es la URL de la p√°gina de origen, <i>base</i> es la URL base del rastreo.  En la salida, obtenemos una lista de enlaces internos (URL) ya absolutos para su posterior procesamiento.  El c√≥digo completo de la funci√≥n se puede <a href="">ver aqu√≠</a> . <br><br><h4>  5. Normalizaci√≥n de URL </h4><br>  Una vez que haya encontrado cualquier URL nuevamente, no es necesario enviar otra solicitud para el recurso, ya que los datos ya se han recibido (u otra conexi√≥n a√∫n est√° abierta y esperando una respuesta).  Pero no siempre es suficiente comparar las cadenas de dos URL para comprender esto.  La normalizaci√≥n es el procedimiento necesario para determinar la equivalencia de URL sint√°cticamente diferentes. <br><br>  El proceso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">normalizaci√≥n</a> es un conjunto completo de transformaciones aplicadas a la URL de origen y sus componentes.  Estos son solo algunos de ellos: <br><br><ul><li>  El esquema y el host no distinguen entre may√∫sculas y min√∫sculas, por lo que se deben convertir a inferiores. </li><li>  Todos los porcentajes (como "% 3A") deben estar en may√∫sculas. </li><li>  El puerto predeterminado (80 para HTTP) se puede eliminar. </li><li>  El fragmento ( <i>#</i> ) nunca es visible para el servidor y tambi√©n se puede eliminar. </li></ul><br>  Siempre puede tomar algo listo (por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">normalizar-url</a> ) o escribir su propia funci√≥n simple que cubra los casos m√°s importantes y comunes: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dstUrl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(dst); <span class="hljs-comment"><span class="hljs-comment">// ignore userinfo (auth property) let origin = dstUrl.protocol + '//' + dstUrl.hostname; // ignore http(s) standart ports if (dstUrl.port &amp;&amp; (!/^https?\:/i.test(dstUrl.protocol) || ![80, 8080, 443].includes(+dstUrl.port))) { origin += ':' + dstUrl.port; } // ignore fragment (hash property) let path = dstUrl.pathname + dstUrl.search; // convert origin to lower case return origin.toLowerCase() // and capitalize letters in escape sequences + path.replace(/%([0-9a-f]{2})/ig, (_, es) =&gt; '%' + es.toUpperCase()); }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Por si acaso, el formato del objeto URL</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/zs/te/jr/zstejr_mjpparhgrr4aar6ma7nq.png"><br></div></div><br>  S√≠, no hay clasificaci√≥n de los par√°metros de consulta, ignorando las etiquetas utm, procesando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">_escaped_fragment_</a> y otras cosas, que (absolutamente) no necesitamos en absoluto. <br><br>  A continuaci√≥n, crearemos un cach√© local de URL normalizadas solicitadas por el marco de rastreo.  Antes de enviar la siguiente solicitud, normalizamos la URL recibida y, si no est√° en el cach√©, la agregamos y solo luego enviamos una nueva solicitud. <br><br><h4>  6. El algoritmo de la funci√≥n principal. </h4><br>  Los componentes clave (primitivos) de la soluci√≥n est√°n listos, es hora de comenzar a recopilar todo junto.  Para comenzar, determinemos la firma de la funci√≥n de <i>rastreo</i> : en la entrada, la URL de inicio y el l√≠mite de p√°gina.  La funci√≥n devuelve una promesa cuya resoluci√≥n proporciona un resultado acumulado;  escr√≠belo en el archivo de <i>salida</i> : <br><br><pre> <code class="javascript hljs">crawl(start, limit).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { fs.writeFile(output, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(result), <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, err =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; }); });</code> </pre><br>  El flujo de trabajo recursivo m√°s simple de la funci√≥n de rastreo se puede describir en pasos: <br><br><blockquote>  1. Inicializaci√≥n de la cach√© y el objeto de resultado. <br>  2. SI la URL de la p√°gina de destino (a trav√©s de <b>normalizar</b> ) no est√° en el cach√©, ENTONCES <br>  - 2.1.  Si <i>se</i> alcanza el <i>l√≠mite</i> , FIN (esperar el resultado) <br>  - 2.2.  Agregar URL a la cach√© <br>  - 2.3.  Guardar el enlace entre la fuente y la p√°gina de destino en el resultado <br>  - 2.4.  Enviar solicitud asincr√≥nica por p√°gina ( <b>buscar</b> ) <br>  - 2.5.  SI la solicitud es exitosa, ENTONCES <br>  - - 2.5.1.  Extraer nuevos enlaces del resultado ( <b>extraer</b> ) <br>  - - 2.5.2.  Para cada nuevo enlace, ejecute el algoritmo 2-3 <br>  - 2.6.  ELSE marca la p√°gina como un error <br>  - 2.7.  Guardar los datos de la p√°gina para obtener el resultado <br>  - 2.8.  SI esta fue la √∫ltima p√°gina, traiga el resultado <br>  3. ELSE guarda el enlace entre la fuente y la p√°gina de destino en el resultado <br></blockquote><br>  <b>S√≠, este algoritmo sufrir√° cambios importantes en el futuro.</b>  Ahora, una soluci√≥n recursiva se usa deliberadamente en la frente, para que luego sea mejor "sentir" la diferencia en las implementaciones.  La pieza de trabajo para la implementaci√≥n de la funci√≥n se ve as√≠: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crawl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start, limit = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// initialize cache &amp; result return new Promise((resolve, reject) =&gt; { function curl(src, dst) { // check dst in the cache &amp; pages limit // save the link (src -&gt; dst) to the result fetch(dst).then(fetched =&gt; { extract(fetched, dst, start).forEach(ln =&gt; curl(dst, ln)); }).finally(() =&gt; { // save the page's data to the result // check completion and resolve the result }); } curl(null, start); }); }</span></span></code> </pre><br>  El logro del l√≠mite de p√°gina se verifica mediante un simple contador de solicitudes.  El segundo contador, el n√∫mero de solicitudes activas a la vez, servir√° como una prueba de preparaci√≥n para dar el resultado (cuando el valor se convierte en cero).  Si la funci√≥n de <i>recuperaci√≥n</i> no pudo obtener la siguiente p√°gina, configure el C√≥digo de estado como nulo. <br><br>  Puede (opcionalmente) <a href="">familiarizarse</a> con el c√≥digo de implementaci√≥n <a href="">aqu√≠</a> , pero antes de eso debe considerar el formato del resultado devuelto. <br><br><h4>  7. Resultado devuelto </h4><br>  Introduciremos un <i>identificador de</i> identificaci√≥n √∫nico con un incremento simple para las p√°ginas encuestadas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cache = {}; <span class="hljs-comment"><span class="hljs-comment">// ... let dstNorm = normalize(dst); if (dstNorm in cache === false) { cache[dstNorm] = ++id; // ... }</span></span></code> </pre><br>  Para el resultado, crearemos una matriz de <i>p√°ginas</i> en las que agregaremos objetos con datos en la p√°gina: <i>id</i> {n√∫mero}, <i>url</i> {cadena} y <i>c√≥digo</i> {n√∫mero | nulo} (esto es suficiente).  Tambi√©n creamos una matriz de <i>enlaces</i> para enlaces entre p√°ginas en forma de un objeto: <i>desde</i> ( <i>id de</i> la p√°gina de origen) <i>hasta</i> ( <i>id de la</i> p√°gina de destino). <br><br>  Con fines informativos, antes de resolver el resultado, clasificamos la lista de p√°ginas en orden ascendente de <i>identificaci√≥n</i> (despu√©s de todo, las respuestas vendr√°n en cualquier orden), complementamos el resultado con el n√∫mero de p√°ginas de <i>conteo</i> escaneadas y una marca al llegar al l√≠mite de <i>aleta</i> especificado: <br><br><pre> <code class="javascript hljs">resolve({ <span class="hljs-attr"><span class="hljs-attr">pages</span></span>: pages.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p1, p2</span></span></span><span class="hljs-function">) =&gt;</span></span> p1.id - p2.id), <span class="hljs-attr"><span class="hljs-attr">links</span></span>: links.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l1, l2</span></span></span><span class="hljs-function">) =&gt;</span></span> l1.from - l2.from || l1.to - l2.to), count, <span class="hljs-attr"><span class="hljs-attr">fin</span></span>: count &lt; limit });</code> </pre><br><h3>  Ejemplo de uso </h3><br>  El script del rastreador terminado tiene la siguiente sinopsis: <br><br><pre> <code class="plaintext hljs">node crawl-cli.js --start="&lt;URL&gt;" [--output="&lt;filename&gt;"] [--limit=&lt;int&gt;]</code> </pre><br>  Complementando el registro de los puntos clave del proceso, veremos dicha imagen al inicio: <br><br><pre> <code class="plaintext hljs">$ node crawl-cli.js --start="https://google.com" --limit=20 [2019-02-26T19:32:10.087Z] Start crawl "https://google.com" with limit 20 [2019-02-26T19:32:10.089Z] Request (#1) "https://google.com/" [2019-02-26T19:32:10.721Z] Fetched (#1) "https://google.com/" with code 301 [2019-02-26T19:32:10.727Z] Request (#2) "https://www.google.com/" [2019-02-26T19:32:11.583Z] Fetched (#2) "https://www.google.com/" with code 200 [2019-02-26T19:32:11.720Z] Request (#3) "https://play.google.com/?hl=ru&amp;tab=w8" [2019-02-26T19:32:11.721Z] Request (#4) "https://mail.google.com/mail/?tab=wm" [2019-02-26T19:32:11.721Z] Request (#5) "https://drive.google.com/?tab=wo" ... [2019-02-26T19:32:12.929Z] Fetched (#11) "https://www.google.com/advanced_search?hl=ru&amp;authuser=0" with code 200 [2019-02-26T19:32:13.382Z] Fetched (#19) "https://translate.google.com/" with code 200 [2019-02-26T19:32:13.782Z] Fetched (#14) "https://plus.google.com/108954345031389568444" with code 200 [2019-02-26T19:32:14.087Z] Finish crawl "https://google.com" on count 20 [2019-02-26T19:32:14.087Z] Save the result in "result.json"</code> </pre><br>  Y aqu√≠ est√° el resultado en formato JSON: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"pages"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://google.com/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">301</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.google.com/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://play.google.com/?hl=ru&amp;tab=w8"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">302</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://mail.google.com/mail/?tab=wm"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">302</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://drive.google.com/?tab=wo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">302</span></span> }, // ... { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://translate.google.com/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://calendar.google.com/calendar?tab=wc"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">302</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }, // ... { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"count"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fin"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br><br>  ¬øQu√© se puede hacer con esto ya?  Como m√≠nimo, en la lista de p√°ginas puede encontrar todas las p√°ginas rotas del sitio.  Y al tener informaci√≥n sobre la vinculaci√≥n interna, puede detectar cadenas largas (y bucles cerrados) de redireccionamientos o encontrar las p√°ginas m√°s importantes por masa de referencia. <br><br><h3>  Anuncio 2.0 </h3><br>  Hemos obtenido una variante del rastreador de consola m√°s simple, que omite las p√°ginas de un sitio.  El c√≥digo fuente <a href="">est√° aqu√≠</a> .  Tambi√©n hay un ejemplo y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pruebas unitarias</a> para algunas funciones. <br><br>  Ahora, este es un remitente de solicitudes sin ceremonias y el siguiente paso razonable ser√≠a ense√±arle buenos modales.  Se tratar√° del encabezado <i>User-agent</i> , las reglas de <i>robots.txt</i> , la directiva <i>Crawl-delay</i> y m√°s.  Desde el punto de vista de la implementaci√≥n, primero se trata de poner en cola los mensajes y luego atender una carga mayor.  <i>Si, por supuesto, este material ser√° interesante!</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441024/">https://habr.com/ru/post/441024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441012/index.html">Datos interesantes sobre la historia del programa lunar chino y la misi√≥n espacial Chang'e-4</a></li>
<li><a href="../441014/index.html">Representaci√≥n est√©reo de bajo presupuesto en pocas l√≠neas de c√≥digo (estereograma, anaglifo, estereoscopio)</a></li>
<li><a href="../441018/index.html">Herramientas de desarrollo y especificaci√≥n del programa NanoCAD Mechanics</a></li>
<li><a href="../441020/index.html">C√≥mo VTB lleg√≥ a un solo conocimiento</a></li>
<li><a href="../441022/index.html">Errores comunes de pasajeros de ferrocarriles y aerol√≠neas</a></li>
<li><a href="../441026/index.html">VMware NSX para los m√°s peque√±os. Parte 2. Configuraci√≥n de firewall y NAT</a></li>
<li><a href="../441028/index.html">C√≥mo los investigadores descubren bases de datos abiertas MongoDB y Elasticsearch</a></li>
<li><a href="../441030/index.html">Detecci√≥n de ataques web con un codificador autom√°tico Seq2Seq</a></li>
<li><a href="../441032/index.html">KeeBee Hacer su propio teclado USB desde cero</a></li>
<li><a href="../441034/index.html">6 puntos de crecimiento de conversi√≥n o c√≥mo aumentar la confianza usando un tel√©fono en el sitio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>