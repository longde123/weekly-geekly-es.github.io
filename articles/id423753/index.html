<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🎨 🚧 👩‍👩‍👧‍👧 Jaga token otorisasi tetap aman 🔊 🎇 🌹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai% nama pengguna%. Terlepas dari topik laporan, saya selalu ditanya di konferensi pertanyaan yang sama - “bagaimana cara menyimpan token dengan aman...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jaga token otorisasi tetap aman</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423753/">  Hai% nama pengguna%.  Terlepas dari topik laporan, saya selalu ditanya di konferensi pertanyaan yang sama - “bagaimana cara menyimpan token dengan aman di perangkat pengguna?”.  Biasanya saya mencoba menjawab, tetapi waktu tidak memungkinkan untuk sepenuhnya mengungkapkan topik.  Dengan artikel ini saya ingin menutup masalah ini sepenuhnya. <br><a name="habracut"></a><br>  Saya menganalisis selusin aplikasi untuk melihat bagaimana mereka bekerja dengan token.  Semua aplikasi yang saya analisis memproses data penting dan memungkinkan saya menetapkan kode pin untuk input sebagai perlindungan tambahan.  Mari kita lihat kesalahan paling umum: <br><br><ul><li>  Mengirim kode PIN ke API bersama dengan RefreshToken untuk mengonfirmasi otentikasi dan menerima token baru.  - Buruk, RefreshToken tidak aman di penyimpanan lokal, dengan akses fisik ke perangkat atau cadangan, Anda dapat menghapusnya, serta malware dapat melakukannya. </li><li> Menyimpan kode pin dalam pesan dengan RefreshToken, lalu verifikasi lokal kode pin dan mengirim RefreshToken ke API.  - Mimpi buruk, RefreshToken tidak aman bersama dengan pin, yang memungkinkan mereka untuk diekstraksi, di samping itu, vektor lain muncul menyarankan memotong otentikasi lokal. </li><li>  Enkripsi RefreshToken yang salah dengan kode pin, yang memungkinkan Anda mengembalikan kode pin dan RefreshToken dari ciphertext.  - Kasus khusus dari kesalahan sebelumnya, dieksploitasi sedikit lebih rumit.  Tetapi perhatikan bahwa ini adalah cara yang benar. </li></ul><br>  Setelah melihat kesalahan umum, Anda dapat melanjutkan dengan memikirkan logika penyimpanan token yang aman di aplikasi Anda.  Layak dimulai dengan aset dasar yang terkait dengan otentikasi / otorisasi selama pengoperasian aplikasi dan mengajukan beberapa persyaratan untuknya: <br><br>  <b>Kredensial</b> - (nama pengguna + kata sandi) - digunakan untuk mengautentikasi pengguna dalam sistem. <br>  + kata sandi tidak pernah disimpan di perangkat dan harus segera dihapus dari RAM setelah dikirim ke API <br>  + tidak ditransmisikan oleh metode GET dalam parameter kueri dari permintaan HTTP, sebaliknya permintaan POST digunakan <br>  + cache keyboard dinonaktifkan untuk bidang teks pemrosesan kata sandi <br>  + clipboard dinonaktifkan untuk bidang teks yang berisi kata sandi <br>  + kata sandi tidak diungkapkan melalui antarmuka pengguna (mereka menggunakan tanda bintang), juga kata sandi tidak masuk ke tangkapan layar <br><br>  <b>AccessToken</b> - digunakan untuk mengonfirmasi otorisasi pengguna. <br>  + tidak pernah disimpan dalam memori jangka panjang dan hanya disimpan dalam RAM <br>  + tidak ditransmisikan oleh metode GET dalam parameter kueri dari permintaan HTTP, sebaliknya permintaan POST digunakan <br><br>  <b>RefreshToken</b> - digunakan untuk mendapatkan bundel AccessToken + RefreshToken baru. <br>  + tidak disimpan dalam bentuk apa pun dalam RAM dan harus segera dihapus darinya setelah menerima dari API dan menyimpannya ke memori jangka panjang atau setelah menerima dari memori jangka panjang dan menggunakan <br>  + disimpan hanya dalam bentuk terenkripsi dalam memori jangka panjang <br>  + dienkripsi dengan pin menggunakan sihir dan aturan tertentu (aturan akan dijelaskan di bawah), yaitu jika pin belum disetel, maka jangan menyimpan sama sekali <br>  + tidak ditransmisikan oleh metode GET dalam parameter kueri dari permintaan HTTP, sebaliknya permintaan POST digunakan <br><br>  <b>PIN</b> - (biasanya nomor 4 atau 6 digit) - digunakan untuk mengenkripsi / mendekripsi RefreshToken. <br>  + tidak pernah disimpan di mana pun di perangkat dan harus segera dihapus dari RAM setelah digunakan <br>  + tidak pernah meninggalkan batas aplikasi, itu tidak dikirim ke mana pun <br>  + hanya digunakan untuk enkripsi / dekripsi RefreshToken <br><br>  <b>OTP</b> adalah kode satu kali untuk 2FA. <br>  + OTP tidak pernah disimpan di perangkat dan harus segera dihapus dari RAM setelah mengirim ke API <br>  + tidak ditransmisikan oleh metode GET dalam parameter kueri dari permintaan HTTP, sebaliknya permintaan POST digunakan <br>  + cache keyboard dinonaktifkan untuk bidang teks yang memproses OTP <br>  + clipboard dinonaktifkan untuk bidang teks yang mengandung OTP <br>  + OTP tidak masuk ke tangkapan layar <br>  + aplikasi menghapus OTP dari layar ketika ia pergi ke latar belakang <br><br>  Sekarang mari kita beralih ke <s>keajaiban</s> kriptografi.  Persyaratan utama adalah bahwa dalam keadaan apa pun Anda tidak boleh mengizinkan implementasi mekanisme enkripsi RefreshToken, di mana Anda dapat memvalidasi hasil dekripsi secara lokal.  Artinya, jika seorang penyerang mengambil ciphertext, ia seharusnya tidak dapat mengambil kunci.  Satu-satunya validator adalah API.  Ini adalah satu-satunya cara untuk membatasi upaya pemilihan kunci dan membatalkan token jika terjadi serangan Brute-Force. <br><br>  Saya akan memberikan contoh yang baik, katakanlah kita ingin mengenkripsi UUID <br><blockquote>  aec27f0f-b8a3-43cb-b076-e075a095abfe </blockquote>  dengan set AES / CBC / PKCS5Padding ini, menggunakan PIN sebagai kunci.  Tampaknya algoritma itu baik, semuanya didasarkan pada pedoman, tetapi ada titik kunci - kuncinya berisi sangat sedikit entropi.  Mari kita lihat apa yang menyebabkan hal ini: <br><br><ol><li>  Padding - karena token kami menempati 36 byte, dan AES adalah mode enkripsi blok dengan blok 128 bit, maka algoritma harus menyelesaikan token hingga 48 byte (yang merupakan kelipatan dari 128 bit).  Dalam versi kami, ekor akan ditambahkan sesuai dengan standar PKCS5Padding, mis.  nilai setiap byte yang ditambahkan sama dengan jumlah byte yang ditambahkan <br><blockquote>  01 <br>  02 02 <br>  03 03 03 <br>  04 04 04 04 <br>  05 05 05 05 05 <br>  06 06 06 06 06 06 <br>  dll. </blockquote>  Blok terakhir kami akan terlihat seperti ini: <br><blockquote>  ... |  61 62 66 65 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C | </blockquote>  Dan ada masalah, melihat padding ini, kita dapat memfilter data (dengan blok terakhir yang tidak valid) didekripsi oleh kunci yang salah dan, dengan demikian, menentukan RefreshToken yang valid dari tumpukan terpelintir. </li><li>  Format token yang dapat diprediksi - bahkan jika kita membuat token kita kelipatan 128 bit (misalnya, menghilangkan tanda hubung) untuk menghindari penambahan padding, kita akan menemukan masalah berikut.  Masalahnya adalah bahwa semua tumpukan bengkok yang sama kita bisa mengumpulkan garis dan menentukan mana yang termasuk dalam format UUID.  UUID dalam bentuk teks kanoniknya adalah 32 digit dalam format heksadesimal yang dipisahkan oleh tanda hubung menjadi 5 kelompok 8-4-4-4-12 <br>  xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx <br>  di mana M adalah versi dan N adalah opsi.  Semua ini cukup untuk memfilter token yang didekripsi dengan kunci yang salah, meninggalkan format UUID RefreshToken yang sesuai. </li></ol><br>  Dengan semua hal di atas, Anda dapat melanjutkan ke implementasi, saya memilih opsi sederhana untuk menghasilkan 64 byte acak dan membungkusnya di base64: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRefreshToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] refreshToken = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">64</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); secureRandom.nextBytes(refreshToken); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Base64.getUrlEncoder().withoutPadding() .encodeToString(refreshToken); }</code> </pre>  Berikut adalah contoh token tersebut: <br><blockquote>  YmI8rF9pwB1KjJAZKY9JzqsCu3kFz4xt4GkRCzXS9-FS_kbN3-CF9RGiRuuGqwqMo-VxFDhgQNmgjlQFD2GvbA </blockquote>  Sekarang mari kita lihat tampilannya secara algoritmik (di Android dan iOS algoritmanya akan sama): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String ALGORITHM = <span class="hljs-string"><span class="hljs-string">"AES"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CIPHER_SUITE = <span class="hljs-string"><span class="hljs-string">"AES/CBC/NoPadding"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AES_KEY_SIZE = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AES_BLOCK_SIZE = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encryptToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String token, String pin)</span></span></span><span class="hljs-function"> </span></span>{ decodedToken = decodeToken(token); <span class="hljs-comment"><span class="hljs-comment">//   rawPin = pin.getBytes(); byte[] iv = generate(AES_BLOCK_SIZE); //      CBC byte[] salt = generate(AES_KEY_SIZE); //       byte[] key = kdf.deriveKey(rawPin, salt, AES_KEY_SIZE); //  -    Cipher cipher = Cipher.getInstance(CIPHER_SUITE); //    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, ALGORITHM), new IvParameterSpec(iv)); return cipher.doFinal(token); } public byte[] decodeToken(String token) { byte[] rawToken = token.getBytes(); return Base64.getUrlDecoder().decode(rawToken); } public final byte[] generate(int size) { byte[] random = new byte[size]; (new SecureRandom()).nextBytes(random); return random; }</span></span></code> </pre><br>  Baris apa yang perlu diperhatikan: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CIPHER_SUITE = <span class="hljs-string"><span class="hljs-string">"AES/CBC/NoPadding"</span></span>;</code> </pre><br>  Tidak ada bantalan, yah, Anda ingat. <br><br><pre> <code class="java hljs">decodedToken = decodeToken(token); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  Anda tidak bisa hanya mengambil dan mengenkripsi token di representasi base64, karena representasi ini memiliki format tertentu (yah, Anda ingat). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] key = kdf.deriveKey(rawPin, salt, AES_KEY_SIZE); <span class="hljs-comment"><span class="hljs-comment">//  -   </span></span></code> </pre><br>  Pada output, kami mendapatkan kunci ukuran AES_KEY_SIZE, cocok untuk algoritma AES.  Fungsi derivasi kunci apa pun yang direkomendasikan oleh Argon2, SHA-3, Scrypt dapat digunakan sebagai kdf dalam kasus kehidupan buruk pbkdf2 (paralel dengan FPGA). <br><br>  Token terenkripsi akhir dapat disimpan dengan aman di perangkat dan tidak khawatir bahwa seseorang dapat mencurinya, baik itu malware atau entitas yang tidak terbebani oleh prinsip-prinsip moral. <br><br>  Beberapa rekomendasi lainnya: <br><br><ul><li>  Kecualikan token dari cadangan. </li><li>  Di iOS, simpan token di gantungan kunci dengan atribut kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly. </li><li>  Jangan hamburkan aset yang dibahas dalam artikel ini (kunci, pin, kata sandi, dll.) Di seluruh aplikasi. </li><li>  Timpa aset segera setelah tidak diperlukan, jangan menyimpannya dalam ingatan Anda lebih lama dari yang diperlukan. </li><li>  Gunakan SecureRandom di Android dan SecRandomCopyBytes di iOS untuk menghasilkan byte acak dalam konteks kriptografi. </li></ul><br>  Kami memeriksa sejumlah jebakan saat menyimpan token, yang, menurut pendapat saya, harus diketahui oleh setiap orang yang mengembangkan aplikasi yang bekerja dengan data penting.  Topik ini, di mana Anda bisa bingung pada langkah apa pun, jika ada pertanyaan, tanyakan di komentar.  Komentar pada teks juga diterima. <br><br>  Referensi: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CWE-311: Enkripsi Data Sensitif yang Hilang</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CWE-327: Penggunaan Algoritma Kriptografi yang Rusak atau Berisiko</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CWE-327: CWE-338: Penggunaan Pseudo-Random Number Generator (PRNG) yang Lemah Secara Kriptografis.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CWE-598: Paparan Informasi Melalui String Permintaan dalam Permintaan GET</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423753/">https://habr.com/ru/post/id423753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423743/index.html">Di bawah kontrol: alat pemantauan disk server VDS</a></li>
<li><a href="../id423745/index.html">Menggunakan Python untuk menganalisis keterampilan yang diminta terkait di antara pengembang</a></li>
<li><a href="../id423747/index.html">Alat pengembangan baru dengan LEGO Education - dari Microsoft, MIT, dan lainnya</a></li>
<li><a href="../id423749/index.html">8 langkah mudah untuk gagal manajer pengembangan pemula</a></li>
<li><a href="../id423751/index.html">Java untuk Playstation 2 - apakah mungkin?</a></li>
<li><a href="../id423759/index.html">Fintech-digest: data pribadi warga Federasi Rusia, pasar Bank Sentral, layanan baru dari CloudFlare</a></li>
<li><a href="../id423763/index.html">Apa Uang Tunai yang Mengajarkan Para Inovator</a></li>
<li><a href="../id423765/index.html">Kami sedang menulis aplikasi untuk remote control pemutar MPV dari RetroOrangePi</a></li>
<li><a href="../id423767/index.html">Peretas menyerang British Airways: 380.000 kartu bank pelanggan dicuri</a></li>
<li><a href="../id423769/index.html">Menghubungkan OpenSSL ke Mono</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>