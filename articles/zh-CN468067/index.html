<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚰️ 🔋 🧕 Alpha合成如何工作 🗿 🙅 👩🏿‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="透明度似乎不是一个有趣的话题。 GIF格式可以让某些像素透过背景发光，这种格式已经发布了30多年。 在过去的二十年中，几乎所有发行的图形设计应用程序都支持创建半透明内容。 这些概念早已不再是新事物。 

 在我的文章中，我想表明，事实上，数字图像中的透明度比看起来要有趣得多-在我们看来，这是一种看不...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alpha合成如何工作</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468067/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fd/bw/7x/fdbw7xdswtd_k6crz13wprtqbtm.gif" alt="图片"></div><br> 透明度似乎不是一个有趣的话题。  GIF格式可以让某些像素透过背景发光，这种格式已经发布了30多年。 在过去的二十年中，几乎所有发行的图形设计应用程序都支持创建半透明内容。 这些概念早已不再是新事物。 <br><br> 在我的文章中，我想表明，事实上，数字图像中的透明度比看起来要有趣得多-在我们看来，这是一种看不见的深度和美。 <br><a name="habracut"></a><br><h1> 不透明度 </h1><br> 如果您曾经看过粉红色的眼镜，那么您会看到与下图类似的内容。  [在原始文章中，许多图像都是交互式的。]尝试移动眼镜，看看它们如何影响通过眼镜可见的图像： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tu/zo/mz/tuzomzqhbl9mcfzbxxcaneot3aq.png"></div><br> 这种眼镜的工作方式如下：它们会错过很多红色，相当数量的蓝色和很少的绿色。 这些点的数学运算可以用三个方程组来表示。 字母<strong>R</strong>表示运算结果，字母<strong>D</strong>表示我们要看的点。  RGB索引指示红色，绿色和蓝色成分： <br><br><blockquote><code>R <sub>R</sub> = D <sub>R</sub> × 1.0 <br> R <sub>G</sub> = D <sub>G</sub> × 0.7 <br> R <sub>B</sub> = D <sub>B</sub> × 0.9</code> </blockquote> <br> 这种彩色玻璃以不同的强度透射背景的红色，绿色和蓝色成分。 换句话说，粉红色眼镜的<em>透明度</em>取决于入射光的颜色。 通常，透明度可能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">会根据光的波长而变化</a> ，但是在此简化示例中，我们仅对眼镜如何影响经典RGB组件感兴趣。 <br><br> 模拟普通太阳镜的行为要简单得多，它们通常只是将入射光衰减一些： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/lq/8k/qflq8kkgpnh__pk8lpv5rx6txya.png"></div><br> 这些眼镜仅允许30％的光线通过。 它们的行为可以通过以下方程式描述： <br><br><blockquote> <code>R <sub>R</sub> = D <sub>R</sub> × 0.3 <br> R <sub>G</sub> = D <sub>G</sub> × 0.3 <br> R <sub>B</sub> = D <sub>B</sub> × 0.3</code> </blockquote> <br> 所有三个颜色分量都减小相同的值-入射光的吸收是相同的。 我们可以说墨镜是30％透明（不透明）或70％不透明的。 对象<em>的不透明度</em>决定了它阻止多少颜色。 在计算机图形学中，我们通常处理一个简化的模型，其中仅需要一个值来描述此属性。 不透明度可以在空间上变化。 例如，一列烟越来越高，越来越透明。 <br><br> 在现实世界中，不透明度为100％的对象就是不透明的，它们根本不透光。 数字图像的世界有些不同。 在某些情况下，即使是不透明的固体物体也可以通过一定量的光。 <br><br><h1> 覆盖范围 </h1><br> 矢量图形处理使用点，线段，贝塞尔曲线和其他数学图元定义的形状的清晰，无限准确的描述。 当您需要在计算机屏幕上显示图形时，必须将这些无懈可击的实体光栅化为位图： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/a01/6ed/ebca016ed191611e29f68dfca5aebe62.svg" width="492" height="202"></div><br>  <i>将矢量形状栅格化为位图</i> <br><br> 光栅化的最原始方法是检查像素样本在矢量形状内部或外部的位置。 在下面的示例中，您可以拖动三角形，在放大视图中，移动将更加准确。 蓝色轮廓指示原始矢量几何。 如您所见，在移动几何图形时，三角形边缘的梯形看起来很丑，并且闪烁很多： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mp/kn/pg/mpknpgk1lauj0ruzaobm6azr2wy.png"></div><br> 这种方法的缺点是，我们只对每个显示的像素执行一次检查，结果离散化为两个可能的值之一（内部或外部）。 <br><br> 您可以对每个像素多次采样矢量几何图形，以获得较大的阶跃渐变，并确定某些像素仅<em>部分</em>闭合。 一种可能的解决方案是使用四个采样点代表五个覆盖级别：0、1 ⁄ <sub>4，2⁄4，3⁄4</sub>和1： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hi/uu/pw/hiuupwrv88cjcfjxv5_f-b1hege.png"></div><br> 三角形边缘的质量得到了改善，但是仅五个可能的覆盖级别通常是不够的，我们可以轻松实现更好的结果。 尽管在信号处理领域中将像素视为小方块的观点遭到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了反对</a> ，但在某些情况下，它还是一个有用的模型，可以让我们通过矢量几何来计算确切的像素覆盖率。 直线和正方形的交点始终可以分解为<i>梯形</i>和<i>矩形</i> ： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24e/b9f/494/24eb9f494ab4259257189da367efef01.svg" alt="图片"></div><br>  <i>线段将正方形分为梯形和矩形</i> <br><br> 您可以轻松计算两个部分的面积，它们的总和除以正方形的面积即可确定像素覆盖率的百分比。 因此，覆盖范围被计算为具有任意精度的准确数字。 在下面的演示中，此方法用于渲染更好的边缘，即使拖动三角形也可以保持平滑： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xj/pd/fw/xjpdfwcvkdgujdwittnyzxan6ce.png"></div><br> 对于更复杂的形状，例如椭圆或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">贝塞尔</a>曲线，它们通常分为简单的直线段，可让您以正确的精度计算覆盖率。 <br><br> 对于矢量图形的高质量渲染，更重要的是对于文本渲染，部分覆盖的概念至关重要。 如果截取本文的屏幕截图并仔细考虑，您会发现字形的几乎所有边缘仅部分覆盖像素： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/b93/1ef/69ab931ef9b9eeb4f669f29652044c0d.png" height="50%" width="50%"></div><br>  <i>在文本呈现中积极使用部分覆盖</i> <br><br> 具有对象的不透明度并用单个像素覆盖它，您可以将它们组合为一个值。 <br><br><h1> 阿尔法 </h1><br> 对象的不透明度及其像素覆盖率的乘积称为<em>alpha</em> ： <br><br><blockquote> <code> =  × </code> </blockquote> <br> 不透明度为60％的对象（占像素面积的30％）在此像素中的alpha值为18％。 自然地，当对象是透明的或完全不覆盖像素时，此像素中的alpha值为0。相乘后，不透明度和涂层之间的差异消失，从某种意义上说，“ alpha”和“ opacity”的概念被用作同义词是有道理的。 <br><br>  Alpha通常表示为位图图像的第四通道。 红色，绿色和蓝色的通常值由一个alpha值补充，形成四个RGBA值。 <br><br> 在将alpha值存储在内存中时，通常会只使用一些位。 在覆盖不透明对象边缘的像素的情况下，根据屏幕的像素密度，似乎4位甚至3位就足够了： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qr/xt/pr/qrxtpr2tyhpn1znd0brdi8ehhns.png"></div><br> 但是，不透明度也会影响alpha值，因此，在平滑更改透明度的某些情况下，低位深度可能是灾难性的。 下图显示了从不透明的黑色到白色的渐变，这表明低位深度会导致非常强烈的颜色变化： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/8a/bv/jm8abvbbl5mejxely1nbhefyv8u.png"></div><br> 显然，位数越多越好，并且alpha 8通常使用8的位深度来匹配颜色分量的精度，这就是为什么许多RGBA缓冲区每个像素占用32位的原因。 还值得注意的是，与通常使用非线性变换编码的颜色分量不同，alpha是线性存储的-编码值0.5对应于alpha值0.5。 <br><br> 说到Alpha，我们完全忽略了所有其他颜色分量，但是除了阻止背景颜色之外，像素本身还可以添加一点颜色。 这个想法很简单-半透明的粉红色物体会阻挡部分传入的背景光，并发出或反射一点粉红色的光： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/_w/kf/tc_wkf6dtsblbjvxx1nslytlu2u.gif"></div><br> 请注意，它的行为不像彩色玻璃。 玻璃只是以不同的亮度阻挡了部分背景照明。 如果您通过粉红色的玻璃看一个完全黑色的物体，那么它的黑色将保持不变，因为黑色的物体不发光也不反射任何光。 但是，半透明的粉红色物体<em>会添加</em>自己的灯光。 如果将其放在黑色物体上，则结果将为粉红色。 这种行为的一个很好的类似物是悬浮在空气中的细小物质，例如雾，烟，雾或一些有色粉末。 <br><br> 渲染Alpha通道要困难一些-完全透明的对象在定义上是不可见的，因此要区分对象，我们需要使用两个技巧。 棋盘背景显示图像的哪些部分是透明的。 此模式用于许多图形应用程序： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b4/ff5/064/6b4ff5064b6cd9262e4d381125b406c4.svg" width="280" height="144"></div><br>  <i>象棋图案显示透明的碎片。</i> <br><br> 图片下方的四个小方块告诉我们，我们看到了图片的红色，绿色，蓝色和Alpha成分。 在某些情况下，直接查看alpha通道值很有用，而显示它们的最简单方法是使用灰色阴影： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9a/c12/c33/c9ac12c335263552b56dda8f3bd35262.svg" width="280" height="306"></div><br>  <i>在不同的表面上显示RGB和A值</i> <br><br> 灰色阴影越亮，alpha值越高，即纯黑色对应于0％的alpha，纯白色对应于100％的alpha。 小方块表示图像的RGB和A分量分为两部分。 <br><br>  alpha组件本身并不是特别有用，但是当我们谈论合成时，它变得非常重要。 <br><br><h1> 简单合成 </h1><br> 一个操作几乎无法实现2D渲染的效果，并且要创建最终结果，我们使用了一种将各种图像<em>组合</em>在一起的<em>合成</em>过程。 例如，可以通过合成五个单独的元素来创建一个简单的“取消”按钮： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd5/2d1/80f/cd52d180f6aba101c8fd2bf95bd721fe.svg" width="318" height="328"></div><br>  <i>取消按钮的合成元素</i> <br><br> 合成通常分几个阶段进行，每个阶段将两个图像进行组合。 合成中使用的前景图像通常称为<em>源</em> 。 通常将合成时使用的叠加有源的背景图像称为<em>destination</em> 。 <br><br> 我们将从在不透明的背景上进行合成开始，因为这是非常常见的情况。 您在屏幕上看到的所有内容最终都会通过在不透明的目标位置上进行合成而叠加。 <br><br> 当source的alpha值为100％时，source是不透明的，应完全覆盖目标。 如果Alpha值为0％，则源是完全透明的，不会以任何方式影响目标。  25％的alpha值允许对象发出25％的光并使75％的背景光通过，依此类推： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/985/719/921/985719921b6dc06496caba46db08a5c5.svg" width="520" height="248"></div><br>  <i>将具有不同alpha值的紫色源合成为黄色目标</i> <br><br> 您已经了解了所有内容-在不透明背景上进行Alpha合成的简单情况-只是目标颜色和源颜色之间的线性插值。 在下面的图形中，滑块控制源的Alpha值，红色，绿色和蓝色图形显示RGB分量的值。  <strong>R</strong>的结果只是源<strong>S</strong>和目标<strong>D</strong>的混合： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fd/bw/7x/fdbw7xdswtd_k6crz13wprtqbtm.gif"></div><br> 可以通过以下方程式描述此处发生的情况。 如前所述，索引表示分量，即S <sub>A</sub>是源中的alpha值，而D <sub>G</sub>是目标中的绿色值： <br><br><blockquote> <code>R <sub>R</sub> = S <sub>R</sub> × S <sub>A</sub> + D <sub>R</sub> × (1 − S <sub>A</sub> ) <br> <br> R <sub>G</sub> = S <sub>G</sub> × S <sub>A</sub> + D <sub>G</sub> × (1 − S <sub>A</sub> ) <br> <br> R <sub>B</sub> = S <sub>B</sub> × S <sub>A</sub> + D <sub>B</sub> × (1 − S <sub>A</sub> )</code> </blockquote> <br> 红色，绿色和蓝色分量的方程式外观相同，因此您可以简单地使用<sub>RGB</sub>索引并将它们组合为一行： <br><br><blockquote> <code>R <sub>RGB</sub> = S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × (1 − S <sub>A</sub> )</code> </blockquote> <br> 此外，由于目标是不透明的并且已经阻挡了所有背景光，因此我们知道结果的alpha值始终为1： <br><br><blockquote> <code>R <sub>A</sub> = 1</code> </blockquote> <br> 在不透明的背景上合成很简单，但是功能上却非常有限。 在许多情况下，需要更可靠的解决方案。 <br><br><h1> 中间缓冲区 </h1><br> 下图显示了将三个不同的层（分别标记为A，B和C）合成的两步过程。符号⇨表示“通过合成叠加”： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a9/fb8/ca5/6a9fb8ca58b71a7327785e10b54ef8da.svg" width="620" height="310"></div><br>  <i>三层两阶段合成的结果</i> <br><br> 首先，我们通过合成使B与C重叠，然后将A与它们重叠以得到最终的图像。 在以下示例中，我们将做一些不同的事情。 首先，我们将通过合成来连接最上面的两个图层，然后将结果覆盖在最后一个目标位置： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/a10/e40/a99a10e409562f903fa7e66b4a363706.svg" width="620" height="310"></div><br>  <i>三层以不同顺序进行两阶段合成的结果</i> <br><br> 您可能想知道这种情况在实践中是否会出现，但实际上这很常见。 许多非平凡的合成操作和渲染效果（例如遮罩和模糊）都需要通过仅包含部分合成结果的中间缓冲区。 这个概念有不同的名称：离屏传递，透明层或侧面缓冲区，但通常它们基于同一思想。 <br><br> 对我们来说更重要的是，几乎<em>所有</em>具有透明度的图像都可以被看作是某些渲染的部分结果，这些渲染随后将通过在最后一个目标上进行合成而被叠加： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/862/2cc/804/8622cc804d280c508244ccfc60c0e461.svg" width="128" height="48"></div><br>  <i>将按钮部分合成到缓冲区中</i> <br><br> 我们需要了解如何用具有相同颜色和不透明度的一个图像（A⇨B）代替半透明图像A和B的合成。 让我们开始计算最终缓冲区的alpha值。 <br><br><h1> 合并Alpha值 </h1><br> 您可能还不清楚如何结合两个对象的不透明度，但是如果我们谈论透明度，则谈论此任务会更容易。 <br><br> 假设一定量的光穿过第一个对象，然后穿过第二个对象。 如果第一个对象的透明度为80％，则它将通过80％的入射光。 同样，透明度为60％的第二个对象将允许60％的光通过，这使我们获得了60％×80％=原始光的48％。 您可以在原始文章中尝试透明性； 不要忘记，滑块控制光路径中对象的透明度，而不是对象的不透明度： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/av/f5/lv/avf5lvv7kve1zkgnztkd_i_hylq.png"></div><br> 自然，当第一个或第二个对象不透明时，没有任何光线穿过它们，甚至另一个完全透明。 <br><br> 如果对象D具有透明度D <sub>T</sub> ，而对象S具有透明度S <sub>T</sub> ，则这两个对象的最终一般透明度R <sub>T</sub>等于它们的乘积： <br><br><blockquote>  R <sub>T</sub> = D <sub>T</sub> ×S <sub>T</sub> </blockquote><br> 但是，透明度只是一个单位减去alpha，因此替换为我们提供了以下内容： <br><br><blockquote>  1-R <sub>A</sub> =（1- D <sub>A</sub> ）×（1- S <sub>A</sub> ） </blockquote><br> 该表达式可以扩展为： <br><br><blockquote>  1-R <sub>A</sub> = 1-D <sub>A</sub> -S <sub>A</sub> + D <sub>A</sub> ×S <sub>A</sub> </blockquote><br> 并像这样简化它： <br><br><blockquote>  R <sub>A</sub> = D <sub>A</sub> + S <sub>A</sub> -D <sub>A</sub> ×S <sub>A</sub> </blockquote><br> 可以将其简化为两种相似类型之一： <br><br><blockquote>  R <sub>A</sub> = S <sub>A</sub> + D <sub>A</sub> ×（1-S <sub>A</sub> ） <br><br>  R <sub>A</sub> = D <sub>A</sub> + S <sub>A</sub> ×（1-D <sub>A</sub> ） </blockquote><br> 很快，我们将看到第二个更常用。 还值得注意的是，所得的alpha值不取决于对象的相对顺序-即使交换了源和目标，所得像素的不透明度也是相同的。 这是很合逻辑的。 穿过两个物体的光应以相同的方式从恒星的任何一侧，从正面或从背面衰减。 <br><br><h1> 颜色组合 </h1><br> 计算alpha并不是那么困难，所以让我们尝试了解RGB分量的计算。 源图像的颜色为S <sub>RGB</sub> ，但其不透明度S <sub>A</sub>仅在最终结果中考虑以下两个值的乘积： <br><br><blockquote>  <sub>RGB</sub> ×S <sub>A</sub> </blockquote><br> 目标图像的颜色为D <sub>RGB</sub> ，不透明度使其发出光D <sub>RGB</sub> ×D <sub>A</sub> ，但是，部分光被图像S的不透明度所阻挡，因此目标的所有影响都相等： <br><br><blockquote>  D <sub>RGB</sub> ×D <sub>A</sub> ×（1-S <sub>A</sub> ） </blockquote><br> 来自S和D的光的总贡献等于它们的和： <br><br><blockquote>  S <sub>RGB</sub> ×S <sub>A</sub> + D <sub>RGB</sub> ×D <sub>A</sub> ×（1-S <sub>A</sub> ） </blockquote><br> 同样，合并图层的贡献等于其颜色乘以其不透明度： <br><br><blockquote>  R <sub>RGB</sub> ×R <sub>A</sub> </blockquote><br> 我们希望这两个值匹配： <br><br><blockquote>  R <sub>RGB</sub> ×R <sub>A</sub> = S <sub>RGB</sub> ×S <sub>A</sub> + D <sub>RGB</sub> ×D <sub>A</sub> ×（1-S <sub>A</sub> ） </blockquote><br> 是什么使我们得出最终方程： <br><br><blockquote>  R <sub>A</sub> = S <sub>A</sub> + D <sub>A</sub> ×（1-S <sub>A</sub> ） <br><br>  R <sub>RGB</sub> =（S <sub>RGB</sub> ×S <sub>A</sub> + D <sub>RGB</sub> ×D <sub>A</sub> ×（1-S <sub>A</sub> ））/ R <sub>A</sub> </blockquote><br> 看看第二个方程有多复杂！ 请注意，要获得结果的RGB值，我们需要除以alpha值。 但是，对于下一个合成阶段，将再次需要乘以alpha值，因为当前操作的结果将成为下一个操作的新源或目标。 这简直是​​丑陋的。 <br><br> 让我们再回到R <sub>RGB</sub>的几乎最终形式： <br><br><blockquote>  R <sub>RGB</sub> ×R <sub>A</sub> = S <sub>RGB</sub> ×S <sub>A</sub> + D <sub>RGB</sub> ×D <sub>A</sub> ×（1-S <sub>A</sub> ） </blockquote><br> 源，目标<em>和</em>结果乘以其alpha分量。 这使我们了解像素的颜色和Alpha“喜欢”在一起，因此我们需要退后一步，重新考虑存储颜色信息的方式。 <br><br><h1> 预乘alpha </h1><br> 回想一下我们讨论过的不透明度-如果对象是部分不透明的，那么它对结果的贡献也将是部分不透明的。 预乘alpha（“乘以alpha的预乘”）的概念实现了这一想法。 顾名思义，RGB分量的值已预先乘以alpha分量。 让我们从没有预乘的颜色开始： <br><br><blockquote>  （1.00，0.80，0.30，0.40） </blockquote><br> 预先乘以alpha可以得到以下结果： <br><br><blockquote>  （0.40、0.32、0.12、0.40） </blockquote><br> 让我们一次查看几个像素。 下图显示了如何在不先乘以alpha的情况下存储颜色信息： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e20/ba7/338/e20ba7338feb27cdf22f3c25d3afa697.svg" width="440" height="262"></div><br>  <i>图像中的RGB和A信息，无需事先相乘</i> <br><br> 请注意，从图像中的绿色和蓝色毛刺可以看出，alpha为0的区域可以具有任意的RGB值。 在通过alpha进行初步乘法的情况下，颜色信息还存储像素不透明度值： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/613/5d9/ede/6135d9ede6ea6789bbcd979e48a2cce0.svg" width="440" height="262"></div><br>  <i>预乘图像中的RGB和A信息</i> <br><br> 预乘Alpha有时称为关联Alpha，而非预乘Alpha有时称为纯Alpha或非关联Alpha。 <br><br> 当颜色的alpha分量为0时，预乘将重置所有其他分量，无论其值如何： <br><br><blockquote>  （0.0、0.0、0.0、0.0） </blockquote><br> 在预乘alpha的情况下，只有<em>一种</em>完全透明的颜色，这很迷人。 <br><br> 对颜色分量进行这种处理的优势将逐渐为您所认识，但是在返回合成示例之前，让我们看一下预乘alpha如何帮助解决其他一些渲染问题。 <br><br><h2> 筛选 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高斯模糊</a>是创建有趣的散焦背景或降低某些UI元素内容<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>背景部分<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高频度的</a>一种流行方法。 正如我们将看到的，预乘alpha对创建正确外观的模糊至关重要。 <br><br> 我们将分析的图像是通过用1％不透明蓝色填充背景而创建的，在该背景上绘制了不透明红色圆圈。 首先，让我们看一个没有预乘的示例。 我将RGB通道与alpha通道分开，以了解发生了什么。 箭头指示模糊操作： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/0eb/7f9/1ce0eb7f9342c4d90ca7c18bb827afba.png" width="530" height="264"></div><br>  <i>无需事先乘法即可模糊内容</i> <br><br> 最终结果具有丑陋的蓝色光晕。 发生这种情况是因为在模糊过程中，蓝色背景泄漏到了红色区域，然后才在合成过程中向其中添加了alpha权重。 <br><br> 将颜色预乘以alpha时，结果是正确的： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c6/9f8/aa9/2c69f8aa9cba7a689eb2094d89661576.png" width="530" height="264"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模糊预乘的内容</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于预乘，图像的蓝色减少到其原始强度的1％，因此对模糊圆圈的颜色的影响非常小。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 插补 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染像素与目标完美匹配的图像是一项简单的任务，因为我们需要在样本之间执行微不足道的一对一映射。</font><font style="vertical-align: inherit;">当没有简单的映射时，例如由于旋转，缩放或断字，就会出现问题。</font><font style="vertical-align: inherit;">下图显示了红色轮廓指示的旋转图像的像素不再与目的地匹配：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7c/55c/d9d/a7c55cd9d320d2fc5b8b4dd80622b54c.svg" width="596" height="290"></div><br> <i>     destination    </i> <br><br>       ,       destination,      —    «   » (nearest-neighbor interpolation),            . <br><br>           destination.        <em></em> .   (  ),       ,       .      source  destination,     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/0v/if/zd0vifjvna1jjf_apdomph8bmd0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该解决方案非常实用，并且像素具有整体颜色，但是质量是不可接受的。最好使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双线性插值法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它可以计算采样图像的四个最近像素的加权平均值：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s0/fy/qi/s0fyqirq3p9cpyfb5vl4gxzsz0q.png"></div><br>   ,      ,     ,    «»  .       ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>   [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>  ],    —              . <br><br>  ,        premultiplied alpha     ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/to/ax/zy/toaxzyjkgdouyossh7kzgkgudyi.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是完美-我们摆脱了所有的色彩融合，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">牙齿</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无处可见</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最终，与模糊和插值相关的问题密切相关。</font><font style="vertical-align: inherit;">需要半透明颜色的任何组合而没有先将颜色乘以alpha的任何操作都可能产生错误的结果。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 正确的合成 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们回到合成。</font><font style="vertical-align: inherit;">我们确定了一个几乎导出的方程式：</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您想象使用预乘Alpha的颜色，那么所有这些不舒服的乘法都会消失，因为Alpha已经成为颜色值的一部分。</font><font style="vertical-align: inherit;">然后我们得到以下内容：</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们看一下alpha方程： </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 红色，绿色，蓝色和alpha通道的系数是相同的，因此我们可以用一个方程式表示整个表达式，而请记住，每个分量都经过相同的运算： </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解预乘alpha如何使事情变得容易。</font><font style="vertical-align: inherit;">当我们分析方程式的组件时，它们都就位。</font><font style="vertical-align: inherit;">该操作会</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遮盖</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分背景光并添加新的光：</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种混合操作被称为信号源切换，切换或正常切换，毫无疑问，它是最常见的合成模式。</font><font style="vertical-align: inherit;">在此模式下，您在我的网站上看到的几乎所有内容都是混杂的。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 关联性 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对预alpha乘以的颜色执行的一个重要的source-over属性是</font><font style="vertical-align: inherit;">此操作</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关联性</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">多亏了他，在复杂的混合方程式中，我们可以将括号完全任意放置。</font><font style="vertical-align: inherit;">下面显示的所有成分均相同：</font></font><br><br><blockquote> R = (((A⇨B)⇨C)⇨D)⇨E <br><br> R = (A⇨B)⇨(C⇨(D⇨E)) <br><br> R = A⇨(B⇨(C⇨(D⇨E))) </blockquote><br>    ,        .    ,        ,  ,      . <br><br>            source-over,       .          . <br><br><h1>  - </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1984年7月，Thomas Porter和Tom Duff发表了原始文章</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ Compositing Digital Images”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">作者不仅首先介绍了预乘alpha的概念并推导了合成源方程，而且还提出了一个完整的alpha合成操作族，尽管它们非常有用，但其中很多鲜为人知。</font><font style="vertical-align: inherit;">新函数也称为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为它们像加法或乘法一样，对输入值执行操作以创建输出值。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 结束 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在以后的示例中，我们将使用交互式演示演示各种混合模式的操作。</font><font style="vertical-align: inherit;">目标图像将是黑色的“俱乐部”符号，源图像将是红色的“蠕虫”符号。</font><font style="vertical-align: inherit;">您可以将心脏拖到图像上方，并观察重叠形状在不同的合成运算符下的行为。</font><font style="vertical-align: inherit;">注意角落的小地图。</font><font style="vertical-align: inherit;">一些混合模式非常具有破坏性，并且容易引起混淆。</font><font style="vertical-align: inherit;">小型地图始终显示简单的源代码合成的结果，从而简化了理解：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/nb/n3/vxnbn3qhwfuiobes7rws0ardxtq.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S×（1-D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）+ D</font></font></blockquote><br>    destination-over,    ,    «» source-over — destination  source        ,     destination  source.    ,  destination-over  ,       ,  <em></em>   . <br><br><h2> Out </h2><br>  source-out  destination-out       source  destination: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c1/pn/ou/c1pnoudiz66kdmddiaqkmdxcyuq.gif"></div><br><blockquote> R = S × (1 − D <sub>A</sub> ) </blockquote><br><blockquote> R = D × (1 − S <sub>A</sub> ) </blockquote><br>        Destination-out,    -      destination. <br><br><h2> In </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 源输入和目标输入运算符本质上是掩盖运算符： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/je/jc/fxjejc-my5ewd7otz8_r2ylueas.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S×D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = D×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 它们使创建非平凡几何图形的复杂交点变得十分容易，而无需解决相对困难的矢量轮廓交点的计算。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在上 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符</font></font><code>source-atop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>destination-atop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许您将新内容叠加在现有内容上，同时沿目标路径对其进行遮盖：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/js/f-/2o/jsf-2on9uxoowdzpk73ugiadypw.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S×D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S×（1-D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）+ D×S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 异或 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XOR运算符（</font></font><code>xor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）存储</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">源，或目标，以及它们的重叠区域消失：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/i6/uo/bmi6uoidqbrytp4e4gbmy6afvck.png"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S×（1-D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）+ D×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 源，目的地，清除 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后三种经典的合成模式非常无聊。</font></font><code>Source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，也称为</font></font><code>copy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，仅采用颜色来源。</font><font style="vertical-align: inherit;">同样，它会</font></font><code>destination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">忽略颜色源并仅返回</font></font><code>destination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">操作员</font></font><code>clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只需清除所有内容：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fw/li/mo/fwlimouoegmu9ff1r1tqno-uags.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R = S </font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R = D </font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R = 0 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些模式的适用性受到限制。</font><font style="vertical-align: inherit;">使用</font></font><code>clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它，您可以刷新已填充的缓冲区，但是可以通过简单地用零填充内存来优化此操作。</font><font style="vertical-align: inherit;">另外，在某些情况下</font><font style="vertical-align: inherit;">，由于不需要任何混合，而只是用源信息替换缓冲区的内容，因此在计算上</font></font><code>source</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更经济。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 波特达夫在行动 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与个别操作员打交道之后，让我们看看如何将它们组合在一起。</font><font style="vertical-align: inherit;">在下面的示例中，我们将绘制海洋徽标，而无需使用遮罩或复杂的几何形状。</font><font style="vertical-align: inherit;">蓝色轮廓显示正在创建的简单几何图形。</font><font style="vertical-align: inherit;">您可以通过单击图像的右侧来完成各个步骤，然后单击左侧可以返回：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/-l/ct/qf-lctetuaygx6y7nwxhl95breu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 当然，我们绝没有义务放弃遮罩和修剪轮廓，但是我们经常忘记像Porter-Duff合成模式这样的工具，尽管在它们的帮助下创建一些视觉效果要容易得多。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 经营者 </font></font></h2><br>     -,   ,      . Source      F <sub>S</sub>    destination,    F <sub>D</sub> : <br><br><blockquote> R = S×F <sub>S</sub> + D×F <sub>D</sub> </blockquote><br> F <sub>S</sub>    0, 1, D <sub>A</sub>  1 − D <sub>A</sub> ,  F <sub>D</sub>    0, 1, S <sub>A</sub>  1 − S <sub>A</sub> .     source  destination    ,      ,     ,       .       : <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  0 </td><td>  1个 </td><td> D <sub>A</sub> </td><td> 1 − D <sub>A</sub> </td></tr><tr><td>  0 </td><td> clear </td><td> source </td><td> source-in </td><td> source-out </td></tr><tr><td>  1个 </td><td> destination </td><td></td><td></td><td> destination-over </td></tr><tr><td> S <sub>A</sub> </td><td> destination-in </td><td></td><td></td><td> destination-atop </td></tr><tr><td> 1 − S <sub>A</sub> </td><td> destination-out </td><td> source-over </td><td> source-atop </td><td> xor </td></tr></tbody></table></div><br>       .          ,     . <br><br><h1>   </h1><br>          ,    F <sub>S</sub> ,  F <sub>D</sub>  1.     <code>plus</code> , <code>lighter</code>  <code>plus-lighter</code> : <br><br><blockquote> R = S + D </blockquote><br>     <em></em>  source  destination: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2f/a9b/31c/a2fa9b31c91913bc0445b91ea8217670.png" width="488" height="226"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由操作员实施的附加照明</font></font><code><em>plus</em></code></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确地以绿色和红色形成黄色，而以绿色和蓝色形成青色。</font><font style="vertical-align: inherit;">黑色表示没有操作；它不会以任何方式更改颜色值，因为将数字加零不会更改任何内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">剩余的三个运算符没有特别的名称，因为它们没有用。</font><font style="vertical-align: inherit;">它们只是遮罩和混合的组合。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还值得注意的是，预乘alpha允许我们以</font></font><code>source-over</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意外的方式</font><font style="vertical-align: inherit;">使用运算符</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们再次看一下等式：</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D×（1-S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们设法使光源中的Alpha值等于零，那么如果RGB通道中存在非零值，则无需使用运算符就可以实现加性照明</font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/400/42b/fbf/40042bfbf25d98ec04a5609fcf828f39.png" width="488" height="290"></div><br> <i> ,     <code><em>source-over</em></code></i> <br><br> ,      —       .      ,       ,          ,  -   ,       ,     .         ,          ,     <code>plus</code> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们正在讨论的所有元素都已很好地结合在一起。</font><font style="vertical-align: inherit;">现在，让我们摘下粉红色眼镜，讨论使用alpha合成时需要考虑的一些问题。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 组不透明度 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们看一下仅由六个基元组成的简单药丸图： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e7/b44/c84/6e7b44c84ff94dfbe3e0f2943cd44b89.png" width="512" height="208"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用简单的形状绘制药丸</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果要求我们绘制不透明度为50％的药丸，那么我们可能会试图在每个绘制操作中将不透明度简单地分成两半，但这将是一个错误的决定：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/63a/26b/13a63a26b176861264010a8d43aefb7a.png" width="160" height="96"></div><br> <i>      </i> <br><br>    ,             .     ,     ,   <em></em>    ,     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/798/7d0/708/7987d07084e48d8b3a51e99111c8a3ae.png" width="512" height="96"></div><br> <i>      </i> <br><br>    ,        . <br><br><h1>   </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将几何封面转换为单个alpha值会带来不舒服的后果。</font><font style="vertical-align: inherit;">请考虑以下情况：矢量几何图形的两个理想匹配的边缘（如下图所示，具有橙色和蓝色轮廓）被渲染为位图。</font><font style="vertical-align: inherit;">在理想的世界中，结果应该看起来像这样，因为每个像素都是完全封闭的：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45d/728/ca1/45d728ca1d4b35c64a2a3b1499930353.svg" width="555" height="255"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有正确覆盖率的理想渲染结果，</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果我们首先渲染橙色几何图形，然后渲染蓝色几何图形，那么在最终图像中，白色背景仍然会渗入边框像素中：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2f/cdd/66f/f2fcdd66f6b53504a36c5db42c17bfc5.svg" width="555" height="255"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两阶段合成的结果</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将涂层存储在alpha通道中后，其所有几何信息都将丢失，我们无法以任何方式对其进行恢复。蓝色几何图形只是与</font><font style="vertical-align: inherit;">缓冲区的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">某些</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font><font style="vertical-align: inherit;">混合在一起</font><font style="vertical-align: inherit;">，但是不知道由红色像素表示的几何图形必须与之匹配。当几何形状彼此精确叠加时，此问题尤其明显。在下图中，在黑色圆圈的上方绘制了一个白色圆圈。尽管两个圆</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">半径和位置</font><em><font style="vertical-align: inherit;">完全相同</font></em><font style="vertical-align: inherit;">，但深色边缘仍然很明显</font><font style="vertical-align: inherit;">：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a8/33f/e2c/9a833fe2c9881ed7c89ece47c0984f38.svg" width="180" height="180"></div><br> <i> ,    </i> <br><br>         ,  <em></em>    ,       .      in/out,         ,   . <br><br>        8- -     256    <em></em> ,        2 <sup>16</sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次。</font><font style="vertical-align: inherit;">正如我们在上面看到的，在减少coverage值的位深度的同时，您仍然可以获得令人满意的结果，因此在实践中，您可以使用较小的比例尺。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还值得注意的是，通常无需使用巨大的位图就可以相对轻松地避免此类问题。</font><font style="vertical-align: inherit;">例如，您可以简单地在彼此上方绘制两个正方形，而不是绘制两个重叠的圆，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对结果进行遮罩以形成一个圆。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 线性值 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您重新了解了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色彩空间</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则可以记住，大多数</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">色彩空间</font></a><font style="vertical-align: inherit;">都是非线性地对色彩值进行编码的，因此必须进行初步的线性化才能执行正确的数学运算。</font><font style="vertical-align: inherit;">完成此阶段后，合成结果如下：</font><font style="vertical-align: inherit;">注意彼此重叠的部分的淡黄色调：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/24f/14d/bb024f14d3ede0fe13e72eb1de4a115a.png" width="280" height="300"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模糊红色圆圈是通过使用线性值在绿色背景上合成而叠加的，</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是在大多数情况下，合成</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并非</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如此。</font><font style="vertical-align: inherit;">Web和大多数图形软件的标准方法是直接混合非线性值：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/245/77c/a2e/24577ca2e1dd42a2ef6c2ef1d33884d9.png" width="280" height="300"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作曲家使用非线性值将模糊的红色圆圈叠加在绿色背景上。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，绿色叠加层上红色的区域要暗得多。</font><font style="vertical-align: inherit;">它们远非理想，但在某些情况下，错误的操作深深植根于理解我们如何感知色彩。</font><font style="vertical-align: inherit;">例如，来自sRGB空间的50％不透明灰色看起来完全像是纯黑色，其中不透明度50％与白色背景混合在一起：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/366/ca1/573/366ca1573d720de845ce276d7ef0d5b4.svg" width="405" height="133"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性化的情况下</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font><i><font style="vertical-align: inherit;">白色背景上合成两种颜色</font></i><font style="vertical-align: inherit;">在下图中，将源图像和目标图像的sRGB颜色进行线性化，然后转换回非线性编码以进行显示。</font><font style="vertical-align: inherit;">这些颜色的实际外观如下：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ae/c74/90a/1aec7490a8fdf2a096f5e4c8f2b56cdc.svg" width="405" height="133"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两种颜色的构成在白色背景的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性化</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有一个不符合我们的期望的差异。</font><font style="vertical-align: inherit;">使用此方法获得视觉均匀性的唯一方法是使用线性值选择所有颜色，但这与每个人习惯的方法有很大不同。</font><font style="vertical-align: inherit;">具有线性值的50％灰度在sRGB空间的73.5％上看起来像灰度。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，在使用预乘alpha时，需要特别小心。</font><font style="vertical-align: inherit;">预乘法必须使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">，即 </font><font style="vertical-align: inherit;">在编码为非线性之前。</font><font style="vertical-align: inherit;">因此，线性化步骤将正确地以正确的线性值结束，该线性值先前已乘以alpha。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 预乘Alpha和位深度 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管预乘alpha在合成，过滤和插值方面很有用，但它并不是“灵丹妙药”，但也有其缺点。</font><font style="vertical-align: inherit;">其中最严重的是可以想象得到的颜色位深度的减少。</font><font style="vertical-align: inherit;">想象一下一个值为150的8位编码，它预先乘以alpha 20％。</font><font style="vertical-align: inherit;">初步乘以alpha之后，我们得到</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 四舍五入（150×0.2）= 30 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果我们重复相同的过程，其值为151，则会得到： </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 四舍五入（151×0.2）= 30 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管初始值有所不同，但编码后的值将相同。</font><font style="vertical-align: inherit;">实际上，在乘以alpha之后，将148、149、150、151和152的值编码为30，并且丢失了这五种唯一颜色之间的原始差异：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af3/a80/76c/af3a8076caef4fdae6146e6d503ea639.svg" width="560" height="203"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预乘以20％的alpha值</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会将</font><i><font style="vertical-align: inherit;">各种8位值减小为1，</font></i><font style="vertical-align: inherit;">当然，alpha </font><i><font style="vertical-align: inherit;">值</font></i><font style="vertical-align: inherit;">越小，其效果越具有破坏性。</font><font style="vertical-align: inherit;">在初步乘以alpha后，在8位RGBA值的各种组合</font><font style="vertical-align: inherit;">的256 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4个</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（大约43亿）</font><font style="vertical-align: inherit;">可能的范围中</font><font style="vertical-align: inherit;">，只有25.2％保留唯一的表示形式。实际上，我们从32位范围中损失了几乎2位。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要在不同的颜色空间之间转换颜色，有时需要反转预乘，即将值除以alpha分量以获得原始颜色亮度。因为如上所述，编码是非线性执行的，所以需要此步骤。预乘法的存在降低了颜色表示的准确性，并且颜色空间之间的转换可能是不完善的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在实践中，减小位深度很少是重要的，尤其是在合成中。 alpha值越低，颜色越不可见，并且对合成的影响也越小。最终，如果您追求精确的色彩操作，则不会使用它们的8位表示法-为此，格式更适合</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浮点数</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 补充阅读 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alpha通道的概念是由Pixar工作室联合创始人</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Elvy </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smith</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ed Catmell创建的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。史密斯（Smith）的文章</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“阿尔法和数字合成</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的历史</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">”</font></a><font style="vertical-align: inherit;">描述了发明的历史和“阿尔法”的名称，以及这些概念如何演变并逐渐取代电影制作中的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">口罩</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概念</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了理解alpha的含义，我强烈建议您阅读Andrew Glassner的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“解释Alpha”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。本文提供了一个严格但很容易获得的数学推导式α，以衡量不透明度和覆盖率之间的相互作用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关预乘alpha的详细讨论，请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">埃里克·海恩斯</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">（</font></a><font style="vertical-align: inherit;"> Eric Haines）的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">“ GPU更喜欢预乘”</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">本文不仅提供了关于</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺少</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初步乘法（尤其是在3D渲染</font><font style="vertical-align: inherit;">中）的问题的出色概述</font><font style="vertical-align: inherit;">，还提供了有关该主题的许多其他文章的链接。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 总结 </font></font></h1><br>         -,    ,   -,   ,      . <br><br>       ,     ,  RGB-,            .               2D-. <br><br>              ,     ,   ,   ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN468067/">https://habr.com/ru/post/zh-CN468067/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN468057/index.html">类似于Unix的OS开发-多任务处理和系统调用（7）</a></li>
<li><a href="../zh-CN468059/index.html">我与Hai句的第二个星期：很多隐藏的钻石和令人惊喜的惊喜，以及一些问题</a></li>
<li><a href="../zh-CN468061/index.html">Linux上的Cron：历史记录，用法和设备</a></li>
<li><a href="../zh-CN468063/index.html">角效应</a></li>
<li><a href="../zh-CN468065/index.html">面向所有人的心理产品管理模型</a></li>
<li><a href="../zh-CN468071/index.html">Tungsten Labs首席技术官Eduard Medvedev：“我们已经发展到技术可能造成巨大伤害的地步”</a></li>
<li><a href="../zh-CN468073/index.html">安德烈·捷列霍夫（Andrei Terekhov）：“您可以随心所欲地说美国人更好，但我们的汽车永远不会抛锚”</a></li>
<li><a href="../zh-CN468075/index.html">暹罗神经网络在搜索中的使用</a></li>
<li><a href="../zh-CN468077/index.html">以成人方式进行测试。 光谱分析</a></li>
<li><a href="../zh-CN468079/index.html">Google Analytics（分析）中的自定义维度为我们节省了不止一次</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>