<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óªÔ∏è üöµüèæ üÜî Essayer de composer le non-composable: sch√©mas d'ancrage üïµüèª üõ¥ üò°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Dans Haskell, il est de coutume de travailler avec des effets comme foncteurs dont les objets sont des expressions qui nous int√©ressent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Essayer de composer le non-composable: sch√©mas d'ancrage</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467683/"><h2>  Pr√©sentation </h2><br>  Dans Haskell, il est de coutume de travailler avec des effets comme foncteurs dont les objets sont des expressions qui nous int√©ressent en ce moment. <br><br>  Quand nous voyons le type d'expression <b>Peut-√™tre a</b> , nous nous abstenons de l'existence r√©elle de certains <b>a</b> , concentrant toute notre attention sur ce <b>a</b> .  La m√™me histoire avec <b>Liste a</b> - valeurs plurielles de <b>a</b> ;  <b>State sa</b> - <b>a</b> , selon un √©tat actuel;  <b>Soit ea</b> - <b>a</b> , ce qui peut renvoyer une erreur <b>e</b> . <br><a name="habracut"></a><br>  Avant de continuer, l'article utilisera plusieurs d√©finitions: <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> (:=) ta = ta </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- |   type (:.) tua = t (ua) -- |   type (~&gt;) tu = forall a . ta -&gt; ua -- |  </span></span></span></span></code> </pre> <br>  Par exemple: <b>Liste:.</b>  <b>Peut-√™tre: = a</b> - cette expression est facile √† imaginer, il s'agit d'une liste de valeurs dont l'existence est en cause. <br><br>  De plus, √† titre d'exemple, nous utiliserons quatre types communs: <b>Reader</b> , <b>State</b> , <b>Either</b> , <b>Maybe</b> . <br><br><h2>  Compositions et transformateurs </h2><br>  La fa√ßon la plus √©vidente d'appliquer plus d'un effet √† une expression est de simplement en incorporer un dans l'autre, c'est la composition habituelle des foncteurs.  Dans les compositions, les effets n'ont aucun effet les uns sur les autres (sauf si des m√©thodes <b>transversales</b> sont utilis√©es par-dessus).  Et pour fusionner de nombreux effets en un seul, des transformateurs sont utilis√©s.  Chaque m√©thode a ses avantages et ses inconv√©nients: <br><br>  Compositions: <br><br><ul><li>  Aucun type suppl√©mentaire n√©cessaire pour les construire </li><li>  Il n'y a pas de m√©thode g√©n√©rale pour fusionner les effets avec les <b>classes Functor</b> / <b>Applicative</b> / <b>Monad</b> </li><li>  Tout se compose √† merveille jusqu'√† ce qu'il s'agisse de monades </li></ul><br>  Transformateurs: <br><br><ul><li>  Vous permet de fusionner plusieurs effets en un seul </li><li>  Mais vous avez besoin d'un type distinct (le plus souvent un nouveau type) </li><li>  √Ä l'aide de l' <b>ascenseur,</b> vous pouvez effectuer des calculs sur n'importe quelle couche de la pile de transformation. </li><li>  Mais vous ne pouvez pas prendre en compte les effets s√©par√©ment, bien qu'il existe des fonctions sp√©cialis√©es </li></ul><br>  Les transformateurs sont diff√©rents des compositions d'embrayage (je ne sais pas comment l'appeler diff√©remment).  Ayant une certaine composition, vous pouvez le transformer en transformateur et vice versa.  Les sch√©mas d'ancrage nous y aideront. <br><br><h2>  Sch√©mas d'ancrage </h2><br>  Si nous examinons de plus pr√®s les types de transformateurs monades, nous pouvons identifier certains mod√®les: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReaderT</span></span></span><span class="hljs-class"> rma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReaderT</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runReaderT</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ma</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybeT</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybeT</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runMaybeT</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ExceptT</span></span></span><span class="hljs-class"> ema = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ExceptT</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runExceptT</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ea</span></span></span><span class="hljs-class">)) } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateT</span></span></span><span class="hljs-class"> sma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateT</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runStateT</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) }</span></span></code> </pre><br>  Les transformateurs d√©crivent un cas particulier de la fa√ßon dont l‚Äôeffet d√©fini et ind√©fini actuel doit √™tre maill√©. <br><br>  Soit <b>t</b> d√©fini et <b>u</b> ind√©fini, essayez: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Reader</span></span>: r -&gt; ua ===&gt; (-&gt;) r :. u := a ===&gt; t :. u := a <span class="hljs-comment"><span class="hljs-comment">-- t ~ (-&gt;) r Maybe: u (Maybe a) ===&gt; u :. Maybe := a ===&gt; u :. t := a -- t ~ Maybe Either: u (Either ea) ===&gt; u :. Either e := a ===&gt; u :. t := a -- t ~ Either e</span></span></code> </pre><br>  Certains effets sont assez complexes et peuvent √™tre d√©finis par la composition d'autres effets plus simples: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">State</span></span>: s -&gt; u (a, s) ===&gt; (-&gt;) s :. (,) s := a ==&gt; t :. u :. t' := a <span class="hljs-comment"><span class="hljs-comment">-- t ~ (-&gt;) s, t' ~ (,) s newtype State sa = State ((-&gt;) s :. (,) s := a)</span></span></code> </pre><br>  Si nous regardons de plus pr√®s les 3 premiers exemples, nous pouvons remarquer des mod√®les g√©n√©raux: si dans <b>Reader</b> , un certain effet en enveloppe un ind√©fini (le prend entre parenth√®ses, devient un objet d'un foncteur), puis avec <b>Soit</b> et <b>Peut</b> - <b>√™tre</b> c'est le contraire - un effet ind√©fini en termine un sp√©cifique.  Dans le cas de <b>State,</b> nous pla√ßons m√™me le foncteur entre deux effets d√©finis plus simples. <br><br>  Essayons d'exprimer ces mod√®les en types: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> tua = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class"> :. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">u</span></span></span><span class="hljs-class"> := </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> tua = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">u</span></span></span><span class="hljs-class"> :. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class"> := </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> tut' a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class"> :. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">u</span></span></span><span class="hljs-class"> :. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t'</span></span></span><span class="hljs-class"> := </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Nous venons de d√©finir des sch√©mas d'ancrage - il s'agit d'une composition de foncteurs dans un wrapper qui indique la position d'un effet sp√©cifique et ind√©fini. <br><br>  En fait, les m√©thodes des transformateurs dont les noms commencent par <b>run</b> suppriment simplement le wrapper du transformateur, retournant la composition des foncteurs.  Nous d√©crivons une telle classe de types: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> t </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> ta :: * run :: ta -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> ta</span></span></code> </pre><br>  Maintenant, nous avons un moyen universel d'ex√©cuter ces circuits: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tu</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tu</span></span></span><span class="hljs-class">) a = t :. u := a run (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) = x instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tu</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tu</span></span></span><span class="hljs-class">) a = u :. t := a run (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) = x instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tu</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t'</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tu</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t'</span></span></span><span class="hljs-class">) a = t :. u :. t' := a run (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) = x</span></span></code> </pre><br>  Et les transformateurs?  Ici, vous aurez √©galement besoin d'une classe de type dans laquelle un sch√©ma d'ancrage est prescrit pour un type particulier, la m√©thode d' <b>int√©gration</b> est d√©clar√©e pour √©lever l'effet ind√©fini au niveau du transformateur et <b>construire</b> pour construire un certain effet dans un transformateur: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> t =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Transformer</span></span></span><span class="hljs-class"> t </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class"> :: * -&gt; *) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">u</span></span></span><span class="hljs-class"> :: * -&gt; *) = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> :: * -&gt; *) | r -&gt; tu embed :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> u =&gt; u ~&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> tu build :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> u =&gt; t ~&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> tu </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> (:&gt;) tua = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Transformer</span></span></span><span class="hljs-class"> t =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> tua</span></span></code> </pre><br>  Reste maintenant √† d√©clarer les instances, commencez par <b>Maybe</b> et <b>Soit</b> : <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Transformer</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> u = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> u embed x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> $ </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> &lt;$&gt; x build x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> . pure $ x instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Transformer</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) u = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) u embed x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> $ </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Right</span></span></span><span class="hljs-class"> &lt;$&gt; x build x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> . pure $ x</span></span></code> </pre><br>  Nous allons cr√©er notre propre type pour <b>Reader</b> , car il n'est pas dans la <b>base</b> .  Et il a √©galement besoin d'une instance de la classe <b>Composition</b> , car il s'agit d'un wrapper pour le foncteur fl√®che: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> ea = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) a = (-&gt;) ea run (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) = x instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Transformer</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) u = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> ((-&gt;) e) u embed x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> . const $ x build x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> $ pure &lt;$&gt; run x</span></span></code> </pre><br>  Faites quelque chose de similaire avec <b>State</b> : <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> sa = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> ((-&gt;) s :. (,) s := a) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) a = (-&gt;) s :. (,) s := a run (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) = x instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Transformer</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) u = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> ((-&gt;) s) u ((,) s) embed x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> $ \s -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">,) &lt;$&gt; x build x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> $ pure &lt;$&gt; run x</span></span></code> </pre><br><h2>  √Ä titre d'exemple </h2><br>  Il reste √† tester cela sur les probl√®mes du monde r√©el - √† titre d'exemple, nous allons √©crire un programme qui calcule le placement correct de diff√©rents types de supports. <br><br>  D√©finissez les types de parenth√®ses: ils peuvent √™tre ouverts et ferm√©s;  et ont √©galement diff√©rents styles: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Opened</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Closed</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Style</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Round</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Square</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Angle</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Curly</span></span></span></span></code> </pre><br>  Les autres symboles de notre programme ne sont pas int√©ressants: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Symbol</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nevermind</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bracket</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Style</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span></span></code> </pre> <br>  Nous d√©finissons √©galement une liste d'erreurs que notre programme peut rencontrer: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stumble</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Deadend</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Style</span></span></span><span class="hljs-class">) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--     | Logjam (Int, Style) --     | Mismatch (Int, Style) (Int, Style) --      </span></span></span></span></code> </pre><br>  De quels effets notre programme a-t-il besoin?  Nous devons conserver une liste de crochets en attente de v√©rification et nous devons nous arr√™ter √† la premi√®re erreur rencontr√©e.  Nous fabriquons un transformateur: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">State</span></span> [(<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Style</span></span>)] :&gt; <span class="hljs-type"><span class="hljs-type">Either</span></span> <span class="hljs-type"><span class="hljs-type">Stumble</span></span> := ()</code> </pre> <br>  L'algorithme est simple: nous parcourons la structure avec des crochets index√©s, si apr√®s le passage nous n'avons pas rencontr√© d'erreur et que nous avons encore les crochets en l'√©tat, alors le crochet ouvert n'en a pas de ferm√©: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">checking</span></span> :: <span class="hljs-type"><span class="hljs-type">Traversable</span></span> t =&gt; t (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Symbol</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Either</span></span> <span class="hljs-type"><span class="hljs-type">Stumble</span></span> () checking struct = run (traverse proceed struct) [] &gt;&gt;= \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (s : _, _) -&gt; <span class="hljs-type"><span class="hljs-type">Left</span></span> . <span class="hljs-type"><span class="hljs-type">Logjam</span></span> $ s <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ([], _) -&gt; <span class="hljs-type"><span class="hljs-type">Right</span></span> ()</code> </pre><br>  Nous nous souvenons de tout crochet ouvert, comparons tout ferm√© au dernier ouvert m√©moris√©: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">proceed</span></span> :: (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Symbol</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">State</span></span> [(<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Style</span></span>)] :&gt; <span class="hljs-type"><span class="hljs-type">Either</span></span> <span class="hljs-type"><span class="hljs-type">Stumble</span></span> := () proceed (_, <span class="hljs-type"><span class="hljs-type">Nevermind</span></span>) = pure () proceed (n, <span class="hljs-type"><span class="hljs-type">Bracket</span></span> style <span class="hljs-type"><span class="hljs-type">Opened</span></span>) = build . modify . (:) $ (n, style) procceed (n, <span class="hljs-type"><span class="hljs-type">Bracket</span></span> closed <span class="hljs-type"><span class="hljs-type">Closed</span></span>) = build get &gt;&gt;= \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> []-&gt; embed $ <span class="hljs-type"><span class="hljs-type">Left</span></span> . <span class="hljs-type"><span class="hljs-type">Deadend</span></span> $ (n, closed) ((m, opened) : ss) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> closed /= opened <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> embed . <span class="hljs-type"><span class="hljs-type">Left</span></span> $ <span class="hljs-type"><span class="hljs-type">Mismatch</span></span> (m, opened) (n, closed) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> build $ put ss <span class="hljs-keyword"><span class="hljs-keyword">where</span></span></code> </pre><br><h2>  Conclusion </h2><br>  En utilisant des sch√©mas d'ancrage, ayant une certaine composition de foncteurs, nous pouvons les transformer en transfom√®res et vice versa.  Malheureusement, une telle astuce ne fonctionnera pas avec la m√®re des monades - les suites.  Et tout cela parce qu'ils ne peuvent pas √™tre imagin√©s comme une composition de foncteurs, mais c'est possible comme une composition de professeurs ... Et pourtant, c'est une histoire compl√®tement diff√©rente. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code de biblioth√®que sur Github</a> |  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation de piratage</a> |  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemple de parenth√®se</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467683/">https://habr.com/ru/post/fr467683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467673/index.html">Fonctionnalit√©s Go int√©gr√©es</a></li>
<li><a href="../fr467675/index.html">Mod√©lisation de l'√©tat de l'application √† l'aide d'objets Store dans SwiftUI</a></li>
<li><a href="../fr467677/index.html">Tests ou types</a></li>
<li><a href="../fr467679/index.html">PyCrunch - Ex√©cution intelligente des tests et couverture visuelle du code dans l'IDE</a></li>
<li><a href="../fr467681/index.html">Vuln√©rabilit√© de d√©tournement de routage SOAP</a></li>
<li><a href="../fr467689/index.html">Un petit aper√ßu de SIMD en .NET / C #</a></li>
<li><a href="../fr467691/index.html">Intel Nervana NNP-T et NNP-I - puces sp√©cialis√©es pour l'IA</a></li>
<li><a href="../fr467693/index.html">R√©sum√© des √©v√©nements informatiques de septembre (deuxi√®me partie)</a></li>
<li><a href="../fr467697/index.html">Est-il vrai que GOPATH et GOROOT ne sont plus n√©cessaires?</a></li>
<li><a href="../fr467699/index.html">Comment ne pas faire le strlen le plus rapide et trouver une faille dans la communaut√© Visual Studio 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>