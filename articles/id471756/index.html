<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🔧 ☪️ 🕉️ Bagaimana server dimulai 🌙 📲 💃🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Memulai server adalah urutan tindakan yang panjang dan kompleks, tergantung pada komponen perangkat keras, pengaturan, dan perangkat lunak yang diguna...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana server dimulai</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/471756/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/hv/8v/zahv8vvh9_djipoukte16mkat-m.png"></div><br>  Memulai server adalah urutan tindakan yang panjang dan kompleks, tergantung pada komponen perangkat keras, pengaturan, dan perangkat lunak yang digunakan.  Banyak, bahkan administrator sistem yang berpengalaman dan berkualifikasi, memiliki gagasan yang buruk tentang apa yang sebenarnya terjadi ketika server mulai, jadi kami memutuskan untuk menganalisis proses ini secara terperinci. <br><a name="habracut"></a><br>  Agar tidak membongkar semua kemungkinan kasus, kami akan mempertimbangkan memuat dalam kondisi berikut: <br><br><ul><li>  Prosesor Intel 64-bit; </li><li>  Mode boot lama </li><li>  MBR mempartisi disk; </li><li>  boot loader GRUB2. </li></ul><br><h2>  Bangun dan bernyanyi </h2><br>  Aktivasi server dimulai dengan berbagai cara, di antaranya menekan tombol <b>Power On</b> adalah yang paling umum, tetapi bukan satu-satunya.  Pilihan lain adalah melalui perintah melalui jaringan ( <b>Wake-on-LAN</b> ) atau melalui perintah dari perangkat eksternal ( <b>Wake-on-PCIe</b> , <b>Wake-on-Keyboard</b> , <b>Wake-on-Mouse</b> ).  Perintah dijalankan hanya jika parameter yang sesuai diaktifkan di <b>BIOS Setup Utility</b> , yang akan kita bicarakan nanti. <br><br>  Perangkat terpisah adalah modul BMC, yang menyediakan kemampuan manajemen server tingkat lanjut.  Baca lebih lanjut tentang teknologi ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di blog kami</a> . <br><br>  Metode sebelumnya cerdas dan membutuhkan pengiriman perintah yang dibentuk khusus pada bus data.  Cara yang lebih sederhana: nyalakan ketika listrik disuplai ke power supply.  Dalam pengaturan BIOS, parameter ini disebut <b>AC Power Loss</b> dan mengambil salah satu dari tiga status: <br><br><ul><li>  <b>Matikan</b> - server akan tetap mati. </li><li>  <b>Power On</b> - server akan menyala. </li><li>  <b>Status Terakhir</b> - server hanya akan hidup jika dihidupkan pada saat listrik mati. </li></ul><br>  Dengan menggunakan metode ini, Anda dapat mengirim sinyal <b>Reset</b> ke prosesor dan memulai prosedur start. <br><br><h2>  Unduh program pertama </h2><br>  Langkah pertama dalam memulai server adalah menyalakan catu daya dan mengatur sinyal <b>Reset</b> untuk prosesor.  Jika ada sinyal <b>Reset</b> , generator frekuensi prosesor tidak berfungsi, dan register prosesor diatur ulang ke nilai yang ditetapkan oleh pabrik prosesor. <br><br>  Ketika mulai dalam catu daya, transien terjadi, karena tegangan output mungkin di luar batas yang diizinkan, yang akan berdampak negatif pada prosesor yang bekerja.  Oleh karena itu, sinyal <b>Atur Ulang</b> tidak dihapus sampai daya masuk sepenuhnya stabil. <br><br>  Setelah menstabilkan tegangan, catu daya menetapkan sinyal <b>Power Good</b> .  Sinyal ini berarti bahwa motherboard dapat memulai semua komponen server.  Selanjutnya, chipset memetakan ke ruang alamat semua perangkat yang terhubung, termasuk ROM (memori hanya baca) dengan kode <b>Basic Input / Output System</b> (BIOS).  Selanjutnya, sinyal <b>Reset</b> dihapus dan generator frekuensi prosesor dimulai. <br><br>  BIOS - sistem yang menyediakan API untuk bekerja dengan peralatan dan perangkat yang terhubung.  Salah satu tujuan penting dari BIOS adalah menginisialisasi dan menguji perangkat keras saat startup. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/az/vh/fh/azvhfhkglubk080zk7rxwuahs1y.jpeg" title="ROM BIOS pada SuperMicro X8DTL-3 Motherboard"></div><br>  Terlepas dari jumlah prosesor dalam sistem, ketika server dimulai, hanya satu inti dari satu prosesor yang bangun, dan inti yang tersisa tetap dalam mode tidur.  Inti terbangun dilambangkan oleh <b>Bootstrap Processor</b> (BSP, selanjutnya disebut sebagai prosesor).  Setelah sinyal <b>Reset</b> menghilang, register prosesor diisi sedemikian rupa sehingga prosesor beroperasi dalam mode 32-bit khusus yang disebut <b>Mode Proses Awal</b> . <br><br>  <b>Mode Prosesor Awal</b> - mode operasi yang digunakan prosesor 64-bit hanya setelah reset.  Dalam mode ini, prosesor mampu menjalankan instruksi 32-bit, dan ruang alamat 4 GiB. <br><br>  Setelah sinyal <b>Reset</b> menghilang, penghitung perintah prosesor menunjuk ke alamat <b>0xFFFFFFF0</b> , yang disebut <b>Reset Vector</b> .  Di alamat ini terletak perintah pertama yang diterjemahkan dan dieksekusi prosesor. <blockquote>  Menempatkan instruksi pertama di akhir ruang alamat memiliki justifikasi historis.  Saat mengembangkan prosesor Intel 8086, pada awal ruang alamat adalah vektor interupsi, diikuti oleh RAM, yang jumlahnya bisa berapa saja.  Untuk menghindari persimpangan dengan RAM, alamat perintah pertama diambil di akhir ruang alamat. <br><br>  Kemudian, dengan munculnya Intel 80286, vektor interupsi dapat dipindahkan ke mana saja.  Namun, bahkan prosesor modern berjalan dalam mode kompatibilitas dengan 8086 dan vektor interupsi pada 0x0. </blockquote>  Saat mengakses alamat <b>0xFFFFFFF0,</b> prosesor menerima perintah pertama dari ROM.  Dalam mode Legacy, perintah ini adalah <b>lompat</b> <b>jauh</b> atau <b>Jauh</b> ke segmen memori dengan kode BIOS.  Setelah menyelesaikan lompatan panjang pertama, prosesor memasuki <b>Mode Real</b> 16-bit dan mulai menjalankan kode BIOS. <br><br>  <b>Real Mode</b> - mode kompatibilitas dengan prosesor 16-bit yang ketinggalan jaman.  Dalam mode ini, hanya 16-bit perintah yang tersedia, dan ruang alamat, yang disebut "memori lebih rendah", hanya berisi 1 MiB. <br><br>  Seperti disebutkan sebelumnya, kode yang dapat dijalankan BIOS disimpan pada perangkat eksternal, yang operasinya tidak terlalu cepat, sehingga hal pertama yang dilakukan BIOS adalah menginisialisasi RAM dan menyalin kode sendiri dari ROM ke dalamnya.  BIOS mempertahankan kompatibilitas dengan prosesor yang sudah usang, karena itu, ia melakukan semua tindakan dalam mode 16-bit. <br><br><h2>  Power On Self-Test </h2><br>  Power On Self-Test (POST) adalah langkah kunci dalam BIOS.  POST disingkat dan lengkap.  POST lengkap memeriksa semua pengontrol yang tersedia dan menguji semua RAM yang tersedia, yang dapat memakan waktu. <br><br>  POST yang disingkat mempercepat proses boot dan mencakup serangkaian tindakan minimum yang diperlukan: <br><br><ul><li>  memeriksa integritas program BIOS dalam ROM menggunakan mekanisme verifikasi checksum; </li><li>  deteksi dan inisialisasi pengendali utama, bus sistem dan perangkat yang terhubung; </li><li>  menentukan ukuran RAM dan menguji segmen pertama (64 kilobyte); </li><li>  transfer kendali ke bootloader. </li></ul><br>  Ketika melewati POST, server menggunakan beberapa cara untuk mencerminkan informasi tentang jalannya tes.  Cara paling umum: <br><br><ul><li>  menampilkan pengidentifikasi tes, <b>kode POST</b> di layar, atau menggunakan indikator tujuh segmen pada motherboard; </li><li>  indikasi suara; </li><li>  alarm ringan dengan kombinasi LED. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uj/ee/_1/ujee_1g778z_8j-oayfruxy64ru.png" title="BIOS menampilkan kode POST di sudut kanan bawah"></div><br>  Cara paling informatif untuk mendapatkan informasi tentang kemungkinan kerusakan adalah dengan menampilkan kode POST saat ini.  Setelah berhasil menyelesaikan tes, kode dengan cepat saling menggantikan, tetapi jika terjadi kegagalan fungsi, POST berhenti dan Anda dapat melihat pengidentifikasi dari tes yang gagal.  Pabrikan Motherboard selalu melampirkan decoding, yang berarti kode tertentu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/xi/xx/zmxixxhixw3a651-iaqof1j5u9i.jpeg" title="Indikator tujuh segmen server ASUS ESC8000 G3 berhenti pada 0xB0"></div><br>  Pada motherboard modern ada indikasi LED yang memungkinkan Anda mengidentifikasi komponen yang salah.  Jika server mulai berhasil, Anda dapat mendengar bunyi bip yang menunjukkan bahwa POST berhasil.  Dengan durasi dan jumlah sinyal suara, juga dimungkinkan untuk menentukan komponen yang gagal. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/_a/f3/gp/_af3gpangdbwzgkka2d-tcwegiy.png" title="Kartu POST PCI Profesional (source.wikipedia.org)"></a> </div><br>  Dalam beberapa kasus, ketika akurasi maksimum diperlukan untuk diagnostik, Anda dapat menggunakan perangkat eksternal yang disebut kartu POST.  Motherboard mengirim informasi tentang tes POST pada bus data, dan kartu POST memproses informasi ini dan menampilkannya menggunakan indikator yang tersedia. <br><br><h2>  Utilitas Pengaturan BIOS </h2><br>  BIOS memiliki menu pengaturan khusus yang disebut <b>BIOS Setup Utility</b> .  Anda dapat memasukkannya dengan menekan tombol khusus saat melewati POST.  Paling sering, tombol untuk memasuki BIOS adalah <b>Del</b> dan <b>F2</b> , namun saat memuat, selalu ditunjukkan kunci mana yang akan membuka pengaturan BIOS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hh/lj/jt/hhljjttanyeib8whct5ikuqmlqw.png" title="UEFI BIOS Setup Menu - Aptio Setup Utility"></div><br>  <b>BIOS Setup Utility</b> menyediakan antarmuka untuk konfigurasi, yang hanya membutuhkan keyboard untuk berkomunikasi.  BIOS Setup Utility memberikan informasi tentang perangkat keras yang diinstal dan memungkinkan Anda untuk mengubah parameter pengoperasian motherboard dan peralatan yang terhubung. <br><br>  Kemungkinan nama dan opsi parameter ini atau itu bergantung pada banyak faktor, di antaranya: <br><br><ul><li>  Versi BIOS </li><li>  model motherboard; </li><li>  model peralatan yang dipasang di motherboard. </li></ul><br>  Di antara parameter kami tertarik pada <b>Prioritas Boot</b> .  Prioritas boot menentukan urutan di mana perangkat polling BIOS menemukan area bootnya.  Segera setelah BIOS menemukan area boot, kontrol ditransfer ke bootloader dan langkah selanjutnya dimulai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/wb/eo/qqwbeoxvdxqehipvcp7cmzsmopa.png" title="Unduh Prioritas dalam Aptio Setup Utility"></div><br><h2>  Pemuat OS </h2><br>  Setelah melewati POST, BIOS mencari area booting, menyurvei perangkat dalam urutan yang ditentukan.  Dalam mode <b>Legacy</b> , area boot pada disk disebut <b>Master Boot Record</b> (MBR).  MBR adalah struktur khusus yang terletak di 512 byte pertama disk.  512 byte ini berisi data berikut: <br><br><ul><li>  <b>kode tahap pertama bootloader</b> - dari 0 hingga 445 byte; </li><li>  <b>tabel partisi</b> - dari 446 hingga 509 byte; </li><li>  <b>Angka ajaib adalah 0xAA55</b> - dari 510 hingga 511 byte. </li></ul><br>  Jika tidak ada angka ajaib <b>0xAA55</b> , maka dianggap bahwa catatan MBR pada disk ini tidak ditemukan dan BIOS memproses polling disk berikutnya. <br><br>  Ketika BIOS menemukan catatan MBR, ia menyalinnya dari disk ke RAM di alamat <b>0x7C00</b> dan <b>melompat</b> ke alamat ini.  Setelah lompatan, tahap pertama ( <b>Tahap 1</b> ) dari bootloader dimulai.  Karena ukuran terbatas, tujuan tahap pertama adalah memuat kode tahap kedua ( <b>Tahap 2</b> ) ke dalam memori dan mentransfer kontrol ke sana. <br><br>  Kode <b>Tahap 2</b> disimpan segera setelah struktur MBR dan sampai awal partisi disk pertama.  Secara historis, celah ini mengandung 31 KB memori, dan dalam sistem modern ini mencapai 1 MB.  Namun, untuk menjaga kompatibilitas, ukuran tahap kedua tidak melebihi 31 KB. <br><br>  Tahap kedua mempersiapkan lingkungan untuk meluncurkan tahap ketiga: <br><br><ul><li>  Memuat driver sistem file yang diperlukan </li><li>  menemukan kode tahap ketiga pada sistem file; </li><li>  memuat kode ke dalam RAM dan mentransfer kontrol ke sana. </li></ul><br>  Tugas <b>tahap 3</b> bermuara pada pengaturan minimal lingkungan dan bootloader: <br><br><ul><li>  mentransfer prosesor ke <b>Mode Terlindungi</b> ; </li><li>  Unduh ekstensi GRUB2 yang diinstal </li><li>  temukan <b>Tahap 4</b> pada sistem file dan berikan kontrol. </li></ul><br>  <b>Mode Terlindungi</b> - mode kompatibilitas dengan prosesor x86.  Dalam mode ini, prosesor mampu menjalankan instruksi 32-bit, dan ruang alamat diperluas hingga 4 GiB.  Inovasi signifikan telah muncul dalam Mode Terlindungi, misalnya: <br><br><ul><li>  memori paging; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cincin perlindungan</a> ; </li><li>  memori virtual. </li></ul><br>  Tahap keempat ( <b>Tahap 4</b> ) sudah bekerja dalam mode 32-bit, jika perlu, itu dimuat dari disk ekspansi GUI, "parsing" file <b>grub.cfg</b> dan menampilkan menu pilihan OS yang sudah dikenal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jb/z6/qk/jbz6qkpcfksjvjlleuw5s2wfo68.png" title="Menu Utama GRUB2"></div><br><h2>  Kernel OS </h2><br>  GRUB2 mengikuti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi Multiboot</a> untuk memuat kernel yang dapat dieksekusi.  Bootloader memeriksa angka ajaib <b>0x1BADB002</b> di awal kernel dan memeriksa checksum untuk memastikan kernel tersebut kompatibel dengan spesifikasi.  Setelah verifikasi berhasil, kernel dapat dimuat ke dalam RAM dan ditransfer ke sana. <br><br>  Menurut spesifikasi yang sama, bootloader memberikan informasi sistem kepada kernel, seperti: <br><br><ul><li>  mode prosesor saat ini; </li><li>  jumlah RAM yang terdeteksi; </li><li>  jenis output video (teks atau piksel); </li><li>  resolusi layar. </li></ul><br>  Terlepas dari kenyataan bahwa bootloader menggunakan driver sistem file dan, mungkin, ekstensi untuk antarmuka grafis, kernel bootable tidak akan menerima semua hal-hal indah ini.  Pertama-tama, setelah mendapatkan kontrol, kernel "mengungkapkan" potensi penuh server dan menempatkan prosesor dalam <b>Mode Panjang</b> . <br><br>  <b>Long Mode</b> - mode utama prosesor 64-bit.  Dalam mode ini, prosesor dapat menjalankan instruksi 64-bit dan menggunakan register tujuan umum 64-bit.  Ruang alamat menampung 16 EIB.  Long Mode menghapus organisasi memori tersegmentasi yang melekat dalam arsitektur 32-bit. <br><br>  Meskipun ruang alamat sangat besar untuk mengatasi memori fisik, hanya 48 bit dari kemungkinan 64 yang digunakan, yang mengurangi jumlah maksimum RAM menjadi 256 TiB, yang 65.536 kali lebih sedikit daripada ruang alamat.  Di masa mendatang, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">direncanakan untuk</a> memperluas pengalamatan fisik menjadi 57 bit. <br><br>  Setelah beralih ke Long Mode, kernel melakukan serangkaian tindakan minimum yang diperlukan untuk operasi: <br><br><ul><li>  Mengkonfigurasi memori paging </li><li>  memuat driver dan menginisialisasi peralatan yang digunakan; </li><li>  Mengkonfigurasi penjadwal memori dan proses </li><li>  menemukan dan mulai init. </li></ul><br>  Adalah penting bahwa sebelum mengkonfigurasi penjadwal proses, server bekerja pada satu inti, yang disebut BSP.  Mengkonfigurasi scheduler membangunkan sisa kernel yang disebut <b>Application Processor</b> (AP).  Kernel tidak memiliki koneksi langsung antara satu sama lain, dan komunikasinya dilakukan melalui interrupt handler <b>lokal</b> yang disebut <b>Local Advanced Programmable Interrupt Controller</b> (LAPIC). <br><br>  Kernel sistem operasi diluncurkan pada BSP, yang selama inisialisasi menerima informasi tentang prosesor yang tersedia dalam sistem menggunakan tabel ACPI.  BSP, menggunakan LAPIC-nya sendiri, mengirimkan serangkaian interupsi “ <b>Init</b> - <b>StartUp</b> - <b>StartUp</b> ” untuk membangunkan semua AP.  Setelah memulai, prosesor aplikasi juga perlu diinisialisasi dan ditransfer ke Long Mode, tetapi sekarang proses ini lebih cepat, karena pekerjaan ini telah dilakukan oleh prosesor utama. <br><br>  Setelah semua AP diinisialisasi, penjadwal proses memulai proses layanan yang disebut " <b>tidak bertindak</b> " atau <b>Idle</b> .  Seperti namanya, proses ini tidak melakukan apa-apa dan mengambil prosesor ketika tidak ada proses lain. <br><br>  Ketika semuanya sudah dikonfigurasi dan siap untuk bekerja, kernel dari sistem operasi memulai proses pertama di ruang pengguna - <b>Init</b> .  Itu, pada gilirannya, memulai sisa proses di ruang pengguna.  Setelah proses init dimulai, kernel masuk ke mode siaga dan tidak aktif sampai tugas muncul di ruang kernel. <br><br>  Setelah memulai semua proses, server menjadi tersedia melalui jaringan, dan pada konsol Anda dapat melihat prompt Masuk di layar. <br><br><h2>  Kesimpulan </h2><br>  Sekilas, startup server yang sederhana dan cepat dan memuat sistem operasi sebenarnya adalah proses yang rumit dan membingungkan dengan banyak nuansa.  Bagian dari proses ini adalah evolusi kecil yang mengembangkan kekuatan pemrosesan prosesor dari prosesor 16-bit lama ke "monster" 64-bit modern. <br><br>  Dan bagaimana menurut Anda, ketika prosesor 128-bit muncul, apakah akan ada mode kompatibilitas dengan yang 16-bit di dalamnya? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471756/">https://habr.com/ru/post/id471756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471742/index.html">Sberbank AI Journey. Bagaimana kami mengajar jaringan saraf untuk mengikuti ujian</a></li>
<li><a href="../id471744/index.html">Tarantool Data Grid: Arsitektur dan Fitur</a></li>
<li><a href="../id471746/index.html">Panduan Lengkap untuk Mengkonfigurasi Judul HTTP untuk Keamanan</a></li>
<li><a href="../id471748/index.html">Optimalisasi farmasi: apa yang kami lakukan dengan matematika</a></li>
<li><a href="../id471750/index.html">Manajemen Akses Privileged sebagai tugas prioritas dalam keamanan informasi (misalnya, Fudo PAM)</a></li>
<li><a href="../id471758/index.html">Bagaimana cara menerjemahkan teks ke bahasa lain?</a></li>
<li><a href="../id471760/index.html">Edward Snowden: The Battlefield - Enkripsi</a></li>
<li><a href="../id471766/index.html">Penanganan kesalahan Kotlin / Java: bagaimana melakukannya dengan benar?</a></li>
<li><a href="../id471770/index.html">Temui Big Data Tools: Spark dan Zeppelin Notebook Support di IntelliJ IDEA</a></li>
<li><a href="../id471772/index.html">Alat untuk meluncurkan dan mengembangkan aplikasi Java, kompilasi, eksekusi pada JVM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>