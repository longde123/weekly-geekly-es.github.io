<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔴 ⛽️ 👩🏻‍🔧 改进了groovy脚本的沙箱 🤾🏼 🙅🏻 🌨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="译者的话：开发CUBA平台时，我们在此框架中具有执行自定义脚本的能力，以便更灵活地配置应用程序业务逻辑。 这个机会是好是坏（我们不仅在谈论CUBA）已经争论了很长时间，但是必须控制用户脚本的执行这一事实并没有引起任何疑问。 CédricChampeau的此翻译介绍了Groovy管理自定义脚本执行的有...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>改进了groovy脚本的沙箱</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/445114/"><p><img src="https://habrastorage.org/webt/l7/d9/cg/l7d9cgoh4tjgptdfr68phnooab4.jpeg"></p><br><p>  <em>译者的话：开发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CUBA平台时，</a>我们在此框架中具有执行自定义脚本的能力，以便更灵活地配置应用程序业务逻辑。</em>  <em>这个机会是好是坏（我们不仅在谈论CUBA）已经争论了很长时间，但是必须控制用户脚本的执行这一事实并没有引起任何疑问。</em>  <em>CédricChampeau的此翻译介绍了Groovy管理自定义脚本执行的有用功能之一。</em>  <em>尽管事实上他最近离开了Groovy开发团队，但程序员社区似乎在很长一段时间内一直在利用他的工作。</em> </p><br><p> 使用Groovy的最常用方法之一是通过脚本编写，因为Groovy使得在运行时动态地执行代码变得容易。 取决于应用程序，脚本可以位于不同的位置：文件系统，数据库，远程服务...，但是最重要的是，执行脚本的应用程序开发人员不一定要编写它们。 此外，脚本可以在有限的环境（内存有限，文件描述符数量限制，运行时...）中工作，或者您可能希望阻止用户使用脚本中的所有语言功能。 </p><br><p>  <strong>这篇文章会告诉你。</strong> </p><br><ul><li> 为什么groovy适合编写内部dsl </li><li> 就您的应用程序的安全性而言，其功能是什么 </li><li> 如何配置编译以改善DSL </li><li>关于<code>SecureASTCustomizer</code>的价值 </li><li> 关于类型控制扩展 </li><li> 如何使用类型控制扩展使沙盒有效 </li></ul><a name="habracut"></a><br><p> 例如，想象一下您需要做什么，以便用户可以计算数学表达式。 一种实现方式是嵌入内部DSL，创建解析器，最后是这些表达式的解释器。 当然，要做到这一点，就必须工作，但是如果需要提高生产率，例如，通过为表达式生成字节码而不是在解释器中计算它们或使用运行时生成的类的缓存，那么Groovy是一个不错的选择。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>介绍了许多选项，但是最简单的示例只是使用<code>Eval</code>类： </p><br><p> <code>Example.java</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = (Integer) Eval.me(<span class="hljs-string"><span class="hljs-string">"1+1"</span></span>);</code> </pre> <br><p>  Groovy在运行时将<code>1+1</code>代码解析，编译为字节码，加载并执行。 当然，此示例中的代码非常简单，您将需要添加参数，但是想法是可执行代码可以是任意的。 而这可能并不是您真正需要的。 在计算器中，您需要允许以下内容： </p><br><pre> <code class="plaintext hljs">1+1 x+y 1+(2*x)**y cos(alpha)*r v=1+x</code> </pre> <br><p> 但肯定不是 </p><br><pre> <code class="plaintext hljs">println 'Hello' (0..100).each { println 'Blah' } Pong p = new Pong() println(new File('/etc/passwd').text) System.exit(-1) Eval.me('System.exit(-1)') // a script within a script!</code> </pre> <br><p> 困难从这里开始，而且很明显，我们需要解决一些问题： </p><br><ul><li> 将语言的语法限制为其功能的子集 </li><li> 防止用户执行未提供的代码 </li><li> 防止执行恶意代码 </li></ul><br><p> 带有计算器的示例非常简单，但是对于更复杂的DSL，人们可能不会注意到他们正在编写有问题的代码，尤其是在DSL如此简单以至于<em>开发人员</em>无法使用<em>它的情况下</em> 。 </p><br><p> 几年前，我处于这种情况。 我开发了一种引擎，该引擎运行由语言学家编写的Groovy“脚本”。 例如，一个问题是它们可能会无意间造成无限循环。 该代码在服务器上执行，并且出现了占用100％CPU的线程，此后有必要重新启动应用程序服务器。 我必须寻找一种解决问题的方法，而又不影响DSL，工具或应用程序的性能。 </p><br><p> 实际上，许多人也有类似的需求。 在过去的4年中，我一直在与很多有相同问题的人交谈： <em>如何防止用户在Groovy脚本中胡说八道？</em> </p><br><h2 id="kastomayzery-kompilyacii"> 定制编译器 </h2><br><p> 那时，我已经有了自己的决定，而且我知道其他人也开发了类似的东西。 最后，Guillaume Laforge建议我在Groovy内核中创建一种机制来帮助解决这些问题。 它在Groovy 1.8.0中作为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编译定制器出现</a> 。 </p><br><p> 编译定制器是一组类，可修改Groovy脚本的编译过程。 您可以编写自己的定制程序，但是Groovy提供了： </p><br><ul><li> 导入自定义程序，可将导入内容隐式添加到脚本中，因此用户无需添加导入说明 </li><li> 定制程序AST（抽象语法树）转换，使您可以将AST转换直接添加到脚本中 </li><li> 限制语言的语法和语法构造的安全AST定制程序 </li></ul><br><p>  AST转换的定制器帮助我解决了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>@ThreadInterrupt</code></a>转换带来的无限循环问题，但是在大多数情况下， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SecureASTCustomizer</a>可能是最容易被误解的东西。 </p><br><p> 我对此表示歉意。 然后我想不出一个更好的名字。 名称“ SecureASTCustomizer”中最重要的部分是<strong>AST</strong> 。 该机制的目的是限制对某些AST功能的访问。 标题中的“安全”一词通常是多余的，我将解释原因。 甚至还有詹金斯（Jenkins）著名的川口<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浩</a>介（Kosuke Kawaguchi）的博客文章，标题为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Fatal Groovy SecureASTCustomizer”</a> 。 那里的所有内容都写得非常正确。  SecureASTCustomizer不是为沙盒设计的。 创建它是为了在编译时限制语言，而不是执行时。 现在我认为最好的名字应该是<em>GrammarCustomizer</em> 。 但是，正如您肯定知道的那样，计算机科学中存在三个困难：缓存失效，创建名称和每单位错误。 </p><br><p> 现在想象一下，您正在考虑使用安全的AST定制器作为确保脚本安全性的一种方法，而您的任务是防止用户从脚本中<code>System.exit</code> 。 该文档说，可以通过创建黑名单或白名单来禁止特殊接收器中的呼叫。 如果需要安全性，我总是建议严格列出允许使用的白名单，而不建议禁止使用任何东西的黑名单。 因为黑客总是思考您可能没有考虑的内容。 我举一个例子。 </p><br><p> 这是使用<code>SecureASTCustomizer</code>设置原始沙箱脚本引擎的方法。 尽管我可以用Groovy编写它们，但我给出了Java配置示例以使集成代码和脚本之间的区别更加明显。 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); SecureASTCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureASTCustomizer(); customizer.setReceiversBlackList(Arrays.asList(System.class.getName())); conf.addCompilationCustomizers(customizer); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(conf); Object v = shell.evaluate(<span class="hljs-string"><span class="hljs-string">"System.exit(-1)"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Result = "</span></span> +v); } }</code> </pre> <br><ol><li> 创建编译器配置 </li><li> 创建安全的AST定制器 </li><li> 声明将<code>System</code>类作为方法调用的接收者列入黑名单 </li><li> 将定制程序添加到编译器配置 </li><li> 将配置与shell脚本绑定，即尝试创建沙箱 </li><li> 运行“坏”脚本 </li><li> 显示运行脚本的结果 </li></ol><br><p> 如果运行此类，则在脚本执行期间将发生错误： </p><br><pre> <code class="plaintext hljs">General error during canonicalization: Method calls not allowed on [java.lang.System] java.lang.SecurityException: Method calls not allowed on [java.lang.System]</code> </pre> <br><p> 该结论由具有安全AST定制器的应用程序发布，该应用程序不允许执行<code>System</code>类的方法。 成功！ 因此，我们已经保护了脚本！ 但是等一下... </p><br><h2 id="secureastcustomizer-vzloman">  SecureASTCustomizer被黑了！ </h2><br><p> 保护，说什么？ 但是，如果我这样做： </p><br><pre> <code class="java hljs">def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p> 如果再次运行该程序，您将看到它崩溃<strong>而没有</strong>错误，并且<strong>没有</strong>在屏幕上显示结果。 进程退出代码为-1，表示用户脚本已运行！ 发生什么事了 在编译时，安全AST定制器<code>c.exit</code>能识别<code>c.exit</code>是对<code>System</code>方法的调用，因为它在AST级别上起作用！ 它分析方法调用，在这种情况下，方法调用为<code>c.exit(-1)</code> ，然后确定接收方并检查其是否在白名单（或黑名单）中。 在这种情况下，接收方为<code>c</code> ，此变量<strong>通过def声明</strong> ，这与将其声明为<code>Object</code> ，并且安全AST定制程序将认为变量<code>c</code>的类型为<code>Object</code> ，而不是<code>System</code> ！ </p><br><p> 通常，有<strong>很多</strong>方法可以解决在安全AST定制器上创建的各种配置。 这里有一些很酷的： </p><br><pre> <code class="java hljs">((Object)System).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) Class.forName(<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span>).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span> as Class).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.<span class="hljs-function"><span class="hljs-function">exit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br><p> 还会有更多。  Groovy的动态特性排除了在编译时修复这些问题的能力。 但是，确实存在解决方案。 一种选择是依赖标准的JVM安全管理器。 但是，这对于整个系统来说是一个庞大而庞大的解决方案，这等效于向麻雀发射大炮。 此外，它并非在所有情况下都有效，例如，如果您要禁止读取文件，但不希望创建文件，则无法执行... </p><br><p> 这种局限性（对我们许多人而言是一种烦恼）导致基于<strong>运行时检查</strong>的解决方案的创建。 这种检查没有这种问题。 例如，因为在开始验证方法调用之前，您将知道消息的实际接收者类型。 以下实现是特别令人感兴趣的： </p><br><ul><li>  Jim White <a href="">撰写的SecureScript</a> </li><li> 川口浩介的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Groovy Sandbox</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Groovy Sandbox</a> ，Simon Temple提供 </li></ul><br><p> 但是，这些实现都不是完全可靠和安全的。 例如，Kosuke的版本基于对缓存调用站点的内部实现的破解。 问题在于它与Groovy的invokedynamic版本不兼容，并且这些内部类将不在Groovy的未来版本中。 另一方面，Simon的版本基于AST转换，但是留下了许多潜在的漏洞。 </p><br><p> 结果，我的朋友Corinne Crisch，Fabrice Matrat和Sebastian Blanc，我决定在运行时创建一种新的沙箱机制，不会出现这些项目这样的问题。 我们开始在尼斯的黑客马拉松上实施它，在去年的Greach会议上，我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">就此做了报告</a> 。 该机制基于AST转换，本质上是重写代码以在每次方法调用之前进行检查，尝试访问类字段，增加变量，二进制表达式等。此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实现</a>仍未准备好，还没有完成很多工作，因此当我意识到通过“隐式this”调用的方法和参数的问题尚未解决时，例如在构建器中： </p><br><pre> <code class="plaintext hljs">xml { cars { // cars is a method call on an implicit this: "this".cars(...) car(make:'Renault', model: 'Clio') } }</code> </pre> <br><p> 到目前为止，由于Groovy中的元对象协议的体系结构，我仍然没有找到解决此问题的方法，该体系基于以下事实：接收方在切换到另一个接收方之前无法找到该方法时会抛出异常。 简而言之，这意味着您无法在实际方法调用之前找出接收器的类型。 如果通话已通过，那就太迟了... </p><br><p> 直到最近，对于可执行脚本使用语言的动态属性的情况，我还没有针对此问题的最佳解决方案。 但是现在是时候解释一下，如果您准备牺牲一点语言的活力，那么如何可以大大改善这种情况。 </p><br><h2 id="proverka-tipov"> 类型检查 </h2><br><p> 让我们回到SecureASTCustomizer的主要问题：它与抽象语法树一起使用，并且没有有关特定消息类型和接收者的信息。 但是对于Groovy 2，Groovy添加了编译，在Groovy 2.1中，我们添加了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用于类型检查的扩展</a> 。 </p><br><p> 类型检查的扩展功能非常强大：它们使Groovy DSL开发人员可以帮助编译器进行类型推断，并且还可以在通常不发生错误的情况下生成编译错误。 例如，在实现traits或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">标记模板引擎</a>时，Groovy在内部使用这些扩展来支持静态编译器。 </p><br><p> 如果我们可以依靠类型检查机制的信息来代替解析器的结果，该怎么办？ 采取我们的黑客试图编写的代码： </p><br><p> <code>((Object)System).exit(-1)</code> </p> <br><p> 如果激活类型检查，则代码不会编译： </p><br><pre> <code class="plaintext hljs">1 compilation error: [Static type checking] - Cannot find matching method java.lang.Object#exit(java.lang.Integer). Please check if the declared type is right and if the method exists.</code> </pre> <br><p> 因此，此代码不再编译。 如果我们采用以下代码，该怎么办： </p><br><pre> <code class="java hljs">def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p> 如您所见，它通过类型检查，包装在方法中并使用<code>groovy</code>命令执行： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@groovy</span></span>.transform.TypeChecked <span class="hljs-comment"><span class="hljs-comment">// or even @CompileStatic void foo() { def c = System c.exit(-1) } foo()</span></span></code> </pre> <br><p> 类型检查器检测到从<code>System</code>类调用了<code>exit</code>方法，并且该方法是有效的。 这对我们没有帮助。 但是我们知道的是，如果此代码通过类型检查，则意味着编译器可以识别对类型为<code>System</code>的接收者的调用。 通常，该想法是禁止带有扩展名的呼叫进行类型检查。 </p><br><h2 id="prostoe-rasshirenie-dlya-proverki-tipov"> 用于类型检查的简单扩展 </h2><br><p> 在详细研究沙箱之前，让我们尝试在标准扩展的帮助下“保护”脚本的类型，以进行类型检查。 注册这样的扩展很容易：只需为<code>@TypeChecked</code>注释设置<code>extensions</code>参数（如果使用静态编译，则设置<code>@TypeChecked</code> ）： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TypeChecked</span></span>(extensions=[<span class="hljs-string"><span class="hljs-string">'SecureExtension1.groovy'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) } foo()</code> </pre> <br><p> 扩展搜索将以源代码格式在类路径中进行（您可以进行预编译的扩展以进行类型检查，但在本文中我们将不考虑它们）： </p><br><p> <code>SecureExtension1.groovy</code> </p> <br><pre> <code class="java hljs">onMethodSelection { expr, methodNode -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodNode.declaringClass.name==<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span>) { addStaticTypeError(<span class="hljs-string"><span class="hljs-string">"Method call is not allowed!"</span></span>, expr) } }</code> </pre> <br><ol><li> 当类型检查器选择要调用的方法时 </li><li> 如果该方法属于<code>System</code>类 </li><li> 然后让类型检查器生成错误 </li></ol><br><p> 这就是您所需要的。 现在再次运行代码，您将看到编译错误！ </p><br><pre> <code class="plaintext hljs">/home/cchampeau/tmp/securetest.groovy: 6: [Static type checking] - Method call is not allowed! @ line 6, column 3. c.exit(-1) ^ 1 error</code> </pre> <br><p> 这次，由于类型检查器的帮助， <code>c</code>识别为<code>System</code>类的一个实例，我们可以禁止该调用。 这是一个非常简单的示例，并且在配置方面没有演示安全AST定制程序可以完成的所有操作。 在我们<strong>编写</strong>的扩展中，检查是<strong>硬编码的</strong> ，但是最好使它们可定制。 因此，让示例变得更加复杂。 </p><br><p> 假设您的应用程序为文档计算某些指标，并允许用户自定义它们。 在这种情况下，DSL： </p><br><ul><li> 将操作（至少） <code>score</code>变量 </li><li> 允许用户执行数学运算（包括调用<em>cos</em> ， <em>abs</em> ，...方法） </li><li> 必须禁止所有其他方法 </li></ul><br><p> 样本用户脚本： </p><br><p> <code>abs(cos(1+score))</code> </p> <br><p> 此DSL易于配置。 这是我们上面定义的变体： </p><br><p> <code>Sandbox.java</code> </p> <br><pre> <code class="java hljs">CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); ImportCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImportCustomizer(); customizer.addStaticStars(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>); conf.addCompilationCustomizers(customizer); Binding binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Binding(); binding.setVariable(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>d); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(binding,conf); Double userScore = (Double) shell.evaluate(<span class="hljs-string"><span class="hljs-string">"abs(cos(1+score))"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"userScore = "</span></span> + userScore);</code> </pre> <br><ol><li> 添加导入定制程序，这会将<code>import static java.lang.Math.*</code>添加到所有脚本 </li><li> 使<code>score</code>变量可用于脚本 </li><li> 执行脚本 </li></ol><br><p>  <em>有一些方法可以缓存脚本，而不是每次都解析和编译脚本。</em>  <em>有关详细信息，请参见文档。</em> </p><br><p> 因此，我们的脚本可以工作，但是没有什么可以阻止黑客启动恶意代码。 由于我们计划使用类型检查，因此我建议使用<code>@CompileStatic</code>转换： </p><br><ul><li> 它会激活脚本中的类型检查，由于扩展了类型检查功能，我们将能够执行其他检查 </li><li> 提高脚本性能 </li></ul><br><p> 将<code>@CompileStatic</code>注释隐式添加到脚本非常简单。 您只需要更新编译器配置： </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer(CompileStatic.class); conf.addCompilationCustomizers(astcz);</code> </pre> <br><p> 现在，如果您尝试再次运行该脚本，将看到编译错误： </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - The variable [score] is undeclared. @ line 1, column 11. abs(cos(1+score)) ^ Script1.groovy: 1: [Static type checking] - Cannot find matching method int#plus(java.lang.Object). Please check if the declared type is right and if the method exists. @ line 1, column 9. abs(cos(1+score)) ^ 2 errors</code> </pre> <br><p> 发生什么事了 如果您从编译器的角度阅读脚本，那么很明显，他对变量“分数”一无所知。 但是作为开发人员，您知道这是一个<code>double</code>变量，但是编译器无法输出它。 为此，将创建用于类型检查的扩展：您可以为编译器提供其他信息，然后编译将正常进行。 在这种情况下，我们需要指出<code>score</code>变量的类型为<code>double</code> 。 </p><br><p> 因此，您可以稍微更改<code>@CompileStatic</code>批注的方式： </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension2.groovy"</span></span>)), CompileStatic.class);</code> </pre> <br><p> 这“模拟”了<code>@CompileStatic(extensions=['SecureExtension2.groovy'])</code>注释的代码<code>@CompileStatic(extensions=['SecureExtension2.groovy'])</code> 。 现在，当然，我们需要编写一个扩展程序来识别<code>score</code>变量： </p><br><p> <code>SecureExtension2.groovy</code> </p> <br><pre> <code class="java hljs">unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name==<span class="hljs-string"><span class="hljs-string">'score'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, double_TYPE) } }</code> </pre> <br><ol><li> 如果类型检查器无法确定变量 </li><li> 如果变量名称是<code>score</code> </li><li> 让编译器使用<code>double</code>类型动态定义变量 </li></ol><br><p> 可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在文档的此部分中</a>找到用于类型检查的DSL扩展的完整说明，但是有一个组合编译模式的示例：编译器无法定义<code>score</code>变量。 作为DSL开发人员，您<strong>知道</strong>变量实际上是其类型<code>makeDynamic</code> ，因此对<code>makeDynamic</code>的调用在这里说：“好吧，不用担心，我知道我在做什么，可以使用<code>double</code>类型动态定义此变量。 ” 仅此而已！ </p><br><h2 id="pervoe-zavershennoe-secure-rasshirenie"> 首次完成的“安全”扩展 </h2><br><p> 现在，让我们把它们放在一起。 我们编写了一个类型检查扩展程序，它一方面防止调用<code>System</code>类的方法，另一方面又定义了<code>score</code>变量。 因此，如果我们将它们连接起来，我们将获得第一个完整的扩展以进行类型检查： </p><br><p> <code>SecureExtension3.groovy</code> </p> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// disallow calls on System onMethodSelection { expr, methodNode -&gt; if (methodNode.declaringClass.name=='java.lang.System') { addStaticTypeError("Method call is not allowed!", expr) } } // resolve the score variable unresolvedVariable { var -&gt; if (var.name=='score') { return makeDynamic(var, double_TYPE) } }</span></span></code> </pre> <br><p> 记住要更新Java类中的配置，以使用新的扩展名进行类型检查： </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension3.groovy"</span></span>)), CompileStatic.class);</code> </pre> <br><p> 再次运行代码-它仍然有效。 现在尝试这个： </p><br><pre> <code class="plaintext hljs">abs(cos(1+score)) System.exit(-1)</code> </pre> <br><p> 脚本的编译将因错误而崩溃： </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - Method call is not allowed! @ line 1, column 19. abs(cos(1+score));System.exit(-1) ^ 1 error</code> </pre> <br><p> 恭喜，您刚刚编写了第一个防止恶意代码运行的类型检查扩展程序！ </p><br><h2 id="uluchshenie-konfiguracii-rasshireniya"> 增强的扩展配置 </h2><br><p> 因此，一切进展顺利，我们可以禁止调用<code>System</code>类的方法，但是似乎很快就会发现新的漏洞，并且我们将需要防止启动恶意代码。 因此，我们将尝试使扩展名通用且可定制，而不是对扩展名中的所有内容进行硬编码。 这可能是最困难的，因为没有直接方法将上下文传递给扩展进行类型检查。 因此，该思想基于使用线程局部变量（曲线方法，是）将配置数据传递给类型检查器。 </p><br><p> 首先，我们将使变量列表可定制。  Java代码如下所示： </p><br><p> <code>Sandbox.java</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String VAR_TYPES = <span class="hljs-string"><span class="hljs-string">"sandboxing.variable.types"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ThreadLocal&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); ImportCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImportCustomizer(); customizer.addStaticStars(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>); ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension4.groovy"</span></span>)), CompileStatic.class); conf.addCompilationCustomizers(astcz); conf.addCompilationCustomizers(customizer); Binding binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Binding(); binding.setVariable(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>d); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Map&lt;String,ClassNode&gt; variableTypes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, ClassNode&gt;(); variableTypes.put(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, ClassHelper.double_TYPE); Map&lt;String,Object&gt; options = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, Object&gt;(); options.put(VAR_TYPES, variableTypes); COMPILE_OPTIONS.set(options); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(binding, conf); Double userScore = (Double) shell.evaluate(<span class="hljs-string"><span class="hljs-string">"abs(cos(1+score));System.exit(-1)"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"userScore = "</span></span> + userScore); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { COMPILE_OPTIONS.remove(); } } }</code> </pre> <br><ol><li>  <code>ThreadLocal</code> ,          </li><li>    — <code>SecureExtension4.groovy</code> </li><li> <code>variableTypes</code> —   “  →  ” </li><li>      <code>score</code> </li><li> <code>options</code> —     </li><li>   "variable types"     VAR_TYPES </li><li>     thread local </li><li> ,    ,     thread local </li></ol><br><p>          : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) } }</code> </pre> <br><ol><li>        thread local </li><li>      ,      , </li><li>   type checker       </li></ol><br><p>         thread local,    ,  type checker  . ,      <code>unresolvedVariable</code> ,    ,  ,    type checker,   .  ,     .   ! </p><br><p>           .        ,       . </p><br><h2 id="konfiguraciya-belogo-spiska-metodov">     </h2><br><p>    .   ,       .      ,         ,     . ,  <code>System.exit</code> ,   : </p><br><pre> <code class="plaintext hljs">java.lang.System#exit(int)</code> </pre> <br><p> ,     Java,    : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String WHITELIST_PATTERNS = <span class="hljs-string"><span class="hljs-string">"sandboxing.whitelist.patterns"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... public static void main(String[] args) { // ... try { Map&lt;String,ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;(); variableTypes.put("score", ClassHelper.double_TYPE); Map&lt;String,Object&gt; options = new HashMap&lt;String, Object&gt;(); List&lt;String&gt; patterns = new ArrayList&lt;String&gt;(); patterns.add("java\\.lang\\.Math#"); options.put(VAR_TYPES, variableTypes); options.put(WHITELIST_PATTERNS, patterns); COMPILE_OPTIONS.set(options); GroovyShell shell = new GroovyShell(binding, conf); Double userScore = (Double) shell.evaluate("abs(cos(1+score));System.exit(-1)"); System.out.println("userScore = " + userScore); } finally { COMPILE_OPTIONS.remove(); } } }</span></span></code> </pre> <br><ol><li>    </li><li>    <code>java.lang.Math</code>   </li><li>        </li></ol><br><p>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> groovy.transform.CompileStatic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.MethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.Parameter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.ExtensionMethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassNode node)</span></span></span><span class="hljs-function"> </span></span>{ node.isArray()?<span class="hljs-string"><span class="hljs-string">"${prettyPrint(node.componentType)}[]"</span></span>:node.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toMethodDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExtensionMethodNode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toMethodDescriptor(node.extensionMethodNode) } def sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() sb.append(node.declaringClass.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) sb.append(node.name) sb.append(<span class="hljs-string"><span class="hljs-string">'('</span></span>) sb.append(node.parameters.collect { Parameter it -&gt; prettyPrint(it.originType) }.join(<span class="hljs-string"><span class="hljs-string">','</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">')'</span></span>) sb } def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS] onMethodSelection { expr, MethodNode methodNode -&gt; def descr = toMethodDescriptor(methodNode) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!whiteList.any { descr =~ it }) { addStaticTypeError(<span class="hljs-string"><span class="hljs-string">"You tried to call a method which is not allowed, what did you expect?: $descr"</span></span>, expr) } } unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) } }</code> </pre> <br><ol><li>       <code>MethodNode</code> </li><li>     thread local </li><li>       </li><li>        ,   </li></ol><br><p>      ,    : </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - You tried to call a method which is not allowed, what did you expect?: java.lang.System#exit(int) @ line 1, column 19. abs(cos(1+score));System.exit(-1) ^ 1 error</code> </pre> <br><p> ,  !        ,   <strong>  </strong> , <strong>  </strong>  .    ,      !     ,       ,       . ,   (  <code>foo.text</code> ,     <code>foo.getText()</code> ). </p><br><h2 id="sobiraem-vse-vmeste">    </h2><br><p>     ,    type checker'    "property selection", ,   .      ,         ,  .         ,     ,       —    .     . </p><br><p> <code>SandboxingTypeCheckingExtension.groovy</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> groovy.transform.CompileStatic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassCodeVisitorSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassHelper <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.MethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.Parameter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.expr.PropertyExpression <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.control.SourceUnit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.ExtensionMethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SandboxingTypeCheckingExtension</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyTypeCheckingExtensionSupport</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeCheckingDSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassNode node)</span></span></span><span class="hljs-function"> </span></span>{ node.isArray()?<span class="hljs-string"><span class="hljs-string">"${prettyPrint(node.componentType)}[]"</span></span>:node.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toMethodDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExtensionMethodNode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toMethodDescriptor(node.extensionMethodNode) } def sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() sb.append(node.declaringClass.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) sb.append(node.name) sb.append(<span class="hljs-string"><span class="hljs-string">'('</span></span>) sb.append(node.parameters.collect { Parameter it -&gt; prettyPrint(it.originType) }.join(<span class="hljs-string"><span class="hljs-string">','</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">')'</span></span>) sb } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Fetch white list of regular expressions of authorized method calls def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS] def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] onMethodSelection { expr, MethodNode methodNode -&gt; def descr = toMethodDescriptor(methodNode) if (!whiteList.any { descr =~ it }) { addStaticTypeError("You tried to call a method which is not allowed, what did you expect?: $descr", expr) } } unresolvedVariable { var -&gt; if (isDynamic(var) &amp;&amp; typesOfVariables[var.name]) { storeType(var, typesOfVariables[var.name]) handled = true } } // handling properties (like foo.text) is harder because the type checking extension // does not provide a specific hook for this. Harder, but not impossible! afterVisitMethod { methodNode -&gt; def visitor = new PropertyExpressionChecker(context.source, whiteList) visitor.visitMethod(methodNode) } } private class PropertyExpressionChecker extends ClassCodeVisitorSupport { private final SourceUnit unit private final List&lt;String&gt; whiteList PropertyExpressionChecker(final SourceUnit unit, final List&lt;String&gt; whiteList) { this.unit = unit this.whiteList = whiteList } @Override protected SourceUnit getSourceUnit() { unit } @Override void visitPropertyExpression(final PropertyExpression expression) { super.visitPropertyExpression(expression) ClassNode owner = expression.objectExpression.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER) if (owner) { if (expression.spreadSafe &amp;&amp; StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(owner, classNodeFor(Collection))) { owner = typeCheckingVisitor.inferComponentType(owner, ClassHelper.int_TYPE) } def descr = "${prettyPrint(owner)}#${expression.propertyAsString}" if (!whiteList.any { descr =~ it }) { addStaticTypeError("Property is not allowed: $descr", expression) } } } } }```     sandbox',     assert' ,  ,     : ``Sandbox.java`` ```java public class Sandbox { public static final String WHITELIST_PATTERNS = "sandboxing.whitelist.patterns"; public static final String VAR_TYPES = "sandboxing.variable.types"; public static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = new ThreadLocal&lt;Map&lt;String, Object&gt;&gt;(); public static void main(String[] args) { CompilerConfiguration conf = new CompilerConfiguration(); ImportCustomizer customizer = new ImportCustomizer(); customizer.addStaticStars("java.lang.Math"); ASTTransformationCustomizer astcz = new ASTTransformationCustomizer( singletonMap("extensions", singletonList("SandboxingTypeCheckingExtension.groovy")), CompileStatic.class); conf.addCompilationCustomizers(astcz); conf.addCompilationCustomizers(customizer); Binding binding = new Binding(); binding.setVariable("score", 2.0d); try { Map&lt;String, ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;(); variableTypes.put("score", ClassHelper.double_TYPE); Map&lt;String, Object&gt; options = new HashMap&lt;String, Object&gt;(); List&lt;String&gt; patterns = new ArrayList&lt;String&gt;(); // allow method calls on Math patterns.add("java\\.lang\\.Math#"); // allow constructors calls on File patterns.add("File#&lt;init&gt;"); // because we let the user call each/times/... patterns.add("org\\.codehaus\\.groovy\\.runtime\\.DefaultGroovyMethods"); options.put(VAR_TYPES, variableTypes); options.put(WHITELIST_PATTERNS, patterns); COMPILE_OPTIONS.set(options); GroovyShell shell = new GroovyShell(binding, conf); Object result; try { result = shell.evaluate("Eval.me('1')"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("System.exit(-1)"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("((Object)Eval).me('1')"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("new File('/etc/passwd').getText()"); // getText is not allowed assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("new File('/etc/passwd').text"); // getText is not allowed assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } Double userScore = (Double) shell.evaluate("abs(cos(1+score))"); System.out.println("userScore = " + userScore); } finally { COMPILE_OPTIONS.remove(); } } }</span></span></code> </pre> <br><h2 id="zaklyuchenie"> 结论 </h2><br><p>      Groovy       JVM.        ,      . ,    ,    ,      .  ,    Groovy,      sandboxing'          (,       ,   ). </p><br><p>  ,            ,          .      ,            .  ,      ,        . </p><br><p>    ,   sandboxing',   , —  <strong></strong>  <code>SecureASTCustomizer</code> .    <strong> ,  </strong> ,       : secure AST customizer    ,      (,       ),              (   ,   ). </p><br><p> ,    : ,   , .   Groovy   .          Groovy,   ,  -      pull request,      -  ! <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN445114/">https://habr.com/ru/post/zh-CN445114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN445104/index.html">Klipsch音频品牌的简要历史</a></li>
<li><a href="../zh-CN445106/index.html">圆桌会议：添加剂技术替代传统制造</a></li>
<li><a href="../zh-CN445108/index.html">不是一个猎鹰-根本不同的可重用ESA和ULA项目</a></li>
<li><a href="../zh-CN445110/index.html">具有辐射型终端驱动器的计算机</a></li>
<li><a href="../zh-CN445112/index.html">揭示网站上的各种漏洞</a></li>
<li><a href="../zh-CN445116/index.html">美国空军正在研发一种名为Skyborg的AI无人机</a></li>
<li><a href="../zh-CN445118/index.html">在私人电报聊天中，您可以删除任何消息-甚至是陌生人（已添加投票结果）</a></li>
<li><a href="../zh-CN445120/index.html">前端每周摘要（2019年3月18日至24日）</a></li>
<li><a href="../zh-CN445122/index.html">上周第357期（2019年3月18日至24日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN445124/index.html">Firefox的中等强化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>