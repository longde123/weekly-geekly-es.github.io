<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèä ‚ùî üßëüèº Wie ich eine Flugsuchmaschine von PHP zu NodeJS umgeschrieben habe üëë üëÜüèª ‚úäüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo. Mein Name ist Andrey, ich bin ein Doktorand an einer der technischen Universit√§ten von Moskau und Teilzeit  sehr bescheiden  Anf√§nger Unternehm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie ich eine Flugsuchmaschine von PHP zu NodeJS umgeschrieben habe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444400/"><p>  Hallo.  Mein Name ist Andrey, ich bin ein Doktorand an einer der technischen Universit√§ten von Moskau und Teilzeit <del>  sehr bescheiden </del>  Anf√§nger Unternehmer und Entwickler.  In diesem Artikel habe ich beschlossen, meine Erfahrungen mit dem Wechsel von PHP (das mir einst wegen seiner Einfachheit gefallen hat, aber schlie√ülich von mir gehasst wurde - ich erkl√§re, warum unter dem Schnitt) zu NodeJS zu teilen.  Hier k√∂nnen sehr triviale und scheinbar elementare Aufgaben gestellt werden, die ich pers√∂nlich w√§hrend meiner Bekanntschaft mit NodeJS und den Funktionen der serverseitigen Entwicklung in JavaScript pers√∂nlich l√∂sen wollte.  Ich werde versuchen, klar zu erkl√§ren und zu demonstrieren, dass PHP endlich in den Sonnenuntergang gegangen ist und NodeJS Platz gemacht hat.  Vielleicht ist es sogar n√ºtzlich, wenn jemand einige Funktionen zum Rendern von HTML-Seiten in Node lernt, die urspr√ºnglich aus dem Wort √ºberhaupt nicht angepasst wurden. </p><a name="habracut"></a><br><h2 id="vvedenie">  Einf√ºhrung </h2><br><p>  Beim Schreiben der Engine habe ich die einfachsten Techniken verwendet.  Keine Paketmanager, kein Routing.  Nur Hardcore-Ordner, deren Name mit der angeforderten Route √ºbereinstimmt, und <strong>index.php</strong> in jedem von ihnen, die von PHP-FPM zur Unterst√ºtzung des Prozesspools konfiguriert wurden.  Sp√§ter wurde es notwendig, Composer und Laravel zu verwenden, was f√ºr mich der letzte Strohhalm war.  Bevor ich zu der Geschichte √ºbergehe, warum ich mich √ºberhaupt dazu entschlossen habe, alles von PHP auf NodeJS umzuschreiben, m√∂chte ich Ihnen ein wenig √ºber den Hintergrund erz√§hlen. </p><br><h3 id="menedzher-paketov">  Paketmanager </h3><br><p>  Ende 2018 arbeitete ich zuf√§llig mit einem in Laravel geschriebenen Projekt.  Es war notwendig, mehrere Fehler zu beheben, √Ñnderungen an der vorhandenen Funktionalit√§t vorzunehmen und einige neue Schaltfl√§chen in der Benutzeroberfl√§che hinzuzuf√ºgen.  Der Prozess begann mit der Installation des Paket- und Abh√§ngigkeitsmanagers.  In PHP wird hierf√ºr Composer verwendet.  Dann stellte der Kunde einen Server mit 1 Kern und 512 Megabyte RAM zur Verf√ºgung, und dies war meine erste Erfahrung mit Composer.  Bei der Installation von Abh√§ngigkeiten auf einem virtuellen privaten Server mit 512 Megabyte Speicher st√ºrzte der Prozess aufgrund von Speichermangel ab. </p><br><p><img src="https://habrastorage.org/webt/pg/jm/hh/pgjmhhg0efngekrokj1yryvdzxg.png" alt="Wut?"></p><br><p> F√ºr mich als Person, die mit Linux vertraut ist und Erfahrung in der Arbeit mit Debian und Ubuntu hat, war die L√∂sung dieses Problems offensichtlich - die Installation einer SWAP-Datei (Swap-Datei - f√ºr diejenigen, die mit der Linux-Administration nicht vertraut sind).  Ein unerfahrener unerfahrener Entwickler, der beispielsweise seine erste Laravel-Distribution auf Digital Ocean installiert hat, geht einfach zum Control Panel und erh√∂ht den Tarif, bis die Installation von Abh√§ngigkeiten mit einem Speichersegmentierungsfehler beendet wird.  Was ist mit NodeJS? <br>  Und NodeJS hat einen eigenen Paketmanager - npm.  Es ist viel einfacher zu bedienen, kompakter und kann auch in einer Umgebung mit minimalem RAM-Speicher verwendet werden.  Im Allgemeinen gibt es nichts, was Composer vor dem Hintergrund von NPM verantwortlich machen k√∂nnte. Im Falle von Fehlern bei der Installation von Paketen st√ºrzt Composer jedoch wie eine normale PHP-Anwendung ab und Sie werden nie wissen, welcher Teil des Pakets installiert wurde und ob es am Ende installiert wurde endet.  Im Allgemeinen ist f√ºr den Linux-Administrator die abgest√ºrzte Installation = R√ºckblenden im Rettungsmodus und <code>dpkg --configure -a</code> .  Als mich solche ‚Äû√úberraschungen‚Äú √ºberholten, mochte ich PHP nicht, aber dies waren die letzten N√§gel im Sarg meiner einst gro√üen Liebe zu PHP. </p><br><h2 id="long-term-support-i-problema-versionirovaniya">  Problem mit langfristiger Unterst√ºtzung und Versionierung </h2><br><p>  Erinnern Sie sich, welche Art von Hype und Erstaunen PHP7 verursachte, als die Entwickler es zum ersten Mal pr√§sentierten?  Steigerung der Produktivit√§t um mehr als das Zweifache und bei einigen Komponenten um das F√ºnffache!  Erinnerst du dich, als die siebte PHP-Version geboren wurde?  Und wie schnell hat WordPress verdient!  Es war Dezember 2015.  Wussten Sie, dass PHP 7.0 jetzt als veraltete Version von PHP gilt und es dringend empfohlen wird, es zu aktualisieren ... Nein, nicht auf Version 7.1, sondern auf Version 7.2.  Laut den Entwicklern ist Version 7.1 bereits der aktiven Unterst√ºtzung beraubt und erh√§lt nur Sicherheitsupdates.  Und nach 8 Monaten wird dies aufh√∂ren.  Es wird zusammen mit der aktiven Unterst√ºtzung und Version 7.2 eingestellt.  Es stellt sich heraus, dass PHP bis Ende dieses Jahres nur eine aktuelle Version haben wird - 7.3. </p><br><p><img src="https://habrastorage.org/webt/zd/0p/me/zd0pmebltmchxqafrdw5yfpdfta.png" alt="Aktuelle PHP-Versionen"></p><br><p>  Eigentlich w√§re dies kein Nit-Picking und ich w√ºrde dies nicht den Gr√ºnden f√ºr meine Abkehr von PHP zuschreiben, wenn die Projekte, die ich in PHP 7.0 geschrieben habe. * Bereits beim √ñffnen keine Warnung vor Verfall verursacht.  Kehren wir zu dem Projekt zur√ºck, bei dem die Installation von Abh√§ngigkeiten abgest√ºrzt ist.  Dies war ein Projekt, das 2015 auf Laravel 4 mit PHP 5.6 geschrieben wurde.  Es schien, dass nur 4 Jahre vergangen waren, aber nein - eine Reihe von Verfallswarnungen, veraltete Module, die Unf√§higkeit, normalerweise aufgrund einer Reihe von Root-Engine-Updates auf Laravel 5 zu aktualisieren. </p><br><p>  Und das gilt nicht nur f√ºr Laravel.  Versuchen Sie, w√§hrend der aktiven Unterst√ºtzung der ersten Versionen von PHP 7.0 eine PHP-Anwendung zu schreiben, und verbringen Sie Ihren Abend damit, nach L√∂sungen f√ºr Probleme zu suchen, die in veralteten PHP-Modulen aufgetreten sind.  Schlie√ülich eine interessante Tatsache: Die Unterst√ºtzung f√ºr PHP 7.0 wurde fr√ºher eingestellt als die Unterst√ºtzung f√ºr PHP 5.6.  F√ºr eine Sekunde. </p><br><p>  Was ist mit NodeJS?  Ich w√ºrde nicht sagen, dass hier alles viel besser ist und dass sich die Support-Zeiten f√ºr NodeJS grundlegend von denen f√ºr PHP unterscheiden.  Nein, hier ist es ungef√§hr gleich - jede LTS-Version wird 3 Jahre lang unterst√ºtzt.  Aber NodeJS hat ein bisschen mehr von diesen aktuellsten Versionen. </p><br><p><img src="https://habrastorage.org/webt/ff/xf/x_/ffxfx_rhvieo0jmad4wnabdrwuy.png" alt="Aktuelle Versionen von NodeJS"></p><br><p>  Wenn Sie eine 2016 geschriebene Anwendung bereitstellen m√ºssen, stellen Sie sicher, dass Sie damit absolut keine Probleme haben.  Version 6. * wird √ºbrigens erst im April dieses Jahres nicht mehr unterst√ºtzt.  Und vorne sind 8, 10, 11 und die kommenden 12. </p><br><h2 id="o-trudnostyah-i-syurprizah-pri-perehode-na-nodejs">  Schwierigkeiten und √úberraschungen beim Wechsel zu NodeJS </h2><br><p>  Ich beginne vielleicht mit der f√ºr mich aufregendsten Frage, wie HTML-Seiten in NodeJS gerendert werden.  Aber denken wir zuerst daran, wie dies in PHP gemacht wird: </p><br><ol><li>  Betten Sie HTML direkt in PHP-Code ein.  Dies gilt auch f√ºr alle Neulinge, die MVC noch nicht erreicht haben.  Und so wird es in WordPress gemacht, was absolut schrecklich ist. </li><li>  Verwenden Sie MVC, um die Interaktion des Entwicklers zu vereinfachen und das Projekt in Teile zu unterteilen. In Wirklichkeit erschwert dieser Ansatz jedoch nur zeitweise alles. </li><li>  Verwenden Sie eine Template-Engine.  Die bequemste Option, aber nicht in PHP.  Schauen Sie sich einfach die in Twig oder Blade vorgeschlagene Syntax mit geschweiften Klammern und Prozents√§tzen an. </li></ol><br><p>  Ich bin ein leidenschaftlicher Gegner der Kombination oder Zusammenf√ºhrung mehrerer Technologien.  HTML muss separat existieren, Stile daf√ºr separat, JavaScript separat (in React sieht dies im Allgemeinen monstr√∂s aus - HTML und JavaScript werden gemischt).  Aus diesem Grund ist eine Vorlagen-Engine die ideale Option f√ºr Entwickler mit Vorlieben wie meinen.  Ich musste lange nicht mehr nach einer Webanwendung auf NodeJS suchen und entschied mich f√ºr Jade (PugJS).  Sch√§tzen Sie einfach die Einfachheit der Syntax: </p><br><pre> <code class="plaintext hljs"> div.row.links div.col-lg-3.col-md-3.col-sm-4 h4.footer-heading . div.copyright div.copy-text 2017 - #{current_year} . div.contact-link span : a(href='mailto:hello@flaut.ru') hello@flaut.ru</code> </pre> <br><p>  Hier ist alles ganz einfach: Ich habe eine Vorlage geschrieben, sie in die Anwendung heruntergeladen, einmal kompiliert und dann zu jeder beliebigen Zeit an einem beliebigen Ort verwendet.  Meiner Meinung nach ist die PugJS-Leistung etwa zweimal besser als das Rendern durch Einbetten von HTML in PHP-Code.  Wenn fr√ºher in PHP eine statische Seite vom Server in etwa 200 bis 250 Millisekunden generiert wurde, betr√§gt diese Zeit jetzt etwa 90 bis 120 Millisekunden (wir sprechen nicht √ºber das Rendern in PugJS, sondern √ºber die Zeit, die von der Seitenanforderung bis zur Antwort des Servers an den Client mit bereitem HTML ben√∂tigt wird )  So sieht das Laden und Kompilieren von Vorlagen und ihren Komponenten beim Start der Anwendung aus: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pugs = {} fs.readdirSync(__dirname + <span class="hljs-string"><span class="hljs-string">'/templates/'</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(file.endsWith(<span class="hljs-string"><span class="hljs-string">'.pug'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filepath = __dirname + <span class="hljs-string"><span class="hljs-string">'/templates/'</span></span> + file pugs[file.split(<span class="hljs-string"><span class="hljs-string">'.pug'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]] = pug.compile(fs.readFileSync(filepath, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: filepath }) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(e) } } }) <span class="hljs-comment"><span class="hljs-comment">//       return pugs.tickets({ ...config })</span></span></code> </pre> <br><p>  Es sieht unglaublich einfach aus, aber mit Jade war die Arbeit mit bereits kompiliertem HTML etwas komplex.  Tatsache ist, dass zum Implementieren von Skripten auf der Seite eine asynchrone Funktion verwendet wird, die alle <code>.js</code> Dateien aus dem Verzeichnis <code>.js</code> und jedem von ihnen das Datum ihrer letzten √Ñnderung hinzuf√ºgt.  Die Funktion hat folgende Form: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; files.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> period = files[i].lastIndexOf(<span class="hljs-string"><span class="hljs-string">'.'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// get last dot in filename let filename = files[i].substring(0, period) let extension = files[i].substring(period + 1) if(extension === 'js') { let fullFilename = filename + '.' + extension if(env === 'production') { scripts.push({ path: paths.production.web + fullFilename, mtime: await getMtime(paths.production.code + fullFilename)}) } else { if(files[i].startsWith('common') || files[i].startsWith('search')) { scripts.push({ path: paths.developer.scripts.web + fullFilename, mtime: await getMtime(paths.developer.scripts.code + fullFilename)}) } else { scripts.push({ path: paths.developer.vendor.web + fullFilename, mtime: await getMtime(paths.developer.vendor.code + fullFilename)}) } } } }</span></span></code> </pre> <br><p>  Bei der Ausgabe erhalten wir ein Array von Objekten mit zwei Eigenschaften - dem Pfad zur Datei und der Zeit, zu der sie zuletzt im Zeitstempel bearbeitet wurde (zum Aktualisieren des Client-Cache).  Das Problem ist, dass selbst beim Sammeln von Skriptdateien aus einem Verzeichnis alle streng alphabetisch in den Speicher geladen werden (da sie sich im Verzeichnis selbst befinden und die Dateien darin von oben nach unten gesammelt werden - vom ersten bis zum letzten).  Dies f√ºhrte dazu, dass die Datei <strong>app.js</strong> zuerst geladen wurde und bereits danach die Datei <strong>core.min.js</strong> mit Polyfills und Vendor.min.js ganz am Ende.  Dieses Problem wurde ganz einfach gel√∂st - sehr banale Sortierung: </p><br><pre> <code class="javascript hljs">scripts.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a.path.includes(<span class="hljs-string"><span class="hljs-string">'core.min.js'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a.path.includes(<span class="hljs-string"><span class="hljs-string">'vendor.min.js'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> })</code> </pre> <br><p>  In PHP hatte alles ein monstr√∂ses Aussehen in Form von Pfaden zu JS-Dateien, die in einer Zeichenfolge vorab geschrieben wurden.  Einfach aber unpraktisch. </p><br><h3 id="nodejs-derzhit-svoyo-prilozhenie-v-operativnoy-pamyati">  NodeJS beh√§lt seine Anwendung im RAM </h3><br><p>  Das ist ein gro√ües Plus.  Alles ist f√ºr mich so angeordnet, dass auf dem Server parallel und unabh√§ngig voneinander zwei separate Sites vorhanden sind - die Version f√ºr den Entwickler und die Produktionsversion.  Stellen Sie sich vor, ich habe einige √Ñnderungen an den PHP-Dateien auf der Entwicklungssite vorgenommen und muss diese √Ñnderungen in der Produktion einf√ºhren.  Dazu m√ºssen Sie den Server stoppen oder einen "sorry, tech. Work" -Stub einf√ºgen und zu diesem Zeitpunkt Dateien einzeln aus dem Entwicklerordner in den Produktionsordner kopieren.  Dies f√ºhrt zu Ausfallzeiten und kann zum Verlust von Conversions f√ºhren.  Der Vorteil der <strong>In-Memory-Anwendung</strong> in NodeJS besteht f√ºr mich darin, dass alle √Ñnderungen an den Engine-Dateien erst nach dem Neustart vorgenommen werden.  Dies ist sehr praktisch, da Sie alle erforderlichen Dateien mit den √Ñnderungen kopieren und erst dann den Server neu starten k√∂nnen.  Der Vorgang dauert nicht l√§nger als 1-2 Sekunden und verursacht keine Ausfallzeiten. <br>  Der gleiche Ansatz wird beispielsweise in Nginx verwendet.  Sie bearbeiten zuerst die Konfiguration, √ºberpr√ºfen sie mit <code>nginx -t</code> und nehmen erst dann √Ñnderungen mit dem <code>service nginx reload</code> </p><br><h3 id="klasterizaciya-nodejs-prilozheniya">  Clustering einer NodeJS-Anwendung </h3><br><p>  NodeJS hat ein sehr praktisches Tool - <strong>pm2</strong> process <strong>manager</strong> .  Wie f√ºhren wir normalerweise Anwendungen in Node aus?  Wir gehen in die Konsole und schreiben den <code>node index.js</code> .  Sobald wir die Konsole schlie√üen, wird die Anwendung geschlossen.  Zumindest passiert dies auf einem Server mit Ubuntu.  Um dies zu vermeiden und die Anwendung immer am Laufen zu halten, f√ºgen Sie sie <strong>einfach mit dem</strong> einfachen <code>pm2 start index.js --name production</code> .  Das ist aber noch nicht alles.  Das Tool erm√∂glicht die √úberwachung ( <code>pm2 monit</code> ) und das Clustering von Anwendungen. </p><br><p>  Erinnern wir uns, wie Prozesse in PHP organisiert sind.  Angenommen, wir haben Nginx, das http-Anfragen bedient, und wir m√ºssen die Anfrage an PHP weiterleiten.  Sie k√∂nnen dies entweder direkt tun und dann wird bei jeder Anforderung ein neuer PHP-Prozess erzeugt, und wenn er abgeschlossen ist, wird er beendet.  Oder Sie k√∂nnen einen Fastcgi-Server verwenden.  Ich denke, jeder wei√ü, was es ist und es besteht keine Notwendigkeit, auf Details einzugehen, aber nur f√ºr den Fall, ich werde klarstellen, dass PHP-FPM am h√§ufigsten als Fastcgi verwendet wird und seine Aufgabe darin besteht, viele PHP-Prozesse zu erzeugen, die jederzeit bereit sind, eine neue Anfrage anzunehmen und zu verarbeiten.  Was ist der Nachteil dieses Ansatzes? </p><br><p>  Das erste ist, dass Sie nie wissen, wie viel Speicher Ihre Anwendung verbraucht.  Zweitens ist die maximale Anzahl von Prozessen immer begrenzt, und dementsprechend verwendet Ihre PHP-Anwendung bei einem starken Anstieg des Datenverkehrs entweder den gesamten verf√ºgbaren Speicher und st√ºrzt ab oder ruht sich an der zul√§ssigen Prozessgrenze aus und beginnt, alte Prozesse zu beenden.  Dies kann verhindert werden, indem ich nicht wei√ü, welcher Parameter in der PHP-FPM-Konfigurationsdatei <strong>dynamisch ist</strong> und dann zu diesem Zeitpunkt so viele Prozesse wie n√∂tig erzeugt werden.  Aber auch hier verbraucht ein elementarer DDoS-Angriff den gesamten Arbeitsspeicher und stellt Ihren Server auf.  Oder ein Fehlerskript verbraucht beispielsweise den gesamten Arbeitsspeicher und der Server friert f√ºr einige Zeit ein (es gab Pr√§zedenzf√§lle im Entwicklungsprozess). </p><br><p>  Der grundlegende Unterschied bei NodeJS besteht darin, dass die Anwendung nicht mehr als 1,5 Gigabyte RAM verbrauchen kann.  Es gibt keine Prozessbeschr√§nkungen, es gibt nur ein Speicherlimit.  Dies ermutigt Sie, so leichte Programme wie m√∂glich zu schreiben.  Dar√ºber hinaus ist es sehr einfach, die Anzahl der Cluster zu berechnen, die wir uns leisten k√∂nnen, abh√§ngig von der verf√ºgbaren CPU-Ressource.  Es wird empfohlen, nicht mehr als einen Cluster an jeden Kern zu h√§ngen (genau wie in Nginx, nicht mehr als einen Worker pro CPU-Kern). </p><br><p><img src="https://habrastorage.org/webt/rk/z4/hp/rkz4hp9g8jkptpmq_tbc-_gpdpu.png" alt="Clustering in PM2"></p><br><p>  Ein Vorteil dieses Ansatzes besteht darin, dass PM2 nacheinander alle Cluster neu l√§dt.  Zur√ºck zum vorherigen Absatz, in dem es um Ausfallzeiten von 1-2 Sekunden w√§hrend des Neustarts ging.  Wenn Sie den Server im Cluster-Modus neu starten, tritt in Ihrer Anwendung keine Ausfallzeit von Millisekunden auf. </p><br><h3 id="nodejs---eto-horoshiy-shveycarskiy-nozh">  NodeJS ist ein gutes Schweizer Messer </h3><br><p>  Jetzt gibt es eine solche Situation, in der PHP als Sprache zum Schreiben von Websites fungiert und Python als Tool zum Crawlen dieser Websites fungiert.  NodeJS ist 2 in 1, einerseits eine Gabel, andererseits ein L√∂ffel.  Sie k√∂nnen schnelle und leistungsstarke Anwendungen und Webcrawler auf demselben Server in derselben Anwendung schreiben.  Klingt verlockend.  Aber wie kann das realisiert werden, fragen Sie?  Google selbst hat die offizielle Chromium API - Puppeteer eingef√ºhrt.  Sie k√∂nnen Headless Chrome (einen Browser ohne Benutzeroberfl√§che - "Headless" Chrome) starten und den gr√∂√ütm√∂glichen Zugriff auf die Browser-API erhalten, um Seiten zu crawlen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die einfachste und zug√§nglichste Art, mit Puppenspieler zu arbeiten</a> . </p><br><p>  In unserer VKontakte-Gruppe werden beispielsweise regelm√§√üig Rabatte und Sonderangebote f√ºr verschiedene Ziele aus den St√§dten der GUS ver√∂ffentlicht.  Wir generieren Bilder f√ºr Beitr√§ge im automatischen Modus, und um sie sch√∂n zu machen, brauchen wir sch√∂ne Bilder.  Ich m√∂chte mich nicht an verschiedene APIs binden und Konten auf Dutzenden von Websites erstellen. Deshalb habe ich eine einfache Anwendung geschrieben, die einen normalen Nutzer mit dem Google Chrome-Browser nachahmt, der mit Stock-Bildern auf der Website heruml√§uft und das durch das Keyword gefundene Bild zuf√§llig aufnimmt.  Fr√ºher habe ich daf√ºr Python und BeautifulSoup verwendet, jetzt ist dies nicht mehr erforderlich.  Das Hauptmerkmal und der Vorteil von Puppeteer ist, dass Sie sogar SPA-Websites problemlos betr√ºgen k√∂nnen, da Ihnen ein vollwertiger Browser zur Verf√ºgung steht, der JavaScript-Code auf Websites versteht und ausf√ºhrt.  Es ist schmerzlich einfach: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({<span class="hljs-attr"><span class="hljs-attr">headless</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">args</span></span>:[<span class="hljs-string"><span class="hljs-string">'--no-sandbox'</span></span>]}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = (<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.pages())[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">`https://pixabay.com/photos/search/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${imageKeyword}</span></span></span><span class="hljs-string">/?cat=buildings&amp;orientation=horizontal`</span></span>, { <span class="hljs-attr"><span class="hljs-attr">waitUntil</span></span>: <span class="hljs-string"><span class="hljs-string">'networkidle0'</span></span> })</code> </pre> <br><p>  Also haben wir in 3 Codezeilen den Browser gestartet und die Site-Seite mit Archivbildern ge√∂ffnet.  Jetzt k√∂nnen wir einen zuf√§lligen Block mit dem Bild auf der Seite ausw√§hlen und ihm eine Klasse hinzuf√ºgen, in der wir sp√§ter auf die gleiche Weise umbl√§ttern und direkt mit dem Bild selbst zur Seite gehen k√∂nnen, um sie weiter zu laden: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imagesLength = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.evaluate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> photos = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'.search_results &gt; .item'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(photos.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { photos[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * photos.length)].className += <span class="hljs-string"><span class="hljs-string">' --anomaly_selected'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> photos.length })</code> </pre> <br><p>  Erinnern Sie sich daran, wie viel Code erforderlich w√§re, um dies in PhantomJS zu schreiben (das √ºbrigens geschlossen wurde und eng mit dem Puppeteer-Entwicklungsteam zusammenarbeitete).  Kann solch ein wunderbares Tool jemanden davon abhalten, zu NodeJS zu wechseln? </p><br><h3 id="v-nodejs-zalozhena-asinhronnost-na-fundamentalnom-urovne">  NodeJS bietet grundlegende Asynchronit√§t </h3><br><p>  Dies kann als gro√üer Vorteil von NodeJS und JavaScript angesehen werden, insbesondere mit dem Aufkommen von async / await in ES2017.  Im Gegensatz zu PHP, wo jeder Anruf synchron get√§tigt wird.  Ich werde ein einfaches Beispiel geben.  Fr√ºher wurden in der Suchmaschine Seiten auf dem Server generiert, aber auf der Seite, die bereits im Client vorhanden war, musste etwas mit JavaScript angezeigt werden. Zu diesem Zeitpunkt war Yandex jedoch noch nicht in der Lage, JavaScript auf Websites zu verwenden, und musste einen Snapshot-Mechanismus (Seiten-Snapshots) speziell daf√ºr implementieren. mit Prerender.  Schnappsch√ºsse wurden auf unserem Server gespeichert und auf Anfrage an den Roboter gesendet.  Das Dilemma bestand darin, dass diese Bilder innerhalb von 3 bis 5 Sekunden erstellt wurden. Dies ist v√∂llig inakzeptabel und kann das Ranking der Website in den Suchergebnissen beeinflussen.  Um dieses Problem zu l√∂sen, wurde ein einfacher Algorithmus erfunden: Wenn der Roboter eine Seite anfordert, von der wir bereits einen Schnappschuss haben, geben wir ihm einfach den vorhandenen Schnappschuss. Anschlie√üend f√ºhren wir den Vorgang aus, um im Hintergrund einen neuen Schnappschuss zu erstellen und ihn zu ersetzen bereits verf√ºgbar.  Wie es in PHP gemacht wurde: </p><br><pre> <code class="php hljs">exec(<span class="hljs-string"><span class="hljs-string">'/usr/bin/php '</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">'/snapshot.php -a '</span></span> . $affiliation_type . <span class="hljs-string"><span class="hljs-string">' -l '</span></span> . urlencode($full_uri) . <span class="hljs-string"><span class="hljs-string">' &gt; /dev/null 2&gt;/dev/null &amp;'</span></span>);</code> </pre> <br><p>  Mach das niemals. <br>  In NodeJS kann dies durch Aufrufen der asynchronen Funktion erreicht werden: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveSnapshot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ getSnapshot().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> { db.saveSnapshot().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">status</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(status.err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }) }) } <span class="hljs-comment"><span class="hljs-comment">/** *     await * ..    resolve()   */</span></span> saveSnapshot()</code> </pre> <br><p>  Kurz gesagt, Sie versuchen nicht, die Synchronit√§t zu umgehen, sondern entscheiden, wann die synchrone Codeausf√ºhrung und wann die asynchrone Codeausf√ºhrung verwendet werden soll.  Und es ist wirklich praktisch.  Besonders wenn Sie die M√∂glichkeiten von <strong>Promise.all () kennenlernen</strong> </p><br><p>  Die Flugsuchmaschine selbst ist so konzipiert, dass sie eine Anfrage an einen zweiten Server sendet, der Daten sammelt und aggregiert, und sich dann an sie wendet, um bereitgestellte Daten zu erhalten.  Richtungsseiten werden verwendet, um organischen Verkehr anzuziehen. </p><br><p>  F√ºr die Abfrage "Fl√ºge Moskau St. Petersburg" wird beispielsweise eine Seite mit der Adresse <em>/ tickets / moscow / saint-petersburg / ausgegeben</em> , die Daten ben√∂tigt: </p><br><ol><li>  Flugpreise in diese Richtung f√ºr den laufenden Monat </li><li>  Flugpreise in diese Richtung f√ºr das kommende Jahr (Durchschnittspreis f√ºr jeden Monat f√ºr die n√§chsten 12 Monate) </li><li>  Planen Sie Fl√ºge in diese Richtung </li><li>  Beliebte Ziele aus der Versandstadt - aus Moskau (zum Verkn√ºpfen) </li><li>  Beliebte Ziele aus der Ankunftsstadt sind St. Petersburg (zum Verkn√ºpfen) </li></ol><br><p>  In PHP wurden alle diese Anforderungen synchron ausgef√ºhrt - nacheinander.  Die durchschnittliche API-Antwortzeit pro Anforderung betr√§gt 150-200 Millisekunden.  Wir multiplizieren 200 mit 5 und erhalten im Durchschnitt eine Sekunde, um Anforderungen an den Server mit Daten zu erf√ºllen.  NodeJS hat eine gro√üartige Funktion <strong>namens Promise.all</strong> , die alle Anforderungen parallel ausf√ºhrt, das Ergebnis jedoch <strong>einzeln</strong> schreibt.  Der Ausf√ºhrungscode f√ºr alle f√ºnf der oben genannten Anforderungen w√ºrde beispielsweise folgenderma√üen aussehen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> [montlyPrices, yearlyPrices, flightsSchedule, originPopulars, destPopulars] = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ getMontlyPrices(), getYearlyPrices(), getFlightSchedule(), getOriginPopulars(), getDestPopulars() ])</code> </pre> <br><p>  Und wir erhalten alle Daten in 200-300 Millisekunden, wodurch sich die Datengenerierungszeit f√ºr die Seite von 1-1,5 Sekunden auf ~ 500 Millisekunden verringert. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Der Wechsel von PHP zu NodeJS hat mir geholfen, mich mit asynchronem JavaScript vertraut zu machen, zu lernen, wie man mit Versprechungen arbeitet und asynchron / wartet.  Nach dem Umschreiben der Engine wurde die Seitenladegeschwindigkeit optimiert und unterschied sich erheblich von den Ergebnissen, die die Engine in PHP zeigte.  In diesem Artikel k√∂nnten wir auch dar√ºber sprechen, wie einfache Module verwendet werden, um mit dem Cache (Redis) und dem pg-Versprechen (PostgreSQL) in NodeJS zu arbeiten und sie mit Memcached und php-pgsql zu vergleichen, aber dieser Artikel erwies sich als ziemlich umfangreich.  Und da sie mein "Talent" zum Schreiben kannte, stellte sich heraus, dass sie schlecht strukturiert war.  Der Zweck dieses Artikels ist es, die Aufmerksamkeit von Entwicklern auf sich zu ziehen, die noch mit PHP arbeiten und sich der Vorteile von NodeJS und der Entwicklung webbasierter Anwendungen nicht bewusst sind, indem ein Beispiel eines realen Projekts verwendet wird, das einmal in PHP geschrieben wurde, jedoch aufgrund von Pr√§ferenzen sein Besitzer ging zu einer anderen Plattform. </p><br><p>  Ich hoffe, dass ich meine Gedanken vermitteln konnte und mehr oder weniger strukturiert war, um sie in diesem Material auszudr√ºcken.  Zumindest habe ich es versucht :) </p><br><p>  Schreiben Sie Kommentare - freundlich oder w√ºtend.  Ich werde jede konstruktive beantworten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444400/">https://habr.com/ru/post/de444400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444390/index.html">DeviceLock 8.3 DLP-System: Ein Jahr ist vergangen, Billy, aber Sie haben sich √ºberhaupt nicht ge√§ndert</a></li>
<li><a href="../de444392/index.html">Strahlung: Risiken, Sicherheit, Schutz</a></li>
<li><a href="../de444394/index.html">Die Linux Foundation startet mit Jenkins und Spinnaker ein neues DevOps-Projekt</a></li>
<li><a href="../de444396/index.html">Epson-Stand auf der ISE 2019 - die Ausstellung ist vorbei, Eindr√ºcke bleiben</a></li>
<li><a href="../de444398/index.html">Warum brauchen Non-Food-L√§den eine Selbstbedienungsorganisation?</a></li>
<li><a href="../de444402/index.html">React Code Splitting im Jahr 2019</a></li>
<li><a href="../de444404/index.html">Warum haben wir Angst vor Robotern?</a></li>
<li><a href="../de444406/index.html">Digitales Italien. Was und wie es funktioniert</a></li>
<li><a href="../de444408/index.html">Apple hat gestern neue iPads ver√∂ffentlicht und hat Fragen.</a></li>
<li><a href="../de444410/index.html">Netzwerkkarten. Ein kurzer √úberblick √ºber Software zum Erstellen von Netzwerkkarten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>