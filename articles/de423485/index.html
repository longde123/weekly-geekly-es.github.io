<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•Ñ üí≠ üöø Faules Laden von Bildern mit IntersectionObserver üçí üìù üò≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heutzutage sind Bilder der Hauptstolperstein auf dem Weg zu Hochgeschwindigkeitsladestellen. Dies gilt insbesondere f√ºr E-Commerce-Projekte. Bilder au...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Faules Laden von Bildern mit IntersectionObserver</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/423485/">  Heutzutage sind Bilder der Hauptstolperstein auf dem Weg zu Hochgeschwindigkeitsladestellen.  Dies gilt insbesondere f√ºr E-Commerce-Projekte.  Bilder auf ihnen, normalerweise ziemlich "schwer", machen den gr√∂√üten Teil des Inhalts der Seiten aus.  Dies f√ºhrt in der Regel dazu, dass sein Browser mehrere Megabyte Grafikdaten herunterladen muss, um dem Benutzer eine Seite anzuzeigen.  Wie kann das Laden von Seiten in dieser Situation beschleunigt werden?  Die Antwort auf diese Frage ist dem Material gewidmet, dessen √úbersetzung wir heute ver√∂ffentlichen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/943/040/c54/943040c5465e609d529aaa40f4f81f67.jpg" alt="Bild"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Allgemeine Bestimmungen</font> </h2><br>  Betrachten Sie zum Beispiel die Startseite der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Home-</a> Abteilung bei Walmart. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e09/717/79a/e0971779a66d1ee7c507d8db410dbb2b.gif"></div><br>  <i><font color="#999999">Eine Seite mit vielen Bildern</font></i> <br><br>  Hier finden Sie Informationen dazu, wie viele Bilder geladen werden, um diese Seite zu erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/584/5d9/139/5845d91397a03e5e6763a0b953d72f93.png"></div><br>  <i><font color="#999999">Bilder, die w√§hrend der Seitenbildung geladen wurden</font></i> <br><br>  Wie Sie sehen k√∂nnen, gibt es 137 Bilder!  Dies bedeutet, dass mehr als 80% der Daten, die zum Anzeigen der Seite ben√∂tigt und √ºber das Netzwerk √ºbertragen werden, als Grafikdateien dargestellt werden. <br><br>  Jetzt analysieren wir die Netzwerkanforderungen, die beim Laden der Seite ausgef√ºhrt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f42/618/dae/f42618daedd718f3766010a6a8a8cde3.png"></div><br>  <i><font color="#999999">Netzwerkanforderungen, die w√§hrend der Seitenbildung ausgef√ºhrt werden</font></i> <br><br>  In diesem Fall werden die Dateien, die sich aus der Trennung des Projektcodes ergeben, sp√§ter heruntergeladen, als sie k√∂nnten.  Dies liegt daran, dass Sie zuerst das <code>cp_ny.bundle</code> laden <code>cp_ny.bundle</code> .  Dieses Bundle k√∂nnte viel schneller heruntergeladen werden, wenn es nicht durch 18 Bilder gest√∂rt worden w√§re, die miteinander um Bandbreite konkurrieren. <br><br>  Wie kann ich das beheben?  In der Tat funktioniert es nicht, dies wirklich zu ‚Äûbeheben‚Äú, aber Sie k√∂nnen viele Dinge tun, um das Laden von Bildern zu optimieren.  Es gibt viele Ans√§tze zur Optimierung von Bildern, die auf Webseiten verwendet werden.  Dazu geh√∂ren die Verwendung verschiedener Grafikdateiformate, die Datenkomprimierung, die Verwendung von Unsch√§rfe-Animationstechniken und die Verwendung von CDN.  Ich m√∂chte auf das sogenannte "Lazy Loading" von Bildern (Lazy Loading) eingehen.  Insbesondere werden wir dar√ºber sprechen, wie diese Technik auf React-Sites implementiert wird. Da sie jedoch auf JavaScript-Mechanismen basiert, kann sie in jedes Webprojekt integriert werden. <br><br><h2>  <font color="#3AC1EF">Pilotprojekt</font> </h2><br>  Beginnen wir mit einer so extrem einfachen <code>Image</code> React-Komponente: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Image</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() {   const { src } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img align=<span class="hljs-string"><span class="hljs-string">"center"</span></span> src={src} /&gt;; } }</code> </pre> <br>  Als Eigenschaft wird eine URL verwendet und zum Rendern des <code>img</code> HTML-Elements verwendet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist der</a> relevante JSFiddle-Code.  Das folgende Bild zeigt die Seite mit dieser Komponente.  Bitte beachten Sie, dass Sie den Inhalt der Seite scrollen m√ºssen, um das von ihm angezeigte Bild zu sehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/754/978/b57/754978b574f4cc42960bda55487491a0.gif"></div><br>  <i><font color="#999999">Die Seite mit der Komponente, die das Bild anzeigt</font></i> <br><br>  Um die Technik des verz√∂gerten Ladens von Bildern in dieser Komponente zu implementieren, m√ºssen Sie die folgenden drei Schritte ausf√ºhren: <br><br><ol><li>  Rendern Sie das Bild nicht sofort nach dem Herunterladen. </li><li>  Richten Sie Tools zum Erkennen des Erscheinungsbilds eines Bildes im Anzeigebereich des Seiteninhalts ein. </li><li>  Zeigen Sie das Bild an, nachdem festgestellt wurde, dass es in den Anzeigebereich gefallen ist. </li></ol><br>  Werfen wir einen Blick auf diese Schritte. <br><br><h2>  <font color="#3AC1EF">Schritt 1</font> </h2><br>  In diesem Schritt wird das Bild unmittelbar nach dem Laden nicht angezeigt. <br><br><pre> <code class="hljs kotlin">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img /&gt;; }</code> </pre> <br><h2>  <font color="#3AC1EF">Schritt 2</font> </h2><br>  Hier konfigurieren wir die Mechanismen, mit denen wir den Moment erkennen k√∂nnen, in dem das Bild in den Betrachtungsbereich gelangt. <br><br><pre> <code class="hljs coffeescript">componentDidMount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntersectionObserver(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        }, {   root: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">".container"</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer.observe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element); } .... render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img ref={el =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element = el} /&gt;; }</code> </pre> <br>  Lassen Sie uns diesen Code analysieren.  Folgendes wurde hier getan: <br><br><ul><li>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ref-</a> Attribut wurde dem <code>img</code> Element hinzugef√ºgt.  Auf diese Weise k√∂nnen Sie den Image-Link in <code>src</code> sp√§ter aktualisieren, ohne die Komponente erneut rendern zu m√ºssen. </li><li>  Eine neue Instanz von <code>IntersectionObserver</code> (wir werden weiter unten darauf eingehen). </li><li>  Das <code>IntersectionObserver</code> Objekt wird aufgefordert, das Bild mithilfe des Konstrukts <code>observe(this.element)</code> zu beobachten. </li></ul><br>  Was ist <code>IntersectionObserver</code> ?  Wenn man bedenkt, dass das Wort "Schnittpunkt" als "Schnittpunkt" √ºbersetzt wird und "Beobachter" "Beobachter" ist, kann man bereits die Rolle dieses Objekts erraten.  Wenn Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MDN</a> nach Informationen dazu suchen, k√∂nnen Sie feststellen, dass die Intersection Observer-API es Webanwendungen erm√∂glicht, √Ñnderungen an der Schnittmenge eines Elements mit seinem √ºbergeordneten Element oder dem Umfang eines Ansichtsfensterdokuments asynchron zu √ºberwachen. <br><br>  Auf den ersten Blick mag diese Eigenschaft der API nicht besonders verst√§ndlich erscheinen, aber tats√§chlich ist sie sehr einfach aufgebaut.  Der <code>IntersectionObserver</code> Instanz werden mehrere Parameter √ºbergeben.  Insbesondere haben wir den <code>root</code> Parameter verwendet, mit dem wir das Root-DOM-Element, das wir als Container betrachten, um den Schnittpunkt des Elements mit dem Rand setzen k√∂nnen, dessen Rand wir kennen m√ºssen.  Standardm√§√üig ist dies der Bereich, in dem sich das sichtbare Fragment der Seite (Ansichtsfenster) befindet. Ich habe es jedoch explizit so eingestellt, dass der Container im <code>iframe</code> Element der JSFiddle verwendet wird.  Dies geschieht, um sp√§ter eine M√∂glichkeit in Betracht zu ziehen, die nicht f√ºr die Verwendung von <code>iframe</code> Elementen ausgelegt ist. <br><br>  Der Grund, warum die Verwendung von <code>IntersectionObserver</code> zum Ermitteln, wann ein Element sichtbar wird, beliebter ist als herk√∂mmliche Methoden wie die gemeinsame Verwendung von <code>onScroll</code> und <code>getBoundingClientRect()</code> , da <code>IntersectionObserver</code> Mechanismen au√üerhalb des Hauptthreads ausgef√ºhrt werden.  Der R√ºckruf, der aufgerufen wird, nachdem <code>IntersectionObserver</code> den Schnittpunkt des Elements mit dem Container erkannt hat, wird nat√ºrlich im Hauptthread ausgef√ºhrt, sodass sein Code nicht zu schwer sein sollte. <br><br><h2>  <font color="#3AC1EF">Schritt 3</font> </h2><br>  Jetzt m√ºssen wir den R√ºckruf konfigurieren, der aufgerufen wird, wenn er den Schnittpunkt des <code>this.element</code> (in diesem Fall dieses Element) mit dem <code>this.element</code> erkennt (in unserem Fall handelt es sich um ein <code>div</code> Element <code>.container</code> ). <br><br><pre> <code class="hljs kotlin">.... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = new IntersectionObserver( entries =&gt; {   entries.forEach(entry =&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { isIntersecting } = entry;     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isIntersecting) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.src = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.src;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer.disconnect();     }   }); }, {   root: document.querySelector(<span class="hljs-string"><span class="hljs-string">".container"</span></span>) } ); ....</code> </pre> <br>  Wenn der Schnittpunkt erkannt wird, wird das Array von <code>entries</code> an den <code>entries</code> , der einer Reihe von Schnappsch√ºssen des Status aller <code>entries</code> √§hnelt, f√ºr die der Schnittpunkt des angegebenen Rahmens erkannt wird.  Die Eigenschaft <code>isIntersecting</code> gibt die Richtung der Kreuzung an.  Wenn das √ºberwachte Element au√üerhalb des Stammelements liegt, ist es <code>true</code> .  Wenn ein Element das Stammelement verl√§sst, ist es <code>false</code> . <br><br>  Wenn sich herausstellt, dass das Element den unteren Rand des Containers √ºberschritten hat, setze ich seine <code>src</code> Eigenschaft manuell und deaktiviere die √úberwachung daf√ºr, was nicht mehr erforderlich ist. <br><br><h2>  <font color="#3AC1EF">Schritt 4 (geheim)</font> </h2><br>  Jetzt, im vierten, geheimen Schritt unserer Arbeit, k√∂nnen Sie das Ergebnis bewundern und Erfolg haben.  Hier ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> , der sammelt, wor√ºber wir gerade gesprochen haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edf/b5c/4e3/edfb5c4e3ab3bd515f11e96fe0e8d8ac.gif"></div><br>  <i><font color="#999999">Das Ergebnis der Anwendung der Lazy Image Loading-Technik</font></i> <br><br>  Wenn Sie sich jedoch genauer ansehen, was wir haben, stellt sich heraus, dass Sie hier etwas finden, das nicht sehr gut ist.  Um dies zu sehen, habe ich schnell durch die Seite gescrollt und gleichzeitig die Geschwindigkeit der Netzwerkverbindung verlangsamt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/400/c00/2ce/400c002ce3f46f27875c40288bf39f4f.gif"></div><br>  <i><font color="#999999">Seitenverhalten, wenn es schnell scrollt und die Netzwerkverbindungsgeschwindigkeit verlangsamt</font></i> <br><br>  Da wir das Bild erst laden, nachdem es den Bereich erreicht hat, in dem es bereits sichtbar sein sollte, hat der Benutzer nicht die M√∂glichkeit, durch die Seite zu scrollen und den vom Bild belegten Bereich und nat√ºrlich das Bild selbst zu sehen, bevor er es l√§dt.  Wenn Websites von normalen Computern aus angezeigt werden, die mit dem schnellen Internet verbunden sind, verursacht dies keine Probleme.  Viele moderne Benutzer besuchen Websites jedoch von ihren Telefonen aus. Manchmal verwenden sie 3G-Netzwerke oder, noch schlimmer, EDGE-Verbindungen. <br><br>  Es ist wahr, dass es nicht so schwierig ist, mit diesem Problem umzugehen.  Dies kann aufgrund der Tatsache erfolgen, dass die Intersection Observer-API dem Entwickler die M√∂glichkeit bietet, die Grenzen des <code>.container</code> zu erweitern oder zu verengen (in unserem Fall ist dies das <code>.container</code> Element).  Um diese Gelegenheit zu nutzen, f√ºgen Sie einfach eine Codezeile hinzu, in der der Stammcontainer konfiguriert ist: <br><br><pre> <code class="hljs objectivec">rootMargin: <span class="hljs-string"><span class="hljs-string">"0px 0px 200px 0px"</span></span></code> </pre> <br>  <code>rootMargin</code> Eigenschaft <code>rootMargin</code> eine Zeile, deren Struktur den CSS-Regeln entspricht, die zum Konfigurieren des Einr√ºckens von Elementen verwendet werden.  In unserem Fall teilen wir dem System mit, dass der untere Rand, der zum Erkennen des Schnittpunkts eines Elements mit einem Container verwendet wird, um 200 Pixel erh√∂ht werden muss.  Dies bedeutet, dass der entsprechende R√ºckruf aufgerufen wird, wenn das Element in einen Bereich f√§llt, der 200 Pixel unter dem unteren Rand des Stammelements liegt (der Standardwert ist 0). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist der</a> Code, der diese Technik implementiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae8/e52/257/ae8e52257adaf3205addb04ac82dc10a.gif"></div><br>  <i><font color="#999999">Verbesserung der Technik des verz√∂gerten Ladens von Bildern</font></i> <br><br>  Als Ergebnis stellt sich heraus, dass das Bild in einem Bereich geladen wird, der 200 Pixel unter dem sichtbaren Bereich der Seite liegt, wenn wir die Seite nur zum 4. Element der Liste scrollen. <br>  Nun scheint alles, was ben√∂tigt wird, getan zu sein.  Aber das ist nicht so. <br><br><h2>  <font color="#3AC1EF">Bildh√∂henproblem</font> </h2><br>  Wenn Sie die obigen GIF-Abbildungen sorgf√§ltig studiert haben, werden Sie m√∂glicherweise feststellen, dass die Bildlaufleiste nach dem Laden des Bildes einen ‚ÄûSprung‚Äú macht.  Gl√ºcklicherweise ist dieses Problem leicht zu handhaben.  Der Grund daf√ºr ist, dass das Element, das das Bild anzeigt, anf√§nglich eine H√∂he von 0 hat, die sich nach dem Laden des Bildes als 300 Pixel herausstellt.  Um das Problem zu beheben, reicht es daher aus, das Element auf eine feste H√∂he zu setzen, indem dem Bild das Attribut <code>height={300}</code> hinzugef√ºgt wird. <br><br><h2>  <font color="#3AC1EF">√úber Optimierungsergebnisse</font> </h2><br>  Welche Ergebnisse haben wir bei Walmart erzielt, nachdem wir das verz√∂gerte Laden von Bildern auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Seite angewendet haben?  Tats√§chlich variieren die spezifischen Ergebnisse stark in Abh√§ngigkeit von vielen Umst√§nden, unter denen wir die Netzwerkverbindungsgeschwindigkeit des Clients, die CDN-Verf√ºgbarkeit, die Anzahl der Bilder auf der Seite und die Regeln zum Erkennen von Schnittpunkten mit dem auf sie angewendeten Stammelement notieren k√∂nnen.  Mit anderen Worten, um die Auswirkungen des verz√∂gerten Ladens von Bildern auf Ihr eigenes Projekt zu beurteilen, ist es f√ºr Sie am besten, dies selbst zu implementieren und zu √ºberpr√ºfen.  Wenn Sie jedoch immer noch daran interessiert sind, was uns das verz√∂gerte Laden von Bildern gebracht hat, finden Sie hier einige Lighthouse-Berichte.  Die erste wird vor der Optimierung gebildet, die zweite nach der Optimierung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/4c8/698/5474c8698697e0489dd1ba213970b244.png"></div><br>  <i><font color="#999999">Leuchtturmbericht vor der Optimierung erstellt</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/c82/7ec/203c827ec729a55597ac33568672365e.png"></div><br>  <i><font color="#999999">Leuchtturmbericht nach Optimierung erstellt</font></i> <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir uns eine Technik zur Optimierung von Webseiten durch verz√∂gertes Laden von Bildern angesehen.  Wenn die Seiten Ihrer Website voller Bilder sind, ist diese Technik m√∂glicherweise f√ºr Sie hilfreich. <br><br>  <b>Liebe Leser!</b>  Wie optimieren Sie Bilder und deren Laden? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423485/">https://habr.com/ru/post/de423485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423475/index.html">Den Alterungscode hacken: eine neue Wissenschaft √ºber das Altern und was es bedeutet, jung zu bleiben</a></li>
<li><a href="../de423477/index.html">Sei ein Sicherheits-Ninja: Begib dich auf den Weg zu den H√∂hen von IB</a></li>
<li><a href="../de423479/index.html">"Zuerst": ob man zum Mars fliegt</a></li>
<li><a href="../de423481/index.html">Ich muss den Kubernetes-Cluster erh√∂hen, bin aber nur ein Code-Programmierer. Es gibt einen Ausweg</a></li>
<li><a href="../de423483/index.html">Finden des richtigen Weges zum Trennen von Website-Inhalten mithilfe von Webpack</a></li>
<li><a href="../de423487/index.html">Node.js ohne node_modules</a></li>
<li><a href="../de423489/index.html">Ich bin Notarzt und m√∂chte √ºber das neue Apple Watch-Elektrokardiogramm sprechen</a></li>
<li><a href="../de423491/index.html">PHP Digest Nr. 139 (3. - 17. September 2018)</a></li>
<li><a href="../de423493/index.html">Android Go ist die zuk√ºnftige Milliarde Ger√§te und ein Limit von 50 MB. Yandex Vortrag</a></li>
<li><a href="../de423495/index.html">Was ist in XGBoost enthalten und was hat Go damit zu tun?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>