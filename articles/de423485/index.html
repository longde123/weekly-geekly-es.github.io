<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥄 💭 🚿 Faules Laden von Bildern mit IntersectionObserver 🍒 📝 😭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heutzutage sind Bilder der Hauptstolperstein auf dem Weg zu Hochgeschwindigkeitsladestellen. Dies gilt insbesondere für E-Commerce-Projekte. Bilder au...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Faules Laden von Bildern mit IntersectionObserver</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/423485/">  Heutzutage sind Bilder der Hauptstolperstein auf dem Weg zu Hochgeschwindigkeitsladestellen.  Dies gilt insbesondere für E-Commerce-Projekte.  Bilder auf ihnen, normalerweise ziemlich "schwer", machen den größten Teil des Inhalts der Seiten aus.  Dies führt in der Regel dazu, dass sein Browser mehrere Megabyte Grafikdaten herunterladen muss, um dem Benutzer eine Seite anzuzeigen.  Wie kann das Laden von Seiten in dieser Situation beschleunigt werden?  Die Antwort auf diese Frage ist dem Material gewidmet, dessen Übersetzung wir heute veröffentlichen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/943/040/c54/943040c5465e609d529aaa40f4f81f67.jpg" alt="Bild"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Allgemeine Bestimmungen</font> </h2><br>  Betrachten Sie zum Beispiel die Startseite der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Home-</a> Abteilung bei Walmart. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e09/717/79a/e0971779a66d1ee7c507d8db410dbb2b.gif"></div><br>  <i><font color="#999999">Eine Seite mit vielen Bildern</font></i> <br><br>  Hier finden Sie Informationen dazu, wie viele Bilder geladen werden, um diese Seite zu erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/584/5d9/139/5845d91397a03e5e6763a0b953d72f93.png"></div><br>  <i><font color="#999999">Bilder, die während der Seitenbildung geladen wurden</font></i> <br><br>  Wie Sie sehen können, gibt es 137 Bilder!  Dies bedeutet, dass mehr als 80% der Daten, die zum Anzeigen der Seite benötigt und über das Netzwerk übertragen werden, als Grafikdateien dargestellt werden. <br><br>  Jetzt analysieren wir die Netzwerkanforderungen, die beim Laden der Seite ausgeführt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f42/618/dae/f42618daedd718f3766010a6a8a8cde3.png"></div><br>  <i><font color="#999999">Netzwerkanforderungen, die während der Seitenbildung ausgeführt werden</font></i> <br><br>  In diesem Fall werden die Dateien, die sich aus der Trennung des Projektcodes ergeben, später heruntergeladen, als sie könnten.  Dies liegt daran, dass Sie zuerst das <code>cp_ny.bundle</code> laden <code>cp_ny.bundle</code> .  Dieses Bundle könnte viel schneller heruntergeladen werden, wenn es nicht durch 18 Bilder gestört worden wäre, die miteinander um Bandbreite konkurrieren. <br><br>  Wie kann ich das beheben?  In der Tat funktioniert es nicht, dies wirklich zu „beheben“, aber Sie können viele Dinge tun, um das Laden von Bildern zu optimieren.  Es gibt viele Ansätze zur Optimierung von Bildern, die auf Webseiten verwendet werden.  Dazu gehören die Verwendung verschiedener Grafikdateiformate, die Datenkomprimierung, die Verwendung von Unschärfe-Animationstechniken und die Verwendung von CDN.  Ich möchte auf das sogenannte "Lazy Loading" von Bildern (Lazy Loading) eingehen.  Insbesondere werden wir darüber sprechen, wie diese Technik auf React-Sites implementiert wird. Da sie jedoch auf JavaScript-Mechanismen basiert, kann sie in jedes Webprojekt integriert werden. <br><br><h2>  <font color="#3AC1EF">Pilotprojekt</font> </h2><br>  Beginnen wir mit einer so extrem einfachen <code>Image</code> React-Komponente: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Image</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() {   const { src } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img align=<span class="hljs-string"><span class="hljs-string">"center"</span></span> src={src} /&gt;; } }</code> </pre> <br>  Als Eigenschaft wird eine URL verwendet und zum Rendern des <code>img</code> HTML-Elements verwendet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist der</a> relevante JSFiddle-Code.  Das folgende Bild zeigt die Seite mit dieser Komponente.  Bitte beachten Sie, dass Sie den Inhalt der Seite scrollen müssen, um das von ihm angezeigte Bild zu sehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/754/978/b57/754978b574f4cc42960bda55487491a0.gif"></div><br>  <i><font color="#999999">Die Seite mit der Komponente, die das Bild anzeigt</font></i> <br><br>  Um die Technik des verzögerten Ladens von Bildern in dieser Komponente zu implementieren, müssen Sie die folgenden drei Schritte ausführen: <br><br><ol><li>  Rendern Sie das Bild nicht sofort nach dem Herunterladen. </li><li>  Richten Sie Tools zum Erkennen des Erscheinungsbilds eines Bildes im Anzeigebereich des Seiteninhalts ein. </li><li>  Zeigen Sie das Bild an, nachdem festgestellt wurde, dass es in den Anzeigebereich gefallen ist. </li></ol><br>  Werfen wir einen Blick auf diese Schritte. <br><br><h2>  <font color="#3AC1EF">Schritt 1</font> </h2><br>  In diesem Schritt wird das Bild unmittelbar nach dem Laden nicht angezeigt. <br><br><pre> <code class="hljs kotlin">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img /&gt;; }</code> </pre> <br><h2>  <font color="#3AC1EF">Schritt 2</font> </h2><br>  Hier konfigurieren wir die Mechanismen, mit denen wir den Moment erkennen können, in dem das Bild in den Betrachtungsbereich gelangt. <br><br><pre> <code class="hljs coffeescript">componentDidMount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntersectionObserver(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        }, {   root: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">".container"</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer.observe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element); } .... render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img ref={el =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element = el} /&gt;; }</code> </pre> <br>  Lassen Sie uns diesen Code analysieren.  Folgendes wurde hier getan: <br><br><ul><li>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ref-</a> Attribut wurde dem <code>img</code> Element hinzugefügt.  Auf diese Weise können Sie den Image-Link in <code>src</code> später aktualisieren, ohne die Komponente erneut rendern zu müssen. </li><li>  Eine neue Instanz von <code>IntersectionObserver</code> (wir werden weiter unten darauf eingehen). </li><li>  Das <code>IntersectionObserver</code> Objekt wird aufgefordert, das Bild mithilfe des Konstrukts <code>observe(this.element)</code> zu beobachten. </li></ul><br>  Was ist <code>IntersectionObserver</code> ?  Wenn man bedenkt, dass das Wort "Schnittpunkt" als "Schnittpunkt" übersetzt wird und "Beobachter" "Beobachter" ist, kann man bereits die Rolle dieses Objekts erraten.  Wenn Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MDN</a> nach Informationen dazu suchen, können Sie feststellen, dass die Intersection Observer-API es Webanwendungen ermöglicht, Änderungen an der Schnittmenge eines Elements mit seinem übergeordneten Element oder dem Umfang eines Ansichtsfensterdokuments asynchron zu überwachen. <br><br>  Auf den ersten Blick mag diese Eigenschaft der API nicht besonders verständlich erscheinen, aber tatsächlich ist sie sehr einfach aufgebaut.  Der <code>IntersectionObserver</code> Instanz werden mehrere Parameter übergeben.  Insbesondere haben wir den <code>root</code> Parameter verwendet, mit dem wir das Root-DOM-Element, das wir als Container betrachten, um den Schnittpunkt des Elements mit dem Rand setzen können, dessen Rand wir kennen müssen.  Standardmäßig ist dies der Bereich, in dem sich das sichtbare Fragment der Seite (Ansichtsfenster) befindet. Ich habe es jedoch explizit so eingestellt, dass der Container im <code>iframe</code> Element der JSFiddle verwendet wird.  Dies geschieht, um später eine Möglichkeit in Betracht zu ziehen, die nicht für die Verwendung von <code>iframe</code> Elementen ausgelegt ist. <br><br>  Der Grund, warum die Verwendung von <code>IntersectionObserver</code> zum Ermitteln, wann ein Element sichtbar wird, beliebter ist als herkömmliche Methoden wie die gemeinsame Verwendung von <code>onScroll</code> und <code>getBoundingClientRect()</code> , da <code>IntersectionObserver</code> Mechanismen außerhalb des Hauptthreads ausgeführt werden.  Der Rückruf, der aufgerufen wird, nachdem <code>IntersectionObserver</code> den Schnittpunkt des Elements mit dem Container erkannt hat, wird natürlich im Hauptthread ausgeführt, sodass sein Code nicht zu schwer sein sollte. <br><br><h2>  <font color="#3AC1EF">Schritt 3</font> </h2><br>  Jetzt müssen wir den Rückruf konfigurieren, der aufgerufen wird, wenn er den Schnittpunkt des <code>this.element</code> (in diesem Fall dieses Element) mit dem <code>this.element</code> erkennt (in unserem Fall handelt es sich um ein <code>div</code> Element <code>.container</code> ). <br><br><pre> <code class="hljs kotlin">.... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = new IntersectionObserver( entries =&gt; {   entries.forEach(entry =&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { isIntersecting } = entry;     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isIntersecting) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.src = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.src;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer.disconnect();     }   }); }, {   root: document.querySelector(<span class="hljs-string"><span class="hljs-string">".container"</span></span>) } ); ....</code> </pre> <br>  Wenn der Schnittpunkt erkannt wird, wird das Array von <code>entries</code> an den <code>entries</code> , der einer Reihe von Schnappschüssen des Status aller <code>entries</code> ähnelt, für die der Schnittpunkt des angegebenen Rahmens erkannt wird.  Die Eigenschaft <code>isIntersecting</code> gibt die Richtung der Kreuzung an.  Wenn das überwachte Element außerhalb des Stammelements liegt, ist es <code>true</code> .  Wenn ein Element das Stammelement verlässt, ist es <code>false</code> . <br><br>  Wenn sich herausstellt, dass das Element den unteren Rand des Containers überschritten hat, setze ich seine <code>src</code> Eigenschaft manuell und deaktiviere die Überwachung dafür, was nicht mehr erforderlich ist. <br><br><h2>  <font color="#3AC1EF">Schritt 4 (geheim)</font> </h2><br>  Jetzt, im vierten, geheimen Schritt unserer Arbeit, können Sie das Ergebnis bewundern und Erfolg haben.  Hier ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> , der sammelt, worüber wir gerade gesprochen haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edf/b5c/4e3/edfb5c4e3ab3bd515f11e96fe0e8d8ac.gif"></div><br>  <i><font color="#999999">Das Ergebnis der Anwendung der Lazy Image Loading-Technik</font></i> <br><br>  Wenn Sie sich jedoch genauer ansehen, was wir haben, stellt sich heraus, dass Sie hier etwas finden, das nicht sehr gut ist.  Um dies zu sehen, habe ich schnell durch die Seite gescrollt und gleichzeitig die Geschwindigkeit der Netzwerkverbindung verlangsamt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/400/c00/2ce/400c002ce3f46f27875c40288bf39f4f.gif"></div><br>  <i><font color="#999999">Seitenverhalten, wenn es schnell scrollt und die Netzwerkverbindungsgeschwindigkeit verlangsamt</font></i> <br><br>  Da wir das Bild erst laden, nachdem es den Bereich erreicht hat, in dem es bereits sichtbar sein sollte, hat der Benutzer nicht die Möglichkeit, durch die Seite zu scrollen und den vom Bild belegten Bereich und natürlich das Bild selbst zu sehen, bevor er es lädt.  Wenn Websites von normalen Computern aus angezeigt werden, die mit dem schnellen Internet verbunden sind, verursacht dies keine Probleme.  Viele moderne Benutzer besuchen Websites jedoch von ihren Telefonen aus. Manchmal verwenden sie 3G-Netzwerke oder, noch schlimmer, EDGE-Verbindungen. <br><br>  Es ist wahr, dass es nicht so schwierig ist, mit diesem Problem umzugehen.  Dies kann aufgrund der Tatsache erfolgen, dass die Intersection Observer-API dem Entwickler die Möglichkeit bietet, die Grenzen des <code>.container</code> zu erweitern oder zu verengen (in unserem Fall ist dies das <code>.container</code> Element).  Um diese Gelegenheit zu nutzen, fügen Sie einfach eine Codezeile hinzu, in der der Stammcontainer konfiguriert ist: <br><br><pre> <code class="hljs objectivec">rootMargin: <span class="hljs-string"><span class="hljs-string">"0px 0px 200px 0px"</span></span></code> </pre> <br>  <code>rootMargin</code> Eigenschaft <code>rootMargin</code> eine Zeile, deren Struktur den CSS-Regeln entspricht, die zum Konfigurieren des Einrückens von Elementen verwendet werden.  In unserem Fall teilen wir dem System mit, dass der untere Rand, der zum Erkennen des Schnittpunkts eines Elements mit einem Container verwendet wird, um 200 Pixel erhöht werden muss.  Dies bedeutet, dass der entsprechende Rückruf aufgerufen wird, wenn das Element in einen Bereich fällt, der 200 Pixel unter dem unteren Rand des Stammelements liegt (der Standardwert ist 0). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist der</a> Code, der diese Technik implementiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae8/e52/257/ae8e52257adaf3205addb04ac82dc10a.gif"></div><br>  <i><font color="#999999">Verbesserung der Technik des verzögerten Ladens von Bildern</font></i> <br><br>  Als Ergebnis stellt sich heraus, dass das Bild in einem Bereich geladen wird, der 200 Pixel unter dem sichtbaren Bereich der Seite liegt, wenn wir die Seite nur zum 4. Element der Liste scrollen. <br>  Nun scheint alles, was benötigt wird, getan zu sein.  Aber das ist nicht so. <br><br><h2>  <font color="#3AC1EF">Bildhöhenproblem</font> </h2><br>  Wenn Sie die obigen GIF-Abbildungen sorgfältig studiert haben, werden Sie möglicherweise feststellen, dass die Bildlaufleiste nach dem Laden des Bildes einen „Sprung“ macht.  Glücklicherweise ist dieses Problem leicht zu handhaben.  Der Grund dafür ist, dass das Element, das das Bild anzeigt, anfänglich eine Höhe von 0 hat, die sich nach dem Laden des Bildes als 300 Pixel herausstellt.  Um das Problem zu beheben, reicht es daher aus, das Element auf eine feste Höhe zu setzen, indem dem Bild das Attribut <code>height={300}</code> hinzugefügt wird. <br><br><h2>  <font color="#3AC1EF">Über Optimierungsergebnisse</font> </h2><br>  Welche Ergebnisse haben wir bei Walmart erzielt, nachdem wir das verzögerte Laden von Bildern auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Seite angewendet haben?  Tatsächlich variieren die spezifischen Ergebnisse stark in Abhängigkeit von vielen Umständen, unter denen wir die Netzwerkverbindungsgeschwindigkeit des Clients, die CDN-Verfügbarkeit, die Anzahl der Bilder auf der Seite und die Regeln zum Erkennen von Schnittpunkten mit dem auf sie angewendeten Stammelement notieren können.  Mit anderen Worten, um die Auswirkungen des verzögerten Ladens von Bildern auf Ihr eigenes Projekt zu beurteilen, ist es für Sie am besten, dies selbst zu implementieren und zu überprüfen.  Wenn Sie jedoch immer noch daran interessiert sind, was uns das verzögerte Laden von Bildern gebracht hat, finden Sie hier einige Lighthouse-Berichte.  Die erste wird vor der Optimierung gebildet, die zweite nach der Optimierung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/4c8/698/5474c8698697e0489dd1ba213970b244.png"></div><br>  <i><font color="#999999">Leuchtturmbericht vor der Optimierung erstellt</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/c82/7ec/203c827ec729a55597ac33568672365e.png"></div><br>  <i><font color="#999999">Leuchtturmbericht nach Optimierung erstellt</font></i> <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir uns eine Technik zur Optimierung von Webseiten durch verzögertes Laden von Bildern angesehen.  Wenn die Seiten Ihrer Website voller Bilder sind, ist diese Technik möglicherweise für Sie hilfreich. <br><br>  <b>Liebe Leser!</b>  Wie optimieren Sie Bilder und deren Laden? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423485/">https://habr.com/ru/post/de423485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423475/index.html">Den Alterungscode hacken: eine neue Wissenschaft über das Altern und was es bedeutet, jung zu bleiben</a></li>
<li><a href="../de423477/index.html">Sei ein Sicherheits-Ninja: Begib dich auf den Weg zu den Höhen von IB</a></li>
<li><a href="../de423479/index.html">"Zuerst": ob man zum Mars fliegt</a></li>
<li><a href="../de423481/index.html">Ich muss den Kubernetes-Cluster erhöhen, bin aber nur ein Code-Programmierer. Es gibt einen Ausweg</a></li>
<li><a href="../de423483/index.html">Finden des richtigen Weges zum Trennen von Website-Inhalten mithilfe von Webpack</a></li>
<li><a href="../de423487/index.html">Node.js ohne node_modules</a></li>
<li><a href="../de423489/index.html">Ich bin Notarzt und möchte über das neue Apple Watch-Elektrokardiogramm sprechen</a></li>
<li><a href="../de423491/index.html">PHP Digest Nr. 139 (3. - 17. September 2018)</a></li>
<li><a href="../de423493/index.html">Android Go ist die zukünftige Milliarde Geräte und ein Limit von 50 MB. Yandex Vortrag</a></li>
<li><a href="../de423495/index.html">Was ist in XGBoost enthalten und was hat Go damit zu tun?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>