<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕙 🛐 👨🏼‍🤝‍👨🏻 模块化精灵字符及其动画 🌈 ⏹️ 😓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这篇博客文章完全致力于我的角色动画系统，其中包含有用的技巧和代码片段。 

 在过去的两个月中，我创造了多达9种新的玩家动作（例如用盾牌挡住，躲避跳跃和武器等有趣的事情），17种新的可穿戴物品，3套盔甲（板，丝绸和皮革）和6种发型。 我还完成了所有自动化和工具的创建，因此游戏中的所有内容都已投入使用...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>模块化精灵字符及其动画</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468991/"> 这篇博客文章完全致力于我的角色动画系统，其中包含有用的技巧和代码片段。 <br><br> 在过去的两个月中，我创造了多达9种新的玩家动作（例如用盾牌挡住，躲避跳跃和武器等有趣的事情），17种新的可穿戴物品，3套盔甲（板，丝绸和皮革）和6种发型。 我还完成了所有自动化和工具的创建，因此游戏中的所有内容都已投入使用。 在文章中，我将介绍如何实现这一目标！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/52a/188/2ef52a1887cdbe639fd35d9df414c38d.gif"></div><br>  <i>我希望这些信息是有用的，并证明不必为了独立创建此类工具/自动化而成为天才。</i> <br><br><h2> 简短说明 </h2><br> 最初，我想检查是否可以将重叠的精灵与同步的动画师组合在一起，以创建具有可替换发型，设备和可穿戴物品的模块化角色。 是否可以将手绘像素动画与真正可自定义的角色结合在一起。 <br><br> 当然，此类功能可在带有预渲染精灵的3D和2D游戏中或在具有骨骼动画的2D游戏中积极使用，但据我所知，结合手动创建的动画和模块化角色的游戏并不多（通常是因为该过程实际上是太单调）。 <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/7a9/d23/4127a9d23d4d84e28671deee781495cb.gif"></div><br>  <i>我在Unity的第一个月发掘了这个古老的GIF。</i>  <i>实际上，这个模块化的精灵是我在游戏开发中的第一个实验之一！</i> <br><br> 我使用Unity动画系统创建了一个原型，然后添加了一件衬衫，一条裤子，一个发型和三个项目来测试这个概念。 这需要26个单独的动画。 <br><br> 那时，我在Photoshop中创建了所有动画，并且不担心流程的自动化，因此非常无聊。 然后我想：“因此，基本构想起作用了，以后我将添加新的动画和设备。” 事实证明，“以后”是几年后。 <br><br> 在今年3月，我绘制了大量装甲的设计（请参阅我的上一篇文章），并注意到如何使此过程更方便。 我继续推迟实施，因为即使有了自动化，我也感到无能为力。 <br><br> 我希望像大多数带有手动动画的游戏一样，我不得不放弃角色的自定义并创建唯一的主要角色。 但是我有一个行动计划，是时候检查我是否可以击败这个怪物了！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88b/030/c5a/88b030c5a82c6cd801f7ce4d8b08ff6d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddd/55f/12c/ddd55f12cb35e4fa22093cdddecd63d4.gif" width="500"></div><br>  <i>剧透：一切都很棒。</i>  <i>下面我将揭示我的***秘密***</i> <br><br><h2> 模块化精灵系统 </h2><br><h4> 一。知道你的界限 </h4><br> 以前，我进行了许多艺术和时间控制测试，以查明此类工作需要花费多长时间，以及对我而言是否可以达到类似的质量水平。 <br><br> 我写下了所有有关动画的想法，将它们放到电子表格中，并根据各种标准（例如有用性，美观性和重复使用）进行排列。 令我惊讶的是，该列表上的第一个是该项目的演员表动画（药水，炸弹，刀，斧头，球）。 <br><br> 我为每个动画得出一个数字分数，并放弃了所有性能不佳的东西。 最初，我计划制造6套装甲，但很快意识到装甲过多，并抛出了三种装甲。 <br><br> 事实证明，时间跟踪非常重要，我强烈建议您使用它来回答诸如“我能在游戏中创造多少个敌人？”这样的问题。 经过仅几次测试，我设法推断出了一个相当准确的估计值。 通过动画方面的进一步工作，我继续跟踪时间并修改了自己的期望。 <br><br>  <i>我将分享过去两个月的工作日志。</i>  <i>请注意，这段时间是我每周工作30个小时的日常工作的补充：</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://docs.google.com/spreadsheets/d/1Nbr7lujZTB4pWMsuedVcgBYS6n5V-rHrk1PxeGxr6Ck/edit?usp=sharing</a> <br><br><h4> 二。 改变调色板，共创美好未来 </h4><br> 明智地使用精灵设计中的颜色，您可以绘制一个精灵并通过更改调色板创建许多不同的变化。 您不仅可以更改颜色，还可以创建各种打开和关闭元素（例如，用透明色替换颜色）。 <br><br> 每套装甲都有3种变化，通过混合上部和下部，您可以得到许多组合。 我计划实施一个系统，在该系统中，您可以为角色的外观收集一套盔甲，并为他的特征收集一套盔甲（例如在Terraria中）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/873/80c/0b9/87380c0b99d150828af05b1a0cf33ef6.gif"></div><br>  <i>在此过程中，我对发现的好奇组合感到惊喜。</i>  <i>如果将平板顶部与丝绸底部连接起来，则可以得到战争法师风格的东西。</i> <br><br> 最好使用对精灵中的值进行编码的颜色来更改调色板，以便以后可以使用它们从调色板中查找真实颜色。 我知道我在简化一点，所以这是一个入门视频： <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/u4Iz5AJa31Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 我不会详细解释所有内容，而是会讨论在Unity中实现此技术的方法以及它们的优缺点。 <br><br><h4>  1.搜索每个调色板的纹理 </h4><br> 这是在敌人，背景以及所有子画面具有相同调色板/材质的所有地方创建变体的最佳策略。 即使使用相同的Sprite / Atlas，也无法将不同的物料分组。 使用纹理非常麻烦，但是如果您需要为每个材质实例使用不同的调色板，则可以通过使用SpriteRenderer.sharedMaterial.SetTexture或MaterialPropertyBlock替换材质来实时更改调色板。 这是一个着色器片段函数的示例： <br><br><pre><code class="cpp hljs">sampler2D _MainTex; sampler2D _PaletteTex; float4 _PaletteTex_TexelSize; <span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f input)</span></span></span><span class="hljs-function"> : SV_TARGET </span></span>{ half4 lookup = tex2D(_MainTex, input.uv); half4 color = tex2D(_PaletteTex, half2(lookup.r * (_PaletteTex_TexelSize.x / <span class="hljs-number"><span class="hljs-number">0.00390625f</span></span>), <span class="hljs-number"><span class="hljs-number">0.5</span></span>)); color.a *= lookup.a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color * input.color; }</code> </pre> <br><h4>  2.颜色数组 </h4><br> 我决定做出这个决定是因为每次角色的外观发生变化（例如，穿上物品时）时都需要更换调色板，并动态创建一些调色板（以显示玩家选择的头发和肤色）。 在我看来，出于这些目的，在运行时和在编辑器中使用数组会容易得多。 <br><br> 代码： <br><br><pre> <code class="cpp hljs">sampler2D _MainTex; half4 _Colors[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f input)</span></span></span><span class="hljs-function"> : SV_TARGET </span></span>{ half4 lookup = tex2D(_MainTex, input.uv); half4 color = _Colors[round(lookup.r * <span class="hljs-number"><span class="hljs-number">255</span></span>)]; color.a *= lookup.a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color * input.color; }</code> </pre> <br> 我将调色板显示为ScriptableObject类型，并使用MonoBehaviour工具对其进行了编辑。 在Aseprite中创建动画的过程中，在编辑调色板上已经工作了很长时间，我意识到自己需要什么工具，并相应地编写了这些脚本。 如果您想编写自己的用于编辑调色板的工具，那么我绝对建议您实现以下一些功能： <br><br>  -在编辑颜色以实时显示更改时更新各种材质上的调色板。 <br><br>  -分配名称并更改调色板中的颜色顺序（使用该字段存储颜色索引，而不是其在数组中的顺序）。 <br><br>  -一次选择并编辑多种颜色。  （提示：您可以在Unity中复制和粘贴“颜色”字段：只需单击一种颜色，复制，单击另一种颜色，然后粘贴-现在它们是相同的！） <br><br>  -将覆盖色应用于整个调色板 <br><br>  -记录调色板中的纹理 <br><br><h4>  3.所有调色板的单一搜索纹理 </h4><br> 如果您想即时切换调色板，但同时需要进行批量处理以减少绘制调用的次数，则可以使用此技术。 它可能对移动平台有用，但是使用起来很不方便。 <br><br> 首先，您需要将所有调色板打包成一个大纹理。 然后，使用SpriteRenderer组件中指定的颜色（AKA顶点颜色）来确定要从调色板纹理读取到着色器中的线。 也就是说，此Sprite的调色板是通过SpriteRenderer.color控制的。 顶点颜色是唯一可以更改而不破坏条件的SpriteRenderer属性（假设所有材质都相同）。 <br><br> 在大多数情况下，最好使用alpha通道来控制索引，因为您可能不需要一堆具有不同透明度的精灵。 <br><br> 代码： <br><br><pre> <code class="cpp hljs">sampler2D _MainTex; sampler2D _PaletteTex; float4 _PaletteTex_TexelSize; <span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f input)</span></span></span><span class="hljs-function"> : SV_TARGET </span></span>{ half4 lookup = tex2D(_MainTex, input.uv); half2 paletteUV = half2( lookup.r * _(PaletteTex_TexelSize.x / <span class="hljs-number"><span class="hljs-number">0.00390625f</span></span>), input.color.a * _(PaletteTex_TexelSize.y / <span class="hljs-number"><span class="hljs-number">0.00390625f</span></span>) ) half4 color = tex2D(_PaletteTex, paletteUV); color.a *= lookup.a; color.rgb *= input.color.rgb; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47c/f90/895/47cf908951a0ba9f8f65a57711a5c85c.gif"></div><br>  <i>替换调色板和精灵图层的奇迹。</i>  <i>这么多组合。</i> <br><br><h4> 三， 自动化一切并使用正确的工具。 </h4><br> 要实现此功能，自动化是绝对必要的，因为结果是我获得了约300个动画和数千个精灵。 <br><br> 我的第一步是为Aseprite创建一个导出器，以使用方便的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命令行界面</a>管理我疯狂的Sprite层方案。 这只是一个Perl脚本，它绕过了我的Aseprite文件中的所有层和标签，并将图像导出到特定的目录和名称结构中，以便以后可以读取它们。 <br><br> 然后，我为Unity编写了一个导入器。  Aseprite显示带有框架数据的便捷JSON文件，因此您可以通过编程方式创建动画资产。 处理Aseprite JSON并编写此数据类型非常繁琐，因此我将其引入此处。 您可以使用JsonUtility.FromJson &lt;AespriteData&gt;轻松地将它们加载到Unity中，只需记住使用--format'json-array'选项运行Aseprite。 <br><br> 代码： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> AespriteData { [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Size { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h; } [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h; } [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Frame { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> filename; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Position frame; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> rotated; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> trimmed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Position spriteSourceSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Size sourceSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> duration; } [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Metadata { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> app; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> format; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Size size; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> scale; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Frame[] frames; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Metadata meta; }</code> </pre> <br> 在Unity方面，我在两个地方遇到了严重的问题：加载/切片Sprite表和构建动画剪辑。 一个清晰的示例将对我有很大帮助，因此这是我的导入器的代码片段，因此您不会遭受太大的痛苦： <br><br> 代码： <br><br><pre> <code class="cs hljs">TextureImporter textureImporter = AssetImporter.GetAtPath(spritePath) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TextureImporter; textureImporter.spriteImportMode = SpriteImportMode.Multiple; SpriteMetaData[] spriteMetaData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteMetaData[aespriteData.frames.Length]; <span class="hljs-comment"><span class="hljs-comment">// Slice the spritesheet according to the aesprite data. for (int i = 0; i &lt; aespriteData.frames.Length; i++) { AespriteData.Position spritePosition = aespriteData.frames[i].frame; spriteMetaData[i].name = aespriteData.frames[i].filename; spriteMetaData[i].rect = new Rect(spritePosition.x, spritePosition.y, spritePosition.w, spritePosition.h); spriteMetaData[i].alignment = (int)SpriteAlignment.Custom; // Same as "Pivot" in Sprite Editor. spriteMetaData[i].pivot = new Vector2(0.5f, 0f); // Same as "Custom Pivot" in Sprite Editor. Ignored if alignment isn't "Custom". } textureImporter.spritesheet = spriteMetaData; AssetDatabase.ImportAsset(spritePath, ImportAssetOptions.ForceUpdate); Object[] assets = AssetDatabase.LoadAllAssetsAtPath(spritePath); // The first element in this array is actually a Texture2D (ie the sheet itself). for (int i = 1; i &lt; assets.Length; i++) { sprites[i - 1] = assets[i] as Sprite; } // Create the animation. AnimationClip clip = new AnimationClip(); clip.frameRate = 40f; float frameLength = 1f / clip.frameRate; ObjectReferenceKeyframe[] keyframes = new ObjectReferenceKeyframe[aespriteData.frames.Length + 1]; // One extra keyframe is required at the end to express the last frame's duration. float time = 0f; for (int i = 0; i &lt; keyframes.Length; i++) { bool lastFrame = i == keyframes.Length - 1; ObjectReferenceKeyframe keyframe = new ObjectReferenceKeyframe(); keyframe.value = sprites[lastFrame ? i - 1 : i]; keyframe.time = time - (lastFrame ? frameLength : 0f); keyframes[i] = keyframe; time += lastFrame ? 0f : aespriteData.frames[i].duration / 1000f; } EditorCurveBinding binding = new EditorCurveBinding(); binding.type = typeof(SpriteRenderer); binding.path = ""; binding.propertyName = "m_Sprite"; AnimationUtility.SetObjectReferenceCurve(clip, binding, keyframes); AssetDatabase.CreateAsset(clip, "Assets/Animation/" + name + ".anim"); AssetDatabase.SaveAssets();</span></span></code> </pre> <br> 如果您还没有做过，那就相信我-开始创建自己的工具非常容易。 最简单的技巧是将一个带有Object对象的游戏对象放置在场景中，该对象具有[ExecuteInEditMode]属性。 添加一个按钮，您就可以战斗了！ 请记住，您的个人工具不必看起来很好，它们可以纯粹是功利主义的。 <br><br> 代码： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ExecuteInEditMode</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyCoolTool</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> button; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (button) { button = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; DoThing(); } } }</code> </pre> <br> 使用精灵时，自动执行标准任务非常容易（例如，在多个精灵文件中创建调色板纹理或批量替换颜色）。 这是一个示例，您可以从中开始学习如何更改精灵。 <br><br> 代码： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = <span class="hljs-string"><span class="hljs-string">"Assets/Whatever/Sprite.png"</span></span>; Texture2D texture = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;(path); TextureImporter textureImporter = AssetImporter.GetAtPath(path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TextureImporter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!textureImporter.isReadable) { textureImporter.isReadable = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate); } Color[] pixels = texture.GetPixels(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, texture.width, texture.height); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pixels.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// Do something with the pixels, eg replace one color with another. } texture.SetPixels(pixels); texture.Apply(); textureImporter.isReadable = false; // Make sure textures are marked as un-readable when you're done. There's a performance cost to using readable textures in your project that you should avoid unless you plan to change a sprite at runtime. byte[] bytes = ImageConversion.EncodeToPNG(texture); File.WriteAllBytes(Application.dataPath + path.Substring(6), bytes); AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);</span></span></code> </pre> <br><h4> 我如何超越Mecanim机会：投诉 </h4><br> 随着时间的流逝，我使用Mecanim创建的原型模块化Sprite系统成为升级Unity时的最大问题，因为API一直在变化并且文档记录不充分。 对于简单的状态机，能够在运行时查询每个剪辑的状态或更改剪辑是合理的。 但是不！ 出于性能原因，Unity烘焙了片段的状态，并迫使我们使用笨拙的重新定义系统来更改它们。 <br><br>  Mecanim本身并不是一个糟糕的系统，但在我看来，它无法实现其主要声明的功能-简单性。 开发人员的想法是用简单的东西（可视状态机）代替看起来复杂和痛苦的东西（脚本）。 但是： <br><br>  -任何非平凡的有限状态机都会迅速变成节点和连接的狂野网，其逻辑分散在不同的层中。 <br><br>  -通用系统要求阻碍了简单的用例。 要播放一个或两个动画，您需要创建一个新的控制器并分配状态/过渡。 当然，这会浪费过多的资源。 <br><br>  -结果很有趣，您仍然必须编写代码，因为为了使状态机执行一些有趣的操作，您需要一个调用Animator.SetBool和类似方法的脚本。 <br><br>  -要使状态机与其他剪辑一起使用，您需要将其复制并手动更换剪辑。 将来，您将不得不在几个地方进行更改。 <br><br>  -如果要在运行时更改状态，则存在问题。 解决方案要么是错误的API，要么是一个疯狂的图形，每个可能的动画只有一个节点。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8VgQ5PpTqjc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Firewatch开发人员如何进入<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可视脚本</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">地狱</a>故事。</i>  <i>有趣的是，当演讲者展示最简单的示例时，它们看起来仍然很疯狂。</i>  <i>观众在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">12:41吟</a> 。</i>  <i>加上巨大的维护成本，您将了解为什么我强烈不喜欢该系统。</i> <br><br> 其中许多问题甚至都不是Mecanim开发人员的错，而仅仅是不兼容想法的自然结果：您无法创建一个通用的同时简单的系统，并且使用图像描述逻辑比仅仅用文字/符号来描述更为困难（有人记得UML流程图吗？） 。 我记得<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Zack McClendon在</a> 《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2018年纽约实践</a> 》上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告中</a>的片段，如果有时间，我建议您观看整个视频！ <br><br> 但是，我知道了。 视觉脚本总是受到不了解艺术家需求的激进“编写自己的引擎”书呆子的谴责。 另外，不可否认的是，大多数代码看起来像是难以理解的技术行话。 <br><br> 如果您已经是一位小程序员，并且使用sprite制作游戏，那么您可能需要三思而后行。 当我开始时，我确信我永远不会写出比Unity开发人员更好的引擎相关内容。 <br><br> 你知道吗？ 事实证明，精灵动画师只是一个在指定的秒数后更改精灵的脚本。 尽管如此，我仍然必须自己编写。 从那时起，我已经在我的特定项目中添加了动画事件和其他功能，但是我半天编写的基本版本满足了我90％的需求。 它仅包含120行，可以从以下位置免费下载： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//pastebin.com/m9Lfmd94</a> 。 感谢您阅读我的文章。 待会见！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN468991/">https://habr.com/ru/post/zh-CN468991/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN468967/index.html">获得TAU动力学方程的“技术”。 以及为什么系统识别很烂，并且“诚实的物理学”规则</a></li>
<li><a href="../zh-CN468969/index.html">通过API从PowerShell创建Google用户</a></li>
<li><a href="../zh-CN468971/index.html">用Java为Nintendo DS编写</a></li>
<li><a href="../zh-CN468973/index.html">使用Python中的Tensorflow对卫星图像进行分类的神经网络</a></li>
<li><a href="../zh-CN468989/index.html">UEBA市场消失-UEBA万岁</a></li>
<li><a href="../zh-CN468993/index.html">Oculus Quest连接到PC并看到手</a></li>
<li><a href="../zh-CN468995/index.html">开放性政策：用户如何影响项目</a></li>
<li><a href="../zh-CN468997/index.html">指导-必须获得还是不错的奖励？</a></li>
<li><a href="../zh-CN468999/index.html">哪些国家/地区拥有“最慢的”互联网，谁可以纠正难以到达的地区的状况</a></li>
<li><a href="../zh-CN469001/index.html">如何用微服务煮粥</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>