<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ² ğŸ‘¨ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ¼ Overclocking Magento Rest API dengan RoadRunner ğŸ•¸ï¸ ğŸ‘¨ğŸ»â€ğŸ’¼ ğŸ“´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP dibuat untuk mati. Dan semuanya akan baik-baik saja, tetapi dia belum diberi kesempatan untuk melakukan ini baru-baru ini. Setahun yang lalu, alat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Overclocking Magento Rest API dengan RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466105/"><p><img src="https://habrastorage.org/webt/p2/kb/o0/p2kbo06xbl1z7zx0m4qyu1-jofe.jpeg" alt="Mempercepat Magento dengan RoadRunner"><br>  PHP dibuat untuk mati.  Dan semuanya akan baik-baik saja, tetapi dia belum diberi kesempatan untuk melakukan ini baru-baru ini.  Setahun yang lalu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat</a> roadrunner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diumumkan</a> di hub; </p><br><p>  Prinsip kerja RoadRunner adalah menjaga proses yang berjalan dan memasukkan permintaan yang masuk ke dalamnya, yang memungkinkan, menurut pengembang, untuk meningkatkan kinerja aplikasi (kadang-kadang bahkan 40 kali). </p><br><p> Karena saya telah bekerja dengan Magento sejak lama, sepertinya ide bagus untuk menguji alat ini bukan pada kerangka mitos, tetapi pada aplikasi nyata, di mana Magento Open Source bekerja dengan sangat baik. </p><a name="habracut"></a><br><h2 id="stoimost-inicializacii-magento-prilozheniya">  Biaya Inisialisasi Aplikasi Magento </h2><br><p>  Cara untuk mempercepat aplikasi RoadRunner melibatkan pengurangan waktu respons (setelah awal pemanasan) dengan mengurangi overhead menginisialisasi aplikasi. </p><br><p><img src="https://habrastorage.org/webt/mi/bt/ea/mibteawafee1aavgi4o1gz89u5y.jpeg" alt="Cuplikan layar dari presentasi Anton Tsitou &quot;Merancang aplikasi Go / PHP hybrid menggunakan RoadRunner&quot;"><br>  <em>Cuplikan layar dari presentasi Anton Tsitou "Merancang aplikasi Go / PHP hybrid menggunakan RoadRunner"</em> </p><br><p>  Dalam kasus Magento, waktu utama yang dihabiskan untuk startup jatuh pada: </p><br><ul><li>  komponis otomatis </li><li>  bootstrap </li></ul><br><p>  Pembuatan komposer otomatis tidak menarik perhatian, karena merupakan standar untuk aplikasi PHP. </p><br><p><img src="https://habrastorage.org/webt/4_/ca/d0/4_cad0h0askyfnxnn6hdzlsrfbk.png" alt="Membuat profil hasil yang terkait dengan Komposer."><br>  <em>Membuat profil hasil yang terkait dengan Komposer.</em> </p><br><p>  Bootstraping aplikasi Magento termasuk menginisialisasi penangan kesalahan, memeriksa status aplikasi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dll.</a> </p><br><p>  Bagian tersulit adalah inisialisasi wadah IoC ("ObjectManager" dalam hal Magento) dan penciptaan berulang ketergantungan contoh melalui itu untuk mendapatkan objek aplikasi. </p><br><p><img src="https://habrastorage.org/webt/ww/88/ag/ww88ag1xoy2gv61wndt7mudf430.png" alt="Membuat profil hasil yang terkait dengan bootstraping."><br>  <em>Membuat profil hasil yang terkait dengan bootstraping.</em> </p><br><h2 id="vnedrenie-roadrunner">  Implementasi RoadRunner </h2><br><p>  Untuk memulai RoadRunner, Anda perlu membuat pekerja yang akan mengandung siklus untuk menerima permintaan masuk dan mengirim tanggapan.  Selain itu, alat ini berfungsi dengan permintaan dan jawaban yang mengimplementasikan PSR-7.  Dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi,</a> terlihat seperti ini: </p><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) { $resp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \Zend\Diactoros\Response(); $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>); $psr7-&gt;respond($resp); }</code> </pre> <br><h2 id="magento-i-psr-7">  Magento dan PSR-7 </h2><br><p>  Magento belum mengimplementasikan PSR-7 dan di luar kotak menggunakan permintaan dan implementasi responnya, pendekatan di mana mereka sebagian besar diseret dari versi sebelumnya. </p><br><p>  Untuk mengimplementasikan RoadRunner, Anda perlu menemukan titik masuk yang akan menerima permintaan dalam beberapa bentuk dan mengembalikan respons ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/symfony/">contoh Symfony</a> ). </p><br><p>  Ada titik seperti itu di <em>Magento</em> , <em>\ Magento \ Framework \ AppInterface</em> , hanya ada satu masalah, antarmuka ini tidak dirancang untuk menerima permintaan.  Tapi tunggu, dari mana itu masuk ke dalam aplikasi?  Perlu kembali ke awal dan mantra - <em>PHP dilahirkan untuk mati</em> .  Oleh karena itu, sebagian besar perpustakaan, paket, dan kerangka kerja, ketika mendesain dan membaginya menjadi beberapa lapisan, tidak menganggap bahwa permintaan itu ternyata bukan hanya satu global. </p><br><p>  Lapisan transport Magento dibangun pada prinsip yang sama.  Meskipun dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggambarkan perbedaan antara objek injeksi / objek yang dapat diperbarui</a> , pada kenyataannya kami menggunakan permintaan tersebut sebagai layanan statefull global yang menginisialisasi dirinya dari variabel global ($ _GET, $ _POST).  Selain semua ini, injeksi layanan ini dapat dilihat di semua tingkatan aplikasi di kernel itu sendiri, apalagi kualitas modul pihak ketiga. </p><br><p>  Berdasarkan hal tersebut di atas, harapan mengimplementasikan RoadRunner hanya melalui konversi permintaan dari gaya PSR-7 ke gaya Magento dihabiskan. </p><br><h2 id="vnedrenie-psr-7-adaptera">  Terapkan adaptor PSR-7 </h2><br><p>  Kami merumuskan masalah, dengan mempertimbangkan informasi yang diterima. <br>  Saya ingin memiliki antarmuka aplikasi tertentu yang menerima permintaan PSR-7 dan mengembalikan respons PSR-7.  Anda juga perlu membuat implementasi antarmuka yang dibuat yang mengadaptasi format interaksi ini ke aplikasi Magento. </p><br><p><img src="https://habrastorage.org/webt/ep/bg/ix/epbgix0lny5de_sx36up92v71fc.png" alt="Adaptor PSR-7"><br>  <em>Adaptor PSR-7</em> </p><br><p>  Seperti yang disebutkan di atas, aplikasi magento sudah mengembalikan respons, jadi kita hanya perlu mengubahnya ke format PSR-7. </p><br><p>  Untuk permintaan, Anda memerlukan kelas yang mem-proksi semua panggilan ke objek permintaan saat ini, yang kami masukkan ke register khusus (ya, para dewa arsitektur akan memaafkan penyimpangan ini).  Selain itu, ditemukan bahwa kelas permintaan tidak digunakan satu, tetapi 3, sehingga mengharuskan mereka untuk didaftarkan ulang melalui konfigurasi IoC wadah. </p><br><p><img src="https://habrastorage.org/webt/5o/ep/nd/5oepndag_2d8xwlmw7q7rbysmpa.png" alt="Himpunan kelas yang digunakan untuk bekerja dengan kueri di Magento"><br>  <em>Himpunan kelas yang digunakan untuk bekerja dengan kueri di Magento</em> </p><br><h2 id="problemy-neumirayuschego-php-prilozheniya">  Masalah aplikasi PHP yang tidak pernah mati </h2><br><p>  Aplikasi yang diluncurkan melalui RoadRunner memiliki masalah yang sama dengan proses php yang berumur panjang, dijelaskan dalam dokumentasi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://roadrunner.dev/docs/usage-production</a> ) </p><br><p>  Masalah utama tingkat aplikasi yang harus dipantau oleh pengembang adalah: </p><br><ul><li>  kebocoran memori ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.php.net/manual/ru/features.gc.php</a> ) </li><li>  koneksi basis data (tiba-tiba) dapat jatuh dalam batas waktu, seperti yang lainnya </li><li>  manajemen negara yang kompeten </li></ul><br><p>  Perhatian khusus dalam konteks Magento harus diberikan kepada manajemen negara, karena baik dalam kernel dan dalam modul pihak ketiga, caching pengguna / produk / kategori saat ini di dalam layanan adalah pendekatan yang sangat umum. </p><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: ?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomerInterface</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;customer) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;customerSession-&gt;isLoggedIn()) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;customer = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;customerRepository-&gt;getById(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;customerSession-&gt;getCustomerId()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;customer; }</code> </pre> <br><p>  <em>Contoh metode dari kernel menggunakan status objek.</em> </p><br><h2 id="zapusk-magento-rest-api-servera-cherez-roadrunner">  Menjalankan Magento Rest API Server melalui RoadRunner </h2><br><p>  Mengingat potensi masalah dengan negara global, berdasarkan pada pengalaman mengembangkan bagian ujung depan Magento, bagian WebApi yang paling cocok dan tidak menyakitkan dipilih untuk diluncurkan. </p><br><p>  Hal pertama yang harus dilakukan adalah menciptakan pekerja kami, yang akan berjalan melalui RoadRunner dan hidup tanpa henti (hampir).  Untuk melakukan ini, ambil sepotong kode dari panduan RoadRunner dan tambahkan aplikasi kami di sana, dibungkus dengan adaptor PSR-7. </p><br><pre> <code class="php hljs">$relay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamRelay(STDIN, STDOUT); $psr7 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PSR7Client(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker($relay)); $bootstrap = \Magento\Framework\App\Bootstrap::create(BP, []); <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Framework\App\Http $app */</span></span> $app = $bootstrap-&gt;createApplication(\Magento\Framework\App\Http::class); <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> ApplicationInterface $psr7Application */</span></span> $psr7Application = $bootstrap-&gt;getObjectManager()-&gt;create( \Isxam\M2RoadRunner\Application\MagentoAppWrapper::class, [ <span class="hljs-string"><span class="hljs-string">'magentoApp'</span></span> =&gt; $app ] ); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($request = $psr7-&gt;acceptRequest()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { $response = $psr7Application-&gt;handle($request); $psr7-&gt;respond($response); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (\Throwable $e) { $psr7-&gt;getWorker()-&gt;error((string)$e); } }</code> </pre> <br><p>  <em>Kode sebelum loop sementara akan dieksekusi pada awal pekerja, semua yang ada di dalam loop - dengan setiap permintaan baru.</em> </p><br><p>  Ketika pekerja kami siap, kami melanjutkan untuk mengonfigurasi server RoadRunner yang ditulis dalam Go.  Semuanya bagus dan cepat di sini, hanya paket komposer yang mengunduh file yang dapat dieksekusi tidak perlu diinstal, yang tidak menyenangkan.  Kami membuat konfigurasi server kami - yang paling sederhana terlihat seperti ini. </p><br><pre> <code class="plaintext hljs">http: address: 0.0.0.0:8086 workers: command: "php worker.php" pool: numWorkers: 1</code> </pre> <br><p>  <em>Konfigurasi RoadRunner.</em> </p><br><p>  Dokumentasi berisi banyak pengaturan yang memungkinkan Anda untuk mengkonfigurasi server secara fleksibel sehingga keinginan untuk mengkompilasi biner Anda tidak terjadi dengan tepat. </p><br><pre> <code class="bash hljs">./rr serve -v -d</code> </pre> <br><p>  <em>Server mulai</em> </p><br><h2 id="testirovanie-resheniya">  Pengujian solusi </h2><br><h3 id="instrumenty">  Alat-alatnya </h3><br><p>  Untuk pengujian yang mudah, kami mengambil sesuatu yang sederhana, misalnya artillery.io. </p><br><p>  Kami akan menguji kinerja dengan bantuan satu pengguna yang mengeksekusi kueri secara berurutan (RoadRunner juga mendukung eksekusi kueri di beberapa utas, kami akan menyerahkan pertanyaan ini kepada peneliti lain) </p><br><p>  Pada input, kami memiliki file konfigurasi artileri dengan dua lingkungan - Apache dan RoadRunner.  Mereka berdua bekerja dengan instance Magento yang sama, jadi di sini mereka memiliki kedudukan yang sama. </p><br><h3 id="testovye-scenarii">  Skenario pengujian </h3><br><p>  Skenario berikut digunakan untuk mengukur kinerja kedua solusi. </p><br><div class="spoiler">  <b class="spoiler_title">Skenario 1. Membuat kategori</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> - name: "S1. Create category" flow: - loop: - post: url: "/rest/V1/categories" json: category: name: "name-{{prefix}}-{{ $loopCount }}" parent_id: 2 is_active: true count: 100</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Skenario 2. Mendapatkan daftar negara</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> - name: "S2. Countries list" flow: - loop: - get: url: "/rest/V1/directory/countries" count: 100</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Skenario 3: Daftar Jenis Produk</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> - name: "S3. Product types list" flow: - loop: - get: url: "/rest/V1/products/types" count: 100</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Skenario 4. Mendapatkan daftar set atribut</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> - name: "S4. Product attribute sets list" flow: - loop: - get: url: "/rest/V1/products/attribute-sets/sets/list?searchCriteria" count: 100</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Skenario 5. Mendapatkan kategori</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> - name: "S5. Category get" flow: - loop: - get: url: "/rest/V1/categories/2" count: 100</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Skenario 6. Penciptaan Produk</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> - name: "S6. Create product" flow: - loop: - post: url: '/rest/V1/products' json: product: sku: "sku-{{prefix}}-{{ $loopCount }}" name: "name-{{prefix}}-{{ $loopCount }}" attribute_set_id: 4 price: 100 type_id: "simple" count: 100</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Skenario 7. Mengambil Daftar Produk</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> - name: "S7. Get product list" flow: - loop: - get: url: "/rest/V1/products?searchCriteria[pageSize]=20" count: 100</code> </pre> </div></div><br><h3 id="rezultat">  Hasil </h3><br><p>  Setelah menjalankan semua skrip secara bergantian melalui RoadRunner dan Apache, median dari durasi kueri diperoleh.  Menurut median, kecepatan semua skenario berbeda dengan kira-kira nilai yang sama ~ 50ms. </p><br><p><img src="https://habrastorage.org/webt/fa/fv/yh/fafvyh1ntgsdywljqiey9a7pqok.png" alt="Hasil Uji Kinerja."><br>  <em>Hasil Uji Kinerja.</em> </p><br><h2 id="itog">  Ringkasan </h2><br><p>  Eksperimen langsung mengonfirmasi asumsi tentang kesegaran perolehan kinerja RoadRunner pada aplikasi tertentu.  Dengan menggunakan alat ini, Anda dapat mempercepat pemrosesan permintaan aplikasi dengan konstan yang sama dengan waktu inisialisasi lingkungan dan dependensi. </p><br><p>  Pada penangan ringan, ini memungkinkan Anda untuk mempercepat aplikasi di kali, pada berat itu hampir tidak memberikan efek nyata.  Jika kode Anda lambat, maka kemungkinan pisang raja tidak akan membantunya. </p><br><p>  Jika aplikasi Anda ditulis dengan baik, maka kemungkinan besar tidak akan ada masalah dengan operasinya melalui RoadRunner, tetapi jika aplikasi tersebut membutuhkan adaptasi untuk digunakan dengan RoadRunner, maka kemungkinan besar itu akan memerlukan hal yang sama tanpa RoadRunner untuk lebih jelas mengamati lapisan arsitektur. dan mengikuti standar pengembangan di lapangan. </p><br><p>  Magento Open Source umumnya cocok untuk diluncurkan di lingkungan yang diberikan, namun, itu membutuhkan peningkatan pada lapisan transportasi dan memperbaiki logika bisnis untuk mencegah perilaku yang salah selama permintaan berulang dalam proses yang sama.  Selain itu, penggunaan RoadRunner memberlakukan batasan tertentu pada pendekatan pembangunan, namun, mereka tidak bertentangan dengan praktik yang sudah mapan. </p><br><div class="spoiler">  <b class="spoiler_title">Akhirnya tangkapan layar yang bagus.</b>  <b class="spoiler_title">Kapan Anda masih melihat permintaan Magento dengan waktu respons ini?</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/0y/_y/bx/0y_ybxrixvx7ftceche2zd-u1ew.jpeg" alt="Shock"></p></div></div><br><h2 id="ssylki">  Referensi </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh dari artikel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Situs Resmi RoadRunner</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466105/">https://habr.com/ru/post/id466105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466089/index.html">Algoritma Berpikir dan Kesadaran, Bagian 2</a></li>
<li><a href="../id466093/index.html">Bagaimana cara kerja kubectl exec?</a></li>
<li><a href="../id466097/index.html">Memonitor Aplikasi .NET</a></li>
<li><a href="../id466099/index.html">Fitur pengujian aplikasi web untuk layanan video</a></li>
<li><a href="../id466103/index.html">Pemantauan keamanan cloud</a></li>
<li><a href="../id466107/index.html">Lakukan sistem Smart Home sendiri</a></li>
<li><a href="../id466109/index.html">Pemecahan masalah dengan pwnable.kr 22 - brainfuck. Serangan ret2libc</a></li>
<li><a href="../id466111/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 32. Pemulihan Kata Sandi, XMODEM / TFTPDNLD dan Aktivasi Lisensi Cisco</a></li>
<li><a href="../id466113/index.html">Menentukan pengodean teks dalam PHP, bukan mb_detect_encoding</a></li>
<li><a href="../id466121/index.html">Pembuatan suara pada mikrokontroler AVR menggunakan metode wavetable dengan dukungan polifoni</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>