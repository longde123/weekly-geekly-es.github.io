<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® ü§¥ ü¶ï Operaciones de comparaci√≥n en C ++ 20 üìé üï∫üèΩ üë®üèø‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La reuni√≥n en Colonia ha pasado, el est√°ndar C ++ 20 se ha reducido a un aspecto m√°s o menos terminado (al menos hasta la aparici√≥n de notas especiale...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Operaciones de comparaci√≥n en C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/465575/">  La reuni√≥n en Colonia ha pasado, el est√°ndar C ++ 20 se ha reducido a un aspecto m√°s o menos terminado (al menos hasta la aparici√≥n de notas especiales), y me gustar√≠a hablar sobre una de las pr√≥ximas innovaciones.  Este es un mecanismo que generalmente se llama <i>operador &lt;=&gt;</i> (el est√°ndar lo define como un "operador de comparaci√≥n de tres v√≠as", pero tiene el apodo informal "nave espacial"), pero creo que su alcance es mucho m√°s amplio. <br><br>  No solo tendremos un nuevo operador: la sem√°ntica de las comparaciones sufrir√° cambios significativos a nivel del lenguaje mismo. <br><a name="habracut"></a><br>  Incluso si no puede obtener nada m√°s de este art√≠culo, recuerde esta tabla: <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>La igualdad</b> <br></td><td>  <b>Racionalizaci√≥n</b> <br></td></tr><tr><td>  <b>B√°sico</b> <br></td><td>  <i>==</i> <br></td><td>  <i>&lt;=&gt;</i> <br></td></tr><tr><td>  <b>Derivados</b> <br></td><td>  <i>! =</i> <br></td><td>  <i>&lt;</i> , <i>&gt;</i> , <i>&lt;=</i> , <i>&gt; =</i> <br></td></tr></tbody></table></div><br>  Ahora tendremos un nuevo operador, <i>&lt;=&gt;</i> , pero, lo que es m√°s importante, los operadores ahora est√°n sistematizados.  Hay operadores b√°sicos y operadores derivados: cada grupo tiene sus propias capacidades. <br><br>  Hablaremos de estas caracter√≠sticas brevemente en la introducci√≥n y consideraremos con m√°s detalle en las siguientes secciones. <br><br>  Los operadores b√°sicos pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>invertirse</b></a> (es decir, reescribirse con el orden inverso de los par√°metros).  Las declaraciones derivadas pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>reescribirse a</b></a> trav√©s de la declaraci√≥n base correspondiente.  Ni los candidatos convertidos ni reescritos generan nuevas funciones, son simplemente reemplazos a nivel de c√≥digo fuente y se seleccionan de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>conjunto extendido de candidatos</b></a> .  Por ejemplo, la expresi√≥n <i>a &lt;9</i> ahora puede evaluarse como <i>a.operator &lt;=&gt; (9) &lt;0</i> , y la expresi√≥n <i>10! = B</i> as <i>! Operator == (b, 10)</i> .  Esto significa que ser√° posible prescindir de uno o dos operadores donde, para lograr el mismo comportamiento, ahora se requiere escribir manualmente 2, 4, 6 o incluso 12 operadores.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">A</a> continuaci√≥n se presentar√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una breve</a> descripci√≥n de las reglas junto con una tabla de todas las posibles transformaciones. <br><br>  Los operadores b√°sicos y derivados se pueden definir como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>predeterminados</b></a> .  En el caso de operadores b√°sicos, esto significa que el operador se aplicar√° a cada miembro en el orden de declaraci√≥n;  en el caso de operadores derivados, se utilizar√°n los candidatos reescritos. <br><br>  Cabe se√±alar que no existe tal transformaci√≥n en la que un operador de un tipo (es decir, igualdad u ordenamiento) pueda expresarse en t√©rminos de un operador de otro tipo.  En otras palabras, las columnas de nuestra tabla no dependen en modo alguno entre s√≠.  La expresi√≥n <i>a == b</i> nunca ser√° evaluada como <i>operador &lt;=&gt;</i> <i>(a, b) == 0</i> impl√≠citamente (pero, por supuesto, nada le impide definir su <i>operador ==</i> usando el <i>operador &lt;=&gt;</i> si lo desea). <br><br>  Considere un peque√±o ejemplo en el que mostramos c√≥mo se ve el c√≥digo antes y despu√©s de aplicar la nueva funcionalidad.  Escribiremos un tipo de cadena que no <i>distinga entre</i> may√∫sculas y min√∫sculas, <i>CIString</i> , cuyos objetos se pueden comparar entre s√≠ y con <i>char const *</i> . <br><br>  En C ++ 17, para nuestra tarea, necesitamos escribir 18 funciones de comparaci√≥n: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CIString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> assize() == bssize() &amp;&amp; ci_compare(asc_str(), bsc_str()) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(asc_str(), bsc_str()) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b &lt; a; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a &lt; b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(b &lt; a); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(asc_str(), b) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(asc_str(), b) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b &lt; a; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a &lt; b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(b &lt; a); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(a, bsc_str()) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(a, bsc_str()) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b &lt; a; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a &lt; b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(b &lt; a); } };</code> </pre> <br>  En C ++ 20, puede hacer solo 4 funciones: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CIString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.size() == bssize() &amp;&amp; ci_compare(s.c_str(), bsc_str()) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(s.c_str(), bsc_str()) &lt;=&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(s.c_str(), b) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(s.c_str(), b) &lt;=&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } };</code> </pre> <br>  Te dir√© lo que significa todo, con m√°s detalle, pero primero, regresemos un poco y recordemos c√≥mo las comparaciones funcionaron con el est√°ndar C ++ 20. <br><br><h2>  Comparaciones en est√°ndares de C ++ 98 a C ++ 17 </h2><br>  Las operaciones de comparaci√≥n no han cambiado mucho desde la creaci√≥n del lenguaje.  Ten√≠amos seis operadores: <i>== ,!</i> <i>=</i> , <i>&lt;</i> , <i>&gt;</i> , <i>&lt;=</i> Y <i>&gt; =</i> .  El est√°ndar define cada uno de ellos para los tipos incorporados, pero en general obedecen las mismas reglas.  Al evaluar cualquier expresi√≥n a <i>@ b</i> (donde <i>@</i> es uno de los seis operadores de comparaci√≥n), el compilador busca funciones miembro, funciones libres y candidatos incorporados llamados <i>operator @</i> , que se pueden llamar con el tipo <i>A</i> o <i>B</i> en el orden especificado.  El candidato m√°s adecuado se selecciona de ellos.  Eso es todo  De hecho, <i>todos los</i> operadores trabajaron de la misma manera: la operaci√≥n <i>&lt;</i> no difiri√≥ de <i>&lt;&lt;</i> . <br><br>  Un conjunto de reglas tan simple es f√°cil de aprender.  Todos los operadores son absolutamente independientes y equivalentes.  No importa lo que los humanos sepamos acerca de la relaci√≥n fundamental entre <i>==</i> y <i>! =</i> Operaciones.  En t√©rminos de lenguaje, este es uno y el mismo.  Usamos modismos.  Por ejemplo, definimos el operador <i>! =</i> Through <i>==</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; lhs, A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(lhs == rhs); }</code> </pre> <br>  Del mismo modo, a trav√©s del operador <i>&lt;</i> definimos todos los dem√°s operadores de relaci√≥n.  Usamos estos modismos porque, a pesar de las reglas del lenguaje, realmente no consideramos que los seis operadores sean equivalentes.  Aceptamos que dos de ellos son b√°sicos ( <i>==</i> y <i>&lt;</i> ), y a trav√©s de ellos todos los dem√°s ya est√°n expresados. <br><br>  De hecho, la Biblioteca de plantillas est√°ndar se basa completamente en estos dos operadores, y la gran cantidad de tipos en el c√≥digo explotado contiene definiciones de solo uno de ellos o de ambos. <br><br>  Sin embargo, el operador <i>&lt;</i> no es muy adecuado para el rol base por dos razones. <br><br>  Primero, no se puede garantizar que otros operadores de relaciones expresen a trav√©s de √©l.  S√≠, <i>a&gt; b</i> significa exactamente lo mismo que <i>b &lt;a</i> , pero no es cierto que <i>a &lt;= b</i> signifique exactamente lo mismo que <i>! (B &lt;a)</i> .  Las dos √∫ltimas expresiones ser√°n equivalentes si hay una propiedad de tricotom√≠a en la que para cualquiera de los dos valores solo una de las tres afirmaciones es verdadera: <i>a &lt;b</i> , <i>a == bo</i> <i>a a&gt; b</i> .  En presencia de una tricotom√≠a, la expresi√≥n <i>a &lt;= b</i> significa que estamos tratando con el primer o el segundo caso ... y esto es equivalente a la afirmaci√≥n de que no estamos tratando con el tercer caso.  Por lo tanto <i>(a &lt;= b) ==! (A&gt; b) ==! (B &lt;a)</i> . <br><br>  Pero, ¬øqu√© pasa si la actitud no posee la propiedad de la tricotom√≠a?  Esto es caracter√≠stico de las relaciones de orden parcial.  Un ejemplo cl√°sico son los n√∫meros de coma flotante para los cuales cualquiera de las operaciones <i>1.f &lt;NaN</i> , <i>1.f == NaN</i> y <i>1.f&gt; NaN</i> da <i>falso</i> .  Por lo tanto, <i>1.f &lt;= NaN</i> tambi√©n da una <i>mentira</i> , pero al mismo tiempo <i>! (NaN &lt;1.f)</i> es <i>cierto</i> . <br><br>  La √∫nica forma de implementar el operador <i>&lt;=</i> en t√©rminos generales a trav√©s de los operadores b√°sicos es pintar ambas operaciones como <i>(a == b) ||</i>  <i>(a &lt;b)</i> , que es un gran paso hacia atr√°s si <i>todav√≠a</i> tenemos que lidiar con el orden lineal, ya que no se llamar√° a una funci√≥n, sino a dos (por ejemplo, la expresi√≥n <i>‚Äúabc..xyz9‚Äù &lt;= ‚Äúabc ..xyz1 "</i> deber√° reescribirse como <i>(" abc..xyz9 "==" abc..xyz1 ") || (" abc..xyz9 "&lt;" abc..xyz1 ")</i> y dos veces para comparar la l√≠nea completa). <br><br>  En segundo lugar, el operador <i>&lt;</i> no <i>es</i> muy adecuado para el papel b√°sico debido a las peculiaridades de su uso en las comparaciones lexicogr√°ficas.  Los programadores a menudo cometen este error: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t &lt; rhs.t &amp;&amp; u &lt; rhs.u; } };</code> </pre> <br>  Para definir el operador == para una colecci√≥n de elementos, es suficiente aplicar <i>==</i> a cada miembro una vez, pero esto no funcionar√° con el operador <i>&lt;</i> .  Desde el punto de vista de esta implementaci√≥n, los conjuntos <i>A {1, 2}</i> y <i>A {2, 1}</i> se considerar√°n equivalentes (ya que ninguno de ellos es menor que el otro).  Para solucionar esto, aplique el operador <i>&lt;</i> dos veces a cada miembro, excepto el √∫ltimo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &lt; rhs.t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rhs.t &lt; t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u &lt; rhs.u; }</code> </pre> <br>  Finalmente, para garantizar el correcto funcionamiento de las comparaciones de objetos heterog√©neos, es decir  Para asegurarse de que las expresiones <i>a == 10</i> y <i>10 == a</i> significan lo mismo, generalmente recomiendan escribir comparaciones como funciones libres.  De hecho, esta es generalmente la √∫nica forma de implementar tales comparaciones.  Esto es inconveniente porque, en primer lugar, debe supervisar el cumplimiento de esta recomendaci√≥n y, en segundo lugar, generalmente tiene que declarar tales funciones como amigos ocultos para una implementaci√≥n m√°s conveniente (es decir, dentro del cuerpo de la clase). <br><br>  Tenga en cuenta que al comparar objetos de diferentes tipos no siempre es necesario escribir <i>operator == (X, int)</i> ;  Tambi√©n pueden significar casos en los que <i>int</i> se puede convertir a <i>X</i> impl√≠citamente. <br><br>  Resumamos las reglas al est√°ndar C ++ 20: <br><br><ul><li>  Todas las declaraciones se manejan de la misma manera. </li><li>  Utilizamos modismos para facilitar la implementaci√≥n.  Los operadores <i>==</i> y <i>&lt;</i> tomamos los modismos b√°sicos y expresamos los operadores de relaci√≥n restantes a trav√©s de ellos. </li><li>  Eso es solo que el operador <i>&lt;</i> no <i>es</i> muy adecuado para el papel de la base. </li><li>  Es importante (y recomendado) escribir comparaciones de objetos heterog√©neos como funciones libres. </li></ul><br><h2>  Nuevo operador de pedido b√°sico: &lt;=&gt; </h2><br>  El cambio m√°s significativo y notable en el trabajo de comparaciones en C ++ 20 es la adici√≥n de un nuevo operador: <i>operador &lt;=&gt;</i> , un operador de comparaci√≥n de tres v√≠as. <br><br>  Ya estamos familiarizados con las comparaciones de tres v√≠as por las funciones <i>memcmp</i> / <i>strcmp</i> en C y <i>basic_string :: compare ()</i> en C ++.  Todos devuelven un valor de tipo <i>int</i> , que est√° representado por un n√∫mero positivo arbitrario si el primer argumento es mayor que el segundo, <i>0</i> si son iguales y un n√∫mero negativo arbitrario en caso contrario. <br><br>  El operador de "nave espacial" no devuelve un valor <i>int</i> , sino un objeto que pertenece a una de las categor√≠as de comparaci√≥n, cuyo valor refleja el tipo de relaci√≥n entre los objetos comparados.  Hay tres categor√≠as principales: <br><br><ul><li>  <i>strong_ordering</i> : una relaci√≥n de orden lineal en la que la igualdad implica la intercambiabilidad de elementos (es decir, <i>(a &lt;=&gt; b) == strong_ordering :: equal</i> implica que <i>f (a) == f (b) se</i> cumple para todas las funciones adecuadas <i>f</i> El t√©rmino "funci√≥n adecuada" intencionalmente no tiene una definici√≥n clara, pero no incluye funciones que devuelvan las direcciones de sus argumentos o la <i>capacidad () del</i> vector, etc. Solo nos interesan las propiedades "esenciales", que tambi√©n son muy vagas, pero pueden ser condicionalmente supongamos que estamos hablando del <i>valor</i> del tipo. El valor del vector est√° contenido en √©l  m elementos, pero no su direcci√≥n, etc.).  Esta categor√≠a incluye los siguientes valores: <i>strong_ordering :: mayor</i> , <i>strong_ordering :: igual</i> y <i>strong_ordering :: less</i> . </li><li>  <i>d√©bil_orden</i> : una relaci√≥n de orden lineal en la que la igualdad define solo una cierta clase de equivalencia.  Un ejemplo cl√°sico es la comparaci√≥n de cadenas sin distinci√≥n entre may√∫sculas y min√∫sculas, cuando dos objetos pueden ser de orden <i>d√©bil :: equivalente</i> , pero no son estrictamente iguales (esto explica el reemplazo de la palabra <i>igual</i> por <i>equivalente</i> en el nombre del valor). </li><li>  <i>parcial_orden</i> : relaci√≥n de orden parcial.  En esta categor√≠a, se agrega un valor m√°s a los valores <i>mayor</i> , <i>equivalente</i> y <i>menor</i> (como en <i>d√©bil_ordenamiento</i> ): <i>no ordenado</i> ("desordenado").  Se puede usar para expresar relaciones de orden parcial en un sistema de tipos: <i>1.f &lt;=&gt; NaN</i> da el valor <i>partial_ordering :: unordered</i> . </li></ul><br>  Trabajar√° principalmente con la categor√≠a <i>strong_ordering</i> ;  Esta es tambi√©n la categor√≠a √≥ptima para su uso por defecto.  Por ejemplo, <i>2 &lt;=&gt; 4</i> devuelve <i>strong_ordering :: less</i> y <i>3 &lt;=&gt; -1</i> <i>devuelve strong_ordering :: mayor</i> . <br><br>  Las categor√≠as de un orden superior pueden reducirse impl√≠citamente a categor√≠as de un orden m√°s d√©bil (es decir, <i>strong_ordering es</i> reducible a <i>d√©bil_ordering</i> ).  En este caso, el tipo actual de relaci√≥n se conserva (es decir, <i>strong_ordering :: equal se</i> convierte en <i>d√©bil_ordering :: equivalente</i> ). <br><br>  Los valores de las categor√≠as de comparaci√≥n se pueden comparar con el literal <i>0</i> (no con ning√∫n <i>int</i> y no con <i>int</i> igual a <i>0</i> , sino simplemente con el literal <i>0</i> ) utilizando uno de los seis operadores de comparaci√≥n: <br><br><pre> <code class="cpp hljs">strong_ordering::less &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">// true strong_ordering::less == 0 // false strong_ordering::less != 0 // true strong_ordering::greater &gt;= 0 // true partial_ordering::less &lt; 0 // true partial_ordering::greater &gt; 0 // true // unordered -  ,   //       partial_ordering::unordered &lt; 0 // false partial_ordering::unordered == 0 // false partial_ordering::unordered &gt; 0 // false</span></span></code> </pre> <br>  Es gracias a una comparaci√≥n con el literal <i>0 que</i> podemos implementar los operadores de relaci√≥n: <i>a @ b es</i> equivalente a <i>(a &lt;=&gt; b) @ 0</i> para cada uno de estos operadores. <br><br>  Por ejemplo, <i>2 &lt;4</i> se puede calcular como <i>(2 &lt;=&gt; 4) &lt;0</i> , que se convierte en <i>strong_ordering :: less &lt;0</i> y da el valor <i>verdadero</i> . <br><br>  El operador <i>&lt;=&gt; se</i> ajusta a la funci√≥n del elemento base mucho mejor que el operador <i>&lt;</i> , ya que elimina ambos problemas de este √∫ltimo. <br><br>  Primero, <i>se</i> garantiza que la expresi√≥n <i>a &lt;= b</i> ser√° equivalente a <i>(a &lt;=&gt; b) &lt;= 0</i> incluso con ordenamiento parcial.  Para dos valores desordenados, <i>a &lt;=&gt; b</i> dar√° el valor <i>partial_ordered :: unordered</i> , y <i>partial_ordered :: unordered &lt;= 0</i> dar√° <i>false</i> , que es lo que necesitamos.  Esto es posible porque <i>&lt;=&gt;</i> puede devolver m√°s variedades de valores: por ejemplo, la categor√≠a de orden <i>parcial</i> contiene cuatro valores posibles.  Un valor de tipo <i>bool</i> solo puede ser <i>verdadero</i> o <i>falso</i> , por lo que antes no pod√≠amos distinguir entre comparaciones de valores ordenados y no ordenados. <br><br>  Para mayor claridad, considere un ejemplo de una relaci√≥n de orden parcial que no est√° relacionada con los n√∫meros de coma flotante.  Supongamos que queremos agregar un estado NaN a un tipo <i>int</i> , donde NaN es solo un valor que no forma un par ordenado con ning√∫n valor involucrado.  Puede hacer esto usando <i>std :: opcional</i> para almacenarlo: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntNan</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; val = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nullopt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(IntNan <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!val || !rhs.val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *val == *rhs.val; } partial_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(IntNan <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!val || !rhs.val) { <span class="hljs-comment"><span class="hljs-comment">//  unordered   //     return partial_ordering::unordered; } // &lt;=&gt;   strong_ordering  int, //        partial_ordering return *val &lt;=&gt; *rhs.val; } }; IntNan{2} &lt;=&gt; IntNan{4}; // partial_ordering::less IntNan{2} &lt;=&gt; IntNan{}; // partial_ordering::unordered //     .    IntNan{2} &lt; IntNan{4}; // true IntNan{2} &lt; IntNan{}; // false IntNan{2} == IntNan{}; // false IntNan{2} &lt;= IntNan{}; // false</span></span></code> </pre> <br>  El operador <i>&lt;=</i> devuelve el valor correcto porque ahora podemos expresar m√°s informaci√≥n a nivel del lenguaje mismo. <br><br>  En segundo lugar, para obtener toda la informaci√≥n necesaria, basta con aplicar <i>&lt;=&gt;</i> una vez, lo que facilita la implementaci√≥n de la comparaci√≥n lexicogr√°fica: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    //  t.   != 0 (..  t // ),    //   if (auto c = t &lt;=&gt; rhs.t; c != 0) return c; //     //    return u &lt;=&gt; rhs.u; };</span></span></code> </pre> <br>  Vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P0515</a> , la oraci√≥n original para agregar el <i>operador &lt;=&gt;, para una</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discusi√≥n</a> m√°s detallada <i>.</i> <br><br><h2>  Nuevas caracter√≠sticas del operador </h2><br>  No solo tenemos a nuestra disposici√≥n un nuevo operador.  Al final, si el ejemplo que se muestra arriba con la declaraci√≥n de la estructura <i>A</i> solo dice que en lugar de <i>x &lt;y</i> ahora tenemos que escribir <i>(x &lt;=&gt; y) &lt;0</i> cada vez, a nadie le gustar√≠a. <br><br>  El mecanismo para resolver las comparaciones en C ++ 20 difiere notablemente del enfoque anterior, pero este cambio est√° directamente relacionado con el nuevo concepto de dos operadores de comparaci√≥n b√°sicos: <i>==</i> y <i>&lt;=&gt;</i> .  Si antes era un idioma (grabaci√≥n a trav√©s de <i>==</i> y <i>&lt;</i> ), que usamos, pero que el compilador no sab√≠a, ahora comprender√° esta diferencia. <br><br>  Una vez m√°s, le dar√© una tabla que ya vio al principio del art√≠culo: <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>La igualdad</b> <br></td><td>  <b>Racionalizaci√≥n</b> <br></td></tr><tr><td>  <b>B√°sico</b> <br></td><td>  <i>==</i> <br></td><td>  <i>&lt;=&gt;</i> <br></td></tr><tr><td>  <b>Derivados</b> <br></td><td>  <i>! =</i> <br></td><td>  <i>&lt;</i> , <i>&gt;</i> , <i>&lt;=</i> , <i>&gt; =</i> <br></td></tr></tbody></table></div><br>  Cada uno de los operadores b√°sicos y derivados recibi√≥ una nueva habilidad, que dir√© algunas palabras m√°s. <br><br><h3>  Inversi√≥n de operadores b√°sicos. </h3><br>  Como ejemplo, tome un tipo que solo se pueda comparar con <i>int</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i == j; } };</code> </pre> <br>  Desde el punto de vista de las viejas reglas, no es sorprendente que la expresi√≥n <i>a == 10</i> funcione y se eval√∫e como <i>a.operator == (10)</i> . <br><br>  Pero, ¬øqu√© pasa con <i>10 == a</i> ?  En C ++ 17, esta expresi√≥n se considerar√≠a un claro error de sintaxis.  No hay tal operador.  Para que este c√≥digo funcione, tendr√≠a que escribir un <i>operador</i> sim√©trico <i>==</i> , que primero tomar√≠a el valor de <i>int</i> , y luego <i>A</i> ... y tendr√≠a que implementarlo como una funci√≥n libre. <br><br>  En C ++ 20, los operadores b√°sicos pueden invertirse.  Para <i>10 == a, el</i> compilador encontrar√° el <i>operador</i> candidato <i>== (A, int)</i> (de hecho, esta es una funci√≥n miembro, pero para mayor claridad, lo escribo aqu√≠ como una funci√≥n libre), y luego, adicionalmente, una variante con el orden inverso de los par√°metros, es decir. .  <i>operador == (int, A)</i> .  Este segundo candidato coincide con nuestra expresi√≥n (e idealmente), por lo que lo elegiremos.  La expresi√≥n <i>10 == a</i> en C ++ 20 se eval√∫a como <i>a.operator == (10)</i> .  El compilador entiende que la igualdad es sim√©trica. <br><br>  Ahora expandiremos nuestro tipo para que pueda compararse con <i>int</i> no solo a trav√©s del operador de igualdad, sino tambi√©n a trav√©s del operador de pedido: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i == j; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i &lt;=&gt; j; } };</code> </pre> <br>  Nuevamente, la expresi√≥n <i>a &lt;=&gt; 42</i> funciona bien y se calcula de acuerdo con las reglas anteriores como <i>a.operator &lt;=&gt; (42)</i> , pero <i>42 &lt;=&gt;</i> a estar√≠a mal desde el punto de vista de C ++ 17, incluso si el operador <i>&lt; =&gt;</i> ya exist√≠a en el idioma.  Pero en C ++ 20, el <i>operador &lt;=&gt;</i> , como el <i>operador ==</i> , es sim√©trico: reconoce candidatos invertidos.  Para <i>42 &lt;=&gt;</i> a, se encontrar√° un <i>operador de</i> funci√≥n miembro <i>&lt;=&gt;</i> <i>(A, int)</i> (nuevamente, lo escribo aqu√≠ como una funci√≥n libre solo para mayor claridad), as√≠ como un <i>operador</i> candidato sint√©tico <i>&lt;=&gt;</i> <i>(int, A)</i> .  Esta versi√≥n inversa coincide exactamente con nuestra expresi√≥n: la seleccionamos. <br><br>  Sin embargo, <i>42 &lt;=&gt;</i> <i>a</i> NO se calcula como un <i>operador</i> <i>&lt;=&gt;</i> <i>(42)</i> .  Eso estar√≠a mal.  Esta expresi√≥n se eval√∫a como <i>0 &lt;=&gt; a.operator &lt;=&gt; (42)</i> .  Intenta descubrir por qu√© esta entrada es correcta. <br><br>  Es importante tener en cuenta que el compilador no crea ninguna funci√≥n nueva.  Al calcular <i>10 == a</i> , el nuevo operador <i>operador == (int, A)</i> no apareci√≥, y al calcular <i>42 &lt;=&gt; a</i> , el <i>operador</i> <i>&lt;=&gt;</i> <i>(int, A)</i> no apareci√≥.  Solo dos expresiones se reescriben a trav√©s de candidatos invertidos.  Repito: no se crean nuevas funciones. <br><br>  Tambi√©n tenga en cuenta que un registro con el orden inverso de los par√°metros est√° disponible solo para operadores b√°sicos, pero para derivados no lo est√°.  Eso es: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; }; b != <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ok   C++17,   C++20 42 != b; //    C++17,   C++20</span></span></code> </pre> <br><h3>  Reescritura de operadores derivados </h3><br>  Volvamos a nuestro ejemplo con la estructura <i>A</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i == j; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i &lt;=&gt; j; } };</code> </pre> <br>  Tome la expresi√≥n <i>a! = 17</i> .  En C ++ 17, este es un error de sintaxis porque el <i>operador! = El</i> operador no existe.  Sin embargo, en C ++ 20, para expresiones que contienen operadores de comparaci√≥n de derivadas, el compilador tambi√©n buscar√° los operadores b√°sicos correspondientes y expresar√° comparaciones de derivadas a trav√©s de ellos. <br><br>  Sabemos que en matem√°ticas, la operaci√≥n <i>! =</i> Esencialmente significa NO <i>==</i> .  Ahora esto es conocido por el compilador.  Para la expresi√≥n <i>a! = 17,</i> buscar√° no solo el <i>operador! = Operadores</i> , sino tambi√©n el <i>operador ==</i> (y, como en los ejemplos anteriores, el <i>operador</i> invertido <i>==</i> ).  Para este ejemplo, encontramos un operador de igualdad que casi nos conviene: solo tenemos que reescribirlo de acuerdo con la sem√°ntica deseada: <i>a! = 17</i> se calcular√° como <i>! (A == 17)</i> . <br><br>  Del mismo modo, <i>17! =</i> A se calcula como <i>! A.operator == (17)</i> , que es una versi√≥n reescrita y una versi√≥n invertida. <br><br>  Tambi√©n se llevan a cabo transformaciones similares para los operadores de pedidos.  Si escribi√©ramos <i>un &lt;9</i> , intentar√≠amos (sin √©xito) encontrar el <i>operador &lt;</i> , y tambi√©n considerar√≠amos los candidatos b√°sicos: <i>operador &lt;=&gt;</i> .  El reemplazo correspondiente para los operadores de relaci√≥n se ve as√≠: <i>a @ b</i> (donde <i>@</i> es uno de los operadores de relaci√≥n) se calcula como <i>(a &lt;=&gt; b) @ 0</i> .  En nuestro caso, <i>a.operator &lt;=&gt; (9) &lt;0</i> .  Del mismo modo, <i>9 &lt;= a se</i> calcula como <i>0 &lt;= a.operator &lt;=&gt; (9)</i> . <br><br>  Tenga en cuenta que, como en el caso de la llamada, el compilador no crea ninguna funci√≥n nueva para los candidatos reescritos.  Simplemente se calculan de manera diferente, y todas las transformaciones se llevan a cabo solo en el nivel del c√≥digo fuente. <br><br>  Lo anterior me lleva al siguiente consejo: <br><br>  <b><i>SOLO OPERADORES B√ÅSICOS</i></b> <i>: defina solo operadores b√°sicos (== y &lt;=&gt;) en su tipo.</i> <br><br>  Dado que los operadores b√°sicos dan el conjunto completo de comparaciones, es suficiente definirlos solo.  Esto significa que solo necesita 2 operadores para comparar objetos del mismo tipo (en lugar de 6, a partir de ahora) y solo 2 operadores para comparar diferentes tipos de objetos (en lugar de 12).  Si solo necesita la operaci√≥n de igualdad, simplemente escriba 1 funci√≥n para comparar objetos del mismo tipo (en lugar de 2) y 1 funci√≥n para comparar diferentes tipos de objetos (en lugar de 4).  La <i>clase std :: sub_match</i> es un caso extremo: en C ++ 17 usa 42 operadores de comparaci√≥n, y en C ++ 20 usa solo 8, mientras que la funcionalidad no se ve afectada de ninguna manera. <br><br>  Dado que el compilador tambi√©n considera candidatos invertidos, todos estos operadores pueden implementarse como funciones miembro.  Ya no tiene que escribir funciones gratuitas solo por comparar objetos de diferentes tipos. <br><br><h3>  Reglas especiales para encontrar candidatos </h3><br>  Como ya mencion√©, la b√∫squeda de candidatos para <i>a @ b</i> en C ++ 17 se llev√≥ a cabo de acuerdo con el siguiente principio: encontramos todos los <i>operadores operator @</i> y seleccionamos el m√°s adecuado de ellos. <br><br>  C ++ 20 utiliza un conjunto extendido de candidatos.  Ahora buscaremos todos los <i>operadores @</i> .  Deje <i>@@</i> ser el operador base para <i>@</i> (puede ser el mismo operador).  Tambi√©n encontramos todos los <i>operadores @@</i> y para cada uno de ellos agregamos su versi√≥n invertida.  De todos estos candidatos encontrados, seleccionamos el m√°s adecuado. <br><br>  Tenga en cuenta que la sobrecarga del operador est√° permitida en <b>una sola</b> pasada.  No estamos tratando de sustituir a diferentes candidatos.  Primero los recogemos todos, y luego elegimos el mejor de ellos.  Si esto no existe, la b√∫squeda, como antes, falla. <br><br>  Ahora tenemos muchos m√°s candidatos potenciales y, por lo tanto, m√°s incertidumbre.  Considere el siguiente ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(C <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(C <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(C x, C y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x != y; }</code> </pre> <br>  En C ++ 17, solo ten√≠amos un candidato para <i>x! = Y</i> , y ahora hay tres: <i>x.operator! = (Y)</i> <i>,! X.operator == (y)</i> y <i>! Y.operator == (x)</i> .  Que elegir  ¬°Son todos iguales!  (Nota: el candidato <i>y.operator! = (X)</i> no existe, ya que solo se pueden <i>invertir</i> los operadores b√°sicos). <br><br>  Se han introducido dos reglas adicionales para eliminar esta incertidumbre.  Los candidatos no convertidos son preferibles a los conversos;    .  ,  <i>x.operator!=(y)</i> ¬´¬ª <i>!x.operator==(y)</i> ,   ¬´¬ª <i>!y.operator==(x)</i> .      ,   ¬´¬ª   . <br><br>   :           <i>operator@@</i> .    .   ,       . <br><br>        -.    ‚Äî    (,   <i>x &lt; y</i> ,    ‚Äî  <i>(x &lt;=&gt; y) &lt; 0</i> ),        (, <i>x &lt;=&gt; y</i>  <i>void</i>  -  ,       DSL),    .          .       ,       <i>bool</i>      (  :  <i>operator==</i>   <i>bool</i> ,        ?) <br><br>  Por ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Base&amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Base&amp;); <span class="hljs-comment"><span class="hljs-comment">// #1 friend bool operator==(const Base&amp;, const Base&amp;); }; struct Derived : Base { friend void operator&lt;=&gt;(const Derived&amp;, const Derived&amp;); // #2 }; bool f(Derived d1, Derived d2) { return d1 &lt; d2; }</span></span></code> </pre> <br>   <i>d1 &lt; d2</i>    : <i>#1</i>  <i>#2</i> .   ‚Äî <i>#2</i> ,      , ,   .    ,  <i>d1 &lt; d2</i>   <i>(d1 &lt;=&gt; d2) &lt; 0</i> .    ,    <i>void</i>  <i>0</i> ‚Äî ,    . ,          - ,    <i>#1</i> . <br><br><h3>    </h3><br> ,     ,    C++17,         .    ,  -    .     : <br><br><ul><li>       </li><li>      (  ) </li><li>            ,         </li><li>               ,   . </li></ul><br>         <b>  </b> ,        .     . <br><br>             .          ,    ,  ,   ,   ,      (   ).  ,         : <br><div class="scrollable-table"><table><tbody><tr><td> <b> </b> <br></td><td> <b> 1</b> <br></td><td> <b> 2</b> <br></td></tr><tr><td> <i>a == b</i> <br></td><td> <i>b == a</i> <br></td><td><br></td></tr><tr><td> <i>a != b</i> <br></td><td> <i>!(a == b)</i> <br></td><td> <i>!(b == a)</i> <br></td></tr><tr><td> <i>a &lt;=&gt; b</i> <br></td><td> <i>0 &lt;=&gt; (b &lt;=&gt; a)</i> <br></td><td><br></td></tr><tr><td> <i>a &lt; b</i> <br></td><td> <i>(a &lt;=&gt; b) &lt; 0</i> <br></td><td> <i>(b &lt;=&gt; a) &gt; 0</i> <br></td></tr><tr><td> <i>a &lt;= b</i> <br></td><td> <i>(a &lt;=&gt; b) &lt;= 0</i> <br></td><td> <i>(b &lt;=&gt; a) &gt;= 0</i> <br></td></tr><tr><td> <i>a &gt; b</i> <br></td><td> <i>(a &lt;=&gt; b) &gt; 0</i> <br></td><td> <i>(b &lt;=&gt; a) &lt; 0</i> <br></td></tr><tr><td> <i>a &gt;= b</i> <br></td><td> <i>(a &lt;=&gt; b) &gt;= 0</i> <br></td><td> <i>(b &lt;=&gt; a) &lt;= 0</i> <br></td></tr></tbody></table></div><br>   ¬´ ¬ª         ,     , .. <i>a &lt; b</i>   <i>0 &lt; (b &lt;=&gt; a)</i> ,       ,   ,      . <br><br><h3>       </h3><br>    C++17       .      .           : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u &amp;&amp; v == rhs.v; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,     , //     ?:  &amp;&amp;/|| if (t &lt; rhs.t) return true; if (rhs.t &lt; t) return false; if (u &lt; rhs.u) return true; if (rhs.u &lt; u) return false; return v &lt; rhs.v; } bool operator&gt; (A const&amp; rhs) const { return rhs &lt; *this; } bool operator&lt;=(A const&amp; rhs) const { return !(rhs &lt; *this); } bool operator&gt;=(A const&amp; rhs) const { return !(*this &lt; rhs); } };</span></span></code> </pre> <br>      - <i>std::tie()</i> ,     . <br><br>       ,   :    : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u &amp;&amp; v == rhs.v; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   T if (auto c = t &lt;=&gt; rhs.t; c != 0) return c; // ...  U if (auto c = u &lt;=&gt; rhs.u; c != 0) return c; // ...  V return v &lt;=&gt; rhs.v; } };</span></span></code> </pre> <br>     .   <i>&lt;=&gt;</i>         <i>&lt;</i> .  ,        .  <i>c != 0</i>    ,      ,          ( <i></i>  <i></i> ),     . <br><br>        <i> </i> .   C++20    ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br>   ,        .     ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br>    .   ,         ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br>   ,     ,     .     :        <i>operator==</i> ,     <i>operator&lt;=&gt;</i> . <br><br><h2>    </h2><br>         C++20:        .          .         ,    ,        ,     . <br><br><h2>   </h2><br>  PVS-Studio      ,            &lt;=&gt;  .         ,       -.   ,     ,            (.  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a> ").  ++          . <br><br>      PVS-Studio        &lt;,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t &lt; rhs.t &amp;&amp; u &lt; rhs.u; }</code> </pre> <br>        . ,   -  .  . <br><br> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comparisons in C++20</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465575/">https://habr.com/ru/post/465575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465561/index.html">Lo que aprend√≠ de un programador l√≠der</a></li>
<li><a href="../465567/index.html">Probar el c√≥digo de SQL Server con tSQLt</a></li>
<li><a href="../465569/index.html">Mapa de desarrollo para desarrolladores m√≥viles</a></li>
<li><a href="../465571/index.html">C√≥mo vender cigarrillos de hombres para mujeres y hacer que los salvajes se protejan a s√≠ mismos: redactores que podr√≠an</a></li>
<li><a href="../465573/index.html">Todo el poder de IntelliJ IDEA en el ejemplo de un idioma (en im√°genes)</a></li>
<li><a href="../465577/index.html">Nuevos tipos de micromarcado para fragmentos interactivos avanzados</a></li>
<li><a href="../465579/index.html">Creaci√≥n de chats corporativos y videoconferencias con el equipo de Zextras</a></li>
<li><a href="../465583/index.html">Detalles de la campa√±a maliciosa para usuarios de iPhone revelados</a></li>
<li><a href="../465585/index.html">C√≥mo administrar React Data Grid a trav√©s de Redux</a></li>
<li><a href="../465587/index.html">An√°lisis: qu√© es el mercado OTC y qu√© transacciones se realizan all√≠</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>