<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò¶ üö© üéé Creaci√≥n de una m√°quina arcade emulador. Parte 4 ‚è© üë©üèæ‚Äçü§ù‚Äçüë©üèº üë®üèæ‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes del primero , segundo , tercero . 

 El resto de la m√°quina 
 El c√≥digo que escribimos para emular el procesador 8080 es bastante general y pue...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Creaci√≥n de una m√°quina arcade emulador. Parte 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419143/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/735/b99/6eb735b9990860a94f9ef0a18ba46a82.jpg" alt="imagen"></div><br>  Partes del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primero</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segundo</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tercero</a> . <br><br><h2>  El resto de la m√°quina </h2><br>  El c√≥digo que escribimos para emular el procesador 8080 es bastante general y puede adaptarse f√°cilmente para ejecutarse en cualquier m√°quina con el compilador de C. Pero para poder jugar el juego en s√≠, necesitamos hacer m√°s.  Tendremos que emular el equipo de toda la m√°quina arcade y escribir c√≥digo que pegue las caracter√≠sticas espec√≠ficas de nuestro entorno inform√°tico al emulador. <br><br>  (Quiz√°s le interese mirar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diagrama de circuito de la</a> m√°quina). <br><a name="habracut"></a><br><h2>  Tiempos </h2><br>  El juego se ejecuta en el 8080 de 2 MHz. Su computadora es mucho m√°s r√°pida.  Para tener esto en cuenta, tendremos que encontrar alg√∫n tipo de mecanismo. <br><br><h2>  Interrupciones </h2><br>  Las interrupciones est√°n dise√±adas para que el procesador pueda procesar tareas con tiempos de ejecuci√≥n precisos, como E / S.  El procesador puede ejecutar el programa, y ‚Äã‚Äãcuando se activa el pin de interrupci√≥n, deja de ejecutar el programa actual y hace algo m√°s. <br><br>  Necesitamos simular la forma en que una m√°quina arcade genera interrupciones. <br><br><h2>  Gr√°ficos </h2><br>  Space Invaders dibuja gr√°ficos en su memoria en el rango de direcciones 0x2400.  Un controlador de video de hardware real leer√≠a RAM y controlar√≠a una pantalla CRT.  Nuestro programa tendr√° que emular este comportamiento presentando una imagen del juego en una ventana. <br><br><h2>  Botones </h2><br>  El juego tiene botones f√≠sicos que el programa lee usando el comando IN del procesador 8080. Nuestro emulador necesitar√° vincular la entrada del teclado a estos comandos IN. <br><br><h2>  ROM y RAM </h2><br>  Debo admitir: "cortamos la esquina" al crear un b√∫fer de memoria de 16 kilobytes, que incluye los 16 KB inferiores de la asignaci√≥n de memoria del procesador.  De hecho, los primeros 2 KB de asignaci√≥n de memoria es una memoria real de solo lectura (ROM).  Tendremos que poner operaciones de escritura en la memoria en una funci√≥n para que no sea posible escribir en la ROM. <br><br><h2>  Sonido </h2><br>  Hasta ahora no hemos dicho nada sobre el sonido.  Space Invaders tiene un lindo esquema de sonido anal√≥gico que reproduce uno de los 8 sonidos controlados por el comando OUT, que se transmite a uno de los puertos.  Tendremos que convertir estos comandos OUT para reproducir muestras de sonido en nuestra plataforma. <br><br>  Puede parecer mucho trabajo, pero no es tan malo y podemos avanzar gradualmente.  Lo primero que queremos hacer es ver la pantalla, para lo cual necesitamos interrupciones, gr√°ficos y parte del procesamiento de los comandos IN y OUT. <br><br><h2>  Pantallas y actualizaciones </h2><br><h3>  Los fundamentos </h3><br>  Probablemente est√© familiarizado con los componentes de un sistema de visualizaci√≥n de video.  En alg√∫n lugar del sistema hay alg√∫n tipo de RAM, que contiene una imagen para mostrar en la pantalla.  En el caso de dispositivos anal√≥gicos, existe un equipo que lee esta RAM y convierte los bytes en voltaje anal√≥gico transmitido al monitor. <br><br>  Una comprensi√≥n m√°s profunda del sistema nos ayudar√° a la hora de analizar el prop√≥sito de la asignaci√≥n de memoria y la funcionalidad del c√≥digo. <br><br>  Las pantallas anal√≥gicas tienen requisitos para frecuencias de actualizaci√≥n y tiempos.  En cualquier momento, la pantalla tiene un p√≠xel espec√≠fico actualizado.  La imagen transmitida a la pantalla se llena punto por punto, comenzando desde la esquina superior izquierda y hacia la derecha superior, luego el primer punto de la segunda l√≠nea, el √∫ltimo punto de la segunda l√≠nea, etc.  Despu√©s de que se dibuja la √∫ltima l√≠nea en la pantalla, el controlador de video puede generar una Interrupci√≥n vertical en blanco (tambi√©n conocida como VBI o VBL). <br><br>  Para garantizar una animaci√≥n fluida, la imagen en RAM procesada por el controlador de video no se puede cambiar.  Si la actualizaci√≥n de RAM ocurri√≥ en el medio del marco, el espectador ver√° partes de dos im√°genes.  Esto da como resultado un efecto de "rasgadura" cuando se muestra un cuadro diferente del cuadro en la parte inferior de la pantalla.  Si alguna vez has visto un salto de l√≠nea, sabes c√≥mo se ve. <br><br>  Para evitar vac√≠os, el software debe hacer algo para evitar transferir la ubicaci√≥n de la actualizaci√≥n de la pantalla.  Y solo hay una forma de hacerlo. <br><br>  El VBL se genera despu√©s del final de la √∫ltima l√≠nea y, por lo general, hay un cierto tiempo antes de volver a dibujar la primera l√≠nea.  (Este es el tiempo en blanco vertical, y puede ser de aproximadamente 1 milisegundo). <br><br>  Cuando se recibe VBL, el programa comienza a representar la pantalla desde arriba. <br><br>  Cada l√≠nea se dibuja antes del proceso inverso de escaneo de cuadros. <br><br>  La CPU siempre est√° por delante del retorno en caliente y, por lo tanto, evita los saltos de l√≠nea. <br><br><div style="text-align:center;"><img src="http://www.emulator101.com/images/verticalretrace.jpg" alt="imagen"></div><br><h2>  Sistema de video Space Invaders </h2><br>  Una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">p√°gina</a> muy informativa nos dice que los Space Invaders tienen dos interrupciones de video.  Uno es para el final del cuadro, pero tambi√©n genera una interrupci√≥n en el medio de la pantalla.  La p√°gina describe el sistema de actualizaci√≥n de pantalla: el juego dibuja gr√°ficos en la mitad superior de la pantalla cuando recibe una interrupci√≥n en el medio de la pantalla, y dibuja gr√°ficos en la parte inferior de la pantalla cuando recibe una interrupci√≥n al final del cuadro.  Esta es una forma bastante inteligente de eliminar los saltos de l√≠nea y un buen ejemplo de lo que se puede lograr al desarrollar hardware y software al mismo tiempo. <br><br>  Debemos forzar la emulaci√≥n de nuestra m√°quina para generar tales interrupciones.  Si los generaremos con una frecuencia de 60 Hz, as√≠ como con la m√°quina Space Invaders, entonces el juego se dibujar√° con la frecuencia correcta. <br><br>  En la siguiente secci√≥n, hablaremos sobre la mec√°nica de las interrupciones y pensaremos en c√≥mo emularlas. <br><br><h2>  Botones y puertos </h2><br>  El 8080 implementa E / S usando las instrucciones IN y OUT.  Tiene 8 puertos IN y OUT separados: el puerto est√° determinado por el byte de datos del comando.  Por ejemplo, <code>IN 3</code> colocar√° el valor del puerto 3 en el registro A, y <code>OUT 2</code> enviar√° A al puerto 2. <br><br>  Tom√© informaci√≥n sobre el prop√≥sito de cada puerto del sitio web de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Computer Archaeology</a> .  Si esta informaci√≥n no estuviera disponible, tendr√≠amos que obtenerla estudiando el diagrama del circuito, as√≠ como leyendo y ejecutando el c√≥digo paso a paso. <br><br> <code>: <br>  1 <br>  0  (0,  ) <br> 1  Start   <br> 2  Start   <br> 3 ? <br> 4     <br> 5     <br> 6     <br> 7 ? <br> <br>  2 <br>  0,1 DIP-   (0:3,1:4,2:5,3:6) <br> 2 ""  <br> 3 DIP-  , 1:1000,0:1500 <br> 4     <br> 5     <br> 6     <br> 7    DIP-, 1:,0: <br> <br>  3    <br> <br>  2     ( 0,1,2) <br>  3    <br>  4    <br>  5    <br>  6  "" ? ,     , <br>       (0=a,1=b,2=c  ..) <br> <br> (  3,5,6      1=$01  2=$00 <br>    ,       (attract mode))</code> <br> <br>  Hay tres formas de implementar E / S en nuestra pila de software (que consta de un emulador 8080, c√≥digo de m√°quina y c√≥digo de plataforma). <br><br><ol><li>  Incruste conocimiento de la m√°quina en nuestro emulador 8080 </li><li>  Incruste el conocimiento del emulador 8080 en el c√≥digo de m√°quina </li><li>  Invente una interfaz formal entre las tres partes del c√≥digo para permitir el intercambio de informaci√≥n a trav√©s de la API </li></ol><br>  Descart√© la primera opci√≥n: es bastante obvio que el emulador est√° en la parte inferior de esta cadena de llamadas y debe permanecer separado.  (Imagine que necesita reutilizar el emulador para otro juego, y comprender√° lo que quiero decir). En el caso general, transferir estructuras de datos de alto nivel a niveles inferiores es una soluci√≥n arquitect√≥nica deficiente. <br><br>  Eleg√≠ la opci√≥n 2. Perm√≠tanme mostrar el c√≥digo primero: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!done) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode = state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*opcode == <span class="hljs-number"><span class="hljs-number">0xdb</span></span>) <span class="hljs-comment"><span class="hljs-comment">//machine specific handling for IN { uint8_t port = opcode[1]; state-&gt;a = MachineIN(state, port); state-&gt;pc++; } else if (*opcode == 0xd3) //OUT { uint8_t port = opcode[1]; MachineOUT(state, port); state-&gt;pc++; } else Emulate8080Op(state); }</span></span></code> </pre> <br>  Este c√≥digo vuelve a implementar el procesamiento de c√≥digos de operaci√≥n para IN y OUT en la misma capa, que llama al emulador para el resto de los comandos.  En mi opini√≥n, esto hace que el c√≥digo sea m√°s limpio.  Esto es similar a una anulaci√≥n o subclase para los dos comandos, que se refiere a una capa de aut√≥mata. <br><br>  La desventaja es que transferimos la emulaci√≥n de c√≥digos de operaci√≥n en dos lugares.  No te culpar√© por elegir la tercera opci√≥n.  En la segunda opci√≥n, se requiere menos c√≥digo, pero la opci√≥n 3 es m√°s "limpia", pero el precio es un aumento en la complejidad.  Esta es una cuesti√≥n de elecci√≥n de estilo. <br><br><h2>  Registro de turnos </h2><br>  La m√°quina Space Invaders tiene una soluci√≥n de hardware interesante que implementa un comando bit shift.  El 8080 tiene comandos para un cambio de 1 bit, pero se necesitar√°n docenas de comandos 8080 para implementar un cambio de varios bits / byte. El hardware especial permite que el juego realice estas operaciones en solo unas pocas instrucciones.  Con su ayuda, cada cuadro se dibuja en el campo del juego, es decir, se usa muchas veces por cuadro. <br><br>  No creo que pueda explicarlo mejor que el excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">an√°lisis de</a> la arqueolog√≠a inform√°tica: <br><br> <code>; 16- : <br> ; f 0  <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ;    4  x  y,     x, : <br> ; $0000, <br> ; write $aa -&gt; $aa00, <br> ; write $ff -&gt; $ffaa, <br> ; write $12 -&gt; $12ff, .. <br> ; <br> ;    2 ( 0,1,2)    8- , : <br> ; offset 0: <br> ; rrrrrrrr result=xxxxxxxx <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ; offset 2: <br> ; rrrrrrrr result=xxxxxxyy <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ; offset 7: <br> ; rrrrrrrr result=xyyyyyyy <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ;    3   .</code> <br> <br>  Para el comando OUT, escribir en el puerto 2 establece la cantidad de desplazamiento, y escribir en el puerto 4 establece los datos en los registros de desplazamiento.  Leer con IN 3 devuelve datos desplazados por la cantidad de desplazamiento.  En mi m√°quina, esto se implementa as√≠: <br><br><pre> <code class="cpp hljs"> -(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) MachineIN(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(port) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> v = (shift1&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | shift0; a = ((v &gt;&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span>-shift_offset)) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } -(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) MachineOUT(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(port) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: shift_offset = value &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: shift0 = shift1; shift1 = value; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><h2>  Teclado </h2><br>  Para obtener la respuesta de la m√°quina, debemos vincular la entrada del teclado.  La mayor√≠a de las plataformas tienen una forma de recibir pulsaciones de teclas y eventos de lanzamiento.  El c√≥digo de plataforma para los botones tendr√° el siguiente aspecto: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(PeekMessage(&amp;msg,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,PM_REMOVE)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.message==WM_KEYDOWN ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.wParam == VK_LEFT ) MachineKeyDown(LEFT); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.message==WM_KEYUP ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.wParam == VK_LEFT ) MachineKeyUp(LEFT); } }</code> </pre> <br>  El c√≥digo de m√°quina que pega el c√≥digo de la plataforma al c√≥digo del emulador se ver√° as√≠: <br><br><pre> <code class="cpp hljs"> MachineKeyDown(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> key) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(key) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LEFT: port[<span class="hljs-number"><span class="hljs-number">1</span></span>] |= <span class="hljs-number"><span class="hljs-number">0x20</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Set bit 5 of port 1 break; case RIGHT: port[1] |= 0x40; //Set bit 6 of port 1 break; /*....*/ } } PlatformKeyUp(char key) { switch(key) { case LEFT: port[1] &amp;= 0xDF //Clear bit 5 of port 1 break; case RIGHT: port[1] &amp;= 0xBF //Clear bit 6 of port 1 break; /*....*/ } }</span></span></code> </pre> <br>  Si lo desea, puede combinar el c√≥digo de la m√°quina y la plataforma como desee; esta es la opci√≥n de implementaci√≥n.  No har√© esto porque voy a portar la m√°quina a varias plataformas diferentes. <br><br><h2>  Interrupciones </h2><br>  Despu√©s de estudiar el manual, me di cuenta de que el 8080 maneja las interrupciones de la siguiente manera: <br><br><ol><li>  La fuente de interrupci√≥n (externa a la CPU) establece el pin de interrupci√≥n de la CPU. </li><li>  Cuando la CPU confirma que se recibi√≥ la interrupci√≥n, la fuente de la interrupci√≥n puede enviar cualquier c√≥digo de operaci√≥n al bus y la CPU lo ve.  (La mayor√≠a de las veces usan el comando RST). </li><li>  La CPU ejecuta este comando.  Si es RST, entonces este es un an√°logo del comando CALL para una direcci√≥n fija en la parte inferior de la memoria.  Empuja la PC actual en la pila. </li><li>  El c√≥digo en la direcci√≥n de memoria inferior procesa lo que la interrupci√≥n quiere decirle al programa.  Una vez que se completa el procesamiento, RST finaliza con una llamada a RET. </li></ol><br>  El equipo de video del juego genera dos interrupciones que debemos emular mediante programaci√≥n: el final del cuadro y el medio del cuadro.  Ambos se realizan a 60 Hz (60 veces por segundo).  1/60 de segundo es 16.6667 milisegundos. <br><br>  Para simplificar el trabajo con interrupciones, agregar√© una funci√≥n al emulador 8080: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interrupt_num)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//perform "PUSH PC" Push(state, (state-&gt;pc &amp; 0xFF00) &gt;&gt; 8, (state-&gt;pc &amp; 0xff)); //Set the PC to the low memory vector. //This is identical to an "RST interrupt_num" instruction. state-&gt;pc = 8 * interrupt_num; }</span></span></code> </pre> <br>  El c√≥digo de la plataforma debe implementar un temporizador al que podamos llamar (por ahora, solo lo llamo hora ()).  El c√≥digo de m√°quina lo usar√° para pasar una interrupci√≥n al emulador 8080.  En el c√≥digo de la m√°quina, cuando expire el temporizador, llamar√© a GenerateInterrupt: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!done) { Emulate8080Op(state); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( time() - lastInterrupt &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//1/60 second has elapsed { //only do an interrupt if they are enabled if (state-&gt;int_enable) { GenerateInterrupt(state, 2); //interrupt 2 //Save the time we did this lastInterrupt = time(); } } }</span></span></code> </pre> <br>  Hay algunos detalles de c√≥mo el 8080 maneja realmente las interrupciones, que no emularemos.  Creo que dicho procesamiento ser√° suficiente para nuestros prop√≥sitos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419143/">https://habr.com/ru/post/es419143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es419131/index.html">La fecha de lanzamiento preliminar del m√≥dulo lunar SpaceIL anunci√≥</a></li>
<li><a href="../es419133/index.html">Seminarios web de los viernes: aprender a programar gratis</a></li>
<li><a href="../es419135/index.html">Friday JS: juego de 0 l√≠neas JS y CSS</a></li>
<li><a href="../es419137/index.html">Registro de actividad utilizando la API de Web Beacon</a></li>
<li><a href="../es419141/index.html">El phishing sexual est√° ganando impulso en los EE. UU.</a></li>
<li><a href="../es419145/index.html">Fintech Digest: la capitalizaci√≥n de Apple super√≥ los $ 1 bill√≥n, AI ayud√≥ a eBay a aumentar los ingresos en miles de millones</a></li>
<li><a href="../es419147/index.html">Cubo de 1000 dimensiones: ¬øes posible crear un modelo computacional de la memoria humana hoy?</a></li>
<li><a href="../es419149/index.html">Gu√≠a de Mikrotik RoMON</a></li>
<li><a href="../es419151/index.html">Hogar inteligente: una nueva dimensi√≥n de confort y la b√∫squeda de la excelencia. Parte dos</a></li>
<li><a href="../es419153/index.html">Memorando de derechos de Cyborg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>