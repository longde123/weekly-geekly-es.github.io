<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍⚕️ 🏏 🈶 Python是C ++的终极案例。 第2/2部分 🤦 👋🏻 💃🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="待续。 从Python开始， 作为C ++的终极案例。 第1/2部分 ”。 
 变量和数据类型 


 现在我们终于弄清楚了数学，让我们决定在我们的语言中什么变量意味着什么。 


 在C ++中，程序员可以选择：使用自动变量放置在堆栈上，或将值保留在程序数据存储器中，仅将指向这些值的指针放置在堆栈...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python是C ++的终极案例。 第2/2部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464405/"><p> 待续。 从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Python</a>开始， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">作为C ++的终极案例。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1/2部分</a> ”。 </p><br><h1> 变量和数据类型 </h1><br><p> 现在我们终于弄清楚了数学，让我们决定在我们的语言中什么变量意味着什么。 </p><br><p> 在C ++中，程序员可以选择：使用自动变量放置在堆栈上，或将值保留在程序数据存储器中，仅将指向这些值的指针放置在堆栈上。 如果我们仅为Python选择这些选项之一怎么办？ </p><br><p> 当然，我们不能总是仅使用变量的值，因为大型数据结构无法容纳在堆栈上，否则它们在堆栈上的不断移动将产生性能问题。 因此，我们将仅在Python中使用指针。 这将从概念上简化该语言。 </p><a name="habracut"></a><br><p> 所以表达 </p><br><pre><code class="python hljs">a = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p> 这将意味着我们在程序数据存储器（即所谓的“堆”）中创建了一个对象“ 3”，并将名称“ a”作为对其的引用。 和表达 </p><br><pre> <code class="python hljs">b = a</code> </pre> <br><p> 在这种情况下，这意味着我们强制变量“ b”引用内存中与“ a”引用的对象相同的对象，换句话说，就是复制了指针。 </p><br><p> 如果一切都是指针，那么我们需要用我们的语言实现多少个列表类型？ 当然，只有一个是指针列表！ 您可以使用它来存储整数，字符串，其他列表，无论如何-毕竟，这些都是指针。 </p><br><p> 我们需要实现多少种哈希表？  （在Python中，这种类型称为“字典” <code>dict</code> 。）一个！ 让它将指向键的指针与指向值的指针相关联。 </p><br><p> 因此，我们不需要用我们的语言来实现C ++规范的很大一部分-模板，因为我们对对象执行所有操作，并且对象始终可以通过指针访问。 当然，用Python编写的程序不必局限于使用指针：像NumPy这样的库可以帮助科学家处理内存中的数据数组，就像在Fortran中一样。 但是语言的基础-像“ a = 3”之类的表达式-始终可以使用指针。 </p><br><p>  “一切都是指针”的概念也将类型的构成简化到极限。 需要字典列表吗？ 只需创建一个列表并将字典放在这里即可！ 您不需要征求Python的许可，也不需要声明其他类型，一切都可以直接使用。 </p><br><p> 但是，如果我们想使用复合对象作为键怎么办？ 字典中的键必须具有不可变的值，否则如何通过它搜索值？ 列表可能会更改，因此不能以此身份使用。 在这种情况下，Python的数据类型类似于列表，是对象的序列，但是与列表不同，该序列不会改变。 这种类型称为元组或<code>tuple</code> （发音为“ tuple”或“ tuple”）。 </p><br><p>  Python中的元组解决了一个长期存在的脚本语言问题。 如果您对此功能不满意，那么您可能从未尝试使用脚本语言来处理数据，在这些数据中，您只能使用字符串或原始类型作为哈希表中的键。 </p><br><p> 元组给我们的另一种可能性是，从函数返回多个值而不必为此声明其他数据类型，就像您在C和C ++中所做的那样。 此外，为了使使用此功能更容易，赋值运算符具有自动将元组解包为单独变量的功能。 </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> host, port host, port = get_address()</code> </pre> <br><p> 拆包有几个有用的副作用，例如，变量值的交换可编写如下： </p><br><pre> <code class="python hljs">x, y = y, x</code> </pre> <br><p> 一切都是指针，这意味着函数和数据类型可以用作数据。 如果您熟悉《四人帮》（The Gang of Four）作者的“设计模式”（Design Patterns）一书，则必须记住它提供了哪些复杂且令人困惑的方法，以便在运行时对由程序创建的对象类型的选择进行参数化。 确实，在许多编程语言中，这很难做到！ 在Python中，所有这些困难都消失了，因为我们知道函数可以返回数据类型，函数和数据类型都只是链接，并且链接可以存储在例如字典中。 这将任务简化到了极限。 </p><br><p> 戴维·惠勒（David Wheeler）说：“所有编程问题都可以通过创建更高级别的间接解决。” 在Python中使用链接是间接级别，该级别通常用于解决许多语言（包括C ++）中的许多问题。 但是，如果在此显式使用它，并使程序复杂化，则在Python中，它隐式地针对所有类型的数据统一使用，并且易于使用。 </p><br><p> 但是，如果一切都是链接，那么这些链接指的是什么？ 像C ++这样的语言有很多类型。 让我们在Python中只保留一种数据类型-一个对象！ 类型理论领域的专家不赞成动摇头，但是我认为，一种源数据类型可以确保语言的统一性和易用性，是一个好主意，可以从中衍生出语言中的所有其他类型。 </p><br><p> 对于特定的内存内容，各种Python实现（PyPy，Jython或MicroPython）可以以不同的方式管理内存。 但是，为了更好地理解Python的简单性和统一性是如何实现的，以形成正确的思维模型，最好使用C语言中称为CPython的Python参考实现，可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">python.org</a>下载。 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ob_type</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* followed by object's data */</span></span> }</code> </pre> <br><p> 我们将在CPython源代码中看到的是一个结构，该结构由指向给定变量类型信息的指针和定义变量特定值的有效负载组成。 </p><br><p> 类型信息如何工作？ 让我们再次研究CPython源代码。 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> getattrfunc tp_getattr; setattrfunc tp_setattr; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> newfunc tp_new; freefunc tp_free; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> binaryfunc nb_add; binaryfunc nb_subtract; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> richcmpfunc tp_richcompare; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p> 我们看到了指向提供给定类型可能的所有操作的函数的指针：加，减，比较，对属性的访问，索引，切片等。这些操作知道如何使用内存中的有效负载在指向类型信息的指针下方，可以是整数，字符串或用户创建的类型的对象。 </p><br><p> 这与C和C ++根本不同，在C和C ++中，类型信息与名称而不是变量的值相关联。 在Python中，所有名称都与链接关联。 引用的值又是类型。 这是动态语言的本质。 </p><br><p> 为了实现该语言的所有功能，对于我们而言，在链接上定义两个操作就足够了。 最明显的之一就是复制。 当我们为变量，字典中的插槽或对象的属性分配值时，我们将复制链接。 这是一个简单，快速且完全安全的操作：复制链接不会更改对象的内容。 </p><br><p> 第二个操作是函数或方法调用。 如上所示，Python程序只能通过内置对象中实现的方法与内存进行交互。 因此，它不会导致与内存访问有关的错误。 </p><br><p> 您可能有一个问题：如果所有变量都包含引用，那么如何通过将变量作为参数传递给函数来保护变量的值免受更改？ </p><br><pre> <code class="python hljs">n = <span class="hljs-number"><span class="hljs-number">3</span></span> some_function(n) <span class="hljs-comment"><span class="hljs-comment"># Q: I just passed a pointer! # Could some_function() have changed “3”?</span></span></code> </pre> <br><p> 答案是Python中的简单类型是不可变的：它们根本没有实现负责更改其值的方法。 不可变（intmutable）的<code>int</code> ， <code>float</code> ， <code>tuple</code>或<code>str</code>以“一切都是指针”之类的语言提供，与自动变量在C中提供的语义效果相同。 </p><br><p> 统一的类型和方法尽可能地简化了通用程序或泛型的使用。 函数<code>min()</code> ， <code>max()</code> ， <code>sum()</code>等是内置函数，无需导入。 并且它们可与实现了<code>min()</code>和<code>max()</code>比较操作， <code>sum()</code>加法运算等任何数据类型一起使用。 </p><br><h1> 创建对象 </h1><br><p> 我们大致了解了对象应如何表现。 现在，我们将确定如何创建它们。 这是语言语法的问题。  C ++支持至少三种创建对象的方式： </p><br><ol><li> 自动，方法是声明此类的变量： <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">my_class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span></span>;</code> </pre> </li><li> 使用<code>new</code>运算符： <br><pre> <code class="cpp hljs">my_class *c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_class(arg);</code> </pre> </li><li> 工厂，通过调用返回指针的任意函数： <br><pre> <code class="cpp hljs">my_class *c = my_factory(arg);</code> </pre> </li></ol><br><p> 正如您可能已经猜到的那样，在上述示例中研究了Python创建者的思维方式后，现在我们必须选择其中之一。 </p><br><p> 从同一本书《四人帮》中，我们了解到工厂是创建对象的最灵活，最通用的方法。 因此，仅在Python中实现此方法。 </p><br><p> 除了通用性之外，此方法还不错，因为您无需使用不必要的语法来重载该语言以确保它：用我们的语言已经实现了函数调用，而工厂不过是一个函数。 </p><br><p> 在Python中创建对象的另一条规则是：任何数据类型都是其自己的工厂。 当然，您可以编写任意数量的其他自定义工厂（当然，它们将是普通的函数或方法），但一般规则将保持有效： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Let's make type objects # their own type's factories! c = MyClass() i = int('7') f = float(length) s = str(bytes)</span></span></code> </pre> <br><p> 所有类型都称为对象，它们都返回其类型的值，该值由调用中传递的参数确定。 </p><br><p> 因此，仅使用语言的基本语法，就可以封装创建对象（例如“ Arena”或“ Adaptation”模式）时的任何操作，因为从C ++借鉴的另一个好主意是类型本身决定了它如何发生生成对象， <code>new</code>操作员如何为他工作。 </p><br><h1>  NULL怎么样？ </h1><br><p> 处理空指针会增加程序的复杂性，因此我们禁止使用NULL。  Python语法使创建空指针成为不可能。 我们定义了指针上的两个基本操作，以使任何变量指向某个对象的方式进行定义。 </p><br><p> 结果，用户无法使用Python创建与内存访问相关的错误，例如分段错误或缓冲区限制。 换句话说，Python程序不受过去20年威胁互联网安全的两种最危险类型的漏洞的影响。 </p><br><p> 您可能会问：“如果像我们前面所看到的那样，如果对象上的操作结构不变，那么用户将如何创建自己的类，而方法和属性未在此结构中列出？” </p><br><p> 神奇之处在于，对于自定义类，Python具有非常简单的“准备”，并且实现了少量方法。 这里是最重要的： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> {</span></span> getattrfunc tr_getattr; setattrfunc tr_setattr; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> newfunc tp_new; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  <code>tp_new()</code>为用户类创建一个哈希表，与<code>dict</code>类型相同。  <code>tp_getattr()</code>从此哈希表中提取内容，而<code>tp_setattr()</code>相反，将内容放置在那里。 因此，不是在C语言结构的级别上而是在更高的级别（哈希表）上提供了任意类存储任何方法和属性的能力。  （当然，除了某些与性能优化有关的情况之外。） </p><br><h1> 访问修饰符 </h1><br><p> 我们如何处理围绕<code>private</code>和<code>protected</code> C ++关键字构建的所有这些规则和概念？  Python是一种脚本语言，不需要它们。 我们已经有部分“受保护的”语言-这些是内置类型的数据。 例如，在任何情况下，Python都不允许程序操纵浮点数的位！ 这种封装级别足以维持语言本身的完整性。 我们，Python的创造者，相信语言完整性是隐藏信息的唯一良好借口。 所有其他结构和用户程序数据都被视为公开的。 </p><br><p> 您可以在类属性名称的开头添加下划线（ <code>_</code> ），以警告同事：您不应依赖此属性。 但是Python的其余部分吸取了90年代初的教训：然后许多人认为，我们编写肿的，不可读的和有错误的程序的主要原因是缺少私有变量。 我认为接下来的20年已经使编程行业的每个人都信服：私有变量并不是唯一的方法，并且远非肿和错误的程序的最有效补救方法。 因此，Python的创建者决定甚至不用担心私有变量，并且正如您所看到的，它们没有失败。 </p><br><h1> 记忆体管理 </h1><br><p> 我们的对象，数字和字符串在较低级别会发生什么？ 它们是如何精确地存储在内存中的，CPython如何在何时以及在什么条件下销毁它们？ </p><br><p> 在这种情况下，我们选择了最通用，可预测和最有效的内存处理方式：从C程序的角度来看，我们所有的对象都是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">共享指针</a> 。 </p><br><p> 考虑到这一点，我们应该在下面的“变量和数据类型”部分中检查数据结构，以补充这些数据结构： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Py_ssize_t ob_refcnt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ob_type</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* followed by object's data */</span></span> } }</code> </pre> <br><p> 因此，Python中的每个对象（当然，我们指的是CPython的实现）都有其自己的引用计数器。 一旦变为零，就可以删除该对象。 </p><br><p> 链接计数机制不依赖于其他计算或后台进程-可以立即销毁一个对象。 此外，它提供了很高的数据局部性：通常，内存在释放后立即开始再次使用。 刚被破坏的对象最有可能在最近使用，这意味着它在处理器缓存中。 因此，新创建的对象将保留在缓存中。 这两个因素-简单性和局部性-使链接计数成为一种非常有效的垃圾收集方式。 </p><br><p>  （由于实际程序中的对象经常互相引用，因此即使在程序中不再使用对象时，在某些情况下引用计数器也无法降为零。因此，CPython还具有第二种垃圾回收机制-一种基于在几代物体上- <em>大约翻译</em> ） </p><br><h1>  Python开发人员错误 </h1><br><p> 我们试图开发一种对初学者来说足够简单但对专业人士也足够吸引人的语言。 同时，我们无法避免在理解和使用我们自己创建的工具时出现错误。 </p><br><p> 由于与脚本语言相关的思维惯性，Python 2试图转换字符串类型，就像类型弱的语言一样。 如果您尝试将字节字符串与Unicode中的字符串组合，则解释器会使用系统上可用的代码表将字节字符串隐式转换为Unicode，并以Unicode形式显示结果： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">'byte string '</span></span> + <span class="hljs-string"><span class="hljs-string">u'unicode string'</span></span> <span class="hljs-string"><span class="hljs-string">u'byte string unicode string'</span></span></code> </pre> <br><p> 结果，一些网站在其用户使用英语时运行良好，但在使用其他字母的字符时却产生了隐式错误。 </p><br><p> 此语言设计错误已在Python 3中修复： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">b'byte string '</span></span> + <span class="hljs-string"><span class="hljs-string">u'unicode string'</span></span> TypeError: can<span class="hljs-string"><span class="hljs-string">'t concat bytes to str</span></span></code> </pre> <br><p>  Python 2中类似的错误与由无与伦比的元素组成的列表的“天真”排序有关： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>sorted([<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]</code> </pre> <br><p> 在这种情况下，Python 3向用户清楚表明他正在尝试做一些不太有意义的事情： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>sorted([<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) TypeError: unorderable types: int() &lt; str()</code> </pre> <br><h1> 滥用行为 </h1><br><p> 用户有时会滥用Python语言的动态特性，然后在90年代，当最佳实践尚未广为人知时，这种情况尤其经常发生： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, host, port)</span></span></span><span class="hljs-function">:</span></span> self.host = host self.port = port</code> </pre> <br><p>  “但这不是最佳选择！”  -有人说-“如果端口与默认值没有区别怎么办？ 无论如何，我们在其存储上花费了整个类的属性！” 结果是像 </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, host, port=None)</span></span></span><span class="hljs-function">:</span></span> self.host = host <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> port <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-comment"><span class="hljs-comment"># so terrible self.port = port</span></span></code> </pre> <br><p> 因此，相同类型的对象会出现在程序中，但是由于其中一些对象具有特定的属性，而另一些对象却没有统一的属性，因此无法统一操作！ 而且，如果不事先检查其存在就无法触摸此属性： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># code was forced to use introspection # (terrible!) if hasattr(addr, 'port'): print(addr.port)</span></span></code> </pre> <br><p> 当前，大量的<code>hasattr()</code> ， <code>isinstance()</code>和其他自省是错误代码的肯定标志，并且使属性始终存在于对象中被认为是最佳实践。 访问时，这提供了一种更简单的语法： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># today's best practice: # every atribute always present if addr.port is not None: print(addr.port)</span></span></code> </pre> <br><p> 因此，有关动态添加和删除属性的早期实验结束了，现在我们以与C ++几乎相同的方式查看Python中的类。 </p><br><p> 早期Python的另一个坏习惯是使用函数，其中参数可以具有完全不同的类型。 例如，您可能认为用户每次创建一个列名列表可能太困难了，应该让他也将它们作为一行传递，其中各个列的名称之间用逗号分隔： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dataframe</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, columns)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(columns, str): columns = columns.split(<span class="hljs-string"><span class="hljs-string">','</span></span>) self.columns = columns</code> </pre> <br><p> 但是这种方法会引起问题。 例如，如果用户不小心给了我们一个不打算用作列名列表的行怎么办？ 还是列名应包含逗号？ </p><br><p> 同样，这样的代码更难以维护，调试，尤其是测试：在测试中，仅可以检查我们支持的两种类型中的一种，但是覆盖率仍为100％，而我们不会测试另一种类型。 </p><br><p> 结果是，我们得出的结论是Python允许用户将任何类型的参数传递给函数，但是大多数情况下它们中的大多数都将以与C中相同的方式使用函数：将相同类型的参数传递给它。 </p><br><p> 在程序中需要使用<code>eval()</code>被认为是显式的架构错误计算。 最有可能的是，您只是不知道如何以正常方式进行相同操作。     − ,      Jupyter notebook  -       −  <code>eval()</code>  ,      Python   ! ,     C++    . </p><br><p>     ,  ( <code>getattr()</code> , <code>hasattr()</code> , <code>isinstance()</code> )          .   ,   ,   ,      ,       : , ,  , ! </p><br><h1>   </h1><br><p>      :     ,           . 20             ,   C++  Python.   ,     ,    .         . </p><br><p>        ,    <code>shared_ptr</code>  TensorFlow   2016  2018 . </p><br><p> TensorFlow −       C++-,         Python- ( C++ −     TensorFlow, ). </p><br><p><img src="https://habrastorage.org/webt/dm/1g/zo/dm1gzovjtl2qbda7muz5wjzzjhq.png" alt="图片"></p><br><p>         TensorFlow,  <code>shared_ptr</code> ,     .     ,     . </p><br><p>      C++?       .    ,   ?     ,     ,  C++  Python! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN464405/">https://habr.com/ru/post/zh-CN464405/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN464391/index.html">来自黑客大会的10篇有趣的报道</a></li>
<li><a href="../zh-CN464393/index.html">如何找到编程课程以及什么是就业保障</a></li>
<li><a href="../zh-CN464395/index.html">基于RSA的区块链随机</a></li>
<li><a href="../zh-CN464399/index.html">R中的Web抓取，第2部分。通过并行计算和使用Rcrawler软件包加快过程</a></li>
<li><a href="../zh-CN464403/index.html">推送到GitLab存储库时如何在shell运行器上运行Java项目</a></li>
<li><a href="../zh-CN464407/index.html">世界上最大的视频监控系统如何工作</a></li>
<li><a href="../zh-CN464409/index.html">19世纪政治如何影响当今的数据中心位置</a></li>
<li><a href="../zh-CN464411/index.html">PVS-Studio：进步的引擎</a></li>
<li><a href="../zh-CN464413/index.html">PVS-Studio-进步的引擎</a></li>
<li><a href="../zh-CN464415/index.html">用于搜索hh.ru的新提示服务</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>