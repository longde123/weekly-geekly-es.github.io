<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•¶ üë®üèº üè¶ Exce√ß√µes de Kotlin e seus recursos üö® üíò üéë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nossa empresa utiliza o Kotlin na produ√ß√£o h√° mais de dois anos. Pessoalmente, me deparei com esse idioma h√° cerca de um ano. Existem muitos t√≥picos p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exce√ß√µes de Kotlin e seus recursos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/maxilect/blog/447380/">  Nossa empresa utiliza o Kotlin na produ√ß√£o h√° mais de dois anos.  Pessoalmente, me deparei com esse idioma h√° cerca de um ano.  Existem muitos t√≥picos para discuss√£o, mas hoje falaremos sobre tratamento de erros, inclusive em um estilo funcional.  Vou lhe dizer como fazer isso no Kotlin. <br><br><img src="https://habrastorage.org/webt/mb/bh/cp/mbbhcprsketr78wg8twpwhijg0y.jpeg" alt="imagem"><br><br>  <i>(Foto da reuni√£o sobre esse t√≥pico, realizada no escrit√≥rio de uma das empresas de Taganrog. Falou Alexey Shafranov, l√≠der do grupo de trabalho (Java) da Maxilekt)</i> <br><a name="habracut"></a><br><h3>  Como voc√™ pode lidar com erros em princ√≠pio? </h3><br>  Eu encontrei v√°rias maneiras: <br><br><ul><li>  voc√™ pode usar algum <b>valor de retorno</b> como um ponteiro para o fato de que h√° um erro; </li><li>  voc√™ pode usar <b>o par√¢metro do indicador</b> para a mesma finalidade, </li><li>  insira uma <b>vari√°vel global</b> </li><li>  lidar com <b>exce√ß√µes</b> </li><li>  Adicionar <b>contratos (DbC)</b> . </li></ul><br>  Vamos nos aprofundar em mais detalhes em cada uma das op√ß√µes. <br><br><h4>  Valor de retorno </h4><br>  Um certo valor "m√°gico" √© retornado se ocorrer um erro.  Se voc√™ j√° usou linguagens de script, deve ter visto constru√ß√µes semelhantes. <br><br>  Exemplo 1: <br><br><pre><code class="plaintext hljs">function sqrt(x) { if(x &lt; 0) return -1; else return ‚àöx; }</code> </pre> <br>  Exemplo 2: <br><br><pre> <code class="plaintext hljs">function getUser(id) { result = db.getUserById(id) if (result) return result as User else return ‚ÄúCan't find user ‚Äù + id }</code> </pre><br><h4>  Par√¢metro indicador </h4><br>  Um determinado par√¢metro passado para a fun√ß√£o √© usado.  Depois de retornar o valor pelo par√¢metro, voc√™ pode ver se houve um erro dentro da fun√ß√£o. <br><br>  Um exemplo: <br><br><pre> <code class="plaintext hljs">function divide(x,y,out Success) { if (y == 0) Success = false else Success = true return x/y } divide(10, 11, Success) id (!Success) //handle error</code> </pre><br><h4>  Vari√°vel global </h4><br>  A vari√°vel global funciona aproximadamente da mesma maneira. <br><br>  Um exemplo: <br><br><pre> <code class="plaintext hljs">global Success = true function divide(x,y) { if (y == 0) Success = false else return x/y } divide(10, 11, Success) id (!Success) //handle error</code> </pre><br><h4>  Exce√ß√µes </h4><br>  Estamos todos acostumados a exce√ß√µes.  Eles s√£o usados ‚Äã‚Äãem quase todos os lugares. <br><br>  Um exemplo: <br><br><pre> <code class="plaintext hljs">function divide(x,y) { if (y == 0) throw Exception() else return x/y } try{ divide(10, 0)} catch (e) {//handle exception}</code> </pre><br><h4>  Contratos (DbC) </h4><br>  Francamente, nunca vi essa abordagem ao vivo.  Pesquisando bastante, descobri que o Kotlin 1.3 tem uma biblioteca que permite o uso de contratos.  I.e.  voc√™ pode definir a condi√ß√£o nas vari√°veis ‚Äã‚Äãque s√£o passadas para a fun√ß√£o, a condi√ß√£o no valor de retorno, o n√∫mero de chamadas, de onde √© chamado, etc.  E se todas as condi√ß√µes forem atendidas, acredita-se que a fun√ß√£o funcionou corretamente. <br><br>  Um exemplo: <br><br><pre> <code class="plaintext hljs">function sqrt (x) pre-condition (x &gt;= 0) post-condition (return &gt;= 0) begin calculate sqrt from x end</code> </pre><br>  Honestamente, esta biblioteca tem uma sintaxe terr√≠vel.  Talvez seja por isso que eu n√£o tenha visto algo ao vivo. <br><br><h3>  Exce√ß√µes em Java </h3><br>  Vamos para o Java e como tudo funcionou desde o in√≠cio. <br><br><img src="https://habrastorage.org/webt/gk/oo/mw/gkoomw72k7yp5mhpi9ebpt02g-i.png" alt="imagem"><br><br>  Ao projetar uma linguagem, dois tipos de exce√ß√µes foram lan√ßados: <br><br><ul><li>  verificado - verificado; </li><li>  desmarcado - desmarcado. </li></ul><br>  Para que s√£o verificadas as exce√ß√µes?  Teoricamente, eles s√£o necess√°rios para que as pessoas procurem erros.  I.e.  se uma certa exce√ß√£o marcada for poss√≠vel, ela dever√° ser verificada mais tarde.  Teoricamente, essa abordagem deveria ter levado √† aus√™ncia de erros n√£o processados ‚Äã‚Äãe √† melhoria da qualidade do c√≥digo.  Mas, na pr√°tica, n√£o √© assim.  Acho que todo mundo pelo menos uma vez na vida viu um bloco de captura vazio. <br><br>  Por que isso pode ser ruim? <br><br>  Aqui est√° um exemplo cl√°ssico diretamente da documenta√ß√£o do Kotlin - uma interface do JDK implementada no StringBuilder: <br><br><pre> <code class="plaintext hljs">Appendable append(CharSequence csq) throws IOException; try { log.append(message) } catch (IOException e) { //Must be safe }</code> </pre><br>  Tenho certeza de que voc√™ encontrou bastante c√≥digo envolvido no try-catch, onde catch √© um bloco vazio, pois essa situa√ß√£o simplesmente n√£o deveria ter acontecido, de acordo com o desenvolvedor.  Em muitos casos, o tratamento de exce√ß√µes verificadas √© implementado da seguinte maneira: eles simplesmente lan√ßam uma RuntimeException e a capturam em algum lugar acima (ou n√£o a capturam ...). <br><br><pre> <code class="plaintext hljs">try { // do something } catch (IOException e) { throw new RuntimeException(e); //  - ...</code> </pre><br><h3>  O que √© poss√≠vel no Kotlin </h3><br>  Em termos de exce√ß√µes, o compilador Kotlin √© diferente: <br><br>  1. N√£o faz distin√ß√£o entre exce√ß√µes verificadas e n√£o verificadas.  Todas as exce√ß√µes s√£o desmarcadas e voc√™ decide se deve captur√°-las e process√°-las. <br><br>  2. Try pode ser usado como uma express√£o - voc√™ pode executar o bloco try e retornar a √∫ltima linha dele ou retornar a √∫ltima linha do bloco catch. <br><br><pre> <code class="plaintext hljs">val value = try {Integer.parseInt(‚Äúlol‚Äù)} catch(e: NumberFormanException) { 4 } // </code> </pre><br>  3. Voc√™ tamb√©m pode usar uma constru√ß√£o semelhante ao se referir a algum objeto, que pode ser anul√°vel: <br><br><pre> <code class="plaintext hljs">val s = obj.money ?: throw IllegalArgumentException(‚Äú , ‚Äù)</code> </pre><br><h4>  Compatibilidade com Java </h4><br>  O c√≥digo Kotlin pode ser usado em Java e vice-versa.  Como lidar com exce√ß√µes? <br><br><ul><li>  As exce√ß√µes verificadas do Java no Kotlin n√£o podem ser verificadas nem declaradas (pois n√£o h√° exce√ß√µes verificadas no Kotlin). </li><li>  As poss√≠veis exce√ß√µes verificadas do Kotlin (por exemplo, aquelas que vieram originalmente do Java) n√£o precisam ser verificadas no Java. </li><li>  Se for necess√°rio verificar, a exce√ß√£o pode ser verificada usando a anota√ß√£o @Throws no m√©todo (voc√™ deve especificar quais exce√ß√µes esse m√©todo pode lan√ßar).  A anota√ß√£o acima √© apenas para compatibilidade com Java.  Mas, na pr√°tica, muitas pessoas o usam para declarar que esse m√©todo, em princ√≠pio, pode gerar algum tipo de exce√ß√£o. </li></ul><br><h4>  Alternativa ao bloco try-catch </h4><br>  O bloco try-catch tem uma desvantagem significativa.  Quando aparece, parte da l√≥gica de neg√≥cios √© transferida dentro da captura e isso pode acontecer em um dos muitos m√©todos acima.  Quando a l√≥gica comercial se espalha por blocos ou por toda a cadeia de chamadas, fica mais dif√≠cil entender como o aplicativo funciona.  E os pr√≥prios blocos de legibilidade n√£o adicionam c√≥digo. <br><br><pre> <code class="plaintext hljs">try { HttpService.SendNotification(endpointUrl); MarkNotificationAsSent(); } catch (e: UnableToConnectToServerException) { MarkNotificationAsNotSent(); }</code> </pre><br>  Quais s√£o as alternativas? <br><br>  Uma op√ß√£o nos oferece uma abordagem funcional para o tratamento de exce√ß√µes.  Uma implementa√ß√£o semelhante √© assim: <br><br><pre> <code class="plaintext hljs">val result: Try&lt;Result&gt; = Try{HttpService.SendNotification(endpointUrl)} when(result) { is Success -&gt; MarkNotificationAsSent() is Failure -&gt; MarkNotificationAsNotSent() }</code> </pre><br>  Temos a oportunidade de usar a m√¥nada Try.  Em ess√™ncia, este √© um cont√™iner que armazena algum valor.  O flatMap √© um m√©todo de trabalhar com esse cont√™iner que, junto com o valor atual, pode assumir uma fun√ß√£o e, novamente, retornar uma m√¥nada. <br><br>  Nesse caso, a chamada √© encerrada na m√¥nada Try (retornamos Try).  Pode ser processado em um √∫nico local - onde precisamos.  Se a sa√≠da tiver um valor, executamos as seguintes a√ß√µes com ela; se uma exce√ß√£o for lan√ßada, a processaremos no final da cadeia. <br><br><h4>  Tratamento de exce√ß√µes funcionais </h4><br>  Onde posso obter o Try? <br><br>  Primeiro, existem algumas implementa√ß√µes comunit√°rias das classes Try e Either.  Voc√™ pode lev√°-los ou at√© mesmo escrever uma implementa√ß√£o.  Em um dos projetos de ‚Äúcombate‚Äù, usamos a implementa√ß√£o Try feita por n√≥s mesmos - gerenciamos com uma classe e fizemos um excelente trabalho. <br>  Em segundo lugar, existe a biblioteca Arrow, que em princ√≠pio adiciona muitas funcionalidades ao Kotlin.  Naturalmente, existem Tente e qualquer um. <br><br>  Al√©m disso, a classe Result apareceu no Kotlin 1.3, que discutirei com mais detalhes posteriormente. <br><br><h4>  Tente usar a biblioteca Arrow como exemplo </h4><br>  A biblioteca Arrow nos d√° uma classe Try.  De fato, ele pode estar em dois estados: Sucesso ou Falha: <br><br><ul><li>  O sucesso na retirada bem-sucedida manter√° nosso valor, </li><li>  A falha armazena uma exce√ß√£o que ocorreu durante a execu√ß√£o de um bloco de c√≥digo. </li></ul><br>  A chamada √© a seguinte.  Naturalmente, ele √© envolvido em um try-catch regular, mas isso acontece em algum lugar dentro do nosso c√≥digo. <br><br><pre> <code class="plaintext hljs">sealed class Try&lt;out A&gt; { data class Success&lt;out A&gt;(val value: A) : Try&lt;A&gt;() data class Failure(val e: Throwable) : Try&lt;Nothing&gt;() companion object { operator fun &lt;A&gt; invoke(body: () -&gt; A): Try&lt;A&gt; { return try { Success(body()) } catch (e: Exception) { Failure(e) } } }</code> </pre><br>  A mesma classe deve implementar o m√©todo flatMap, que permite que voc√™ passe uma fun√ß√£o e retorne nossa try monad: <br><br><pre> <code class="plaintext hljs">inline fun &lt;B&gt; map(f: (A) -&gt; B): Try&lt;B&gt; = flatMap { Success(f(it)) } inline fun &lt;B&gt; flatMap(f: (A) -&gt; TryOf&lt;B&gt;): Try&lt;B&gt; = when (this) { is Failure -&gt; this is Success -&gt; f(value) }</code> </pre><br>  Para que √© isso?  Para n√£o processar erros para cada um dos resultados quando tivermos v√°rios deles.  Por exemplo, obtivemos v√°rios valores de diferentes servi√ßos e queremos combin√°-los.  De fato, podemos ter duas situa√ß√µes: recebemos e combinamos com sucesso ou algo caiu.  Portanto, podemos fazer o seguinte: <br><br><pre> <code class="plaintext hljs">val result1: Try&lt;Int&gt; = Try { 11 } val result2: Try&lt;Int&gt; = Try { 4 } val sum = result1.flatMap { one -&gt; result2.map { two -&gt; one + two } } println(sum) //Success(value=15)</code> </pre><br>  Se as duas chamadas foram bem-sucedidas e obtivemos os valores, executamos a fun√ß√£o  Se n√£o forem bem-sucedidas, Failure retornar√° com uma exce√ß√£o. <br><br>  Aqui est√° o que parece se algo caiu: <br><br><pre> <code class="plaintext hljs">val result1: Try&lt;Int&gt; = Try { 11 } val result2: Try&lt;Int&gt; = Try { throw RuntimeException(‚ÄúOh no!‚Äù) } val sum = result1.flatMap { one -&gt; result2.map { two -&gt; one + two } } println(sum) //Failure(exception=java.lang.RuntimeException: Oh no!</code> </pre><br>  Usamos a mesma fun√ß√£o, mas a sa√≠da √© uma falha de uma RuntimeException. <br><br>  Al√©m disso, a biblioteca Arrow permite que voc√™ use constru√ß√µes que s√£o de fato a√ß√∫car sint√°tico, em particular vinculativo.  Tudo o mesmo pode ser reescrito atrav√©s de um flatMap serial, mas a encaderna√ß√£o permite torn√°-lo leg√≠vel. <br><br><pre> <code class="plaintext hljs">val result1: Try&lt;Int&gt; = Try { 11 } val result2: Try&lt;Int&gt; = Try { 4 } val result3: Try&lt;Int&gt; = Try { throw RuntimeException(‚ÄúOh no, again!‚Äù) } val sum = binding { val (one) = result1 val (two) = result2 val (three) = result3 one + two + three } println(sum) //Failure(exception=java.lang.RuntimeException: Oh no, again!</code> </pre><br>  Dado que um dos resultados caiu, obtemos um erro na sa√≠da. <br><br>  Uma m√¥nada semelhante pode ser usada para chamadas ass√≠ncronas.  Por exemplo, aqui est√£o duas fun√ß√µes executadas de forma ass√≠ncrona.  Combinamos os resultados da mesma maneira, sem verificar separadamente seu status: <br><br><pre> <code class="plaintext hljs">fun funA(): Try&lt;Int&gt; { return Try { 1 } } fun funB(): Try&lt;Int&gt; { Thread.sleep(3000L) return Try { 2 } } val a = GlobalScope.async { funA() } val b = GlobalScope.async { funB() } val sum = runBlocking { a.await().flatMap { one -&gt; b.await().map {two -&gt; one + two } } }</code> </pre><br>  E aqui est√° um exemplo mais de "combate".  Temos uma solicita√ß√£o para o servidor, processamos, obtemos o corpo e tentamos mapear para nossa classe, da qual j√° estamos retornando dados. <br><br><pre> <code class="plaintext hljs">fun makeRequest(request: Request): Try&lt;List&lt;ResponseData&gt;&gt; = Try { httpClient.newCall(request).execute() } .map { it.body() } .flatMap { Try { ObjectMapper().readValue(it, ParsedResponse::class.java) } } .map { it.data } fun main(args : Array&lt;String&gt;) { val response = makeRequest(RequestBody(args)) when(response) { is Try.Success -&gt; response.data.toString() is Try.Failure -&gt; response.exception.message } }</code> </pre><br>  O try-catch tornaria esse bloco muito menos leg√≠vel.  E, nesse caso, obtemos response.data na sa√≠da, que podemos processar dependendo do resultado. <br><br><h4>  Resultado do Kotlin 1.3 </h4><br>  Kotlin 1.3 introduziu a classe Result.  De fato, √© algo semelhante ao Try, mas com v√°rias limita√ß√µes.  Ele foi originalmente projetado para ser usado em v√°rias opera√ß√µes ass√≠ncronas. <br><br><pre> <code class="plaintext hljs">val result: Result&lt;VeryImportantData&gt; = Result.runCatching { makeRequest() } .mapCatching { parseResponse(it) } .mapCatching { prepareData(it) } result.fold{ { data -&gt; println(‚ÄúWe have $data‚Äù) }, exception -&gt; println(‚ÄúThere is no any data, but it's your exception $exception‚Äù) } )</code> </pre><br>  Se n√£o estiver enganado, essa classe √© atualmente experimental.  Os desenvolvedores de idiomas podem alterar sua assinatura, comportamento ou remov√™-lo completamente; portanto, no momento √© proibido us√°-lo como valor de retorno de m√©todos ou vari√°veis.  No entanto, ele pode ser usado como uma vari√°vel local (privada).  I.e.  de fato, ele pode ser usado como uma tentativa do exemplo. <br><br><h3>  Conclus√µes </h3><br>  Conclus√µes que fiz para mim: <br><br><ul><li>  a manipula√ß√£o de erros funcionais no Kotlin √© simples e conveniente; </li><li>  ningu√©m se incomoda em process√°-las atrav√©s do try-catch no estilo cl√°ssico (isso e aquilo tem direito √† vida; isso e aquilo s√£o convenientes); </li><li>  a aus√™ncia de exce√ß√µes verificadas n√£o significa que erros n√£o possam ser tratados; </li><li>  exce√ß√µes n√£o capturadas na produ√ß√£o levam a tristes conseq√º√™ncias. </li></ul><br>  Autor do artigo: Alexey Shafranov, l√≠der do grupo de trabalho (Java), Maxilect <br><br>  PS Publicamos nossos artigos em v√°rios sites do Runet.  Assine nossas p√°ginas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">canal</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VK</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FB</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Telegram</a> para descobrir todas as nossas publica√ß√µes e outras not√≠cias do Maxilect. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt447380/">https://habr.com/ru/post/pt447380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt447368/index.html">N√£o apenas pegando pulgas. Por que a velocidade √© t√£o importante para qualquer loja</a></li>
<li><a href="../pt447370/index.html">Por que, devido a um sistema de patentes quebrado, a sombra de Theranos ainda paira sobre n√≥s</a></li>
<li><a href="../pt447372/index.html">A transforma√ß√£o da TI √© inevit√°vel: por onde come√ßar</a></li>
<li><a href="../pt447374/index.html">Criando elementos de interface programaticamente usando o PureLayout (parte 2)</a></li>
<li><a href="../pt447376/index.html">SNA Hackathon 2019</a></li>
<li><a href="../pt447382/index.html">O livro "Unidade e C #. Gamedev da ideia √† implementa√ß√£o. 2nd ed</a></li>
<li><a href="../pt447384/index.html">Semicondutores de pot√™ncia em guarda da ecologia</a></li>
<li><a href="../pt447388/index.html">TL; resumo DR da Universidade ITMO: admiss√£o n√£o cl√°ssica √† universidade, eventos futuros e os materiais mais interessantes</a></li>
<li><a href="../pt447390/index.html">Diretrizes de configura√ß√£o do AccelStor AFA para VMware vSphere</a></li>
<li><a href="../pt447392/index.html">Tr√™s problemas de servi√ßos para verificar a gram√°tica inglesa e se eles podem ser resolvidos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>