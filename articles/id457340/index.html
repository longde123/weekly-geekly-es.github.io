<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ˆğŸ» ğŸ¬ ğŸŒ¡ï¸ 10 plugin PostCSS yang akan menghemat waktu tata letak Anda ğŸ‘©â€ğŸŒ¾ ğŸ® ğŸº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami, front-end, memiliki kategori alat yang tidak menyelesaikan masalah yang kami hadapi, tetapi lebih memengaruhi proses penyelesaiannya. Ubah itu. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 plugin PostCSS yang akan menghemat waktu tata letak Anda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457340/"><p><img src="https://habrastorage.org/webt/1b/7_/el/1b7_elrk3cworvip4qutltld9to.jpeg"></p><br><p>  Kami, front-end, memiliki kategori alat yang tidak menyelesaikan masalah yang kami hadapi, tetapi lebih memengaruhi proses penyelesaiannya.  Ubah itu.  Sikap terhadap alat-alat seperti itu sangat berbeda - mulai dari mania dalam semangat "mari kita dorong benda ini ke mana-mana, itu sangat keren" dan diakhiri dengan alasan seperti "jika itu tidak menyelesaikan masalah bisnis, maka kita tidak membutuhkannya".  Tetapi, bagaimanapun, hari ini kita akan berbicara tentang PostCSS - salah satu alat tersebut. </p><br><p>  Gelombang sensasi telah lama berlalu, dalam beberapa tahun terakhir, sangat sedikit yang dikatakan tentang PostCSS.  Banyak pemula bahkan tidak tahu apa itu.  Saya pikir sudah waktunya untuk melihat alat ini dari sudut pandang penggunaan praktis dalam proyek yang paling biasa, di mana orang memecahkan masalah, dan tidak bermain-main dengan teknologi modern. </p><a name="habracut"></a><br><h2 id="postcss-vs-sass">  PostCSS vs SASS </h2><br><p> Oh ... Rupanya beberapa kata tentang ini.  Saya pikir sekarang penyetem langka tidak bertemu dengan preprosesor.  SASS atau KURANG favorit saya, lebih jarang Stylus, digunakan baik pada proyek besar maupun kecil.  Seseorang mencoba memeras sebagian besar dari mereka, seseorang menggunakan set-nesting, variabel, impor minimum.  Tetapi, satu atau lain cara, alat-alat ini membantu dengan masalah sintaksis.  Mereka membuatnya lebih mudah bagi kita untuk menulis kode. </p><br><p>  Sekitar dua atau tiga tahun yang lalu PostCSS secara konstan dibandingkan dengan preprosesor.  Dan itu bisa dimengerti.  Secara formal, dengan menggunakannya Anda dapat melakukan hal yang sama, membuat semacam sintaks yang akan lebih nyaman daripada CSS murni.  Tetapi semua ini menyebabkan massa yang menggelegak, terutama karena semua orang dengan bantuan PostCSS melakukan sesuatu yang berbeda.  Tak terhitung plugin yang tidak diketahui, jutaan kombinasi, dan terlepas dari pembuat konfigurasi ini atau itu, tidak ada yang mengerti cara kerjanya dan apa fungsinya.  Ini seperti Vim atau Emacs - Anda dapat membuat pesawat luar angkasa dari mereka, tetapi akan sangat sulit untuk mengajari pengembang lain cara menggunakannya. </p><br><p>  Tetapi jika kita membuang perbandingan ini, maka PostCSS adalah alat yang memungkinkan kita untuk mengambil CSS kita dan melakukan sesuatu dengannya.  Tidak ada yang mengganggu untuk menggunakan SASS demi sintaks, dan setelah perakitan, tempel PostCSS dan lakukan sesuatu dengan hasilnya.  Mereka tidak saling bertentangan. </p><br><h2 id="staroe--ne-znachit-nerabotayuschee">  Tua bukan berarti menganggur </h2><br><p>  Baru-baru ini, telah menjadi mode bagi kami untuk membuat kombinasi yang dapat melakukan segala sesuatu yang hanya terpikirkan, dan pengembangannya tidak pernah berhenti.  Dan jika tidak ada komitmen baru dalam repositori selama beberapa bulan, maka semuanya - kita dapat mengasumsikan bahwa itu sudah usang dan sekarang menggunakannya - bukan kome il faut.  Saya akan membesar-besarkan, tentu saja, tetapi saya pikir Anda sendiri memperhatikan betapa absurdnya hal ini. </p><br><p>  Di dunia PostCSS, biasanya satu plugin memecahkan satu masalah.  Anda dapat melihat elemen-elemen filosofi Unix di sini.  Kesimpulan logis berikut dari ini - jika plugin sudah menyelesaikan tugasnya, maka tidak ada lagi yang perlu dilakukan dengannya.  Anda dapat menemukan plugin yang belum diperbarui selama bertahun-tahun, tetapi ini tidak berarti bahwa mereka tiba-tiba berhenti menyelesaikan tugas yang mereka buat. </p><br><p>  Tapi mari kita mulai ... Saya mengumpulkan selusin plug-in, yang dalam praktiknya telah menunjukkan kemampuan mereka untuk menyederhanakan kehidupan bagi desainer tata letak dan menghemat waktu selama pengembangan.  Tetapi Anda selalu dapat menambahkan sesuatu di komentar. </p><br><h2 id="1-doiuse">  1  Doiuse </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/anandthakker/doiuse</a> </p><br><p>  Saya pikir kita semua menghadapi masalah ini: Anda menulis kode, check in chrome - semuanya baik-baik saja.  Anda check-in FF - sekitar.  Dan kemudian di Safari seluler semuanya berantakan.  Atau di Edge.  Dan Anda duduk dan tidak mengerti apa yang salah.  Kemudian Anda menatap kode untuk waktu yang lama, minum teh, dan tiba-tiba muncul wawasan bahwa beberapa properti tidak didukung di beberapa browser.  Anda pergi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kaniuse</a> dan Anda melihat konfirmasi yang jelas. </p><br><p><img src="https://habrastorage.org/webt/pm/dy/lw/pmdylwl6g5ahftjlsoikrqyckec.png"></p><br><p>  Tentu saja, dengan pengalaman, tangan itu sendiri mengingat sifat apa yang harus dihindari, tetapi apa pun terjadi.  Anda tidak bisa cukup tidur, bisa ada tenggat waktu dan saraf yang ketat, daftar browser yang perlu diubah dapat berubah.  Dan kemudian pengalaman akan mulai gagal.  Doiuse adalah alat yang banyak membantu dalam situasi seperti itu. </p><br><p>  Prinsip operasi sederhana - kami memberinya daftar browser dan CSS kami.  Plugin masuk ke database caniuse dan secara real time memberi kami jawaban yang kami gunakan dari apa yang tidak didukung. </p><br><p>  Kita dapat mengatur daftar browser secara langsung di package.json.  Sederhana dan nyaman.  PostCSS menggunakan daftar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">browser</a> dan, jika Anda belum pernah melihatnya, tampilannya seperti ini: </p><br><pre><code class="plaintext hljs">"browserslist": [ "&gt; .5% and last 2 versions", "not dead", "not OperaMini all", "ie &gt;= 11", "Edge &gt;= 12" ]</code> </pre> <br><p>  Ada juga konfigurasi doiuse itu sendiri, di mana Anda dapat memaksanya untuk mengabaikan beberapa grup properti jika Anda yakin itu tidak mempengaruhi apa pun.  Misalnya, jika Anda menggunakan polyfiles atau dari hilangnya dukungan beberapa properti, tidak ada yang akan berubah: </p><br><pre> <code class="plaintext hljs">ignore: [ 'will-change', 'object-fit' ]</code> </pre> <br><p>  Log standar yang disediakan oleh plugin tidak mudah dibaca.  Ini berisi banyak informasi dan tidak nyaman untuk melihatnya.  Tapi ini bisa diperbaiki.  Dalam konfigurasi yang sama, kita bisa melakukan fungsi kita untuk membuat log. </p><br><blockquote>  Gunakan console.log untuk mengetahui bagaimana objek yang mengirimkan PostCSS ke fungsi ini berfungsi.  Ada banyak hal menarik. </blockquote><p>  Praktik saya telah menunjukkan bahwa opsi paling mudah adalah menampilkan pemilih dan properti spesifik yang tidak didukung, tanpa menentukan peramban dan baris kode.  Jika proyek menggunakan BEM atau beberapa analog, dan kode komponen didistribusikan dalam file yang terpisah, maka pendekatan ini memungkinkan Anda untuk dengan cepat menemukan tempat masalahnya tanpa memuat otak. </p><br><pre> <code class="javascript hljs">onFeatureUsage(info) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = info.usage.parent.selector; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> property = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${info.usage.prop}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${info.usage.value}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> status = info.featureData.caniuseData.status.toUpperCase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.featureData.missing) { status = <span class="hljs-string"><span class="hljs-string">'NOT SUPPORTED'</span></span>.red; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.featureData.partial) { status = <span class="hljs-string"><span class="hljs-string">'PARTIAL SUPPORT'</span></span>.yellow; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`\n</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${status}</span></span></span><span class="hljs-string">:\n\n </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selector}</span></span></span><span class="hljs-string"> {\n </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${property}</span></span></span><span class="hljs-string">;\n }\n`</span></span>); }</code> </pre> <br><p>  Agar tidak menulis urutan karakter khusus untuk warna di konsol, Anda dapat menghubungkan paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">warna</a> , itu akan lebih nyaman dengannya. </p><br><p>  Saat membangun, akan ada sesuatu seperti ini di konsol: </p><br><pre> <code class="plaintext hljs">NOT SUPPORTED: html { -ms-text-size-adjust: 100%; } NOT SUPPORTED: html { -webkit-text-size-adjust: 100%; } PARTIAL SUPPORT: body { display: flex; }</code> </pre> <br><h2 id="2-autoprefixer">  2  Autoprefixer </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/postcss/autoprefixer</a> </p><br><p>  Bahkan memalukan untuk membicarakannya, tetapi terlalu sering saya melihat orang-orang yang pada tahun 2019 menulis awalan dengan tangan mereka dan masih meyakinkan orang lain bahwa mereka tahu persis mana yang dibutuhkan dan mana yang tidak.  Tindakan tersebut mengarah pada fakta bahwa kode ditumbuhi banyak awalan yang tidak perlu dan menjadi benar-benar tidak dapat dibaca.  Ini mempengaruhi produktivitas tenaga kerja.  Di sisi lain, jika Anda memerlukan dukungan dinosaurus, Anda selalu dapat melupakan sesuatu.  Jadi ada baiknya menyingkirkan tenaga manual saat memecahkan masalah ini. </p><br><p>  Autoprefixer bekerja dengan database caniuse yang sama, menggunakan daftar browser yang sama dan dapat menambahkan ke CSS awalan yang benar-benar diperlukan di browser yang kami tentukan.  Pada saat yang sama, kode itu sendiri menjadi lebih bersih, dan pekerjaan berjalan lebih cepat. </p><br><h2 id="3-stylelint">  Nomor 3  Stylelint </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/stylelint/stylelint</a> </p><br><p>  Ketika Anda mencetak banyak dan cepat, cepat atau lambat Anda mulai membuat banyak kesalahan tanpa benar-benar menyadarinya.  Mata buram.  Dalam kasus CSS, ini dapat memberikan efek lucu (sebenarnya tidak) ketika Anda melihat di browser - Anda melihat masalah dengan tata letak.  Anda melihat kode - itu tidak ada di sana.  Anda melihat di browser - itu.  Namun dalam kode - tidak.  Sebagai hasilnya, Anda dapat mencari masalah yang sulit untuk waktu yang lama, sama sekali tidak menyadari bahwa Anda baru saja berkutat.  Untuk mencegah hal ini, diciptakan linter. </p><br><p>  Stylelint adalah opsi yang populer.  Dia tahu bagaimana bekerja dengan sintaks dari preprosesor utama, dia tahu tentang tren terbaru dalam CSS, dia dapat menyesuaikannya dengan seleranya - konfigurasi mirip dengan eslint.  Secara formal, alat ini dapat digunakan sendiri, tanpa PostCSS, tetapi belum lagi akan salah. </p><br><h2 id="4-postcss-flexbugs-fixes">  Nomor 4  Postcss-flexbugs-fixes </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/luisrudge/postcss-flexbugs-fixes</a> </p><br><p>  Atau dalam arti yang lebih luas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perbaikan postcss</a> , yang mencakup plugin ini.  Perlahan, tapi pasti, melenturkan menggantikan pendekatan lama untuk tata letak pada pelampung.  Ini bagus, tetapi kita semua tahu bahwa banyak bug terkait dengan mereka.  Mereka dijelaskan dalam repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">flexbugs</a> .  Beberapa dari mereka memerlukan perhatian khusus, tetapi ada juga beberapa yang sangat sederhana sehingga mereka terus-menerus terbang keluar dari kepala Anda.  Sebagai contoh, IE mengabaikan fungsi calc di singkatan untuk properti flex.  Ini tidak begitu sering diperlukan, tetapi jika perlu, maka tangan Anda dapat menulis versi singkat dan kemudian Anda harus berpikir lama tentang masalahnya.  Untungnya, ini dapat diperbaiki secara otomatis.  Plugin postcss-flexbugs-fixes datang untuk menyelamatkan. </p><br><p>  Dalam contoh kalk, ia akan menemukan fragmen seperti ini dalam kode: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">flex</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(1vw â€“ 1px); }</code> </pre> <br><p>  Dan sebarkan: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">flex-grow</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-shrink</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-basis</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(1vw - 1px); }</code> </pre> <br><p>  Sederhana dan nyaman. </p><br><h2 id="5-postcss-preset-env">  No. 5.  Postcss-preset-env </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/csstools/postcss-preset-env</a> </p><br><p>  Karena kita berbicara tentang dukungan browser, itu tidak akan keluar dari tempatnya untuk mengatakan tentang postcss-preset-env.  Sebelumnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cssnext</a> memainkan peran yang sama.  Plugin ini akan berguna jika Anda tertarik dengan tren baru di CSS. </p><br><p><img src="https://habrastorage.org/webt/bu/kp/4h/bukp4htn6ewwkk4qznb8phjxzoa.jpeg"></p><br><p>  Banyak inovasi yang secara teknis dapat diimplementasikan dengan menggunakan metode lama, itu hanya akan panjang, verbose dan jelek.  Preset-env membantu Anda menulis kode dengan cara baru, menghemat waktu untuk hal ini, dan kemudian mengonversinya ke versi lama yang andal.  Tentu saja, beberapa hal seperti properti khusus tidak diterapkan sama sekali di peramban lama, jadi fallback akan digunakan di sana. </p><br><p>  Seperti yang bisa Anda tebak dari nama instrumen, itu menyerupai nama yang sama ditetapkan di Babel.  Di sini, semuanya sama - ada banyak konverter yang dirangkai menjadi satu set yang stabil.  Beberapa transformasi memerlukan koneksi skrip polifile berikutnya pada klien, tetapi sebagian besar diimplementasikan murni oleh CSS.  Sejauh yang saya mengerti, untuk skrip Stage2 + tidak diperlukan.  Bagaimanapun, saya tidak menemukan kebutuhan mereka.  Perbaiki saya jika saya melewatkan sesuatu di sana. </p><br><h2 id="6-postcss-animation">  No. 6.  Postcss-animasi </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/zhouwenbin/postcss-animation</a> </p><br><p>  Saya sering mendengar dari orang yang berbeda (kebanyakan backend yang tidak terlalu kuat dalam CSS) bahwa mereka ingin menggunakan animasi terpisah dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">animate.css</a> , tetapi menganggap itu ide yang buruk untuk menghubungkan seluruh perpustakaan.  Cukup logis.  Tetapi sebagai hasilnya, mereka menghabiskan banyak waktu untuk mencoba mengulangi animasi ini sendiri. </p><br><p><img src="https://habrastorage.org/webt/hy/tw/wp/hytwwpkrfzjzsktmomybo51bea0.jpeg"></p><br><p>  Plugin postcss-animation sangat mempercepat proses ini.  Kami hanya menulis nama animasi, misalnya: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-name</span></span>: bounce; }</code> </pre> <br><p>  Dan dia menarik implementasinya dari animate.css dan memasukkannya ke dalam kode. </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-name</span></span>: bounce; } @<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> bounce { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span>, 20%, 53%, 80%, <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.215, 0.610, 0.355, 1.000); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0,0,0); } 40%, 43% { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.755, 0.050, 0.855, 0.060); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0, -30px, 0); } 70% { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.755, 0.050, 0.855, 0.060); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0, -15px, 0); } 90% { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0,-4px,0); } }</code> </pre> <br><h2 id="7-list-selectors">  Nomor 7  Penyeleksi daftar </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/davidtheclark/list-selectors</a> </p><br><p>  Ketika Anda memiliki beberapa huruf dan banyak gaya, pertanyaan muncul dari tinjauan kode, bahwa akan menyenangkan untuk kadang-kadang melihat dengan mata Anda gambaran besar dengan semua penyeleksi yang kita miliki.  Ketahui ID mana yang digunakan, apakah ada pemilih tag, atau seberapa baik metodologi yang diterima diikuti.  Ini sangat penting ketika Anda memeriksa kode pemula, yang dapat menulis hal-hal aneh yang secara resmi akan berfungsi, tetapi sebenarnya bertentangan dengan perjanjian yang diterima (jauh dari mana-mana perjanjian ini telah diperbaiki dengan baik dan ada peluang untuk mengotomatisasi hal-hal seperti itu).  Gulir ke berbagai lembar gaya Anda sendiri untuk memeriksa kecukupan pemilih untuk waktu yang lama.  Kami membutuhkan cara untuk mengisolasi mereka dan menunjukkannya secara terpisah.  Daftar-pemilih hanya menyelesaikan masalah ini. </p><br><p>  Sama seperti doiuse, plugin ini memungkinkan Anda untuk menggunakan fungsinya untuk menyiapkan informasi untuk ditampilkan.  Anda hanya dapat menampilkan apa yang menarik bagi Anda, atau cat semuanya dengan warna berbeda.  Sebagai contoh: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'list-selectors'</span></span>).plugin(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">list</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inspect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>).inspect; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'SELECTORS:'</span></span>.blue); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(inspect(list.selectors, { <span class="hljs-attr"><span class="hljs-attr">maxArrayLength</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }).blue); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'IDS:'</span></span>.red); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(inspect(list.simpleSelectors.ids, { <span class="hljs-attr"><span class="hljs-attr">maxArrayLength</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }).red); })</code> </pre> <br><p>  Contoh ini menghasilkan daftar pemilih yang sangat panjang: </p><br><pre> <code class="plaintext hljs">SELECTORS: [ '.mui-progress-bar', '.mui-progress-bar &gt; .indicator', '.mui-progress-bar &gt; .value', '.mui-progress-bar.-radial', '.mui-progress-bar.-radial &gt; .indicator', '.mui-progress-bar.-radial &gt; .indicator &gt; .background', '.mui-progress-bar.-radial &gt; .indicator &gt; .progress', '.mui-progress-bar.-radial &gt; .value', . . .</code> </pre> <br><h2 id="8-immutable-css">  Nomor 8  Immutable-CSS </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/johno/immutable-css</a> </p><br><p>  Hal lain yang harus diperhatikan adalah mengganggu gaya dari perpustakaan pihak ketiga.  Jika kita menghubungkan semacam perpustakaan, dan kemudian kita mulai menulis gaya kita sendiri untuk penyeleksi dari sana, maka pada akhirnya kita mendapatkan kode yang membingungkan di mana kita tidak bisa mengetahui dari mana asalnya.  Ini dapat menyebabkan bug acak, yang kemudian memakan waktu terlalu lama.  Semakin sering kita mendefinisikan ulang sesuatu, semakin sulit untuk akhirnya memahami apa yang terjadi, walaupun masalah itu sendiri yang perlu diselesaikan bisa sangat sederhana.  Dalam situasi ini, alat yang disebut immutable-css mungkin berguna. </p><br><p>  Secara umum, prinsip kerjanya sederhana: ia mengambil file dengan gaya, jika menemukan kecocokan pada penyeleksi, itu mulai menjadi marah: </p><br><pre> <code class="plaintext hljs">! .button was mutated 2 times [line 93, col 1]: /css/basscss.css [line 3, col 1]: /css/custom.css [immutable-css] ! .left was mutated 2 times [line 291, col 1]: /css/basscss.css [line 4, col 1]: /css/custom.css [immutable-css]</code> </pre> <br><p>  Satu-satunya masalah dengan alat ini adalah tidak mendukung sintaksis non-CSS.  Jadi jika preprosesor digunakan dalam proyek, maka file yang sudah dirakit harus dibandingkan.  Tetapi secara umum, jika tugasnya hanya untuk memastikan bahwa tidak ada yang tanpa sengaja menulis ulang gaya dari perpustakaan pihak ketiga, maka ini tidak begitu penting. </p><br><h2 id="9-bye-bye">  No. 9.  Bye-Bye! </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/AoDev/css-byebye</a> </p><br><p>  Saya pikir semua orang akrab dengan situasi ketika kita secara bertahap menambahkan beberapa komponen ke situs yang berfungsi.  Beberapa dari mereka segera pergi untuk produksi, dan beberapa dari mereka duduk untuk waktu yang lama dan menunggu giliran mereka (misalnya, kami berbaikan, kami belum menyelesaikan backend).  Sesuatu dapat berupa eksperimen atau solusi sementara untuk liburan.  Mungkin ada banyak situasi, tetapi mereka disatukan oleh fakta bahwa kita memiliki banyak komponen, dan hanya sebagian kecil dari mereka yang digunakan di situs pertempuran.  Akan menyenangkan untuk menghapus semua yang tidak digunakan dari perakitan saat ini.  Ini dapat secara signifikan mengurangi ukurannya, serta mengurangi sakit kepala di masa depan, ketika akan perlu untuk melakukan desain ulang misalnya, dan pertanyaannya adalah, apa dari semua ini yang benar-benar perlu ditulis ulang sekarang, dan apa yang tidak. </p><br><p><img src="https://habrastorage.org/webt/l5/rl/e5/l5rle5k5yldudgr5rvtz7hotjom.gif"></p><br><p>  Ada berbagai pendekatan untuk masalah ini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Uncss</a> segera muncul di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">benak saya</a> .  Alat ini secara otomatis mendeteksi gaya mana yang digunakan pada halaman dan menghapus yang tidak perlu.  Namun dalam praktiknya, ini hampir selalu mengarah pada fakta bahwa tidak ada yang tahu apa yang sebenarnya digunakan dan apa yang tidak.  Saya juga ragu sepanjang waktu apakah alat ini telah menghapus sesuatu yang berlebihan.  Tapi ini mungkin paranoia saya.  Meskipun ... </p><br><p>  Bye-bye adalah alat yang lebih sederhana yang kami sendiri masukkan daftar pemilih untuk dihapus dari CSS.  Dan Anda dapat menggunakan ekspresi reguler.  Jika Anda menggunakan BEM atau hal lain seperti itu, maka dengan satu reguler sederhana Anda dapat menghapus blok dengan segala sesuatu yang berkaitan dengannya.  Sampai jumpa! </p><br><p>  Pendekatan ini ternyata cukup nyaman.  Segera dihapus gaya mana yang belum digunakan atau telah dihapus karena tidak perlu, sementara semua sumber ada di tempat, semua pengaturan dalam satu file, tidak ada yang hilang, itu tidak menyebabkan kesulitan untuk membuat beberapa rakitan yang berbeda, dan yang terpenting, solusinya sederhana dan dapat diprediksi. </p><br><h2 id="10-postcss-trolling">  No. 10.  Postcss-trolling </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/juanfran/postcss-trolling</a> </p><br><p>  Semua alat sebelumnya dapat sedikit meningkatkan produktivitas desainer tata letak Anda, tetapi yang ini memberikan hasil yang sangat fenomenal.  Saya sangat merekomendasikannya. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  PostCSS adalah bantuan yang baik untuk perancang tata letak.  Jika mereka tidak disalahgunakan, tentu saja.  Untuk banyak masalah yang memakan waktu, ada solusi siap pakai dalam bentuk plug-in, dan meskipun mereka sering tidak berkembang dan tampaknya ditinggalkan, ini tidak mengganggu penggunaannya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457340/">https://habr.com/ru/post/id457340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457330/index.html">Bagaimana cara cepat memeriksa peringatan menarik yang diberikan oleh alat analisa PVS-Studio untuk kode C dan C ++?</a></li>
<li><a href="../id457332/index.html">Bagaimana cara cepat melihat peringatan menarik yang dihasilkan oleh alat analisa PVS-Studio untuk kode C dan C ++?</a></li>
<li><a href="../id457334/index.html">TacacsGUI, Manajer Konfigurasi</a></li>
<li><a href="../id457336/index.html">Konsekuensi dari pencabutan gigi bungsu sebelum waktunya</a></li>
<li><a href="../id457338/index.html">Blitz dengan Ilya Krasinsky: bagaimana cara menembak hipotesis buruk, mengapa mengabaikan suatu produk dan bagaimana tumbuh untuk tindakan minimum?</a></li>
<li><a href="../id457342/index.html">Tanda dari Atas: Bagaimana Kami Menyelamatkan Kartografer dari Pekerjaan yang Tidak Perlu dan Mata Merah</a></li>
<li><a href="../id457348/index.html">Penempatan di PythonAnywhere dari GitHub</a></li>
<li><a href="../id457350/index.html">Mengapa osiloskop memerlukan dukungan kriptografi?</a></li>
<li><a href="../id457352/index.html">Kesimpulan informasi pada tampilan pembeli</a></li>
<li><a href="../id457354/index.html">Kebingungan Data untuk Tes Kinerja</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>