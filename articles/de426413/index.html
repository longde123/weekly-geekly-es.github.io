<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèº üë®üèº‚Äçüöí ü§∑ FESTE Prinzipien, √ºber die jeder Entwickler Bescheid wissen sollte üë∞üèø ‚ö±Ô∏è ‚òéÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die objektorientierte Programmierung hat neue Ans√§tze f√ºr das Anwendungsdesign in die Softwareentwicklung gebracht. Insbesondere erm√∂glichte OOP Progr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FESTE Prinzipien, √ºber die jeder Entwickler Bescheid wissen sollte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426413/">  Die objektorientierte Programmierung hat neue Ans√§tze f√ºr das Anwendungsdesign in die Softwareentwicklung gebracht.  Insbesondere erm√∂glichte OOP Programmierern, Entit√§ten, die durch ein gemeinsames Ziel oder eine gemeinsame Funktionalit√§t vereint sind, in separaten Klassen zu kombinieren, um unabh√§ngige Probleme zu l√∂sen und unabh√§ngig von anderen Teilen der Anwendung.  Die Verwendung von OOP allein bedeutet jedoch nicht, dass der Entwickler vor der M√∂glichkeit gesch√ºtzt ist, obskuren, verwirrenden Code zu erstellen, der schwer zu warten ist.  Um allen zu helfen, die hochwertige OOP-Anwendungen entwickeln m√∂chten, hat Robert Martin f√ºnf Prinzipien der objektorientierten Programmierung und des objektorientierten Designs entwickelt, √ºber die mit Hilfe von Michael Fazers das Akronym SOLID verwendet wird. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/46/xx/ol/46xxolpv46av7bknmyywp3ii9vs.jpeg"></a> <br><br>  Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, ist den Grundlagen von SOLID gewidmet und richtet sich an Anf√§nger. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Was ist FEST?</font> </h2><br>  So steht das Akronym SOLID f√ºr: <br><br><ul><li>  S: Prinzip der Einzelverantwortung. </li><li>  O: Offen-Geschlossen-Prinzip. </li><li>  L: Liskov-Substitutionsprinzip (Barbara-Liskov-Substitutionsprinzip). </li><li>  I: Prinzip der Schnittstellentrennung. </li><li>  D: Prinzip der Abh√§ngigkeitsinversion. </li></ul><br>  Nun werden wir diese Prinzipien in schematischen Beispielen betrachten.  Beachten Sie, dass der Hauptzweck der Beispiele darin besteht, dem Leser zu helfen, die Prinzipien von SOLID zu verstehen, zu lernen, wie man sie anwendet und wie man sie beim Entwerfen von Anwendungen befolgt.  Der Autor des Materials war nicht bestrebt, einen Arbeitscode zu erreichen, der in realen Projekten verwendet werden kann. <br><br><h2>  <font color="#3AC1EF">Grundsatz der alleinigen Verantwortung</font> </h2><br>  <i><font color="#999999">‚ÄûEin Auftrag.</font></i>  <i><font color="#999999">Nur eine Sache. "</font></i>  <i><font color="#999999">- Loki erz√§hlt Skurge im Film Thor: Ragnarok.</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">Jede Klasse sollte nur ein Problem l√∂sen.</font></i> <br><br>  Eine Klasse sollte nur f√ºr eine Sache verantwortlich sein.  Wenn eine Klasse f√ºr die L√∂sung mehrerer Probleme verantwortlich ist, erweisen sich ihre Subsysteme, die die L√∂sung dieser Probleme implementieren, als miteinander verbunden.  √Ñnderungen in einem solchen Subsystem f√ºhren zu √Ñnderungen in einem anderen. <br><br>  Beachten Sie, dass dieses Prinzip nicht nur f√ºr Klassen gilt, sondern auch f√ºr Softwarekomponenten im weiteren Sinne. <br><br>  Betrachten Sie beispielsweise diesen Code: <br><br><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {    constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">){ }    getAnimalName() { }    saveAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { } }</span></span></code> </pre> <br>  Die hier vorgestellte Tierklasse beschreibt eine Art Tier.  Diese Klasse verst√∂√üt gegen das Prinzip der alleinigen Verantwortung.  Wie genau wird dieses Prinzip verletzt? <br><br>  Nach dem Prinzip der alleinigen Verantwortung darf eine Klasse nur eine Aufgabe l√∂sen.  Er l√∂st die beiden <code>saveAnimal</code> indem er mit dem Data Warehouse in der <code>saveAnimal</code> Methode arbeitet und die Eigenschaften des Objekts im Konstruktor und in der <code>getAnimalName</code> Methode <code>getAnimalName</code> . <br><br>  Wie kann eine solche Klassenstruktur zu Problemen f√ºhren? <br><br>  Wenn sich das Verfahren f√ºr die Arbeit mit dem von der Anwendung verwendeten Data Warehouse √§ndert, m√ºssen Sie √Ñnderungen an allen Klassen vornehmen, die mit dem Warehouse arbeiten.  Diese Architektur ist nicht flexibel, √Ñnderungen in einigen Subsystemen wirken sich auf andere aus, was dem Dominoeffekt √§hnelt. <br><br>  Um den obigen Code mit dem Prinzip der alleinigen Verantwortung in Einklang zu bringen, erstellen wir eine weitere Klasse, deren einzige Aufgabe darin besteht, mit dem Repository zu arbeiten, insbesondere Objekte der <code>Animal</code> Klasse darin zu speichern: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {   constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">){ }   getAnimalName() { } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AnimalDB</span></span></span><span class="hljs-class"> {   getAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { }   saveAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { } }</span></span></code> </pre> <br>  Dazu sagt Steve Fenton: ‚ÄûBeim Entwerfen von Klassen sollten wir uns bem√ºhen, verwandte Komponenten zu integrieren, dh solche, bei denen √Ñnderungen aus den gleichen Gr√ºnden auftreten.  Wir sollten versuchen, die Komponenten zu trennen, √Ñnderungen, die verschiedene Gr√ºnde haben. " <br><br>  Die korrekte Anwendung des Grundsatzes der alleinigen Verantwortung f√ºhrt zu einem hohen Ma√ü an Konnektivit√§t der Elemente innerhalb des Moduls, dh zu der Tatsache, dass die darin gel√∂sten Aufgaben gut seinem Hauptziel entsprechen. <br><br><h2>  <font color="#3AC1EF">Open-Closed-Prinzip</font> </h2><br>  <i><font color="#999999">Software-Entit√§ten (Klassen, Module, Funktionen) sollten zur Erweiterung ge√∂ffnet sein, jedoch nicht zur √Ñnderung.</font></i> <br><br>  Wir arbeiten weiter an der <code>Animal</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name: string){ }   getAnimalName() { } }</code> </pre> <br>  Wir wollen die Liste der Tiere sortieren, von denen jedes durch ein Objekt der <code>Animal</code> , und herausfinden, welche Ger√§usche sie machen.  Stellen Sie sich vor, wir l√∂sen dieses Problem mit der <code>AnimalSounds</code> Funktion: <br><br><pre> <code class="hljs powershell">//... const animals: Array&lt;Animal&gt; = [   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'lion'</span></span>),   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'mouse'</span></span>) ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'lion'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'mouse'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;   } } AnimalSound(animals);</code> </pre> <br>  Das Hauptproblem bei dieser Architektur besteht darin, dass die Funktion bestimmt, welche Art von Ger√§usch ein Tier bei der Analyse bestimmter Objekte macht.  Die <code>AnimalSound</code> Funktion <code>AnimalSound</code> nicht dem Prinzip der Offenheit, da wir beispielsweise neue Tierarten √§ndern m√ºssen, um die von ihnen erzeugten Ger√§usche zu erkennen. <br><br>  F√ºgen Sie dem Array ein neues Element hinzu: <br><br><pre> <code class="hljs powershell">//... const animals: Array&lt;Animal&gt; = [   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'lion'</span></span>),   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'mouse'</span></span>),   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'snake'</span></span>) ] //...</code> </pre> <br>  Danach m√ºssen wir den Code der <code>AnimalSound</code> Funktion <code>AnimalSound</code> : <br><br><pre> <code class="hljs powershell">//... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'lion'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'mouse'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'snake'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hiss'</span></span>;   } } AnimalSound(animals);</code> </pre> <br>  Wie Sie sehen, m√ºssen Sie beim Hinzuf√ºgen eines neuen Tieres zum Array den Funktionscode erg√§nzen.  Ein Beispiel ist sehr einfach, aber wenn eine √§hnliche Architektur in einem realen Projekt verwendet wird, muss die Funktion st√§ndig erweitert werden und neue <code>if</code> Ausdr√ºcke hinzugef√ºgt werden. <br><br>  Wie kann die <code>AnimalSound</code> Funktion mit dem Prinzip von offen-geschlossen in Einklang gebracht werden?  Zum Beispiel so: <br><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {       makeSound();       //... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {   makeSound() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;   } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Squirrel</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {   makeSound() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;   } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Snake</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {   makeSound() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hiss'</span></span>;   } } //... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       a[<span class="hljs-type"><span class="hljs-type">i</span></span>].makeSound();   } } AnimalSound(animals);</code> </pre> <br>  M√∂glicherweise stellen Sie fest, dass die <code>Animal</code> Klasse jetzt √ºber eine virtuelle <code>makeSound</code> Methode verf√ºgt.  Bei diesem Ansatz ist es erforderlich, dass Klassen zur Beschreibung bestimmter Tiere die <code>Animal</code> erweitern und diese Methode implementieren. <br><br>  Infolgedessen verf√ºgt jede Klasse, die ein Tier beschreibt, √ºber eine eigene <code>makeSound</code> Methode. Wenn Sie ein Array mit Tieren in der <code>AnimalSound</code> Funktion <code>AnimalSound</code> , reicht <code>AnimalSound</code> aus, diese Methode f√ºr jedes Element des Arrays aufzurufen. <br><br>  Wenn Sie dem Array jetzt ein Objekt hinzuf√ºgen, das das neue Tier beschreibt, m√ºssen Sie die <code>AnimalSound</code> Funktion nicht √§ndern.  Wir haben es mit dem Prinzip der Offenheit und N√§he in Einklang gebracht. <br><br>  Betrachten Sie ein anderes Beispiel. <br><br>  Angenommen, wir haben ein Gesch√§ft.  Wir gew√§hren Kunden einen Rabatt von 20% in dieser Klasse: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Discount</span></span></span><span class="hljs-class"> </span></span>{   giveDiscount() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.2</span></span>   } }</code> </pre> <br>  Nun wurde beschlossen, die Kunden in zwei Gruppen aufzuteilen.  Lieblingskunden erhalten einen Rabatt von 20% und VIP-Kunden (VIP) den doppelten Rabatt, <code>fav</code> 40%.  Um diese Logik zu implementieren, wurde beschlossen, die Klasse wie folgt zu √§ndern: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Discount</span></span></span><span class="hljs-class"> </span></span>{   giveDiscount() {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.customer == <span class="hljs-string"><span class="hljs-string">'fav'</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.2</span></span>;       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.customer == <span class="hljs-string"><span class="hljs-string">'vip'</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.4</span></span>;       }   } }</code> </pre> <br>  Dieser Ansatz verst√∂√üt gegen das Prinzip der Offenheit-N√§he.  Wie Sie sehen k√∂nnen, m√ºssen wir der Klasse einen neuen Code hinzuf√ºgen, wenn wir einer bestimmten Kundengruppe einen Sonderrabatt gew√§hren m√ºssen. <br><br>  Um diesen Code gem√§√ü dem Prinzip der Offenheit und N√§he zu verarbeiten, f√ºgen wir dem Projekt eine neue Klasse hinzu, die die <code>Discount</code> Klasse erweitert.  In dieser neuen Klasse implementieren wir einen neuen Mechanismus: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VIPDiscount</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Discount {   getDiscount</span></span></span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getDiscount() * <span class="hljs-number"><span class="hljs-number">2</span></span>;   } }</code> </pre> <br>  Wenn Sie ‚ÄûSuper-VIP‚Äú -Kunden einen Rabatt von 80% gew√§hren, sollte dies folgenderma√üen aussehen: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperVIPDiscount</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIPDiscount {   getDiscount</span></span></span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getDiscount() * <span class="hljs-number"><span class="hljs-number">2</span></span>;   } }</code> </pre> <br>  Wie Sie sehen k√∂nnen, wird hier die Erm√§chtigung von Klassen verwendet, nicht deren √Ñnderung. <br><br><h2>  <font color="#3AC1EF">Das Substitutionsprinzip von Barbara Liskov</font> </h2><br>  <i><font color="#999999">Es ist notwendig, dass Unterklassen als Ersatz f√ºr ihre Oberklassen dienen.</font></i> <br><br>  Der Zweck dieses Prinzips besteht darin, dass Vererbungsklassen anstelle der √ºbergeordneten Klassen verwendet werden k√∂nnen, aus denen sie gebildet werden, ohne das Programm zu st√∂ren.  Wenn sich herausstellt, dass der Klassentyp im Code √ºberpr√ºft wird, wird das Substitutionsprinzip verletzt. <br><br>  Betrachten Sie die Anwendung dieses Prinzips und kehren Sie zum Beispiel mit der <code>Animal</code> .  Wir werden eine Funktion schreiben, die Informationen √ºber die Anzahl der Gliedma√üen eines Tieres zur√ºckgibt. <br><br><pre> <code class="hljs powershell">//... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Lion)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LionLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Mouse)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MouseLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Snake)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SnakeLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);   } } AnimalLegCount(animals);</code> </pre> <br>  Die Funktion verst√∂√üt gegen das Substitutionsprinzip (und das Prinzip der Offenheitsschlie√üung).  Dieser Code sollte die Typen aller von ihm verarbeiteten Objekte kennen und je nach Typ die entsprechende Funktion verwenden, um die Gliedma√üen eines bestimmten Tieres zu berechnen.  Daher muss beim Erstellen eines neuen Tiertyps die Funktion neu geschrieben werden: <br><br><pre> <code class="hljs powershell">//... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pigeon</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {      } const animals[]: Array&lt;Animal&gt; = [   //<span class="hljs-type"><span class="hljs-type">...</span></span>,   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Pigeon</span></span>(); ] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Lion)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LionLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Mouse)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MouseLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Snake)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SnakeLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Pigeon)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PigeonLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);   } } AnimalLegCount(animals);</code> </pre> <br>  Damit diese Funktion nicht gegen das Substitutionsprinzip verst√∂√üt, transformieren wir sie anhand der von Steve Fenton formulierten Anforderungen.  Sie bestehen in der Tatsache, dass Methoden, die Werte mit dem Typ einer Oberklasse akzeptieren oder zur√ºckgeben (in unserem Fall <code>Animal</code> ), auch Werte akzeptieren und zur√ºckgeben sollten, deren Typen ihre Unterklassen sind ( <code>Pigeon</code> ). <br><br>  Mit diesen √úberlegungen k√∂nnen wir die <code>AnimalLegCount</code> Funktion wiederholen: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt;= a.length; i++)</span></span></span><span class="hljs-function"> {       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[i]</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;   } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animals)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Diese Funktion interessiert sich jetzt nicht mehr f√ºr die Arten von Objekten, die an sie √ºbergeben werden.  Sie ruft einfach ihre <code>LegCount</code> Methoden auf.  Alles, was sie √ºber Typen wei√ü, ist, dass die Objekte, die sie verarbeitet, zur <code>Animal</code> Klasse oder ihren Unterklassen geh√∂ren m√ºssen. <br><br>  Die <code>LegCount</code> Methode sollte jetzt in der <code>Animal</code> Klasse <code>LegCount</code> werden: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//...   LegCount(); }</span></span></code> </pre> <br>  Und seine Unterklassen m√ºssen diese Methode implementieren: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class">{   //...   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LegCount</span></span></span><span class="hljs-class">() {       //...   } } //...</span></span></code> </pre> <br>  Wenn Sie beispielsweise auf die <code>LegCount</code> Methode f√ºr eine Instanz der <code>Lion</code> Klasse zugreifen, wird die in dieser Klasse implementierte Methode aufgerufen und genau das zur√ºckgegeben, was vom Aufruf einer solchen Methode erwartet werden kann. <br><br>  Jetzt muss die <code>AnimalLegCount</code> Funktion <code>AnimalLegCount</code> mehr wissen, welches Objekt einer bestimmten Unterklasse der <code>Animal</code> Klasse sie verarbeitet, um Informationen √ºber die Anzahl der Gliedma√üen in dem von diesem Objekt dargestellten Tier zu erhalten.  Die Funktion ruft einfach die <code>LegCount</code> Methode der <code>Animal</code> Klasse auf, da Unterklassen dieser Klasse diese Methode implementieren m√ºssen, damit sie stattdessen verwendet werden k√∂nnen, ohne die korrekte Operation des Programms zu verletzen. <br><br><h2>  <font color="#3AC1EF">Prinzip der Schnittstellentrennung</font> </h2><br>  <i><font color="#999999">Erstellen Sie hochspezialisierte Schnittstellen f√ºr einen bestimmten Client.</font></i>  <i><font color="#999999">Clients sollten nicht auf Schnittstellen angewiesen sein, die sie nicht verwenden.</font></i> <br><br>  Dieses Prinzip zielt darauf ab, die mit der Implementierung gro√üer Schnittstellen verbundenen M√§ngel zu beheben. <br><br>  Betrachten Sie die <code>Shape</code> Oberfl√§che: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Shape</span></span> {   drawCircle();   drawSquare();   drawRectangle(); }</code> </pre> <br>  Es werden Methoden zum Zeichnen von Kreisen ( <code>drawCircle</code> ), Quadraten ( <code>drawSquare</code> ) und Rechtecken ( <code>drawRectangle</code> ) beschrieben.  Daher m√ºssen Klassen, die diese Schnittstelle implementieren und einzelne geometrische Formen darstellen, wie z. B. ein Kreis, ein Quadrat und ein Rechteck, eine Implementierung all dieser Methoden enthalten.  Es sieht so aus: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Circle</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Square</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rectangle</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } }</span></span></code> </pre> <br>  Es stellte sich heraus, dass seltsamer Code vorhanden war.  Beispielsweise implementiert die <code>Rectangle</code> Klasse, die ein Rechteck darstellt, Methoden ( <code>drawCircle</code> und <code>drawSquare</code> ), die √ºberhaupt nicht ben√∂tigt werden.  Das gleiche gilt f√ºr die Analyse des Codes von zwei anderen Klassen. <br><br>  Angenommen, wir beschlie√üen, der <code>drawTriangle</code> eine andere Methode hinzuzuf√ºgen, <code>drawTriangle</code> , mit der Dreiecke <code>drawTriangle</code> werden sollen: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Shape</span></span> {   drawCircle();   drawSquare();   drawRectangle();   drawTriangle(); }</code> </pre> <br>  Dies f√ºhrt dazu, dass Klassen, die bestimmte geometrische Formen darstellen, auch die <code>drawTriangle</code> Methode implementieren <code>drawTriangle</code> .  Andernfalls tritt ein Fehler auf. <br><br>  Wie Sie sehen k√∂nnen, ist es mit diesem Ansatz unm√∂glich, eine Klasse zu erstellen, die eine Methode zur Ausgabe eines Kreises implementiert, jedoch keine Methoden zum Ableiten eines Quadrats, Rechtecks ‚Äã‚Äãund Dreiecks.  Solche Verfahren k√∂nnen so implementiert werden, dass bei ihrer Ausgabe ein Fehler ausgegeben wird, der anzeigt, dass eine solche Operation nicht ausgef√ºhrt werden kann. <br><br>  Das Prinzip der Schnittstellentrennung warnt uns davor, Schnittstellen wie <code>Shape</code> aus unserem Beispiel zu erstellen.  Clients (wir haben die Klassen <code>Circle</code> , <code>Square</code> und <code>Rectangle</code> ) sollten keine Methoden implementieren, die sie nicht verwenden m√ºssen.  Dar√ºber hinaus gibt dieses Prinzip an, dass die Schnittstelle nur eine Aufgabe l√∂sen sollte (dies √§hnelt dem Prinzip der alleinigen Verantwortung), daher sollte alles, was √ºber den Umfang dieser Aufgabe hinausgeht, auf eine andere Schnittstelle oder Schnittstellen √ºbertragen werden. <br><br>  In unserem Fall l√∂st die <code>Shape</code> Schnittstelle Probleme, f√ºr deren L√∂sung separate Schnittstellen erstellt werden m√ºssen.  Nach dieser Idee √ºberarbeiten wir den Code, indem wir separate Schnittstellen zur L√∂sung verschiedener hochspezialisierter Aufgaben erstellen: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> </span></span>{   draw(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICircle</span></span></span><span class="hljs-class"> </span></span>{   drawCircle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISquare</span></span></span><span class="hljs-class"> </span></span>{   drawSquare(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IRectangle</span></span></span><span class="hljs-class"> </span></span>{   drawRectangle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ITriangle</span></span></span><span class="hljs-class"> </span></span>{   drawTriangle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Circle</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICircle</span></span></span><span class="hljs-class"> </span></span>{   drawCircle() {       <span class="hljs-comment"><span class="hljs-comment">//...   } } class Square implements ISquare {   drawSquare() {       //...   } } class Rectangle implements IRectangle {   drawRectangle() {       //...   } } class Triangle implements ITriangle {   drawTriangle() {       //...   } } class CustomShape implements Shape {  draw(){     //...  } }</span></span></code> </pre> <br>  Jetzt wird die <code>ICircle</code> Oberfl√§che nur zum Zeichnen von Kreisen sowie von anderen speziellen Schnittstellen zum Zeichnen anderer Formen verwendet.  Die <code>Shape</code> Schnittstelle kann als universelle Schnittstelle verwendet werden. <br><br><h2>  <font color="#3AC1EF">Prinzip der Abh√§ngigkeitsinversion</font> </h2><br>  <i><font color="#999999">Das Objekt der Abh√§ngigkeit sollte eine Abstraktion sein, nicht etwas Spezifisches.</font></i> <br><br><ol><li>  Module der oberen Ebene sollten nicht von Modulen der unteren Ebene abh√§ngen.  Beide Modultypen sollten von Abstraktionen abh√§ngen. </li><li>  Abstraktionen sollten nicht von den Details abh√§ngen.  Details sollten von Abstraktionen abh√§ngen. </li></ol><br>  W√§hrend der Softwareentwicklung gibt es einen Moment, in dem die Funktionalit√§t der Anwendung nicht mehr in dasselbe Modul passt.  In diesem Fall m√ºssen wir das Problem der Modulabh√§ngigkeiten l√∂sen.  Infolgedessen kann sich beispielsweise herausstellen, dass die Komponenten auf hoher Ebene von den Komponenten auf niedriger Ebene abh√§ngen. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpRequestService</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http</span></span></span><span class="hljs-class"> </span></span>{   constructor(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> xmlhttpService: <span class="hljs-type"><span class="hljs-type">XMLHttpService</span></span>) { }   get(url: string , options: any) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xmlhttpService.request(url,<span class="hljs-symbol"><span class="hljs-symbol">'GE</span></span>T');   }   post() {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xmlhttpService.request(url,<span class="hljs-symbol"><span class="hljs-symbol">'POS</span></span>T');   }   <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Hier ist die <code>Http</code> Klasse eine <code>XMLHttpService</code> Komponente, und der <code>XMLHttpService</code> ist eine <code>XMLHttpService</code> Komponente.  Eine solche Architektur verst√∂√üt gegen Klausel A des Abh√§ngigkeitsinversionsprinzips: ‚ÄûModule h√∂herer Ebenen sollten nicht von Modulen niedrigerer Ebenen abh√§ngen.  Beide Modultypen sollten von Abstraktionen abh√§ngen. ‚Äú <br><br>  Die <code>XMLHttpService</code> Klasse muss von der <code>XMLHttpService</code> Klasse abh√§ngen.  Wenn wir den von der <code>Http</code> Klasse f√ºr die Interaktion mit dem Netzwerk verwendeten Mechanismus √§ndern m√∂chten, beispielsweise einen Node.js-Dienst oder beispielsweise einen zu Testzwecken verwendeten Stub-Dienst, m√ºssen wir alle Instanzen der <code>Http</code> Klasse bearbeiten, indem wir den entsprechenden Code √§ndern.  Dies verst√∂√üt gegen das Prinzip der Offenheit-N√§he. <br><br>  Die <code>Http</code> Klasse sollte nicht wissen, was genau zum Herstellen einer Netzwerkverbindung verwendet wird.  Daher erstellen wir die <code>Connection</code> : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Connection</span></span> {   request(url: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, opts:any); }</code> </pre> <br>  Die <code>Connection</code> enth√§lt eine Beschreibung der <code>request</code> , und wir √ºbergeben das Argument f√ºr den <code>Connection</code> an die <code>Http</code> Klasse: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> httpConnection: Connection) { }   <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url: string , options: any) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpConnection.request(url,<span class="hljs-string"><span class="hljs-string">'GET'</span></span>);   }   post() {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpConnection.request(url,<span class="hljs-string"><span class="hljs-string">'POST'</span></span>);   }   <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Unabh√§ngig davon, was zum Organisieren der Interaktion mit dem Netzwerk verwendet wird, kann die <code>Http</code> Klasse nun das verwenden, was an sie √ºbergeben wurde, ohne sich Gedanken dar√ºber machen zu m√ºssen, was sich hinter der <code>Connection</code> verbirgt. <br><br>  Wir schreiben die <code>XMLHttpService</code> Klasse neu, damit sie diese Schnittstelle implementiert: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest();   <span class="hljs-comment"><span class="hljs-comment">//...   request(url: string, opts:any) {       xhr.open();       xhr.send();   } }</span></span></code> </pre> <br>  Infolgedessen k√∂nnen wir viele Klassen erstellen, die die <code>Connection</code> implementieren und f√ºr die Verwendung in der <code>Http</code> Klasse zum Organisieren des Datenaustauschs √ºber das Netzwerk geeignet sind: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class"> </span></span>{   request(url: string, opts:any) {       <span class="hljs-comment"><span class="hljs-comment">//...   } } class MockHttpService implements Connection {   request(url: string, opts:any) {       //...   } }</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, h√§ngen die Module auf hoher und niedriger Ebene von Abstraktionen ab.  Die <code>Http</code> Klasse (High-Level-Modul) h√§ngt von der <code>Connection</code> (Abstraktion) ab.  Die <code>MockHttpService</code> <code>XMLHttpService</code> , <code>NodeHttpService</code> und <code>MockHttpService</code> (Module auf niedriger Ebene) h√§ngen auch von der <code>Connection</code> . <br><br>  Dar√ºber hinaus ist anzumerken, dass wir nach dem Prinzip der Abh√§ngigkeitsinversion das Prinzip der Substitution Barbara Liskov beobachten.  Es stellt sich n√§mlich heraus, dass die Typen <code>XMLHttpService</code> , <code>NodeHttpService</code> und <code>MockHttpService</code> als Ersatz f√ºr den <code>NodeHttpService</code> <code>MockHttpService</code> dienen k√∂nnen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Hier haben wir uns f√ºnf SOLID-Prinzipien angesehen, die jeder OOP-Entwickler einhalten sollte.  Zun√§chst mag dies nicht einfach sein, aber wenn Sie danach streben und die W√ºnsche der Praxis bekr√§ftigen, werden diese Prinzipien zu einem nat√ºrlichen Bestandteil des Workflows, was sich sehr positiv auf die Qualit√§t der Anwendungen auswirkt und deren Unterst√ºtzung erheblich erleichtert. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie in Ihren Projekten SOLID-Prinzipien? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426413/">https://habr.com/ru/post/de426413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426401/index.html">Amazon wird seiner KI beibringen, menschliche Emotionen zu definieren</a></li>
<li><a href="../de426405/index.html">Hacker im Rahmen der Gesetze der Russischen F√∂deration</a></li>
<li><a href="../de426407/index.html">Wie man die Reise zur Konferenz so nutzlos wie m√∂glich macht</a></li>
<li><a href="../de426409/index.html">Der Hacker Alexei, der MikroTik-Router ohne Erlaubnis der Eigent√ºmer sch√ºtzt, ist ber√ºhmt geworden</a></li>
<li><a href="../de426411/index.html">Entwickeln von C ++ / CLI-Deskriptorklassen</a></li>
<li><a href="../de426415/index.html">Fintech-Digest: Digitalisierungskontrolle durch die Zentralbank, Gehalt in Kryptow√§hrung, Mir-Karte in Form von Armb√§ndern und Schl√ºsselringen</a></li>
<li><a href="../de426417/index.html">Pavel 2.0: Reptilienberater auf JS, node.js mit Sockets und Telefonie</a></li>
<li><a href="../de426419/index.html">Verbotene √úberlastungs- oder Bridge-Methoden in Java</a></li>
<li><a href="../de426421/index.html">EHCI menschlich auf Russisch</a></li>
<li><a href="../de426423/index.html">mmWave auf Smartphones: Wie Qualcomm das Unm√∂gliche m√∂glich gemacht hat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>