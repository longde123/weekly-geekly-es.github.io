<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏼 ♏️ 💨 动态细节：编译器秘密游戏，内存泄漏，性能差异 🚤 🍯 🤽🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前戏 

 考虑以下代码： 



//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601")); while (true) { dynami...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>动态细节：编译器秘密游戏，内存泄漏，性能差异</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466657/"><h2> 前戏 </h2><br><br> 考虑以下代码： <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601")); while (true) { dynamic com = Activator.CreateInstance(comType); //do some work Marshal.FinalReleaseComObject(com); }</span></span></code> </pre> <br><br>  <i>Marshal.FinalReleaseComObject</i>方法的签名如下： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalReleaseComObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Object o</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><br> 我们创建一个简单的COM对象，做一些工作，然后立即释放它。 看来可能出什么问题了？ 是的，在无限循环内创建对象不是一个好习惯，但是<i>GC</i>将承担所有肮脏的工作。 实际情况略有不同： <br><br><img src="https://habrastorage.org/webt/mt/xo/rx/mtxorxomorvksyskqgtn3b3z7_g.png"><br><br> 要了解内存泄漏的原因，您需要了解<i>动态的</i>工作原理。 在Habré上已经有关于此主题的几篇文章，例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这篇文章</a> ，但是它们没有详细介绍实现的细节，因此我们将进行自己的研究。 <br><br><a name="habracut"></a><br><br> 首先，我们将详细研究<i>动态</i>工作机制，然后将获得的知识简化为一张图片，最后，我们将讨论造成这种泄漏的原因以及如何避免这种泄漏。 在深入研究代码之前，让我们澄清一下源数据：哪些因素导致泄漏？ <br><br><h2> 实验 </h2><br><br> 也许创建许多<i>本机COM</i>对象本身<i>并不是</i>一个好主意？ 让我们检查一下： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601")); while (true) { dynamic com = Activator.CreateInstance(comType); }</span></span></code> </pre> <br><br> 这次一切都很好： <br><br><img src="https://habrastorage.org/webt/l2/x4/01/l2x401f_4vsbrysnx1zctwoyfjk.png"><br><br> 让我们回到代码的原始版本，但是更改对象的类型： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any managed type include managed COM var type = typeof(int); while (true) { dynamic com = Activator.CreateInstance(type); //do some work Marshal.FinalReleaseComObject(com); }</span></span></code> </pre> <br><br> 再一次，不出意外： <br><br><img src="https://habrastorage.org/webt/09/lm/bv/09lmbvpiklt9lo43b1fv9wzhdhu.png"><br><br> 让我们尝试第三个选项： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Simple COM object var comType = Type.GetTypeFromCLSID(new Guid("435356F9-F33F-403D-B475-1E4AB512FF95")); while (true) { dynamic com = Activator.CreateInstance(comType); //do some work Marshal.FinalReleaseComObject((object) com); }</span></span></code> </pre> <br><br> 现在，我们绝对应该得到相同的行为！  ?？ 否:( <br><br><img src="https://habrastorage.org/webt/uu/2p/l1/uu2pl1_xtrmpc4kuuy3mwdh_7la.png"><br><br> 如果您将com声明为<i>对象</i>或使用<i>Managed COM，</i>则情况类似。 总结实验结果： <br><br><ol><li> 本身实例化<i>本机COM</i>对象不会导致泄漏<i>-GC</i>成功处理了清除内存的问题 </li><li> 使用任何<i>托管</i>类时，都不会发生泄漏 </li><li> 当将对象显式转换为<i>对象时</i> ，一切都很好 </li></ol><br><br> 展望未来，第一点我们可以添加一个事实，即单独使用<i>动态</i>对象（调用方法或使用属性）也不会导致泄漏。 结论本身表明：当我们传递包含<i>本机COM</i>作为方法参数的<i>动态</i>对象（不进行“手动”类型转换）时，就会发生内存泄漏。 <br><br><h2> 我们需要更深入 </h2><br><br> 现在该记住这种<i>动态</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的意义了</a> ： <br><br><div class="spoiler">  <b class="spoiler_title">快速参考</b> <div class="spoiler_text"><blockquote>  C＃4.0提供了一种新型的<b>dynamic</b> 。 此类型避免了编译器进行的静态类型检查。 在大多数情况下，它用作<b>对象</b>类型。 在编译时，假定声明为<b>动态</b>的元素支持任何操作。 这意味着您不必考虑对象的来源-COM API，IronPython之类的动态语言，使用反射或其他地方。 而且，如果代码无效，则会在运行时引发错误。 <br><br> 例如，如果以下代码中的<b>exampleMethod1</b>方法仅具有一个参数，则编译器会识别到对<b>ec.exampleMethod1（10，4）</b>方法的第一次调用是无效的，因为它包含两个参数。 这将导致编译错误。 编译器不会检查第二个方法调用<b>dynamic_ec.exampleMethod1（10，4）</b> ，因为<b>dynamic_ec被</b>声明为<b>dynamic</b> 。 不会有编译错误。 但是，该错误不会永远不会被忽略-将在运行时检测到。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { ExampleClass ec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExampleClass(); <span class="hljs-comment"><span class="hljs-comment">//      ,  exampleMethod1    . //ec.exampleMethod1(10, 4); dynamic dynamic_ec = new ExampleClass(); //      ,  //      dynamic_ec.exampleMethod1(10, 4); //        ,  //  ,      dynamic_ec.someMethod("some argument", 7, null); dynamic_ec.nonexistentMethod(); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleClass</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleMethod1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleMethod2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br></blockquote><br></div></div><br><br> 使用<i>动态</i>变量的代码在编译过程中会发生重大变化。 这段代码： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); Marshal.FinalReleaseComObject(com);</code> </pre> <br><br> 变成以下内容： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = Activator.CreateInstance(typeFromClsid); <span class="hljs-comment"><span class="hljs-comment">// ISSUE: reference to a compiler-generated field if (Foo.o__0.p__0 == null) { // ISSUE: reference to a compiler-generated field Foo.o__0.p__0 = CallSite&lt;Action&lt;CallSite, Type, object&gt;&gt;.Create(Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "FinalReleaseComObject", (IEnumerable&lt;Type&gt;) null, typeof (Foo), (IEnumerable&lt;CSharpArgumentInfo&gt;) new CSharpArgumentInfo[2] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null) })); } // ISSUE: reference to a compiler-generated field // ISSUE: reference to a compiler-generated field Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, typeof (Marshal), instance);</span></span></code> </pre> <br><br> 其中<b>o__0</b>是生成的静态类，而<b>p__0</b>是其中的静态字段： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">o__0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CallSite&lt;Action&lt;CallSite, Type, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt; p__0; }</code> </pre> <br><br>  <i>注意：对于每次与<i>dynamic的</i>交互，都会创建一个CallSite字段。</i>  <i>稍后将看到，这对于优化性能是必需的。</i> <br><br> 请注意，这里没有提到<i>动态</i> -我们的对象现在存储在类型为<i>object</i>的变量中。 让我们来看一下生成的代码。 首先，创建一个绑定，该绑定描述了我们正在做什么以及正在做什么： <br><br><pre> <code class="cs hljs">Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, <span class="hljs-string"><span class="hljs-string">"FinalReleaseComObject"</span></span>, (IEnumerable&lt;Type&gt;) <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Foo), (IEnumerable&lt;CSharpArgumentInfo&gt;) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpArgumentInfo[<span class="hljs-number"><span class="hljs-number">2</span></span>] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span>), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span>) })</code> </pre> <br><br> 这是对我们动态操作的描述。 让我提醒您，我们将<i>动态</i>变量传递给<i>FinalReleaseComObject</i>方法。 <br><br><ul><li>  CSharpBinderFlags.ResultDiscarded-将来不再使用方法执行的结果 </li><li>  “ FinalReleaseComObject”-调用方法的名称 </li><li>  typeof（Foo）-操作上下文； 通话类型 </li></ul><br><br>  <b>CSharpArgumentInfo-</b>绑定参数的描述。 在我们的情况下： <br><br><ul><li>  CSharpArgumentInfo.Create（CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType，（字符串）null）-第一个参数的说明-元帅类：它是静态的，绑定时应考虑其类型 </li><li>  CSharpArgumentInfo.Create（CSharpArgumentInfoFlags.None，（string）null）-方法参数的描述，通常没有附加信息。 </li></ul><br><br> 如果不是调用方法的问题，而是例如从<i>动态</i>对象调用属性的问题，那么将只有一个<b>CSharpArgumentInfo</b>描述<i>动态</i>对象本身。 <br><br>  <b>CallSite</b>是动态表达式的包装。 它对我们包含两个重要领域： <br><br><ul><li> 公开T更新 </li><li> 公众目标 </li></ul><br><br> 从生成的代码中可以明显看出，当执行任何操作时，都会使用描述它的参数调用<b>Target</b> ： <br><br><pre> <code class="cs hljs">Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Marshal), instance);</code> </pre> <br><br> 与上述<b>CSharpArgumentInfo</b>结合使用<b>，</b>此代码意味着以下含义：您需要使用实例参数在静态Marshal类上调用FinalReleaseComObject方法。 在第一次调用时，与<b>Update中</b>相同的委托存储在<b>Target</b>中。  <b>更新</b>委托负责两项重要任务： <br><br><ol><li> 将动态操作绑定到静态操作（出价机制本身不在本文讨论范围之内） </li><li> 缓存形成 </li></ol><br><br> 我们对第二点感兴趣。 这里应该注意的是，当使用动态对象时，我们需要每次检查操作的有效性。 这是一项相当耗费资源的任务，因此我想缓存此类检查的结果。 关于调用带有参数的方法，我们需要记住以下几点： <br><br><ol><li> 调用方法的类型 </li><li> 参数传递的对象的类型（确保可以将其强制转换为参数的类型） </li><li> 操作有效吗 </li></ol><br><br> 然后，当再次调用<b>Target</b>时，我们不需要执行相对昂贵的绑定：只需比较类型，如果匹配，就调用目标函数。 为了解决此问题，为每个动态操作创建一个<i>ExpressionTree</i> ，该树存储动态表达式绑定到的<i>约束</i>和<i>目标函数</i> 。 <br><br> 此函数可以有两种类型： <br><br><ul><li>  <i>绑定错误</i> ：例如，在不存在的<i>动态</i>对象上调用方法，或者无法将<i>动态</i>对象转换为传递给它的参数的类型：然后，您需要引发类似<i>Microsoft.CSharp.RuntimeBinderException</i>的异常<i>：'NoSuchMember'</i> </li><li> 挑战是合法的：然后执行所需的操作 </li></ul><br><br> 该<i>ExpressionTree</i>在<b>Update</b>委托执行期间形成，并存储在<b>Target中</b> 。  <b>目标</b> <i>-L0</i>缓存，稍后我们将详细讨论缓存。 <br><br> 因此， <b>Target</b>存储通过<b>Update</b>委托生成的最后一个<i>ExpressionTree</i> 。 让我们看看这个<i>规则</i>看起来像一个传递给<i>Boo</i>方法的<i>Managed</i>类型的示例： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> instance = Activator.CreateInstance(type); Boo(instance); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br><br><pre> <code class="cs hljs">.Lambda CallSite.Target&lt;System.Action`<span class="hljs-number"><span class="hljs-number">3</span></span>[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]&gt;( Actionsss.CallSite $$site, ConsoleApp12.Foo $$arg0, System.Object $$arg1) { .Block() { .If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; $$arg1 .TypeEqual System.Int32) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.Object)((System.Int32)$$arg1)); .Default(System.Object) } } } .Else { .Default(System.Void) }; .Block() { .Constant&lt;Actionsss.Ast.Expression&gt;(IIF((($arg0 TypeEqual Foo) AndAlso ($arg1 TypeEqual Int32)), returnUnamedLabel_0 ({ ... }) , default(Void))); .Label .LabelTarget CallSiteBinder.UpdateLabel: }; .Label .If ( .Call Actionsss.CallSiteOps.SetNotMatched($$site) ) { .Default(System.Void) } .Else { .Invoke (((Actionsss.CallSite`1[System.Action`3[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]])$$site).Update)( $$site, $$arg0, $$arg1) } .LabelTarget #Label1: } }</span></span></code> </pre> <br><br> 对我们来说最重要的障碍： <br><br><pre> <code class="cs hljs">.If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; $$arg1 .TypeEqual System.Int32)</code> </pre> <br><br>  <i>$$ arg0</i>和<i>$$ arg1</i>是用于调用<b>Target</b>的参数： <br><pre> <code class="cs hljs">Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>&lt;/b&gt;, &lt;b&gt;instance&lt;/b&gt;);</code> </pre> <br><br> 翻译成人类，这意味着： <br><br> 我们已经验证了，如果第一个参数的类型为<i>Foo</i> ，第二个参数的类型为<i>Int32</i> ，则可以安全地调用<i>Boo（（object）$$ arg1）</i> 。 <br><br><pre> <code class="cs hljs">.Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.Object)((System.Int32)$$arg1)); .Default(System.Object) }</span></span></code> </pre> <br><br>  <i>注意：如果发生绑定错误，Label1块如下所示：</i> <br><pre> <code class="cs hljs">.Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Throw .New Microsoft.CSharp.RuntimeBinderException("NoSuchMember")</span></span></code> </pre> <br><br> 这些检查称为<b>约束</b> 。  <b>限制</b>有两种类型：按对象的类型和按对象的特定实例（对象必须完全相同）。 如果至少一项限制失败，我们将必须重新检查动态表达式的有效性，为此，我们将调用<b>Update</b>委托。 根据我们已知的方案，他将执行与新类型的绑定，并将新的<i>ExpressionTree</i>保存在<b>Target中</b> 。 <br><br><h2> 快取 </h2><br><br> 我们已经发现<b>Target</b>是<b>L0缓存</b> 。 每次调用<b>Target时</b> ，我们要做的第一件事就是遍历已经存储在其中的限制。 如果限制失败并且生成了新的绑定，那么旧规则将同时进入<b>L1</b>和<b>L2</b> 。 将来，当您错过<i>L0</i>缓存时，将搜索<i>L1</i>和<i>L2中</i>的规则，直到找到合适的规则为止。 <br><br><ul><li>  <i>L1</i> ：剩下<i>L0</i>的最后十条规则（直接存储在<i>CallSite中</i> ） </li><li>  <i>L2</i> ：使用特定的绑定程序实例（每个<i>CallSite</i>唯一的<i>CallSiteBinder</i> ）创建的最后128条规则 </li></ul><br><br> 现在，我们终于可以将这些详细信息添加到一个整体中，并以算法的形式描述<i>调用Foo.Bar（someDynamicObject）</i>时发生的情况： <br><br>  1.创建一个活页夹，该活页夹在其签名级别记住上下文和被调用的方法 <br><br>  2.首次调用该操作时，将创建<i>ExpressionTree</i> ，该存储以下内容： <br>  2.1 <b>局限性</b> 。 在这种情况下，这将是当前绑定参数类型的两个限制 <br>  2.2 <b>目标函数</b> ： <i>抛出一些异常</i> （在这种情况下是不可能的，因为任何<i>动态</i>都会成功导致对象）或调用<i>Bar</i>方法 <br><br>  3.编译并执行生成的ExpressionTree <br><br>  4.调用该操作时，可能有两个选项： <br>  4.1 <b>工作限制</b> ：只需致电<i>Bar</i> <br>  4.2 <b>限制无效</b> ：对新的绑定参数重复步骤2 <br><br> 因此，以<i>Managed</i>类型的示例为例，几乎可以清楚地看出<i>动态</i>是如何从内部工作的。 在描述的情况下，我们永远不会错过缓存，因为类型始终相同*，因此，在初始化<i>CallSite</i>时， <b>Update将被</b>完全调用一次。 然后，对于每次调用，将仅检查限制，并且将立即调用目标函数。 这与我们对内存的观察非常吻合：没有计算-没有泄漏。 <br><br>  <i>*因此，编译器会为每个生成其CallSites：丢失L0缓存的可能性大大降低</i> <br><br> 现在是时候找出这种方案与<i>本地COM</i>对象的不同之处了。 让我们看一下<i>ExpressionTree</i> ： <br><br><pre> <code class="cs hljs">.Lambda CallSite.Target&lt;System.Action`<span class="hljs-number"><span class="hljs-number">3</span></span>[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]&gt;( Actionsss.CallSite $$site, ConsoleApp12.Foo $$arg0, System.Object $$arg1) { .Block() { .If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; .Block(System.Object $var1) { $var1 = .Constant&lt;System.WeakReference&gt;(System.WeakReference).Target; $var1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (System.Object)$$arg1 == $var1 }) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.__ComObject)$$arg1); .Default(System.Object) } } } .Else { .Default(System.Void) }; .Block() { .Constant&lt;Actionsss.Ast.Expression&gt;(IIF((($arg0 TypeEqual Foo) AndAlso {var Param_0; ... }), returnUnamedLabel_1 ({ ... }) , default(Void))); .Label .LabelTarget CallSiteBinder.UpdateLabel: }; .Label .If ( .Call Actionsss.CallSiteOps.SetNotMatched($$site) ) { .Default(System.Void) } .Else { .Invoke (((Actionsss.CallSite`1[System.Action`3[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]])$$site).Update)( $$site, $$arg0, $$arg1) } .LabelTarget #Label1: } }</span></span></code> </pre> <br><br> 可以看出，区别仅在于第二个限制： <br><br><pre> <code class="cs hljs">.If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; .Block(System.Object $var1) { $var1 = .Constant&lt;System.WeakReference&gt;(System.WeakReference).Target; $var1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (System.Object)$$arg1 == $var1 })</code> </pre> <br><br> 如果在<i>托管</i>代码的情况下，我们对对象的类型有两个限制，那么在这里我们看到第二个限制通过<i>WeakReference</i>检查实例的等效性。 <br><br>  <i>注意：除COM对象外，实例限制也用于TransparentProxy</i> <br><br> 实际上，根据我们对缓存操作的了解，这意味着每次我们在循环中重新创建<i>COM</i>对象时，我们都会错过<i>L0</i>缓存（以及<i>L1 / L2</i> ，因为带有链接的旧规则将存储在此处）到旧实例）。 首先要问您的是规则缓存正在流动。 但是那里的代码非常简单，那里的一切都很好：正确删除了旧规则。 同时，在<i>ExpressionTree</i>中使用<i>WeakReference</i>不会阻止<i>GC</i>收集不必要的对象。 <br><br>  <i>在L1缓存中保存规则的机制：</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxRules = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T newRule</span></span></span><span class="hljs-function">)</span></span> { T[] rules = Rules; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Rules = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { newRule }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } T[] temp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules.Length &lt; (MaxRules - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[rules.Length + <span class="hljs-number"><span class="hljs-number">1</span></span>]; Array.Copy(rules, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>, rules.Length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[MaxRules]; Array.Copy(rules, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>, MaxRules - <span class="hljs-number"><span class="hljs-number">1</span></span>); } temp[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newRule; Rules = temp; }</code> </pre> <br><br> 那怎么办？ 让我们尝试阐明这个假设：绑定<i>COM</i>对象时某处发生内存泄漏。 <br><br><h2> 实验，第2部分 </h2><br><br> 同样，让我们​​从推测性结论转向实验。 首先，让我们重复编译器为我们做的事情： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Simple COM object var comType = Type.GetTypeFromCLSID(new Guid("435356F9-F33F-403D-B475-1E4AB512FF95")); var autogeneratedBinder = Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "Boo", null, typeof(Foo), new CSharpArgumentInfo[2] { CSharpArgumentInfo.Create( CSharpArgumentInfoFlags.UseCompileTimeType, null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) }); var callSite = CallSite&lt;Action&lt;CallSite, Foo, object&gt;&gt;.Create(autogeneratedBinder); while (true) { object instance = Activator.CreateInstance(comType); callSite.Target(callSite, this, instance); }</span></span></code> </pre> <br><br> 我们检查： <br><br><img src="https://habrastorage.org/webt/bf/-u/k6/bf-uk6jtzrfh8_pyzaagi0p8cr4.png"><br><br> 泄漏已保留。 公平。 但是是什么原因呢？ 在研究了活页夹的代码（我们放在方括号之后）之后，很明显，唯一影响我们对象类型的是约束选项。 也许这不是<i>COM</i>对象的问题，而是绑定器的问题？ 没有太多选择，让我们为<i>托管</i>类型引发多个绑定： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = Activator.CreateInstance(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> autogeneratedBinder = Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, <span class="hljs-string"><span class="hljs-string">"Boo"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Foo), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpArgumentInfo[<span class="hljs-number"><span class="hljs-number">2</span></span>] { CSharpArgumentInfo.Create( CSharpArgumentInfoFlags.UseCompileTimeType, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callSite = CallSite&lt;Action&lt;CallSite, Foo, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt;.Create(autogeneratedBinder); callSite.Target(callSite, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, instance); }</code> </pre> <br><br><img src="https://habrastorage.org/webt/-y/an/hj/-yanhjj9jkmqr8bl2adf9rvjsvs.png"><br><br> 哇！ 看来我们抓到了他。 这个问题根本就不像最初在我们看来的<i>COM对象</i>那样，只是由于实例的限制，这是唯一的绑定在循环内发生多次的情况。 在所有其他情况下，我都建立了<i>L0缓存</i>并绑定了一次。 <br><br><h2> 结论 </h2><br><br><h3> 内存泄漏 </h3><br><br> 如果您使用包含<i>本机COM</i>或<i>TransparentProxy的</i> <i>动态</i>变量，请不要将它们作为方法参数传递。 如果仍然需要执行此操作，请使用显式强制转换为<i>对象</i> ，然后编译器将落后于您 <br><br>  <b>错误的</b> ： <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); <span class="hljs-comment"><span class="hljs-comment">//do some work Marshal.FinalReleaseComObject(com);</span></span></code> </pre> <br><br>  <b>正确地</b> ： <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); <span class="hljs-comment"><span class="hljs-comment">//do some work Marshal.FinalReleaseComObject((object) com);</span></span></code> </pre><br><br> 作为额外的预防措施，请尝试尽可能少地实例化此类对象。 适用于<i>.NET Framework的</i>所有版本。  （目前）不是很相关。  <i>NET Core</i> ，因为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不支持</a> <i>动态COM</i>对象。 <br><br><h3> 性能表现 </h3><br><br> 您的利益是尽可能少地发生高速缓存未命中，因为在这种情况下，无需在高级高速缓存中找到合适的规则。  <i>L0</i>高速缓存中的未命中主要是在<i>动态</i>对象的类型与保留的限制不匹配的情况下发生的。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = GetSomeObject(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//:      //:         }</span></span></code> </pre> <br><br> 但是，实际上，除非对该函数的调用数以百万计，或者类型的可变性不是异常大，否则您可能不会注意到性能的差异。  <i>L0</i>高速缓存未命中时的开销是这样的， <i>N</i>是类型数： <br><br><ul><li>  <i>N</i> &lt;10。 如果错过了，请仅迭代现有的<i>L1</i>缓存规则 </li><li>  10 &lt; <i>N &lt;128</i> 。  <i>L1</i>和<i>L2</i>缓存的枚举（最多10次和<i>N</i>次迭代）。 创建并填充10个元素的数组 </li><li>  <i>N</i> &gt; 128。 遍历<i>L1</i>和<i>L2</i>缓存。 创建并填充10和128个元素的数组。 如果您错过了<i>L2</i>缓存，请重新绑定 </li></ul><br><br> 在第二种和第三种情况下，GC的负载将增加。 <br><br><h2> 结论 </h2><br><br> 不幸的是，我们没有找到导致内存泄漏的真正原因，这需要对绑定器进行单独研究。 幸运的是， <i>WinDbg</i>为进一步研究提供了提示： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DLR中</a>发生了一些不好的事情。 第一列是对象数 <br><br><img src="https://habrastorage.org/webt/n_/6g/xf/n_6gxf7etpsj2fg17odfa0varvy.png"><br><br><h2> 红利 </h2><br><br>  <b>为什么强制转换为<i>对象可以</i>防止泄漏？</b> <br> 可以将任何类型强制转换为<i>object</i> ，因此操作不再是动态的。 <br><br>  <b>在使用COM对象的字段和方法时，为什么没有泄漏？</b> <br> 这是<i>ExpressionTree</i>用于字段访问的外观： <br><br><pre> <code class="cs hljs">.If ( .Call System.Dynamic.ComObject.IsComObject($$arg0) ) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Dynamic GetMember ComMarks(.Call System.Dynamic2.ComObject.ObjectToComObject($$arg0)) } }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN466657/">https://habr.com/ru/post/zh-CN466657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN466643/index.html">＃314移动开发人员的有趣材料摘要（9月2日至8日）</a></li>
<li><a href="../zh-CN466647/index.html">没有钢琴家的马和乐团的电话。 如何在前端提出运动任务</a></li>
<li><a href="../zh-CN466649/index.html">周末电动车</a></li>
<li><a href="../zh-CN466651/index.html">以Java / Spring / H2为例，在XML和SQL之间进行选择以滚动LiquiBase脚本</a></li>
<li><a href="../zh-CN466653/index.html">为NES调试游戏：今天如何发生</a></li>
<li><a href="../zh-CN466659/index.html">Kubecost审查可在云端的Kubernetes上省钱</a></li>
<li><a href="../zh-CN466661/index.html">国外远程硕士学位：论文发表前的注意事项</a></li>
<li><a href="../zh-CN466663/index.html">使用STM32F103微控制器（Blue Tablet）进行的简单实验</a></li>
<li><a href="../zh-CN466665/index.html">CSS溢出和数据丢失</a></li>
<li><a href="../zh-CN466667/index.html">上周第379期（2019年9月2日至8日）来自前端世界的新鲜材料摘要</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>