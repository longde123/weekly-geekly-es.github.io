<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏻 🙅🏼 🧒🏿 Un petit aperçu de SIMD en .NET / C # 👸🏻 🧖🏻 👨🏻‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous vous proposons un petit aperçu des capacités de vectorisation d'algorithmes dans le .NET Framework et .NETCORE. Le but de l'article est de présen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un petit aperçu de SIMD en .NET / C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435840/"><p> Nous vous proposons un petit aperçu des capacités de vectorisation d'algorithmes dans le .NET Framework et .NETCORE.  Le but de l'article est de présenter ces techniques à ceux qui ne les connaissaient pas du tout et de montrer que .NET n'est pas loin derrière les "vrais, compilés" langages pour le natif <br>  développement. </p><a name="habracut"></a><br><p>  Je commence tout juste à apprendre les techniques de vectorisation, donc si quelqu'un de la communauté me pointe vers un dévers explicite ou suggère des versions améliorées des algorithmes décrits ci-dessous, je serai extrêmement heureux. </p><br><h2 id="nemnogo-istorii">  Un peu d'histoire </h2><br><p>  Dans .NET, SIMD est apparu pour la première fois en 2015 avec la sortie du .NET Framework 4.6.  Ensuite, les types Matrix3x2, Matrix4x4, Plane, Quaternion, Vector2, Vector3 et Vector4 ont été ajoutés, ce qui a permis la construction de calculs vectorisés.  Plus tard, le type Vector &lt;T&gt; a été ajouté, ce qui a fourni plus d'opportunités pour la vectorisation d'algorithmes.  Mais de nombreux programmeurs étaient toujours mécontents car  les types ci-dessus limitaient le flux de pensées du programmeur et ne permettaient pas d'utiliser toute la puissance des instructions SIMD des processeurs modernes.  Déjà à notre époque, dans l'aperçu .NET Core 3.0, l'espace de noms System.Runtime.Intrinsics est apparu, ce qui offre une plus grande liberté dans le choix des instructions.  Pour obtenir les meilleurs résultats de vitesse, vous devez utiliser RyuJit et soit construire sur x64, soit désactiver Prefer 32 bits et construire sur AnyCPU.  Toutes les références que j'ai exécutées sur un ordinateur avec un processeur Intel Core i7-6700 à 3,40 GHz (Skylake). </p><br><h2 id="summiruem-elementy-massiva">  Résumer les éléments du tableau </h2><br><p>  J'ai décidé de commencer par le problème classique, qui est souvent écrit en premier quand il s'agit de vectorisation.  C'est la tâche de trouver la somme des éléments du tableau.  Nous écrirons quatre implémentations de cette tâche, nous résumerons les éléments du tableau Array: </p><br><p>  Le plus évident </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { result += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Utilisation de LINQ </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Aggregate&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, (current, i) =&gt; current + i);</code> </pre> <br><p>  Utilisation de vecteurs de System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  À l'aide du code de l'espace System.Runtime.Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  J'ai lancé un benchmark sur ces 4 méthodes sur mon ordinateur et j'ai obtenu ce résultat: </p><br><div class="scrollable-table"><table><thead><tr><th>  La méthode </th><th>  ItemsCount </th><th>  Médiane </th></tr></thead><tbody><tr><td>  Naïf </td><td>  10 </td><td>  75,12 ns </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  1 186,85 ns </td></tr><tr><td>  Vecteurs </td><td>  10 </td><td>  60,09 ns </td></tr><tr><td>  Intrinsèque </td><td>  10 </td><td>  255,40 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naïf </td><td>  100 </td><td>  360,56 ns </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  2 719,24 ns </td></tr><tr><td>  Vecteurs </td><td>  100 </td><td>  60,09 ns </td></tr><tr><td>  Intrinsèque </td><td>  100 </td><td>  345,54 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naïf </td><td>  1000 </td><td>  1 847,88 ns </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  12 033,78 ns </td></tr><tr><td>  Vecteurs </td><td>  1000 </td><td>  240,38 ns </td></tr><tr><td>  Intrinsèque </td><td>  1000 </td><td>  630,98 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naïf </td><td>  10 000 </td><td>  18 403,72 ns </td></tr><tr><td>  LINQ </td><td>  10 000 </td><td>  102 489,96 ns </td></tr><tr><td>  Vecteurs </td><td>  10 000 </td><td>  7 316,42 ns </td></tr><tr><td>  Intrinsèque </td><td>  10 000 </td><td>  3 365,25 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naïf </td><td>  100 000 </td><td>  176 630,67 ns </td></tr><tr><td>  LINQ </td><td>  100 000 </td><td>  975 998,24 ns </td></tr><tr><td>  Vecteurs </td><td>  100 000 </td><td>  78 828,03 ns </td></tr><tr><td>  Intrinsèque </td><td>  100 000 </td><td>  41 269,41 ns </td></tr></tbody></table></div><br><p>  On peut voir que les solutions avec vecteurs et intrinsèque sont beaucoup plus rapides que la solution évidente et avec LINQ.  Maintenant, nous devons comprendre ce qui se passe dans ces deux méthodes. </p><br><p>  Considérez la méthode Vectors plus en détail: </p><br><div class="spoiler">  <b class="spoiler_title">Vecteurs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  int vectorSize = Vector &lt;int&gt; .Count;  - c'est le nombre de 4 octets que nous pouvons mettre dans un vecteur.  Si l'accélération matérielle est utilisée, cette valeur indique le nombre de nombres à 4 octets pouvant être placés dans un registre SIMD.  En fait, il montre combien d'éléments de ce type vous pouvez effectuer des opérations en parallèle; </li><li>  accVector - un vecteur dans lequel le résultat de la fonction s'accumulera; <br>  var v = nouveau vecteur &lt;int&gt; (tableau, i);  - les données sont chargées dans un nouveau vecteur v, à partir du tableau, à partir de l'index i.  Les données vectorSize seront chargées exactement. </li><li>  accVector = Vector.Add (accVector, v);  - deux vecteurs sont ajoutés. <br>  Par exemple, dans le tableau 8, les nombres sont stockés: {0, 1, 2, 3, 4, 5, 6, 7} et vectorSize == 4, puis: <br>  Dans la première itération de la boucle accVector = {0, 0, 0, 0}, v = {0, 1, 2, 3}, après addition dans accVector ce sera: {0, 0, 0, 0} + {0, 1, 2 , 3} = {0, 1, 2, 3}. <br>  Dans la deuxième itération, v = {4, 5, 6, 7} et après addition, accVector = {0, 1, 2, 3} + {4, 5, 6, 7} = {4, 6, 8, 10}. </li><li>  Il ne reste plus qu'à obtenir en quelque sorte la somme de tous les éléments du vecteur, pour cela nous pouvons appliquer la multiplication scalaire par un vecteur rempli d'unités: int result = Vector.Dot (accVector, Vector &lt;int&gt; .One); <br>  Il s'avère alors: {4, 6, 8, 10} <em>{1, 1, 1, 1} = 4</em> 1 + 6 <em>1 + 8</em> 1 + 10 * 1 = 28. </li><li>  En fin de compte, si nécessaire, des nombres sont ajoutés qui ne correspondent pas au dernier vecteur. </li></ul><br><p>  Si vous regardez le code de la méthode intrinsèque: </p><br><div class="spoiler">  <b class="spoiler_title">Intrinsèque</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p>  Vous pouvez voir qu'il est très similaire aux vecteurs à quelques exceptions près: </p><br><ul><li>  vectorSize est donné par constante.  En effet, les instructions Avx2 qui fonctionnent sur des registres 256 bits sont explicitement utilisées dans cette méthode.  Dans une application réelle, il devrait y avoir une vérification pour voir si le processeur Avx2 actuel prend en charge les instructions et, sinon, appeler un autre code.  Cela ressemble à ceci: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.IsSupported) { DoThingsForAvx2(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx.IsSupported) { DoThingsForAvx(); } ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sse2.IsSupported) { DoThingsForSse2(); } ...</code> </pre> </li><li>  var accVector = Vector256 &lt;int&gt; .Zero;  accVector est déclaré comme un vecteur 256 bits rempli de zéros. </li><li>  fixed (int * ptr = Array) - un pointeur vers un tableau est entré dans ptr. </li><li>  Puis les mêmes opérations que dans Vectors: charger des données dans un vecteur et ajouter deux vecteurs. </li><li>  Pour résumer les éléments du vecteur, la méthode suivante a été appliquée: <br><ul><li>  un tableau est créé sur la pile: var temp = stackalloc int [vectorSize]; </li><li>  le vecteur est chargé dans ce tableau: Avx2.Store (temp, accVector); </li><li>  dans une boucle, les éléments du tableau sont additionnés. </li></ul></li><li>  puis les éléments du tableau qui ne sont pas placés dans le dernier vecteur sont additionnés </li></ul><br><h2 id="sravnivaem-dva-massiva">  Comparez deux tableaux </h2><br><p>  Il est nécessaire de comparer deux tableaux d'octets.  En fait, c'est le problème à cause duquel j'ai commencé à apprendre SIMD dans .NET.  Encore une fois, nous écrirons plusieurs méthodes pour le benchmark, nous comparerons deux tableaux: ArrayA et ArrayB: </p><br><p>  La solution la plus évidente: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Solution via LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; ArrayA.SequenceEqual(ArrayB);</code> </pre> <br><p>  Solution via la fonction MemCmp: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">, CallingConvention = CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memcmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemCmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; memcmp(ArrayA, ArrayB, ArrayA.Length) == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Utilisation de vecteurs de System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayA, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayB, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Vector.EqualsAll(va, vb)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Utilisation de l'intrinsèque: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> equalsMask = <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (<span class="hljs-number"><span class="hljs-number">0b1111</span></span>_1111_1111_1111_1111_1111_1111_1111)); <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrA = ArrayA) <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrB = ArrayB) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = Avx2.LoadVector256(ptrA + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = Avx2.LoadVector256(ptrB + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Le résultat du benchmark sur mon ordinateur: </p><br><div class="scrollable-table"><table><thead><tr><th>  La méthode </th><th>  ItemsCount </th><th>  Médiane </th></tr></thead><tbody><tr><td>  Naïf </td><td>  10 000 </td><td>  66 719,1 ns </td></tr><tr><td>  LINQ </td><td>  10 000 </td><td>  71 211,1 ns </td></tr><tr><td>  Vecteurs </td><td>  10 000 </td><td>  3 695,8 ns </td></tr><tr><td>  Memcmp </td><td>  10 000 </td><td>  600,9 ns </td></tr><tr><td>  Intrinsèque </td><td>  10 000 </td><td>  1 607,5 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naïf </td><td>  100 000 </td><td>  588 633,7 ns </td></tr><tr><td>  LINQ </td><td>  100 000 </td><td>  651 191,3 ns </td></tr><tr><td>  Vecteurs </td><td>  100 000 </td><td>  34 659,1 ns </td></tr><tr><td>  Memcmp </td><td>  100 000 </td><td>  5 513,6 ns </td></tr><tr><td>  Intrinsèque </td><td>  100 000 </td><td>  12078,9 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naïf </td><td>  1 000 000 </td><td>  5 637 293,1 ns </td></tr><tr><td>  LINQ </td><td>  1 000 000 </td><td>  6 622 666,0 ns </td></tr><tr><td>  Vecteurs </td><td>  1 000 000 </td><td>  777 974,2 ns </td></tr><tr><td>  Memcmp </td><td>  1 000 000 </td><td>  361 704,5 ns </td></tr><tr><td>  Intrinsèque </td><td>  1 000 000 </td><td>  434 252,7 ns </td></tr></tbody></table></div><br><p>  Tout le code de ces méthodes, je pense, est compréhensible, à l'exception de deux lignes en Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Dans le premier, deux vecteurs sont comparés pour l'égalité et le résultat est stocké dans le vecteur areEqual, dans lequel tous les bits sont mis à 1 dans un élément à une position spécifique si les éléments correspondants dans va et vb sont égaux.  Il s'avère que si les vecteurs des octets va et vb sont complètement égaux, alors dans areEquals tous les éléments doivent être égaux à 255 (11111111b).  Parce que  Avx2.CompareEqual est un wrapper sur _mm256_cmpeq_epi8, puis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le site Intel</a> vous pouvez voir le pseudo-code de cette opération: <br>  La méthode MoveMask à partir d'un vecteur fait un nombre 32 bits.  Les valeurs binaires sont les bits hauts de chacun des 32 éléments à un octet du vecteur.  Le pseudocode peut être trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Ainsi, si certains octets dans va et vb ne correspondent pas, alors dans areEqual les octets correspondants seront 0, donc les bits les plus significatifs de ces octets seront également 0, ce qui signifie que les bits correspondants dans la réponse Avx2.MoveMask seront également 0 et la comparaison avec equalsMask ne fonctionnera pas. </p><br><p>  Analysons un petit exemple, en supposant que la longueur du vecteur est de 8 octets (pour l'écrire, c'était moins): </p><br><ul><li>  Soit va = {100, 10, 20, 30, 100, 40, 50, 100} et vb = {100, 20, 10, 30, 100, 40, 80, 90}; </li><li>  Alors areEqual sera égal à {255, 0, 0, 255, 255, 255, 0, 0}; </li><li>  La méthode MoveMask renverra 10011100b, qui devra être comparée avec le masque 11111111b, car  Ces masques étant inégaux, il s'avère que les vecteurs va et vb ne sont pas égaux. </li></ul><br><h2 id="podschityvaem-skolko-raz-element-vstrechaetsya-v-kollekcii">  Compter le nombre de fois qu'un élément apparaît dans la collection </h2><br><p>  Parfois, il est nécessaire de calculer le nombre de fois qu'un élément particulier est trouvé dans une collection, par exemple, des entiers, cet algorithme peut également être accéléré.  Écrivons quelques méthodes de comparaison, nous chercherons l'élément Item dans le tableau Array. </p><br><p>  Le plus évident: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == Item) { result++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  en utilisant LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Count(i =&gt; i == Item);</code> </pre> <br><p>  en utilisant des vecteurs de System.Numerics.Vectors: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(Item); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accResult = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Vector.Equals(v, mask); accResult = Vector.Subtract(accResult, areEqual); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] == Item) { result++; } } result += Vector.Dot(accResult, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Utilisation de l'intrinsèque: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//var mask = Avx2.SetAllVector256(Item); //var mask = Avx2.SetVector256(Item, Item, Item, Item, Item, Item, Item, Item); var temp = stackalloc int[vectorSize]; for (int j = 0; j &lt; vectorSize; j++) { temp[j] = Item; } var mask = Avx2.LoadVector256(temp); var accVector = Vector256&lt;int&gt;.Zero; int i; var array = Array; fixed (int* ptr = array) { for (i = 0; i &lt; array.Length - vectorSize; i += vectorSize) { var v = Avx2.LoadVector256(ptr + i); var areEqual = Avx2.CompareEqual(v, mask); accVector = Avx2.Subtract(accVector, areEqual); } } int result = 0; Avx2.Store(temp, accVector); for(int j = 0; j &lt; vectorSize; j++) { result += temp[j]; } for(; i &lt; array.Length; i++) { if (array[i] == Item) { result++; } } return result; }</span></span></code> </pre> <br><p>  Le résultat du benchmark sur mon ordinateur: </p><br><div class="scrollable-table"><table><thead><tr><th>  La méthode </th><th>  ItemsCount </th><th>  Médiane </th></tr></thead><tbody><tr><td>  Naïf </td><td>  1000 </td><td>  2 824,41 ns </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  12 138,95 ns </td></tr><tr><td>  Vecteurs </td><td>  1000 </td><td>  961,50 ns </td></tr><tr><td>  Intrinsèque </td><td>  1000 </td><td>  691,08 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naïf </td><td>  10 000 </td><td>  27 072,25 ns </td></tr><tr><td>  LINQ </td><td>  10 000 </td><td>  113 967,87 ns </td></tr><tr><td>  Vecteurs </td><td>  10 000 </td><td>  7 571,82 ns </td></tr><tr><td>  Intrinsèque </td><td>  10 000 </td><td>  4 296,71 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naïf </td><td>  100 000 </td><td>  361 028,46 ns </td></tr><tr><td>  LINQ </td><td>  100 000 </td><td>  1.091.994,28 ns </td></tr><tr><td>  Vecteurs </td><td>  100 000 </td><td>  82 839,29 ns </td></tr><tr><td>  Intrinsèque </td><td>  100 000 </td><td>  40 307,91 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naïf </td><td>  1 000 000 </td><td>  1 634 175,46 ns </td></tr><tr><td>  LINQ </td><td>  1 000 000 </td><td>  6 194 257,38 ns </td></tr><tr><td>  Vecteurs </td><td>  1 000 000 </td><td>  583 901,29 ns </td></tr><tr><td>  Intrinsèque </td><td>  1 000 000 </td><td>  413 520,38 ns </td></tr></tbody></table></div><br><p>  Les méthodes Vectors et Intrinsics sont complètement identiques en logique, les différences ne concernent que la mise en œuvre d'opérations spécifiques.  L'idée dans son ensemble est: </p><br><ul><li>  un vecteur de masque est créé dans lequel le nombre requis est stocké dans chaque élément; </li><li>  La partie du tableau est chargée dans le vecteur v et comparée au masque, alors tous les bits seront définis en éléments égaux dans areEqual, car  areEqual est un vecteur d'entiers, alors si vous définissez tous les bits d'un élément, nous obtenons -1 dans cet élément ((int) (1111_1111_1111_1111_1111_1111_1111_1111b) == -1); </li><li>  le vecteur areEqual est soustrait de accVector, puis accVector sera la somme du nombre de fois que l'élément item s'est produit dans tous les vecteurs v pour chaque position (moins min donne un plus). </li></ul><br><p>  Tout le code de l'article peut être trouvé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Je n'ai examiné qu'une très petite partie des possibilités offertes par .NET pour la vectorisation des calculs.  Pour une liste complète et à jour des éléments intrinsèques disponibles dans .NETCORE sous x86, vous pouvez vous référer au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code source</a> .  Il est pratique que dans les fichiers C # du résumé de chaque intrinsèque, il y ait son propre nom du monde de C, ce qui simplifie la compréhension de l'objectif de cet intrinsèque et la traduction des algorithmes C ++ / C existants en .NET.  La documentation System.Numerics.Vector est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">msdn</a> . </p><br><p>  À mon avis, .NET a un gros avantage sur C ++, car  La compilation JIT a déjà lieu sur la machine client, puis le compilateur peut optimiser le code pour un processeur client spécifique, offrant des performances maximales.  Dans le même temps, un programmeur pour écrire du code rapide peut rester dans le cadre d'un langage et d'une technologie. </p><br><p>  UPD (15/09/2019): </p><br><div class="spoiler">  <b class="spoiler_title">Il y avait un montant dans les repères</b> <div class="spoiler_text"><p>  Dans les benchmarks, j'ai utilisé IterationSetup, qui, en fin de compte, peut affecter considérablement les performances des benchmarks qui fonctionnent en moins de 100 ms.  Si vous le refaitez sur GlobalSetup, les résultats seront comme ceci. </p><br><p>  Somme des éléments du tableau: </p><br><div class="scrollable-table"><table><thead><tr><th>  La méthode </th><th>  ItemsCount </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Ratio </th></tr></thead><tbody><tr><td>  Naïf </td><td>  10 </td><td>  3,531 ns </td><td>  0,0336 ns </td><td>  0,0314 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  76,925 ns </td><td>  0,4166 ns </td><td>  0,3889 ns </td><td>  21,79 </td></tr><tr><td>  Vecteurs </td><td>  10 </td><td>  2,750 ns </td><td>  0,0210 ns </td><td>  0,0196 ns </td><td>  0,78 </td></tr><tr><td>  Intrinsèque </td><td>  10 </td><td>  6,513 ns </td><td>  0,0623 ns </td><td>  0,0582 ns </td><td>  1,84 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naïf </td><td>  100 </td><td>  47,982 ns </td><td>  0,3975 ns </td><td>  0,3524 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  590.414 ns </td><td>  3,8808 ns </td><td>  3,4402 ns </td><td>  12,31 </td></tr><tr><td>  Vecteurs </td><td>  100 </td><td>  10.122 ns </td><td>  0,0747 ns </td><td>  0,0699 ns </td><td>  0,21 </td></tr><tr><td>  Intrinsèque </td><td>  100 </td><td>  14,277 ns </td><td>  0,0566 ns </td><td>  0,0529 ns </td><td>  0,30 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naïf </td><td>  1000 </td><td>  569,910 ns </td><td>  2,8297 ns </td><td>  2,6469 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  5,658.570 ns </td><td>  31,7465 ns </td><td>  29,6957 ns </td><td>  9,93 </td></tr><tr><td>  Vecteurs </td><td>  1000 </td><td>  79,598 ns </td><td>  0,3498 ns </td><td>  0,3272 ns </td><td>  0,14 </td></tr><tr><td>  Intrinsèque </td><td>  1000 </td><td>  66,970 ns </td><td>  0,3937 ns </td><td>  0,3668 ns </td><td>  0,12 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naïf </td><td>  10 000 </td><td>  5,637.571 ns </td><td>  37.5050 ns </td><td>  29.2814 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10 000 </td><td>  56 498,987 ns </td><td>  294.8776 ns </td><td>  275,8287 ns </td><td>  10.02 </td></tr><tr><td>  Vecteurs </td><td>  10 000 </td><td>  772.900 ns </td><td>  2,6802 ns </td><td>  2,5070 ns </td><td>  0,14 </td></tr><tr><td>  Intrinsèque </td><td>  10 000 </td><td>  579,152 ns </td><td>  2,8371 ns </td><td>  2,6538 ns </td><td>  0,10 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naïf </td><td>  100 000 </td><td>  56 352,865 ns </td><td>  230,7916 ns </td><td>  215,8826 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100 000 </td><td>  562 610,571 ns </td><td>  3,775.7631 ns </td><td>  3,152.9332 ns </td><td>  9,98 </td></tr><tr><td>  Vecteurs </td><td>  100 000 </td><td>  8.389,647 ns </td><td>  165,9590 ns </td><td>  227.1666 ns </td><td>  0,15 </td></tr><tr><td>  Intrinsèque </td><td>  100 000 </td><td>  7,261,334 ns </td><td>  89,6468 ns </td><td>  69,9903 ns </td><td>  0,13 </td></tr></tbody></table></div><br><p>  Comparaison de deux tableaux: </p><br><div class="scrollable-table"><table><thead><tr><th>  La méthode </th><th>  ItemsCount </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Ratio </th></tr></thead><tbody><tr><td>  Naïf </td><td>  10 000 </td><td>  7 033,8 ns </td><td>  50,636 ns </td><td>  47,365 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10 000 </td><td>  64 841,4 ns </td><td>  289,157 ns </td><td>  270,478 ns </td><td>  9.22 </td></tr><tr><td>  Vecteurs </td><td>  10 000 </td><td>  504,0 ns </td><td>  2,406 ns </td><td>  2,251 ns </td><td>  0,07 </td></tr><tr><td>  Memcmp </td><td>  10 000 </td><td>  368,1 ns </td><td>  2,637 ns </td><td>  2,466 ns </td><td>  0,05 </td></tr><tr><td>  Intrinsèque </td><td>  10 000 </td><td>  283,6 ns </td><td>  1.135 ns </td><td>  1,061 ns </td><td>  0,04 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naïf </td><td>  100 000 </td><td>  85,214.4 ns </td><td>  903,868 ns </td><td>  845,478 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100 000 </td><td>  702 279,4 ns </td><td>  2,846.609 ns </td><td>  2 662,720 ns </td><td>  8.24 </td></tr><tr><td>  Vecteurs </td><td>  100 000 </td><td>  5 179,2 ns </td><td>  45,337 ns </td><td>  42.409 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  100 000 </td><td>  4,510,5 ns </td><td>  24,292 ns </td><td>  22,723 ns </td><td>  0,05 </td></tr><tr><td>  Intrinsèque </td><td>  100 000 </td><td>  2 957,0 ns </td><td>  11,452 ns </td><td>  10,712 ns </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naïf </td><td>  1 000 000 </td><td>  844 006,1 ns </td><td>  3,552.478 ns </td><td>  3.322.990 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1 000 000 </td><td>  6 483 079,3 ns </td><td>  42,641.040 ns </td><td>  39 886,455 ns </td><td>  7,68 </td></tr><tr><td>  Vecteurs </td><td>  1 000 000 </td><td>  54,180.1 ns </td><td>  357,258 ns </td><td>  334.180 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  1 000 000 </td><td>  49,480.1 ns </td><td>  515,675 ns </td><td>  457,133 ns </td><td>  0,06 </td></tr><tr><td>  Intrinsèque </td><td>  1 000 000 </td><td>  36 633,9 ns </td><td>  680,525 ns </td><td>  636,564 ns </td><td>  0,04 </td></tr></tbody></table></div><br><p>  Le nombre d'occurrences d'un élément dans un tableau: </p><br><div class="scrollable-table"><table><thead><tr><th>  La méthode </th><th>  ItemsCount </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Ratio </th></tr></thead><tbody><tr><td>  Naïf </td><td>  10 </td><td>  8,844 ns </td><td>  0,0772 ns </td><td>  0,0603 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  87,456 ns </td><td>  0,9496 ns </td><td>  0,8888 ns </td><td>  9,89 </td></tr><tr><td>  Vecteurs </td><td>  10 </td><td>  3.140 ns </td><td>  0,0406 ns </td><td>  0,0380 ns </td><td>  0,36 </td></tr><tr><td>  Intrinsèque </td><td>  10 </td><td>  13,813 ns </td><td>  0,0825 ns </td><td>  0,0772 ns </td><td>  1,56 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naïf </td><td>  100 </td><td>  107,310 ns </td><td>  0,6975 ns </td><td>  0,6183 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  626,285 ns </td><td>  5.7677 ns </td><td>  5.3951 ns </td><td>  5.83 </td></tr><tr><td>  Vecteurs </td><td>  100 </td><td>  11,844 ns </td><td>  0,2113 ns </td><td>  0,1873 ns </td><td>  0,11 </td></tr><tr><td>  Intrinsèque </td><td>  100 </td><td>  19,616 ns </td><td>  0,1018 ns </td><td>  0,0903 ns </td><td>  0,18 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naïf </td><td>  1000 </td><td>  1.032.466 ns </td><td>  6.3799 ns </td><td>  5.6556 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  6,266.605 ns </td><td>  42,6585 ns </td><td>  39.9028 ns </td><td>  6.07 </td></tr><tr><td>  Vecteurs </td><td>  1000 </td><td>  83,417 ns </td><td>  0,5393 ns </td><td>  0,4780 ns </td><td>  0,08 </td></tr><tr><td>  Intrinsèque </td><td>  1000 </td><td>  88,358 ns </td><td>  0,4921 ns </td><td>  0,4603 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naïf </td><td>  10 000 </td><td>  9 942,503 ns </td><td>  47,9732 ns </td><td>  40.0598 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10 000 </td><td>  62 305,598 ns </td><td>  643,8775 ns </td><td>  502,6972 ns </td><td>  6.27 </td></tr><tr><td>  Vecteurs </td><td>  10 000 </td><td>  914,967 ns </td><td>  7.2959 ns </td><td>  6,8246 ns </td><td>  0,09 </td></tr><tr><td>  Intrinsèque </td><td>  10 000 </td><td>  931,698 ns </td><td>  6.3444 ns </td><td>  5,9346 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naïf </td><td>  100 000 </td><td>  94 834,804 ns </td><td>  793,8585 ns </td><td>  703,7349 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100 000 </td><td>  626 620,968 ns </td><td>  4 696,9221 ns </td><td>  4,393,5038 ns </td><td>  6,61 </td></tr><tr><td>  Vecteurs </td><td>  100 000 </td><td>  9,000.827 ns </td><td>  179,5351 ns </td><td>  192.1005 ns </td><td>  0,09 </td></tr><tr><td>  Intrinsèque </td><td>  100 000 </td><td>  8 690,771 ns </td><td>  101,7078 ns </td><td>  95.1376 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naïf </td><td>  1 000 000 </td><td>  959.302.249 ns </td><td>  4,268.2488 ns </td><td>  3.783.6914 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1 000 000 </td><td>  6,218,681.888 ns </td><td>  31 321,9277 ns </td><td>  29,298.5506 ns </td><td>  6,48 </td></tr><tr><td>  Vecteurs </td><td>  1 000 000 </td><td>  99,778.488 ns </td><td>  1,975.6001 ns </td><td>  4252,6877 ns </td><td>  0,10 </td></tr><tr><td>  Intrinsèque </td><td>  1 000 000 </td><td>  96 449 350 ns </td><td>  1,171.8067 ns </td><td>  978.5116 ns </td><td>  0,10 </td></tr></tbody></table></div></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435840/">https://habr.com/ru/post/fr435840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435828/index.html">Les mathématiques dans Gamedev sont simples. Courbes d'unité et ondulations pour effet pluie</a></li>
<li><a href="../fr435830/index.html">OMEGA - Automatisation du chronométrage des événements sportifs</a></li>
<li><a href="../fr435834/index.html">EXAM - Méthode de classification des textes à la pointe de la technologie</a></li>
<li><a href="../fr435836/index.html">Les plus grandes entreprises de Wall Street acceptent de lancer un nouvel échange pour concurrencer le Nasdaq et le NYSE</a></li>
<li><a href="../fr435838/index.html">Fonctions paresseuses JavaScript</a></li>
<li><a href="../fr435842/index.html">Créer des modèles de jeu 3D pour les pauvres: Indie Way</a></li>
<li><a href="../fr435846/index.html">Conférences et hackathons pour écoliers et étudiants: 11 événements thématiques</a></li>
<li><a href="../fr435848/index.html">Nouveaux appareils et technologies avec CES 2019 de Microsoft et de ses partenaires</a></li>
<li><a href="../fr435854/index.html">Notes d'un phytochimiste. Radio banane</a></li>
<li><a href="../fr435856/index.html">Quels antivirus sont utilisés dans les pare-feu modernes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>