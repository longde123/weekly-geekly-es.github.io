<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèø ü¶ä üß§ Zustandsverwaltung in Flatteranwendungen ‚úãüèº ü§æüèª ü§°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Allgemeine Grunds√§tze 


 Flutter ist ein reaktives Framework, und f√ºr einen Entwickler, der sich auf native Entwicklung spezialisiert hat, kann seine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zustandsverwaltung in Flatteranwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424765/"><p><img src="https://habrastorage.org/webt/4r/cs/fa/4rcsfacb6jeocfr5aprzgmk7-a0.jpeg"></p><br><h1 id="obschie-principy">  Allgemeine Grunds√§tze </h1><br><p>  Flutter ist ein reaktives Framework, und f√ºr einen Entwickler, der sich auf native Entwicklung spezialisiert hat, kann seine Philosophie ungew√∂hnlich sein.  Daher beginnen wir mit einem kurzen R√ºckblick. </p><br><p> Die Benutzeroberfl√§che von Flutter besteht wie in den meisten modernen Frameworks aus einem Baum von Komponenten (Widgets).  Wenn sich eine Komponente √§ndert, werden diese und alle untergeordneten Komponenten neu gerendert (mit internen Optimierungen, die unten beschrieben werden).  Wenn sich die Anzeige global √§ndert (z. B. durch Drehen des Bildschirms), wird der gesamte Widget-Baum neu gezeichnet. </p><a name="habracut"></a><br><p>  Dieser Ansatz mag unwirksam erscheinen, gibt dem Programmierer jedoch die Kontrolle √ºber die Arbeitsgeschwindigkeit.  Wenn Sie die Benutzeroberfl√§che auf h√∂chster Ebene aktualisieren, ohne dass dies erforderlich ist, funktioniert alles langsam. Mit dem richtigen Layout der Widgets k√∂nnen Anwendungen auf Flutter jedoch sehr schnell ausgef√ºhrt werden. </p><br><p>  Flutter hat zwei Arten von Widgets - Stateless und Stateful.  Die ersteren (analog zu Pure Components in React) haben keinen Zustand und werden durch ihre Parameter vollst√§ndig beschrieben.  Wenn sich die Anzeigebedingungen (z. B. die Gr√∂√üe des Bereichs, in dem das Widget angezeigt werden soll) und seine Parameter nicht √§ndern, verwendet das System die zuvor erstellte visuelle Darstellung des Widgets erneut, sodass sich die Verwendung zustandsloser Widgets positiv auf die Leistung auswirkt.  Gleichzeitig wird jedes Mal, wenn das Widget neu gezeichnet wird, ein neues Objekt formell erstellt und der Konstruktor gestartet. </p><br><p>  Stateful-Widgets behalten einen gewissen Status zwischen den Renderings bei.  Dazu werden sie von zwei Klassen beschrieben.  Die erste der Klassen, das Widget selbst, beschreibt die Objekte, die bei jedem Rendern erstellt werden.  Die zweite Klasse beschreibt den Status des Widgets und seine Objekte werden auf die erstellten Widget-Objekte √ºbertragen.  Stateful State Widgets sind eine wichtige Quelle f√ºr das Neuzeichnen von Schnittstellen.  Dazu m√ºssen Sie die Eigenschaften innerhalb des Aufrufs der SetState-Methode √§ndern.  Im Gegensatz zu vielen anderen Frameworks verf√ºgt Flutter daher nicht √ºber eine implizite Statusverfolgung. Eine √Ñnderung der Eigenschaften des Widgets au√üerhalb der SetState-Methode f√ºhrt nicht zu einem erneuten Zeichnen der Schnittstelle. </p><br><p>  Nachdem Sie die Grundlagen beschrieben haben, k√∂nnen Sie mit einer einfachen Anwendung beginnen, die Stateless- und Stateful-Widgets verwendet: </p><br><div class="spoiler">  <b class="spoiler_title">Basisanwendung</b> <div class="spoiler_text"><pre><code class="plaintext hljs">import 'dart:math'; import 'package:flutter/material.dart'; void main() =&gt; runApp(new MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), home: Scaffold( appBar: AppBar( title: Text('Sample app'), ), body: new MyHomePage(), ), ); } } class MyHomePage extends StatefulWidget { @override _MyHomePageState createState() =&gt; _MyHomePageState(); } class _MyHomePageState extends State&lt;MyHomePage&gt; { Random rand = Random(); @override Widget build(BuildContext context) { return new ListView.builder(itemBuilder: (BuildContext context, int index) { return Text('Random number ${rand.nextInt(100)}',); }); } }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollst√§ndiges Beispiel</a> </p><br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sd/bv/nv/sdbvnvms7mjzadqujfg8vjm2wgs.png"></p></div></div><br><h1 id="esli-nuzhny-bolee-zhivuchie-sostoyaniya">  Wenn Sie hartn√§ckigere Bedingungen ben√∂tigen </h1><br><p>  Lass uns weitermachen.  Der Status der Widgets wird zwischen dem erneuten Zeichnen von Schnittstellen beibehalten, jedoch nur solange das Widget ben√∂tigt wird, d. H.  wirklich auf dem Bildschirm gelegen.  Lassen Sie uns ein einfaches Experiment durchf√ºhren - platzieren Sie unsere Liste auf der Registerkarte: </p><br><div class="spoiler">  <b class="spoiler_title">Tab App</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin { Random rand = Random(); TabController _tabController; final List&lt;Tab&gt; myTabs = &lt;Tab&gt;[ new Tab(text: 'FIRST'), new Tab(text: 'SECOND'), ]; @override void initState() { super.initState(); _tabController = new TabController(vsync: this, length: myTabs.length); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Sample app'), ), body: new TabBarView( controller: _tabController, children: [ new ListView.builder(itemBuilder: (BuildContext context, int index) { return Text('Random number ${rand.nextInt(100)}',); }), Text('Second tab'), ],), bottomNavigationBar: new TabBar( controller: _tabController, tabs: myTabs, labelColor: Colors.blue, ), ); } }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollst√§ndiges Beispiel</a> </p><br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/va/fw/km/vafwkmelvxeapujubze6ixv4him.gif"></p></div></div><br><p>  Beim Start k√∂nnen Sie sehen, dass beim Wechseln zwischen Registerkarten der Status gel√∂scht wird (die Methode dispose () wird aufgerufen) und bei der R√ºckgabe erneut erstellt wird (die Methode initState ()).  Dies ist sinnvoll, da das Speichern des Status nicht anzeigbarer Widgets Systemressourcen verbraucht.  F√ºr den Fall, dass der Status des Widgets seine vollst√§ndige Verschleierung √ºberleben muss, sind mehrere Ans√§tze m√∂glich: </p><br><p>  Zun√§chst k√∂nnen Sie separate Objekte (ViewModel) zum Speichern des Status verwenden.  Dart auf Sprachebene unterst√ºtzt Factory-Konstruktoren, mit denen Fabriken und Singletones erstellt werden k√∂nnen, in denen die erforderlichen Daten gespeichert werden. </p><br><p>  Ich mag diesen Ansatz mehr, weil  Sie k√∂nnen damit die Gesch√§ftslogik von der Benutzeroberfl√§che isolieren.  Dies gilt insbesondere aufgrund der Tatsache, dass Flutter Release Preview 2 die M√∂glichkeit hinzugef√ºgt hat, pixelgenaue Schnittstellen f√ºr iOS zu erstellen. Dies m√ºssen Sie jedoch nat√ºrlich f√ºr die entsprechenden Widgets tun. </p><br><p>  Zweitens ist es m√∂glich, den den React-Programmierern bekannten State-Raising-Ansatz zu verwenden, wenn Daten in vorgelagerten Komponenten gespeichert werden.  Da Flutter die Schnittstelle nur beim Aufruf der Methode setState () neu zeichnet, k√∂nnen diese Daten ohne Rendern ge√§ndert und verwendet werden.  Dieser Ansatz ist etwas komplexer und erh√∂ht die Konnektivit√§t von Widgets in der Struktur. Sie k√∂nnen jedoch die Ebene der Datenspeicherung punktuell angeben. </p><br><p>  Schlie√ülich gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statusspeicherbibliotheken</a> wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">flutter_redux</a> . </p><br><p>  Der Einfachheit halber verwenden wir den ersten Ansatz.  Erstellen wir eine separate ListData-Klasse, Singleton, in der die Werte f√ºr unsere Liste gespeichert werden.  Bei der Anzeige verwenden wir diese Klasse. </p><br><div class="spoiler">  <b class="spoiler_title">Registerkarten-Datenwiederherstellungsanwendung</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin { TabController _tabController; final List&lt;Tab&gt; myTabs = &lt;Tab&gt;[ new Tab(text: 'FIRST'), new Tab(text: 'SECOND'), ]; @override void initState() { super.initState(); _tabController = new TabController(vsync: this, length: myTabs.length); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Sample app'), ), body: new TabBarView( controller: _tabController, children: [ new ListView.builder(itemBuilder: ListData().build), Text('Second tab'), ],), bottomNavigationBar: new TabBar( controller: _tabController, tabs: myTabs, labelColor: Colors.blue, ), ); } } class ListData { static ListData _instance = ListData._internal(); ListData._internal(); factory ListData() { return _instance; } Random _rand = Random(); Map&lt;int, int&gt; _values = new Map(); Widget build (BuildContext context, int index) { if (!_values.containsKey(index)) { _values[index] = _rand.nextInt(100); } return Text('Random number ${_values[index]}',); } }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollst√§ndiges Beispiel</a> </p><br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/pk/tu/s1/pktus1ysyqw1xzdhvdr-jdy5o-k.gif"></p></div></div><br><h1 id="sohranenie-pozicii-skrolla">  Speichern einer Bildlaufposition </h1><br><p>  Wenn Sie im vorherigen Beispiel in der Liste nach unten scrollen und dann zwischen den Registerkarten wechseln, ist leicht zu erkennen, dass die Bildlaufposition nicht gespeichert ist.  Dies ist logisch, da es nicht in unserer ListData-Klasse gespeichert ist und der Status des Widgets den Wechsel zwischen Registerkarten nicht √ºberlebt.  Wir implementieren den Speicher f√ºr den Bildlaufstatus manuell, f√ºgen ihn jedoch zum Spa√ü nicht einer separaten Klasse und nicht ListData hinzu, sondern einem Status h√∂herer Ebene, um zu zeigen, wie damit gearbeitet wird. </p><br><p>  Beachten Sie die Widgets ScrollController und NotificationListener (sowie den zuvor verwendeten DefaultTabController).  Das Konzept von Widgets ohne eigene Anzeige sollte Entwicklern, die mit React / Redux arbeiten, vertraut sein - Containerkomponenten werden in diesem Bundle aktiv verwendet.  In Flutter werden h√§ufig Widgets ohne Anzeige verwendet, um untergeordneten Widgets Funktionen hinzuzuf√ºgen.  Auf diese Weise k√∂nnen Sie die visuellen Widgets selbst leicht machen und Systemereignisse nicht dort verarbeiten, wo sie nicht ben√∂tigt werden. </p><br><p>  Der Code basiert auf der von Marcin Sza≈Çek bei Stakoverflow vorgeschlagenen L√∂sung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stackoverflow.com/questions/45341721/flutter-listview-inside-on-a-tabbarview-loses-its-scroll-position</a> ).  Der Plan ist wie folgt: </p><br><ol><li>  F√ºgen Sie der Liste einen ScrollController hinzu, um mit der Bildlaufposition zu arbeiten. </li><li>  F√ºgen Sie der Liste NotificationListener hinzu, um den Bildlaufstatus zu √ºbergeben. </li><li>  Wir speichern die Bildlaufposition in _MyHomePageState (eine Ebene √ºber den Registerkarten) und ordnen sie dem Listenlauf zu. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Anwendung mit gespeicherter Bildlaufposition</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin { double listViewOffset=0.0; TabController _tabController; final List&lt;Tab&gt; myTabs = &lt;Tab&gt;[ new Tab(text: 'FIRST'), new Tab(text: 'SECOND'), ]; @override void initState() { super.initState(); _tabController = new TabController(vsync: this, length: myTabs.length); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Sample app'), ), body: new TabBarView( controller: _tabController, children: [new ListTab( getOffsetMethod: () =&gt; listViewOffset, setOffsetMethod: (offset) =&gt; this.listViewOffset = offset, ), Text('Second tab'), ],), bottomNavigationBar: new TabBar( controller: _tabController, tabs: myTabs, labelColor: Colors.blue, ), ); } } class ListTab extends StatefulWidget { ListTab({Key key, this.getOffsetMethod, this.setOffsetMethod}) : super(key: key); final GetOffsetMethod getOffsetMethod; final SetOffsetMethod setOffsetMethod; @override _ListTabState createState() =&gt; _ListTabState(); } class _ListTabState extends State&lt;ListTab&gt; { ScrollController scrollController; @override void initState() { super.initState(); //Init scrolling to preserve it scrollController = new ScrollController( initialScrollOffset: widget.getOffsetMethod() ); } @override Widget build(BuildContext context) { return NotificationListener( child: new ListView.builder( controller: scrollController, itemBuilder: ListData().build, ), onNotification: (notification) { if (notification is ScrollNotification) { widget.setOffsetMethod(notification.metrics.pixels); } }, ); } }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollst√§ndiges Beispiel</a> </p><br><div class="spoiler">  <b class="spoiler_title">Ergebnis</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rd/me/am/rdmeamzm7c-4jgyc-2qjqbmr9oq.gif"></p></div></div><br><h1 id="perezhivaem-vyklyuchenie-prilozheniya">  Herunterfahren der Anwendung </h1><br><p>  Das Speichern von Informationen f√ºr die Dauer der Anwendung ist gut, aber h√§ufig m√∂chten Sie sie zwischen Sitzungen speichern, insbesondere angesichts der Gewohnheit von Betriebssystemen, Hintergrundanwendungen zu schlie√üen, wenn nicht gen√ºgend Speicher vorhanden ist.  Die Hauptoptionen f√ºr die dauerhafte Datenspeicherung in Flutter sind: </p><br><ol><li>  Shared Preferences ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://pub.dartlang.org/packages/shared_preferences</a> ) ist ein Wrapper f√ºr NSUserDefaults (unter iOS) und SharedPreferences (unter Android) und erm√∂glicht das Speichern einer kleinen Anzahl von Schl√ºssel-Wert-Paaren.  Ideal zum Speichern von Einstellungen. </li><li>  sqflite ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://pub.dartlang.org/packages/sqflite</a> ) ist ein Plugin f√ºr die Arbeit mit SQLite (mit einigen Einschr√§nkungen).  Unterst√ºtzt sowohl Abfragen auf niedriger Ebene als auch Helfer.  In Analogie zu Room k√∂nnen Sie au√üerdem mit Datenbankschemaversionen arbeiten und den Code f√ºr die Aktualisierung des Schemas beim Aktualisieren der Anwendung festlegen. </li><li>  Der Cloud Firestore ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://pub.dartlang.org/packages/cloud_firestore</a> ) ist Teil der offiziellen FireBase-Plugin-Familie. </li></ol><br><p>  Zur Demonstration speichern wir den Bildlaufstatus in den freigegebenen Einstellungen.  F√ºgen Sie dazu die Wiederherstellung der Bildlaufposition hinzu, wenn Sie den Status _MyHomePageState initialisieren und beim Bildlauf speichern. </p><br><p>  Hier m√ºssen wir uns mit dem asynchronen Flutter / Dart-Modell befassen, da alle externen Dienste mit asynchronen Aufrufen arbeiten.  Das Funktionsprinzip dieses Modells √§hnelt dem von node.js - es gibt einen Hauptausf√ºhrungsthread (Thread), der durch asynchrone Aufrufe unterbrochen wird.  Bei jedem nachfolgenden Interrupt (und die Benutzeroberfl√§che macht sie st√§ndig) werden die Ergebnisse abgeschlossener asynchroner Operationen verarbeitet. Gleichzeitig ist es m√∂glich, umfangreiche Berechnungen in Hintergrundthreads auszuf√ºhren (√ºber die Berechnungsfunktion). </p><br><p>  Das Schreiben und Lesen in SharedPreferences erfolgt also asynchron (obwohl die Bibliothek das synchrone Lesen aus dem Cache erm√∂glicht).  Zun√§chst werden wir uns mit dem Lesen befassen.  Der Standardansatz f√ºr den asynchronen Datenabruf sieht folgenderma√üen aus: Starten Sie den asynchronen Prozess und f√ºhren Sie nach Abschluss SetState aus, indem Sie die empfangenen Werte schreiben.  Infolgedessen wird die Benutzeroberfl√§che anhand der empfangenen Daten aktualisiert.  In diesem Fall arbeiten wir jedoch nicht mit Daten, sondern mit der Bildlaufposition.  Wir m√ºssen die Schnittstelle nicht aktualisieren, wir m√ºssen nur die jumpTo-Methode auf dem ScrollController aufrufen.  Das Problem ist, dass das Ergebnis der Verarbeitung einer asynchronen Anforderung jederzeit zur√ºckgegeben werden kann und es nicht unbedingt sein muss, was und wo gescrollt werden soll.  Um sicherzustellen, dass eine Operation an einer vollst√§ndig initialisierten Schnittstelle ausgef√ºhrt wird, m√ºssen wir ... immer noch in setState scrollen. </p><br><p>  Wir bekommen so etwas wie diesen Code: </p><br><div class="spoiler">  <b class="spoiler_title">Statuseinstellung</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> @override void initState() { super.initState(); //Init scrolling to preserve it scrollController = new ScrollController( initialScrollOffset: widget.getOffsetMethod() ); _restoreState().then((double value) =&gt; scrollController.jumpTo(value)); } Future&lt;double&gt; _restoreState() async { SharedPreferences prefs = await SharedPreferences.getInstance(); return prefs.getDouble('listViewOffset'); } void setScroll(double value) { setState(() { scrollController.jumpTo(value); }); }</code> </pre> </div></div><br><p>  Mit der Aufzeichnung ist alles interessanter.  Tatsache ist, dass beim Scrollen st√§ndig Ereignisse auftreten, die dar√ºber berichten.  Das Starten der asynchronen Aufzeichnung bei jeder √Ñnderung des Werts kann zu Anwendungsfehlern f√ºhren.  Wir m√ºssen nur das letzte Ereignis aus der Kette verarbeiten.  In Bezug auf die reaktive Programmierung wird dies als Entprellen bezeichnet und wir werden es verwenden.  Dart unterst√ºtzt die Hauptfunktionen der reaktiven Programmierung √ºber Datenstr√∂me. Daher m√ºssen wir einen Stream aus Aktualisierungen der Bildlaufposition erstellen, ihn abonnieren und mithilfe von Debounce konvertieren.  Zum Konvertieren ben√∂tigen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Bibliothek stream_transform</a> .  Alternativ k√∂nnen Sie RxDart verwenden und in Bezug auf ReactiveX arbeiten. </p><br><p>  Es stellt sich folgender Code heraus: </p><br><div class="spoiler">  <b class="spoiler_title">Statusdatensatz</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> StreamSubscription _stream; StreamController&lt;double&gt; _controller = new StreamController&lt;double&gt;.broadcast(); @override void initState() { super.initState(); _tabController = new TabController(vsync: this, length: myTabs.length); _stream = _controller.stream.transform(debounce(new Duration(milliseconds: 500))).listen(_saveState); } void _saveState(double value) async { SharedPreferences prefs = await SharedPreferences.getInstance(); await prefs.setDouble('listViewOffset', value); }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollst√§ndiges Beispiel</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424765/">https://habr.com/ru/post/de424765/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424753/index.html">Was ist neu in YouTrack 2018.3?</a></li>
<li><a href="../de424755/index.html">Geld liebt die Rechnung: wie Autos Rechnungen sortieren</a></li>
<li><a href="../de424757/index.html">Die Zusammenfassung der Ereignisse f√ºr HR-Fachkr√§fte im Bereich IT im Oktober 2018</a></li>
<li><a href="../de424761/index.html">Einf√ºhrung in das Booten und Booten von Linux-Kerneln</a></li>
<li><a href="../de424763/index.html">Ein Texteditor ist nicht Ihre h√∂chste Mathematik, hier m√ºssen Sie nachdenken</a></li>
<li><a href="../de424767/index.html">Wir machen einen Kuchen aus Habr. Wieder</a></li>
<li><a href="../de424771/index.html">Pers√∂nliche Erfahrung: von einer Idee und einem leeren Blatt bis zu einer Entwurfsversion einer Website</a></li>
<li><a href="../de424773/index.html">Biopharma und numerische Modellierung: Amgen Erfahrung und Praxis</a></li>
<li><a href="../de424777/index.html">Verwenden von Consul zum Skalieren von Stateful Services</a></li>
<li><a href="../de424779/index.html">Mehrseitiges SPA in Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>