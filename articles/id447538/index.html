<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üà∑Ô∏è üë† üî© CUBA 7: Apa yang baru? ü§∞üèæ üíµ ü§ñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tiga tahun lalu, kami mengumumkan rilis CUBA 6 . Versi itu menjadi revolusioner: alih-alih lisensi kepemilikan tertutup, kami mulai mendistribusikan k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CUBA 7: Apa yang baru?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/447538/"><p><img src="https://habrastorage.org/webt/f8/-f/_k/f8-f_kslug-6yzi1yx-ui1e51gy.png"></p><br><p>  Tiga tahun lalu, kami mengumumkan rilis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBA 6</a> .  Versi itu menjadi revolusioner: alih-alih lisensi kepemilikan tertutup, kami mulai mendistribusikan kerangka kerja secara bebas, di bawah lisensi Apache 2.0.  Pada saat itu, kami bahkan tidak dapat memiliki gagasan yang dekat tentang bagaimana ini akan mempengaruhi pengembangan kerangka kerja dalam jangka panjang.  Komunitas CUBA mulai tumbuh secara eksponensial, dan kami dihadapkan dengan semua cara yang mungkin (dan kadang-kadang tidak mungkin) untuk menggunakan kerangka tersebut.  Kami sekarang memperkenalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBA 7</a> .  Kami berharap bahwa versi ini akan membuat pengembangan lebih mudah dan lebih menyenangkan bagi semua anggota komunitas: dari pemula yang baru berkenalan dengan CUBA dan Java, hingga pengembang berpengalaman yang memiliki lebih dari satu proyek selesai di tingkat perusahaan besar. </p><a name="habracut"></a><br><h2 id="instrumenty-razrabotki">  Alat pengembangan </h2><br><p>  Bagian penting dari kesuksesan CUBA, kami berutang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBA Studio</a> .  Lingkungan pengembangan ini telah sangat menyederhanakan pelaksanaan tugas-tugas khas yang dilakukan di setiap proyek Java, mengurangi mereka untuk membuat konfigurasi sederhana dalam desainer visual.  Anda tidak perlu tahu semua atribut anotasi API Persisten, sintaks Gradle atau seluk-beluk konfigurasi Spring untuk mengembangkan aplikasi CRUD yang lengkap dan kaya fitur - CUBA Studio menangani pembuatan kode khas. </p><br><p><img src="https://habrastorage.org/webt/lr/5f/8g/lr5f8gtzh5ls_zvskmqccmrccpc.png"></p><br><p>  Studio adalah aplikasi web terpisah, yang menyebabkan sejumlah batasan signifikan: </p><br><ul><li>  Pertama, Studio bukan IDE yang lengkap, sehingga pengembang harus beralih antara Studio dan IntelliJ IDEA atau Eclipse untuk mengembangkan logika bisnis dan pada saat yang sama menggunakan navigasi yang nyaman, penyelesaian kode dan hal-hal lain yang diperlukan, yang agak mengganggu. </li><li>  Kedua, semua kesederhanaan ajaib ini dibangun di atas sejumlah besar pekerjaan yang kami habiskan untuk menulis algoritma untuk parsing dan menghasilkan kode sumber.  Menerapkan fungsionalitas yang lebih maju akan berarti pindah ke pengembangan IDE penuh - terlalu ambisius untuk kita. </li></ul><br><p>  Kami memutuskan untuk mengandalkan raksasa lain untuk mengatasi keterbatasan ini dan membangun Studio berdasarkan IntelliJ IDEA.  Sekarang Anda dapat menginstal Studio baik sebagai aplikasi mandiri (IntelliJ IDEA Bundle), dan sebagai plug-in untuk IDEA. </p><br><p><img src="https://habrastorage.org/webt/bh/qk/kg/bhqkkgmeebyr6fjyecadq1ln_cm.png"></p><br><p>  Dan ini memberi kita peluang baru: </p><br><ul><li>  Dukungan untuk bahasa JVM lainnya (dan, yang terpenting, Kotlin) </li><li>  Superior Hot deploy </li><li>  Navigasi seluruh proyek yang intuitif </li><li>  Petunjuk yang lebih cerdas dan generator kode </li></ul><br><p> Saat ini, kami secara aktif mengembangkan versi baru Studio - kami mentransfer fungsionalitas dari versi lama dan menambahkan hal-hal baru menggunakan fungsi platform IntelliJ.  Dalam waktu dekat - terjemahan editor khusus CUBA ke komponen IntelliJ dan meningkatkan navigasi melalui kode proyek. </p><br><h2 id="obnovlenie-tehnologicheskogo-steka">  Pembaruan Teknologi Stack </h2><br><p>  Secara tradisional, tumpukan teknologi di inti CUBA telah diperbarui ke versi baru: Java 8/11, Vaadin 8, Spring 5. </p><br><p>  Secara default, proyek baru menggunakan Java 8, tetapi Anda bisa menentukan versi Java dengan menambahkan kode berikut ke file build.gradle: </p><br><pre><code class="plaintext hljs">subprojects { sourceCompatibility = JavaVersion.VERSION_11 targetCompatibility = JavaVersion.VERSION_11 }</code> </pre> <br><p>  Masalah yang sangat besar adalah peningkatan ke Vaadin 8, di mana API pengikat data telah banyak berubah.  Untungnya, CUBA melindungi pengembang dari komponen internal Vaadin, membungkusnya dengan API mereka sendiri.  Tim CUBA melakukan pekerjaan yang baik untuk memperbarui komponen internal tanpa mengubah API CUBA.  Ini berarti kompatibilitas sepenuhnya terpelihara, dan Anda dapat memanfaatkan semua fitur baru Vaadin 8 segera setelah memigrasi proyek ke CUBA 7, tanpa melakukan refactoring apa pun. </p><br><p>  Daftar lengkap dependensi yang diperbarui tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar perubahan</a> . </p><br><h2 id="novyy-api-ekranov">  API layar baru </h2><br><p>  Bagian ini mungkin disebut "API layar pertama", karena CUBA tidak pernah memiliki API layar yang diumumkan secara resmi dalam modul klien web.  Ini terjadi secara historis, termasuk karena beberapa asumsi yang muncul pada tahap awal: </p><br><ul><li>  Pendekatan yang berorientasi deklaratif - segala sesuatu yang dapat dideskripsikan secara deklaratif harus dideklarasikan dalam deskriptor layar, dan bukan dalam kode pengontrol. </li><li>  Layar standar (browser dan editor) menyediakan fungsionalitas umum tertentu, dan tidak perlu mengubahnya. </li></ul><br><p><img src="https://habrastorage.org/webt/vd/ym/le/vdymlejgwnh3eco6adm3ly5smmi.png"></p><br><p>  Pada saat seribu anggota pertama bergabung dengan komunitas kami, kami menyadari berapa banyak persyaratan yang berbeda yang ditempatkan pada layar CRUD "standar".  Dan semua persyaratan ini jauh melampaui fungsi awal.  Namun, untuk waktu yang lama kami dapat memenuhi permintaan untuk menerapkan perilaku layar atipikal tanpa mengubah API - berkat prinsip arsitektur lain yang ditetapkan pada tahap awal: Buka Warisan.  Faktanya, Open Inheritance berarti Anda dapat menulis ulang metode umum atau terlindung dari kelas utama untuk menyesuaikan perilakunya sesuai dengan kebutuhan Anda.  Ini mungkin tampak seperti obat mujarab yang ajaib, tetapi sebenarnya Anda tidak bisa mengandalkannya bahkan dalam jangka pendek.  Bagaimana jika metode yang diganti diganti, dihapus, atau tidak pernah digunakan dalam versi kerangka kerja yang akan datang? </p><br><p>  Jadi sebagai tanggapan terhadap permintaan komunitas yang berkembang, kami memutuskan untuk memperkenalkan API layar baru.  API ini memberikan poin ekstensi yang jelas (tanpa sihir tersembunyi), fleksibel dan mudah digunakan yang dijamin tidak akan berubah untuk waktu yang lama. </p><br><h3 id="deklaraciya-ekranov">  Deklarasi layar </h3><br><p>  Di CUBA 7, mendeklarasikan layar sangat sederhana: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@UiController</span></span>(<span class="hljs-string"><span class="hljs-string">"new-screen"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// screen id public class NewScreen extends Screen { }</span></span></code> </pre> <br><p>  Contoh di atas menunjukkan bahwa pengidentifikasi layar secara eksplisit didefinisikan langsung di atas deklarasi kelas controller.  Dengan kata lain, ID layar dan kelas pengontrol sekarang cocok satu sama lain dengan cara yang unik.  Jadi, kami memiliki kabar baik: sekarang Anda dapat dengan aman mengakses layar langsung berdasarkan jenis pengontrol: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ScreenBuilders screenBuilders; <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBeforeClose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BeforeCloseEvent event)</span></span></span><span class="hljs-function"> </span></span>{ screenBuilders.screen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .withScreenClass(SomeConfirmationScreen.class) .build() .show(); }</code> </pre> <br><p>  Deskriptor layar menjadi bagian opsional dari layar.  UI dapat dibuat secara terprogram atau dideklarasikan sebagai deskriptor layar xml, yang ditentukan oleh anotasi <code>@UiDescriptor</code> pada kelas controller.  Ini membuat pengontrol dan markup jauh lebih mudah dibaca dan dipahami - pendekatan ini sangat mirip dengan yang digunakan dalam pengembangan Android. </p><br><p>  Sebelumnya, itu juga perlu mendaftarkan pegangan layar di file web-screens.xml dan menetapkannya sebagai pengidentifikasi.  Di CUBA 7, file ini disimpan untuk tujuan kompatibilitas, tetapi cara baru untuk membuat layar tidak memerlukan pendaftaran tersebut. </p><br><h3 id="zhiznennyy-cikl-ekrana">  Siklus hidup layar </h3><br><p>  API baru memperkenalkan acara siklus hidup layar sederhana dan jelas: </p><br><ul><li>  Init </li><li>  Setelah itu </li><li>  Di depan </li><li>  Entah bagaimana </li><li>  Sebelum ditutup </li><li>  Setelah ditutup </li></ul><br><p>  Anda dapat berlangganan semua acara di CUBA 7 sebagai berikut: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@UiController</span></span>(<span class="hljs-string"><span class="hljs-string">"new-screen"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewScreen</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InitEvent event)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBeforeShow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BeforeShowEvent event)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre> <br><p>  Dibandingkan dengan pendekatan lama, API baru menunjukkan bahwa kami tidak tumpang tindih dengan metode hook yang secara implisit dipanggil saat inisialisasi, tetapi secara eksplisit menentukan logika untuk memproses peristiwa siklus hidup layar spesifik dan spesifik. </p><br><h3 id="obrabotka-sobytiy-i-funkcionalnye-delegaty">  Penanganan Acara dan Delegasi Fungsional </h3><br><p>  Di bagian sebelumnya, kami belajar cara berlangganan acara siklus hidup, tetapi bagaimana dengan komponen lainnya?  Apakah masih perlu untuk menuangkan semua pendengar yang diperlukan ke tumpukan yang sama ketika menginisialisasi layar, dalam metode init (), seperti pada versi 6.x?  API baru ini cukup konsisten, sehingga Anda dapat berlangganan ke acara lain dengan cara yang sama seperti pada acara kehidupan layar. </p><br><p>  Pertimbangkan contoh sederhana dengan dua elemen UI: tombol dan bidang untuk menampilkan jumlah uang dalam mata uang tertentu;  Deskriptor XML akan terlihat seperti ini: </p><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">window</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.haulmont.com/cuba/screen/window.xsd"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">caption</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"msg://caption"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">messagesPack</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.company.demo.web"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hbox</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">spacing</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">currencyField</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"currencyField"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">currency</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">currencyLabelPosition</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"LEFT"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"calcPriceBtn"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">caption</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Calculate Price"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hbox</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">window</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Ketika Anda mengklik tombol, kami memanggil layanan dari backend, yang mengembalikan nomor, kami menuliskannya di bidang jumlah.  Bidang ini harus mengubah gaya tergantung pada nilai harga. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@UiController</span></span>(<span class="hljs-string"><span class="hljs-string">"demo_MyFirstScreen"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@UiDescriptor</span></span>(<span class="hljs-string"><span class="hljs-string">"my-first-screen.xml"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFirstScreen</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PricingService pricingService; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CurrencyField&lt;BigDecimal&gt; currencyField; <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span>(<span class="hljs-string"><span class="hljs-string">"calcPriceBtn"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCalcPriceBtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Button.ClickEvent event)</span></span></span><span class="hljs-function"> </span></span>{ currencyField.setValue(pricingService.calculatePrice()); } <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span>(<span class="hljs-string"><span class="hljs-string">"currencyField"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPriceChange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HasValue.ValueChangeEvent&lt;BigDecimal&gt; event)</span></span></span><span class="hljs-function"> </span></span>{ currencyField.setStyleName(getStyleNameByPrice(event.getValue())); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStyleNameByPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal price)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p>  Dalam contoh di atas, kita melihat dua pengendali acara: satu dipanggil ketika tombol ditekan, dan yang lainnya diluncurkan ketika bidang mata uang mengubah nilainya - semuanya sederhana. </p><br><p>  Sekarang bayangkan kita perlu memeriksa harga dan memastikan nilainya positif.  Ini bisa dilakukan "dahi" - tambahkan validator selama inisialisasi layar: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@UiController</span></span>(<span class="hljs-string"><span class="hljs-string">"demo_MyFirstScreen"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@UiDescriptor</span></span>(<span class="hljs-string"><span class="hljs-string">"my-first-screen.xml"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFirstScreen</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CurrencyField&lt;BigDecimal&gt; currencyField; <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InitEvent event)</span></span></span><span class="hljs-function"> </span></span>{ currencyField.addValidator(value -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.compareTo(BigDecimal.ZERO) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValidationException(<span class="hljs-string"><span class="hljs-string">"Price should be greater than zero"</span></span>); }); } }</code> </pre> <br><p>  Dalam aplikasi nyata, setelah beberapa waktu metode inisialisasi akan menjadi kekacauan inisialisasi, validator, pendengar, dll.  Untuk mengatasi masalah ini, CUBA memiliki anotasi <code>@Install</code> berguna.  Mari kita lihat bagaimana ini dapat membantu dalam kasus kami: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@UiController</span></span>(<span class="hljs-string"><span class="hljs-string">"demo_MyFirstScreen"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@UiDescriptor</span></span>(<span class="hljs-string"><span class="hljs-string">"my-first-screen.xml"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFirstScreen</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CurrencyField&lt;BigDecimal&gt; currencyField; <span class="hljs-meta"><span class="hljs-meta">@Install</span></span>(to = <span class="hljs-string"><span class="hljs-string">"currencyField"</span></span>, subject = <span class="hljs-string"><span class="hljs-string">"validator"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">currencyFieldValidator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.compareTo(BigDecimal.ZERO) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValidationException(<span class="hljs-string"><span class="hljs-string">"Price should be greater than zero"</span></span>); } }</code> </pre> <br><p>  Bahkan, kami mendelegasikan logika validasi bidang mata uang ke metode currencyFieldValidator di layar.  Ini mungkin tampak sedikit rumit pada pandangan pertama, tetapi para pengembang dengan cepat terbiasa dengan metode penambahan fungsi ini dan segera mulai menggunakannya. </p><br><h3 id="postroiteli-ekranov-notifikacii-dialogi">  Pembuat layar, notifikasi, dialog </h3><br><p><img src="https://habrastorage.org/webt/mo/ni/n-/monin-pixoctyntukkkflsdgvc4.png"></p><br><p>  CUBA 7 memiliki serangkaian komponen yang berguna dengan API yang nyaman: </p><br><ul><li>  <strong>ScreenBuilders</strong> menggabungkan pabrik yang fasih untuk membuat layar standar untuk melihat dan mengedit entitas, serta layar khusus.  Contoh di bawah ini menunjukkan bagaimana Anda dapat membuka satu layar dari yang lain.  Perhatikan bahwa metode build () segera mengembalikan layar dari jenis yang diinginkan tanpa perlu pemain: <br><pre> <code class="java hljs">CurrencyConversions currencyConversions = screenBuilders.screen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .withScreenClass(CurrencyConversions.class) .withLaunchMode(OpenMode.DIALOG) .build(); currencyConversions.setBaseCurrency(Currency.EUR); currencyConversions.show();</code> </pre> </li><li>  Komponen <strong>Layar</strong> menyediakan tingkat abstraksi yang lebih rendah untuk membuat dan menampilkan layar, tidak seperti <em>API ScreenBuilders</em> .  Ini juga menyediakan akses ke informasi tentang semua layar terbuka di aplikasi CUBA Anda ( <em>Layar # getOpenedScreens</em> ), jika Anda tiba-tiba harus melalui semuanya dalam satu siklus. </li><li>  Komponen <strong>Notifikasi</strong> dan <strong>Dialog</strong> menyediakan API yang mudah didokumentasikan sendiri dan praktis.  Berikut ini adalah contoh membuat dan menampilkan kotak dialog dan pemberitahuan: <br><pre> <code class="java hljs">dialogs.createOptionDialog() .withCaption(<span class="hljs-string"><span class="hljs-string">"My first dialog"</span></span>) .withMessage(<span class="hljs-string"><span class="hljs-string">"Would you like to thank CUBA team?"</span></span>) .withActions( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DialogAction(DialogAction.Type.YES).withHandler(e -&gt; notifications.create() .withCaption(<span class="hljs-string"><span class="hljs-string">"Thank you!"</span></span>) .withDescription(<span class="hljs-string"><span class="hljs-string">"We appreciate all community members"</span></span>) .withPosition(Notifications.Position.MIDDLE_CENTER) .withHideDelayMs(<span class="hljs-number"><span class="hljs-number">3000</span></span>) .show()), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DialogAction(DialogAction.Type.CANCEL) ) .show();</code> </pre> </li></ul><br><h3 id="privyazka-dannyh">  Pengikatan data </h3><br><p>  CUBA menyediakan pengembangan antarmuka pengguna yang sangat cepat untuk back office, tidak hanya dengan alat pengembangan visual canggih dan sistem pembuatan kode yang kuat, tetapi juga dengan serangkaian komponen kaya yang tersedia langsung di luar kotak.  Komponen-komponen ini hanya perlu mengetahui data apa yang mereka kerjakan, dan sisanya akan dilakukan secara otomatis.  Misalnya, daftar drop-down, kalender, tabel dengan operasi CRUD bawaan, dan sebagainya. </p><br><p>  Sebelum versi 7, pengikatan data dilakukan melalui apa yang disebut sumber data - objek yang membungkus satu atau lebih entitas untuk pengikatan reaktifnya terhadap komponen.  Pendekatan ini bekerja dengan sangat baik, tetapi dalam hal implementasi, itu adalah monolit.  Arsitektur monolitik biasanya bermasalah untuk dikonfigurasi, sehingga dalam CUBA 7 batu besar ini dibagi menjadi tiga komponen untuk bekerja dengan data: </p><br><ul><li>  Pemuat data adalah penyedia data untuk wadah data.  Loader tidak menyimpan data, ia hanya meneruskan semua parameter kueri yang diperlukan ke gudang data dan menempatkan data yang dihasilkan dalam wadah data. </li><li>  Wadah data menyimpan data yang dimuat (satu entitas atau lebih) dan memberikannya kepada komponen data: semua perubahan dalam entitas ini ditransfer ke komponen yang sesuai, dan sebaliknya, semua perubahan dalam komponen akan mengarah ke perubahan yang sesuai pada entitas yang terletak di dalam wadah data. </li><li>  Datacontext (konteks data) adalah kelas yang melacak perubahan dan menyimpan semua entitas yang diubah.  Entitas yang dipantau ditandai sebagai kotor setiap kali atributnya berubah, dan DataContext menyimpan instance yang kotor di Middleware ketika metode commit () dipanggil. </li></ul><br><p>  Dengan demikian, ada fleksibilitas dalam bekerja dengan data.  Contoh buatan: loader dapat memilih data di UI dari RDBMS, dan konteksnya dapat menyimpan perubahan ke layanan REST. </p><br><p>  Dalam CUBA 6.x, Anda harus menulis sumber data Anda sendiri untuk ini, yang dapat bekerja dengan RDBMS dan REST.  Di CUBA 7, Anda dapat mengambil loader standar yang dapat bekerja dengan database dan hanya menulis implementasi konteksnya untuk bekerja dengan REST. </p><br><p>  Komponen untuk bekerja dengan data dapat dideklarasikan dalam deskriptor layar atau dibuat secara terprogram menggunakan pabrik khusus - DataComponents. </p><br><h3 id="prochee">  Lainnya </h3><br><p>  Uff ... Bagian terpenting dari API di layar yang baru dijelaskan, jadi mari kita daftarkan secara singkat fungsi-fungsi penting lainnya di tingkat klien web: </p><br><ul><li>  <strong>Riwayat URL dan navigasi</strong> .  Fungsi ini memecahkan masalah SPA yang sangat umum - perilaku tombol kembali di browser web tidak selalu benar.  Sekarang menyediakan cara mudah untuk menetapkan rute ke layar aplikasi dan memungkinkan API untuk menampilkan kondisi layar saat ini dalam URL. </li><li>  <strong>Bentuk bukan FieldGroup</strong> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FieldGroup</a> adalah komponen untuk menampilkan dan mengubah bidang dari satu entitas.  Ini menampilkan UI untuk bidang dalam runtime.  Dengan kata lain, jika entitas memiliki bidang Tanggal, itu akan ditampilkan sebagai <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DateField</a></em> .  Namun, jika Anda ingin bekerja dengan bidang ini secara terprogram, Anda harus memasukkannya ke pengontrol layar dan secara manual melemparkannya ke jenis yang benar ( <em>DateField dalam contoh kami</em> ).  Jika nanti kita mengubah jenis bidang ke bidang lainnya, maka aplikasi kita akan macet saat runtime.  Formulir memecahkan masalah ini dengan secara eksplisit mendeklarasikan tipe bidang.  Informasi lebih lanjut tentang komponen dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </li><li>  <strong>Integrasi komponen JavaScript pihak ketiga</strong> sangat disederhanakan, baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> tentang penyematan komponen JavaScript khusus dalam aplikasi CUBA. </li><li>  Atribut <strong>HTML / CSS</strong> sekarang dapat dengan mudah didefinisikan langsung dari deskriptor layar xml atau diatur secara terprogram.  Informasi lebih lanjut dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </li></ul><br><h2 id="novye-vozmozhnosti-bekend-modulya">  Fitur baru dari modul backend </h2><br><p>  Bagian sebelumnya pada layar API baru ternyata lebih dari yang saya harapkan, jadi di bagian ini saya akan singkat. </p><br><h3 id="sobytie-entity-changed">  Entitas Berubah Peristiwa </h3><br><p>  Acara Entity Changed adalah acara di aplikasi Musim Semi yang menyala saat entitas memasuki penyimpanan data, ditempatkan secara fisik, dan satu langkah lagi dari komit.  Saat memproses acara ini, Anda dapat mengonfigurasi cek tambahan (misalnya, memeriksa ketersediaan barang di gudang sebelum mengonfirmasi pesanan) dan mengubah data (misalnya, menghitung ulang total) tepat sebelum terlihat oleh transaksi lain (tentu saja, jika Anda memiliki level baca isolasi yang dilakukan).  Acara ini juga dapat menjadi kesempatan terakhir untuk membatalkan transaksi dengan melemparkan pengecualian, yang mungkin berguna dalam beberapa kasus rumit. </p><br><p>  Ada juga cara untuk menangani acara Entity Changed segera setelah komit. </p><br><p>  Anda dapat melihat contoh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bab dokumentasi ini</a> . </p><br><h3 id="tranzakcionnyy-menedzher-dannyh">  Manajer data transaksional </h3><br><p>  Saat mengembangkan aplikasi, kami biasanya bekerja dengan entitas terpisah - entitas yang tidak dalam konteks transaksi apa pun.  Namun, bekerja dengan entitas yang terpisah tidak selalu mungkin, terutama ketika Anda harus sepenuhnya mematuhi persyaratan ACID - ini adalah kasus ketika Anda dapat menggunakan manajer data transaksional.  Ia sangat mirip dengan manajer biasa, tetapi berbeda dalam aspek-aspek berikut: </p><br><ul><li>  Dia dapat bergabung dengan transaksi yang ada (dipanggil dalam konteks transaksi ini) atau membuat transaksi sendiri. </li><li>  Itu tidak memiliki metode komit, tetapi ada metode save yang tidak langsung melakukan, tetapi menunggu transaksi saat ini untuk berkomitmen. </li></ul><br><p>  Berikut ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> penggunaannya. </p><br><h3 id="obratnye-vyzovy-jpa">  Callback JPA </h3><br><p>  Akhirnya, CUBA 7 mendukung panggilan balik JPA.  Agar tidak mengulangi materi yang diketahui untuk apa callback ini dapat digunakan, saya hanya meninggalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan di</a> sini.  Dalam materi ini, topik panggilan balik sepenuhnya diungkapkan. </p><br><h2 id="kak-naschet-sovmestimosti">  Bagaimana dengan kompatibilitas? </h2><br><p><img src="https://habrastorage.org/webt/tk/fu/lb/tkfulbguaccnmhsisnhgsgepteg.png"></p><br><p>  Sebuah pertanyaan yang wajar untuk setiap rilis besar, terutama ketika ada begitu banyak perubahan kritis!  Kami mengembangkan semua fitur dan API baru ini dengan kompatibilitas ke belakang: </p><br><ul><li>  API lama didukung di CUBA 7 dan diimplementasikan melalui yang baru di bawah tenda :) </li><li>  Kami juga menyediakan adaptor untuk pengikatan data melalui API lama.  Adaptor ini akan bekerja dengan sempurna untuk layar yang dibuat sesuai dengan skema lama. </li></ul><br><p>  Berita baiknya adalah proses migrasi dari versi 6 ke 7 seharusnya cukup sederhana. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Sebagai penutup tinjauan teknis, saya ingin mencatat bahwa ada inovasi penting lainnya, terutama di bidang perizinan: </p><br><ul><li>  Batas 10 entitas untuk Studio sekarang dihapus </li><li>  Add-on untuk Pelaporan, BPM, Bagan dan Peta, dan pencarian teks lengkap sekarang gratis dan open source. </li><li>  Versi komersial Studio menambah pengembangan kenyamanan dengan bantuan desainer visual dari entitas, layar, menu, dan elemen platform lainnya, dan versi gratisnya difokuskan untuk bekerja dengan kode. </li><li>  Harap dicatat bahwa untuk versi 6.x dan versi sebelumnya, ketentuan lisensi untuk Platform dan Studio tetap sama! </li></ul><br><p>  Akhirnya, izinkan saya sekali lagi berterima kasih kepada komunitas atas dukungan dan umpan balik mereka.  Saya harap Anda menyukai versi 7!  Informasi lengkap tersedia secara tradisional di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">changelog</a> resmi. <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447538/">https://habr.com/ru/post/id447538/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447528/index.html">Siapa yang bertanggung jawab atas kualitas?</a></li>
<li><a href="../id447530/index.html">OceanLotus: Pembaruan Malvari untuk macOS</a></li>
<li><a href="../id447532/index.html">Splunk Universal Forwarder di Docker sebagai pengumpul log sistem</a></li>
<li><a href="../id447534/index.html">Cosmonaut Aleksandr Laveykin tentang film ruang angkasa terbaik, G-force 20g, dan soft landing</a></li>
<li><a href="../id447536/index.html">Terapkan IdM. Persiapan untuk implementasi oleh pelanggan</a></li>
<li><a href="../id447540/index.html">RHEL 8 Beta Workshop: Membangun Aplikasi Web Langsung</a></li>
<li><a href="../id447542/index.html">Perkiraan VaR dan KonVaR untuk harga saham perusahaan Kazakhstani</a></li>
<li><a href="../id447546/index.html">Bowers & Wilkins PX. Review Neo Terlambat</a></li>
<li><a href="../id447548/index.html">Bagaimana dibenarkannya pengenalan VDI di perusahaan kecil dan menengah?</a></li>
<li><a href="../id447552/index.html">Cara mengoptimalkan bagian katalog di toko online: petunjuk langkah demi langkah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>