<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è∫Ô∏è ü•© üíø Octet-machine pour le fort (et pas seulement) en am√©rindien (partie 3) ‚è∞ ‚óÄÔ∏è üéã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'ann√©e 2019 est arriv√©e, les f√™tes de fin d'ann√©e s'ach√®vent. Il est temps de commencer √† se souvenir des octets, des commandes, des variables, des b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Octet-machine pour le fort (et pas seulement) en am√©rindien (partie 3)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435236/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="image"><br><br>  L'ann√©e 2019 est arriv√©e, les f√™tes de fin d'ann√©e s'ach√®vent.  Il est temps de commencer √† se souvenir des octets, des commandes, des variables, des boucles ... <br><br>  Quelque chose que j'ai d√©j√† oubli√© avec ces vacances.  Faut se souvenir ensemble! <br><br>  Aujourd'hui, nous allons faire un interpr√®te pour notre machine d'octets.  Ceci est le troisi√®me article, les premi√®res parties sont ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 2</a> . <br><br>  Bonne ann√©e √† tous et bienvenue dans la coupe! <br><a name="habracut"></a><br>  Pour commencer, je r√©pondrai aux questions de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">fpauk</a> .  Ces questions sont absolument correctes.  Maintenant, l'architecture de cette machine d'octets est telle que nous travaillons avec des adresses de processeur directes.  Mais dans le bytecode, ces adresses ne le sont pas, elles sont form√©es apr√®s le d√©marrage du syst√®me.  Apr√®s le d√©marrage du syst√®me, nous pouvons cr√©er des pointeurs et ce code fonctionnera correctement sur n'importe quelle plate-forme.  Par exemple, l'adresse d'une variable ou d'un tableau peut √™tre obtenue avec la commande var0.  Cette commande fonctionnera sur n'importe quelle plateforme et renverra l'adresse correcte sp√©cifique √† cette plateforme.  Ensuite, vous pouvez travailler avec cette adresse comme vous le souhaitez. <br><br>  Mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">quand</a> m√™me, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">fpauk a</a> raison.  L'adresse ne peut pas √™tre stock√©e en bytecode.  Il s'av√®re que nous pouvons √©crire du code ind√©pendant de la plate-forme, mais pour cela, nous devons faire des efforts.  Assurez-vous en particulier que les adresses ne figurent pas dans le bytecode.  Et ils peuvent entrer, par exemple, si vous enregistrez le code compil√© dans un fichier.  Il contiendra des donn√©es et il peut s'agir d'adresses.  Par exemple, les valeurs des variables ici, le contexte et autres. <br><br>  Pour vous d√©barrasser d'un tel probl√®me, vous devez rendre les adresses virtuelles.  L'adressage du processeur x86 est assez puissant et, dans la plupart des cas, il n'ajoutera m√™me pas de commandes suppl√©mentaires.  Mais quand m√™me, je vais continuer dans l'architecture actuelle, avec des adresses absolues.  Et puis, lorsque nous arriverons aux tests, il sera possible de refaire les adresses en adresses virtuelles, et de voir comment cela affectera les performances.  C'est int√©ressant. <br><br><h4>  R√©chauffer </h4><br>  Et maintenant un petit entra√Ænement.  Faisons une autre partie de commandes d'octets petites mais utiles.  Ce seront les commandes nip, emit, 1+, +!, -!, Count, mots de travail avec la pile de retour r&gt;,&gt; r, r @, un litt√©ral de cha√Æne (") et des mots constants 1, 2, 3, 4, 8. N'oubliez pas de les inclure dans le tableau des commandes. <br><br><div class="spoiler">  <b class="spoiler_title">Voici le code de ces commandes</b> <div class="spoiler_text"><pre><code class="cpp hljs">b_nip = <span class="hljs-number"><span class="hljs-number">0x39</span></span> bcmd_nip: pop rax mov [rsp], rax jmp _next b_emit = <span class="hljs-number"><span class="hljs-number">0x81</span></span> bcmd_emit: pop rax mov rsi, offset emit_buf #   mov [rsi], al mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov rdx, <span class="hljs-number"><span class="hljs-number">1</span></span> #   push r8 syscall #   pop r8 jmp _next b_wp = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_wp: incq [rsp] jmp _next b_setp = <span class="hljs-number"><span class="hljs-number">0x48</span></span> bcmd_setp: pop rcx pop rax add [rcx], rax jmp _next b_setm = <span class="hljs-number"><span class="hljs-number">0x49</span></span> bcmd_setm: pop rcx pop rax sub [rcx], rax jmp _next b_2r = <span class="hljs-number"><span class="hljs-number">0x60</span></span> bcmd_2r: pop rax sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], rax jmp _next b_r2 = <span class="hljs-number"><span class="hljs-number">0x61</span></span> bcmd_r2: push [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next b_rget = <span class="hljs-number"><span class="hljs-number">0x62</span></span> bcmd_rget: push [rbp] jmp _next b_str = <span class="hljs-number"><span class="hljs-number">0x82</span></span> bcmd_str: movzx rax, byte ptr [r8] lea r8, [r8 + rax + <span class="hljs-number"><span class="hljs-number">1</span></span>] jmp _next b_count = <span class="hljs-number"><span class="hljs-number">0x84</span></span> bcmd_count: pop rcx movzx rax, byte ptr [rcx] inc rcx push rcx push rax jmp _next b_num1 = <span class="hljs-number"><span class="hljs-number">0x03</span></span> bcmd_num1: push <span class="hljs-number"><span class="hljs-number">1</span></span> jmp _next b_num2 = <span class="hljs-number"><span class="hljs-number">0x04</span></span> bcmd_num2: push <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next b_num3 = <span class="hljs-number"><span class="hljs-number">0x05</span></span> bcmd_num3: push <span class="hljs-number"><span class="hljs-number">3</span></span> jmp _next b_num4 = <span class="hljs-number"><span class="hljs-number">0x06</span></span> bcmd_num4: push <span class="hljs-number"><span class="hljs-number">4</span></span> jmp _next b_num8 = <span class="hljs-number"><span class="hljs-number">0x07</span></span> bcmd_num8: push <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre> <br></div></div><br>  La commande nip supprime le mot sous le haut de la pile.  Cela √©quivaut √† √©changer des commandes de d√©p√¥t.  Cela peut parfois √™tre utile. <br><br>  La commande emit repousse un caract√®re de la pile.  Il utilise le m√™me num√©ro d'appel syst√®me 1, le caract√®re place dans un tampon d'une longueur de 1. <br><br>  La commande count est tr√®s simple - elle prend l'adresse de la ligne avec le compteur de la pile et la transforme en deux valeurs - l'adresse de la ligne sans le compteur et la longueur. <br><br>  Les commandes b_2r, b_r2, b_rget sont les mots Fort r&gt;,&gt; r, r @.  Le premier prend le mot de la pile de retour et le place sur la pile arithm√©tique.  Le second effectue l'op√©ration inverse.  Le troisi√®me copie le mot de la pile de retour, le place dans l'arithm√©tique, la pile de retour ne change pas. <br><br>  Les commandes b_setp et b_setm sont les mots +!  et -! .. Ils prennent la valeur et l'adresse de la pile, et modifient le mot √† l'adresse sp√©cifi√©e, ajoutant ou supprimant la valeur de la pile. <br><br>  La commande b_str a un param√®tre de longueur arbitraire - une ligne avec un compteur.  Cette ligne est dans le bytecode apr√®s l'octet de commande, et la commande pousse simplement l'adresse de cette ligne sur la pile.  En fait, il s'agit d'un litt√©ral de cha√Æne. <br><br>  Le reste de l'√©quipe, je pense, n'a pas besoin de commentaires. <br><br>  Nous allons √©galement cr√©er une commande pour imprimer une cha√Æne constante (. "). Nous l'impl√©menterons comme point d'entr√©e √† taper, comme suit: <br><br><pre> <code class="cpp hljs">b_strp = <span class="hljs-number"><span class="hljs-number">0x83</span></span> bcmd_strp: movsx rax, byte ptr [r8] inc r8 push rax push r8 add r8, rax b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx #   pop rsi #   push r8 syscall #   pop r8 jmp _next</code> </pre><br>  Cette commande est structur√©e de mani√®re similaire √† b_str.  Seulement, elle ne met rien sur la pile.  La ligne situ√©e derri√®re cette commande en tant que param√®tre est simplement affich√©e √† l'utilisateur. <br><br>  L'√©chauffement est termin√©, le moment est venu pour quelque chose de plus grave.  Voyons les g√©n√©rateurs de mots et les autres commandes var. <br><br><h4>  Mots g√©n√©rateurs </h4><br>  Rappelez les variables.  Nous savons comment ils sont organis√©s au niveau du bytecode (commande var0).  Pour cr√©er une nouvelle variable, le fort utilise la construction suivante: <br><br><pre> <code class="cpp hljs">variable &lt; &gt;</code> </pre><br>  Apr√®s avoir ex√©cut√© cette s√©quence, un nouveau mot &lt;nom de variable&gt; est cr√©√©.  L'ex√©cution de ce nouveau mot pousse l'adresse sur la pile pour stocker la valeur de la variable.  Il y a aussi des constantes dans le fort, elles sont cr√©√©es comme ceci: <br><br><pre> <code class="cpp hljs">&lt;&gt; constant &lt; &gt;</code> </pre><br>  Apr√®s avoir cr√©√© la constante, l'ex√©cution du mot &lt;nom constant&gt; place sur la pile &lt;valeur&gt;. <br><br>  Ainsi, √† la fois la variable de mot et la constante de mot sont des mots g√©n√©rateurs.  Ils sont con√ßus pour cr√©er de nouveaux mots.  Dans un fort, ces mots sont d√©crits √† l'aide de la construction create ... does&gt;. <br><br>  Les variables et constantes peuvent √™tre d√©finies comme suit: <br><br><pre> <code class="cpp hljs">: variable create <span class="hljs-number"><span class="hljs-number">0</span></span> , does&gt; ; : constant create , does&gt; @ ;</code> </pre><br>  Qu'est-ce que tout cela signifie? <br><br>  Le mot create, une fois ex√©cut√©, cr√©e un nouveau mot avec le nom qu'il prendra lorsqu'il sera ex√©cut√© √† partir du flux d'entr√©e.  Apr√®s la cr√©ation, une s√©quence de mots est ex√©cut√©e avant le mot&gt;.  Mais au moment de l'ex√©cution de ce mot, ce qui est √©crit apr√®s est ex√©cut√©.  En m√™me temps, l'adresse de donn√©es sera d√©j√† sur la pile (comme on dit dans le fort, ¬´champs de donn√©es¬ª). <br><br>  Ainsi, lors de la cr√©ation d'une variable, la s√©quence ¬´0¬ª est ex√©cut√©e - il s'agit de la r√©servation d'un mot machine √† remplissage nul.  Et lorsque le mot cr√©√© est ex√©cut√©, rien n'est fait (apr√®s le fait&gt; il n'y a rien).  L'adresse m√©moire o√π la valeur est stock√©e reste simplement sur la pile. <br><br>  Dans la d√©finition d'une constante, un mot avec une valeur de remplissage sur la pile est r√©serv√©.  Lorsque le mot cr√©√© est ex√©cut√©, "@" est ex√©cut√©, ce qui r√©cup√®re la valeur √† l'adresse sp√©cifi√©e. <br><br>  Voyons maintenant comment organiser le mot que nous cr√©ons.  Il pousse l'adresse de donn√©es sur la pile (comme var0), puis transf√®re le contr√¥le √† une adresse sp√©cifique, bytecode.  La commande var0 revient imm√©diatement.  Mais dans ce cas, nous devons faire non pas un retour, mais, en fait, une transition. <br><br>  Encore une fois, je formulerai ce qui doit √™tre fait: <br><br><ul><li>  mettre l'adresse de donn√©es sur la pile </li><li>  passer √† un morceau de code apr√®s le fait&gt; </li></ul><br>  Il s'av√®re que vous avez juste besoin de transf√©rer le contr√¥le vers une autre adresse de bytecode, mais mettez d'abord l'adresse de l'octet suivant (R8) sur la pile. <br><br>  C'est presque une commande de branche!  Et ici, elle n'est pas seule.  Vous avez d√©j√† branch8 et branch16.  Nous nommerons les nouvelles commandes var8 et var16, et laisserons celles-ci √™tre juste les points d'entr√©e des commandes de branchement.  Nous √©conomisons sur la transition vers l'√©quipe de transition :) Donc, ce sera comme √ßa: <br><br><pre> <code class="cpp hljs">b_var8 = <span class="hljs-number"><span class="hljs-number">0x29</span></span> bcmd_var8: push r8 b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_var16 = <span class="hljs-number"><span class="hljs-number">0x30</span></span> bcmd_var16: push r8 b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next</code> </pre><br>  Dans le bon sens, la commande var32 fonctionnera toujours, et var64 aussi.  Nous n'avons pas de transitions aussi longues, car les transitions ordinaires ne sont pas si longues.  Mais pour la commande var, c'est un cas tr√®s r√©aliste.  Mais pour l'instant, nous ne ferons pas ces commandes.  Nous ferons plus tard, si n√©cessaire. <br><br>  Avec les mots-g√©n√©rateurs tri√©s.  Ce fut au tour de d√©cider du dictionnaire. <br><br><h4>  Vocabulaire </h4><br>  Habituellement, lorsqu'ils parlent de fa√ßon simpliste du dictionnaire fort, il se pr√©sente sous la forme d'une liste unidirectionnelle d'entr√©es de dictionnaire.  En fait, tout est un peu plus compliqu√©, car le fort prend en charge de nombreux dictionnaires.  En fait, c'est un arbre.  La recherche d'un mot dans un tel arbre commence par une ¬´feuille¬ª - c'est le dernier mot du dictionnaire actuel.  Le dictionnaire courant est d√©fini par la variable de contexte et l'adresse du dernier mot est dans le mot du dictionnaire.  Une autre variable est utilis√©e pour g√©rer les dictionnaires - elle d√©finit un dictionnaire o√π de nouveaux mots seront ajout√©s.  Ainsi, un dictionnaire peut √™tre install√© pour une recherche, et un autre pour inclure de nouveaux mots. <br><br>  Pour notre cas simple, nous n'aurions pas pu prendre en charge de nombreux dictionnaires, mais j'ai d√©cid√© de ne rien simplifier.  En fait, pour comprendre le code d'octets, la machine d'octets, il n'est pas n√©cessaire de savoir ce qui est d√©crit dans cette section.  Par cons√©quent, qui ne sont pas int√©ress√©s, vous pouvez simplement ignorer cette section.  Eh bien, qui veut conna√Ætre les d√©tails - allez-y! <br><br>  Initialement, il existe un dictionnaire de base nomm√©.  Cela signifie qu'il existe un tel mot - en avant.  Ce mot est aussi appel√© "dictionnaire", il y a une certaine confusion.  Par cons√©quent, quand il s'agit d'un mot, je l'appellerai un mot de dictionnaire. <br><br>  De nouveaux dictionnaires sont cr√©√©s en utilisant cette construction: <br><br><pre> <code class="cpp hljs">vocabulary &lt;  &gt;</code> </pre><br>  Cela cr√©e un mot avec le nom &lt;nom du dictionnaire cr√©√©&gt;.  Une fois ex√©cut√©, ce mot d√©finira le dictionnaire cr√©√© comme dictionnaire de d√©part pour la recherche. <br><br>  En fait, dans le mot du dictionnaire, il y a un lien vers le dernier article de ce dictionnaire, avec lequel la recherche commence.  Et au moment de l'ex√©cution, ce mot de dictionnaire √©crit un lien vers son champ de donn√©es dans la variable de contexte. <br><br>  Plus tard, il sera possible de faire le mot vocabulaire, qui sur le fort, dans la mise en ≈ìuvre actuelle, est d√©crit tout simplement: <br><br><pre> <code class="cpp hljs">: vocabulary create context @ , does&gt; context ! ;</code> </pre><br>  Alors, cr√©ez le mot.  Nous utiliserons la commande var8.  Bytecode "context!"  placer juste apr√®s le champ de donn√©es: <br><br><pre> <code class="cpp hljs">forth: .byte b_var8 .byte does_voc - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .quad <span class="hljs-number"><span class="hljs-number">0</span></span> # &lt;--      .      ,    -    . does_voc: .byte b_call8 .byte context - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_set .byte b_exit</code> </pre><br>  Revenons maintenant √† la cr√©ation du dictionnaire lui-m√™me. <br><br>  En g√©n√©ral, dans un fort, la description d'un mot en m√©moire est appel√©e ¬´entr√©e de dictionnaire¬ª.  En termes ordinaires, je dirais qu'il y a un titre d'article et son code.  Mais tout n'est pas tout √† fait habituel dans un fort, l√† on l'appelle ¬´champ de nom¬ª, ¬´champ de communication¬ª, ¬´champ de code¬ª et ¬´champ de donn√©es¬ª.  Je vais essayer de vous dire ce que tout cela signifie en termes traditionnels. <br><br>  Le champ du nom est le nom du mot "ligne avec un compteur".  C'est comme dans l'ancien pascal - octet de longueur de cha√Æne, puis cha√Æne.  Le champ de lien est un lien vers l'article pr√©c√©dent.  Auparavant, il n'y avait qu'une adresse, mais nous aurons un code ind√©pendant de la plate-forme, et ce sera un d√©calage.  Le champ de code, traditionnellement dans le fort, est le code machine (lorsque l'impl√©mentation est sur une ligne directe), pour les mots en dehors du noyau, il y avait appel _call.  Nous aurons juste un bytecode.  Et le champ de donn√©es est pour les mots contenant des donn√©es - par exemple, pour les variables ou les constantes.  Soit dit en passant, le mot dictionnaire y fait √©galement r√©f√©rence. <br><br>  Pour le compilateur, nous avons encore besoin de drapeaux.  Habituellement, un fort n'a besoin que d'un seul drapeau - imm√©diat, et il est plac√© dans un long octet (parfois il y en a un autre - cach√©).  Mais c'est pour le code cousu directement, o√π le contr√¥le du processeur est transf√©r√© lorsqu'il est appel√© dans le champ de code.  Et nous avons des mots diff√©rents - bytecode et code machine, et au moins deux, voire trois, indicateurs sont n√©cessaires. <br><br>  Combien faut-il pour le domaine de la communication?  Au d√©but, je voulais utiliser 16 bits.  Il s'agit d'un lien vers le mot pr√©c√©dent, et le mot est certainement inf√©rieur √† 64 Ko.  Mais je me suis alors souvenu que le mot peut contenir des donn√©es de presque n'importe quelle taille.  Et d'ailleurs, en pr√©sence de plusieurs dictionnaires, le lien peut passer par plusieurs mots.  Il s'av√®re que dans la plupart des cas, 8 bits suffisent, mais il peut y en avoir 16 et 32. Et m√™me 64 bits, s'il y a des donn√©es de plus de 4 Go.  Eh bien, prenons en charge toutes les options.  Quelle option est utilis√©e - mettez les drapeaux.  Il en r√©sulte au moins 4 drapeaux: l'attribut imm√©diat, l'attribut du mot noyau et 2 bits par variante du champ de communication utilis√©.  Il n'est pas n√©cessaire d'utiliser un octet distinct pour les drapeaux, d'aucune autre mani√®re. <br><br>  Nous d√©finissons les drapeaux comme suit: <br><br><pre> <code class="cpp hljs">f_code = <span class="hljs-number"><span class="hljs-number">0x80</span></span> f_immediate = <span class="hljs-number"><span class="hljs-number">0x60</span></span></code> </pre><br>  L'indicateur f_code sera pour les mots du noyau √©crits en assembleur, l'indicateur f_immediate sera utile pour le compilateur, √† ce sujet dans l'article suivant.  Et les deux bits les moins significatifs d√©termineront la longueur du champ de communication (1, 2, 4 ou 8 octets). <br><br>  Ainsi, le titre de l'article sera comme ceci: <br><br><ul><li>  drapeaux (1 octet) </li><li>  champ de communication (1-8 octets) </li><li>  nom octet de longueur </li><li>  nom (1-255 octets) </li></ul><br>  Jusqu'√† pr√©sent, je n'ai pas utilis√© les capacit√©s de l'assembleur "macro".  Et maintenant, nous en avons besoin.  Voici comment j'ai obtenu une macro avec l'√©l√©ment de nom pour former le titre du mot: <br><br><pre> <code class="cpp hljs">.macro item name, flags = <span class="hljs-number"><span class="hljs-number">0</span></span> link = . - p_item <span class="hljs-number"><span class="hljs-number">9</span></span>: .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags .byte link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">1</span></span> .word . - p_item .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">2</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> . - p_item .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">3</span></span> .quad . - p_item .endif p_item = <span class="hljs-number"><span class="hljs-number">9b</span></span> .byte <span class="hljs-number"><span class="hljs-number">9f</span></span> - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\name"</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: .endm</code> </pre><br>  Cette macro utilise la valeur p_item - il s'agit de l'adresse de l'entr√©e de dictionnaire pr√©c√©dente.  Cette valeur √† la fin est mise √† jour pour une utilisation future: p_item = 9b.  Ici 9b est une √©tiquette, pas un nombre, ne confondez pas :) La macro a deux param√®tres - le nom du mot et des drapeaux (facultatif).  Au d√©but de la macro, le d√©calage par rapport au mot pr√©c√©dent est calcul√©.  Ensuite, en fonction de la taille du d√©calage, les drapeaux et le champ de communication de la taille souhait√©e sont compil√©s.  Puis l'octet de la longueur du nom et du nom lui-m√™me. <br><br>  D√©finissez avant le premier mot p_item comme suit: <br><br><pre> <code class="cpp hljs">p_item = .</code> </pre><br>  Le point est l'adresse de compilation actuelle dans l'assembleur.  √Ä la suite de cette d√©finition, le premier mot se r√©f√©rera √† lui-m√™me (le champ de communication sera 0).  C'est le signe de la fin des dictionnaires. <br><br>  Au fait, qu'y aura-t-il dans le champ de code des mots du noyau?  Au minimum, vous devez enregistrer le code de commande quelque part.  J'ai d√©cid√© de suivre le chemin le plus simple.  Pour les mots du noyau, il y aura √©galement un bytecode.  Pour la plupart des √©quipes, ce ne sera qu'une commande d'octets, suivie de b_exit.  Ainsi, pour l'interpr√©teur, l'indicateur f_code n'a pas besoin d'√™tre analys√© et les commandes ne diff√®rent en aucune fa√ßon.  Vous avez juste besoin d'appeler le bytecode pour tout le monde. <br><br>  Il y a un autre avantage √† cette option.  Pour les commandes avec param√®tres, vous pouvez sp√©cifier des param√®tres s√ªrs.  Par exemple, si vous appelez la commande allum√©e dans les impl√©mentations Fort avec du code cousu directement, le syst√®me se bloque.  Et ici, il sera √©crit l√†, par exemple, allum√© 0, et cette s√©quence mettra simplement 0 sur la pile.  M√™me pour la branche peut se faire en toute s√©curit√©! <br><br><pre> <code class="cpp hljs"> .byte branch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit</code> </pre><br>  Avec un tel appel, il y aura des frais g√©n√©raux, mais pour l'interpr√®te, ils ne seront pas importants.  Et le compilateur analysera les indicateurs et compilera le code correct et rapide. <br><br>  Le premier mot sera, bien s√ªr, le mot ¬´en avant¬ª - le vocabulaire de base que nous cr√©ons.  Ici, venez dans la commande var pratique avec un lien vers le code apr√®s le fait&gt;.  J'ai d√©j√† cit√© ce code dans la section pr√©c√©dente, mais je vais le r√©p√©ter √† nouveau, avec le titre: <br><br><pre> <code class="cpp hljs">p_item = . item forth .byte b_var8 .byte does_voc - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .quad <span class="hljs-number"><span class="hljs-number">0</span></span> does_voc: .byte b_call8 .byte context - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_set .byte b_exit</code> </pre><br>  Et nous allons imm√©diatement cr√©er les variables de contexte et, nous en avons besoin pour rechercher des mots: <br><br><pre> <code class="cpp hljs"> item .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item context context: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Et maintenant, vous devez √™tre patient et √©crire un titre pour chaque mot que nous avons √©crit en assembleur avec l'indicateur f_code: <br><br><pre> <code class="cpp hljs"> item <span class="hljs-number"><span class="hljs-number">0</span></span>, f_code .byte b_num0 .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>, f_code .byte b_num1 .byte b_exit ... item <span class="hljs-number"><span class="hljs-number">1</span></span>-, f_code .byte b_wm .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>+, f_code .byte b_wp .byte b_exit item +, f_code .byte b_add .byte b_exit item -, f_code .byte b_sub .byte b_exit item *, f_code .byte b_mul .byte b_exit</code> </pre><br>  Et ainsi de suite ... <br><br>  Avec des √©quipes √©crites en bytecode, c'est encore plus simple.  Il suffit d'ajouter juste un en-t√™te avant le bytecode, tout comme le mot suivant, par exemple: <br><br><pre> <code class="cpp hljs"> item hold hold: .byte b_call8 .byte holdpoint - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-meta"><span class="hljs-meta"># holdpoint ...</span></span></code> </pre><br>  Pour les commandes avec param√®tres, nous cr√©erons des param√®tres s√ªrs.  Par exemple, laissez les commandes lite retourner le nombre Pi, si quelqu'un les appelle de mani√®re interactive, il y aura une telle P√¢ques :) <br><br><pre> <code class="cpp hljs"> item lit8, f_code .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">31</span></span> .byte b_exit item lit16, f_code .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">31415</span></span> .byte b_exit item lit32, f_code .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">31415926</span></span> .byte b_exit item lit64, f_code .byte b_lit64 .quad <span class="hljs-number"><span class="hljs-number">31415926535</span></span> .byte b_exit</code> </pre><br>  Le dernier mot de la liste fera symboliquement dispara√Ætre le mot.  Mais nous devons encore initialiser l'adresse de ce mot dans le champ de donn√©es.  Pour obtenir l'adresse de ce mot, utilisez la commande var0: <br><br><pre> <code class="cpp hljs">last_item: .byte b_var0 item bye, f_code .byte b_bye</code> </pre><br>  Dans cette conception, si nous appelons l'adresse last_item dans le bytecode, nous obtiendrons l'adresse du mot bye.  Pour l'√©crire dans les champs de donn√©es du mot en avant, ex√©cutez en avant, et l'adresse souhait√©e sera en contexte.  Ainsi, le code d'initialisation du syst√®me sera comme ceci: <br><br><pre> <code class="cpp hljs">forth last_item context @ !</code> </pre><br>  Passons maintenant directement √† l'interpr√®te.  Tout d'abord, nous devons travailler avec le tampon d'entr√©e et en extraire des mots.  Permettez-moi de vous rappeler que l'interpr√®te du fort est tr√®s simple.  Il extrait les mots du tampon d'entr√©e en s√©quence, essaie de les trouver.  Si le mot est trouv√©, l'interpr√®te le lance pour ex√©cution. <br><br><h4>  Tampon d'entr√©e et extraction de mots </h4><br>  Pour √™tre honn√™te, je ne veux pas passer beaucoup de temps √† √©tudier les normes du fort.  Mais je vais quand m√™me essayer de le rapprocher le plus possible d'eux, principalement de m√©moire.  Si les experts du fort verront une forte diff√©rence ici - √©crivez, je le corrigerai. <br><br>  Le fort a trois variables pour travailler avec le tampon: tib, #tib et&gt; in.  La variable tib pousse l'adresse du tampon d'entr√©e sur la pile.  La variable #tib pousse le nombre de caract√®res qui sont dans le tampon sur la pile.  Et la variable&gt; in contient le d√©calage dans le tampon d'entr√©e, au-del√† duquel se trouve le texte brut.  D√©finissez ces variables. <br><br><pre> <code class="cpp hljs"> item tib .byte b_var0 v_tib: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-meta"><span class="hljs-meta">#tib .byte b_var0 v_ntib: .quad 0 item &gt;in .byte b_var0 v_in: .quad 0</span></span></code> </pre><br>  Ensuite, nous faisons le mot blword.  Ce mot, en utilisant les variables sp√©cifi√©es, obtient le mot suivant du flux d'entr√©e.  Un espace est utilis√© comme d√©limiteurs et tous les caract√®res avec un code inf√©rieur √† un espace.  Ce mot sera en assembleur.  Apr√®s le d√©bogage, il s'est av√©r√© comme ceci: <br><br><pre> <code class="cpp hljs">b_blword = <span class="hljs-number"><span class="hljs-number">0xF0</span></span> bcmd_blword: mov rsi, v_tib #    mov rdx, rsi #   RDX       mov rax, v_in #     mov rcx, v_ntib #    add rsi, rax #  RSI -      sub rcx, rax #     jz <span class="hljs-number"><span class="hljs-number">3f</span></span> word2: lodsb #   AL  RSI   cmp al, <span class="hljs-string"><span class="hljs-string">' '</span></span> ja <span class="hljs-number"><span class="hljs-number">1f</span></span> #    (    ) dec rcx jnz word2 #    <span class="hljs-number"><span class="hljs-number">3</span></span>: sub rsi, rdx mov v_in, rsi push rcx jmp _next <span class="hljs-number"><span class="hljs-number">1</span></span>: lea rdi, [rsi - <span class="hljs-number"><span class="hljs-number">1</span></span>] # RDI = RSI - <span class="hljs-number"><span class="hljs-number">1</span></span> ( ) dec rcx word3: lodsb cmp al, <span class="hljs-string"><span class="hljs-string">' '</span></span> jbe <span class="hljs-number"><span class="hljs-number">2f</span></span> dec rcx jnz word3 <span class="hljs-number"><span class="hljs-number">2</span></span>: mov rax, rsi sub rsi, rdx #        (   ) mov v_in, rsi sub rax, rdi dec rax jz word1 push rdi #   word1: push rax #   jmp _next</code> </pre><br>  Ce mot est similaire au mot standard, mais, contrairement √† lui, prend en compte tous les d√©limiteurs et ne copie pas le mot dans le tampon.  Il renvoie seulement deux valeurs sur la pile - adresse et longueur.  Si le mot ne peut pas √™tre r√©cup√©r√©, renvoie 0. Le moment est venu de commencer √† √©crire l'interpr√©teur. <br><br><h4>  Recherche de mots et interpr√®te </h4><br>  Pour commencer, faisons interpr√©ter le mot.  Ce mot s√©lectionne un nouveau mot dans le tampon √† l'aide de blworld, le recherche dans le dictionnaire et l'ex√©cute.  Et ainsi, il se r√©p√®te jusqu'√† √©puisement du tampon.  Nous n'avons toujours pas la possibilit√© de rechercher un mot, nous allons donc √©crire un talon de test qui imprimera simplement le mot √† partir du tampon en utilisant type.  Cela nous donnera l'occasion de v√©rifier et de d√©boguer blworld: <br><br><pre> <code class="cpp hljs"># : interpret begin blword dup <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> type repeat drop ; item interpret <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_type .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">1b</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br>  Maintenant, faites cesser le mot.  Habituellement, ils le font lors de la mise en ≈ìuvre de syst√®mes de fortification: ils utilisent le mot quitter ou abandonner pour passer en mode interpr√®te.  Le mot quit vide les piles et d√©marre une boucle sans fin d'entr√©e et d'interpr√©tation du tampon.  Avec nous, ce sera juste un appel √† interpr√©ter.  Le code de ce mot comprendra deux parties.  La premi√®re partie sera en assembleur, la seconde sera en bytecode.  La premi√®re partie: <br><br><pre> <code class="cpp hljs">b_quit = <span class="hljs-number"><span class="hljs-number">0xF1</span></span> bcmd_quit: lea r8, quit mov sp, init_stack mov bp, init_rstack jmp _next</code> </pre><br>  La deuxi√®me partie: <br><br><pre> <code class="cpp hljs">quit: .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_bye</code> </pre><br>  Comme d'habitude, le code assembleur se trouve dans la section .text, le code octet se trouve dans la section .data. <br><br>  Et enfin, changez le bytecode de d√©part.  Il n'y aura que l'initialisation du dictionnaire, la mise en place d'un tampon sur la ligne de d√©part et l'appel √† quitter. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! start_code tib ! </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;  &gt; #tib ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_call8 .byte start_code - . - 1 .byte b_call16 .word tib - . - 2 .byte b_set .byte b_lit16 .world 1f - 0f .byte b_call16 .word ntib - . - 2 .byte b_set .byte b_quit start_code: .byte b_var0 0: .ascii "word1 word2 word3" 1:</span></span></span></span></code> </pre><br>  Compilez, liez, ex√©cutez! <br><br><pre> <code class="plaintext hljs">$ as forth.s -o forth.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth word1word2wordBye!</code> </pre><br>  C‚Äôest un peu comme de la bouillie, mais c‚Äôest exactement le r√©sultat.  Nous sortons sans d√©limiteurs.  Par ailleurs, mettez le fil de ligne avant d'acheter pour l'avenir, cela ne fera pas de mal. <br><br>  Bien s√ªr, j'ai d√ª bricoler avec le d√©bogage.  En plus du ¬´d√©faut de segmentation (core dumped)¬ª d√©j√† mentionn√©, des r√©sultats parfois int√©ressants ont √©t√© obtenus.  Par exemple, ceci: <br><br><pre> <code class="plaintext hljs">$ ./forth word1word2word3forth)%60Acurrent(context(%600lit8lit16zlit32v%5E%DF%80lit64v%5E%DF%80call8call16call32branch8branch16qbranch8qbranch16exit1-+!-%22*#/$mod%25/mod&amp;abs'dup0drop1swap2rot3-rot4over5pick6roll7depth8@@!Ac@Bc!Cw@Dw!Ei@Fi!G0=P0%3CQ0%3ER=S%3CT%3EU%3C=V%3E=Wvar8)var160base(holdbuf(Qholdpoint(hold@0U110ACp@&amp;20T0!?!%3CgF!A0@RF!5%220'%DE%A61Q-%DD%80:tib(%7F%60(%3Ein(%20%20%20%20%20%20%20interpret01('byeSegmentation%20fault%20(core%20dumped)</code> </pre><br>  Cela semble √™tre juste notre dictionnaire entier sous forme binaire avec du texte coup√© en d√©limiteurs :) C'est arriv√© quand j'ai oubli√© ¬´dec rcx¬ª avant word3 dans la commande b_blword. <br><br>  Nous pouvons choisir des mots dans le flux d'entr√©e, il y a un dictionnaire.  Vous devez maintenant impl√©menter une recherche dans le dictionnaire et lancer des mots pour les ex√©cuter.  Cela n√©cessitera les mots find, cfa et execute. <br><br>  Le mot find prendra l'adresse du mot et sa longueur dans la pile.  Ce mot sera retourn√© par l'adresse de l'entr√©e du dictionnaire ou 0 s'il n'est pas trouv√©. <br><br>  Le mot cfa √† l'adresse de l'article calculera l'adresse du bytecode ex√©cutable. <br><br>  Et le mot ex√©cuter ex√©cutera le bytecode. <br><br>  Commen√ßons par trouver.  Dans les normes fort, il faut une seule adresse - une ligne avec un compteur.  Mais je ne veux pas √† nouveau copier la cha√Æne dans le tampon, je vais donc d√©vier un peu des normes.  Le mot find prendra deux param√®tres sur la pile - l'adresse et la longueur de la cha√Æne (en fait, cela renvoie le mot blword).  Apr√®s le d√©bogage, ce mot a pris la forme suivante: <br><br><pre> <code class="cpp hljs">b_find = <span class="hljs-number"><span class="hljs-number">0xF2</span></span> bcmd_find: pop rbx #   pop r9 #   mov rdx, v_context mov rdx, [rdx] #        #   find0: mov al, [rdx] #  <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">3</span></span> #   -     ,     ,    <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, al jz find_l8 cmp al, <span class="hljs-number"><span class="hljs-number">1</span></span> jz find_l16 cmp al, <span class="hljs-number"><span class="hljs-number">2</span></span> jz find_l32 mov r10, [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">64</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">9</span></span>] #   jmp find1 find_l32: movsx r10, dword ptr [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">32</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">5</span></span>] #   jmp find1 find_l16: movsx r10, word ptr [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">16</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">3</span></span>] #   jmp find1 find_l8: movsx r10, byte ptr [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">8</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">2</span></span>] #   find1: movzx rax, byte ptr [rsi] #       cmp rax, rbx jz find2 #      find3: <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r10, r10 jz find_notfound #  ,    add rdx, r10 #     jmp find0 #  ,   find2: inc rsi mov rdi, r9 mov rcx, rax repz cmpsb jnz find3 #   push rdx jmp _next find_notfound: push r10 jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est peut-√™tre le mot le plus difficile pour aujourd'hui. </font><font style="vertical-align: inherit;">Maintenant, nous modifions le mot interpr√©ter, en rempla√ßant type par "find":</font></font><br><br><pre> <code class="cpp hljs"># : interpret begin blword dup <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> find . repeat drop ; item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_find .byte b_call16 .word dot - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la ligne de test, vous devez mettre les mots qui sont dans le dictionnaire, par exemple, "0 1- dup +". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout est pr√™t √† √™tre lanc√©!</font></font><br><br><pre> <code class="plaintext hljs">$ ld forth.o -o forth $ ./forth 6297733 6297898 6298375 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G√©nial, la recherche fonctionne. </font><font style="vertical-align: inherit;">Ce sont les adresses des mots (en d√©cimal). </font><font style="vertical-align: inherit;">Maintenant, le mot cfa. </font><font style="vertical-align: inherit;">Que ce soit aussi en assembleur, c'est tr√®s simple, travailler avec des drapeaux est similaire √† trouver:</font></font><br><br><pre> <code class="cpp hljs">b_cfa = <span class="hljs-number"><span class="hljs-number">0xF3</span></span> bcmd_cfa: pop rdx #    mov al, [rdx] #  <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">3</span></span> #   -     ,     ,    <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, al jz cfa_l8 cmp al, <span class="hljs-number"><span class="hljs-number">1</span></span> jz cfa_l16 cmp al, <span class="hljs-number"><span class="hljs-number">2</span></span> jz cfa_l32 lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">9</span></span>] #   (<span class="hljs-number"><span class="hljs-number">64</span></span>  ) jmp cfa1 find_l32: lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">5</span></span>] #   (<span class="hljs-number"><span class="hljs-number">32</span></span>  ) jmp cfa1 find_l16: lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">3</span></span>] #   (<span class="hljs-number"><span class="hljs-number">16</span></span>  ) jmp cfa1 find_l8: lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">2</span></span>] #   (<span class="hljs-number"><span class="hljs-number">8</span></span>  ) xor rax, rax lodsb add rsi, rax push rsi jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et enfin, le mot ex√©cuter, c'est encore plus simple: </font></font><br><br><pre> <code class="cpp hljs">b_execute = <span class="hljs-number"><span class="hljs-number">0xF4</span></span> bcmd_execute: sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], r8 #       pop r8 #  - jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corrigez le mot interpr√©ter et courir! </font></font><br><br><pre> <code class="cpp hljs"># : interpret begin blword dup <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> find cfa execute repeat drop ; item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_find .byte b_cfa .byte b_execute .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lancement: </font></font><br><br><pre> <code class="plaintext hljs">$ as forth.s -o forth.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth -2 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urrra, gagn√©! </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(C) Cat Matroskin</font></font></s> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En effet, si vous soustrayez 1 de 0 et ajoutez le r√©sultat √† vous-m√™me, ce sera -2 :) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est super, mais je veux quand m√™me taper les commandes au clavier. Et, il y a un autre probl√®me - notre interpr√®te ne comprend que les nombres 0, 1, 2, 3, 4 et 8 (qui sont d√©finis comme des constantes). Qu'apprendrait-il pour comprendre des nombres, vous avez besoin du mot ¬´nombre¬ª. De la m√™me mani√®re que pour le mot find, je n'utiliserai pas le buffer. Le mot "nombre?" prendra deux param√®tres sur la pile - l'adresse de la cha√Æne et la longueur. En cas de succ√®s, il renverra le num√©ro re√ßu et le drapeau 1. Si la conversion √©choue, il y aura un num√©ro sur la pile: 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code s'est av√©r√© long, mais plut√¥t simple et lin√©aire:</font></font><br><br><pre> <code class="cpp hljs">b_number = <span class="hljs-number"><span class="hljs-number">0xF5</span></span> bcmd_number: pop rcx #   pop rsi #  xor rax, rax #   xor rbx, rbx #     mov r9, v_base #  xor r10, r10 #   <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz num_false mov bl, [rsi] cmp bl, <span class="hljs-string"><span class="hljs-string">'+'</span></span> jnz <span class="hljs-number"><span class="hljs-number">1f</span></span> inc rsi dec rcx jz num_false jmp num0 <span class="hljs-number"><span class="hljs-number">1</span></span>: cmp bl, <span class="hljs-string"><span class="hljs-string">'-'</span></span> jnz num0 mov r10, <span class="hljs-number"><span class="hljs-number">1</span></span> inc rsi dec rcx jz num_false num0: mov bl, [rsi] cmp bl, <span class="hljs-string"><span class="hljs-string">'0'</span></span> ja num_false cmp bl, <span class="hljs-string"><span class="hljs-string">'9'</span></span> jae num_09 cmp bl, <span class="hljs-string"><span class="hljs-string">'A'</span></span> ja num_false cmp bl, <span class="hljs-string"><span class="hljs-string">'Z'</span></span> jae num_AZ cmp bl, <span class="hljs-string"><span class="hljs-string">'a'</span></span> ja num_false sub bl, <span class="hljs-string"><span class="hljs-string">'a'</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span> jmp num_check num_AZ: sub bl, <span class="hljs-string"><span class="hljs-string">'A'</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span> jmp num_check num_09: sub bl, <span class="hljs-string"><span class="hljs-string">'0'</span></span> num_check: cmp rbx, r9 jge num_false add rax, rbx mul r9 inc rsi dec rcx jnz num0 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r10, r10 push rax push <span class="hljs-number"><span class="hljs-number">1</span></span> jmp _next num_false: xor rcx, rcx push rcx jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifier interpr√©ter. </font><font style="vertical-align: inherit;">Si le mot n'est pas dans le dictionnaire, nous essaierons de l'interpr√©ter comme un nombre:</font></font><br><br><pre> <code class="cpp hljs"># : interpret <span class="hljs-meta"><span class="hljs-meta"># begin # blword dup # while # over over find dup # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> -rot drop drop cfa execute </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> number? drop then # repeat # drop ; item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte 0f - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte 1f - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa .byte b_execute .byte b_branch8 .byte 2f - . 1: .byte b_numberq .byte b_drop 2: .byte b_branch8 .byte interpret - . 0: .byte b_drop .byte b_exit last_item: .byte b_var0 item bye, f_code .byte b_bye</span></span></code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et me voil√†! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©boguez un tel bytecode dans l'assembleur, sans points d'arr√™t dans le bytecode, sans la possibilit√© de simplement ¬´avancer¬ª le long du bytecode ... De plus, avec pas les mouvements les plus faciles sur la pile, et sans la simple capacit√© de visualiser le contenu de la pile ... Et sur GDB, o√π juste la ligne de commande ... Je vais vous dire - c'est juste une explosion de cerveau! </font><font style="vertical-align: inherit;">Pas pire. </font><font style="vertical-align: inherit;">C'est une </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPLOSION DU CERVEAU</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais ... nous sommes des Indiens, nous trouverons toujours des solutions :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En g√©n√©ral, j'ai trouv√© cette solution: j'ai impl√©ment√© une commande pour afficher le contenu de la pile - ¬´s¬ª. </font><font style="vertical-align: inherit;">La commande n'est pas la plus simple, mais toujours plus facile √† interpr√©ter. </font><font style="vertical-align: inherit;">Et, comme il est </font><font style="vertical-align: inherit;">apparu, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ochchchen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utile. </font><font style="vertical-align: inherit;">Le voici:</font></font><br><br><pre> <code class="cpp hljs"># : .s depth dup . c<span class="hljs-string"><span class="hljs-string">": emit do dup while dup pick . 1- again drop ; item .s # 11 22 33 prstack: .byte b_depth # 11 22 33 3 .byte b_dup # 11 22 33 3 3 .byte b_lit8 .byte '(' .byte b_emit .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_strp # 11 22 33 3 .byte 3 .ascii "</span></span>): <span class="hljs-string"><span class="hljs-string">" 1: .byte b_dup # 11 22 33 3 3 .byte b_qnbranch8 # 11 22 33 3 .byte 2f - . .byte b_dup # 11 22 33 3 3 .byte b_pick # 11 22 33 3 11 .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_wm # 11 22 33 2 .byte b_branch8 .byte 1b - . 2: .byte b_drop # 11 22 33 .byte b_exit</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä droite, j'ai donn√© un exemple du contenu de la pile, apr√®s l'ex√©cution de chaque commande. </font><font style="vertical-align: inherit;">Bien s√ªr, il y a un cycle, et ce n'est que la premi√®re passe. </font><font style="vertical-align: inherit;">Mais les autres sont tr√®s similaires, seule la valeur en haut de la pile change. </font><font style="vertical-align: inherit;">Apr√®s une telle ¬´trace¬ª, l'√©quipe a imm√©diatement gagn√©! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour le d√©bogage, j'ai cr√©√© les macros suivantes:</font></font><br><br><pre> <code class="cpp hljs">.macro prs new_line = <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_call16 .word prstack - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> \new_line &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> .byte b_lit8, <span class="hljs-string"><span class="hljs-string">'\n'</span></span> .byte b_emit .endif .endm</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilis√© en ins√©rant aux bons endroits de cette fa√ßon: </font></font><br><br><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword prs .byte b_dup prs .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over ......</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En cons√©quence, le premier lancement a produit la sortie suivante: </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth (2 ): 6297664 1 (3 ): 6297664 1 1 (3 ): 2 6297666 1 (4 ): 2 6297666 1 1 (4 ): 2 3 6297668 1 (5 ): 2 3 6297668 1 1 (3 ): 6 6297670 2 (4 ): 6 6297670 2 2 (4 ): 6 6297670 6297673 1 (5 ): 6 6297670 6297673 1 1 6297670 (2 ): 6 0 (3 ): 6 0 0 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque mouvement sur la pile peut √™tre vu clairement. </font><font style="vertical-align: inherit;">Il fallait faire √ßa plus t√¥t :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je suis all√© plus loin en faisant une autre macro de d√©bogage:</font></font><br><br><pre> <code class="cpp hljs">.macro pr <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">9f</span></span> - <span class="hljs-number"><span class="hljs-number">8f</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\n\string"</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: .endm</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En cons√©quence, il est devenu possible de le faire: </font></font><br><br><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword pr blworld prs .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over prs .byte b_find pr find prs .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa pr execute prs .byte b_execute .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_numberq pr numberq prs .byte b_drop <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et obtenez ceci: </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth blworld(2 ): 6297664 2 (4 ): 6297664 2 6297664 2 find(3 ): 6297664 2 0 numberq(2 ): 6297664 0 blworld(3 ): 6297664 6297667 2 (5 ): 6297664 6297667 2 6297667 2 find(4 ): 6297664 6297667 2 0 numberq(3 ): 6297664 6297667 0 blworld(4 ): 6297664 6297667 6297670 1 (6 ): 6297664 6297667 6297670 1 6297670 1 find(5 ): 6297664 6297667 6297670 1 6297958 execute(3 ): 6297664 6297667 6297962 blworld(3 ): 39660590749888 6297672 1 (5 ): 39660590749888 6297672 1 6297672 1 find(4 ): 39660590749888 6297672 1 6298496 execute(2 ): 39660590749888 6298500 39660590749888 blworld(1 ): 0 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'√©tait une tentative d'interpr√©tation de la cha√Æne ¬´20 30 *¬ª. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et vous pouvez afficher les num√©ros de ligne source ... D'accord, peut-√™tre alors ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, c'est une technique de journalisation classique pour le d√©bogage, mais quelque chose dont je ne me souvenais pas imm√©diatement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En g√©n√©ral, √† la suite du d√©bogage, j'ai trouv√© une pile √† l'√©tranger. C'est l'oppos√© du d√©bordement quand ils essaient d'en prendre plus qu'ils n'en mettent. Ajout de son contr√¥le √† ".s". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec l'aide de nouvelles macros, le d√©bogage a √©t√© rapide. Au fait, avant cela, j'ai publi√© un bytecode par ligne. Mais l'assembleur vous permet de placer plusieurs octets dans une cha√Æne, pourquoi ne pas l'utiliser. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terminons le mot interpr√©ter en ajoutant deux v√©rifications: que le mot n'a pas √©t√© converti en nombre et quitter la pile √† l'√©tranger. Par cons√©quent, interpr√©ter est le suivant:</font></font><br><br><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa .byte b_execute .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . #     <span class="hljs-number"><span class="hljs-number">0</span></span>, ,      <span class="hljs-number"><span class="hljs-number">3</span></span> .byte b_type #    .byte b_strp #   .byte <span class="hljs-number"><span class="hljs-number">19</span></span> #     .ascii <span class="hljs-string"><span class="hljs-string">" : word not found!\n"</span></span> .byte b_quit #    <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_nip, b_nip #  ,     ( b_over, b_over) <span class="hljs-number"><span class="hljs-number">2</span></span>: #       .byte b_depth #    .byte b_zlt # ,   <span class="hljs-number"><span class="hljs-number">0</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte <span class="hljs-number"><span class="hljs-number">14</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\nstack fault!\n"</span></span> .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soit dit en passant, il convient de noter que la commande quit vide d√©sormais les piles et recommence l'interpr√©tation sans modifier l'√©tat du tampon. </font><font style="vertical-align: inherit;">Ainsi, l'interpr√©tation continue, mais avec des piles ¬´fra√Æches¬ª. </font><font style="vertical-align: inherit;">Nous allons corriger cela un peu plus tard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il ne reste plus qu'√† organiser la saisie au clavier.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entr√©e clavier </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La saisie au clavier dans le fort est simple. </font><font style="vertical-align: inherit;">Il y a le mot attend, il prend deux param√®tres - l'adresse du buffer et sa taille. </font><font style="vertical-align: inherit;">Ce mot effectue la saisie au clavier. </font><font style="vertical-align: inherit;">Le nombre r√©el de caract√®res saisis est plac√© dans la variable span. </font><font style="vertical-align: inherit;">Faisons ces mots. </font><font style="vertical-align: inherit;">Nous allons entrer √† partir de l'entr√©e standard.</font></font><br><br><pre> <code class="cpp hljs">.data item span span: .byte b_var0 v_span: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> .text b_expect = <span class="hljs-number"><span class="hljs-number">0x88</span></span> bcmd_expect: mov rax, <span class="hljs-number"><span class="hljs-number">0</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_read mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx #   pop rsi #   push r8 syscall #   pop r8 mov rbx, rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jge <span class="hljs-number"><span class="hljs-number">1f</span></span> xor rbx, rbx <span class="hljs-number"><span class="hljs-number">1</span></span>: mov v_span, rbx jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons maintenant cr√©er un tampon d'entr√©e clavier. </font><font style="vertical-align: inherit;">Soit 256 caract√®res. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faisons-le √† la place de la ligne de test pr√©c√©dente.</font></font><br><br><pre> <code class="cpp hljs">inbuf_size = <span class="hljs-number"><span class="hljs-number">256</span></span> inbuf: .byte b_var0 .space inbuf_size</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et nous modifions quit, ainsi que le bytecode de d√©part. </font><font style="vertical-align: inherit;">D√©finissez la variable tib sur le tampon d'entr√©e inbuf, appelez expect, puis copiez la valeur de span dans #tib. </font><font style="vertical-align: inherit;">La variable&gt; in est annul√©e; nous appelons interpr√©ter. </font><font style="vertical-align: inherit;">Et donc nous r√©p√©tons dans un cycle. </font><font style="vertical-align: inherit;">Il y a des babioles - pour ajouter une invite de saisie et ce serait bien d'afficher l'√©tat de la pile (et nous avons d√©j√† une commande pr√™te √† l'emploi pour cela!). </font><font style="vertical-align: inherit;">Apr√®s plusieurs it√©rations, nous avons obtenu le code suivant (commande start et quit):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_quit inbuf: .byte b_var0 .space inbuf_size # begin inbuf dup tib ! inbuf_size expect span @ #tib ! 0 &gt;in ! interpret again quit: .byte b_strp, 1 .ascii </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n"</span></span></span><span class="hljs-meta"> .byte b_call16 .word prstack - . - 2 .byte b_strp .byte 2 .ascii </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&gt; "</span></span></span><span class="hljs-meta"> .byte b_call16 .word inbuf - . - 2 .byte b_dup .byte b_call16 .word tib - . - 2 .byte b_set .byte b_lit16 .word inbuf_size .byte b_expect .byte b_call16 .word span - . - 2 .byte b_get .byte b_call16 .word ntib - . - 2 .byte b_set .byte b_num0 .byte b_call16 .word bin - . - 2 .byte b_set .byte b_call16 .word interpret - . - 2 .byte b_branch8, quit - .</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et voici le r√©sultat: </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; 60 ( 1 ): 60 &gt; 60 24 ( 3 ): 60 60 24 &gt; rot ( 3 ): 60 24 60 &gt; -rot ( 3 ): 60 60 24 &gt; swap ( 3 ): 60 24 60 &gt; * * . 86400 ( 0 ): &gt; 200 30 /mod ( 2 ): 20 6 &gt; bye Bye! $</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout ce qui se trouve apr√®s le symbole "&gt;" est ma saisie au clavier. </font><font style="vertical-align: inherit;">Le reste est la r√©ponse du syst√®me. </font><font style="vertical-align: inherit;">J'ai jou√© un peu avec les commandes, en tapant sur le clavier. </font><font style="vertical-align: inherit;">Il a effectu√© plusieurs op√©rations de pile, calcul√© le nombre de secondes en jours.</font></font><br><br><h4>  R√©sum√© </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'interpr√®te est complet et fonctionne. </font><font style="vertical-align: inherit;">Et dit poliment au revoir - √† lui "au revoir" et il "au revoir" :) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme une invitation - le contenu de la pile arithm√©tique. </font><font style="vertical-align: inherit;">Le premier nombre entre parenth√®ses est la taille de la pile, puis le contenu et l'invite pour entrer "&gt;". </font><font style="vertical-align: inherit;">Vous pouvez entrer toutes les commandes impl√©ment√©es (j'ai compt√© 76 commandes). </font><font style="vertical-align: inherit;">Certes, beaucoup n'ont de sens que pour le compilateur - par exemple, les litt√©raux, les transitions, les commandes d'invocation.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source compl√®te (environ 1300 lignes)</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> f_code = <span class="hljs-number"><span class="hljs-number">0x80</span></span> f_immediate = <span class="hljs-number"><span class="hljs-number">0x60</span></span> .macro item name, flags = <span class="hljs-number"><span class="hljs-number">0</span></span> link = p_item - . <span class="hljs-number"><span class="hljs-number">9</span></span>: .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags .byte link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">1</span></span> .word link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">2</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">3</span></span> .quad link .endif p_item = <span class="hljs-number"><span class="hljs-number">9b</span></span> .byte <span class="hljs-number"><span class="hljs-number">9f</span></span> - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\name"</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: .endm .section .data init_stack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> init_rstack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> emit_buf: .byte <span class="hljs-number"><span class="hljs-number">0</span></span> inbuf_size = <span class="hljs-number"><span class="hljs-number">256</span></span> msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"\nBye!\n"</span></span> msg_bye_len = . - msg_bye bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_num1, bcmd_num2, bcmd_num3, bcmd_num4, bcmd_num8 # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_call8, bcmd_call16, bcmd_call32, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_qnbranch8, bcmd_qnbranch16,bcmd_bad, bcmd_exit # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_wp, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_add, bcmd_sub, bcmd_mul, bcmd_div, bcmd_mod, bcmd_divmod, bcmd_abs # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_var0, bcmd_var8, bcmd_var16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_dup, bcmd_drop, bcmd_swap, bcmd_rot, bcmd_mrot, bcmd_over, bcmd_pick, bcmd_roll # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_depth, bcmd_nip, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_get, bcmd_set, bcmd_get8, bcmd_set8, bcmd_get16, bcmd_set16, bcmd_get32, bcmd_set32 # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_setp, bcmd_setm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_zeq, bcmd_zlt, bcmd_zgt, bcmd_eq, bcmd_lt, bcmd_gt, bcmd_lteq, bcmd_gteq # <span class="hljs-number"><span class="hljs-number">0x50</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_2r, bcmd_r2, bcmd_rget, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_emit, bcmd_str, bcmd_strp, bcmd_count, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_expect, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x90</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_blword, bcmd_quit, bcmd_find, bcmd_cfa, bcmd_execute, bcmd_numberq, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0xF0</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # forth last_item context @ ! quit start: .byte b_call16 .word forth - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word last_item - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word context - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_set .byte b_quit inbuf: .byte b_var0 .space inbuf_size # begin inbuf dup tib ! inbuf_size expect span @ #tib ! <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;in ! interpret again quit: .byte b_strp, <span class="hljs-number"><span class="hljs-number">1</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\n"</span></span> .byte b_call16 .word prstack - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">2</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"&gt; "</span></span> .byte b_call16 .word inbuf - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_dup .byte b_call16 .word tib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_lit16 .word inbuf_size .byte b_expect .byte b_call16 .word span - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_call16 .word ntib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_num0 .byte b_call16 .word bin - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_branch8, quit - . p_item = . item forth forth: .byte b_var8 .byte does_voc - . .quad <span class="hljs-number"><span class="hljs-number">0</span></span> does_voc: .byte b_call8 .byte context - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_set .byte b_exit item current .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item context context: .byte b_var0 v_context: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-number"><span class="hljs-number">0</span></span>, f_code .byte b_num0 .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>, f_code .byte b_num1 .byte b_exit item <span class="hljs-number"><span class="hljs-number">2</span></span>, f_code .byte b_num2 .byte b_exit item <span class="hljs-number"><span class="hljs-number">3</span></span>, f_code .byte b_num3 .byte b_exit item <span class="hljs-number"><span class="hljs-number">4</span></span>, f_code .byte b_num4 .byte b_exit item <span class="hljs-number"><span class="hljs-number">8</span></span>, f_code .byte b_num8 .byte b_exit item lit8, f_code .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">31</span></span> .byte b_exit item lit16, f_code .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">31415</span></span> .byte b_exit item lit32, f_code .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">31415926</span></span> .byte b_exit item lit64, f_code .byte b_lit64 .quad <span class="hljs-number"><span class="hljs-number">31415926</span></span> .byte b_exit item call8, f_code .byte b_call8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item call16, f_code .byte b_call16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . - <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item call32, f_code .byte b_call32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0f</span></span> - . - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item branch8, f_code .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item branch16, f_code .byte b_branch16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item qbranch8, f_code .byte b_qbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item qbranch16, f_code .byte b_qbranch16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>, f_code .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>-, f_code .byte b_wm .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>+, f_code .byte b_wp .byte b_exit item +, f_code .byte b_add .byte b_exit item -, f_code .byte b_sub .byte b_exit item *, f_code .byte b_mul .byte b_exit item /, f_code .byte b_div .byte b_exit item mod, f_code .byte b_mod .byte b_exit item /mod, f_code .byte b_divmod .byte b_exit item <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>, f_code .byte b_abs .byte b_exit item dup, f_code .byte b_dup .byte b_exit item drop, f_code .byte b_drop .byte b_exit item swap, f_code .byte b_swap .byte b_exit item rot, f_code .byte b_rot .byte b_exit item -rot, f_code .byte b_mrot .byte b_exit item over, f_code .byte b_over .byte b_exit item pick, f_code .byte b_pick .byte b_exit item roll, f_code .byte b_roll .byte b_exit item depth, f_code .byte b_depth .byte b_exit item @, f_code .byte b_get .byte b_exit item !, f_code .byte b_set .byte b_exit item c@, f_code .byte b_get8 .byte b_exit item c!, f_code .byte b_set8 .byte b_exit item w@, f_code .byte b_get16 .byte b_exit item w!, f_code .byte b_set16 .byte b_exit item i@, f_code .byte b_get32 .byte b_exit item i!, f_code .byte b_set32 .byte b_exit item +!, f_code .byte b_setp .byte b_exit item -!, f_code .byte b_setm .byte b_exit item &gt;r, f_code .byte b_2r .byte b_exit item r&gt;, f_code .byte b_r2 .byte b_exit item r@, f_code .byte b_rget .byte b_exit item <span class="hljs-string"><span class="hljs-string">"0="</span></span>, f_code .byte b_zeq .byte b_exit item <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;, f_code .byte b_zlt .byte b_exit item <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, f_code .byte b_zgt .byte b_exit item <span class="hljs-string"><span class="hljs-string">"="</span></span>, f_code .byte b_eq .byte b_exit item &lt;, f_code .byte b_lt .byte b_exit item &gt;, f_code .byte b_gt .byte b_exit item <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span>, f_code .byte b_lteq .byte b_exit item <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span>, f_code .byte b_gteq .byte b_exit item type, f_code .byte b_type .byte b_exit item expect, f_code .byte b_expect .byte b_exit item emit, f_code .byte b_emit .byte b_exit item count, f_code .byte b_count .byte b_exit item <span class="hljs-string"><span class="hljs-string">"(\")"</span></span>, f_code .byte b_str .byte b_exit item <span class="hljs-string"><span class="hljs-string">"(.\")"</span></span>, f_code .byte b_strp .byte b_exit item var8, f_code .byte b_var8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item var16, f_code .byte b_var16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item base base: .byte b_var0 v_base: .quad <span class="hljs-number"><span class="hljs-number">10</span></span> holdbuf_len = <span class="hljs-number"><span class="hljs-number">70</span></span> item holdbuf holdbuf: .byte b_var0 .space holdbuf_len item holdpoint holdpoint: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item span span: .byte b_var0 v_span: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> # : hold holdpoint @ <span class="hljs-number"><span class="hljs-number">1</span></span>- dup holdbuf &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup holdpoint ! c! then ; item hold hold: .byte b_call8 .byte holdpoint - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-meta"><span class="hljs-meta"># holdpoint .byte b_get # @ .byte b_wm # 1- .byte b_dup # dup .byte b_call8 .byte holdbuf - . - 1 # holdbuf .byte b_gt # &gt; .byte b_qbranch8 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> .byte 0f - . .byte b_drop # drop .byte b_drop # drop .byte b_branch8 #     ( then) .byte 1f - . 0: .byte b_dup # dup .byte b_call8 .byte holdpoint - . - 1 # holdpoint .byte b_set # ! .byte b_set8 # c! 1: .byte b_exit # ; # : # base /mod swap dup 10 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; if c" 0 + else 10 - c" A + then hold ; item # conv: .byte b_call16 .word base - . - 2 # base .byte b_get # @ .byte b_divmod # /mod .byte b_swap # swap .byte b_dup # dup .byte b_lit8 .byte 10 # 10 .byte b_lt # &lt; .byte b_qnbranch8 # if .byte 0f - . .byte b_lit8 .byte '0' # c" 0 .byte b_add # + .byte b_branch8 # else .byte 1f - . 0: .byte b_lit8 .byte '?' # c" A .byte b_add # + 1: .byte b_call16 .word hold - . - 2 # hold .byte b_exit # ; # : &lt;# holdbuf 70 + holdpoint ! ; item &lt;# conv_start: .byte b_call16 .word holdbuf - . - 2 .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_call16 .word holdpoint - . - 2 .byte b_set .byte b_exit # : #s do # dup 0=until ; item #s conv_s: .byte b_call8 .byte conv - . - 1 .byte b_dup .byte b_qbranch8 .byte conv_s - . .byte b_exit # : #&gt; holdpoint @ holdbuf 70 + over - ; item #&gt; conv_end: .byte b_call16 .word holdpoint - . - 2 .byte b_get .byte b_call16 .word holdbuf - . - 2 .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_over .byte b_sub .byte b_exit item . dot: .byte b_dup .byte b_abs .byte b_call8 .byte conv_start - . - 1 .byte b_lit8 .byte ' ' .byte b_call16 .word hold - . - 2 .byte b_call8 .byte conv_s - . - 1 .byte b_drop .byte b_zlt .byte b_qnbranch8 .byte 1f - . .byte b_lit8 .byte '-' .byte b_call16 .word hold - . - 2 1: .byte b_call8 .byte conv_end - . - 1 .byte b_type .byte b_exit item tib tib: .byte b_var0 v_tib: .quad 0 item #tib ntib: .byte b_var0 v_ntib: .quad 0 item &gt;in bin: .byte b_var0 v_in: .quad 0 # : .s depth dup . c": emit do dup while dup pick . 1- again drop ; item .s # 11 22 33 prstack: .byte b_depth # 11 22 33 3 .byte b_dup # 11 22 33 3 3 .byte b_strp .byte 2 .ascii "( " .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_strp # 11 22 33 3 .byte 3 .ascii "): " .byte b_dup, b_zlt .byte b_qnbranch8, 1f - . .byte b_strp .byte 14 .ascii "\nStack fault!\n" .byte b_quit 1: .byte b_dup # 11 22 33 3 3 .byte b_qnbranch8 # 11 22 33 3 .byte 2f - . .byte b_dup # 11 22 33 3 3 .byte b_pick # 11 22 33 3 11 .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_wm # 11 22 33 2 .byte b_branch8 .byte 1b - . 2: .byte b_drop # 11 22 33 .byte b_exit .macro prs new_line = 1 .byte b_call16 .word prstack - . - 2 .if \new_line &gt; 0 .byte b_lit8, '\n' .byte b_emit .endif .endm .macro pr string .byte b_strp .byte 9f - 8f 8: .ascii "\n\string" 9: .endm item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte 0f - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte 1f - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa .byte b_execute .byte b_branch8 .byte 2f - . 1: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, 3f - . #     0, ,      3 .byte b_type #    .byte b_strp #   .byte 19 #     .ascii " : word not found!\n" .byte b_quit #    3: .byte b_nip, b_nip #  ,     ( b_over, b_over) 2: #       .byte b_depth #    .byte b_zlt # ,   0 ( 0&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte 14 .ascii "\nstack fault!\n" .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . 0: .byte b_drop .byte b_exit last_item: .byte b_var0 item bye, f_code .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start mov init_stack, rsp mov init_rstack, rbp jmp _next b_var0 = 0x28 bcmd_var0: push r8 b_exit = 0x17 bcmd_exit: mov r8, [rbp] add rbp, 8 _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*8] b_num0 = 0x02 bcmd_num0: push 0 jmp _next b_num1 = 0x03 bcmd_num1: push 1 jmp _next b_num2 = 0x04 bcmd_num2: push 2 jmp _next b_num3 = 0x05 bcmd_num3: push 3 jmp _next b_num4 = 0x06 bcmd_num4: push 4 jmp _next b_num8 = 0x07 bcmd_num8: push 8 jmp _next b_lit8 = 0x08 bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = 0x09 bcmd_lit16: movsx rax, word ptr [r8] add r8, 2 push rax jmp _next b_call8 = 0x0C bcmd_call8: movsx rax, byte ptr [r8] sub rbp, 8 inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = 0x0D bcmd_call16: movsx rax, word ptr [r8] sub rbp, 8 add r8, 2 mov [rbp], r8 add r8, rax jmp _next b_call32 = 0x0E bcmd_call32: movsx rax, dword ptr [r8] sub rbp, 8 add r8, 4 mov [rbp], r8 add r8, rax jmp _next b_lit32 = 0x0A bcmd_lit32: movsx rax, dword ptr [r8] add r8, 4 push rax jmp _next b_lit64 = 0x0B bcmd_lit64: mov rax, [r8] add r8, 8 push rax jmp _next b_dup = 0x30 bcmd_dup: push [rsp] jmp _next b_wm = 0x20 bcmd_wm: decq [rsp] jmp _next b_wp = 0x18 bcmd_wp: incq [rsp] jmp _next b_add = 0x21 bcmd_add: pop rax add [rsp], rax jmp _next b_sub = 0x22 bcmd_sub: pop rax sub [rsp], rax jmp _next b_mul = 0x23 bcmd_mul: pop rax pop rbx imul rbx push rax jmp _next b_div = 0x24 bcmd_div: pop rbx pop rax cqo idiv rbx push rax jmp _next b_mod = 0x25 bcmd_mod: pop rbx pop rax cqo idiv rbx push rdx jmp _next b_divmod = 0x26 bcmd_divmod: pop rbx pop rax cqo idiv rbx push rdx push rax jmp _next b_abs = 0x27 bcmd_abs: mov rax, [rsp] or rax, rax jge _next neg rax mov [rsp], rax jmp _next b_drop = 0x31 bcmd_drop: add rsp, 8 jmp _next b_swap = 0x32 bcmd_swap: pop rax pop rbx push rax push rbx jmp _next b_rot = 0x33 bcmd_rot: pop rax pop rbx pop rcx push rbx push rax push rcx jmp _next b_mrot = 0x34 bcmd_mrot: pop rcx pop rbx pop rax push rcx push rax push rbx jmp _next b_over = 0x35 bcmd_over: push [rsp + 8] jmp _next b_pick = 0x36 bcmd_pick: pop rcx push [rsp + 8*rcx] jmp _next b_roll = 0x37 bcmd_roll: pop rcx mov rbx, [rsp + 8*rcx] roll1: mov rax, [rsp + 8*rcx - 8] mov [rsp + 8*rcx], rax dec rcx jnz roll1 push rbx jmp _next b_depth = 0x38 bcmd_depth: mov rax, init_stack sub rax, rsp sar rax, 3 push rax jmp _next b_nip = 0x39 bcmd_nip: pop rax mov [rsp], rax jmp _next b_get = 0x40 bcmd_get: pop rcx push [rcx] jmp _next b_set = 0x41 bcmd_set: pop rcx pop rax mov [rcx], rax jmp _next b_get8 = 0x42 bcmd_get8: pop rcx movsx rax, byte ptr [rcx] push rax jmp _next b_set8 = 0x43 bcmd_set8: pop rcx pop rax mov [rcx], al jmp _next b_get16 = 0x44 bcmd_get16: pop rcx movsx rax, word ptr [rcx] push rax jmp _next b_set16 = 0x45 bcmd_set16: pop rcx pop rax mov [rcx], ax jmp _next b_get32 = 0x46 bcmd_get32: pop rcx movsx rax, dword ptr [rcx] push rax jmp _next b_set32 = 0x47 bcmd_set32: pop rcx pop rax mov [rcx], eax jmp _next b_setp = 0x48 bcmd_setp: pop rcx pop rax add [rcx], rax jmp _next b_setm = 0x49 bcmd_setm: pop rcx pop rax sub [rcx], rax jmp _next b_2r = 0x60 bcmd_2r: pop rax sub rbp, 8 mov [rbp], rax jmp _next b_r2 = 0x61 bcmd_r2: push [rbp] add rbp, 8 jmp _next b_rget = 0x62 bcmd_rget: push [rbp] jmp _next # 0= b_zeq = 0x50 bcmd_zeq: pop rax or rax, rax jnz rfalse rtrue: push -1 jmp _next rfalse: push 0 jmp _next # 0&lt; b_zlt = 0x51 bcmd_zlt: pop rax or rax, rax jl rtrue push 0 jmp _next # 0&gt; b_zgt = 0x52 bcmd_zgt: pop rax or rax, rax jg rtrue push 0 jmp _next # = b_eq = 0x53 bcmd_eq: pop rbx pop rax cmp rax, rbx jz rtrue push 0 jmp _next # &lt; b_lt = 0x54 bcmd_lt: pop rbx pop rax cmp rax, rbx jl rtrue push 0 jmp _next # &gt; b_gt = 0x55 bcmd_gt: pop rbx pop rax cmp rax, rbx jg rtrue push 0 jmp _next # &lt;= b_lteq = 0x56 bcmd_lteq: pop rbx pop rax cmp rax, rbx jle rtrue push 0 jmp _next # &gt;= b_gteq = 0x57 bcmd_gteq: pop rbx pop rax cmp rax, rbx jge rtrue push 0 jmp _next b_var8 = 0x29 bcmd_var8: push r8 b_branch8 = 0x10 bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_var16 = 0x30 bcmd_var16: push r8 b_branch16 = 0x11 bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = 0x12 bcmd_qbranch8: pop rax or rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = 0x13 bcmd_qbranch16: pop rax or rax, rax jnz bcmd_branch16 add r8, 2 jmp _next b_qnbranch8 = 0x14 bcmd_qnbranch8: pop rax or rax, rax jz bcmd_branch8 inc r8 jmp _next b_qnbranch16 = 0x15 bcmd_qnbranch16:pop rax or rax, rax jz bcmd_branch16 add r8, 2 jmp _next b_bad = 0x00 bcmd_bad: mov rax, 1 #    1 - sys_write mov rdi, 1 #   1  stdout mov rsi, offset msg_bad_byte #     mov rdx, msg_bad_byte_len #   syscall #   mov rax, 60 #    1 - sys_exit mov rbx, 1 #    1 syscall #   b_bye = 0x01 bcmd_bye: mov rax, 1 #    1 - sys_write mov rdi, 1 #   1  stdout mov rsi, offset msg_bye #     mov rdx, msg_bye_len #   syscall #   mov rax, 60 #    60 - sys_exit mov rdi, 0 #    0 syscall #   b_strp = 0x83 bcmd_strp: movsx rax, byte ptr [r8] inc r8 push r8 add r8, rax push rax b_type = 0x80 bcmd_type: mov rax, 1 #    1 - sys_write mov rdi, 1 #   1 - stdout pop rdx #   pop rsi #   push r8 syscall #   pop r8 jmp _next b_expect = 0x88 bcmd_expect: mov rax, 0 #    1 - sys_read mov rdi, 0 #   1 - stdout pop rdx #   pop rsi #   push r8 syscall #   pop r8 mov rbx, rax or rax, rax jge 1f xor rbx, rbx 1: mov v_span, rbx jmp _next b_str = 0x82 bcmd_str: movzx rax, byte ptr [r8] lea r8, [r8 + rax + 1] jmp _next b_count = 0x84 bcmd_count: pop rcx movzx rax, byte ptr [rcx] inc rcx push rcx push rax jmp _next b_emit = 0x81 bcmd_emit: pop rax mov rsi, offset emit_buf #   mov [rsi], al mov rax, 1 #    1 - sys_write mov rdi, 1 #   1 - stdout mov rdx, 1 #   push r8 syscall #   pop r8 jmp _next b_blword = 0xF0 bcmd_blword: mov rsi, v_tib #    mov rdx, rsi #   RDX       mov rax, v_in #     mov rcx, v_ntib #    mov rbx, rcx add rsi, rax #  RSI -      sub rcx, rax #     jz 3f word2: lodsb #   AL  RSI   cmp al, ' ' ja 1f #    (    ) dec rcx jnz word2 #    3: sub rsi, rdx mov v_in, rsi push rcx jmp _next 1: lea rdi, [rsi - 1] # RDI = RSI - 1 ( ) dec rcx jz word9 word3: lodsb cmp al, ' ' jbe 2f dec rcx jnz word3 word9: inc rsi 2: mov rax, rsi sub rsi, rdx #        (   ) cmp rsi, rbx jle 4f mov rsi, rbx 4: mov v_in, rsi sub rax, rdi dec rax jz word1 push rdi #   word1: push rax #   jmp _next b_quit = 0xF1 bcmd_quit: lea r8, quit mov rsp, init_stack mov rbp, init_rstack jmp _next b_find = 0xF2 bcmd_find: pop rbx #   pop r9 #   mov rdx, v_context mov rdx, [rdx] #        #   find0: mov al, [rdx] #  and al, 3 #   -     ,     ,    or al, al jz find_l8 cmp al, 1 jz find_l16 cmp al, 2 jz find_l32 mov r10, [rdx + 1] #  64  lea rsi, [rdx + 9] #   jmp find1 find_l32: movsx r10, dword ptr [rdx + 1] #  32  lea rsi, [rdx + 5] #   jmp find1 find_l16: movsx r10, word ptr [rdx + 1] #  16  lea rsi, [rdx + 3] #   jmp find1 find_l8: movsx r10, byte ptr [rdx + 1] #  8  lea rsi, [rdx + 2] #   find1: movzx rax, byte ptr [rsi] #       cmp rax, rbx jz find2 #      find3: or r10, r10 jz find_notfound #  ,    add rdx, r10 #     jmp find0 #  ,   find2: inc rsi mov rdi, r9 mov rcx, rax repz cmpsb jnz find3 #   push rdx jmp _next find_notfound: push r10 jmp _next b_cfa = 0xF3 bcmd_cfa: pop rdx #    mov al, [rdx] #  and al, 3 #   -     ,     ,    or al, al jz cfa_l8 cmp al, 1 jz cfa_l16 cmp al, 2 jz cfa_l32 lea rsi, [rdx + 9] #   (64  ) jmp cfa1 cfa_l32: lea rsi, [rdx + 5] #   (32  ) jmp cfa1 cfa_l16: lea rsi, [rdx + 3] #   (16  ) jmp cfa1 cfa_l8: lea rsi, [rdx + 2] #   (8  ) cfa1: xor rax, rax lodsb add rsi, rax push rsi jmp _next b_execute = 0xF4 bcmd_execute: sub rbp, 8 mov [rbp], r8 #       pop r8 #  - jmp _next b_numberq = 0xF5 bcmd_numberq: pop rcx #   pop rsi #  xor rax, rax #   xor rbx, rbx #     mov r9, v_base #  xor r10, r10 #   or rcx, rcx jz num_false mov bl, [rsi] cmp bl, '+' jnz 1f inc rsi dec rcx jz num_false jmp num0 1: cmp bl, '-' jnz num0 mov r10, 1 inc rsi dec rcx jz num_false num0: mov bl, [rsi] cmp bl, '0' jb num_false cmp bl, '9' jbe num_09 cmp bl, 'A' jb num_false cmp bl, 'Z' jbe num_AZ cmp bl, 'a' jb num_false cmp bl, 'z' ja num_false sub bl, 'a' - 10 jmp num_check num_AZ: sub bl, 'A' - 10 jmp num_check num_09: sub bl, '0' num_check: cmp rbx, r9 jge num_false mul r9 add rax, rbx inc rsi dec rcx jnz num0 or r10, r10 push rax push 1 jmp _next num_false: xor rcx, rcx push rcx jmp _next</span></span></span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code source s'agrandit, donc je l'apporte ici pour la derni√®re fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, son lieu de r√©sidence sera sur le github: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/hal9000cc/forth64</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au m√™me endroit, dans le dossier bin, vous pouvez trouver la version d√©j√† compil√©e pour Linux x64. Qui a Linux, vous pouvez t√©l√©charger et ex√©cuter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et qui a Windows - vous pouvez installer WSL (Windows Subsystem for Linux). Je partais pour les vacances et je l'ai fait. Cela s'est av√©r√© √™tre tr√®s simple, cela a pris environ 5 minutes. Il n'y a eu qu'un instant, il n'a pas d√©marr√© tout de suite, le sous-syst√®me a d√ª √™tre "activ√©" via la commande PowerShell. Suivi le lien du message d'erreur, ex√©cut√© la commande et cela a fonctionn√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais il y a aussi un moyen pour les vrais Indiens de tout faire fonctionner sous Windows :) Ce n'est pas difficile √† faire, il suffit de refaire quelques mots qui interagissent avec le syst√®me.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C‚Äôest tout! </font><font style="vertical-align: inherit;">La prochaine fois, nous ex√©cuterons le compilateur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y aura l'occasion de compiler de nouveaux mots, il y aura des conditions, des cycles. </font><font style="vertical-align: inherit;">En fait, il sera possible d'√©crire sur un fort plus ou moins standard, de le compiler en code octet et de l'ex√©cuter. </font><font style="vertical-align: inherit;">Eh bien, il sera possible d'effectuer des tests plus s√©rieux, de v√©rifier les performances de la machine √† octets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suite: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte-machine pour le fort (et pas seulement) en am√©rindien (partie 4)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435236/">https://habr.com/ru/post/fr435236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435220/index.html">Kotlin Native: garder une trace des fichiers</a></li>
<li><a href="../fr435224/index.html">Comment communiquer dans un bureau anglophone: 14 idiomes utiles</a></li>
<li><a href="../fr435226/index.html">Restaurer les donn√©es √† partir de z√©ro</a></li>
<li><a href="../fr435228/index.html">Cluster Kubernetes pour 20 $ par mois</a></li>
<li><a href="../fr435234/index.html">Plus intelligent, plus loin et plus pr√©cis√©ment: comment l'IA transforme les vols dans l'espace</a></li>
<li><a href="../fr435240/index.html">Unreal Engine4 - Effet de scan PostProcess</a></li>
<li><a href="../fr435242/index.html">Pourquoi ai-je peur de devenir un "homme pomp√©"</a></li>
<li><a href="../fr435244/index.html">Projet ITER en 2018</a></li>
<li><a href="../fr435246/index.html">Tesla a ouvert des pr√©commandes pour le mod√®le 3 en Europe et en Chine</a></li>
<li><a href="../fr435248/index.html">Navigation dans l'application Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>