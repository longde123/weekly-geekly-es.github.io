<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèª üí™üèø üïí Como escrever testes de unidade para atores? Abordagem SObjectizer üë• üõÄüèΩ ‚ù£Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Os atores simplificam a programa√ß√£o multithread, evitando um estado mut√°vel compartilhado e compartilhado. Cada ator possui seus pr√≥prios dados que n√£...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como escrever testes de unidade para atores? Abordagem SObjectizer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435606/">  Os atores simplificam a programa√ß√£o multithread, evitando um estado mut√°vel compartilhado e compartilhado.  Cada ator possui seus pr√≥prios dados que n√£o s√£o vis√≠veis para ningu√©m.  Os atores interagem apenas atrav√©s de mensagens ass√≠ncronas.  Portanto, os horrores mais aterrorizantes do multithreading na forma de ra√ßas e impasses ao usar atores n√£o s√£o terr√≠veis (embora os atores tenham seus problemas, mas isso n√£o √© sobre isso agora). <br><br>  Em geral, escrever aplicativos multithread usando atores √© f√°cil e agrad√°vel.  Inclusive porque os pr√≥prios atores s√£o escritos com facilidade e naturalidade.  Voc√™ poderia at√© dizer que escrever o c√≥digo do ator √© a parte mais f√°cil do trabalho.  Mas quando o ator √© escrito, surge uma pergunta muito boa: "Como verificar a corre√ß√£o de seu trabalho?" <br><br>  A quest√£o √© realmente muito boa.  Nos perguntam regularmente quando falamos sobre atores em geral e sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SObjectizer</a> em particular.  E at√© recentemente, poder√≠amos responder a essa pergunta apenas em termos gerais. <br><br>  Mas a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vers√£o 5.5.24 foi lan√ßada</a> , na qual havia suporte experimental para a possibilidade de teste de unidade dos atores.  E neste artigo, tentaremos falar sobre o que √©, como us√°-lo e com o que foi implementado. <br><a name="habracut"></a><br><h1>  Como s√£o os testes de ator? </h1><br>  Vamos considerar os novos recursos do SObjectizer em alguns exemplos, transmitindo o que √© o qu√™.  O c√≥digo fonte dos exemplos discutidos pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste reposit√≥rio</a> . <br><br>  Ao longo da hist√≥ria, os termos "ator" e "agente" ser√£o usados ‚Äã‚Äãde forma intercambi√°vel.  Eles designam a mesma coisa, mas no SObjectizer o termo "agente" √© usado historicamente, portanto, mais "agente" ser√° usado com mais frequ√™ncia. <br><br><h2>  O exemplo mais simples com Pinger e Ponger </h2><br>  O exemplo dos atores Pinger e Ponger √© provavelmente o exemplo mais comum para estruturas de atores.  Pode-se dizer um cl√°ssico.  Bem, se sim, ent√£o vamos come√ßar com os cl√°ssicos. <br><br>  Portanto, temos um agente Pinger que, no in√≠cio de seu trabalho, envia uma mensagem Ping ao agente Ponger.  E o agente Ponger envia de volta uma mensagem Pong.  √â assim que fica no c√≥digo C ++: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Types of signals to be used. struct ping final : so_5::signal_t {}; struct pong final : so_5::signal_t {}; // Pinger agent. class pinger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : pinger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;pong&gt;) { so_deregister_agent_coop_normally(); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } void so_evt_start() override { so_5::send&lt; ping &gt;( m_target ); } }; // Ponger agent. class ponger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : ponger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;ping&gt;) { so_5::send&lt; pong &gt;( m_target ); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } };</span></span></code> </pre> <br>  Nossa tarefa √© escrever um teste que verifique se, ao registrar esses agentes no SObjectizer, o Ponger receber√° uma mensagem Ping e o Pinger receber√° uma mensagem Pong em resposta. <br><br>  OK  Escrevemos esse teste usando a estrutura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">doctest</a> unit-test e obtemos: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;doctest/doctest.h&gt; #include &lt;ping_pong/agents.hpp&gt; #include &lt;so_5/experimental/testing.hpp&gt; namespace tests = so_5::experimental::testing; TEST_CASE( "ping_pong" ) { tests::testing_env_t sobj; pinger_t * pinger{}; ponger_t * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::coop_t &amp; coop) { pinger = coop.make_agent&lt; pinger_t &gt;(); ponger = coop.make_agent&lt; ponger_t &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); }); sobj.scenario().define_step("ping") .when(*ponger &amp; tests::reacts_to&lt;ping&gt;()); sobj.scenario().define_step("pong") .when(*pinger &amp; tests::reacts_to&lt;pong&gt;()); sobj.scenario().run_for(std::chrono::milliseconds(100)); REQUIRE(tests::completed() == sobj.scenario().result()); }</span></span></span></span></code> </pre> <br>  Parece ser f√°cil.  Vamos ver o que acontece aqui. <br><br>  Primeiro, baixamos descri√ß√µes das ferramentas de suporte ao teste do agente: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/experimental/testing.hpp&gt;</span></span></span></span></code> </pre> <br>  Todas essas ferramentas s√£o descritas no namespace so_5 :: experimental :: testing, mas, para n√£o repetir um nome t√£o longo, introduzimos um alias mais curto e mais conveniente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tests = so_5::experimental::testing;</code> </pre> <br>  A seguir, √© apresentada uma descri√ß√£o de um √∫nico caso de teste (e n√£o precisamos mais aqui). <br><br>  Dentro do caso de teste, existem v√°rios pontos-chave. <br><br>  Primeiramente, esta √© a cria√ß√£o e o lan√ßamento de um ambiente de teste especial para o SObjectizer: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj;</code> </pre> <br>  Sem esse ambiente, a ‚Äúexecu√ß√£o de teste‚Äù para agentes n√£o pode ser conclu√≠da, mas falaremos sobre isso um pouco mais tarde. <br><br>  A classe testing_env_t √© muito semelhante √† classe wrap_env_t no SObjectizer.  Da mesma maneira, o SObjectizer inicia no construtor e para no destruidor.  Portanto, ao escrever testes, voc√™ n√£o precisa pensar em iniciar e parar o SObjectizer. <br><br>  Em seguida, precisamos criar e registrar agentes Pinger e Ponger.  Nesse caso, precisamos usar esses agentes para determinar o chamado.  "Cen√°rio de teste".  Portanto, armazenamos separadamente ponteiros para agentes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  E ent√£o come√ßamos a trabalhar com o "cen√°rio de teste". <br><br>  Um caso de teste √© uma pe√ßa que consiste em uma sequ√™ncia direta de etapas que devem ser conclu√≠das do come√ßo ao fim.  A frase "de uma sequ√™ncia direta" significa que no SObjectizer-5.5.24 as etapas do script "funcionam" estritamente em sequ√™ncia, sem ramifica√ß√µes ou loops. <br><br>  Escrever um teste para agentes √© a defini√ß√£o de um script de teste que precisa ser executado.  I.e.  todas as etapas do cen√°rio de teste devem funcionar, desde a primeira at√© a √∫ltima. <br><br>  Portanto, em nosso caso de teste, definimos um cen√°rio de duas etapas.  A primeira etapa verifica se o agente Ponger receber√° e processar√° a mensagem Ping: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"ping"</span></span>) .when(*ponger &amp; tests::reacts_to&lt;ping&gt;());</code> </pre> <br>  A segunda etapa verifica se o agente Pinger recebe uma mensagem Pong: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"pong"</span></span>) .when(*pinger &amp; tests::reacts_to&lt;pong&gt;());</code> </pre> <br>  Essas duas etapas s√£o suficientes para o nosso caso de teste; portanto, ap√≥s sua determina√ß√£o, prosseguimos para a execu√ß√£o do script.  Executamos o script e permitimos que ele funcione n√£o mais do que 100ms: <br><br><pre> <code class="cpp hljs">sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>));</code> </pre> <br>  Cem milissegundos deve ser mais do que suficiente para os dois agentes trocarem mensagens (mesmo se o teste for executado em uma m√°quina virtual muito lenta, como √†s vezes √© o caso do Travis CI).  Bem, se cometemos um erro ao escrever agentes ou descrevemos incorretamente um script de teste, aguardar a conclus√£o de um script incorreto por mais de 100 ms n√£o faz sentido. <br><br>  Portanto, depois de retornar de run_for (), nosso script pode ser conclu√≠do com √™xito ou n√£o.  Portanto, simplesmente verificamos o resultado do script: <br><br><pre> <code class="cpp hljs">REQUIRE(tests::completed() == sobj.scenario().result());</code> </pre> <br>  Se o script n√£o foi conclu√≠do com √™xito, isso levar√° √† falha do nosso caso de teste. <br><br><h3>  Alguns esclarecimentos e acr√©scimos </h3><br>  Se executarmos esse c√≥digo dentro de um SObjectizer normal: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  ent√£o, muito provavelmente, os agentes Pinger e Ponger conseguiriam trocar mensagens e concluir seu trabalho antes de retornar do introdutor_coop (milagres de multithreading s√£o tais).  Mas dentro do ambiente de teste, criado gra√ßas a testing_env_t, isso n√£o acontece, os agentes Pinger e Ponger esperam pacientemente at√© executarmos nosso script de teste.  Como isso acontece? <br><br>  O fato √© que, dentro do ambiente de teste, os agentes parecem estar congelados.  I.e.  ap√≥s o registro, eles est√£o presentes no SObjectizer, mas n√£o podem processar nenhuma de suas mensagens.  Portanto, mesmo que so_evt_start () n√£o seja chamado para agentes antes da execu√ß√£o do script de teste. <br><br>  Quando executamos o script de teste usando o m√©todo run_for (), o script de teste primeiro descongela todos os agentes congelados.  E ent√£o o script come√ßa a receber notifica√ß√µes do SObjectizer sobre o que acontece com os agentes.  Por exemplo, que o agente Ponger recebeu a mensagem Ping e que o agente Ponger processou a mensagem, mas n√£o a rejeitou. <br><br>  Quando essas notifica√ß√µes come√ßam a chegar ao script de teste, o script tenta "experiment√°-las" na primeira etapa.  Portanto, temos uma notifica√ß√£o de que o Ponger recebeu e processou o Ping - √© interessante para n√≥s ou n√£o?  Acontece que √© interessante, porque a descri√ß√£o da etapa diz exatamente isso: funciona quando Ponger reage ao Ping.  O que vemos no c√≥digo: <br><br><pre> <code class="cpp hljs">.when(*ponger &amp; tests::reacts_to&lt;ping&gt;())</code> </pre> <br>  OK  Portanto, o primeiro passo funcionou, v√° para o pr√≥ximo passo. <br><br>  Em seguida, vem uma notifica√ß√£o de que o agente Pinger reagiu a Pong.  E √© exatamente isso que voc√™ precisa para o segundo passo para o trabalho: <br><br><pre> <code class="cpp hljs">.when(*pinger &amp; tests::reacts_to&lt;pong&gt;())</code> </pre> <br>  OK  Ent√£o, o segundo passo funcionou, temos mais alguma coisa?  N√£o.  Isso significa que todo o script de teste foi conclu√≠do e voc√™ pode retornar o controle de run_for (). <br><br>  Aqui, em princ√≠pio, como o script de teste funciona.  De fato, tudo √© um pouco mais complicado, mas abordaremos aspectos mais complexos quando considerarmos um exemplo mais complexo. <br><br><h2>  Exemplo de Fil√≥sofos </h2><br>  Exemplos mais complexos de agentes de teste podem ser vistos na solu√ß√£o da tarefa bem conhecida ‚ÄúComer fil√≥sofos.  Sobre os atores, esse problema pode ser resolvido de v√°rias maneiras.  A seguir, consideraremos a solu√ß√£o mais trivial: atores e fil√≥sofos s√£o representados na forma de atores, pelos quais os fil√≥sofos precisam lutar.  Cada fil√≥sofo pensa por um tempo, depois tenta pegar o garfo √† esquerda.  Se isso der certo, ele tenta pegar o garfo √† direita.  Se isso der certo, o fil√≥sofo come por algum tempo, ap√≥s o que abaixa os garfos e come√ßa a pensar.  Se n√£o foi poss√≠vel colocar o plugue √† direita (ou seja, foi tirado por outro fil√≥sofo), o fil√≥sofo devolve o plugue √† esquerda e pensa por mais algum tempo.  I.e.  essa n√£o √© uma boa solu√ß√£o no sentido de que algum fil√≥sofo pode passar fome por muito tempo.  Mas ent√£o √© muito simples.  E tem o escopo de demonstrar a capacidade de testar agentes. <br><br>  Os c√≥digos-fonte com a implementa√ß√£o dos agentes Fork e Philosopher podem ser encontrados <a href="">aqui</a> , no artigo n√£o os consideraremos para economizar espa√ßo. <br><br><h3>  Teste para garfo </h3><br>  O primeiro teste para agentes do Dining Philosophers ser√° para o agente Fork. <br><br>  Este agente funciona de acordo com um esquema simples.  Ele tem dois estados: Livre e Tomado.  Quando o agente est√° no estado Livre, ele responde a uma mensagem Receber.  Nesse caso, o agente entra no estado de Tomada e responde com uma mensagem de resposta Tomada. <br><br>  Quando o agente est√° no estado Tomado, ele responde √† mensagem Receber de maneira diferente: o estado do agente n√£o muda e Ocupado √© enviado como uma mensagem de resposta.  Tamb√©m no estado Tomado, o agente responde √† mensagem Colocar: o agente retorna ao estado Livre. <br><br>  No estado Livre, a mensagem Colocar √© ignorada. <br><br>  Vamos tentar testar este por meio do seguinte caso de teste: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"fork"</span></span> ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } }; tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>&gt;(); }); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_taken"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;(), *philosopher &amp; tests::reacts_to&lt;msg_busy&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>) .impact&lt;msg_put&gt;(*fork) .when( *fork &amp; tests::reacts_to&lt;msg_put&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>)); REQUIRE(tests::completed() == sobj.scenario().result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"free"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); }</code> </pre> <br>  H√° muito c√≥digo, ent√£o vamos lidar com ele em partes, pulando os fragmentos que j√° devem estar claros. <br><br>  A primeira coisa que precisamos aqui √© substituir o verdadeiro agente fil√≥sofo.  Um agente do Fork deve receber mensagens de algu√©m e responder a algu√©m.  Mas n√£o podemos usar o fil√≥sofo real neste caso de teste, porque o agente fil√≥sofo real tem sua pr√≥pria l√≥gica de comportamento, ele envia mensagens ele mesmo e essa independ√™ncia interfere aqui. <br><br>  Portanto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">zombamos</a> , ou seja,  em vez do verdadeiro fil√≥sofo, apresentaremos um substituto para ele: um agente vazio que n√£o envia nada, mas recebe apenas mensagens enviadas, sem nenhum processamento √∫til.  Este √© o pseudo-fil√≥sofo implementado no c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } };</code> </pre> <br>  Em seguida, criamos uma colabora√ß√£o do agente Fork e do agente PseudoPhiloospher e come√ßamos a determinar o conte√∫do do nosso caso de teste. <br><br>  A primeira etapa do script √© verificar se o Fork, estando no estado Livre (e este √© seu estado inicial), n√£o responde √† mensagem Put.  Veja como esta verifica√ß√£o √© escrita: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;());</code> </pre> <br>  A primeira coisa que chama a aten√ß√£o √© a constru√ß√£o do impacto. <br><br>  Ela √© necess√°ria porque nosso agente Fork n√£o faz nada, ele apenas reage √†s mensagens recebidas.  Portanto, algu√©m deve enviar uma mensagem ao agente.  Mas quem? <br><br>  Mas a pr√≥pria etapa do script envia impacto.  De fato, o impacto √© um an√°logo da fun√ß√£o de envio usual (e o formato √© o mesmo). <br><br>  Bem, a pr√≥pria etapa do script enviar√° uma mensagem atrav√©s do impacto.  Mas quando ele far√° isso? <br><br>  E ele far√° isso quando chegar a sua vez.  I.e.  se a etapa no script for a primeira, o impacto ser√° executado imediatamente ap√≥s a inser√ß√£o de run_for.  Se a etapa no script n√£o for a primeira, o impacto ser√° executado assim que a etapa anterior tiver funcionado e o script prosseguir√° para processar a pr√≥xima etapa. <br><br>  A segunda coisa que precisamos discutir aqui √© chamada ignora.  Essa fun√ß√£o auxiliar diz que a etapa √© acionada quando o agente falha ao processar a mensagem.  I.e.  nesse caso, o agente Fork deve se recusar a processar a mensagem Put. <br><br>  Vamos considerar mais uma etapa do cen√°rio de teste com mais detalhes: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;());</code> </pre><br>  Primeiro, aqui vemos quando tudo em vez de quando.  Isso ocorre porque, para disparar uma etapa, precisamos preencher v√°rias condi√ß√µes ao mesmo tempo.  O agente do garfo precisa lidar com o Take.  E o fil√≥sofo precisa lidar com a resposta Tomada.  Portanto, escrevemos when_all, n√£o when.  A prop√≥sito, tamb√©m h√° quando_qualquer, mas n√£o nos encontraremos com ele nos exemplos considerados hoje. <br><br>  Em segundo lugar, tamb√©m precisamos verificar o fato de que, ap√≥s o processamento do Take, o agente do Fork estar√° no estado Tomado.  Fazemos a verifica√ß√£o da seguinte maneira: primeiro, indicamos que, assim que o agente Fork terminar o processamento do Take, o nome do seu estado atual deve ser salvo usando a tag "fork".  Essa constru√ß√£o apenas preserva o nome do estado do agente: <br><br><pre> <code class="cpp hljs">&amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)</code> </pre> <br>  E ent√£o, quando o script √© conclu√≠do com √™xito, verificamos este nome salvo: <br><pre> <code class="cpp hljs">REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>));</code> </pre> <br>  I.e.  pedimos o script: forne√ßa o nome que foi salvo com a tag fork da etapa chamada take_when_free e, em seguida, compare o nome com o valor esperado. <br><br>  Aqui, talvez, esteja tudo o que pode ser observado no caso de teste do agente Fork.  Se os leitores tiverem alguma d√∫vida, pergunte nos coment√°rios, responderemos com prazer. <br><br><h3>  Teste de script bem-sucedido para fil√≥sofo </h3><br>  Para o agente fil√≥sofo, consideraremos apenas um caso de teste - para o caso em que o fil√≥sofo pode pegar os garfos e comer. <br><br>  Este caso de teste ter√° a seguinte apar√™ncia: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"philosopher (takes both forks)"</span></span> ) { tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } }; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * left_fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * right_fork{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { left_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); right_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>&gt;( <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>, left_fork-&gt;so_direct_mbox(), right_fork-&gt;so_direct_mbox()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scenario = sobj.scenario(); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_left"</span></span>) .when( *left_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_right"</span></span>) .when( *right_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_eating&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"return_forks"</span></span>) .when_all( *left_fork &amp; tests::reacts_to&lt;msg_put&gt;(), *right_fork &amp; tests::reacts_to&lt;msg_put&gt;() ); scenario.run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds(<span class="hljs-number"><span class="hljs-number">1</span></span>)); REQUIRE(tests::completed() == scenario.result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_left"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_right"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"eating"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"thinking"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); }</code> </pre> <br>  Bastante volumoso, mas trivial.  Primeiro, verifique se o fil√≥sofo terminou de pensar e come√ßou a se preparar para a comida.  Depois, verificamos que ele tentou pegar o garfo esquerdo.  Em seguida, ele deve tentar pegar o garfo certo.  Ent√£o ele deve comer e interromper esta atividade.  Ent√£o ele deve colocar os dois garfos. <br><br>  Em geral, tudo √© simples.  Mas voc√™ deve se concentrar em duas coisas. <br><br>  Primeiro, a classe testing_env_t, como seu prot√≥tipo, wrap_env_t, permite personalizar o ambiente do SObjectizer.  Usaremos isso para ativar o mecanismo de rastreamento de entrega de mensagens: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } };</code> </pre> <br>  Esse mecanismo permite que voc√™ "visualize" o processo de entrega de mensagens, o que ajuda na investiga√ß√£o do comportamento do agente (j√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conversamos</a> sobre isso em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mais detalhes</a> ). <br><br>  Em segundo lugar, o agente Philosopher realiza uma s√©rie de a√ß√µes n√£o imediatamente, mas depois de algum tempo.  Portanto, come√ßando a funcionar, o agente deve enviar uma mensagem StopThinking pendente.  Portanto, essa mensagem deve chegar ao agente ap√≥s alguns milissegundos.  O que indicamos definindo a restri√ß√£o necess√°ria para uma determinada etapa: <br><br><pre> <code class="cpp hljs">scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) );</code> </pre> <br>  I.e.  aqui dizemos que n√£o estamos interessados ‚Äã‚Äãem nenhuma rea√ß√£o do agente fil√≥sofo ao StopThinking, mas apenas no que ocorreu antes de 250ms ap√≥s o in√≠cio do processamento desta etapa. <br><br>  Uma restri√ß√£o do tipo not_before informa ao script que todos os eventos que ocorrem antes que o tempo limite especificado expire devem ser ignorados. <br><br>  H√° tamb√©m uma restri√ß√£o no formul√°rio not_after, que funciona ao contr√°rio: somente os eventos que ocorrem at√© o tempo limite especificado expirar s√£o levados em considera√ß√£o. <br><br>  As restri√ß√µes not_before e not_after podem ser combinadas, por exemplo: <br><br><pre> <code class="cpp hljs">.constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)), tests::not_after(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">1250</span></span>)))</code> </pre> <br>  mas, nesse caso, o SObjectizer n√£o verifica a consist√™ncia dos valores fornecidos. <br><br><h1>  Como voc√™ conseguiu implementar isso? </h1><br>  Eu gostaria de dizer algumas palavras sobre como tudo come√ßou a funcionar.  Afinal, em geral, fomos confrontados com uma grande quest√£o ideol√≥gica: "Como testar agentes em princ√≠pio?"  e uma pergunta menor, j√° t√©cnica: "Como implementar isso?" <br><br>  E se sobre a ideologia de teste foi poss√≠vel sair da sua mente, ent√£o sobre a implementa√ß√£o a situa√ß√£o foi mais complicada.  Era necess√°rio encontrar uma solu√ß√£o que, em primeiro lugar, n√£o exigisse uma altera√ß√£o radical dos interiores do SObjectizer.  E, em segundo lugar, deveria ser uma solu√ß√£o que pudesse ser implementada no curto prazo previs√≠vel e, muito desej√°vel. <br><br>  Como resultado do dif√≠cil processo de fumar bambu, foi encontrada uma solu√ß√£o.  Para isso, foi necess√°rio, de fato, fazer apenas uma pequena inova√ß√£o no comportamento regular do SObjectizer.  E a base da solu√ß√£o √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mecanismo de envelope de mensagem, que foi adicionado na vers√£o 5.5.23 e sobre o qual j√° falamos</a> . <br><br>  Dentro do ambiente de teste, cada mensagem enviada √© embrulhada em um envelope especial.  Quando um envelope com uma mensagem √© entregue ao agente para processamento (ou, inversamente, rejeitado pelo agente), o cen√°rio de teste fica ciente disso.  Gra√ßas aos envelopes, o script de teste sabe o que est√° acontecendo e pode determinar os momentos em que o script "funciona". <br><br>  Mas como fazer o SObjectizer envolver cada mensagem em um envelope especial? <br><br>  Essa foi uma pergunta interessante.  Ele decidiu da seguinte maneira: um conceito como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">event_queue_hook</a> foi inventado.  Este √© um objeto especial com dois m√©todos - on_bind e on_unbind. <br><br>  Quando um agente √© vinculado a um despachante espec√≠fico, o despachante emite um event_queue do agente para o agente.  Por meio dessa event_queue, as solicita√ß√µes do agente entram na fila necess√°ria e ficam dispon√≠veis para o expedidor para processamento.  Quando um agente √© executado dentro de um SObjectizer, ele possui um ponteiro para event_queue.  Quando um agente √© removido de um SObjectizer, seu ponteiro para event_queue √© anulado. <br><br>  Portanto, a partir da vers√£o 5.5.24, o agente, ap√≥s o recebimento do event_queue, deve chamar o m√©todo on_bind do event_queue_hook.  Onde o agente deve passar o ponteiro recebido para event_queue.  E event_queue_hook pode retornar o mesmo ponteiro ou outro ponteiro em resposta.  E o agente deve usar o valor retornado. <br><br>  Quando um agente √© removido de um SObjectizer, ele deve chamar on_unbind em event_queue_hook.  Em on_unbind, o agente transmite o valor retornado pelo m√©todo on_bind. <br><br>  Toda essa cozinha √© executada dentro do SObjectizer e o usu√°rio n√£o v√™ nada disso.  E, em princ√≠pio, voc√™ pode n√£o saber nada disso.  Mas o ambiente de teste do SObjectizer, o mesmo testing_env_t, explora exatamente event_queue_hook.  Dentro testing_env_t, uma implementa√ß√£o especial de event_queue_hook √© criada.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa implementa√ß√£o em on_bind agrupa cada event_queue em um objeto proxy especial. </font><font style="vertical-align: inherit;">E esse objeto proxy j√° coloca as mensagens enviadas ao agente em um envelope especial.</font></font><br><br>  Mas isso n√£o √© tudo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ deve se lembrar que, em um ambiente de teste, os agentes devem ser congelados. </font><font style="vertical-align: inherit;">Isso tamb√©m √© implementado atrav√©s dos objetos proxy mencionados. </font><font style="vertical-align: inherit;">Enquanto o script de teste n√£o estiver em execu√ß√£o, o objeto proxy armazena as mensagens enviadas para o agente em casa. </font><font style="vertical-align: inherit;">Mas quando o script √© executado, o objeto proxy transfere todas as mensagens acumuladas anteriormente para a fila de mensagens atual do agente.</font></font><br><br><h1>  Conclus√£o </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em conclus√£o, quero dizer duas coisas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, implementamos nossa vis√£o de como os agentes podem ser testados no SObjectizer. Minha opini√£o, porque n√£o existem tantos bons exemplos por a√≠. N√≥s olhamos para </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akka.Testing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mas o Akka e o SObjectizer s√£o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muito diferentes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para portar as abordagens que funcionam no Akka para o SObjectizer. E o C ++ n√£o √© Scala / Java, no qual algumas coisas relacionadas √† introspec√ß√£o podem ser feitas devido √† reflex√£o. Ent√£o eu tive que criar uma abordagem que fosse do SObjectizer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na vers√£o 5.5.24, a primeira implementa√ß√£o experimental ficou dispon√≠vel. Certamente voc√™ pode fazer melhor. Mas como entender o que ser√° √∫til e o que s√£o fantasias in√∫teis? Infelizmente nada. Voc√™ precisa tomar e tentar, ver o que acontece na pr√°tica. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por isso, criamos uma vers√£o m√≠nima que voc√™ pode usar e experimentar. O que nos propomos a fazer por todos: experimente, experimente e compartilhe suas impress√µes conosco. O que voc√™ gostou, o que voc√™ n√£o gostou? Talvez algo esteja faltando? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, as palavras ditas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no in√≠cio de 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tornaram-se ainda mais relevantes </font><font style="vertical-align: inherit;">:</font></font><br><blockquote> ‚Ä¶       ,   ,   ,    .      -      ‚Äî      .             .      . :  ,   . <br><br>    ,  ,   ,       ‚Äî    ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, meu conselho para aqueles que procuram uma estrutura de ator pronta: preste aten√ß√£o n√£o apenas √† originalidade das id√©ias e √† beleza dos exemplos. </font><font style="vertical-align: inherit;">Veja tamb√©m todos os tipos de coisas auxiliares que ajudar√£o voc√™ a descobrir o que est√° acontecendo no seu aplicativo: por exemplo, para descobrir quantos atores est√£o dentro agora, quais s√£o os tamanhos de fila deles, se a mensagem n√£o chegar ao destinat√°rio, ent√£o para onde ele vai ... Se a estrutura fornece algo assim, ser√° mais f√°cil para voc√™. </font><font style="vertical-align: inherit;">Caso contr√°rio, voc√™ ter√° mais trabalho.</font></font><br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tudo isso √© ainda mais importante quando se trata de testar atores. </font><font style="vertical-align: inherit;">Portanto, ao escolher uma estrutura de ator para si mesmo, preste aten√ß√£o no que est√° nela e no que n√£o est√°. </font><font style="vertical-align: inherit;">Por exemplo, j√° temos em nosso kit de ferramentas para simplificar os testes :)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435606/">https://habr.com/ru/post/pt435606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435592/index.html">A√ßores: √∫ltima reserva de flora no meio do Oceano Atl√¢ntico</a></li>
<li><a href="../pt435594/index.html">Gr√°fico de rotas para Apache Camel</a></li>
<li><a href="../pt435600/index.html">Como migrar para outra operadora de celular e n√£o entrar em fal√™ncia (para propriet√°rios de iOS)</a></li>
<li><a href="../pt435602/index.html">Prepara√ß√£o para o Exame do Azure</a></li>
<li><a href="../pt435604/index.html">BlaBlaCar tornou-se o que n√£o se destinava</a></li>
<li><a href="../pt435608/index.html">Telas DIY</a></li>
<li><a href="../pt435610/index.html">Ovos de P√°scoa para o ZX Spectrum - no √°lbum e no filme</a></li>
<li><a href="../pt435612/index.html">Confie na Codd ou nas suas instala√ß√µes?</a></li>
<li><a href="../pt435614/index.html">Rust News # 4 (dezembro de 2018)</a></li>
<li><a href="../pt435616/index.html">Como o zoneamento entre pares simplificou nossas vidas e ajudou a equilibrar a carga do EMC VPLEX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>