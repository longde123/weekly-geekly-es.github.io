<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•Ñ ü§≠ ü§∂üèø GPU Bound. Comment tout transf√©rer sur la carte vid√©o et un peu plus. Des animations üê© üöô ü•´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il √©tait une fois un √©v√©nement √©norme quand une unit√© multitexture ou une transformation mat√©rielle et un √©clairage (T&L) sont apparus sur le GPU. Le ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GPU Bound. Comment tout transf√©rer sur la carte vid√©o et un peu plus. Des animations</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468549/">  Il √©tait une fois un √©v√©nement √©norme quand une unit√© multitexture ou une transformation mat√©rielle et un √©clairage (T&amp;L) sont apparus sur le GPU.  Le r√©glage de la fonction fixe Pipeline √©tait un chamanisme magique.  Et ceux qui savaient comment activer et utiliser les fonctionnalit√©s avanc√©es de puces sp√©cifiques via les hacks de l'API D3D9, se consid√©raient comme ayant appris le Zen.  Mais le temps a pass√©, des shaders sont apparus.  Au d√©but, fortement limit√© √† la fois en fonctionnalit√© et en longueur.  De plus en plus de fonctionnalit√©s, plus d'instructions, plus de vitesse.  L'informatique (CUDA, OpenCL, DirectCompute) est apparue et l'√©tendue des capacit√©s des cartes vid√©o a commenc√© √† s'√©tendre rapidement. <br><br>  Dans cette s√©rie d'articles (esp√©rons-le), j'essaierai d'expliquer et de montrer comment ¬´inhabituellement¬ª vous pouvez appliquer les capacit√©s du GPU moderne lors du d√©veloppement de jeux, en plus des effets graphiques.  La premi√®re partie sera consacr√©e au syst√®me d'animation.  Tout ce qui est d√©crit est bas√© sur une exp√©rience pratique, mis en ≈ìuvre et fonctionne dans des projets de jeu r√©els. <br><a name="habracut"></a><br>  Oooo, encore une fois l'animation.  √Ä ce sujet, cent fois d√©j√† √©crit et d√©crit.  Qu'est-ce qui est si compliqu√©?  Nous emballons la matrice des os dans le tampon / la texture et l'utilisons pour le skinning dans le vertex shader.  Cela a √©t√© d√©crit dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GPU Gems 3 (Chapitre 2. Rendu de foule anim√©)</a> .  Et impl√©ment√© dans la r√©cente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©sentation Unite Tech</a> .  Est-ce possible d'une autre mani√®re? <br><br><h4>  Technodemka de Unity </h4><br>  Beaucoup de battage m√©diatique, mais est-ce vraiment cool?  Il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article</a> sur le hub qui d√©crit en d√©tail comment l'animation squelettique est faite et fonctionne dans cette techno-d√©mo.  Le travail parall√®le est tout bon, nous ne les consid√©rons pas.  Mais nous devons savoir quoi et comment l√†-bas, en termes de rendu. <br><br>  Dans une bataille √† grande √©chelle, deux arm√©es se battent, chacune compos√©e d'un type d'unit√©.  Squelettes √† gauche, chevaliers √† droite.  La vari√©t√© est moyenne.  Chaque unit√© se compose de 3 LOD (~ 300, ~ 1000, ~ 4000 sommets chacun), et seulement 2 os affectent le sommet.  Le syst√®me d'animation ne comprend que 7 animations pour chaque type d'unit√© (je rappelle qu'il y en a d√©j√† 2).  Les animations ne se fondent pas, mais passent discr√®tement du code simple qui est ex√©cut√© dans job'ax, qui est soulign√© dans la pr√©sentation.  Il n'y a pas de machine d'√©tat.  Lorsque nous avons deux types de maillage, vous pouvez dessiner toute la foule en deux appels de tirage instanci√©s.  L'animation squelettique, comme je l'ai d√©j√† √©crit, est bas√©e sur la technologie d√©crite en 2009. <br>  Innovant?  Hmm ... une perc√©e?  Hum ... Convient aux jeux modernes?  Eh bien, peut-√™tre, le rapport FPS au nombre d'unit√©s se vante. <br><br>  Les principaux inconv√©nients de cette approche (pr√©-matrice dans les textures): <br><br><ol><li>  D√©pendant de la fr√©quence d'images.  Recherch√© deux fois plus d'images d'animation - donnez deux fois plus de m√©moire. </li><li>  Manque d'animations de m√©lange.  Vous pouvez les faire, bien s√ªr, mais dans le shader de peau, un d√©sordre complexe se formera √† partir de la logique de m√©lange. </li><li>  Absence de liaison avec la machine d'√©tat Unity Animator.  Un outil pratique pour ajuster le comportement du personnage, qui peut √™tre connect√© √† n'importe quel syst√®me de skinning, mais dans notre cas, en raison du point 2, tout devient tr√®s difficile (imaginez comment m√©langer le BlendTree imbriqu√©). </li></ol><br><h4>  GPAS </h4><br>  Syst√®me d'animation aliment√© par GPU.  Le nom vient d'appara√Ætre. <br>  Le nouveau syst√®me d'animation avait plusieurs exigences: <br><br><ol><li>  Travaillez vite (enfin, c'est compr√©hensible).  Vous devez animer des dizaines de milliers d'unit√©s diff√©rentes. </li><li>  Soyez un analogue complet (ou presque) du syst√®me d'animation Unity.  Si l'animation ressemble √† ceci, alors dans le nouveau syst√®me, elle devrait √™tre exactement la m√™me.  Possibilit√© de basculer entre les syst√®mes CPU et GPU int√©gr√©s.  Ceci est souvent n√©cessaire pour le d√©bogage.  Lorsque les animations sont ¬´bogu√©es¬ª, en passant √† l'animateur classique, vous pouvez comprendre: ce sont les d√©fauts du nouveau syst√®me, ou la machine d'√©tat / l'animation elle-m√™me. </li><li>  Toutes les animations sont personnalisables dans Unity Animator.  Un outil pratique, test√© et surtout pr√™t √† l'emploi.  Nous construirons des v√©los ailleurs. </li></ol><br>  Repensons la pr√©paration et la cuisson des animations.  Nous n'utiliserons pas de matrices.  Les cartes vid√©o modernes fonctionnent bien avec les boucles, prennent en charge nativement int en plus de float, nous allons donc travailler avec des images cl√©s comme sur un CPU. <br><br>  Regardons un exemple d'animation dans la visionneuse d'animation: <br><br><img src="https://habrastorage.org/webt/_4/yw/bg/_4ywbgkzw8frqb3pjng98db5zwm.jpeg"><br><br>  On peut voir que les images cl√©s sont d√©finies s√©par√©ment pour la position, l'√©chelle et la rotation.  Pour certains os, vous en avez besoin de beaucoup, pour certains seulement, et pour les os qui ne sont pas anim√©s s√©par√©ment, seules les images cl√©s initiales et finales sont d√©finies. <br><br>  Position - Vector3, quaternion - Vector4, √©chelle - Vector3.  La structure des images cl√©s aura une chose en commun (pour simplifier), nous avons donc besoin de 4 flotteurs pour s'adapter √† l'un des types ci-dessus.  Nous avons √©galement besoin d'InTangent et OutTangent pour l'interpolation correcte entre les images cl√©s en fonction de la courbure.  Oh oui, et le temps normalis√© n'oublie pas: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyFrame</span></span></span><span class="hljs-class"> {</span></span> float4 v; float4 inTan, outTan; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> time; };</code> </pre> <br>  Pour obtenir toutes les images cl√©s, utilisez AnimationUtility.GetEditorCurve (). <br>  De plus, nous devons nous rappeler les noms des os, car il sera n√©cessaire de remapper les os de l'animation dans les os du squelette (et ils peuvent ne pas co√Øncider) au stade de la pr√©paration des donn√©es GPU. <br><br>  En remplissant les tampons lin√©aires avec des tableaux d'images cl√©s, nous nous souviendrons de leurs d√©calages afin de trouver ceux qui se rapportent √† l'animation dont nous avons besoin. <br><br>  Maintenant int√©ressant.  Animation squelette GPU. <br><br>  Nous pr√©parons un grand ("nombre de squelettes anim√©s" X "nombre d'os dans le squelette" X "coefficient empirique du nombre maximum de m√©langes d'animation").  Nous y stockons la position, la rotation et l'√©chelle de l'os au moment de l'animation.  Et pour tous les os anim√©s planifi√©s dans ce cadre, ex√©cutez le calcul shader.  Chaque fil anime son os. <br><br>  Chaque image cl√©, quelle que soit sa taille (traduction, rotation, √©chelle), est interpol√©e exactement de la m√™me mani√®re (recherche par recherche lin√©aire, pardonnez-moi Knuth): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterpolateKeyFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout float4 rv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIdx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endIdx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = startIdx; i &lt; endIdx; ++i) { KeyFrame k0 = keyFrames[i + <span class="hljs-number"><span class="hljs-number">0</span></span>]; KeyFrame k1 = keyFrames[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lerpFactor = (t - k0.time) / (k1.time - k0.time); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lerpFactor &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || lerpFactor &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; rv = CurveInterpoate(k0, k1, lerpFactor); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  La courbe est une courbe de B√©zier cubique, donc la fonction d'interpolation sera la suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurveInterpoate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(KeyFrame v0, KeyFrame v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dt = v1.time - v0.time; float4 m0 = v0.outTan * dt; float4 m1 = v1.inTan * dt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t2 = t * t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t3 = t2 * t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span> * t3 - <span class="hljs-number"><span class="hljs-number">3</span></span> * t2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = t3 - <span class="hljs-number"><span class="hljs-number">2</span></span> * t2 + t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = t3 - t2; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = <span class="hljs-number"><span class="hljs-number">-2</span></span> * t3 + <span class="hljs-number"><span class="hljs-number">3</span></span> * t2; float4 rv = a * v0.v + b * m0 + c * m1 + d * v1.v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }</code> </pre><br>  La posture locale (TRS) de l'os a √©t√© calcul√©e.  Ensuite, avec un shader de calcul s√©par√©, nous fusionnons toutes les animations n√©cessaires pour cet os.  Pour ce faire, nous avons un tampon avec des indices d'animation et les poids de chaque animation dans le m√©lange final.  Nous obtenons ces informations de la machine d'√©tat.  La situation de BlendTree √† l'int√©rieur de BlendTree est r√©solue comme suit.  Par exemple, il y a un arbre: <br><br><img src="https://habrastorage.org/webt/yg/n6/_4/ygn6_4arygdkgbnigucbv0tz0fe.jpeg"><br><br>  BlendTree Walk aura un poids de 0,35, Run - 0,65.  En cons√©quence, la position finale des os doit √™tre d√©termin√©e par 4 animations: Walk1, Walk2, Run1 et Run2.  Leurs poids auront des valeurs (0,35 * 0,92, 0,35 * 0,08, 0,65 * 0,92, 0,65 * 0,08) = (0,322, 0,028, 0,598, 0,052), respectivement.  Il convient de noter que la somme des poids doit toujours √™tre √©gale √† un, sinon des bugs magiques sont fournis. <br><br>  Le ¬´c≈ìur¬ª de la fonction de m√©lange: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bw = animDef.blendWeight; BoneXForm boneToBlend = animatedBones[srcBoneIndex]; float4 q = boneToBlend.quat; float3 t = boneToBlend.translate; float3 s = boneToBlend.scale; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dot(resultBone.quat, q) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) q = -q; resultBone.translate += t * bw; resultBone.quat += q * bw; resultBone.scale += s * bw;</code> </pre><br>  Vous pouvez maintenant traduire en matrice de transformation.  Arr√™ter  A propos de la hi√©rarchie des os compl√®tement oubli√©e. <br>  Sur la base des donn√©es du squelette, nous construisons un tableau d'indices, o√π la cellule avec l'indice osseux contient l'indice de son parent.  En racine, √©crivez -1. <br><br>  Un exemple: <br><br><img src="https://habrastorage.org/webt/c0/8v/tl/c08vtlrw1w80dsczyczusebox34.jpeg"><br><br><pre> <code class="cpp hljs">float4x4 animMat = IdentityMatrix(); float4x4 mat = initialPoses[boneId]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (boneId &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { BoneXForm b = blendedBones[boneId]; float4x4 xform = MakeTransformMatrix(b.translate, b.quat, b.scale); animMat = mul(animMat, xform); boneId = bonesHierarchyIndices[boneId]; } mat = mul(mat, animMat); resultSkeletons[id] = mat;</code> </pre><br>  Voici, en principe, tous les principaux points du rendu et du m√©lange des animations. <br><br><h4>  GPSM </h4><br>  Machine d'√©tat aliment√©e par GPU (vous l'avez devin√©).  Le syst√®me d'animation d√©crit ci-dessus fonctionnerait parfaitement avec la machine d'√©tat d'animation Unity, mais tous les efforts seraient alors inutiles.  Avec la possibilit√© de calculer des dizaines (sinon des centaines) de milliers d'animations par image, UnityAnimator ne retirera pas des milliers de machines d'√©tat fonctionnant simultan√©ment.  Hmm ... <br>  Qu'est-ce qu'une machine d'√©tat dans Unity?  Il s'agit d'un syst√®me ferm√© d'√©tats et de transitions, contr√¥l√© par de simples propri√©t√©s num√©riques.  Chaque machine d'√©tat fonctionne ind√©pendamment les unes des autres et pour le m√™me ensemble de donn√©es d'entr√©e.  Attends une minute.  C'est une t√¢che id√©ale pour le GPU et les shaders de calcul! <br><br>  <u>Phase de cuisson</u> <br><br>  Tout d'abord, nous devons collecter et placer toutes les donn√©es de la machine d'√©tat dans une structure conviviale GPU.  Et cela: √©tats (√©tats), transitions (transitions) et param√®tres (param√®tres). <br>  Toutes ces donn√©es sont plac√©es dans des tampons lin√©aires et trait√©es par des index. <br>  Chaque thread de calcul consid√®re sa machine d'√©tat.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AnimatorController</a> fournit une interface √† toutes les structures de machine d'√©tat interne n√©cessaires. <br><br>  Les principales structures de la machine d'√âtat: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstTransition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numTransitions; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> animDefId; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Transition</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> exitTime; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> duration; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sourceStateId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetStateId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstCondition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endCondition; uint properties; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeInState; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> animationLoop; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransitionData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeInTransition; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurrentState</span></span></span><span class="hljs-class"> {</span></span> StateData srcState, dstState; TransitionData transition; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimationDef</span></span></span><span class="hljs-class"> {</span></span> uint animId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextAnimInTree; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parameterIdx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lengthInSec; uint numBones; uint loop; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParameterDef</span></span></span><span class="hljs-class"> {</span></span> float2 line0ab, line1ab; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> runtimeParamId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextParameterId; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Condition</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> checkMode; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> runtimeParamIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> referenceValue; };</code> </pre><br><ul><li>  State contient la vitesse √† laquelle l'√©tat est jou√©, et les indices des conditions de transition vers les autres selon la machine d'√©tat. </li><li>  La transition contient des indices d'√©tat ¬´de¬ª et ¬´√†¬ª.  Temps de transition, temps de sortie et lien vers un tableau de conditions pour entrer dans cet √©tat. </li><li>  CurrentState est un bloc de donn√©es d'ex√©cution avec des donn√©es sur l'√©tat actuel de la machine d'√©tat. </li><li>  AnimationDef contient une description de l'animation avec des liens vers d'autres qui lui sont li√©s par BlendTree. </li><li>  ParameterDef est une description du param√®tre qui contr√¥le le comportement des machines √† √©tats.  Line0ab et Line1ab sont les coefficients de l'√©quation des lignes pour d√©terminer le poids de l'animation par la valeur du param√®tre.  D'ici: <br><br><img src="https://habrastorage.org/webt/ge/dl/wd/gedlwdz-u4iiyqciuy-lewx8xnm.jpeg"><br></li><li>  Condition - sp√©cification de la condition de comparaison de la valeur d'ex√©cution du param√®tre et de la valeur de r√©f√©rence. </li></ul><br>  <u>Phase d'ex√©cution</u> <br><br>  Le cycle principal de chaque machine d'√©tat peut √™tre affich√© en utilisant l'algorithme suivant: <br><br><img src="https://habrastorage.org/webt/q_/cu/gc/q_cugcb1tr2krdkztmuxbr1yds8.jpeg"><br><br>  Il existe 4 types de param√®tres dans Unity animator: float, int, bool et trigger (qui est bool).  Nous les pr√©senterons tous sous forme de flotteur.  Lors de la configuration des conditions, il est possible de choisir l'un des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">six</a> types de comparaison.  Si == est √©gal √†.  IfNot == NotEqual.  Nous n'utiliserons donc que 4. L'index d'op√©rateur est pass√© au champ checkMode de la structure Condition. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = t.firstCondition; i &lt; t.endCondition; ++i) { Condition c = allConditions[i]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> paramValue = runtimeParameters[c.runtimeParamIndex]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (c.checkMode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (paramValue &lt; c.referenceValue) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (paramValue &gt; c.referenceValue) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(paramValue - c.referenceValue) &gt; <span class="hljs-number"><span class="hljs-number">0.001f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(paramValue - c.referenceValue) &lt; <span class="hljs-number"><span class="hljs-number">0.001f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  Pour d√©marrer la transition, toutes les conditions doivent √™tre remplies.  Les √©tiquettes de cas √©tranges sont simplement (int) AnimatorConditionMode.  La logique d'interruption est une logique d√©licate pour interrompre et annuler les transitions. <br><br>  Apr√®s avoir mis √† jour l'√©tat de la machine d'√©tat et fait d√©filer les horodatages sur le cadre delta t, il est temps de pr√©parer des donn√©es sur les animations √† lire dans ce cadre et les poids correspondants.  Cette √©tape est ignor√©e si le mod√®le d'unit√© n'est pas dans le cadre (Frustum abattu).  Pourquoi devrions-nous envisager des animations de ce qui n'est pas visible?  Nous passons en revue l'√©tat source de l'arbre de m√©lange, en fonction de l'√©tat de destination de l'arbre de m√©lange, nous en ajoutons toutes les animations et nous calculons les poids par le temps de transition normalis√© de la source √† la destination (temps pass√© en transition).  Avec les donn√©es pr√©par√©es, GPAS entre en jeu et compte les animations pour chaque entit√© anim√©e du jeu. <br><br>  Les param√®tres de contr√¥le de l'unit√© proviennent de la logique de contr√¥le de l'unit√©.  Par exemple, vous devez activer l'ex√©cution, d√©finir le param√®tre CharSpeed ‚Äã‚Äãet une machine √† √©tats correctement configur√©e m√©lange en douceur les animations de transition de ¬´marche¬ª √† ¬´course¬ª. <br><br>  Naturellement, l'analogie compl√®te avec Unity Animator n'a pas fonctionn√©.  Les principes de travail internes, s'ils ne sont pas d√©crits dans la documentation, ont d√ª √™tre invers√©s et un analogue cr√©√©.  Certaines fonctionnalit√©s ne sont pas encore termin√©es (elles ne le sont peut-√™tre pas).  Par exemple, BlendType dans BlendTree ne prend en charge que 1D.  Faire d'autres types, en principe, n'est pas difficile, il n'est pas n√©cessaire pour l'instant.  Il n'y a pas d'√©v√©nements d'animation, car il est n√©cessaire de faire une relecture avec le GPU, et la relecture ¬´correcte¬ª sera plusieurs images derri√®re, ce qui n'est pas toujours acceptable.  Mais c'est aussi possible. <br><br><h4>  Rendu </h4><br>  Le rendu des unit√©s se fait par instanciation.  Selon SV_InstanceID, dans le vertex shader, nous obtenons la matrice de tous les os qui affectent le sommet et le transformons.  Absolument rien d'inhabituel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplySkin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 v, uint vertexID, uint instanceID)</span></span></span><span class="hljs-function"> </span></span>{ BoneInfoPacked bip = boneInfos[vertexID]; BoneInfo bi = UnpackBoneInfo(bip); SkeletonInstance skelInst = skeletonInstances[instanceID]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bonesOffset = skelInst.boneOffset; float4x4 animMat = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bw = bi.boneWeights[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bw &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { uint boneId = bi.boneIDs[i]; float4x4 boneMat = boneMatrices[boneId + bonesOffset]; animMat += boneMat * bw; } } float4 rv = float4(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); rv = mul(rv, animMat); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }</code> </pre><br><h4>  R√©sum√© </h4><br>  Cette ferme fonctionne-t-elle rapidement?  √âvidemment plus lent que d'√©chantillonner la texture avec des matrices, mais je peux quand m√™me montrer quelques chiffres (GTX 970). <br><br>  Voici 50 000 machines d'√©tat: <br><br><img src="https://habrastorage.org/webt/cw/bv/4o/cwbv4oww0dles0lwgt-xlsqxg5m.jpeg"><br><br>  Voici 280 000 os anim√©s: <br><br><img src="https://habrastorage.org/webt/pe/lt/pv/peltpvbyztjsutrkxmhxyjbimbs.jpeg"><br><br>  Concevoir et d√©boguer tout cela est une vraie douleur.  Un tas de tampons et de d√©calages.  Un tas de composants et leurs interactions.  Il y avait des moments o√π les mains tombaient lorsque vous vous frappiez la t√™te √† propos d'un probl√®me pendant plusieurs jours, mais vous ne pouvez pas trouver le probl√®me.  C'est particuli√®rement "sympa" quand tout fonctionne comme il se doit sur les donn√©es de test, mais dans une vraie situation de "combat", il n'y a pas de probl√®me d'animation.  Les √©carts entre le fonctionnement des machines d'√©tat Unity et les leurs ne sont pas non plus imm√©diatement visibles.  En g√©n√©ral, si vous d√©cidez de faire un analogique pour vous, alors je ne vous envie pas.  En fait, tout le d√©veloppement sous le GPU est une telle chose √† se plaindre. <br><br>  <b>PS</b> Je veux jeter une pierre dans le jardin des d√©veloppeurs d'Unite TechDemo.  Ils ont un grand nombre de mod√®les identiques de ruines et de ponts sur sc√®ne, et ils n'ont en aucun cas optimis√© leur rendu.  Ils ont plut√¥t essay√© en cochant ¬´statique¬ª.  Seulement maintenant, dans les index 16 bits, vous ne pouvez pas entasser beaucoup de g√©om√©trie (trois fois haha, 2017) et rien ne s'est assembl√©, car les mod√®les sont fortement polygonaux.  J'ai mis "Activer l'instanciation" pour tous les shaders, et d√©coch√© "Statique".  Il n'y a pas eu de boost tangible, mais bon sang, vous faites une d√©mo techno, vous vous battez pour chaque FPS.  Vous ne pouvez pas chier comme √ßa. <br><br><div class="spoiler">  <b class="spoiler_title">√âtait</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">*** Summary *** Draw calls: 2553 Dispatch calls: 0 API calls: 8378 Index/vertex bind calls: 2992 Constant bind calls: 648 Sampler bind calls: 395 Resource bind calls: 805 Shader set calls: 682 Blend set calls: 230 Depth/stencil set calls: 92 Rasterization set calls: 238 Resource update calls: 1017 Output set calls: 74 API:Draw/Dispatch call ratio: 3.28163 298 Textures - 1041.01 MB (1039.95 MB over 32x32), 42 RTs - 306.94 MB. Avg. tex dimension: 1811.77x1810.21 (2016.63x2038.98 over 32x32) 216 Buffers - 180.11 MB total 17.54 MB IBs 159.81 MB VBs. 1528.06 MB - Grand total GPU buffer + texture load. *** Draw Statistics *** Total calls: 2553, instanced: 2, indirect: 2 Instance counts: 1: 2: 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: &gt;=15: ******************************************************************************************************************************** (2)</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Est devenu</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">*** Summary *** Draw calls: 1474 Dispatch calls: 0 API calls: 11106 Index/vertex bind calls: 3647 Constant bind calls: 1039 Sampler bind calls: 348 Resource bind calls: 718 Shader set calls: 686 Blend set calls: 230 Depth/stencil set calls: 110 Rasterization set calls: 258 Resource update calls: 1904 Output set calls: 74 API:Draw/Dispatch call ratio: 7.5346 298 Textures - 1041.01 MB (1039.95 MB over 32x32), 42 RTs - 306.94 MB. Avg. tex dimension: 1811.77x1810.21 (2016.63x2038.98 over 32x32) 427 Buffers - 93.30 MB total 9.81 MB IBs 80.51 MB VBs. 1441.25 MB - Grand total GPU buffer + texture load. *** Draw Statistics *** Total calls: 1474, instanced: 391, indirect: 2 Instance counts: 1: 2: ******************************************************************************************************************************** (104) 3: ************************************************* (40) 4: ********************** (18) 5: ****************************** (25) 6: ********************************************************************************************* (76) 7: *********************************** (29) 8: ************************************************** (41) 9: ********* (8) 10: ************** (12) 11: 12: ****** (5) 13: ******* (6) 14: ** (2) &gt;=15: ****************************** (25)</code> </pre><br></div></div><br>  <b>PPS</b> √Ä tout moment, les jeux √©taient principalement li√©s au processeur, c'est-√†-dire  Le CPU n'a pas suivi le GPU.  Trop de logique et de physique.  En transf√©rant une partie de la logique du jeu du CPU au GPU, nous d√©chargeons le premier et chargons le second, c'est-√†-dire  rendre la situation du GPU li√© plus probable.  D'o√π le titre de l'article. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468549/">https://habr.com/ru/post/fr468549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468535/index.html">Vous n'avez pas besoin de journaux?</a></li>
<li><a href="../fr468537/index.html">Bases de DevOps. Entr√©e dans le projet √† partir de z√©ro</a></li>
<li><a href="../fr468543/index.html">Comit√© du programme en semaine FrontendConf. Entretien avec Sergey Popov</a></li>
<li><a href="../fr468545/index.html">"Alice, allons au front!"</a></li>
<li><a href="../fr468547/index.html">Parlant anglais, CSS, grille et accessibilit√© √† FrontendConf</a></li>
<li><a href="../fr468553/index.html">Gestion des param√®tres dans les applications m√©tier similaire √† un syst√®me de contr√¥le de version</a></li>
<li><a href="../fr468555/index.html">Introduction aux assemblages d√©terministes en C / C ++. 2e partie</a></li>
<li><a href="../fr468557/index.html">WEB 3.0 - la deuxi√®me approche du projectile</a></li>
<li><a href="../fr468559/index.html">Sauvegardez le cloud, amis</a></li>
<li><a href="../fr468561/index.html">Semaine de la s√©curit√© 39: erreurs de s√©curit√© et banales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>