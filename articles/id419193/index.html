<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👫 👼🏻 🙀 Kami menangani objek dalam JavaScript 🤰🏻 🍴 🎙️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, seorang penulis - pengembang front-end - memberikan ikhtisar tentang cara utama untuk membuat, memodifikasi dan membandingkan objek ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menangani objek dalam JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wirex/blog/419193/">  <i>Pada artikel ini, seorang penulis - pengembang front-end - memberikan ikhtisar tentang cara utama untuk membuat, memodifikasi dan membandingkan objek JavaScript.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tw/em/rb/twemrbhsfbxmrw7_htw8o4mfzny.jpeg"></div><br>  Objek adalah salah satu konsep dasar dalam JavaScript.  Ketika saya mulai mempelajarinya, itu tampak cukup sederhana bagi saya: hanya beberapa kunci dan nilai, seperti yang dijelaskan dalam teori. <br><br>  Hanya setelah beberapa waktu saya mulai menyadari bahwa topik itu jauh lebih rumit daripada yang saya kira.  Dan kemudian saya mulai mempelajari informasi dari berbagai sumber.  Beberapa dari mereka memberikan ide yang bagus tentang masalah ini, tetapi saya tidak bisa langsung melihat keseluruhan gambar. <br><br>  Dalam posting ini, saya mencoba untuk mencakup semua aspek bekerja dengan objek di JS, tanpa masuk terlalu jauh ke detail individu, tetapi tanpa kehilangan detail penting yang akan membantu Anda memahami subjek dan merasa lebih percaya diri selama studi lebih lanjut. <br><br>  Jadi mari kita mulai dengan dasar-dasarnya. <br><br><h3>  Obyek </h3><br>  <b>Objek dalam JavaScript hanyalah kumpulan properti, yang masing-masing merupakan pasangan nilai kunci.</b>  Kunci dapat diakses menggunakan notasi bertitik ( <i>obj.a</i> ) atau kurung kurung ( <i>obj ['a']</i> ). <br><br>  Ingat bahwa tanda kurung harus digunakan jika kuncinya adalah: <br><br><ul><li>  bukan pengidentifikasi JavaScript yang valid (memiliki spasi, tanda hubung, itu dimulai dengan angka ...) </li><li>  adalah variabel. </li></ul><br>  Salah satu properti yang objek di JS dapatkan ketika mereka dibuat disebut <i>Prototipe</i> , dan ini adalah konsep yang sangat penting. <br><a name="habracut"></a><br><h3>  Prototipe </h3><br>  Setiap objek dalam JavaScript memiliki properti internal yang disebut <i>Prototipe</i> .  Di sebagian besar browser, Anda dapat merujuknya dengan sebutan <i>__proto__</i> . <br><br>  <i>Prototipe</i> adalah cara untuk menyediakan warisan properti dalam JavaScript.  Jadi, Anda dapat berbagi fungsionalitas tanpa menggandakan kode dalam memori.  Metode ini bekerja dengan membuat hubungan antara dua objek. <br><br>  Sederhananya, Prototipe membuat pointer dari satu objek ke objek lain. <br><br>  <b>Rantai prototipe</b> <br><br>  Setiap kali JS mencari properti di objek dan tidak menemukannya langsung di objek itu sendiri, JS akan memeriksa keberadaan properti di objek prototipe.  Jika tidak ada properti di dalamnya, maka JS akan terus mencari dalam prototipe objek terkait.  Ini akan berlanjut sampai JS menemukan properti yang cocok atau mencapai akhir rantai. <br><br>  Mari kita lihat sebuah contoh: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cons = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = <span class="hljs-number"><span class="hljs-number">1</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cons(); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">i</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>  cons.prototype.b = <span class="hljs-number"><span class="hljs-number">3</span></span>; cons.prototype.c = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  <i>kontra</i> adalah konstruktor (hanya fungsi yang dapat dipanggil menggunakan operator <i>baru</i> ). <br><br>  Pada baris kelima, kita membuat objek baru - salinan <i>kontra baru</i> .  Segera setelah membuat, <i>obj</i> juga mendapat properti prototipe. <br><br>  Dan sekarang kita menambahkan properti ( <i>'b', 'c'</i> ) ke prototipe objek <i>kontra</i> . <br>  Pertimbangkan <i>obj</i> : <br><br>  <b>obj.a // 1</b> - semuanya seperti <i>sebelumnya</i> , <i>obj.a</i> masih 1. <br>  <b>obj.c</b> - <i>obj</i> tidak <i>memiliki</i> properti <i>c</i> !  Namun, seperti yang disebutkan sebelumnya, JS sekarang akan mencarinya di prototipe objek dan mengembalikan nilai 4. <br><br>  Sekarang mari kita pikirkan apa nilai <i>obj.b itu</i> dan apa jadinya bila kita menghapus <i>obj.b</i> ? <br><br>  <i>Obj.b</i> adalah 2. Kami menetapkan properti <i>b</i> , tetapi kami melakukannya untuk prototipe <i>kontra</i> , jadi ketika kami memeriksa <i>obj.b</i> , kami masih mendapatkan 2. Namun, segera setelah menghapus <i>obj.b,</i> JS tidak lagi dapat menemukan <i>b</i> di o <i>bj</i> , dan karenanya akan melanjutkan pencarian dalam prototipe dan mengembalikan nilai 3. <br><br>  Selanjutnya, saya ingin berbicara singkat tentang berbagai cara untuk membuat objek dan lebih banyak tentang prototipe. <br><br><h3>  Penciptaan Obyek </h3><br>  <b>Objek literal:</b> <i>biarkan obj = {a: 1};</i> <br>  Kami membuat objek dengan rantai prototipe berikut: <i>obj ---&gt; Object.prototype ---&gt; null</i> <br>  Seperti yang bisa Anda tebak, <i>object.prototype</i> adalah prototipe objek, serta akhir dari rantai prototipe. <br><br>  <b>Object.create ():</b> <i>var newObj = Object.create (obj);</i> <br>  <i>NewObj</i> akan memiliki rantai prototipe berikut: <i>newObj ---&gt; obj ---&gt; Object.prototype ---&gt; null</i> <br><br>  <b>Konstruktor.</b>  Seperti pada contoh di atas, konstruktor hanyalah fungsi JS yang memungkinkan kita menggunakan operator <i>baru</i> untuk membuat instance baru. <br><br>  <b>Kelas ES6:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rectangle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(height, width) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = width; } getArea() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> square = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> rectangle(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  <i>Square</i> adalah turunan dari konstruktor <i>persegi panjang</i> , jadi kita bisa memanggil <i>square.getArea () // 4</i> , <i>square.width</i> , serta semua fungsi yang diwarisi dari <i>object.prototype</i> . <br><br>  Metode mana yang lebih baik?  Jika Anda berencana untuk membuat banyak instance, Anda dapat menggunakan ES6 atau konstruktor.  Jika Anda berencana untuk membuat objek sekali, lebih baik untuk menentukan literal, karena ini adalah cara termudah. <br><br>  Dan sekarang, ketika kita belajar tentang <i>prototipe</i> dan berkenalan dengan semua cara untuk membuat objek baru, kita dapat melanjutkan untuk membahas salah satu aspek yang paling membingungkan terkait dengan objek. <br><br><h3>  Membandingkan dan memodifikasi objek </h3><br>  <b>Dalam JavaScript, objek adalah tipe referensi</b> <br><br>  Ketika kita membuat objek, <i>biarkan obj = {a: 1};</i>  , variabel <i>obj</i> mendapat alamat di memori objek, tetapi bukan nilainya!  Sangat penting untuk memahami perbedaan ini, karena kesalahan dapat terjadi sebaliknya.  Ketika kita membuat objek lain, <i>biarkan newObj = obj</i> , kita benar-benar membuat <b>pointer</b> ke area tertentu dari memori <i>obj</i> , dan bukan objek yang sepenuhnya baru. <br><br>  Ini berarti bahwa dengan menjalankan <i>newObj.a = 2</i> , kami benar-benar mengubah <i>obj</i> sehingga <i>obj.a</i> menjadi 2! <br><br>  Pendekatan ini dengan mudah menyebabkan munculnya bug, sehingga banyak perusahaan bekerja dengan objek yang tidak dapat diubah.  Alih-alih mengubah objek yang sudah dibuat, Anda harus membuat lagi objek baru (salinan aslinya) dan mengubahnya.  Ini adalah betapa pentingnya perpustakaan seperti Redux bekerja, dan secara keseluruhan ini adalah salah satu konsep dasar pemrograman fungsional.  Baca lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  <b>Kesetaraan</b> <br><br>  Dari penjelasan di atas, dapat diketahui bahwa dua objek tidak akan pernah bisa sama, walaupun mereka memiliki sifat yang sama.  Hal ini disebabkan oleh fakta bahwa JS sebenarnya membandingkan lokasi objek dalam memori, dan dua objek tidak pernah berada dalam sel memori yang sama. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Two distinct objects with the same properties are not equal var fruit = {name: 'apple'}; var fruitbear = {name: 'apple'}; fruit === fruitbear; // return false // here fruit and fruitbear are pointing to same object var fruit = {name: 'apple'}; var fruitbear = fruit; fruit === fruitbear; // return true</span></span></code> </pre><br>  Jadi, Anda kemungkinan besar sudah bertanya-tanya bagaimana cara membandingkan objek atau bagaimana melakukan berbagai manipulasi dengan objek, mengingat persyaratan untuk kekekalannya. <br><br>  Pertimbangkan beberapa kemungkinan. <br><br>  <b>Perubahan objek</b> <br><br>  Misalkan jelas bahwa dengan cara yang baik kita tidak boleh mengubah objek, jadi kami ingin membuat salinan objek yang sesuai dan mengubah propertinya.  <i>Object.assign ()</i> datang untuk <i>menyelamatkan</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newObj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, obj,{<span class="hljs-attr"><span class="hljs-attr">a</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>}) <span class="hljs-comment"><span class="hljs-comment">// {a : 2, b : 2 }</span></span></code> </pre> <br>  Jika kita ingin mengubah nilai properti <i>obj</i> , kita dapat menggunakan <i>object.assign</i> untuk membuat salinan <i>obj</i> dan mengubahnya. <br><br>  Contoh tersebut menunjukkan bahwa kita pertama-tama membuat objek kosong, lalu menyalin nilai <i>obj</i> dan membuat perubahan, akhirnya mendapatkan objek baru dan siap digunakan. <br><br>  Harap dicatat bahwa metode ini tidak akan berfungsi untuk penyalinan dalam.  Berbicara tentang penyalinan yang dalam, kami bermaksud bahwa Anda perlu menyalin objek dengan satu properti atau lebih. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {<span class="hljs-attr"><span class="hljs-attr">a</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span> : { <span class="hljs-attr"><span class="hljs-attr">a</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> } }; <span class="hljs-comment"><span class="hljs-comment">// b property is an object</span></span></code> </pre> <br>  <i>Object.assign ()</i> menyalin properti objek, jadi jika nilai properti adalah pointer ke objek, hanya pointer yang disalin. <br><br>  Penyalinan yang dalam membutuhkan operasi rekursif.  Anda dapat menulis fungsi di sini atau cukup menggunakan metode <a href=""><i>_.cloneDeep</i></a> dari pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lodash</a> . <br><br>  <b>Perbandingan Objek</b> <br><br>  Ada satu cara keren untuk bekerja dengan objek - konversi baris.  Dalam contoh berikut, kami mengonversi kedua objek menjadi string dan membandingkannya: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(obj1) === <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(obj2)</code> </pre> <br>  Pendekatan ini dibenarkan, karena pada akhirnya kami membandingkan string yang mewakili pointer ke tipe nilai.  Kabar buruknya adalah bahwa itu tidak selalu berhasil, terutama karena satu atau urutan properti lainnya dari objek tidak dijamin. <br><br>  Solusi bagus lainnya adalah dengan menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">_.isEqual</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lodash</a> , yang melakukan perbandingan objek secara mendalam. <br><br>  Dan sebelum kita selesai, mari kita membahas beberapa pertanyaan yang sering diajukan tentang objek.  Ini akan membantu menggali lebih dalam ke dalam topik dan mempraktikkan pengetahuan yang diperoleh. <br><br>  Cobalah untuk memikirkan solusinya sendiri sebelum membaca jawabannya. <br><br><h3>  Bagaimana cara mengetahui panjang suatu benda? </h3><br>  Untuk mendapatkan jawabannya, perlu menyortir semua properti objek satu per satu dan menghitungnya.  Ada beberapa cara untuk melakukan iterasi ini: <br><br><ul><li>  <i>untuk masuk</i>  Metode ini mencakup semua properti yang dapat dihitung dari suatu objek dan rantai prototipe-nya.  Kami berkenalan dengan prototipe (dan, saya harap, mempelajari materi), jadi harus jelas bahwa penggunaan <i>untuk</i> tidak akan selalu benar untuk mendapatkan sifat-sifat objek. </li><li>  <i>Objek.kunci</i> .  Metode ini mengembalikan array dengan kunci properti <b>terhitung</b> (miliknya ke objek yang ditentukan).  Pendekatan ini lebih baik, karena kami hanya bekerja pada properti dari suatu objek, tanpa menggunakan properti <i>prototipe</i> .  Namun, ada beberapa situasi ketika Anda <i>mengatur</i> atribut <i>enumerable</i> dari beberapa properti menjadi false, dan <i>object.keys</i> akhirnya melewatkannya, dan Anda mendapatkan hasil yang salah.  Ini jarang terjadi, tetapi dalam kasus seperti itu <i>getOwnPropertyNames</i> akan <i>berguna</i> . </li><li>  <i>getOwnPropertyNames</i> mengembalikan array yang berisi semua kunci objek <b>sendiri</b> (baik yang dapat dihitung maupun yang tidak terhitung). </li></ul><br>  Juga layak disebutkan: <br><br><ul><li>  <i>Object.values ​​mengulangi</i> properti penghitungannya sendiri dan mengembalikan array dengan nilai yang sesuai. </li><li>  <i>Object.entries mengulangi</i> properti penghitungannya sendiri dan mengembalikan array <b>dengan kunci dan nilainya</b> . </li></ul><br>  Saya pikir Anda memperhatikan bahwa sebagian besar metode yang tercantum di atas mengembalikan array.  Ini adalah peluang untuk memanfaatkan sepenuhnya metode JavaScript untuk bekerja dengan array. <br><br>  Salah satu metode tersebut adalah <i>array.length</i> .  Pada akhirnya, kita bisa menulis <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> objLength = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(obj).length;</code> </pre> <br><h3>  Bagaimana cara memeriksa apakah suatu objek kosong? </h3><br><ol><li>  <i>JSON.stringify (myObj) === “{}”</i> .  Di sini kita kembali menggunakan alat konversi string, yang membuatnya mudah untuk memeriksa apakah suatu objek kosong (membandingkan string, bukan objek). </li><li>  <i>! Object.keys (myobj). Length // true</i> .  Seperti yang saya sebutkan, mengonversi kunci objek ke array bisa sangat berguna.  Di sini kita menggunakan <i>panjang</i> properti nyaman yang diwarisi dari <i>Array.prototype</i> , dengan memeriksa panjang kunci dalam array.  Di JS, <i>0</i> berubah menjadi false, jadi tambah <i>!</i>  kita mengubahnya menjadi benar.  Angka lain akan berubah menjadi false. </li></ol><br><h3>  Kesimpulannya </h3><br>  Saya harap sekarang Anda merasa lebih percaya diri dalam membuat objek dan bekerja dengannya.  Mari kita simpulkan: <br><br><ul><li>  Ingatlah bahwa objek milik tipe referensi, yang berarti direkomendasikan untuk bekerja dengannya tanpa mengubah objek aslinya. <br></li><li>  Berteman dengan properti <i>prototipe</i> dan rantai <i>prototipe</i> . <br></li><li>  Kenali alat bantu dalam bekerja dengan objek.  Ingatlah bahwa Anda dapat mengubah objek menjadi string, mendapatkan array dengan kunci mereka, atau hanya mengulangi properti mereka menggunakan serangkaian metode yang kami temui. <br></li></ul><br>  Selamat mencoba objek JavaScript. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/4bd/bf6/597/4bdbf659775744b1bdbb4d8a00a0a980.png" alt="gambar"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419193/">https://habr.com/ru/post/id419193/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419179/index.html">Arsitektur pragmatis murni. Brainstorming</a></li>
<li><a href="../id419181/index.html">Pemrograman Mouse: Bagaimana Kami Lari Dari Rutin CRM</a></li>
<li><a href="../id419183/index.html">Demopati di Helsinki "Majelis 2018", laporan foto, hari pertama</a></li>
<li><a href="../id419185/index.html">Tinjauan protokol pembangunan konsensus saat ini dalam lingkungan yang terdesentralisasi</a></li>
<li><a href="../id419189/index.html">Mengapa penawaran paket akan segera membentuk dasar ritel</a></li>
<li><a href="../id419199/index.html">Laporan Club of Rome 2018, Bab 3.5: “Beberapa Kisah Sukses di Bidang Pertanian”</a></li>
<li><a href="../id419201/index.html">Startup apa yang dicari Y Combinator di tahun 2018?</a></li>
<li><a href="../id419203/index.html">Siaran hari kedua Slurm: intens di Kubernetes</a></li>
<li><a href="../id419205/index.html">Kerentanan Mikrotik baru? Tidak, tapi ada baiknya memeriksa perangkat Anda.</a></li>
<li><a href="../id419207/index.html">[Terjemahan] 4 Cara Membuat Stylize React Components</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>