<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏽 🎎 🧖🏻 Node.js指南，第3部分：托管，REPL，控制台操作，模块 🛶 🚫 🚶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是Node.js手册翻译的第三部分。 今天，我们将讨论如何为Node.js项目选择托管，如何在REPL模式下使用Node.js以及如何运行带有参数的脚本，如何与控制台和模块进行交互。 

  

 [我们建议您阅读]周期的其他部分  第1部分： 一般信息和入门 
 第2部分： JavaScript...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js指南，第3部分：托管，REPL，控制台操作，模块</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/423701/"> 这是Node.js手册翻译的第三部分。 今天，我们将讨论如何为Node.js项目选择托管，如何在REPL模式下使用Node.js以及如何运行带有参数的脚本，如何与控制台和模块进行交互。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[我们建议您阅读]周期的其他部分</b> <div class="spoiler_text"> 第1部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一般信息和入门</a> <br> 第2部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaScript，V8，一些开发技巧</a> <br> 第3部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">托管，REPL，使用控制台，模块</a> <br> 第4部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">npm，package.json和package-lock.json文件</a> <br> 第5部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">npm和npx</a> <br> 第6部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件循环，调用堆栈，计时器</a> <br> 第7部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">异步编程</a> <br> 第8部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南，第8部分：HTTP和WebSocket协议</a> <br> 第9部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南，</a>第9 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">部分：使用文件系统</a> <br> 第10部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南，第10部分：标准模块，流，数据库，NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南的完整PDF</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">托管Node.js应用程序</font> </h2><br> 托管Node.js应用程序的选择取决于您的需求。 以下是托管选项的简短列表，您可以通过决定部署应用程序并将其公开来进行探索。 首先，考虑一些简单的选项，这些选项的功能是有限的，然后变得更复杂，但功能也更加严重。 <br><br><h3>  <font color="#3AC1EF">hosting最简单的托管选项：本地隧道</font> </h3><br> 即使将动态IP地址分配给您的计算机，或者您位于NAT之后，也可以在其上部署应用程序，并使用本地隧道为它提供用户请求。 <br><br> 此选项适用于快速组织测试，安排产品演示或使极少数人能够访问应用程序。 <br><br> 对于组织许多平台的本地隧道<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ngrok来说</a> ，这是一项非常好的服务。 <br><br> 使用ngrok，足以执行<code>ngrok PORT</code>形式的命令，并且您可以从Internet访问指定的端口。 同时，如果您使用服务的免费版本，则您将在<code>ngrok.io</code>域中找到一个地址。 如果决定获得付费订阅，则可以使用自己的域名，此外，还可以提高解决方案的安全性（使用ngrok，可以在Internet上打开对计算机的访问权限）。 <br><br> 可以用来组织本地隧道的另一种工具称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">localtunnel</a> 。 <br><br><h3>  <font color="#3AC1EF">ing用于部署不需要配置的Node.js项目的环境</font> </h3><br><h4> 毛刺 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Glitch</a>是用于快速应用程序开发的交互式环境和平台，允许您将它们部署在glitch.com子域中。 该平台尚不支持其自己的用户域，使用该平台存在一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">限制</a> ，但对于处理应用程序原型非常有用。  Glitch的设计看起来很有趣（也许可以写成这个平台的优点），但这并不是某种非常有限的“玩具”环境。 在这里，您将有机会使用Node.js，CDN，用于机密信息的安全存储库，与GitHub交换数据的功能以及更多其他功能。 <br><br>  Glitch项目由FogBugz和Trello（StackOverflow的创建者之一）背后的同一家公司运营。 我经常使用这个平台来演示应用程序。 <br><br><h4> 码笔 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Codepen</a>是一个不错的平台，周围形成了一个有趣的社区。 在这里，您可以创建包含许多文件的项目，并使用自己的域来部署它们。 <br><br><h3>  <font color="#3AC1EF">▍无服务器环境</font> </h3><br> 无服务器平台使您无需完全考虑服务器，设置或管理服务器即可发布应用程序。 无服务器计算的范例是应用程序发布为响应对网络端点的调用的函数。 一种类似的应用程序部署方法也称为FAAS（功能即服务，功能即服务）。 <br><br> 以下是该领域的一些流行解决方案： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">无服务器</a>框架。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">标准</a>库。 </li></ul><br> 这两个项目都为开发人员提供了一定程度的抽象，从而允许在各种FAAS平台上发布应用程序，例如Amazon AWS Lambda，Microsoft Azure和Google Cloud。 <br><br><h3>  <font color="#3AC1EF">ASPAAS解决方案</font> </h3><br>  PAAS（平台即服务，平台即服务）是负责许多事情的平台，在正常情况下，应由部署应用程序的开发人员来照顾。 <br><br><h4> 现在时代 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Zeit</a>是用于部署应用程序的有趣选项。 使用此平台进行的部署归结为在终端中输入<code>now</code>命令。 有一个免费版本的Zeit，使用它时有一些限制。 该平台还有一个付费的，功能更强大的版本。 使用Zeit，您根本无法考虑您的应用程序需要服务器这一事实。 您只需部署应用程序，其他所有内容均由该平台管理。 <br><br><h4> 纳米盒 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nanobox</a>平台（包括Node.js应用程序的部署）的创建者将其称为PAAS V2。 <br><br><h4>  Heroku </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Heroku</a>是另一个用于托管Node.js应用程序的出色平台。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a>一篇关于如何使用它<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>好文章。 <br><br><h4> 微软天蓝色 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Azure</a>是Microsoft的云平台。 其文档中有关于Node.js应用程序的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">部分</a> 。 <br><br><h4>  Google Cloud Platform </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google Cloud</a>是用于部署Node.js应用程序的绝佳环境。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a>其文档<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>相关部分。 <br><br><h3>  <font color="#3AC1EF">▍VPS主机</font> </h3><br> 提供<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VPS托管服务的</a>平台很多。 这种平台的一个共同特征是，开发人员可以使用虚拟服务器，可以在其上独立安装操作系统（Linux或Windows），并可以独立部署应用程序。 <br><br> 在提供VPS服务的平台中，有很多，我们可以注意到以下内容，这些是我使用过的，可以推荐给其他人： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数字海洋</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Linode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Amazon Web Services</a> （尤其是我想提到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AWS Elastic Beanstalk</a> ，它使部署应用程序和管理AWS资源变得容易）。 </li></ul><br>  <i>我们自己补充说， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RUVDS</a>还提供VPS托管服务。</i>  <i>我们已获得FSTEC的许可，我们的客户已获得AIG的保险，我们在不同国家/地区拥有四个数据中心。</i>  <i>在莫斯科地区科罗廖夫市拥有自己的数据中心<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RUCLOUD</a> TIER 3，在数据中心<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Deltalis（瑞士）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">伦敦Equinix LD8（英国）</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MMTS-9</a> （俄罗斯莫斯科）中有压力区。</i>  <i>所有密闭区的可靠性至少达到TIER 3级。</i> <i><br><br></i>  <i>该公司的合作伙伴是FINAM JSC，BCS金融集团，国家结算存管所（莫斯科交易所），VTsIOM JSC，Gars-Telecom公司，Gett出租车运营商，Delivery Club交付运营商等。</i> <i><br></i> <br><br><h3>  <font color="#3AC1EF">▍普通服务器</font> </h3><br> 另一个托管解决方案是购买（或租用，例如，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vultr Bare Metal服务</a> ）常规服务器，在其上安装Linux和其他软件，将其连接到Internet并在其上托管Node.js应用程序。 <br><br> 托管是一个巨大的主题，但是希望本节中的材料将使您能够准确选择所需的内容。 现在，我们来谈谈在REPL模式下使用Node.js的故事。 <br><br><h2>  <font color="#3AC1EF">在REPL模式下使用Node.js</font> </h2><br> 缩写REPL代表Read-Evaluate-Print-Loop（循环“读取-计算-输出”）。 使用REPL是快速探索Node.js功能的好方法。 <br><br> 如您所知， <code>node</code>命令用于在Node.js中运行脚本，如下所示： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">node</span></span> script.js</code> </pre> <br> 如果您输入相同的命令，但未指定文件名，则将以REPL模式启动Node.js： <br><br><pre> <code class="hljs">node</code> </pre> <br> 如果您现在尝试在终端中输入这样的命令，那么您将看到类似以下内容： <br><br><pre> <code class="hljs markdown"><span class="hljs-quote"><span class="hljs-quote">&gt; node &gt;</span></span></code> </pre> <br>  Node.js现在处于待机模式。 系统希望我们在将要执行的命令行上输入一些JavaScript代码。 <br><br> 首先，让我们尝试一些非常简单的方法： <br><br><pre> <code class="hljs javascript">&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) test <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> &gt;</code> </pre> <br> 在这里，我们建议Node.js执行用于将数据输出到控制台的命令。 第一个值<code>test</code>是<code>console.log('test')</code> 。 第二个值<code>undefined</code>是<code>console.log()</code>函数返回的值。 <br><br> 命令完成后，将显示REPL提示符，这意味着我们可以在此处输入新命令。 <br><br><h3>  <font color="#3AC1EF">using使用Tab键完成命令</font> </h3><br>  REPL是一个交互式环境。 如果在编写代码时按键盘上的<code>Tab</code>键，REPL将尝试通过选择（例如）已声明的变量的合适名称或标准对象的名称来自动完成输入。 <br><br><h3>  <font color="#3AC1EF">JavaScript探索JavaScript对象</font> </h3><br> 在命令行中输入一些标准JavaScript对象的名称，例如<code>Number</code> ，在其后添加一个点，然后按<code>Tab</code> 。 <br><br>  REPL将列出开发人员可以与之交互的对象的属性和方法： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d67/455/2ac/d674552aca4cc48b60109e9602dc6d2a.png"></div><br>  <i><font color="#999999">检查数字对象</font></i> <br><br><h3>  <font color="#3AC1EF">global探索全局对象</font> </h3><br> 要找出可以使用的全局Node.js对象，请在terminal中输入<code>global.</code>命令<code>global.</code> 然后按<code>Tab</code> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/059/a52/b1a/059a52b1a742940e161b43a2af29bd51.png"></div><br>  <i><font color="#999999">全球对象研究</font></i> <br><br><h3>  <font color="#3AC1EF">▍特殊变量_</font> </h3><br> 变量<code>_</code> （下划线）存储上一次执行的操作的结果。 此变量可以用作输入到控制台的命令的一部分。 <br><br><h3>  <font color="#3AC1EF">with以句点开头的命令</font> </h3><br> 在REPL模式下，可以使用一些以句点开头的特殊命令。 它们是： <br><br><ul><li>  <code>.help</code>命令显示以<code>.help</code>命令的参考信息。 </li><li>  <code>.editor</code>命令<code>.editor</code>系统置于编辑器模式，这使输入多行JavaScript代码变得容易。 进入此模式后，输入所需的所有内容，使用<code>Ctrl+D</code>命令运行代码<code>Ctrl+D</code> </li><li>  <code>.break</code>命令允许<code>.break</code>中止多行表达式输入。 它的用法类似于键盘快捷键<code>Ctrl+C</code>的用法<code>Ctrl+C</code> </li><li>  <code>.clear</code>命令清除REPL上下文，并中断多行表达式的输入。 </li><li>  <code>.load</code>命令将代码从JavaScript文件加载到当前会话中。 </li><li>  <code>.save</code>命令会将在REPL会话期间输入的所有内容保存到文件中。 </li><li>  <code>.exit</code>命令允许<code>.exit</code>退出REPL会话；它的行为就像<code>Ctrl+C</code>组合键的两个连续击键一样。 </li></ul><br> 应该注意的是，即使不使用<code>.editor</code> ，REPL也会识别多行表达式的输入。 <br><br> 例如，我们开始输入迭代器代码： <br><br><pre> <code class="hljs javascript">[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function"> =&gt;</span></span> {</code> </pre> <br> 如果在输入花括号后，按<code>Enter</code>键，则REPL将转到新行，提示中的内容将类似于三个点。 这表明我们可以输入相应块的代码。 看起来像这样： <br><br><pre> <code class="hljs matlab">... console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(num) ... })</code> </pre> <br>  <code>Enter</code>最后一个括号后按<code>Enter</code>将执行表达式。 如果在此模式下输入<code>.break</code> ，则输入将被中止，并且表达式将不被执行。 <br><br>  REPL模式是Node.js的有用功能，但其范围仅限于小型实验。 除了对执行几个命令的能力之外，我们对其他事情还感兴趣。 因此，我们继续以普通模式使用Node.js。 即，让我们谈谈Node.js脚本如何接受命令行参数。 <br><br><h2>  <font color="#3AC1EF">在Node.js脚本中使用命令行参数</font> </h2><br> 运行Node.js脚本时，可以将参数传递给它们。 这是一个常规的脚本调用： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">node</span></span> app.js</code> </pre> <br> 传递给脚本的参数可以是独立值或键值构造。 在第一种情况下，运行脚本如下所示： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">node</span></span> app.js flavio</code> </pre> <br> 在第二个-像这样： <br><br><pre> <code class="hljs pgsql">node app.js <span class="hljs-type"><span class="hljs-type">name</span></span>=flavio</code> </pre> <br> 传递参数的方法用于确定如何在脚本代码中使用它们。 <br><br> 因此，为了访问命令行参数，使用了标准的Node.js <code>process</code>对象。 它具有<code>argv</code>属性，该属性是一个数组，其中包含启动时传递给脚本的参数。 <br><br>  <code>argv</code>数组的第一个元素包含在命令行上输入<code>node</code>命令时执行的文件的完整路径。 <br><br> 第二个元素是脚本可执行文件的路径。 <br><br> 从第三个数组开始，数组的所有其他元素都包含运行时传递给脚本的内容。 <br><br> 可以使用<code>forEach</code>循环来组织<code>argv</code>可用的参数的枚举（这包括<code>node</code>的路径和脚本的可执行文件的路径）： <br><br><pre> <code class="hljs javascript">process.argv.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val, index</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${index}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${val}</span></span></span><span class="hljs-string">`</span></span>) })</code> </pre> <br> 如果您对前两个参数不感兴趣，则可以基于<code>argv</code>创建一个新数组，该数组将包含<code>argv</code>除前两个元素以外的所有内容： <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args = process.argv.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br> 假设在运行脚本时，仅一个参数以独立值的形式传递给它： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">node</span></span> app.js flavio</code> </pre> <br> 您可以像这样访问此参数： <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args = process.argv.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>) args[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br> 现在，让我们尝试使用键值类型构造： <br><br><pre> <code class="hljs pgsql">node app.js <span class="hljs-type"><span class="hljs-type">name</span></span>=flavio</code> </pre> <br> 通过这种方法，在形成<code>args</code>数组之后，字符串<code>name=flavio</code>在<code>args[0]</code> 。 在使用参数之前，必须先解析此字符串。 最方便的方法是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">minimist</a>库，该库旨在简化命令行参数的使用： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'minimist'</span></span>)(process.argv.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>)) args[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] <span class="hljs-comment"><span class="hljs-comment">//flavio</span></span></code> </pre> <br> 现在考虑输出到控制台。 <br><br><h2>  <font color="#3AC1EF">使用控制台模块将数据输出到控制台</font> </h2><br> 标准的Node.js <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">控制台</a>模块为开发人员提供了很多在程序执行过程中与命令行进行交互的机会。 通常，这与基于浏览器的JavaScript中使用的<code>console</code>对象相同。  <code>console</code>模块最简单，使用最广泛的方法可能是<code>console.log()</code> ，它用于将字符串数据输出到控制台。 此外，如果将对象传递给它，则该对象在输出之前将转换为它的字符串表示形式。 <br><br>  <code>console.log()</code>方法可以传递几个值： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> y = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x, y)</code> </pre> <br> 执行此指令序列后， <code>x</code>值和<code>y</code>值都将到达控制台。 <br><br> 要形成复杂的字符串， <code>console.log()</code>命令支持使用通配符，通配​​符在输出数据时会按优先级顺序用其对应的值替换。 <br><br> 例如，这是一个显示文本<code>My cat has 2 years</code> ： <br><br><pre> <code class="hljs pgsql">console.log(<span class="hljs-string"><span class="hljs-string">'My %s has %d years'</span></span>, <span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br> 请考虑通配符的功能： <br><br><ul><li>  <code>%s</code>将值格式化为字符串。 </li><li>  <code>%d</code>或<code>%i</code>将值格式化为整数。 </li><li>  <code>%f</code>将值格式化为浮点数。 </li><li>  <code>%O</code>用于显示对象的字符串表示形式。 </li></ul><br> 这是使用通配符的另一个示例： <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'%O'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">▍清洁控制台</font> </h3><br> 要清除控制台，请使用<code>console.clear()</code>命令（其在不同终端中的行为可能有所不同）。 <br><br><h3>  <font color="#3AC1EF">▍计数元素</font> </h3><br> 现在我们来看一下有用的<code>console.count()</code>方法。 看一下这段代码： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> y = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> z = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.count( <span class="hljs-string"><span class="hljs-string">'The value of x is '</span></span> + x + <span class="hljs-string"><span class="hljs-string">' and has been checked .. how many times?'</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.count( <span class="hljs-string"><span class="hljs-string">'The value of x is '</span></span> + x + <span class="hljs-string"><span class="hljs-string">' and has been checked .. how many times?'</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.count( <span class="hljs-string"><span class="hljs-string">'The value of y is '</span></span> + y + <span class="hljs-string"><span class="hljs-string">' and has been checked .. how many times?'</span></span> )</code> </pre> <br>  <code>count()</code>方法对行输出的数量进行计数，并在其旁边显示结果。 <br> 在以下示例中，使用此方法，您可以计算苹果和橙子： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oranges = [<span class="hljs-string"><span class="hljs-string">'orange'</span></span>, <span class="hljs-string"><span class="hljs-string">'orange'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> apples = [<span class="hljs-string"><span class="hljs-string">'just one apple'</span></span>] oranges.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fruit</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.count(fruit) }) apples.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fruit</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.count(fruit) })</code> </pre> <br><h3>  <font color="#3AC1EF">stack将堆栈跟踪结果显示到控制台</font> </h3><br> 有时将功能堆栈的痕迹打印到控制台很有用。 例如，为了回答我们如何到达程序中的某个位置的问题。 您可以使用以下命令执行此操作： <br><br><pre> <code class="hljs mel">console.<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>()</code> </pre> <br> 这是一个用法示例： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> function2 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.trace() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> function1 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> function2() function1()</code> </pre> <br> 这是我在REPL模式下运行此代码时发生的情况： <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Trace</span></span>   <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">function2</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">repl</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:1</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:33)</span></span>   <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">function1</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">repl</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:1</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:25)</span></span>   <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">repl</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:1</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:1</span></span>   <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ContextifyScript</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Script</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.runInThisContext</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">vm</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.js</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:33)</span></span>   <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">REPLServer</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.defaultEval</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">repl</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.js</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:239</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:29)</span></span>   <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bound</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">domain</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.js</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:301</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:14)</span></span>   <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">REPLServer</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.runBound</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[as eval]</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">domain</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.js</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:314</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:12)</span></span>   <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">REPLServer</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onLine</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">repl</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.js</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:440</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:10)</span></span>   <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">emitOne</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">events</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.js</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:120</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:20)</span></span>   <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">REPLServer</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.emit</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">events</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.js</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:210</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:7)</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍衡量完成一项动作所花费的时间</font> </h3><br> 您可以使用<code>console.time()</code>和<code>console.timeEnd()</code>方法来衡量执行某个函数所需的时间。 看起来像这样： <br><br><pre> <code class="hljs coffeescript">const doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) const measureDoingSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">'doSomething()'</span></span>) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,     doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">'doSomething()'</span></span>) } measureDoingSomething()</code> </pre> <br><h3>  <font color="#3AC1EF">with使用stdout和stderr</font> </h3><br> 如我们所见， <code>console.log()</code>命令非常适合将消息输出到控制台。 使用它时，将使用所谓的标准输出流或<code>stdout</code> 。 <br><br>  <code>console.error()</code>命令将数据转储到标准错误流<code>stderr</code> 。 发送到<code>stderr</code>数据将到达控制台，尽管例如，输出到此流的内容可以重定向到错误日志文件。 <br><br><h3>  <font color="#3AC1EF">color将数据输出到控制台时使用颜色</font> </h3><br> 为了使控制台中显示的文本着色，可以使用标识颜色的转义序列： <br><br><pre> <code class="hljs pgsql">console.log(<span class="hljs-string"><span class="hljs-string">'\x1b[33m%s\x1b[0m'</span></span>, <span class="hljs-string"><span class="hljs-string">'hi!'</span></span>)</code> </pre> <br> 例如，如果在REPL模式下执行此命令，则文本<code>hi</code>将以黄色显示。 <br> 但是，这种方法不是特别方便。 使用专门的库（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">粉笔）在控制台中显示彩色文本</a>会很方便。 该库除了可以对文本进行颜色格式化外，还支持其他样式样式。 例如，在其帮助下，可以将文本设置为粗体，斜体或带下划线的字体。 <br><br> 要从npm安装它，请使用以下命令： <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> chalk</code> </pre> <br> 您可以像这样使用它： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chalk = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chalk'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.yellow(<span class="hljs-string"><span class="hljs-string">'hi!'</span></span>))</code> </pre> <br> 使用<code>chalk.yellow()</code> 。 <br><br> 要了解有关粉笔的更多信息，请查看GitHub上的此库<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">页面</a> 。 <br><br><h3>  <font color="#3AC1EF">▍创建进度条</font> </h3><br> 进度栏在不同情况下可能很有用。 您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">进度</a>包来创建在控制台中运行的进度指示器。 您可以这样安装： <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> progress</code> </pre> <br> 下面是一个代码示例，其中创建了一个指示符，该指示符可用于显示有关由10个步骤组成的任务的信息。 在我们的情况下，完成每个步骤需要100毫秒。 指示器满后，将<code>clearItnerval()</code>命令，程序结束。 <br><br><pre> <code class="hljs lisp">const ProgressBar = require('progress') const bar = new ProgressBar('<span class="hljs-symbol"><span class="hljs-symbol">:bar</span></span>', { total: <span class="hljs-number"><span class="hljs-number">10</span></span> }) const timer = setInterval(() =&gt; { bar.tick() if (<span class="hljs-name"><span class="hljs-name">bar</span></span>.complete) {   clearInterval(<span class="hljs-name"><span class="hljs-name">timer</span></span>) } }, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">from从命令行接收用户输入</font> </h3><br> 如何使为Node.js平台编写的命令行应用程序具有交互性？ 从版本7开始，Node.js包含一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">readline</a>模块，该模块允许您从可读取的流（例如从<code>process.stdin</code>接收数据。 在Node.js程序执行期间，该线程就是在终端中输入的线程。 一次输入一行数据。 <br><br> 考虑以下代码片段： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> readline = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'readline'</span></span>).createInterface({ <span class="hljs-attr"><span class="hljs-attr">input</span></span>: process.stdin, <span class="hljs-attr"><span class="hljs-attr">output</span></span>: process.stdout }) readline.question(<span class="hljs-string"><span class="hljs-string">`What's your name?`</span></span>, (name) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Hi </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">!`</span></span>) readline.close() })</code> </pre> <br> 在这里，我们询问用户他的名字，然后输入文本并按键盘上的<code>Enter</code>键，然后显示问候语。 <br><br>  <code>question()</code>方法将传递给它的内容作为第一个参数（即，向用户询问的问题）显示出来，并等待输入完成。 按下<code>Enter</code>它将调用第二个参数中传递给它的回调并处理输入的内容。 在同一回调中，我们关闭<code>readline</code>接口。 <br><br>  <code>readline</code>    ,        ,     . <br><br>  ,    ,     ,     ,   ,  ,        — <code>*</code> . <br><br>     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">readline-sync</a> ,     ,    <code>readline</code> ,        . <br><br>     ,        .   <a href="">inquirer</a> .    : <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> inquirer</code> </pre> <br>         : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inquirer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'inquirer'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> questions = [{ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'input'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">"What's your name?"</span></span>, }] inquirer.prompt(questions).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">answers</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Hi </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${answers[</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'name'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">!`</span></span>) })</code> </pre> <br>  inquirer   . ,                 . <br><br>             Node.js.       <code>readline</code> ,  readline-sync  inquirer.       ,              ,      . <br><br><h2> <font color="#3AC1EF">  Node.js,   exports</font> </h2><br>   ,   API <code>module.exports</code>  ,         .  Node.js    ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> .   ,    <code>require</code> ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./library'</span></span>)</code> </pre> <br>     <code>library.js</code> ,       ,    ,  . <br><br> ,      ,  - ,  .  ,      ,   .  , API <code>module.exports</code>    ,         . <br><br>     . <br><br>       <code>module.exports</code> ,    ,   .       : <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { brand: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, model: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> = car <span class="hljs-comment"><span class="hljs-comment">//..   const car = require('./car')</span></span></code> </pre> <br>     ,        <code>exports</code> .        , ,    — : <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { brand: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, model: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span>.car = car</code> </pre> <br>       : <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">exports</span></span>.car = { brand: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, model: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span> }</code> </pre> <br>     ,   ,  : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> items = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./items'</span></span>) items.car</code> </pre> <br>  : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./items'</span></span>).car</code> </pre> <br>        <code>module.exports</code>     <code>exports</code> ? <br><br>    ,    <code>module.exports</code> .       . <br><br><h2> <font color="#3AC1EF"></font> </h2><br>       Node.js-,  REPL,     ,    Node.js.         npm, ,  ,    <code>package.json</code>  <code>package-lock.json</code> . <br><br>  <b>亲爱的读者们！</b>       Node.js-? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN423701/">https://habr.com/ru/post/zh-CN423701/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN423689/index.html">RTOS MAX-免费吗？ 我们计划开放免费商业使用许可</a></li>
<li><a href="../zh-CN423693/index.html">使用Webpack 4和代码分离的另一种方法</a></li>
<li><a href="../zh-CN423695/index.html">如何用银行账户中的一百万美元退休40年</a></li>
<li><a href="../zh-CN423697/index.html">介绍Spring Data JDBC</a></li>
<li><a href="../zh-CN423699/index.html">“数字经济”的价格上涨：必须从预算中拨出2万亿卢布</a></li>
<li><a href="../zh-CN423703/index.html">Node.js手册，第4部分：npm，package.json和package-lock.json文件</a></li>
<li><a href="../zh-CN423705/index.html">Node.js手册，第5部分：npm和npx</a></li>
<li><a href="../zh-CN423707/index.html">Jaxx的内幕是什么。 开箱即用的熵128位</a></li>
<li><a href="../zh-CN423709/index.html">CSS Grid-用于网站和应用程序布局的瑞士军刀</a></li>
<li><a href="../zh-CN423711/index.html">管理极客：从哪里获取数据？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>