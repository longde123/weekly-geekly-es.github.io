<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ˆğŸ» ğŸ‘¨ğŸ½â€ğŸ“ ğŸ‘¨ğŸ¾â€ğŸ¨ Kombinieren mehrerer Pakete in einem einzigen Python-Namespace ğŸ¤½ğŸ½ ğŸ² ğŸ‘©ğŸ½â€ğŸ¤â€ğŸ‘¨ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Manchmal ist es erforderlich, mehrere Pakete, die im selben Namespace liegen, auf unterschiedlichen physischen Pfaden zu trennen. Wenn Sie beispielswe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kombinieren mehrerer Pakete in einem einzigen Python-Namespace</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458432/">  Manchmal ist es erforderlich, mehrere Pakete, die im selben Namespace liegen, auf unterschiedlichen physischen Pfaden zu trennen.  Wenn Sie beispielsweise verschiedene Layouts von Plugins Ã¼bertragen mÃ¶chten, diese anschlieÃŸend hinzufÃ¼gen kÃ¶nnen, ohne ihren Speicherort zu steuern, und gleichzeitig Ã¼ber einen Namespace auf sie zugreifen kÃ¶nnen. <br><br>  Dieser Spickzettel, der eher fÃ¼r AnfÃ¤nger geeignet ist, ist Python-Namespaces gewidmet. <br><br>  Schauen wir uns an, wie dies in verschiedenen Versionen von Python mÃ¶glich ist, da Python2 zwar bald nicht mehr unterstÃ¼tzt wird, sich viele von uns jedoch gerade zwischen zwei BrÃ¤nden befinden. Dies ist nur eine der wichtigen Nuancen beim Ãœbergang. <br><br><img src="https://habrastorage.org/webt/q4/bw/uz/q4bwuz7njfxhpsdaaignisff3ew.png" alt="Bild"><br><a name="habracut"></a><br>  Betrachten Sie dieses Beispiel: <br><br>  Wir wollen die Paketstruktur bekommen: <br><br><pre><code class="markdown hljs">namespace1 package1 module1 package2 module2</code> </pre> <br>  Inhalt der Modul1-Datei <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">'package 1'</span></span>) var1 = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Inhalt der Modul2-Datei <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">'package 2'</span></span>) var2 = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Gleichzeitig werden Pakete in der folgenden Ordnerstruktur verteilt: <br><br><pre> <code class="markdown hljs"> path1 namespace1 package1 module1 path2 namespace1 package2 module2</code> </pre><br>  Angenommen, Pfad1 und Pfad2 sind bereits zu sys.path hinzugefÃ¼gt.  Wir mÃ¼ssen auf Modul1 und Modul2 zugreifen: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> namespace1.package1 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> module1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> namespace1.package2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> module2</code> </pre><br>  Was passiert in <b>Python 3.7,</b> wenn dieser Code ausgefÃ¼hrt wird?  Alles funktioniert wunderbar: <br><br><pre> <code class="markdown hljs">package 1 package 2</code> </pre><br>  Mit PEP-420 in Python 3.3 wurde die UnterstÃ¼tzung impliziter Namespaces angezeigt.  AuÃŸerdem mÃ¼ssen Sie beim Importieren eines Pakets von py33 keine __init__.py-Dateien erstellen.  Und beim Importieren von Namespace ist es nur _ verboten_.  Wenn die Datei __init__.py in einem oder beiden Verzeichnissen mit dem Namen name1 vorhanden ist, tritt beim Import des zweiten Pakets ein Fehler auf. <br><br><pre> <code class="python hljs">ModuleNotFoundError: No module named <span class="hljs-string"><span class="hljs-string">'namespace1.package2'</span></span></code> </pre><br>  Das Vorhandensein eines Insiders bestimmt also explizit das Paket, und Pakete kÃ¶nnen nicht kombiniert werden, es ist eine einzelne EntitÃ¤t.  Wenn Sie unabhÃ¤ngig von der alten Entwicklung ein neues Projekt starten und die Pakete mit pip installiert werden, mÃ¼ssen Sie sich an diese Methode halten.  Manchmal erben wir jedoch den alten Code, der zumindest fÃ¼r eine Weile beibehalten oder auf eine neue Version portiert werden muss. <br><br>  Fahren wir mit <b>Python 2.7 fort</b> .  Bei dieser Version ist es bereits interessanter, dass Sie zuerst __init__.py zu jedem Verzeichnis hinzufÃ¼gen mÃ¼ssen, um Pakete zu erstellen. Andernfalls erkennt der Interpreter das Paket in diesem Satz von Dateien einfach nicht.  Schreiben Sie dann eine explizite Namespace-Deklaration in __init__-Dateien, die sich auf Namespace1 beziehen. Andernfalls wird nur das erste Paket importiert. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pkgutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> extend_path __path__ = extend_path(__path__, __name__)</code> </pre><br>  Was passiert damit?  Wenn der Interpreter den ersten Import erreicht, wird ein Paket mit demselben Namen in sys.path durchsucht, es befindet sich in path1 / namespace1 und der Interpreter fÃ¼hrt path1 / namespace1 / __ init__.py aus.  Weitere Suche wird nicht durchgefÃ¼hrt.  Die Funktion extens_path selbst durchsucht jedoch bereits sys.path, findet alle Pakete mit dem Namen namespace1 und dem internen Namen und fÃ¼gt sie der Variablen __path__ des Pakets namespace1 hinzu, mit der in diesem Namespace nach untergeordneten Paketen gesucht wird. <br><br>  In offiziellen HandbÃ¼chern wird empfohlen, dass die Initialen bei jedem Platzieren von Namespace1 gleich sind.  TatsÃ¤chlich kÃ¶nnen sie alle bis auf die erste leer sein, die wÃ¤hrend einer Suche in sys.path gefunden wird, in der pkgutil.extend_path aufgerufen werden soll, da der Rest nicht ausgefÃ¼hrt wird.  Es ist jedoch natÃ¼rlich besser, dass der Anruf wirklich in jedem Team erfolgt, um Ihre Logik nicht â€fÃ¼r den Fallâ€œ zu verknÃ¼pfen und nicht zu erraten, welches Team als erstes ausgefÃ¼hrt wurde, da sich die Suchreihenfolge Ã¤ndern kann.  Aus dem gleichen Grund sollten Sie keine anderen logischen __init__- Dateien im Variablenbereich platzieren. <br><br>  Dies wird in zukÃ¼nftigen Versionen funktionieren und dieser Code kann zum Schreiben von <b>kompatiblem Code verwendet</b> werden. Beachten Sie jedoch, dass Sie die gewÃ¤hlte Methode in jedem verteilten Paket einhalten mÃ¼ssen.  Wenn Sie in Version 3 bei einem Aufruf von pkgutil.extend_path einen Posteingang in einige Pakete einfÃ¼gen und einige ohne Posteingang belassen, funktioniert dies nicht. <br>  DarÃ¼ber hinaus eignet sich diese Option auch fÃ¼r den Fall, dass Sie die Installation mit python setup.py installieren mÃ¶chten. <br><br>  Ein anderer Weg, der jetzt als etwas veraltet gilt, aber immer noch viel zu finden ist, wo: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#namespace1/__init__.py __import__('pkg_resources').declare_namespace(__name__)</span></span></code> </pre><br>  Das Modul pkg_resources wird mit dem Paket setuptools geliefert.  Hier ist die Bedeutung dieselbe wie in pkgutil - es ist erforderlich, dass jede __init__-Datei an jedem Speicherort von Namespace1 dieselbe Namespace-Deklaration enthÃ¤lt und es keinen anderen Code gibt.  Gleichzeitig muss der Namespace namespace_packages = ['namespace1'] in setup.py registriert werden.  Eine detailliertere Beschreibung des Erstellens von Paketen wÃ¼rde den Rahmen dieses Artikels sprengen. <br><br>  AuÃŸerdem finden Sie hÃ¤ufig einen solchen Code <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: __import__(<span class="hljs-string"><span class="hljs-string">'pkg_resources'</span></span>).declare_namespace(__name__) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pkgutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> extend_path __path__ = extend_path(__path__, __name__)</code> </pre><br>  Hier ist die Logik einfach: Wenn setuptools nicht installiert ist, verwenden wir pkgutil, das in der Standardbibliothek enthalten ist. <br><br>  Wenn Sie einen Namespace auf eine dieser Arten konfigurieren, kÃ¶nnen Sie einen anderen von einem Modul aus aufrufen.  Ã„ndern Sie beispielsweise den Namespace1 / package2 / module2 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namespace1.package1.module1 print(var1)</code> </pre><br>  Und dann werden wir sehen, was passiert, wenn wir fÃ¤lschlicherweise ein neues und ein vorhandenes Paket benennen und es mit demselben Namespace umschlieÃŸen.  Beispielsweise gibt es zwei Pakete an verschiedenen Orten mit dem Namen package1. <br><br><pre> <code class="markdown hljs">namespace1 package1 module1 package1 module2</code> </pre><br>  In diesem Fall wird nur der erste importiert und es besteht kein Zugriff auf Modul2.  Pakete kÃ¶nnen nicht kombiniert werden. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> namespace1.package1 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> module1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> namespace1.package1 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> module2 <span class="hljs-comment"><span class="hljs-comment">#&gt;&gt;ImportError: cannot import name module2</span></span></code> </pre> <br>  <b>Zusammenfassung:</b> <br><br><ol><li>  FÃ¼r Python, das Ã¤lter als 3.3 ist und mit pip installiert wird, wird empfohlen, eine implizite Namespace-Deklaration zu verwenden. </li><li>  Bei UnterstÃ¼tzung der Versionen 2 und 3 sowie bei der Installation mit pip und python setup.py wird die Option mit pkgutil empfohlen. </li><li>  Die Option pkg_resources wird empfohlen, wenn Sie Ã¤ltere Pakete mit dieser Methode unterstÃ¼tzen mÃ¼ssen oder wenn das Paket zip-sicher sein soll. </li></ol><br>  Quellen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">package.python.org/guides/packaging-namespace-packages</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.python.org/dev/peps/pep-0420</a> </li><li>  Python lernen, 5. Auflage von Mark Lutz </li></ul><br>  Beispiele finden Sie <a href="">hier</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458432/">https://habr.com/ru/post/de458432/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458418/index.html">5 Browser-Erweiterungen fÃ¼r die Arbeit mit englischem Text</a></li>
<li><a href="../de458420/index.html">AWS_Ru-Treffen bei der Raiffeisenbank</a></li>
<li><a href="../de458422/index.html">Ãœbersicht Ã¼ber Grant-Programme fÃ¼r Blockchain-Entwickler</a></li>
<li><a href="../de458424/index.html">Drohnen-Show: Inside Look</a></li>
<li><a href="../de458428/index.html">Google Ã¶ffnet den Parser-Quellcode robots.txt</a></li>
<li><a href="../de458434/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 11. VLAN-Grundlagen</a></li>
<li><a href="../de458436/index.html">HÃ¤ufige Protokollierungsfehler</a></li>
<li><a href="../de458440/index.html">Technischer Support an Wochentagen: Geschichten darÃ¼ber, was passiert, wenn Sie den Benutzer nicht erreichen kÃ¶nnen</a></li>
<li><a href="../de458442/index.html">Warum ruft LLVM mÃ¶glicherweise eine nie aufgerufene Funktion auf?</a></li>
<li><a href="../de458444/index.html">Internet fÃ¼r den Sommerbewohner. Teil 4. Eine SIM-Karte reicht aus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>