<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏼 🤚🏽 💝 Dart 2. Programmation asynchrone: flux de données ⛓️ 👵🏽 🔊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programmation asynchrone: flux de données 


 Table des matières 


- Réception d'événements de flux 
- Événements d'erreur 
- Travailler avec des flu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dart 2. Programmation asynchrone: flux de données</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442274/"><h1 id="asinhronnoe-programmirovanie-potoki-dannyh">  Programmation asynchrone: flux de données </h1><br><p>  <strong>Table des matières</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Réception d'événements de flux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Événements d'erreur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travailler avec des flux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Types de flux</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Flux d'abonnement</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Flux de diffusion</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Méthodes de traitement des flux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Méthodes de modification du flux</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonction Transform ()</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lecture et décodage d'un fichier</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Méthode Listen ()</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Que lire d'autre?</a> </li></ul><br><p>  <strong>Ce qui est important:</strong> </p><br><ul><li>  Les flux fournissent une séquence de données asynchrone. </li><li>  Les séquences de données contiennent des événements utilisateur et des données lues dans des fichiers. </li><li> Le flux peut être traité à l'aide de l' <strong>attente</strong> ou de l' <code>listen()</code> de l'API <code>Stream</code> . </li><li>  Les flux fournissent un moyen de répondre aux erreurs. </li><li>  Il existe deux types de flux: les flux <code>single subscription</code> et la diffusion. <a name="habracut"></a></li></ul><br><p>  La programmation asynchrone dans Dart est caractérisée par les classes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Future</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stream</a> . </p><br><p>  <code>Future</code> est un calcul différé.  Si une fonction normale renvoie un résultat, la fonction asynchrone renvoie un objet <code>Future</code> ( <code>future</code> ) qui contiendra finalement le résultat.  <code>future</code> renverra le résultat une fois l'opération terminée. </p><br><p>  Un flux est une séquence d'événements asynchrones.  Cela est similaire à un objet asynchrone <code>Iterable</code> , où au lieu de recevoir l'événement suivant lorsque vous le demandez, le thread signale l'événement lorsqu'il est prêt. </p><br><h2 id="poluchenie-sobytiy-potoka">  Réception d'événements de flux </h2><br><p>  Les flux peuvent être créés de différentes manières, ce qui est le sujet d'un autre article, mais ils peuvent tous être utilisés de la même manière: une boucle for asynchrone (généralement appelée en <strong>attente de</strong> ) itère les événements de flux, comme une boucle <strong>for</strong> itère à travers une collection.  Par exemple: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; stream)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value in stream)</span></span></span><span class="hljs-function"> </span></span>{ sum += value; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br><p>  Ce code reçoit simplement l'événement entier du flux, les ajoute et renvoie le montant ( <code>future</code> ).  Lorsque le corps de la boucle se termine, la fonction se met en pause jusqu'à la fin de l'événement ou du thread suivant. </p><br><p>  La fonction est marquée avec le <code>async</code> - <code>async</code> , qui est requis lors de l'utilisation de la boucle <strong>wait for</strong> . </p><br><p>  L'exemple suivant (sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DartPad</a> ) vérifie le code précédent en créant un simple flux d'entiers à l'aide d'une fonction avec <code>async*</code> ( <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">générateur de</a> notes</em> ): </p><br><div class="spoiler">  <b class="spoiler_title">Exemple de code</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2015, the Dart project authors. // Please see the AUTHORS file for details. // All rights reserved. Use of this source code is governed // by a BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;int&gt; sumStream(Stream&lt;int&gt; stream) async { var sum = 0; await for (var value in stream) { sum += value; } return sum; } Stream&lt;int&gt; countStream(int to) async* { for (int i = 1; i &lt;= to; i++) { yield i; } } main() async { var stream = countStream(10); var sum = await sumStream(stream); print(sum); // 55 }</span></span></code> </pre> </div></div><br><h2 id="sobytiya-s-oshibkoy">  Événements d'erreur </h2><br><p>  Les threads sont exécutés lorsqu'il n'y a plus d'événements en eux, et le code qui reçoit les événements en est informé de la même manière qu'il est informé de l'arrivée d'un nouvel événement.  Lors de la lecture des événements avec <strong>wait for, la</strong> boucle se termine à la fin du flux. </p><br><p>  Dans certains cas, une erreur se produit avant la fin du flux;  peut-être une défaillance du réseau lors de la récupération d'un fichier à partir d'un serveur distant ou le code qui a généré les événements contient une erreur, quelqu'un devrait le savoir. </p><br><p>  Les flux peuvent signaler un événement d'erreur de la même manière que les événements de données.  La plupart des threads s'arrêtent après la première erreur, mais les threads qui renvoient plus d'une erreur et les threads qui signalent des données après un événement d'erreur sont possibles.  Dans ce document, nous discutons uniquement des threads qui ne retournent pas plus d'une erreur. </p><br><p>  Lors de la lecture d'un flux à l'aide de l' <strong>attente de, une</strong> erreur est générée par l'opérateur de boucle.  Cela termine également la boucle.  Vous pouvez attraper l'erreur avec try-catch.  Dans l'exemple suivant (sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DartPad</a> ), une erreur se produit si l'itérateur de boucle est 4: </p><br><div class="spoiler">  <b class="spoiler_title">Exemple de code</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2015, the Dart project authors. // Please see the AUTHORS file for details. // All rights reserved. Use of this source code is governed // by a BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;int&gt; sumStream(Stream&lt;int&gt; stream) async { var sum = 0; try { await for (var value in stream) { sum += value; } } catch (e) { return -1; } return sum; } Stream&lt;int&gt; countStream(int to) async* { for (int i = 1; i &lt;= to; i++) { if (i == 4) { throw new Exception('Intentional exception'); } else { yield i; } } } main() async { var stream = countStream(10); var sum = await sumStream(stream); print(sum); // -1 }</span></span></code> </pre> </div></div><br><h2 id="rabota-s-potokami">  Travailler avec des flux </h2><br><p>  La classe <code>Stream</code> contient un certain nombre de méthodes d'assistance qui peuvent effectuer des opérations générales sur un flux, similaires aux méthodes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Iterable</a> .  Par exemple, vous pouvez trouver le plus petit entier positif dans un flux à l'aide de <code>lastWhere()</code> de l'API <code>Stream</code> . </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastPositive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; stream)</span></span></span><span class="hljs-function"> </span></span>=&gt; stream.lastWhere((x) =&gt; x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h2 id="tipy-potokov">  Types de flux </h2><br><h3 id="potoki-podpiski">  Flux d'abonnement </h3><br><p>  Le type de flux le plus courant contient une séquence d'événements qui font partie d'un ensemble plus large.  Les événements doivent être livrés dans le bon ordre sans en manquer aucun.  Il s'agit du type de flux que vous recevez lors de la lecture d'un fichier ou de la réception d'une demande Web. </p><br><p>  Un tel flux ne peut être écouté qu'une seule fois.  Écouter plus tard peut signifier ignorer les événements initiaux, puis le reste du flux n'a pas de sens.  Lorsque vous commencez à écouter, les données seront extraites et fournies en morceaux. </p><br><h3 id="shirokoveschatelnye-potoki">  Flux de diffusion </h3><br><p>  Un autre type de flux concerne les messages individuels qui peuvent être traités un par un.  Un tel flux peut être utilisé, par exemple, pour des événements de souris dans un navigateur. </p><br><p>  Vous pouvez commencer à écouter un tel flux à tout moment et vous recevrez des événements survenus pendant l'écoute.  Stream peut écouter plusieurs auditeurs.  Vous pouvez recommencer à écouter les événements de streaming après avoir annulé un abonnement précédent. </p><br><h2 id="metody-obrabatyvayuschie-potok">  Méthodes de traitement des flux </h2><br><p>  Les méthodes suivantes dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stream &lt;T&gt;</a> traitent le flux et renvoient le résultat: </p><br><pre> <code class="java hljs">Future&lt;T&gt; get first; Future&lt;bool&gt; get isEmpty; Future&lt;T&gt; get last; Future&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; get length; Future&lt;T&gt; get single; <span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object needle)</span></span></span></span>; Future&lt;E&gt; drain&lt;E&gt;([E futureValue]); <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elementAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">every</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstWhere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test, </span></span>{<span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> orElse})</span></span>; Future&lt;S&gt; fold&lt;S&gt;(S initialValue, <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S previous, T element)</span></span></span><span class="hljs-function"> combine)</span></span>; <span class="hljs-function"><span class="hljs-function">Future </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(T element)</span></span></span><span class="hljs-function"> action)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([String separator = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastWhere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test, </span></span>{<span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> orElse})</span></span>; <span class="hljs-function"><span class="hljs-function">Future </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pipe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamConsumer&lt;T&gt; streamConsumer)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T Function(T previous, T element)</span></span></span><span class="hljs-function"> combine)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">singleWhere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test, </span></span>{<span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> orElse})</span></span>; Future&lt;List&lt;T&gt;&gt; toList(); Future&lt;Set&lt;T&gt;&gt; toSet();</code> </pre> <br><p>  Toutes ces fonctions, à l'exception de <code>drain()</code> et <code>pipe()</code> , correspondent à une fonction similaire dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Iterable</a> .  Chacun d'eux peut être facilement écrit en utilisant une fonction asynchrone avec une boucle en <strong>attente</strong> (ou simplement en utilisant l'une des autres méthodes).  Par exemple, certaines implémentations peuvent être les suivantes: <br>  Toutes ces fonctions, à l'exception de drain () et pipe (), correspondent à une fonction similaire sur Iterable.  Chacun peut être écrit facilement en utilisant une fonction asynchrone avec une boucle d'attente (ou simplement en utilisant l'une des autres méthodes).  Par exemple, certaines implémentations pourraient être: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object needle)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event == needle) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-function"><span class="hljs-function">Future </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(T element)</span></span></span><span class="hljs-function"> action) async </span></span>{ <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ action(event); } } Future&lt;List&lt;T&gt;&gt; toList() async { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> result = &lt;T&gt;[]; await <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forEach(result.add); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-function">Future&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([String separator = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> async </span></span>=&gt; (await <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toList()).join(separator);</code> </pre> <br><p>  (La mise en œuvre réelle est un peu plus compliquée, mais principalement pour des raisons historiques.) </p><br><h2 id="metody-izmenyayuschie-potok">  Méthodes de modification du flux </h2><br><p>  Les méthodes suivantes dans Stream renvoient un nouveau flux basé sur le flux d'origine.  Chacun attend que quelqu'un écoute le nouveau flux avant d'écouter l'original. </p><br><pre> <code class="java hljs">Stream&lt;R&gt; cast&lt;R&gt;(); Stream&lt;S&gt; expand&lt;S&gt;(<span class="hljs-function"><span class="hljs-function">Iterable&lt;S&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T element)</span></span></span><span class="hljs-function"> convert)</span></span>; Stream&lt;S&gt; map&lt;S&gt;(<span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert)</span></span>; Stream&lt;R&gt; retype&lt;R&gt;(); <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skipWhile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeWhile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">where</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T event)</span></span></span><span class="hljs-function"> test)</span></span>;</code> </pre> <br><p>  Les méthodes ci-dessus correspondent à des méthodes similaires dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Iterable</a> , qui convertissent l'objet itérable en un autre objet itérable.  Tout cela peut être facilement écrit à l'aide d'une fonction asynchrone avec une boucle <strong>d'attente</strong> . </p><br><pre> <code class="java hljs">Stream&lt;E&gt; asyncExpand&lt;E&gt;(<span class="hljs-function"><span class="hljs-function">Stream&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert)</span></span>; Stream&lt;E&gt; asyncMap&lt;E&gt;(<span class="hljs-function"><span class="hljs-function">FutureOr&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert)</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([bool Function(T previous, T next)</span></span></span><span class="hljs-function"> equals])</span></span>;</code> </pre> <br><p>  Les fonctions <code>asyncExpand()</code> et <code>asyncMap()</code> sont similaires aux fonctions <code>expand()</code> et <code>map()</code> , mais permettent à l'argument de fonction d'être une fonction asynchrone.  <code>distinct()</code> n'existent pas dans Iterable, mais elles peuvent être implémentées. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function onError, {bool test(error)</span></span></span><span class="hljs-function">})</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Duration timeLimit, {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(EventSink&lt;T&gt; sink)</span></span></span><span class="hljs-function"> onTimeout})</span></span>; Stream&lt;S&gt; transform&lt;S&gt;(StreamTransformer&lt;T, S&gt; streamTransformer);</code> </pre> <br><p>  Les trois dernières fonctions sont plus spécifiques.  Il s'agit notamment de la gestion des erreurs que la boucle <strong>d'attente</strong> ne peut pas effectuer, car la toute première erreur termine la boucle et s'abonne au flux.  Il n'y a rien à faire.  Vous pouvez <code>handleError()</code> pour supprimer les erreurs du flux avant de l'utiliser dans la boucle <strong>d'attente</strong> . </p><br><h3 id="funkciya-transform">  Fonction Transform () </h3><br><p>  La fonction transform () n'est pas seulement pour la gestion des erreurs;  c'est une "carte" plus généralisée pour les flux.  Une carte normale nécessite une valeur pour chaque événement entrant.  Cependant, en particulier pour les flux d'E / S, plusieurs événements entrants peuvent être nécessaires pour créer un événement de sortie.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">StreamTransformer</a> peut vous y aider.  Par exemple, les décodeurs comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utf8Decoder</a> sont des transformateurs.  Un transformateur ne nécessite qu'une seule fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bind ()</a> , qui peut être facilement implémentée via une fonction asynchrone. </p><br><pre> <code class="java hljs">Stream&lt;S&gt; mapLogErrors&lt;S, T&gt;( Stream&lt;T&gt; stream, <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert, ) async* </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> streamWithoutErrors = stream.handleError((e) =&gt; log(e)); <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event in streamWithoutErrors)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span></span>; } }</code> </pre> <br><h3 id="chtenie-i-dekodirovanie-fayla">  Lecture et décodage d'un fichier </h3><br><p>  Le code suivant lit le fichier et effectue deux conversions dans le flux.  Tout d'abord, il convertit les données UTF8, puis les transmet via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LineSplitter</a> .  Toutes les lignes sont imprimées, sauf celles commençant par un hashtag ( <code>#</code> ). </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'dart:convert'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'dart:io'</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; args)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> file = File(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lines = file .openRead() .transform(utf8.decoder) .transform(LineSplitter()); <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line in lines)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!line.startsWith(<span class="hljs-string"><span class="hljs-string">'#'</span></span>)) print(line); } }</code> </pre> <br><h2 id="metod-listen">  Méthode Listen () </h2><br><p>  La méthode <code>listen()</code> est une méthode de «bas niveau», toutes les autres fonctions de la fonction sont définies via <code>listen()</code> . </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">StreamSubscription&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(T event)</span></span></span><span class="hljs-function"> onData, </span></span>{Function onError, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> onDone, bool cancelOnError})</span></span>;</code> </pre> <br><p>  Pour créer un nouveau type de flux, vous pouvez simplement hériter de la classe <code>Stream</code> et implémenter la méthode <code>listen()</code> , toutes les autres méthodes <code>Stream</code> appellent <code>listen()</code> pour fonctionner. </p><br><p>  La méthode listen () vous permet de commencer à écouter le flux.  Tant que vous ne le faites pas, le flux est un objet inerte qui décrit les événements que vous souhaitez écouter.  Lors de l'écoute, un objet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">StreamSubscription</a> est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">renvoyé</a> qui représente le flux actif qui génère des événements.  Ceci est similaire à la façon dont <code>Iterable</code> n'est qu'une collection d'objets, et un itérateur est celui qui effectue l'itération réelle. </p><br><p>  Vous pouvez arrêter de vous abonner à un flux, le reprendre après une pause et l'annuler complètement.  Vous pouvez spécifier des rappels qui seront appelés pour chaque événement de données ou événement d'erreur, ainsi que lorsque le flux est fermé. </p><br><hr><br><h2 id="chto-esche-pochitat">  Que lire d'autre? </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dart 2. Programmation asynchrone: futurs</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442274/">https://habr.com/ru/post/fr442274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442264/index.html">Éliminer les opportunités de détournement de trafic</a></li>
<li><a href="../fr442266/index.html">Delta Chat - messager décentralisé au-dessus du courrier électronique</a></li>
<li><a href="../fr442268/index.html">AsyncIO Micropython: méthodes de synchronisation en programmation asynchrone</a></li>
<li><a href="../fr442270/index.html">5 erreurs à éviter lors de la création de modèles 3D pour l'impression 3D</a></li>
<li><a href="../fr442272/index.html">Aller + = versionner le package</a></li>
<li><a href="../fr442278/index.html">Guide de l'utilisateur Kibana. Visualisation. Partie 6</a></li>
<li><a href="../fr442280/index.html">Apprentissage automatique dans Dodo. Comment lancer une nouvelle direction si vous êtes développeur</a></li>
<li><a href="../fr442282/index.html">Dart 2. Programmation asynchrone: futurs</a></li>
<li><a href="../fr442284/index.html">NoVerify: le linter pour PHP de l'équipe VKontakte est maintenant dans le domaine public</a></li>
<li><a href="../fr442286/index.html">Les ophtalmologistes russes ont parlé de la vision bionique. La nouvelle application mobile démontre le travail du cyber</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>