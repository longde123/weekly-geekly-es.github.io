<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘— â—ï¸ ğŸŒ Bagaimana kami mempercepat pekerjaan dengan parameter konfigurasi sistem frontal ğŸ‘‰ğŸ¼ â›³ï¸ ğŸš¶ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Nama saya Sergey Lezhnin, saya seorang arsitek senior di Sbertekh. Salah satu petunjuk pekerjaan saya adalah Unified Frontal System. Siste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami mempercepat pekerjaan dengan parameter konfigurasi sistem frontal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/438144/">  Halo, Habr!  Nama saya Sergey Lezhnin, saya seorang arsitek senior di Sbertekh.  Salah satu petunjuk pekerjaan saya adalah Unified Frontal System.  Sistem ini memiliki layanan manajemen parameter konfigurasi.  Ini digunakan oleh banyak pengguna, layanan dan aplikasi, yang membutuhkan kinerja tinggi.  Dalam posting ini saya akan memberi tahu bagaimana layanan ini berkembang dari yang pertama, paling sederhana, ke versi saat ini dan mengapa kami akhirnya mengerahkan seluruh arsitektur 180 derajat. <br><br><img src="https://habrastorage.org/webt/pk/zu/rp/pkzurprn4lbofwkn2dfrayv34di.jpeg"><br><a name="habracut"></a><br>  Di sinilah kami mulai - ini adalah implementasi pertama dari layanan manajemen parameter: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b3/251/771/9b3251771f856c6f1c7234e042c3a2c3.png"><br><br>  Klien meminta parameter konfigurasi dari layanan.  Layanan menerjemahkan permintaan ke dalam basis data, menerima respons, dan mengembalikannya ke klien.  Pada saat yang sama, administrator dapat mengelola parameter menggunakan layanan terpisah mereka: menambah nilai baru, mengubah yang sekarang. <br><br>  Pendekatan ini memiliki satu keunggulan - kesederhanaan.  Ada lebih banyak kerugian, meskipun semuanya terkait: <br><br><ul><li>  akses yang sering ke penyimpanan melalui jaringan, <br></li><li>  persaingan yang tinggi untuk akses ke database (kami memilikinya terletak di satu simpul), <br></li><li>  kinerja buruk. <br></li></ul><br>  Untuk lulus pengujian beban, arsitektur ini harus menyediakan beban tidak lebih dari yang datang melalui akses langsung ke database.  Akibatnya, pengujian beban sirkuit ini tidak lulus. <br><br>  Tahap kedua: kami memutuskan untuk menyimpan data di sisi layanan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e7c/51d/867/e7c51d8670edf3a14e641c5158c40975.png"><br><br>  Di sini, data pada permintaan awalnya dimuat ke cache bersama dan dikembalikan dari cache pada permintaan berikutnya.  Administrator layanan tidak hanya mengelola data, tetapi juga menandainya dalam cache sehingga ketika mereka berubah, mereka diperbarui. <br><br>  Jadi kami mengurangi jumlah akses ke repositori.  Pada saat yang sama, sinkronisasi data ternyata sederhana, karena layanan administrator memiliki akses ke cache di memori dan mengontrol pengaturan ulang.  Di sisi lain, jika terjadi kegagalan jaringan, klien tidak akan dapat menerima data.  Dan secara umum, logika untuk memperoleh data rumit: jika tidak ada data dalam cache, Anda perlu mendapatkannya dari database, masukkan ke dalam cache dan baru kemudian kembalikan.  Perlu dikembangkan lebih lanjut. <br><br>  Tahap ketiga pengembangan adalah caching data sisi klien: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc7/c76/873/cc7c76873ed1f3ea9524e244f04f4e1e.png"><br><br>  Klien memiliki shell untuk mengakses layanan ("modul klien"), yang menyembunyikan cache data lokal.  Jika data yang diminta tidak ada dalam cache saat meminta, layanan akan dipanggil.  Layanan meminta parameter dari database dan mengembalikannya.  Dibandingkan dengan skema sebelumnya, manajemen caching rumit di sini.  Untuk mengatur ulang parameter, layanan harus memberi tahu pelanggan bahwa parameter ini telah berubah. <br><br>  Dalam arsitektur ini, kami mengurangi jumlah panggilan ke layanan dan ke database.  Sekarang, jika parameter sudah diminta, itu akan kembali ke klien tanpa mengakses jaringan, bahkan jika layanan atau database tidak tersedia.  Di sisi lain, minus utama adalah bahwa logika bertukar data dengan klien itu rumit, Anda juga harus memberi tahu dia melalui beberapa layanan - misalnya, antrian pesan.  Klien harus berlangganan ke topik, ia menerima pemberitahuan tentang perubahan parameter, dan dalam cache-nya klien harus mengatur ulang untuk mendapatkan nilai baru.  Skema yang cukup rumit. <br><br>  Akhirnya, kita sampai pada tahap terakhir saat ini.  Dalam hal ini kami dibantu oleh prinsip-prinsip dasar yang dirumuskan dalam Manifesto Reaktif. <br><br><ul><li>  Responsif: Sistem merespons secepat mungkin. <br></li><li>  Tangguh: sistem terus merespons bahkan jika terjadi kegagalan. <br></li><li>  Elastis: sistem menggunakan sumber daya sesuai dengan beban. <br></li><li>  Message Driven: menyediakan sinkronisasi dan pengiriman pesan gratis antar komponen sistem. <br></li></ul><br>  Skema yang sesuai dengan pendekatan ini ternyata cukup sederhana: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1e/302/480/f1e3024800a86896bd690104311ad134.png"><br><br>  Prinsip umum adalah ini: klien berlangganan ke parameter konfigurasi, dan ketika nilainya berubah, server memberi tahu klien tentang hal ini.  Skema di atas sedikit disederhanakan: itu tidak mencerminkan bahwa ketika klien mendaftar, ia perlu menginisialisasi dan mendapatkan nilai awal.  Tapi kemudian ada hal utama di dalamnya: panah berubah arah.  Sebelumnya, klien atau cache secara aktif meminta layanan untuk perubahan data, tetapi sekarang layanan itu sendiri mengirimkan peristiwa tentang perubahan data, dan mereka diperbarui oleh klien. <br><br>  Arsitektur ini memiliki beberapa keunggulan penting.  Jumlah panggilan ke layanan dan penyimpanan berkurang, karena klien tidak secara aktif memintanya.  Bahkan, banding untuk setiap parameter yang diinginkan hanya terjadi satu kali, ketika berlangganan.  Maka klien sudah cukup menerima aliran perubahan.  Ketersediaan data meningkat karena klien selalu memiliki nilai - itu di-cache.  Dan secara umum, skema pertukaran parameter ini cukup sederhana. <br><br>  Satu-satunya kelemahan dari arsitektur ini adalah ketidakpastian dalam inisialisasi data.  Sampai pembaruan pertama dengan berlangganan, nilai parameter tetap tidak terdefinisi.  Tetapi ini dapat diatasi dengan mengatur nilai parameter default klien, yang diganti dengan yang sebenarnya selama pembaruan pertama. <br><br><h2>  Pemilihan teknologi </h2><br>  Setelah menyetujui skema tersebut, kami mulai mencari produk untuk implementasinya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pilih</a> antara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vertx.io</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akka.io</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring Boot</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f62/9fe/d44/f629fed442892d5b43a6466e73e4c288.png"><br><br>  Tabel tersebut merangkum karakteristik yang menarik bagi kami.  Vertx dan Akka memiliki aktor, dan Sping Boot memiliki perpustakaan layanan mikro yang pada dasarnya dekat dengan para aktor.  Demikian pula dengan reaktivitas: Spring Boot memiliki perpustakaan WebFlux sendiri yang mengimplementasikan fitur yang sama.  Kami memperkirakan tingkat pencahayaan di dalam tabel.  Adapun bahasa, dari tiga opsi, Vertx dianggap polyglot: mendukung Java, Scala, Kotlin, dan JavaScript.  Akka memiliki Scala dan Jawa;  Kotlin mungkin juga bisa digunakan, tetapi tidak ada dukungan langsung.  Musim semi memiliki Jawa, Kotlin, dan Groovy. <br><br>  Hasilnya, Vertx menang.  Ngomong-ngomong, mereka banyak berbicara tentang dia di konferensi JUG, dan memang banyak perusahaan yang menggunakannya.  Ini adalah screenshot dari situs pengembang: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfd/5e1/927/cfd5e19271c2d28809e43208b4566237.png"><br><br>  Di Vertx.io, skema implementasi solusi kami adalah sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f63/ab8/99f/f63ab899fb017bf113925eedce617632.png"><br><br>  Kami memutuskan untuk menyimpan parameter tidak dalam database, tetapi dalam repositori Git.  Kami dapat menggunakan sumber data yang relatif lambat ini dengan baik karena fakta bahwa klien tidak secara aktif meminta parameter dan jumlah klik berkurang. <br><br>  Pembaca (verticle) membaca data dari repositori Git ke dalam memori aplikasi untuk mempercepat akses pengguna ke data.  Ini penting, misalnya, ketika berlangganan parameter.  Selain itu, pembaca memproses pembaruan - membaca kembali dan menandai data, menggantikan data lama dengan yang baru. <br><br>  Event Bus adalah layanan Vertx yang mengirimkan acara antara vertikal maupun keluar melalui jembatan.  Termasuk melalui jembatan websocket, yang digunakan dalam hal ini.  Ketika acara perubahan parameter tiba, Bus Acara mengirimkannya ke klien. <br><br>  Akhirnya, di sisi klien, klien web sederhana diimplementasikan di sini, yang berlangganan acara (perubahan parameter) dan menampilkan perubahan ini di halaman. <br><br><h2>  Bagaimana cara kerjanya </h2><br>  Kami menunjukkan bagaimana semuanya bekerja melalui aplikasi web. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VaBtM07AN9Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Kami meluncurkan halaman aplikasi di browser.  Kami berlangganan perubahan data utama.  Lalu kita pergi ke halaman proyek dalam GitLab lokal, ubah data dalam format JSON dan simpan ke repositori.  Aplikasi menampilkan perubahan yang sesuai, yang kami butuhkan. <br><br>  Itu saja.  Anda dapat menemukan kode sumber demo di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori git</a> saya, dan bertanya di komentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438144/">https://habr.com/ru/post/id438144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438132/index.html">GOSINT - solusi sumber terbuka untuk mengelola indikator kompromi (IoC)</a></li>
<li><a href="../id438134/index.html">Instalasi sistem CCTV: cerita indah dan malang dengan kamera</a></li>
<li><a href="../id438136/index.html">Persetujuan untuk pemrosesan data GDPR: analisis terperinci</a></li>
<li><a href="../id438138/index.html">Anatomi falcon</a></li>
<li><a href="../id438142/index.html">Industri otomotif modern. Mobil listrik - gangguan</a></li>
<li><a href="../id438146/index.html">Kami menempatkan garis dalam parameter template</a></li>
<li><a href="../id438148/index.html">Google Must Split</a></li>
<li><a href="../id438150/index.html">Cara membuat batch sepatu unik di Cina</a></li>
<li><a href="../id438152/index.html">"Saya dapat memberi tahu Anda tentang rasa sakit yang dimiliki setiap pengembang iOS di pantat" - 10 pertanyaan kepada pengembang, episode 2</a></li>
<li><a href="../id438158/index.html">Pialang data AS menjual data lokasi tanpa persetujuan pengguna - pekerjaan mereka akan diatur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>