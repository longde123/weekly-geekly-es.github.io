<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛄️ 👩🏼‍💼 👩🏿‍🔬 Travailler avec IPv6 en PHP 🛐 🤸🏻 🥧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons récemment reçu le statut LIR et le bloc / 29 IPv6. Et puis il y avait un besoin de garder une trace des sous-réseaux désignés. Et comme not...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Travailler avec IPv6 en PHP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/484586/">  Nous avons récemment reçu le statut LIR et le bloc / 29 IPv6.  Et puis il y avait un besoin de garder une trace des sous-réseaux désignés.  Et comme notre facturation était écrite en PHP, j'ai dû m'inspirer un peu du problème et me rendre compte que ce langage n'est pas le plus convivial en termes de travail avec IPv6.  Under the cut - notre solution aux problèmes de travail avec les adresses et les plages.  Peut-être pas le plus élégant, mais il accomplit les tâches. <br><br><img src="https://habrastorage.org/webt/bk/on/p9/bkonp9-y-sxfdqvirte2ehjunr0.jpeg"><a name="habracut"></a><br><br><h3>  Un peu de théorie </h3><br><blockquote>  <b>Clause de non-responsabilité.</b>  Si vous êtes familier avec IPv6 et avec quoi il est consommé, cette partie peut être ennuyeuse pour vous.  Ce n'est peut-être pas le cas. </blockquote><br>  Les personnes qui voient d'abord l'annotation IPv6 pourraient bien être découragées.  Après l'élégant <i>64.233.177.101,</i> nous rencontrons soudain <i>2607: f8b0: 4002: c08 :: 8b</i> et pouvons devenir confus.  À la fois cela et un autre - seule représentation lisible par l'homme de 32 et 128 bits respectivement.  Tout paquet IP contient un en-tête avec une affectation strictement standardisée de chaque bit.  Sans aller encore plus loin dans la structure des en-têtes, nous devons tirer une chose d'ici: pour les opérations avec des adresses IP et des plages, il est généralement pratique d'utiliser les mathématiques binaires et les opérations au niveau du bit.  Il est également plus pratique de les stocker dans la base de données en tant que <i>BINARY (4)</i> pour IPv4 et <i>BINARY (16)</i> pour IPv6. <br><br>  Un autre aspect important qui devrait être abordé est les masques de réseau et la notation CIDR.  CIDR est un acronyme pour Classless Inter-Domain Routing.  Ce concept a remplacé celui de classe 1 pour déterminer quelle partie de l'adresse IP est le préfixe du réseau et quelle partie est l'adresse de l'interface réseau au sein de ce réseau.  En pratique, les n premiers bits correspondant au préfixe seront mis à 1, le reste à 0. <br><br>  Sous une forme lisible par l'homme, ceci est écrit comme <i>ip.add.re.ss. / cidr</i> .  Par exemple, <i>64.233.177.0/24</i> signifie que les 24 premiers bits font référence au préfixe.  Les 8 derniers bits, ils sont le dernier numéro d'une entrée lisible par l'homme, se réfèrent à l'adresse à l'intérieur du sous-réseau.  Encore quelques exercices.  <i>64.233.177.101/32</i> et <i>2607: f8b0: 4002: c08 :: 8b / 128</i> - une adresse spécifique.  <i>2607: f8b0: 4002: c08 :: / 64</i> - les 64 premiers bits (les 4 premiers groupes) - le préfixe, les 64 bits restants - la partie locale.  Soit dit en passant, si quelqu'un est gêné par le "::" dans l'entrée, le double signe deux points remplace un nombre arbitraire de sections contenant 0. Il ne peut apparaître dans l'annotation qu'une seule fois.  En d'autres termes, <i>2607: f8b0: 4002: c08 :: 8b = 2607: f8b0: 4002: c08: 0: 0: 0: 8b</i> . <br><br>  Que devons-nous apprendre de tout cela?  Tout d'abord, les première et dernière adresses de sous-réseau peuvent être obtenues en utilisant les ET binaires ET et OU, connaissant le masque sous forme binaire.  Deuxièmement, le sous-réseau suivant de taille (c'est-à-dire avec CIDR) <b>n</b> peut être calculé en ajoutant 1 à la nième position en représentation binaire.  Par vue binaire, j'entends le résultat de l'utilisation des fonctions <i>pack ()</i> et <i>inet_pton ()</i> et l'utilisation ultérieure d' <a href="https://www.php.net/manual/ru/language.operators.bitwise.php">opérateurs au niveau</a> du <a href="https://www.php.net/manual/ru/language.operators.bitwise.php">bit</a> , par binaire - une représentation dans le système binaire, qui peut être obtenue, par exemple, en utilisant <i>base_convert ()</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Contexte historique</b> <div class="spoiler_text"> Séparation sans classe <s>de l'</s> adressage précédée sans classe.  Dans ces années lointaines, personne ne s'attendait à ce qu'il y ait autant de sous-réseaux; ils étaient répartis à droite et à gauche en grands blocs: classe A - les 8 premiers bits (c'est-à-dire le premier nombre) étaient préfixés, avec le bit de tête 0;  classe B - les 16 premiers (deux premiers chiffres), les bits de tête de 10;  classe C - les 24 premiers bits, les bits de tête de 110. Ces mêmes bits de tête définissent les plages dans lesquelles l'adresse d'une classe a été émise: <i>0.0.0.0 - 127.255.255.255</i> pour la classe A, <i>128.0.0.0 - 191.255.255.255</i> - classe B, 192.0 .0.0 - 223.255.255.255 - classe C. Au fur et à mesure que l'Internet se répandait sur la planète, les régulateurs ont réalisé qu'ils avaient raté et, au début des années 90, ont développé un concept sans classe, qui leur a permis de ne pas s'attacher aux bits principaux.  Un peu plus de détails peuvent être trouvés, disons, dans le <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B5%25D1%2581%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">grand et omniscient</a> . </div></div><br><br><h3>  Passons à la pratique </h3><br>  En pratique, nous mettons en œuvre les trois tâches les plus probables, comme il me semble,: <br><br><ol><li>  obtenir la première et la dernière adresse de la plage; </li><li>  obtenir la plage suivante d'une taille donnée (CIDR); </li><li>  vérifier que l'adresse appartient à une plage. </li></ol><br>  L'implémentation sera pour IPv6, mais si nécessaire, la logique peut être facilement adaptée.  J'ai eu quelques idées d' <a href="https://intsystem.org/coding/kak-rabotat-s-ipv6-v-php/">ici</a> , mais mises en œuvre un peu différemment.  Dans les exemples également, il n'y a pas de vérification des erreurs de saisie.  Alors allons-y. <br><br>  Comme je l'ai déjà mentionné, la première et la dernière adresse d'une plage peuvent être déterminées à l'aide d'opérations au niveau du bit, connaissant le début de la plage et le masque de sous-réseau binaire.  En conséquence, la première chose que nous devons faire est de transformer le CIDR en masque binaire.  Pour ce faire, collectez sa représentation hexadécimale et empaquetez-la en binaire. <br><br><pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cidrToMask</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($cidr)</span></span></span><span class="hljs-function"> </span></span>{ $mask = str_repeat(<span class="hljs-string"><span class="hljs-string">'f'</span></span>, ceil($cidr / <span class="hljs-number"><span class="hljs-number">4</span></span>)); $mask .= dechex(<span class="hljs-number"><span class="hljs-number">4</span></span> * ($cidr % <span class="hljs-number"><span class="hljs-number">4</span></span>)); $mask = str_pad($mask, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, $mask); }</code> </pre> <br>  Le <i>pack d'</i> appels <i>('H *', $ mask)</i> emballe la représentation hexadécimale de la même manière que <i>inet_pton ()</i> .  La seule différence est que lorsque vous appelez <i>pack (),</i> tous les 0 doivent être en place et il ne doit pas y avoir de deux-points dans l'entrée, contrairement à l'entrée lisible par l'homme. <br><br>  L'étape suivante consiste à calculer le début et la fin de la plage.  Et ici, il y a des nuances.  Les opérations au niveau du bit sont limitées par la capacité du processeur.  Par conséquent, sur mon CubieTruck 32 bits, que j'utilise parfois pour tous les tests, tous les 128 bits de l'adresse ne peuvent pas être traités en une seule opération.  Cependant, rien ne nous empêche de le diviser en groupes de 32 bits (juste au cas où, qui sait sur quels processeurs nous allons tourner). <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRangeBoundary</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ip, $cidr, $which, $ipIsBin = false, $returnBin = false)</span></span></span><span class="hljs-function"> </span></span>{ $mask = cidrToMask($cidr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$ipIsBin) { $ip = inet_pton($ip); } $ipParts = str_split($ip, <span class="hljs-number"><span class="hljs-number">4</span></span>); $maskParts = str_split($mask, <span class="hljs-number"><span class="hljs-number">4</span></span>); $rangeParts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; count($ipParts); $i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($which == <span class="hljs-string"><span class="hljs-string">'start'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  &amp;       . */</span></span> $rangeParts[$i] = $ipParts[$i] &amp; $maskParts[$i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*  |    (~)           1. */</span></span> $rangeParts[$i] = $ipParts[$i] | ~$maskParts[$i]; } } $rangeBoundary = implode($rangeParts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($returnBin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $rangeBoundary; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inet_ntop($rangeBoundary); } }</code> </pre> <br>  Pour une utilisation future, nous fournirons la capacité de transmettre IP et d'obtenir le résultat à la fois sous forme binaire et lisible par l'homme.  Le paramètre <i>$ which</i> définit ici si nous voulons obtenir le début ou la fin de la plage (les valeurs sont <i>'start'</i> ou <i>'end',</i> respectivement). <br><br>  La tâche suivante (en plus de la plus pratique pour notre entreprise) est de calculer la plage suivante.  Pour cette tâche, rien de mieux n'est venu à l'esprit, sauf comment décomposer l'adresse en une chaîne binaire et ajouter 1 à la position souhaitée, puis tout replier.  Pour éviter que des artefacts n'apparaissent n'importe où, j'ai décidé de diviser l'adresse par octet pendant la décomposition et l'assemblage. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNextBlock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ipStart, $cidr, $ipIsBin = false, $returnBin = false)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$ipIsBin) { $ipStart = inet_pton($ipStart); } $ipParts = str_split($ipStart, <span class="hljs-number"><span class="hljs-number">1</span></span>); $ipBin = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ipParts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $ipPart) { $ipBin .= str_pad(base_convert(unpack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, $ipPart)[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, STR_PAD_LEFT); } <span class="hljs-comment"><span class="hljs-comment">/*  1       "" :) */</span></span> $i = $cidr - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($ipBin[$i] == <span class="hljs-string"><span class="hljs-string">'0'</span></span>) { $ipBin[$i] = <span class="hljs-string"><span class="hljs-string">'1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $ipBin[$i] = <span class="hljs-string"><span class="hljs-string">'0'</span></span>; } $i--; } $ipBinParts = str_split($ipBin, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ipBinParts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $ipBinPart) { $ipParts[$key] = pack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, str_pad(base_convert($ipBinPart, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, STR_PAD_LEFT)); } $nextIp = implode($ipParts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($returnBin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $nextIp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inet_ntop($nextIp); } }</code> </pre> <br>  En sortie, nous obtenons le préfixe de la prochaine plage de taille spécifiée dans <i>$ cidr</i> .  Avec cette fonction, nous attribuons des blocs d'adresses à nos clients. <br><br>  Enfin, vérifiez si l'adresse appartient à la plage.  Par exemple, nous avons alloué un bloc / 48 pour la distribution de / 64 blocs aux clients, et nous devons nous assurer que lors du rendez-vous, nous n'allons pas au-delà du bloc alloué (en pratique, cela se produira bientôt, mais il y a encore une chance).  Ici, tout est simple.  Nous obtenons le début et la fin de la plage sous forme binaire et vérifions si l'adresse est à l'intérieur. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ipInRange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ip, $rangeStart, $cidr)</span></span></span><span class="hljs-function"> </span></span>{ $start = getRangeBoundary($rangeStart, $cidr, <span class="hljs-string"><span class="hljs-string">'start'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $end = getRangeBoundary($rangeStart, $cidr, <span class="hljs-string"><span class="hljs-string">'end'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $ipBin = inet_pton($ip); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ($ipBin &gt;= $start &amp;&amp; $ipBin &lt;= $end); }</code> </pre> <br>  J'espère que cela a été utile.  Quelles autres fonctionnalités d'adressage pourriez-vous trouver utiles?  Tous les ajouts, commentaires et revues de code sont les bienvenus dans les commentaires. <br><br>  Si vous êtes déjà notre client ou envisagez d'en devenir un, à l'occasion de la parution de cet article, nous vous proposons d'obtenir gratuitement le bloc / 64 pour tous les services vps ou un serveur dédié dans le centre de données Equinix Tier IV, Pays-Bas, sur demande auprès du service commercial, en fournissant un lien vers cet article dans le ticket.  L'offre est valable jusqu'en mars 2020. <br><br><h3>  Un peu de publicité :) </h3><br>  Merci de rester avec nous.  Aimez-vous nos articles?  Vous voulez voir des matériaux plus intéressants?  Soutenez-nous en passant une commande ou en recommandant à vos amis <a href="https://ua-hosting.company/cloudvps/nl">des VPS basés sur le cloud pour les développeurs à partir de 4,99 $</a> , un <b>analogue unique de serveurs d'entrée de gamme que nous avons inventés pour vous:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">Toute la vérité sur les VPS (KVM) E5-2697 v3 (6 cœurs) 10 Go DDR4 480 Go SSD 1 Gbit / s à partir de 19 $ ou comment diviser le serveur?</a>  (les options sont disponibles avec RAID1 et RAID10, jusqu'à 24 cœurs et jusqu'à 40 Go de DDR4). <br><br>  <b>Dell R730xd 2 fois moins cher au centre de données Equinix Tier IV à Amsterdam?</b>  Nous avons seulement <b><a href="https://ua-hosting.company/serversnl">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV à partir de 199 $</a> aux Pays-Bas!</b>  <b><b>Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - à partir de 99 $!</b></b>  Pour en savoir plus sur la <a href="https://habr.com/company/ua-hosting/blog/329618/">création d'un bâtiment d'infrastructure.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">classe utilisant des serveurs Dell R730xd E5-2650 v4 coûtant 9 000 euros pour un sou?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484586/">https://habr.com/ru/post/fr484586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484574/index.html">Pas de tiques! Plantes vs vecteur de la maladie de Lyme</a></li>
<li><a href="../fr484578/index.html">Objectifs de niveau de service - Expérience Google (traduction de la section Google SRE Book)</a></li>
<li><a href="../fr484580/index.html">Ce que vous devez savoir sur les simulateurs de mémoire</a></li>
<li><a href="../fr484582/index.html">ASP.NET MVC - Entity Framework, MySQL et utilisation de Dependency Resolver pour sélectionner un référentiel</a></li>
<li><a href="../fr484584/index.html">Pourquoi avons-nous besoin d'un gestionnaire dans un projet informatique et que se passera-t-il lorsqu'il ne l'est pas</a></li>
<li><a href="../fr484588/index.html">Modèle de gestion de programme automatisé</a></li>
<li><a href="../fr484590/index.html">Pour que les garçons n'aient pas honte de montrer</a></li>
<li><a href="../fr484592/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 398 (13-19 janvier 2020)</a></li>
<li><a href="../fr484596/index.html">Boutique en ligne côté client Blazor: Partie 1 - Autorisation oidc (oauth2) + Identity Server4</a></li>
<li><a href="../fr484600/index.html">Microsoft Ignite The Tour Prague Conférence technique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>