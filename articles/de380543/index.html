<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚸 👨‍👩‍👧‍👦 🐿️ Smartcards. Teil 4. JavaCard ⛷️ 👩🏻‍💻 🦎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Giktayms! 
 
 Heute möchte ich über JavaCard sprechen. Dieser Artikel konzentriert sich auf das Konzept der JavaCard und einen Überblick über de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Smartcards. Teil 4. JavaCard</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/380543/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Giktayms! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute möchte ich über JavaCard sprechen. Dieser Artikel konzentriert sich auf das Konzept der JavaCard und einen Überblick über deren Architektur. Wenn Interesse an diesem Thema besteht, könnte ich eine separate Artikelserie schreiben, in der alle Aspekte von JavaCard ausführlich behandelt werden. Ich werde sofort sagen, dass ich Ihnen nicht beibringen werde, wie Sie Ihre erste Anwendung in JavaCard schreiben, weil Es gibt bereits zu viele Artikel im Internet darüber. Heute werden wir hauptsächlich darüber sprechen, wie JavaCard funktioniert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine JavaCard-basierte Smartcard ist also eine Karte, auf der Anwendungen auf der JavaCard Virtual Machine (einer eingeschränkten Version der für Smartcards angepassten Java Virtual Machine) in der sogenannten JavaCard Runtime Environment (die mit der Java Runtime Environment sehr wenig gemein hat) ausgeführt werden. .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf die Terminologie werden Anwendungen Applets genannt und sind in Paketen enthalten. Pakete werden in CAP-Dateien verteilt (anstelle von Jar-Dateien). Pakete und Anwendungen haben eine eigene AID (Application Identifier). Dies ist erforderlich, damit sie in Befehlen wie SELECT, INSTALL, DELETE usw. eindeutig identifiziert werden können. (SELECT wird in ISO7816-4 beschrieben, und JavaCard und andere Befehle werden in der globalen Plattform beschrieben.)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Lebenszyklus von Applets unterscheidet sich geringfügig vom üblichen Lebenszyklus von Computeranwendungen. </font><font style="vertical-align: inherit;">Ein Applet ist eine beliebige Klasse, die von der Applet-Basisklasse erbt. </font><font style="vertical-align: inherit;">Bei der Installation von Anwendungen wird die statische Installationsmethode aufgerufen. </font><font style="vertical-align: inherit;">Diese Methode sollte ein Objekt der entsprechenden Klasse erstellen und die Registermethode darauf aufrufen. </font><font style="vertical-align: inherit;">Anschließend wird das Objekt im System gespeichert und erhält eine eigene AID, die für die weitere Kommunikation mit der Anwendung verwendet wird. </font><font style="vertical-align: inherit;">Das Objekt und seine Datenfelder werden im NVM (Non-Volatile Memory) gespeichert. </font><font style="vertical-align: inherit;">Jedes Objekt oder Array, das von der Anwendung mit dem Operator "Neu" erstellt wurde, befindet sich ebenfalls in NVM. </font><font style="vertical-align: inherit;">Dies bedeutet, dass im Gegensatz zu herkömmlichen Computerprogrammen der Status von JavaCard-Anwendungen konstant ist und auch beim Ausschalten der Karte nicht verloren geht.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kommunikation mit der Anwendung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder offene logische Kanal hat zu jeder Zeit eine aktive Anwendung. </font><font style="vertical-align: inherit;">Eine aktive Anwendung empfängt alle vom Terminal gesendeten APDUs. </font><font style="vertical-align: inherit;">Wenn eine APDU empfangen wird, ruft die JavaCard die Prozessmethode der aktiven Anwendung auf, die die empfangene APDU als einzigen Parameter verwendet. </font><font style="vertical-align: inherit;">Diese Methode ist der Kern des Applets, da sie Anforderungen vom Terminal verarbeitet. </font><font style="vertical-align: inherit;">Die resultierende APDU wird auch zum Senden von Antworten verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Applet kann auf zwei Arten aktiviert werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Zurücksetzen der Karte oder beim Öffnen eines logischen Kanals aktiviert das System normalerweise die Anwendung, die als Standardanwendung markiert ist</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden des Befehls SELECT mit P1 = 0x04 und der AID (vollständig oder teilweise) der Anwendung in Data</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Anwendung mit dem Befehl SELECT aktiviert wird, wird unmittelbar nach der Aktivierung die Prozessmethode mit der APDU aufgerufen, die diesen Befehl enthält. Somit kann das Applet bei Aktivierung Informationen als Antwort auf einen SELECT-Befehl senden. Die Applet-Klasse stellt die Methode selectedApplet () bereit, um festzustellen, ob der empfangene Befehl die Aktivierung der Anwendung verursacht hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anwendung hat auch die Möglichkeit, die Methoden select () und deselect () neu zu schreiben, um sie während der Aktivierung zu initialisieren bzw. während der Deaktivierung zu de-initialisieren. Diese Methoden werden unabhängig davon aufgerufen, wie die Anwendung aktiviert wurde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Logische Kanäle können mit dem Befehl MANAGE CHANNEL geöffnet und geschlossen werden. </font><font style="vertical-align: inherit;">Über offene logische Kanäle können Sie beliebige Befehle senden, einschließlich SELECT. </font><font style="vertical-align: inherit;">Es sind SELECT und MANAGE CHANNEL, die die einzigen Befehle sind, die direkt vom System und nicht von der aktiven Anwendung verarbeitet werden. </font><font style="vertical-align: inherit;">Obwohl im Fall des Befehls SELECT gesagt werden kann, dass er sowohl vom System als auch von der aktiven Anwendung verarbeitet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die vollständigen Regeln zum Aufrufen der Anwendung und zum Verarbeiten des Befehls SELECT sind recht komplex und es gibt kaum Widersprüche zwischen der JavaCard und der globalen Plattform. </font><font style="vertical-align: inherit;">Ich werde dieses Thema jedoch in einem meiner nächsten Artikel behandeln. </font><font style="vertical-align: inherit;">Nun ist es erwähnenswert, dass Karten häufig den in der globalen Plattform beschriebenen Regeln folgen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherverwaltung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie oben erwähnt, werden Objekte und Arrays standardmäßig in NVM gespeichert. </font><font style="vertical-align: inherit;">Neben NVM ermöglicht JavaCard auch das Erstellen von Arrays im RAM mit einer Reihe von Methoden aus der JCSystem-Klasse. </font><font style="vertical-align: inherit;">Es gibt zwei Arten von temporärem Speicher: Löschen beim Zurücksetzen und Löschen beim Abwählen. </font><font style="vertical-align: inherit;">Die erste wird gelöscht, wenn die Karte ausgeschaltet oder zurückgesetzt wird. </font><font style="vertical-align: inherit;">Die zweite wird gelöscht, wenn das Applet nicht mehr aktiv ist (d. H. Wenn Sie eine andere Anwendung auswählen, herunterfahren, zurücksetzen usw.). </font><font style="vertical-align: inherit;">Es sollte beachtet werden, dass, obwohl der Inhalt des Arrays gelöscht wird (d. H. Alle Nullen oder Falschen werden dort geschrieben), das Array selbst verbleibt und es beispielsweise im Objektdatenfeld gespeichert werden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was wird in NVM gespeichert:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Objekte und ihre Datenfelder.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Arrays.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Inhalt der vom neuen Operator erstellten Arrays.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist im RAM gespeichert (CLEAR_ON_RESET oder CLEAR_ON_DESELECT):</font></font><br>
<ul>
<li> ,   JCSystem.makeTransient&lt;&gt;Array.  ,  ,   ,   JCSystem.makeTransientObjectArray(),      NVM.       RAM.</li>
<li>Global Arrays:  (APDU   Install Parameters ),   Global Arrays,    JCSystem.makeGlobalArray().</li>
<li>  .       .</li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Anwendung sollte in der Regel alle Objekte und Arrays erstellen, die sie während der Installation benötigt, und nicht dynamisch. Der Grund dafür sind hauptsächlich zwei Faktoren: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) Der Wunsch, sicherzustellen, dass die Anwendung nach erfolgreicher Installation nicht nicht mehr funktioniert, wenn eine andere Anwendung den gesamten freien Speicher belegt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) Garbage Collector - eine optionale (wenn auch sehr häufige) Funktion. Dies bedeutet, dass beim dynamischen Erstellen von Objekten das Risiko besteht, dass die erstellten Objekte niemals gelöscht werden. Dies wird im Laufe der Zeit zu einem Mangel an freiem Speicher führen. Selbst wenn es einen Garbage Collector gibt, erfolgt diese Prozedur nicht automatisch, sondern auf Anforderung der Anwendung (JCSystem.requestObjectDeletion ()).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Folge wird Anwendungscode in Bezug auf die objektorientierte Programmierung selten „sauber“ erhalten. </font><font style="vertical-align: inherit;">Die Verwendung von Common Byte [] für viele verschiedene Operationen ist eine sehr verbreitete Praxis. </font><font style="vertical-align: inherit;">Klassen, die ausschließlich aus statischen Methoden bestehen und auf Byte [] ausgeführt werden, sind ebenfalls keine Seltenheit. </font><font style="vertical-align: inherit;">Außerdem wird die Erstellung von Klassen und Objekten minimiert. </font><font style="vertical-align: inherit;">Wenig Speicher und es muss um jeden Preis geschützt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist auch erwähnenswert, welche Rolle das APDU-Objekt spielt. </font><font style="vertical-align: inherit;">Der im RAM befindliche Puffer wird vor dem Empfang jedes Befehls gelöscht. </font><font style="vertical-align: inherit;">Es ist üblich, es nicht nur als Antwort zu verwenden, sondern oft sogar als temporären Puffer. </font><font style="vertical-align: inherit;">Die Größe beträgt mindestens 256 Byte oder viel mehr, wenn die Karte Extended Length unterstützt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Applet-Firewall</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein wichtiges Merkmal von JavaCard, das Programmierer verwirren kann, ist das Vorhandensein der sogenannten Applet-Firewall. </font><font style="vertical-align: inherit;">Das Ziel der Firewall ist es, zu verhindern, dass ein Applet auf die Daten eines anderen zugreifen kann. </font><font style="vertical-align: inherit;">Ich muss sofort sagen, dass JavaCard die Kommunikation zwischen Anwendungen über gemeinsam nutzbare Schnittstellen ermöglicht und dass Pakete Bibliotheken von Klassen und Funktionen sind, die in verschiedenen Anwendungen verwendet werden können. </font><font style="vertical-align: inherit;">Aus diesem Grund ist eine Firewall erforderlich. </font><font style="vertical-align: inherit;">Die Grundprinzipien der Applet-Firewall lauten wie folgt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Anwendung gehört zu einem Kontext. </font><font style="vertical-align: inherit;">Alle Anwendungen aus demselben Paket gehören zum selben Kontext.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Objekt gehört zu einer Anwendung oder einem System.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Paket ohne Anwendungen (Bibliothek) hat keinen Kontext. </font><font style="vertical-align: inherit;">Objekte aus seinen Klassen gehören zu der Anwendung, die sie erstellt hat.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt immer einen aktiven Kontext im System.</font></font></li>
<li> (/         )    ,   .</li>
<li>     .</li>
<li>         .       .  ,     ,    firewall.</li>
<li>    CLEAR_ON_DESELECT   ,       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Über die gemeinsam nutzbare Schnittstelle kann ein Programmierer zulassen, dass bestimmte Methoden eines Objekts für Anwendungen aus einem anderen Kontext verfügbar sind. Wenn eine dieser Methoden aufgerufen wird, wechselt das System den Kontext zu dem Kontext, zu dem das Objekt gehört, das die gemeinsam nutzbare Schnittstelle bereitstellt. Dies bedeutet, dass diese Methode nur auf Objekte zugreifen kann, die zu ihrem Kontext gehören. Wenn Sie beispielsweise dieses Methodenbyte [] als Parameter aus dem ursprünglichen Kontext übergeben, tritt beim Zugriff ein Fehler auf. Nach Abschluss der Methodenausführung wechselt der Kontext zurück zum ursprünglichen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anwendung hat auch Zugriff auf bestimmte Objekte, die zum System gehören. </font><font style="vertical-align: inherit;">Solche Objekte werden als Einstiegspunkte bezeichnet. </font><font style="vertical-align: inherit;">Es gibt zwei Arten von Einstiegspunkten: temporär und permanent. </font><font style="vertical-align: inherit;">Permanente Einstiegspunkte sind einfach, der Zugriff auf sie ist aus jedem Kontext möglich. </font><font style="vertical-align: inherit;">Ein Beispiel hierfür sind Objekte aus der AID-Klasse. </font><font style="vertical-align: inherit;">Temporäre Einstiegspunkte haben andererseits eine Einschränkung, die verhindert, dass sie in den Datenfeldern des Objekts oder in den statischen Feldern der Klasse gespeichert werden. </font><font style="vertical-align: inherit;">Ein Beispiel für einen temporären Einstiegspunkt ist ein APDU-Objekt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ab JavaCard 3.0.4 können auch globale Arrays mit der Methode JCSystem.makeGlobalArray () erstellt werden. </font><font style="vertical-align: inherit;">Ihr Verhalten entspricht genau dem von temporären Einstiegspunkten. </font><font style="vertical-align: inherit;">Sie werden hauptsächlich als Parameter für Methoden benötigt, die mit der Shareable Interface-Technik aufgerufen werden.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomarität und Transaktionen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaCard garantiert atomare Operationen beim Ändern von Datenfeldern von Objekten oder Klassen. Die Atomizität wird auch durch Methoden bereitgestellt, die an Arrays arbeiten (mit Ausnahme derjenigen, deren Name das Suffix NonAtomic enthält). Dies bedeutet, dass beispielsweise Util.arrayCopy entweder alle Bytes kopiert (falls erfolgreich) oder das Array im Falle eines Fehlers oder Energieverlusts unverändert lässt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie mehrere konstante Felder und Arrays in einer atomaren Operation ändern müssen, bietet JavaCard auch die Funktion JCSystem.beginTransaction () zum Starten der Transaktion und JCSystem.commitTransaction () zum Abschließen. </font><font style="vertical-align: inherit;">Alle Änderungen, die in Arrays und konstanten Feldern zwischen Aufrufen von JCSystem.beginTransaction () und JCSystem.commitTransaction () auftreten, werden automatisch Teil der Transaktion. </font><font style="vertical-align: inherit;">Wenn die Transaktion aufgrund eines Fehlers, eines Energieverlusts oder eines Aufrufs der JCSystem.abortTransaction () -Methode abgebrochen wird, stellt das System den ursprünglichen Zustand wieder her. </font><font style="vertical-align: inherit;">Es sei daran erinnert, dass die technische Implementierung der Transaktion einen zusätzlichen Systempuffer verwendet. </font><font style="vertical-align: inherit;">Wenn der Puffer voll ist, gibt das System einen TransactionException-Fehler aus.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rmi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaCard unterstützt die RMI-Technologie (Remote Metod Invocation). </font><font style="vertical-align: inherit;">In diesem Artikel werde ich diese Technologie nicht widmen. </font><font style="vertical-align: inherit;">Ich kann nur sagen, dass diese Funktionalität nicht üblich ist und viele Karten sie nicht unterstützen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der größte Teil der JavaCard-API ist der Kryptografie gewidmet. </font><font style="vertical-align: inherit;">Es gibt Klassen zum Verschlüsseln, Erstellen und Überprüfen einer digitalen Signatur, zum Generieren von Schlüsseln und Zufallszahlen, zum Berechnen von Prüfsummen und Hashes sowie zum Implementieren von Schlüsselaustauschschemata. </font><font style="vertical-align: inherit;">Neben der Kryptografie bietet JavaCard auch Klassen zum Speichern und Überprüfen von PINs und sogar biometrischen Daten. </font><font style="vertical-align: inherit;">Die übrigen Klassen bieten Zugriff auf die in anderen Kapiteln beschriebenen Funktionen oder sind Hilfsprogramme für die Arbeit mit Zeichenfolgen, Zahlen, TLV usw. </font><font style="vertical-align: inherit;">Die API wird in einer anderen Artikelserie interpretiert.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wichtige JavaCard-Einschränkungen im Vergleich zu Java</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Programmiersprache der JavaCard-Anwendung ist Java. Fast Java. Daher werden die Typen char, float, double, long und enum nicht unterstützt. Der int-Typ ist für Karten optional (normalerweise unterstützen ihn moderne Karten) und seine Verwendung führt, wenn er nicht durch die entsprechende Option aktiviert wird, zu einem Fehler beim Konvertieren der Anwendung in eine CAP-Datei. Vergessen Sie für, Iterator und Lambda. Generika, statischer Import und Anmerkungen (nur Runtime Invisible) werden vom Konverter seit Version 3.0.0 als unterstützt Sie haben keinen Einfluss auf die Codeausführung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Kompilieren des Codes wird ein gewöhnlicher JDK-Compiler verwendet. Inkompatibilitätsfehler treten nur bei der Konvertierung in eine CAP-Datei oder bei Verwendung der Smart IDE für JavaCard auf.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das größte Problem für Programmierer ist in der Tat das Fehlen eines int standardmäßig. </font><font style="vertical-align: inherit;">Normalerweise werden sie wirklich nicht benötigt, daher möchte ich sie nicht unnötig aktivieren. </font><font style="vertical-align: inherit;">Der Java-Compiler hat jedoch die Angewohnheit, das Ergebnis aller arithmetischen Operationen automatisch in int umzuwandeln. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, müssen Sie einen expliziten Typ verwenden, der im Code auf kurz oder byte umgestellt wird, wodurch der Code weniger lesbar wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere Einschränkung besteht bei der Initialisierung statischer Felder darin, dass sie nur mit Konstanten und Arrays initialisiert werden können, die Konstanten enthalten, nicht jedoch mit Objekten.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das war also meine Einführung in JavaCard. </font><font style="vertical-align: inherit;">Wenn Sie diesen Artikel interessant finden oder zumindest Ihr Interesse an diesem Thema geweckt haben, können Sie in den Kommentaren schreiben, worüber Sie konkret mehr wissen möchten. </font><font style="vertical-align: inherit;">So kann ich entscheiden, in welcher Reihenfolge und in wie vielen Details über eine bestimmte Funktionalität und Anwendung von JavaCard geschrieben werden soll. </font><font style="vertical-align: inherit;">In jedem Fall wird der nächste Artikel der Global Platform diese Reihe abschließen.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de380543/">https://habr.com/ru/post/de380543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de380531/index.html">Bus Blaster — универсальный скоростной bit-bang интерфейс для терпеливых энтузиастов</a></li>
<li><a href="../de380533/index.html">Компания Epson приглашает всех на Пикник для гиков</a></li>
<li><a href="../de380535/index.html">Die sanfte Landung der Union-Kapsel ist eher eine Explosion, aber kein Problem</a></li>
<li><a href="../de380537/index.html">Unreal Engine 4.8 veröffentlicht</a></li>
<li><a href="../de380541/index.html">Freitag "Paket": ungewöhnliche Fälle und Kuriositäten bei der Lieferung</a></li>
<li><a href="../de380545/index.html">Panasonic gibt Handbewegungen an Schlaganfallpatienten zurück, indem es Gehirnwellen entschlüsselt</a></li>
<li><a href="../de380547/index.html">Apple WWDC Zusammenfassung für das Internet der Dinge: Hätte interessanter sein können</a></li>
<li><a href="../de380549/index.html">Die Balken von Zhenya und Luke - ein Multiplikatorwerkzeug des späten 19. Jahrhunderts</a></li>
<li><a href="../de380551/index.html">DEXP Ixion ML 4.5 '' Test: Ein langlebiges Smartphone - eine Woche ohne Steckdose für 4.990 Rubel</a></li>
<li><a href="../de380553/index.html">Need For Speed ​​III Modern Patch: Mehr als 100 Änderungen ohne Quellcode</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>