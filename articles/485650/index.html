<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè∏ üï∂Ô∏è ü§±üèª T√©cnicas de reducci√≥n de imagen de Docker üòã üà∫ üë®‚Äçüë®‚Äçüëß‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øAlguna vez se ha preguntado por qu√© el tama√±o de un contenedor Docker que contiene una sola aplicaci√≥n puede ser de alrededor de 400 MB? ¬øO tal vez l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>T√©cnicas de reducci√≥n de imagen de Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/485650/">  ¬øAlguna vez se ha preguntado por qu√© el tama√±o de un contenedor Docker que contiene una sola aplicaci√≥n puede ser de alrededor de 400 MB?  ¬øO tal vez le preocupaba el tama√±o bastante grande de la imagen de Docker que conten√≠a un solo archivo binario de varias decenas de MB de tama√±o? <br><br> <a href="https://habr.com/ru/company/ruvds/blog/485650/"><img src="https://habrastorage.org/webt/ny/az/k8/nyazk8uqdkaog5lwtukn8qz1zpu.jpeg"></a> <br><br>  El autor del art√≠culo, cuya traducci√≥n publicamos hoy, quiere analizar los principales factores que afectan el tama√±o de los contenedores Docker.  √âl, adem√°s, va a compartir recomendaciones sobre la reducci√≥n del tama√±o de los contenedores. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Capas de imagen de Docker</font> </h2><br>  Una imagen de un contenedor Docker es esencialmente una colecci√≥n de archivos apilados uno encima del otro en varias capas.  A partir de estos archivos se ensambla un contenedor de trabajo.  Docker utiliza el sistema de archivos <a href="https://en.wikipedia.org/wiki/UnionFS">UnionFS</a> , en el que los archivos se agrupan en capas.  Una capa puede contener uno o varios archivos, las capas se superponen entre s√≠.  Durante la ejecuci√≥n del contenedor, los contenidos de las capas se combinan, como resultado, el usuario final del contenedor percibe los materiales "dispuestos" en capas como un √∫nico sistema de archivos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/3ba/eea/0a23baeea85753e1a66d8399ff188b4c.png"></div><br>  <i><font color="#999999">Vista simplificada de UnionFS</font></i> <br><br>  El sistema de archivos resultante se presenta al usuario final utilizando alguna implementaci√≥n de UnionFS (Docker <a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">admite</a> muchas implementaciones similares a trav√©s de controladores de almacenamiento enchufables).  El tama√±o total de los archivos recibidos por el usuario final es igual a la suma de los tama√±os de los archivos en las capas.  Cuando Docker crea un contenedor basado en la imagen, usa todas las capas de solo lectura de la imagen, agregando una capa delgada en la parte superior de estas capas que admite lectura y escritura.  Es esta capa la que le permite modificar archivos en un contenedor en ejecuci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/895/c00/aaf895c00a3353efa96934aeabd85f6f.png"></div><br>  <i><font color="#999999">El contenedor en ejecuci√≥n contiene una capa de lectura y escritura ubicada en la parte superior de las capas de solo lectura</font></i> <br><br>  ¬øQu√© sucede si un archivo se elimina en la <code>Layer 4</code> contenedor presentado esquem√°ticamente arriba?  Aunque este archivo no estar√° disponible en el sistema de archivos que ve el usuario, de hecho, el tama√±o de este archivo seguir√° siendo uno de los componentes del tama√±o del contenedor, ya que este archivo permanecer√° en una de las capas de solo lectura. <br><br>  Es bastante simple comenzar a construir la imagen con un peque√±o archivo ejecutable de la aplicaci√≥n y llegar a una imagen muy grande.  A continuaci√≥n veremos varios m√©todos para hacer que los contenedores sean lo m√°s peque√±os posible. <br><br><h2>  <font color="#3AC1EF">Preste atenci√≥n a la ruta a la carpeta, en funci√≥n de los materiales de los que se recopilan las im√°genes.</font> </h2><br>  ¬øCu√°l es la forma m√°s com√∫n de ensamblar im√°genes de Docker?  Aparentemente, as√≠: <br><br><pre> <code class="plaintext hljs">docker build .</code> </pre> <br>  El punto en este comando le dice a Docker que consideramos que el directorio de trabajo actual es la ra√≠z del sistema de archivos utilizado en el proceso de ensamblaje de im√°genes. <br><br>  Para comprender mejor lo que sucede despu√©s de ejecutar el comando anterior, vale la pena recordar que construir una imagen Docker es un proceso cliente-servidor.  La interfaz de l√≠nea de comandos de Docker (cliente), a la que le damos el <code>docker build</code> Docker, utiliza el motor de Docker (servidor) para compilar la imagen del contenedor.  Para limitar el acceso al sistema de archivos base del cliente, el sistema de ensamblaje de im√°genes necesita saber d√≥nde se encuentra la ra√≠z del sistema de archivos virtual.  Es all√≠ donde las instrucciones del archivo <code>Dockerfile</code> buscan recursos de archivos que eventualmente pueden terminar en la imagen que se est√° ensamblando. <br><br>  Imagine un lugar donde generalmente se coloca un <code>Dockerfile</code> .  Este es probablemente el directorio ra√≠z del proyecto?  Si hay un <code>Dockerfile</code> en la ra√≠z del proyecto, que es utilizado por el <code>docker build</code> para construir la imagen, entonces resulta que todos los archivos del proyecto pueden entrar en la imagen.  Esto puede llevar al hecho de que miles de archivos basura de muchos megabytes de tama√±o pueden entrar en el contexto del ensamblaje de la imagen.  Si usa ligeramente los comandos <code>ADD</code> y <code>COPY</code> en el <code>Dockerfile</code> , entonces todos los archivos del proyecto pueden formar parte de la imagen finalizada.  Muy a menudo, quienes recopilan im√°genes no necesitan esto, ya que la imagen final generalmente debe incluir solo algunos archivos seleccionados. <br><br>  Aseg√∫rese siempre de que el comando de <code>docker build</code> ruta correcta y que no haya comandos en el <code>Dockerfile</code> que agreguen archivos innecesarios a la imagen.  Si por alguna raz√≥n necesita hacer que el proyecto arraigue el contexto de compilaci√≥n, puede incluir selectivamente archivos en √©l y excluirlos usando <code>.dockerignore</code> . <br><br><h2>  <font color="#3AC1EF">Optimizar capas de imagen</font> </h2><br>  El n√∫mero m√°ximo de capas que puede tener una imagen es 127 (dado el soporte para ese n√∫mero de capas utilizadas por el controlador del almac√©n de datos).  Esta limitaci√≥n, si es absolutamente necesaria, se puede relajar, pero con este enfoque se reduce la gama de sistemas en los que se pueden recopilar esas im√°genes.  El punto es que el motor Docker debe ejecutarse en un sistema cuyo n√∫cleo se modifica en consecuencia. <br><br>  Como se mencion√≥ en la secci√≥n anterior, debido al hecho de que UnionFS se usa al ensamblar im√°genes, los archivos que caen en una determinada capa permanecen all√≠ incluso si se eliminaron de las capas superpuestas.  Vamos a resolverlo usando el Dockerfile experimental: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp RUN rm /tmp/10MB.zip</code> </pre> <br>  Ensamblemos la imagen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/d7c/e6d/44bd7ce6d60c71fd0856e96bd48ec5b7.png"></div><br>  <i><font color="#999999">Montaje de una imagen experimental en la que hay espacio utilizado irracionalmente</font></i> <br><br>  Explore la imagen usando <a href="https://github.com/wagoodman/dive">buceo</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/e7f/1a5/2dae7f1a5875ece43a52042632a21401.png"></div><br>  <i><font color="#999999">El indicador de rendimiento de la imagen es del 34%.</font></i> <br><br>  El indicador de eficiencia de imagen del 34% indica que una cantidad considerable de espacio de imagen se usa irracionalmente.  Esto lleva a un aumento en el tiempo de arranque de la imagen, a un desperdicio innecesario de recursos de red, a un tiempo de inicio m√°s lento del contenedor. <br><br>  ¬øC√≥mo deshacerse de este problema?  Consideremos varias opciones. <br><br><h3>  <font color="#3AC1EF">‚ñç Fusionar resultados de trabajo en equipo</font> </h3><br>  ¬øAlguna vez ha visto <code>Dockerfile</code> contienen directivas <code>RUN</code> muy largas en las que se combinan muchos comandos de shell con <code>&amp;&amp;</code> ?  Esta es la fusi√≥n de los resultados de los equipos. <br><br>  Con este m√©todo, creamos, en base a los resultados de un solo equipo largo, solo una capa.  Dado que no habr√° capas en la imagen que contengan archivos eliminados en las siguientes capas, la imagen final no incluir√° dichos "archivos fantasma".  Considere esto como un ejemplo, llevando el <code>Dockerfile</code> anterior a este estado: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp &amp;&amp; rm /tmp/10MB.zip</code> </pre> <br>  Despu√©s de eso, analizamos la imagen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbe/87f/a16/fbe87fa1633aec55d8fdcbe4d8d1014e.png"></div><br>  <i><font color="#999999">La fusi√≥n de equipos le permiti√≥ crear una imagen 100% optimizada</font></i> <br><br>  La aplicaci√≥n de esta t√©cnica para optimizar el tama√±o de las im√°genes en la pr√°ctica es que despu√©s de terminar de trabajar en el archivo <code>Dockerfile</code> , debe analizarlo y descubrir si la combinaci√≥n de comandos se puede utilizar para reducir la cantidad de espacio desperdiciado. <br><br><h3>  <font color="#3AC1EF">‚ñçAplicar la opci√≥n --squash</font> </h3><br>  En los casos en que use <code>Dockerfile</code> otras personas que no desea o no puede cambiar, una alternativa a la combinaci√≥n de comandos puede ser ensamblar una imagen usando la opci√≥n <code>--squash</code> . <br><br>  Las versiones modernas de Docker (que comienzan con 1.13) le permiten reunir todas las capas en una sola, eliminando as√≠ los "recursos fantasmas".  En este caso, puede usar el <code>Dockerfile</code> original no modificado, que contiene muchos comandos separados.  Pero necesita construir la imagen usando la opci√≥n <code>--squash</code> : <br><br><pre> <code class="plaintext hljs">docker build --squash .</code> </pre> <br>  La imagen resultante tambi√©n resulta estar 100% optimizada: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/10f/5fc/92310f5fc60ee677d39db75f3d0bac93.png"></div><br>  <i><font color="#999999">El uso de la opci√≥n --squash durante el ensamblaje permiti√≥ crear una imagen que estaba 100% optimizada</font></i> <br><br>  Aqu√≠ puedes prestar atenci√≥n a un detalle interesante.  Es decir, en <code>Dockerfile</code> se cre√≥ una capa para agregar un archivo y otra capa para eliminar este archivo.  La opci√≥n <code>--squash</code> es lo suficientemente inteligente como para comprender que en este escenario no es necesario crear capas adicionales (en la imagen final solo <code>9ccd9‚Ä¶</code> capa de <code>9ccd9‚Ä¶</code> partir de la imagen base que usamos).  En general, para esto podemos poner <code>--squash</code> una ventaja adicional.  Es cierto que con <code>--squash</code> , debe tener en cuenta que esto puede interferir con el uso de capas en cach√©. <br><br>  Como resultado, se recomienda tener en cuenta el hecho de que al trabajar con el <code>Dockerfile</code> otra persona que no le gustar√≠a cambiar, puede minimizar la cantidad de espacio de imagen utilizado de forma irracional al recopilar im√°genes utilizando la opci√≥n <code>--squash</code> .  Para analizar la imagen terminada, puede usar la herramienta de <a href="https://github.com/wagoodman/dive">buceo</a> . <br><br><h2>  <font color="#3AC1EF">Eliminar cach√©s y archivos temporales</font> </h2><br>  Al contener aplicaciones, a menudo surge una situaci√≥n en la que necesita colocar herramientas, bibliotecas y utilidades adicionales en la imagen con ellas.  Esto se hace usando administradores de paquetes como <code>apk</code> , <code>yum</code> , <code>apt</code> . <br><br>  Los administradores de paquetes se esfuerzan por ahorrar tiempo al usuario y no cargar su conexi√≥n de red una vez m√°s al instalar paquetes.  Por lo tanto, almacenan en cach√© los datos descargados.  Para que el tama√±o de la imagen final de Docker sea lo m√°s peque√±o posible, no necesitamos almacenar cach√©s del administrador de paquetes en esta imagen.  Despu√©s de todo, si alguna vez necesitamos otra imagen, siempre podemos reconstruirla usando el <code>Dockerfile</code> actualizado. <br><br>  Para eliminar los cach√©s creados por los tres administradores de paquetes populares mencionados anteriormente, al final de un comando agregado (es decir, uno que se ejecuta para crear una capa), puede agregar lo siguiente: <br><br><pre> <code class="plaintext hljs">APK: ... &amp;&amp; rm -rf /etc/apk/cache YUM: ... &amp;&amp; rm -rf /var/cache/yum APT: ... &amp;&amp; rm -rf /var/cache/apt</code> </pre> <br>  Como resultado, se recomienda que antes de completar el trabajo en el <code>Dockerfile</code> agregue <code>Dockerfile</code> que eliminen los cach√©s de los administradores de paquetes utilizados para construir la imagen.  Lo mismo se aplica a los archivos temporales que no afectan el funcionamiento correcto del contenedor. <br><br><h2>  <font color="#3AC1EF">Elige tu imagen base con cuidado</font> </h2><br>  Cada <code>Dockerfile</code> comienza con una directiva <code>FROM</code> .  Aqu√≠ es donde establecemos la imagen b√°sica sobre la base de la cual se crear√° nuestra imagen. <br><br>  Esto es lo <a href="https://docs.docker.com/engine/reference/builder/">que</a> dice la <a href="https://docs.docker.com/engine/reference/builder/">documentaci√≥n de</a> Docker al respecto: ‚ÄúLa instrucci√≥n <code>FROM</code> inicializa una nueva fase de creaci√≥n y configura la imagen base para las instrucciones que siguen.  Como resultado, un <code>Dockerfile</code> correctamente compuesto deber√≠a comenzar con una instrucci√≥n <code>FROM</code> .  Una imagen puede ser cualquier imagen viable.  Es m√°s f√°cil comenzar a armar su propia imagen, tomando como base una imagen de un repositorio p√∫blico ". <br><br>  Obviamente, hay muchas im√°genes b√°sicas, cada una de las cuales tiene sus propias caracter√≠sticas y capacidades.  La selecci√≥n correcta de una imagen b√°sica que contiene exactamente lo que necesita la aplicaci√≥n, ni m√°s ni menos, tiene un gran impacto en el tama√±o de la imagen final. <br><br>  Como es de esperar, los tama√±os de las im√°genes base populares var√≠an enormemente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/847/e59/97c/847e5997cf00104e3b212874ee830243.png"></div><br>  <i><font color="#999999">Tama√±os de im√°genes b√°sicas populares de docker</font></i> <br><br>  Entonces, la contenedorizaci√≥n de la aplicaci√≥n usando la imagen base de <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/19.10/images/sha256-bceb2fb47400491f75a9056a3d4e219cbe5f9512d4220ca43f3f5cb3d08e9d04">Ubuntu 19.10</a> conducir√° al hecho de que el tama√±o de la imagen, adem√°s del tama√±o de la aplicaci√≥n, se agregar√° otros 73 MB.  Si recopilamos la misma imagen sobre la base de la imagen de <a href="https://hub.docker.com/layers/alpine/library/alpine/3.10.3/images/sha256-77cbe97593c890eb1c4cadcbca37809ebff2b5f46a036666866c99f08a708967">Alpine 3.10.3</a> , obtendremos un "aditivo" solo en la cantidad de 6 MB.  Dado que Docker almacena en cach√© las capas de imagen, los recursos de red se gastan en cargar una imagen solo cuando el contenedor se inicia por primera vez de la manera apropiada (en otras palabras, cuando la imagen se carga por primera vez).  Pero el tama√±o de la imagen en s√≠ no se reduce a partir de esto. <br><br>  Aqu√≠ puede llegar a la siguiente conclusi√≥n (completamente l√≥gica): "Entonces, ¬°siempre usar√© Alpine!".  Pero, desafortunadamente, en el mundo del desarrollo de software, no todo es tan simple. <br><br>  ¬øQuiz√°s <a href="https://gitlab.alpinelinux.org/groups/alpine/-/activity">los desarrolladores de Alpine Linux</a> descubrieron alg√∫n ingrediente secreto que Ubuntu o Debian todav√≠a no pueden encontrar?  No  El hecho es que para crear una imagen de Docker, cuyo tama√±o es un orden de magnitud menor que el tama√±o de la imagen de la misma Debian, los desarrolladores de Alpine tuvieron que tomar algunas decisiones sobre lo que debe incluirse en la imagen y lo que no es necesario.  Antes de llamar a Alpine la imagen base que siempre usar√°, debe preguntar si tiene todo lo que necesita.  Adem√°s, aunque Alpine tiene un administrador de paquetes, es posible que el paquete espec√≠fico que se utiliza en su entorno de trabajo basado, por ejemplo, en Ubuntu, no est√© disponible en Alpine.  O bien, no un paquete, sino la versi√≥n deseada del paquete.  Estas son las compensaciones que debe tener en cuenta antes de elegir y probar la imagen b√°sica que mejor se adapte a su proyecto. <br><br>  Y, por √∫ltimo, si realmente necesita una de las im√°genes b√°sicas m√°s grandes, puede usar la herramienta para minimizar el tama√±o de la imagen.  Por ejemplo, una herramienta gratuita de c√≥digo abierto <a href="https://dockersl.im/">DockerSlim</a> .  Esto reducir√° el tama√±o de la imagen terminada. <br><br>  Al final, podemos decir que el uso de una imagen b√°sica cuidadosamente seleccionada es extremadamente importante para crear sus propias im√°genes compactas.  Eval√∫e las necesidades de su proyecto y seleccione una imagen que contenga lo que necesita y, al mismo tiempo, tenga dimensiones aceptables para usted. <br><br><h2>  <font color="#3AC1EF">Considere crear una imagen que no tenga una imagen b√°sica.</font> </h2><br>  Si su aplicaci√≥n puede ejecutarse sin un entorno adicional proporcionado de manera b√°sica, puede decidir no usar una imagen b√°sica.  Por supuesto, dado que la instrucci√≥n <code>FROM</code> debe estar presente en el <code>Dockerfile</code> , no puede prescindir de ella.  Adem√°s, debe se√±alar alg√∫n tipo de imagen.  ¬øQu√© imagen usar en tal situaci√≥n? <br><br>  Una apariencia de <a href="https://hub.docker.com/_/scratch">rasgu√±o</a> podr√≠a ser √∫til aqu√≠.  A partir de su descripci√≥n, puede descubrir que est√° especialmente vac√≠o y dise√±ado para crear im√°genes, si habla el lenguaje <code>Dockerfile</code> , <code>FROM scratch</code> , es decir, desde cero.  Esta imagen es especialmente √∫til cuando se crean im√°genes b√°sicas (como im√°genes de debian y busybox) o im√°genes extremadamente m√≠nimas (aquellas que contienen un solo archivo binario y lo que se requiere para su funcionamiento, por ejemplo, es algo as√≠ como hello-world).  Usar esta imagen como la base de la imagen descrita por el <code>Dockerfile</code> es similar a usar una "operaci√≥n vac√≠a" en alg√∫n programa.  La aplicaci√≥n de una imagen <code>scratch</code> no crear√° una capa adicional en la imagen terminada. <br><br>  Como resultado, si su aplicaci√≥n es un ejecutable aut√≥nomo que puede funcionar por s√≠ solo, la elecci√≥n de la imagen b√°sica de <code>scratch</code> le permitir√° minimizar el tama√±o del contenedor. <br><br><h2>  <font color="#3AC1EF">Usa compilaciones de varias etapas</font> </h2><br>  Las construcciones de etapas m√∫ltiples han sido el centro de atenci√≥n desde Docker 05/17.  Era una oportunidad que se hab√≠a esperado durante mucho tiempo.  Permite a los creadores de im√°genes abandonar sus propios scripts para crear im√°genes e implementar todo lo que necesitan utilizando el conocido formato <code>Dockerfile</code> . <br><br>  En t√©rminos generales, se puede pensar que un <code>Dockerfile</code> varias <code>Dockerfile</code> combina m√∫ltiples <code>Dockerfile</code> , o como un <code>Dockerfile</code> , que tiene varias instrucciones <code>FROM</code> . <br><br>  Antes de la aparici√≥n de ensamblajes de varias etapas, si tuviera que crear un ensamblaje de su proyecto y distribuirlo en un contenedor utilizando el <code>Dockerfile</code> , entonces probablemente necesitar√≠a realizar el proceso de ensamblaje, lo que conducir√≠a a la aparici√≥n de un contenedor, como el que se muestra a continuaci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/060/270/1b9/0602701b97e37b957b0e77663b79faec.png"></div><br>  <i><font color="#999999">Cree y distribuya una aplicaci√≥n sin utilizar la tecnolog√≠a de creaci√≥n de etapas m√∫ltiples</font></i> <br><br>  Aunque, desde un punto de vista t√©cnico, todo se hizo correctamente, la imagen final y el contenedor resultante est√°n llenos de capas creadas en el proceso de preparaci√≥n de los materiales del proyecto.  Y estas capas no son necesarias para formar el tiempo de ejecuci√≥n del proyecto. <br><br>  Los ensambles de varias etapas le permiten separar las fases de creaci√≥n y preparaci√≥n de los materiales del proyecto del entorno en el que se ejecuta el c√≥digo del proyecto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b30/938/c61/b30938c61707b5fb08866fac84df1c85.png"></div><br>  <i><font color="#999999">Ensamblaje en varias etapas, separaci√≥n del proceso de creaci√≥n y preparaci√≥n de materiales del proyecto del entorno de ejecuci√≥n.</font></i> <br><br>  Al mismo tiempo, un solo <code>Dockerfile</code> suficiente para describir el proceso completo de construcci√≥n del proyecto.  Pero ahora puede copiar material de una etapa a otra y deshacerse de datos innecesarios. <br><br>  Los ensamblajes de varias etapas le permiten crear ensamblajes multiplataforma que se pueden usar repetidamente sin usar sus propios scripts de ensamblaje escritos para un sistema operativo espec√≠fico.  El tama√±o final de la imagen se puede minimizar debido a la posibilidad de inclusi√≥n selectiva de los materiales generados en las etapas anteriores del proceso de ensamblaje de la imagen. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Crear im√°genes de contenedor Docker es un proceso que los programadores modernos a menudo tienen que enfrentar.  Existen muchos recursos para crear <code>Dockerfile</code> , y puede encontrar muchos ejemplos de dichos archivos en Internet.  Pero no importa lo que use, al crear su propio <code>Dockerfile</code> siempre vale la pena considerar el tama√±o de las im√°genes resultantes. <br><br>  Aqu√≠ observamos varias t√©cnicas para minimizar el tama√±o de las im√°genes de Docker.  Atenci√≥n al contenido del <code>Dockerfile</code> , incluido solo lo que realmente necesita, elegir la imagen base correcta, usar la tecnolog√≠a de construcci√≥n de etapas m√∫ltiples; todo esto puede ayudar a reducir seriamente el tama√±o de las im√°genes de Docker que cree. <br><br>  <b>PD:</b> Lanzamos el <a href="https://ruvds.com/ru-rub/marketplace">mercado</a> en el sitio web de RUVDS.  En el mercado, la imagen de <a href="https://ruvds.com/ru-rub/marketplace/docker">Docker</a> se instala con un solo clic, puede verificar c√≥mo funcionan los contenedores en <a href="https://ruvds.com/">VPS</a> , 3 d√≠as para las pruebas se proporcionan de forma gratuita para todos los nuevos clientes. <br><br>  <b>Estimados lectores!</b>  ¬øC√≥mo optimizas el tama√±o de tus im√°genes de Docker? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/485650/">https://habr.com/ru/post/485650/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485634/index.html">El tablero de Dungeons and Dragons me ayud√≥ a aprender ingl√©s</a></li>
<li><a href="../485636/index.html">Los virus resistentes a CRISPR construyen refugios para proteger los genomas de las enzimas que penetran el ADN</a></li>
<li><a href="../485640/index.html">M√©todos de ocultamiento de p√°ginas web</a></li>
<li><a href="../485646/index.html">Consejos √∫tiles de Python que nunca has conocido antes. Parte 2</a></li>
<li><a href="../485648/index.html">El enfoque pit√≥nico de los bucles for: range () y enumerate ()</a></li>
<li><a href="../485652/index.html">Estad√≠sticas de comentarios en l√≠nea de confluencia</a></li>
<li><a href="../485660/index.html">La propia compa√±√≠a de protecci√≥n DDoS lanz√≥ ataques DDoS, admiti√≥ su fundador.</a></li>
<li><a href="../485664/index.html">Crear par√°metros din√°micos en un trabajo de Jenkins, o c√≥mo hacer que su tarea sea f√°cil de usar</a></li>
<li><a href="../485672/index.html">Mejores pr√°cticas de Redis, parte 1</a></li>
<li><a href="../485688/index.html">Myapp extiende vacaciones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>