<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÅâÔ∏è ‚úèÔ∏è üïû Echtzeit-Manipulation von Maschen auf Einheit üôãüèº üêà üí≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einer der Vorteile von Unity als Plattform f√ºr die Spieleentwicklung ist die leistungsstarke 3D-Engine. In diesem Tutorial lernen Sie die Welt der 3D-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Echtzeit-Manipulation von Maschen auf Einheit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428796/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/532/c83/ce5532c83ff152100775d62091370bf2.gif" alt="Bild"></div><br>  Einer der Vorteile von Unity als Plattform f√ºr die Spieleentwicklung ist die leistungsstarke 3D-Engine.  In diesem Tutorial lernen Sie die Welt der 3D-Objekte und der Netzmanipulation kennen. <br><br>  Aufgrund des Wachstums der VR- und AR-Technologien (Virtual and Augmented Reality) sind die meisten Entwickler mit komplexen Konzepten von 3D-Grafiken konfrontiert.  Lassen Sie dieses Tutorial der Ausgangspunkt f√ºr sie sein.  Keine Sorge, es wird keine komplizierte 3D-Mathematik geben - nur Herzen, Zeichnungen, Pfeile und viele interessante Dinge! <br><a name="habracut"></a><br><blockquote>  <em>Hinweis:</em> Dieses Lernprogramm richtet sich an Benutzer, die mit der Unity-IDE vertraut sind und √ºber Programmiererfahrung in C # verf√ºgen.  Wenn Sie nicht √ºber solche Kenntnisse verf√ºgen, lesen Sie zuerst die Tutorials <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Einf√ºhrung in die Unity-Benutzeroberfl√§che</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Einf√ºhrung in Unity Scripting</a> . <br><br>  Sie ben√∂tigen eine Version von Unity, die nicht niedriger als 2017.3.1 ist.  Die neueste Version von Unity kann hier heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">werden</a> .  In diesem Lernprogramm wird ein benutzerdefinierter Editor verwendet. Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Informationen hierzu finden Sie im</a> Lernprogramm zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Erweitern des Unity-Editors</a> . </blockquote><br><h2>  An die Arbeit gehen </h2><br>  Machen Sie sich zun√§chst mit den Grundbegriffen der 3D-Grafik vertraut, damit Sie das Tutorial besser verstehen. <br><br>  Grundlegende Fachbegriffe f√ºr 3D-Grafiken: <br><br><ul><li>  <em>Scheitelpunkte</em> : Jeder Scheitelpunkt ist ein Punkt im 3D-Raum. </li><li>  <em>Netz</em> : Enth√§lt alle Eckpunkte, Kanten, Dreiecke, Normalen und UV-Daten des Modells. </li><li>  <em>Netzfilter</em> : Speichert Modellnetzdaten. </li><li>  <em>Mesh Renderer</em> : Rendert die Mesh-Daten in der Szene. </li><li>  <em>Normalen</em> : Der Vektor eines Scheitelpunkts oder einer Oberfl√§che.  Es ist senkrecht zur Oberfl√§che des Netzes nach au√üen gerichtet. </li><li>  <em>Linien / Kanten</em> : Unsichtbare Linien, die Eckpunkte miteinander verbinden. </li><li>  <em>Dreiecke</em> : gebildet durch Verbinden von drei Spitzen. </li><li>  <em>UV-Karte</em> : H√§ngt Material an ein Objekt an und erstellt eine Textur und Farbe daf√ºr. </li></ul><br>  Die Anatomie eines 3D-Objekts beginnt mit seinem Netz.  Die Erstellung dieses Netzes beginnt an seinen Spitzen.  Unsichtbare Linien, die diese Eckpunkte verbinden, bilden Dreiecke, die die Grundform des Objekts definieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/83a/4c2/5a783a4c2ed2c144ccd0d7eb97369370.gif"></div><br>  Dann legen die Normalen und UV-Daten die Schattierung, Farbe und Textur fest.  Netzdaten werden in einem Netzfilter gespeichert, und der Netzrenderer verwendet diese Daten, um ein Objekt in der Szene zu zeichnen. <br><br>  Das hei√üt, der Pseudocode zum Erstellen eines 3D-Modells sieht folgenderma√üen aus: <br><br><ul><li>  Erstellen Sie ein neues Netz mit dem Namen "myMesh". </li><li>  F√ºgen Sie Daten zu den Eigenschaften der Eckpunkte und Dreiecke myMesh hinzu. </li><li>  Erstellen Sie einen neuen Netzfilter mit dem Namen "myMeshFilter". </li><li>  Setzen Sie die Mesh-Eigenschaft myMeshFilter auf myMesh. </li></ul><br>  Wenn Sie die Grundlagen beherrschen, laden Sie das <a href="">Projekt</a> herunter, entpacken Sie die Dateien und f√ºhren Sie das Werkst√ºck des Projekts in Unity aus.  Sehen Sie sich die Ordnerstruktur im <em>Projektfenster an</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/690/2d6/c2e/6902d6c2e14a98284c8af39055242bc7.png"></div><br>  Beschreibung der Ordner: <br><br><ul><li>  <em>Prefabs</em> : Enth√§lt das Sphere-Prefab, mit dem das 3D-Netz w√§hrend der Anwendungsausf√ºhrung gespeichert wird. </li><li>  <em>Szenen</em> : Enth√§lt die drei Szenen, die wir in diesem Tutorial verwenden. </li><li>  <em>Editor</em> : Die Skripte in diesem Ordner geben uns die Superfunktionen im Editor, die wir in der Entwicklung verwenden. </li><li>  <em>Skripte</em> : Hier sind die Laufzeitskripte, die an das GameObject angeh√§ngt und ausgef√ºhrt werden, wenn Sie auf " <em>Spielen"</em> klicken. </li><li>  <em>Materialien</em> : Dieser Ordner enth√§lt das Material f√ºr das Netz. </li></ul><br>  Im n√§chsten Abschnitt erstellen wir einen benutzerdefinierten Editor, um die Erstellung eines 3D-Netzes zu visualisieren. <br><br><h2>  √Ñndern Sie die Netze mit dem benutzerdefinierten Editor </h2><br>  √ñffnen Sie die <em>01 Mesh Study Demo</em> im Ordner " <em>Scenes</em> ".  Im <em>Szenenfenster</em> sehen Sie einen 3D-W√ºrfel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/ed2/812/6d5ed28123a0c65bb083c67efab702c7.gif"></div><br>  Bevor wir uns mit dem Netz befassen, werfen wir einen Blick auf das benutzerdefinierte Editor-Skript. <br><br><h3>  Bearbeiten eines Editor-Skripts </h3><br>  W√§hlen Sie den <em>Editor-</em> Ordner im <em>Projektfenster</em> .  Die Skripte in diesem Ordner erweitern den Editor (Editor) w√§hrend der Entwicklung um Funktionen und sind im Erstellungsmodus nicht verf√ºgbar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/442/653/b41/442653b41ca755b67d3a1ce42ae1ec5a.png"></div><br>  √ñffnen Sie <em>MeshInspector.cs</em> und zeigen Sie den Quellcode an.  Alle Editor-Skripte m√ºssen die <code>Editor</code> Klasse implementieren. Das <code>CustomEditor</code> Attribut teilt der <code>Editor</code> Klasse mit, f√ºr welchen Objekttyp sie bestimmt ist.  <code>OnSceneGUI()</code> ist eine Ereignismethode, die das Rendern im <code>OnSceneGUI()</code> erm√∂glicht.  <code>OnInspectorGUI()</code> k√∂nnen Sie dem Inspector zus√§tzliche GUI-Elemente hinzuf√ºgen. <br><br>  <em>F√ºgen Sie</em> in <em>MeshInspector.cs</em> vor dem Starten der <code>MeshInspector</code> Klasse Folgendes hinzu: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CustomEditor(typeof(MeshStudy))</span></span>]</code> </pre> <br>  Code Erl√§uterung: Das <code>CustomEditor</code> Attribut teilt Unity mit, welchen Objekttyp die benutzerdefinierte <code>CustomEditor</code> √§ndern kann. <br><br>  <code>OnSceneGUI()</code> in <code>OnSceneGUI()</code> vor <code>EditMesh()</code> Folgendes hinzu: <br><br><pre> <code class="cs hljs">mesh = target <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MeshStudy; Debug.Log(<span class="hljs-string"><span class="hljs-string">"Custom editor is running"</span></span>);</code> </pre> <br>  Codeerkl√§rung: Die <code>Editor</code> Klasse verf√ºgt √ºber eine Standardzielvariable.  <code>target</code> ist hier eine Konvertierung in <code>MeshStudy</code> .  Jetzt zeichnet der benutzerdefinierte Editor alle GameObjects im Szenenfenster und die <em>daran</em> angeh√§ngten <em>MeshStudy.cs</em> .  Durch Hinzuf√ºgen von Debugging-Meldungen k√∂nnen Sie in der Konsole √ºberpr√ºfen, ob der benutzerdefinierte Editor tats√§chlich ausgef√ºhrt wird. <br><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  Gehen Sie zum Ordner " <em>Scripts</em> " und ziehen Sie <em>MeshStudy.cs</em> auf den GameObject- <em>Cube</em> in der <em>Hierarchie</em> , um ihn anzuh√§ngen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa6/b8a/ee4/aa6b8aee48eacb8421eff3c4e1ef4be3.png"></div><br>  Jetzt sollte die Meldung "Benutzerdefinierter Editor l√§uft" in der Konsole angezeigt werden. Dies bedeutet, dass wir alles richtig gemacht haben!  Sie k√∂nnen die Debug-Nachricht l√∂schen, damit sie uns in der Konsole nicht st√∂rt. <br><br><h3>  Klonen und Dumping des Netzes </h3><br>  Achten Sie beim Arbeiten mit einem 3D-Netz im Bearbeitungsmodus mit dem benutzerdefinierten Editor darauf, das Standard-Unity-Netz nicht zu √ºberschreiben.  In diesem Fall m√ºssen Sie Unity neu starten. <br><br>  Um das Netz sicher zu klonen, ohne das urspr√ºngliche Formular zu √ºberschreiben, erstellen Sie eine Kopie des Netzes aus der Eigenschaft <code>MeshFilter.sharedmesh</code> und weisen Sie es dem Netzfilter erneut zu. <br><br>  Doppelklicken Sie <em>dazu</em> im Ordner <em>Scripts</em> auf <em>MeshStudy.cs</em> , um die Datei im Code-Editor zu √∂ffnen.  Dieses Skript erbt von der <code>MonoBehaviour</code> Klasse und seine <code>Start()</code> -Funktion wird im Bearbeitungsmodus nicht ausgef√ºhrt. <br><br>  <em>F√ºgen Sie</em> in <em>MeshStudy.cs</em> vor dem Starten der <code>MeshStudy</code> Klasse Folgendes hinzu: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ExecuteInEditMode</span></span>]</code> </pre> <br>  Erl√§uterung des Codes: Nach dem Hinzuf√ºgen dieses Attributs wird die Funktion <code>Start()</code> sowohl im Wiedergabemodus als auch im Bearbeitungsmodus ausgef√ºhrt.  Jetzt k√∂nnen wir zuerst das Netzobjekt instanziieren und es klonen. <br><br>  <code>InitMesh()</code> in <code>InitMesh()</code> den folgenden Code hinzu: <br><br><pre> <code class="cs hljs">oMeshFilter = GetComponent&lt;MeshFilter&gt;(); oMesh = oMeshFilter.sharedMesh; <span class="hljs-comment"><span class="hljs-comment">//1 cMesh = new Mesh(); //2 cMesh.name = "clone"; cMesh.vertices = oMesh.vertices; cMesh.triangles = oMesh.triangles; cMesh.normals = oMesh.normals; cMesh.uv = oMesh.uv; oMeshFilter.mesh = cMesh; //3 vertices = cMesh.vertices; //4 triangles = cMesh.triangles; isCloned = true; Debug.Log("Init &amp; Cloned");</span></span></code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  Ruft das urspr√ºngliche <code>oMesh</code> Netz aus der <code>MeshFilter</code> Komponente ab. </li><li>  Kopiert <code>cMesh</code> in eine neue Mesh- <code>cMesh</code> . </li><li>  Weist den kopierten Maschennetzfilter erneut zu. </li><li>  Aktualisiert lokale Variablen. </li></ol><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  Die Meldung "Init &amp; Cloned" sollte in der Debug-Konsole angezeigt werden.  W√§hlen Sie den GameObject- <code>Cube</code> in der <em>Hierarchie aus</em> und √ºberpr√ºfen Sie seine Eigenschaften im <em>Inspektor</em> .  <em>Der Netzfilter</em> sollte ein Netzelement namens <em>Klon</em> anzeigen.  Gro√üartig!  Dies bedeutet, dass wir das Netz erfolgreich geklont haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6c/2da/3e0/c6c2da3e0e29703888bad5e50bb608a6.png"></div><br>  Navigieren <em>Sie</em> im Editor-Ordner zu <em>MeshInspector.cs</em> .  <code>OnInspectorGUI()</code> in <code>OnInspectorGUI()</code> nach der zweiten Codezeile Folgendes hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button(<span class="hljs-string"><span class="hljs-string">"Reset"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.Reset(); //2 }</span></span></code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  Dieser Code zeichnet eine Schaltfl√§che zum Zur√ºcksetzen im <em>Inspektor</em> . </li><li>  Wenn diese <em>Taste</em> gedr√ºckt wird, wird die Funktion <code>Reset()</code> in <em>MeshStudy.cs aufgerufen</em> . </li></ol><br>  Speichern Sie die Datei, √∂ffnen Sie <em>MeshStudy.cs</em> und f√ºgen Sie der Funktion <code>Reset()</code> den folgenden Code hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cMesh != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; oMesh != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">//1 { cMesh.vertices = oMesh.vertices; //2 cMesh.triangles = oMesh.triangles; cMesh.normals = oMesh.normals; cMesh.uv = oMesh.uv; oMeshFilter.mesh = cMesh; //3 vertices = cMesh.vertices; //4 triangles = cMesh.triangles; }</span></span></code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  √úberpr√ºfen der Existenz der Quelle und des geklonten Netzes. </li><li>  <code>cMesh</code> auf das urspr√ºngliche Netz zur√ºck. </li><li>  Zuordnung zu <code>cMesh</code> <code>oMeshFilter</code> . </li><li>  Lokale Variablen aktualisieren. </li></ol><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  Klicken Sie im <em>Inspektor</em> auf die Schaltfl√§che <em>Test bearbeiten</em> , um das W√ºrfelnetz zu verzerren.  Klicken Sie anschlie√üend auf die Schaltfl√§che <em>Zur√ºcksetzen</em> .  Der W√ºrfel sollte in seine urspr√ºngliche Form zur√ºckkehren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c3/a8a/e22/0c3a8ae22c8f8382dd46ee652b4b6eea.gif"></div><br><h3>  Erkl√§rung von Eckpunkten und Dreiecken in Unity </h3><br>  Ein Netz besteht aus Eckpunkten, die durch Kanten in Dreiecken verbunden sind.  Dreiecke definieren die Grundform des Objekts. <br><br><blockquote>  <em>Mesh-Klasse:</em> <br><br><ul><li>  Die Eckpunkte werden als Array von <code>Vector3</code> Werten gespeichert. </li><li>  Dreiecke werden als ganzzahliges Array gespeichert, das den Indizes des Vertex-Arrays entspricht. </li></ul><br>  Das hei√üt, in einem einfachen Quad-Netz, das aus vier Eckpunkten und zwei Dreiecken besteht, sehen die Netzdaten folgenderma√üen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56c/56d/794/56c56d794628ff20592f801340308790.gif"></div></blockquote><br><h3>  Vertex-Mapping </h3><br>  Hier wollen wir die Eckpunkte des W√ºrfels als blaue Punkte anzeigen. <br><br>  In <em>MeshInspector.cs</em> gehen wir in die Funktion <code>EditMesh()</code> und f√ºgen Folgendes hinzu: <br><br><pre> <code class="cs hljs">handleTransform = mesh.transform; <span class="hljs-comment"><span class="hljs-comment">//1 handleRotation = Tools.pivotRotation == PivotRotation.Local ? handleTransform.rotation : Quaternion.identity; //2 for (int i = 0; i &lt; mesh.vertices.Length; i++) //3 { ShowPoint(i); }</span></span></code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  <code>handleTransform</code> Transformationswerte aus dem <code>mesh</code> . </li><li>  <code>handleRotation</code> den Rotationsmodus des aktuellen Gelenks ab. </li><li>  Durchqueren Sie die Eckpunkte des Netzes und zeichnen Sie die Punkte mit <code>ShowPoint()</code> . </li></ol><br>  <code>ShowPoint()</code> Funktion <code>ShowPoint()</code> unmittelbar nach dem Kommentar <code>//draw dot</code> Folgendes hinzu: <br><br><pre> <code class="cs hljs">Vector3 point = handleTransform.TransformPoint(mesh.vertices[index]);</code> </pre> <br>  Code Erl√§uterung: Diese Linie konvertiert die lokale Position des Scheitelpunkts in eine Koordinate im Weltraum. <br><br>  F√ºgen Sie in derselben Funktion im <code>if</code> Block unmittelbar nach der gerade hinzugef√ºgten Codezeile Folgendes hinzu: <br><br><pre> <code class="cs hljs">Handles.color = Color.blue; point = Handles.FreeMoveHandle(point, handleRotation, mesh.handleSize, Vector3.zero, Handles.DotHandleCap);</code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  Legt die Farbe, Gr√∂√üe und Position eines Punkts mithilfe der <code>Handles</code> . </li><li>  <code>Handles.FreeMoveHandle()</code> erstellt einen unbegrenzten Bewegungsmanipulator, der das Ziehen und Ablegen vereinfacht, was f√ºr uns im n√§chsten Abschnitt n√ºtzlich ist. </li></ol><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  √úberpr√ºfen Sie die Cube-Eigenschaft im <em>Inspektor</em> und stellen Sie sicher, dass die Option <em>Vertexpunkt verschieben</em> aktiviert ist.  Sie sollten jetzt sehen, dass das Netz auf dem Bildschirm mit mehreren blauen Punkten markiert ist.  Hier sind sie - die Spitzen des W√ºrfelnetzes!  Versuchen Sie dies mit anderen 3D-Objekten und beobachten Sie die Ergebnisse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d78/3aa/205/d783aa2054dd9ca81ee7a6c948c7c00a.gif"></div><br><h3>  Verschieben Sie einen einzelnen Scheitelpunkt </h3><br>  Beginnen wir mit dem einfachsten Schritt der Manipulation des Netzes - dem Verschieben eines einzelnen Scheitelpunkts. <br><br>  Gehen Sie zu <em>MeshInspector.cs</em> .  <code>ShowPoint()</code> der <code>ShowPoint()</code> -Funktion unmittelbar nach dem <code>//drag</code> Kommentars und direkt vor den schlie√üenden Klammern des <code>if</code> Blocks Folgendes hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUI.changed) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.DoAction(index, handleTransform.InverseTransformPoint(point)); //2 }</span></span></code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  <code>GUI.changed</code> verfolgt alle √Ñnderungen, die an Punkten auftreten, und arbeitet gut mit <code>Handles.FreeMoveHandle()</code> , um einen Drag &amp; Drop-Vorgang zu erkennen. </li><li>  F√ºr den ziehbaren Scheitelpunkt erh√§lt die Funktion <code>mesh.DoAction()</code> ihre Index- und Transformationswerte als Parameter.  Da sich die Transformationswerte des Scheitelpunkts im Weltraum befinden, konvertieren wir sie mit <code>InverseTransformPoint()</code> in den lokalen Raum. </li></ol><br>  Speichern Sie die Skriptdatei und gehen Sie zu <em>MeshStudy.cs</em> .  <code>DoAction()</code> in <code>DoAction()</code> nach den √∂ffnenden Klammern Folgendes hinzu: <br><br><pre> <code class="cs hljs">PullOneVertex(index, localPos);</code> </pre> <br>  <code>PullOneVertex()</code> der <code>PullOneVertex()</code> Funktion Folgendes <code>PullOneVertex()</code> : <br><br><pre> <code class="cs hljs">vertices[index] = newPos; <span class="hljs-comment"><span class="hljs-comment">//1 cMesh.vertices = vertices; //2 cMesh.RecalculateNormals(); //3</span></span></code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  Wir aktualisieren den Zielscheitelpunkt mit dem Wert <code>newPos</code> . </li><li>  <code>cMesh.vertices</code> aktualisierte Scheitelpunktwerte zu. </li><li>  In <code>RecalculateNormals()</code> berechnen <code>RecalculateNormals()</code> das Netz neu und zeichnen <code>RecalculateNormals()</code> neu, sodass es den √Ñnderungen entspricht. </li></ol><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  Versuchen Sie, Punkte auf den W√ºrfel zu ziehen.  Hast du ein gebrochenes Netz gesehen? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fca/ccf/c86/fcaccfc865e30b3c922e6cabcf9f79d7.gif"></div><br>  Es scheint, dass einige der Scheitelpunkte dieselbe Position haben. Wenn wir also nur einen ziehen, bleiben die verbleibenden Scheitelpunkte dahinter und das Netz bricht.  Im n√§chsten Abschnitt werden wir dieses Problem beheben. <br><br><h3>  Alle √§hnlichen Eckpunkte finden </h3><br>  Visuell besteht ein W√ºrfelnetz aus acht Eckpunkten, sechs Seiten und 12 Dreiecken.  Lassen Sie uns √ºberpr√ºfen, ob dies so ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/253/a30/b3f/253a30b3fcca7b0d9028d92b4c4149c2.gif"></div><br>  √ñffnen Sie <em>MeshStudy.cs</em> , <em>werfen</em> Sie einen Blick vor die Funktion <code>Start()</code> und suchen Sie die Variable <code>vertices</code> .  Wir werden folgendes sehen: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">HideInInspector</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3[] vertices;</code> </pre> <br>  Code Erl√§uterung: <code>[HideInInspector]</code> verbirgt eine gemeinsam genutzte Variable im <em>Inspector-</em> Fenster. <br><br>  Kommentieren Sie dieses Attribut aus: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//[HideInInspector] public Vector3[] vertices;</span></span></code> </pre> <br><blockquote>  <em>Hinweis: Das</em> Ausblenden von Scheitelpunktwerten hilft <code>[HideInInspector]</code> bei komplexeren 3D-Netzen.  Da die Gr√∂√üe des Scheitelpunktarrays Tausende von Elementen erreichen kann, kann dies zu einer Hemmung der Einheit f√ºhren, wenn versucht wird, den Arraywert im Inspektor anzuzeigen. </blockquote><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  Gehen Sie zum <em>Inspektor</em> .  Jetzt wurde unter der <em>Skriptkomponente "Netzstudie"</em> die Eigenschaft " <em>Vertices"</em> angezeigt.  Klicken Sie auf das Pfeilsymbol daneben.  Sie <code>Vector3</code> Array der <code>Vector3</code> Elemente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/feb/f83/fd0/febf83fd02d469734b73910b1769d670.gif"></div><br>  Sie k√∂nnen sehen, dass die Gr√∂√üe des Arrays 24 betr√§gt, dh es gibt Scheitelpunkte mit derselben Position!  Bevor Sie fortfahren, m√ºssen Sie <code>[HideInInspector]</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Warum gibt es 24 Eckpunkte?</b> <div class="spoiler_text">  Es gibt viele Theorien zu diesem Thema.  Die einfachste Antwort lautet jedoch: Der W√ºrfel hat sechs Seiten, und jede Seite besteht aus vier Eckpunkten, die eine Ebene bilden. <br><br>  Daher lautet die Berechnung wie folgt: 6 x 4 = 24 Eckpunkte. <br><br>  Sie k√∂nnen nach anderen Antworten suchen.  Im Moment ist es jedoch einfach zu wissen, dass einige Netze Scheitelpunkte haben, die dieselbe Position haben. </div></div><br>  <em>Ersetzen Sie</em> in <em>MeshStudy.cs</em> den <em>gesamten</em> Code in der <code>DoAction()</code> Funktion durch Folgendes: <br><br><pre> <code class="cs hljs">PullSimilarVertices(index, localPos);</code> </pre> <br>  Gehen wir in die <code>PullSimilarVertices()</code> -Funktion und f√ºgen Folgendes hinzu: <br><br><pre> <code class="cs hljs">Vector3 targetVertexPos = vertices[index]; <span class="hljs-comment"><span class="hljs-comment">//1 List&lt;int&gt; relatedVertices = FindRelatedVertices(targetVertexPos, false); //2 foreach (int i in relatedVertices) //3 { vertices[i] = newPos; } cMesh.vertices = vertices; //4 cMesh.RecalculateNormals();</span></span></code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  Wir erhalten die Position des Zielscheitelpunkts, der als Argument f√ºr die <code>FindRelatedVertices()</code> -Methode verwendet wird. </li><li>  Diese Methode gibt eine Liste von Indizes zur√ºck (die Scheitelpunkten entsprechen), die dieselbe Position wie der Zielscheitelpunkt haben. </li><li>  Die Schleife durchl√§uft die gesamte Liste und setzt die entsprechenden Eckpunkte auf <code>newPos</code> . </li><li>  <code>cMesh.vertices</code> aktualisierte <code>vertices</code> zu.  Dann rufen wir <code>RecalculateNormals()</code> auf, um das Netz mit den neuen Werten neu zu zeichnen. </li></ol><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  Ziehen Sie einen der Scheitelpunkte.  Jetzt sollte das Netz seine Form behalten und nicht kollabieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/66d/bcc/b1b66dbccb73ac3a8ad8c56594611919.gif"></div><br>  Nachdem wir den ersten Schritt zum Bearbeiten der Netze abgeschlossen haben, speichern Sie die Szene und fahren Sie mit dem n√§chsten Abschnitt fort. <br><br><h2>  Netzmanipulation </h2><br>  In diesem Abschnitt erfahren Sie, wie Sie Netze in Echtzeit bearbeiten.  Es gibt viele M√∂glichkeiten, aber in diesem Tutorial werden wir uns die einfachste Art der Netzmanipulation ansehen, n√§mlich das Verschieben der zuvor erstellten Netzscheitelpunkte. <br><br><h3>  Ausgew√§hlte Indizes sammeln </h3><br>  Beginnen wir mit der Auswahl der Eckpunkte, die wir in Echtzeit verschieben werden. <br><br>  √ñffnen Sie Szene <em>02 Herznetz</em> aus dem Ordner <em>Szenen</em> <em>erstellen</em> .  Im Szenenfenster sehen Sie eine rote Kugel.  W√§hlen Sie <em>Sphere</em> in the <em>Hierarchy</em> und gehen Sie zu <em>Inspector</em> .  Sie werden sehen, dass die <em>Heart Mesh-Skriptkomponente</em> an das Objekt angeh√§ngt ist. <br><br>  Jetzt ben√∂tigen wir das Editor-Skript f√ºr dieses Objekt, um die Eckpunkte des Netzes im Szenenfenster anzuzeigen.  Gehen Sie zum <em>Editor-</em> Ordner und <em>doppelklicken</em> Sie auf <em>HeartMeshInspector.cs</em> . <br><br>  <code>ShowHandle()</code> in der <code>ShowHandle()</code> -Funktion im <code>if</code> Block Folgendes hinzu: <br><br><pre> <code class="cs hljs">Handles.color = Color.blue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Handles.Button(point, handleRotation, mesh.pickSize, mesh.pickSize, Handles.DotHandleCap)) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.selectedIndices.Add(index); //2 }</span></span></code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  Legt die Eckpunkte des Netzes fest und zeigt sie als Typ <code>Handles.Button</code> . </li><li>  Wenn Sie darauf <code>mesh.selectedIndices</code> , wird der ausgew√§hlte Index zur <code>mesh.selectedIndices</code> der gedr√ºckten <code>mesh.selectedIndices</code> . </li></ol><br>  <code>OnInspectorGUI()</code> in <code>OnInspectorGUI()</code> vor der schlie√üenden Klammer Folgendes hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button(<span class="hljs-string"><span class="hljs-string">"Clear Selected Vertices"</span></span>)) { mesh.ClearAllData(); }</code> </pre> <br>  Erl√§uterung des Codes: Auf diese Weise f√ºgen wir dem <em>Inspektor</em> eine Schaltfl√§che zum Zur√ºcksetzen hinzu, um <code>mesh.ClearAllData()</code> . <br><br>  Speichern Sie die Datei und √∂ffnen Sie <em>HeartMesh.cs</em> im Ordner <em>Scripts</em> .  <code>ClearAllData()</code> Funktion <code>ClearAllData()</code> Folgendes hinzu: <br><br><pre> <code class="cs hljs">selectedIndices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); targetIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; targetVertex = Vector3.zero;</code> </pre> <br>  Code Erl√§uterung: Der Code l√∂scht die Werte in <code>selectedIndices</code> und <code>targetIndex</code> .  Au√üerdem wird <code>targetVertex</code> . <br><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  W√§hlen Sie <em>Sphere aus</em> und <em>rufen Sie</em> den <em>Inspector</em> f√ºr die <em>HeartMesh-Skriptkomponente auf</em> .  Erweitern Sie <em>Ausgew√§hlte Indizes,</em> indem Sie auf das Pfeilsymbol daneben klicken.  Auf diese Weise k√∂nnen wir jeden zur Liste hinzugef√ºgten Scheitelpunkt verfolgen. <br><br>  Aktivieren Sie <em>Ist Bearbeitungsmodus</em> √ºber das Kontrollk√§stchen daneben.  Aus diesem Grund werden die Eckpunkte des Netzes im Szenenfenster gezeichnet.  Durch Klicken auf die blauen Punkte in den <em>ausgew√§hlten Indizes</em> sollten die Werte entsprechend ge√§ndert werden.  Testen Sie auch die Schaltfl√§che <em>Ausgew√§hlte Scheitelpunkte l√∂schen</em> , um sicherzustellen, dass alle Werte <em>gel√∂scht</em> werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17a/271/dea/17a271dea970e9c3ade451773b87eb65.gif"></div><br>  <em>Hinweis:</em> Im ge√§nderten benutzerdefinierten <em>Inspektor</em> haben wir die M√∂glichkeit, den Transformationsmanipulator mithilfe des <em>Transformationshandles anzeigen ein-</em> / auszublenden.  Keine Panik, wenn Sie den Transformationsmanipulator in anderen Szenen nicht finden!  Schalten Sie es vor dem Beenden ein. <br><br><h3>  Eine Kugel in ein Herz verwandeln </h3><br>  Das √Ñndern von Netzscheitelpunkten in Echtzeit besteht im Wesentlichen aus drei Schritten: <br><br><ol><li>  Kopieren Sie die aktuellen <code>mVertices</code> (vor der Animation) nach <code>mVertices</code> . </li><li>  <code>mVertices</code> Berechnungen durch und √§ndern die Werte in <code>mVertices</code> . </li><li>  Aktualisieren Sie die aktuellen <code>mVertices</code> mit <code>mVertices</code> wenn Sie sie bei jedem Schritt √§ndern, und lassen Sie Unity die Normalen automatisch berechnen. </li></ol><br>  √ñffnen Sie <em>HeartMesh.cs</em> und die folgenden Variablen vor der Funktion <code>Start()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radiusofeffect = <span class="hljs-number"><span class="hljs-number">0.3f</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 public float pullvalue = 0.3f; //2 public float duration = 1.2f; //3 int currentIndex = 0; //4 bool isAnimate = false; float starttime = 0f; float runtime = 0f;</span></span></code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  Der Radius des vom Zielscheitelpunkt betroffenen Bereichs. </li><li>  Kraft ziehen. </li><li>  Die Dauer der Animation. </li><li>  Der aktuelle Index der Liste <code>selectedIndices</code> . </li></ol><br>  <code>Init()</code> Funktion <code>Init()</code> vor dem <code>if</code> Block Folgendes hinzu: <br><br><pre> <code class="cs hljs">currentIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Erl√§uterung des Codes: Zu Beginn des Spiels wird <code>currentIndex</code> auf 0 gesetzt, den ersten Index der Liste <code>selectedIndices</code> . <br><br>  <code>Init()</code> derselben <code>Init()</code> Funktion vor der schlie√üenden Klammer des <code>else</code> Blocks Folgendes hinzu: <br><br><pre> <code class="cs hljs">StartDisplacement();</code> </pre> <br>  <code>StartDisplacement()</code> : F√ºhren Sie die Funktion <code>StartDisplacement()</code> aus, wenn <code>isEditMode</code> false ist. <br><br>  <code>StartDisplacement()</code> Funktion <code>StartDisplacement()</code> Folgendes hinzu: <br><br><pre> <code class="cs hljs">targetVertex = oVertices[selectedIndices[currentIndex]]; <span class="hljs-comment"><span class="hljs-comment">//1 starttime = Time.time; //2 isAnimate = true;</span></span></code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  W√§hlen Sie <code>targetVertex</code> , um die Animation zu starten. </li><li>  <code>isAnimate</code> Sie die Startzeit ein und √§ndern Sie den Wert von <code>isAnimate</code> in true. </li></ol><br>  Erstellen Sie nach der Funktion <code>StartDisplacement()</code> Funktion <code>FixedUpdate()</code> mit dem folgenden Code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//1 { if (!isAnimate) //2 { return; } runtime = Time.time - starttime; //3 if (runtime &lt; duration) //4 { Vector3 targetVertexPos = oFilter.transform.InverseTransformPoint(targetVertex); DisplaceVertices(targetVertexPos, pullvalue, radiusofeffect); } else //5 { currentIndex++; if (currentIndex &lt; selectedIndices.Count) //6 { StartDisplacement(); } else //7 { oMesh = GetComponent&lt;MeshFilter&gt;().mesh; isAnimate = false; isMeshReady = true; } } }</span></span></span></span></code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  Die Funktion <code>FixedUpdate()</code> wird in einer festen FPS-Schleife ausgef√ºhrt. </li><li>  Wenn <code>isAnimate</code> false ist, √ºberspringen Sie den folgenden Code. </li><li>  <code>runtime</code> √§ndern. </li><li>  Wenn die <code>runtime</code> innerhalb der <code>duration</code> , erhalten wir die Weltkoordinaten von <code>targetVertex</code> und <code>DisplaceVertices()</code> , wobei der Zielscheitelpunkt mit den <code>radiusofeffect</code> <code>pullvalue</code> und <code>radiusofeffect</code> . </li><li>  Ansonsten ist die Zeit abgelaufen.  F√ºgen Sie einen zu <code>currentIndex</code> . </li><li>  √úberpr√ºfen Sie, ob <code>currentIndex</code> zu <code>selectedIndices</code> .  Gehen Sie mit <code>StartDisplacement()</code> zum n√§chsten Scheitelpunkt in der Liste. </li><li>  Andernfalls √§ndern <code>oMesh</code> am Ende der Liste die <code>oMesh</code> Daten in das aktuelle Netz und <code>isAnimate</code> auf false, um die Animation zu stoppen. </li></ol><br>  <code>DisplaceVertices()</code> in <code>DisplaceVertices()</code> Folgendes hinzu: <br><br><pre> <code class="cs hljs">Vector3 currentVertexPos = Vector3.zero; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sqrRadius = radius * radius; <span class="hljs-comment"><span class="hljs-comment">//1 for (int i = 0; i &lt; mVertices.Length; i++) //2 { currentVertexPos = mVertices[i]; float sqrMagnitute = (currentVertexPos - targetVertexPos).sqrMagnitude; //3 if (sqrMagnitute &gt; sqrRadius) { continue; //4 } float distance = Mathf.Sqrt(sqrMagnitute); //5 float falloff = GaussFalloff(distance, radius); Vector3 translate = (currentVertexPos * force) * falloff; //6 translate.z = 0f; Quaternion rotation = Quaternion.Euler(translate); Matrix4x4 m = Matrix4x4.TRS(translate, rotation, Vector3.one); mVertices[i] = m.MultiplyPoint3x4(currentVertexPos); } oMesh.vertices = mVertices; //7 oMesh.RecalculateNormals();</span></span></code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  Das Quadrat des Radius. </li><li>  Wir durchlaufen jeden Scheitelpunkt des Netzes. </li><li>  <code>sqrMagnitude</code> zwischen <code>currentVertexPos</code> und <code>targetVertexPos</code> . </li><li>  Wenn <code>sqrMagnitude</code> √ºberschreitet, fahren Sie mit dem n√§chsten Scheitelpunkt fort. </li><li>  Andernfalls bestimmen Sie den <code>falloff</code> , der vom <code>distance</code> aktuellen Scheitelpunkts vom Mittelpunkt des <code>falloff</code> abh√§ngt. </li><li>  <code>Vector3</code> neue <code>Vector3</code> Position und wenden Sie ihre Transformation auf den aktuellen Scheitelpunkt an. </li><li>  Wenn Sie die Schleife verlassen, weisen wir den <code>mVertices</code> die ge√§nderten <code>mVertices</code> Werte zu und erzwingen, dass Unity die Normalen neu berechnet. </li></ol><br><blockquote>  <em>Quelle der Falloff-Technologie</em> <br>  Die urspr√ºngliche Formel stammt aus der Asset-Paketdatei " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Verfahrensbeispiele"</a> , die kostenlos aus dem Unity Asset Store heruntergeladen werden kann. </blockquote><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  W√§hlen Sie <em>Sphere aus</em> , <em>wechseln</em> Sie zur <em>HeartMesh-</em> Komponente und versuchen Sie, der Eigenschaft <em>Selected Indices</em> einige Scheitelpunkte hinzuzuf√ºgen.  Deaktivieren Sie den <em>Bearbeitungsmodus</em> und klicken Sie auf <em>Wiedergabe</em> , um das Ergebnis Ihrer Arbeit anzuzeigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1e/527/23b/e1e52723b08453591da6d10a28dbe13d.gif"></div><br>  Experimentieren Sie mit den Werten f√ºr <em>Radiusofeffekt</em> , <em>Pullvalue</em> und <em>Dauer</em> , um unterschiedliche Ergebnisse zu erhalten.  Wenn Sie bereit sind, √§ndern Sie die Einstellungen gem√§√ü dem folgenden Screenshot. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a63/c44/082/a63c44082183529e737f287cb746dfd6.png"></div><br>  Klicken Sie auf <em>Spielen</em> .  Hat sich deine Kugel in ein Herz verwandelt? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/532/c83/ce5532c83ff152100775d62091370bf2.gif"></div><br>  Gl√ºckwunsch!  Im n√§chsten Abschnitt speichern wir das Netz als Fertighaus f√ºr die zuk√ºnftige Verwendung. <br><br><h3>  Speichern des Netzes in Echtzeit </h3><br>  Um ein herzf√∂rmiges prozedurales Netz im Wiedergabemodus zu speichern, m√ºssen Sie ein Fertighaus vorbereiten, dessen Kind ein 3D-Objekt ist, und dann sein Netzelement mithilfe eines Skripts durch ein neues ersetzen. <br><br>  Suchen <em>Sie</em> im <em>Projektfenster</em> <em>CustomHeart</em> im Ordner <em>Prefabs</em> .  Klicken Sie auf das Pfeilsymbol, um den Inhalt zu erweitern, und w√§hlen Sie <em>Kind aus</em> .  Sie sehen jetzt ein Sphere-Objekt im <em>Inspektor-</em> Vorschaufenster.  Dies ist das Fertighaus, in dem die Daten f√ºr das neue Netz gespeichert werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a3/f07/048/9a3f070486f3a66ee56304dae5bd2b12.png"></div><br>  √ñffnen Sie <em>HeartMeshInspector.cs</em> .  <code>OnInspectorGUI()</code> Funktion <code>OnInspectorGUI()</code> vor der schlie√üenden Klammer Folgendes hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mesh.isEditMode &amp;&amp; mesh.isMeshReady) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = <span class="hljs-string"><span class="hljs-string">"Assets/Prefabs/CustomHeart.prefab"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 if (GUILayout.Button("Save Mesh")) { mesh.isMeshReady = false; Object pfObj = AssetDatabase.LoadAssetAtPath(path, typeof(GameObject)); //2 Object pfRef = AssetDatabase.LoadAssetAtPath (path, typeof(GameObject)); GameObject gameObj = (GameObject)PrefabUtility.InstantiatePrefab(pfObj); Mesh pfMesh = (Mesh)AssetDatabase.LoadAssetAtPath(path, typeof(Mesh)); //3 if (!pfMesh) { pfMesh = new Mesh(); } else { pfMesh.Clear(); } pfMesh = mesh.SaveMesh(); //4 AssetDatabase.AddObjectToAsset(pfMesh, path); gameObj.GetComponentInChildren&lt;MeshFilter&gt;().mesh = pfMesh; //5 PrefabUtility.ReplacePrefab(gameObj, pfRef, ReplacePrefabOptions.Default); //6 Object.DestroyImmediate(gameObj); //7 } }</span></span></code> </pre> <br>  Code Erl√§uterung: <br><br><ol><li>  Legt den <code>path</code> zum Pfad zum CustomHeart- <em>Fertighausobjekt fest</em> . </li><li>  Erstellt zwei Objekte aus dem CustomHeart- <em>Fertighaus</em> , eines zum Erstellen einer Instanz als GameObject ( <code>pfObj</code> ) und das zweite als Links ( <code>pfRef</code> ). </li><li>  Erstellt <em>eine</em> Instanz des pfMesh-Mesh- <code>pfMesh</code> .  Wenn es nicht gefunden wird, wird ein neues Netz erstellt, andernfalls werden die vorhandenen Daten bereinigt. </li><li>  <code>pfMesh</code> mit neuen <code>pfMesh</code> und f√ºgt sie dann <em>CustomHeart</em> als Asset <em>hinzu</em> . <br></li><li>  F√ºllt ein Mesh-Asset in <code>gameObj</code> Wert <code>pfMesh</code> . </li><li>  Ersetzt <em>CustomHeart</em> durch <code>gameObj</code> bereits vorhandene Verbindungen <code>gameObj</code> . </li><li>  <code>gameObj</code> . </li></ol><br>  Speichern Sie die Datei und gehen Sie zu <em>HeartMesh.cs</em> .  <code>SaveMesh()</code> in der allgemeinen <code>SaveMesh()</code> -Methode nach dem Erstellen der <code>nMesh</code> Instanz Folgendes hinzu: <br><br><pre> <code class="cs hljs">nMesh.name = <span class="hljs-string"><span class="hljs-string">"HeartMesh"</span></span>; nMesh.vertices = oMesh.vertices; nMesh.triangles = oMesh.triangles; nMesh.normals = oMesh.normals;</code> </pre> <br>  Code Erl√§uterung: Gibt ein Netzelement mit Werten aus einem herzf√∂rmigen Netz zur√ºck. <br><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  Klicken Sie auf <em>Wiedergabe</em> .  Nach Abschluss der Animation wird im <em>Inspektor die</em> Schaltfl√§che <em>Netz speichern angezeigt</em> .  Klicken Sie auf die Schaltfl√§che, um das neue Netz zu speichern, und stoppen Sie den Player. <br><br>  Gehen Sie zum Ordner <em>Prefabs</em> und sehen Sie sich das CustomHeart- <em>Prefab an</em> .  Sie sollten sehen, dass es jetzt im CustomHeart- <em>Fertighausobjekt</em> ein v√∂llig neues herzf√∂rmiges Netz gibt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/126/dee/103/126dee103ce798611d2dc2e94013c23c.png"></div><br>  <i>Ausgezeichnete Arbeit!</i> <br><br><h2>  Alles zusammenf√ºgen </h2><br>  In der vorherigen Szene verwendete die Funktion <code>DisplaceVertices()</code> die Falloff-Formel, um die Widerstandskraft zu bestimmen, die auf jeden Scheitelpunkt innerhalb eines bestimmten Radius angewendet wurde.  Der Punkt des ‚ÄûAbfalls‚Äú, an dem die Widerstandskraft abzunehmen beginnt, h√§ngt von der Art des verwendeten Abfalls ab: Linear, Gau√ü oder Nadel.  Jeder Typ erzeugt unterschiedliche Ergebnisse im Netz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/284/9c0/9ff2849c0d0fe5f9d496d641c07e35d8.png"></div><br>  In diesem Abschnitt sehen wir uns eine andere M√∂glichkeit an, Scheitelpunkte zu bearbeiten: die Verwendung einer bestimmten Kurve.  Unter der Regel, dass die Geschwindigkeit gleich der durch die Zeit geteilten Entfernung (d = (v / t)) ist, k√∂nnen wir die Position des Vektors anhand seiner durch die Zeit geteilten Entfernung bestimmen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/2d6/13c/3b82d613cedaf85e12db66beb6349201.gif"></div><br><h3>  Verwenden der Kurvenmethode </h3><br>  Speichern Sie die aktuelle Szene und √∂ffnen Sie <em>03 Customize Heart Mesh</em> aus dem Ordner <em>Scenes</em> .  Sie sehen eine <em>Hierarchieinstanz</em> des CustomHeart- <em>Fertighauses</em> .  Klicken Sie auf das Pfeilsymbol daneben, um den Inhalt zu erweitern, und w√§hlen Sie <em>Kind aus</em> . <br><br>  Zeigen Sie die Eigenschaften im <em>Inspektor an</em> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie sehen die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Netzfilterkomponente</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heart Mesh</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asset </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">H√§ngen Sie </font><font style="vertical-align: inherit;">ein </font><em><font style="vertical-align: inherit;">benutzerdefiniertes</font></em><font style="vertical-align: inherit;"> Herzskript </font><font style="vertical-align: inherit;">als Komponente </font><font style="vertical-align: inherit;">an </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Child</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jetzt sollte das Asset von </font><em><font style="vertical-align: inherit;">HeartMesh</font></em><font style="vertical-align: inherit;"> zu </font><em><font style="vertical-align: inherit;">Klon</font></em><font style="vertical-align: inherit;"> wechseln </font><font style="vertical-align: inherit;">.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/954/27f/89d/95427f89d17410e26893a0ec27dff51d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ñffnen Sie anschlie√üend </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomHeart.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Ordner </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scripts</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">F√ºgen Sie vor der Funktion </font></font><code>Start()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgendes hinzu:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CurveType { Curve1, Curve2 } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CurveType curveType; Curve curve;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erl√§uterung des Codes: Hier wird eine allgemeine Aufz√§hlung unter dem Namen erstellt </font></font><code>CurveType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nach der sie vom </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspektor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur Verf√ºgung gestellt wird </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen Sie zu </font></font><code>CurveType1()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und f√ºgen Sie Folgendes hinzu:</font></font><br><br><pre> <code class="cs hljs">Vector3[] curvepoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//1 curvepoints[0] = new Vector3(0, 1, 0); curvepoints[1] = new Vector3(0.5f, 0.5f, 0); curvepoints[2] = new Vector3(1, 0, 0); curve = new Curve(curvepoints[0], curvepoints[1], curvepoints[2], false); //2</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code Erl√§uterung: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine einfache Kurve besteht aus drei Punkten. </font><font style="vertical-align: inherit;">Stellen Sie die Punkte f√ºr die erste Kurve ein.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Hilfe der Hilfe erzeugen wir die erste Kurve </font></font><code>Curve()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und weisen ihre Werte zu </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die gezeichnete Kurve kann in der Vorschau angezeigt werden, wenn Sie als letzten Parameter true angeben.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen Sie zu </font></font><code>CurveType2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und f√ºgen Sie Folgendes hinzu:</font></font><br><br><pre> <code class="cs hljs">Vector3[] curvepoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//1 curvepoints[0] = new Vector3(0, 0, 0); curvepoints[1] = new Vector3(0.5f, 1, 0); curvepoints[2] = new Vector3(1, 0, 0); curve = new Curve(curvepoints[0], curvepoints[1], curvepoints[2], false); //2</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code Erl√§uterung: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen Sie die Punkte f√ºr die zweite Kurve ein. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erzeugen die zweite Kurve mit </font></font><code>Curve()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und weisen ihre Werte zu </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die gezeichnete Kurve kann in der Vorschau angezeigt werden, wenn Sie als letzten Parameter true angeben.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><code>StartDisplacement()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie vor der schlie√üenden Klammer Folgendes hinzu:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curveType == CurveType.Curve1) { CurveType1(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curveType == CurveType.Curve2) { CurveType2(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codeerkl√§rung: Hier √ºberpr√ºfen wir die vom Benutzer ausgew√§hlte Option </font></font><code>curveType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und generieren sie entsprechend </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><code>DisplaceVertices()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºgen Sie </font><font style="vertical-align: inherit;">in der Schleifenanweisung </font><font style="vertical-align: inherit;">vor den schlie√üenden Klammern Folgendes hinzu:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> increment = curve.GetPoint(distance).y * force; <span class="hljs-comment"><span class="hljs-comment">//1 Vector3 translate = (vert * increment) * Time.deltaTime; //2 Quaternion rotation = Quaternion.Euler(translate); Matrix4x4 m = Matrix4x4.TRS(translate, rotation, Vector3.one); mVertices[i] = m.MultiplyPoint3x4(mVertices[i]);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code Erl√§uterung: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir </font><font style="vertical-align: inherit;">erhalten die </font><font style="vertical-align: inherit;">Position der Kurve bei der gegebenen </font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und multiplizieren ihren Wert </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit </font></font><code>force</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um zu erhalten </font></font><code>increment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie einen neuen Datentyp </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die neue Position des aktuellen Scheitelpunkts zu speichern, und wenden Sie dessen Transformation entsprechend an.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern Sie die Datei und kehren Sie zu Unity zur√ºck. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie </font><font style="vertical-align: inherit;">die Eigenschaften des Bauteils </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomHeart</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spielobjekt </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kind</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hier finden Sie </font><font style="vertical-align: inherit;">eine Dropdown-Liste sehen , </font><font style="vertical-align: inherit;">wo Sie ausw√§hlen k√∂nnen , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Kurve den Typ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In der Dropdown- </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typen bearbeiten</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> w√§hlen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hinzuf√ºgen Indizes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Remove - </font><font style="vertical-align: inherit;">Indizes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die Liste der Eckpunkt zu aktualisieren und mit verschiedenen Einstellungen zu experimentieren.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/1a7/3b6/7921a73b676b205bd33ec1db076cd4a6.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geben Sie die Werte gem√§√ü dem Screenshot ein, um detaillierte Ergebnisse f√ºr verschiedene Kurventypen anzuzeigen: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/ab3/e5d/e06ab3e5d0bfc950be0c6dbc82d36f6e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Liste der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurventyp</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , w√§hlen Sie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curve1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , stellen Sie </font><font style="vertical-align: inherit;">sicher , </font><font style="vertical-align: inherit;">zu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bearbeiten Typ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> w√§hlen Sie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und klicken Sie auf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Play</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie sollten sehen, dass das Netz in das Muster abweicht. </font><font style="vertical-align: inherit;">Rollen Sie das Modell, um es in der Seitenansicht zu sehen, und vergleichen Sie die Ergebnisse f√ºr beide Kurventypen. </font><font style="vertical-align: inherit;">Hier sehen Sie, wie sich der ausgew√§hlte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurventyp</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf den Netzversatz auswirkt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/f90/4d5/8e1f904d50987247014011ac32261134.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da0/e1a/df4/da0e1adf49f8503188f47826c4079cf1.png"></div><br>  Das ist alles!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen auf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgew√§hlte Scheitelpunkte l√∂schen klicken</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgew√§hlte Indizes zur√ºckzusetzen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und mit Ihren eigenen Mustern zu experimentieren. </font><font style="vertical-align: inherit;">Vergessen Sie jedoch nicht, dass es andere Faktoren gibt, die das Endergebnis des Netzes beeinflussen, n√§mlich:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Wert des Radius. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Verteilung der Eckpunkte im Bereich. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Musterposition der ausgew√§hlten Scheitelpunkte. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die f√ºr den Offset ausgew√§hlte Methode. </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wohin als n√§chstes? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dateien des fertigen Projekts befinden sich im </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Archiv des</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lernprojekts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂r hier nicht auf! </font><font style="vertical-align: inherit;">Probieren Sie die komplexeren Techniken aus, die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lernprogramm zur Erstellung von </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Unity Procedural Maze verwendet werden</font></a><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe, Ihnen hat dieses Tutorial gefallen und Sie fanden die Informationen hilfreich. </font><font style="vertical-align: inherit;">Ein besonderer Dank spricht </font><font style="vertical-align: inherit;">ich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jasper Flick</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catlike Coding</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr seine hervorragend Tutorials , </font><font style="vertical-align: inherit;">die mir geholfen , </font><font style="vertical-align: inherit;">eine Demo f√ºr mein Projekt zusammenzustellen .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/190/e37/362/190e3736241796c39eac74bbe3ddc86e.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428796/">https://habr.com/ru/post/de428796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428786/index.html">Quantenprozessor basierend auf Spinresonanz und Manipulationen mit einem Singulett-Triplett-System</a></li>
<li><a href="../de428788/index.html">Unter der Haube von Bitfury Clarke - wie unser neuer Mining-Chip funktioniert</a></li>
<li><a href="../de428790/index.html">Wir schreiben einen Bot-Chat f√ºr VKontakte in Python mit Longpoll. Teil Zwei Doppelschleifen, Ausnahmen und andere H√§resien</a></li>
<li><a href="../de428792/index.html">Der neue Apple T2-Chip macht es schwierig, √ºber das eingebaute Mikrofon des Laptops zu h√∂ren</a></li>
<li><a href="../de428794/index.html">√úberblick √ºber die grundlegenden Methoden der mathematischen Optimierung bei Problemen mit Einschr√§nkungen</a></li>
<li><a href="../de428798/index.html">Wie man einen Indie-Entwickler √ºberlebt. Teil 2</a></li>
<li><a href="../de428800/index.html">Perfektes CSS kochen</a></li>
<li><a href="../de428806/index.html">Consumer Check Analysis: Was sie bei Amazon kaufen</a></li>
<li><a href="../de428808/index.html">Wenig Bequemlichkeit im Studentenleben</a></li>
<li><a href="../de428810/index.html">18 Materialien zur digitalen Technologie in Audio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>