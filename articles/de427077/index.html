<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéµ ‚ûï üìô Laplace-Unsch√§rfe - Ist es m√∂glich, Laplace anstelle von Gau√ü zu blubbern, wie oft ist es schneller und ist es den Verlust von 1/32 Genauigkeit wert? ü§úüèº ‚úíÔ∏è üïô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Unsch√§rfe" bei gew√∂hnlichen Menschen ist ein Unsch√§rfeeffekt in der digitalen Bildverarbeitung. Es kann an sich und als Bestandteil von Schnittstelle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Laplace-Unsch√§rfe - Ist es m√∂glich, Laplace anstelle von Gau√ü zu blubbern, wie oft ist es schneller und ist es den Verlust von 1/32 Genauigkeit wert?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427077/"><img src="https://habrastorage.org/webt/ge/pb/p3/gepbp3bpdluk4yg0-xzbn0via3y.jpeg" alt="Bild"><br><br>  "Unsch√§rfe" bei gew√∂hnlichen Menschen ist ein Unsch√§rfeeffekt in der digitalen Bildverarbeitung.  Es kann an sich und als Bestandteil von Schnittstellenanimationen oder komplexeren abgeleiteten Effekten (Bloom / FocusBlur / MotionBlur) sehr effektiv sein.  Bei alledem ist ehrlicher Blues in der Stirn eher langsam.  Und oft lassen die in die Zielplattform integrierten Implementierungen zu w√ºnschen √ºbrig.  Entweder ist die Geschwindigkeit traurig, die Artefakte verletzen die Augen.  Die Situation f√ºhrt zu vielen Kompromissimplementierungen, die f√ºr bestimmte Bedingungen besser oder schlechter geeignet sind.  Eine originelle Implementierung mit guter Zuverl√§ssigkeitsqualit√§t und h√∂chster Geschwindigkeit, w√§hrend die geringste Abh√§ngigkeit von Hardware unter dem Strich auf Sie wartet.  Guten Appetit! <br><a name="habracut"></a><br>  (Laplace Blur - Vorgeschlagener urspr√ºnglicher Algorithmusname) <br><br>  Heute hat mich meine interne Demoszene getreten und mich gezwungen, einen Artikel zu schreiben, der vor sechs Monaten geschrieben werden musste.  Als Amateur m√∂chte ich der √ñffentlichkeit in aller Ruhe einen ‚Äûfast gausischen Blurah‚Äú -Algorithmus anbieten, der durch die Verwendung au√üergew√∂hnlich schneller Prozessoranweisungen (Verschiebungen und Masken) gekennzeichnet ist und daher f√ºr die Implementierung bis zu Mikrocontrollern zug√§nglich ist (extrem schnell in einer begrenzten Umgebung). <br><br>  Gem√§√ü meiner Tradition, Artikel √ºber Habr zu schreiben, werde ich Beispiele in JS als beliebteste Sprache nennen und ob Sie es glauben oder nicht, es ist sehr praktisch f√ºr den Zweck des Rapid Prototyping von Algorithmen.  Dar√ºber hinaus war die M√∂glichkeit, dies effektiv in JS zu implementieren, mit typisierten Arrays verbunden.  Auf meinem nicht sehr leistungsstarken Laptop wird das Vollbild mit einer Geschwindigkeit von 30 fps verarbeitet (Multithreading von Arbeitern war nicht beteiligt). <br><br><div class="spoiler">  <b class="spoiler_title">Haftungsausschluss f√ºr Cool Maths</b> <div class="spoiler_text">  Ich werde sofort sagen, dass ich meinen Hut abnehme, weil ich mich in der Grundmathematik als nicht versiert genug betrachte.  Ich lasse mich jedoch immer vom allgemeinen Geist eines grundlegenden Ansatzes leiten.  Bevor Sie meinen etwas ‚Äûbeobachtenden‚Äú Ansatz zur Approximation betr√ºgen, m√ºssen Sie daher die Bitkomplexit√§t des Algorithmus berechnen, die, wie Sie denken, mit klassischen polynomiellen Approximationsmethoden erhalten werden kann.  Ich habe richtig geraten?  Sie wollten sie schnell approximieren?  Da sie eine schwebende Arithmetik erfordern, sind sie erheblich langsamer als eine einzelne Bitverschiebung, die ich am Ende erl√§utern werde.  Mit einem Wort, beeilen Sie sich nicht zum theoretischen Fundamentalismus und vergessen Sie nicht den Kontext, in dem ich das Problem l√∂se. <br></div></div><br>  Diese Beschreibung ist hier eher vorhanden, um den Verlauf meiner Gedanken und Vermutungen zu erkl√§ren, die mich zum Ergebnis gef√ºhrt haben.  F√ºr diejenigen, die interessiert sein werden: <br><br>  Urspr√ºngliche Gau√ü-Funktion: <br><br><img src="https://habrastorage.org/webt/63/h0/km/63h0kmf5xougnx-tcp05_esii1y.png" alt="Bild"><br><br>  g (x) = a * e ** (- ((xb) ** 2) / c), wobei <br>  a ist die Amplitude (wenn wir acht Farbbits pro Kanal haben, dann ist es = 256) <br>  e ist die Eulerkonstante ~ 2.7 <br>  b - Graphverschiebung in x (wir brauchen nicht = 0) <br>  c - Parameter, der die Breite des damit verbundenen Diagramms beeinflusst, als ~ w / 2.35 <br><br>  Unsere private Funktion (minus vom Exponenten, der durch Ersetzen der Multiplikation durch Division entfernt wurde): <br><br><img src="https://habrastorage.org/webt/rj/o-/ns/rjo-nsq8o1nptsuyrbhpit1ozkw.png" alt="Bild"><br><br>  g (x) = 256 / e ** (x * x / c) <br><br>  Lassen Sie die schmutzige Approximationsaktion beginnen: <br>  Beachten Sie, dass Parameter c sehr nahe an der halben Breite liegt und 8 eingestellt ist (dies liegt daran, wie viele Schritte Sie jeweils um einen 8-Bit-Kanal verschieben k√∂nnen). <br><br>  Wir ersetzen e auch grob durch 2, wobei wir jedoch feststellen, dass dies die Kr√ºmmung der ‚ÄûGlocke‚Äú st√§rker beeinflusst als ihre Grenzen.  Eigentlich betrifft es 2 / e-mal, aber die √úberraschung ist, dass dieser Fehler den Parameter c kompensiert, so dass die Randbedingungen noch in Ordnung sind und der Fehler nur in einer leicht falschen ‚ÄûNormalverteilung‚Äú f√ºr die Grafik erscheint Algorithmen, dies wird die Dynamik von Farbverl√§ufen mit Farbverl√§ufen beeinflussen, aber es ist fast unm√∂glich, mit dem Auge zu bemerken. <br><br>  Unsere Funktion lautet nun wie folgt: <br>  gg (x) = 256/2 ** (x * x / 8) oder gg (x) = 2 ** (8 - x * x / 8) <br>  Es ist zu beachten, dass der Exponent (x * x / 8) den gleichen Wertebereich [0-8] wie die Funktion eines Abs (x) niedrigerer Ordnung hat, daher ist letzterer ein Kandidat f√ºr eine Ersetzung.  Wir werden die Vermutung schnell √ºberpr√ºfen, indem wir uns ansehen, wie sich der Graph damit √§ndert. Gg (x) = 256 / (2 ** abs (x)): <br><br>  GaussBlur gegen LaplasBlur: <br><br><img src="https://habrastorage.org/webt/ri/9m/wn/ri9mwnl06vzoim4atrlhnyi5wye.png" alt="Bild"><br><br>  Abweichungen scheinen zu gro√ü zu sein, au√üerdem hat die Funktion, die ihre Gl√§tte verloren hat, jetzt einen H√∂hepunkt.  Aber hey. <br><br>  Vergessen wir zun√§chst nicht, dass die Gl√§tte der durch Unsch√§rfe erhaltenen Gradienten nicht von der Wahrscheinlichkeitsdichtefunktion (der Gau√ü-Funktion) abh√§ngt, sondern von ihrem Integral - der Verteilungsfunktion.  Zu dieser Zeit kannte ich diese Tatsache nicht, aber nachdem ich eine ‚Äûdestruktive‚Äú N√§herung in Bezug auf die Wahrscheinlichkeitsdichtefunktion (Gau√ü) durchgef√ºhrt hatte, blieb die Verteilungsfunktion ziemlich √§hnlich. <br><br>  Es war: <br><br><img src="https://habrastorage.org/webt/gj/nl/_l/gjnl_lzdrv_e_yvi87kxcrnu-e4.png" alt="Bild"><br><br>  Es wurde: <br><br><img src="https://habrastorage.org/webt/le/nw/te/lenwteibjhhx9mwosint393sgjo.png" alt="Bild"><br><br>  Der Beweis, der dem vorgefertigten Algorithmus entnommen wurde, stimmt √ºberein: <br><br><img src="https://habrastorage.org/webt/lg/ly/bm/lglybmx2fx4-rtff1eq_natuodm.png" alt="Bild"><br><br>  (Mit Blick auf die Zukunft werde ich sagen, dass der Unsch√§rfefehler meines Algorithmus in Bezug auf Gausian x5 nur 3% betrug.) <br><br>  Wir sind also der Laplace-Verteilungsfunktion viel n√§her gekommen.  Wer h√§tte das gedacht, aber sie k√∂nnen die Bilder zu 97% nicht schlechter waschen. <br><br>  Beweis, Unterschiede Gausian Blura x5 und "Laplace Blura" x7: <br><br><img src="https://habrastorage.org/webt/qy/1g/z1/qy1gz1d0fahnsbstiqwijj-rb3y.png" alt="Bild"><br><br>  (Dies ist kein schwarzes Bild! Sie k√∂nnen im Editor studieren) <br><br>  Die Annahme dieser Transformation erm√∂glichte es uns, zu der Idee √ºberzugehen, den Wert durch iterative Filterung zu erhalten, auf die ich zun√§chst reduzieren wollte. <br><br>  Bevor ich einen bestimmten Algorithmus erz√§hle, ist es ehrlich, wenn ich vorauslaufe und sofort seinen einzigen Nachteil beschreibe (obwohl die Implementierung mit einem Geschwindigkeitsverlust behoben werden kann).  Dieser Algorithmus wird jedoch unter Verwendung von Scherarithmetik implementiert, und Potenzen von 2 sind seine Begrenzung.  Das Original verwischt also x7 (was in Tests am ehesten mit Gausian x5 zusammenh√§ngt).  Diese Implementierungsbeschr√§nkung ist auf die Tatsache zur√ºckzuf√ºhren, dass bei einer 8-Bit-Farbe, bei der der Wert im Filterantrieb um ein Bit pro Schritt verschoben wird, jede Aktion vom Punkt aus in maximal 8 Schritten endet.  Ich habe auch eine etwas langsamere Version durch Proportionen und zus√§tzliche Erg√§nzungen implementiert, die eine schnelle Division durch 1,5 implementiert (was zu einem Radius von x15 f√ºhrt).  Mit der weiteren Anwendung dieses Ansatzes steigt jedoch der Fehler und die Geschwindigkeit sinkt, was eine solche Verwendung nicht zul√§sst.  Andererseits ist anzumerken, dass x15 bereits ausreicht, um den Unterschied nicht zu bemerken. Das Ergebnis wird aus dem Original oder aus dem heruntergetasteten Bild erhalten.  Die Methode eignet sich daher gut, wenn Sie in einer begrenzten Umgebung eine au√üergew√∂hnliche Geschwindigkeit ben√∂tigen. <br><br>  Der Kern des Algorithmus ist also einfach: Es werden vier Durchg√§nge desselben Typs ausgef√ºhrt: <br><br>  1. Die H√§lfte des Wertes des Laufwerks t (anf√§nglich gleich Null) wird zur H√§lfte des Wertes des n√§chsten Pixels addiert, das Ergebnis wird ihm zugewiesen.  Fahren Sie auf diese Weise bis zum Ende der Bildzeile fort.  F√ºr alle Zeilen. <br><br>  Nach Abschluss des ersten Durchgangs wird das Bild in eine Richtung unscharf. <br><br>  2. Beim zweiten Durchgang machen wir f√ºr alle Linien dasselbe in die entgegengesetzte Richtung. <br>  Wir erhalten ein Bild, das horizontal vollst√§ndig unscharf ist. <br><br>  3-4.  Machen Sie jetzt dasselbe vertikal. <br>  Fertig! <br><br>  Anfangs habe ich einen Zwei-Pass-Algorithmus mit der Implementierung von Back-Blur durch den Stack verwendet, aber es ist schwer zu verstehen, nicht anmutig, und es stellte sich heraus, dass es auf aktuellen Architekturen langsamer ist.  M√∂glicherweise ist der One-Pass-Algorithmus auf Mikrocontrollern schneller, und die M√∂glichkeit, das Ergebnis schrittweise auszugeben, ist ebenfalls von Vorteil. <br><br>  Bei der aktuellen Vier-Wege-Implementierungsmethode habe ich mir Habr√© vom vorherigen Guru √ºber Unsch√§rfealgorithmen angesehen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com/post/151157</a> Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nutze</a> diese Gelegenheit, um ihm meine Solidarit√§t und tiefe Dankbarkeit auszudr√ºcken. <br><br>  Aber die Hacks endeten nicht dort.  Nun erfahren Sie, wie Sie alle drei Farbkan√§le in einer Prozessoranweisung berechnen!  Tatsache ist, dass Sie mit der Bitverschiebung, die als Division durch zwei verwendet wird, die Position der Ergebnisbits sehr gut steuern k√∂nnen.  Das einzige Problem besteht darin, dass die unteren Bits der Kan√§le in benachbarte h√∂here Bits verschoben werden. Sie k√∂nnen sie jedoch einfach zur√ºcksetzen, um das Problem mit einem gewissen Genauigkeitsverlust zu beheben.  Und gem√§√ü der beschriebenen Filterformel f√ºhrt die Addition des halben Wertes des Laufwerks mit dem halben Wert der n√§chsten Zelle (vorbehaltlich des Zur√ºcksetzens der entladenen Bits) niemals zu einem √úberlauf, sodass Sie sich dar√ºber keine Sorgen machen sollten.  Und die Filterformel f√ºr die gleichzeitige Berechnung aller Ziffern lautet wie folgt: <br><br>  buf32 [i] = t = (((t &gt;&gt; 1) &amp; 0x7F7F7F) + ((buf32 [i] &gt;&gt; 1) &amp; 0x7F7F7F); <br><br>  Es ist jedoch noch eine weitere Erg√§nzung erforderlich: Es wurde experimentell festgestellt, dass der Genauigkeitsverlust in dieser Formel zu signifikant ist und die Helligkeit des Bildes visuell signifikant springt.  Es wurde klar, dass das verlorene Bit auf das n√§chste Ganze gerundet und nicht verworfen werden muss.  Eine einfache M√∂glichkeit, dies in Ganzzahlarithmetik zu tun, besteht darin, die H√§lfte des Divisors vor der Division zu addieren.  Unser Divisor ist zwei, daher m√ºssen Sie in allen Ziffern eine hinzuf√ºgen - die Konstante 0x010101.  Aber bei jedem Zusatz muss man vorsichtig sein, wenn es zu einem √úberlauf kommt.  Daher k√∂nnen wir eine solche Korrektur nicht verwenden, um den halben Wert der n√§chsten Zelle zu berechnen.  (Wenn es wei√üe Farbe gibt, werden wir √ºberlaufen, daher werden wir es nicht korrigieren).  Es stellte sich jedoch heraus, dass der Hauptfehler in der mehrfachen Aufteilung des Laufwerks lag, die wir nur korrigieren k√∂nnen.  Denn selbst bei einer solchen Korrektur steigt der Wert im Antrieb nicht √ºber 254. Bei Addition zu 0x010101 kann jedoch kein √úberlauf garantiert werden.  Und die Filterformel mit Korrektur hat folgende Form: <br><br>  buf32 [i] = t = (((((0x010101 + t) &gt;&gt; 1) &amp; 0x7F7F7F) + ((buf32 [i] &gt;&gt; 1) &amp; 0x7F7F7F); <br><br>  Tats√§chlich f√ºhrt die Formel die Korrektur recht gut durch. Wenn Sie diesen Algorithmus wiederholt auf das Bild anwenden, werden Artefakte erst in den zweiten zehn Durchg√§ngen sichtbar.  (nicht die Tatsache, dass das Wiederholen der Gausianischen Blura solche Artefakte nicht hervorbringt). <br><br>  Dar√ºber hinaus gibt es ein wunderbares Anwesen mit vielen P√§ssen.  (Dies liegt nicht an meinem Algorithmus, sondern an der "Normalit√§t" der Normalverteilung).  Bereits beim zweiten Durchgang der Laplace Blura sieht die Wahrscheinlichkeitsdichtefunktion (wenn ich alles richtig gemacht habe) ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/webt/sl/1m/tk/sl1mtkidvvurt8z7vxiuhjbfzka.png" alt="Bild"><br><br>  Was, wie Sie sehen, dem Gau√üschen schon sehr nahe kommt. <br><br>  Empirisch fand ich, dass die Verwendung von Modifikationen mit einem gro√üen Radius paarweise zul√§ssig ist, weil  Die oben beschriebene Eigenschaft kompensiert Fehler, wenn der letzte Durchgang genauer ist (der genaueste ist der hier beschriebene x7-Unsch√§rfealgorithmus). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rap</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">codpen</a> <br><br>  Ein Appell an coole Mathematiker: <br>  Was interessant w√§re zu wissen, wie richtig es ist, einen solchen Filter getrennt zu verwenden, ich bin mir nicht sicher, ob es ein symmetrisches Verteilungsbild gibt.  Obwohl die Heterogenit√§t des Auges nicht sichtbar ist. <br><br>  upd: Hier werde ich n√ºtzliche Links ansprechen, die freundlicherweise von Kommentatoren pr√§sentiert und von anderen Khabroviten gefunden wurden. <br>  1. Wie Intel-Assistenten basierend auf der Leistung von SSE funktionieren - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">software.intel.com/en-us/articles/iir-gaussian-blur-filter-implementation-using-intel-advanced-vector-extensions</a> (danke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">vladimirovich</a> ) <br>  2. Theoretische Grundlage zum Thema ‚ÄûSchnelle Bildfaltungen‚Äú + einige seiner benutzerdefinierten Anwendungen in Bezug auf ehrliche Gau√üsche Blau - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">blog.ivank.net/fastest-gaussian-blur.html</a> (danke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Grox</a> ) <br><br>  Vorschl√§ge, Kommentare, konstruktive Kritik sind willkommen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427077/">https://habr.com/ru/post/de427077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427059/index.html">"Mensch, zu menschlich." Werden wir nicht durch die Implementierung einer universellen KI zu Geiseln unseres Geistes?</a></li>
<li><a href="../de427061/index.html">Sprachassistenten am Steuer des Autos: F√ºr wen die Zukunft</a></li>
<li><a href="../de427065/index.html">Klassenattribute Metamorphosen</a></li>
<li><a href="../de427069/index.html">Lokales NPM-Repository in 5 Minuten mit seinen Paketen und dem Caching</a></li>
<li><a href="../de427075/index.html">Die Geschichte einer Entwicklung</a></li>
<li><a href="../de427079/index.html">NetApp Insight 2018</a></li>
<li><a href="../de427081/index.html">Kriterien des menschlichen Geistes aus der Sicht eines Programmierers</a></li>
<li><a href="../de427087/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 12: Netzwerksicherheit, Teil 2</a></li>
<li><a href="../de427091/index.html">Numerische √úberpr√ºfung der abc-Hypothese (ja, diese)</a></li>
<li><a href="../de427093/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 12: Netzwerksicherheit, Teil 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>