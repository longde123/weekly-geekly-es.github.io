<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ„ ğŸš ğŸ‘¼ğŸ» Cara memulai proyek kesayangan dan tidak mendapat manfaat ğŸ‘©â€ğŸ‘©â€ğŸ‘¦ ğŸ¤ğŸ» ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 

 Artikel tersebut menjelaskan penggunaan proyek hewan peliharaan sebagai cara untuk mempertahankan dan meningkatkan keterampilan. Penulis mem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara memulai proyek kesayangan dan tidak mendapat manfaat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479122/"><p><img src="https://habrastorage.org/webt/cz/x-/ln/czx-lnrbjewed61t5fm8k_pjvei.png" alt="Cara memulai proyek kesayangan dan tidak mendapat manfaat"></p><br><div class="spoiler">  <b class="spoiler_title">TL; DR</b> <div class="spoiler_text"><p>  Artikel tersebut menjelaskan penggunaan proyek hewan peliharaan sebagai cara untuk mempertahankan dan meningkatkan keterampilan.  Penulis membuat <a href="https://github.com/liquetsoft/fias-symfony" rel="nofollow">perpustakaan PHP</a> untuk menginstal <a href="https://fias.nalog.ru/" rel="nofollow">FIAS</a> dari file XML. </p></div></div><br><h2 id="cel">  Tujuan </h2><br><p>  Karena itu, saya jarang berganti pekerjaan, mengingat keinginan alami setiap organisasi untuk proses yang tetap, tugas apa pun berubah menjadi rutinitas.  Di satu sisi, itu bermanfaat bagi bisnis untuk mempertahankan keadaan seperti itu, di sisi lain, bagi saya itu berarti kerugian total atau usang keterampilan.  PHP berkembang pesat, dan, akibatnya, potensi lag juga berkembang pesat.  Akhirnya, kita semua tahu bahwa hari ini sulit bagi seorang programmer untuk menemukan pekerjaan yang baik tanpa sepengetahuan Elasticsearch, RabbitMQ, Kafka dan teknologi lainnya yang tidak sering muncul dalam pekerjaan sehari-hari saya. </p><a name="habracut"></a><br><p>  Setelah memulai situs khas berikutnya, saya memutuskan bahwa sudah waktunya untuk mengubah sesuatu.  Saya tidak ingin mengubah pekerjaan saya, tetapi saya ingat bagaimana di salah satu konferensi yang direkomendasikan oleh pembicara menggunakan proyek pilihannya sendiri, yang disebut proyek hewan peliharaan, untuk pelatihan.  Metode itu sepertinya tepat dan saya memutuskan untuk mencobanya. </p><br><h2 id="vybor-zadachi">  Pemilihan tugas </h2><br><p>  Pilihan tugas ternyata menjadi bagian paling sulit dari usaha tersebut.  Tidak ada yang istimewa terlintas dalam pikiran: beberapa layanan, seperti parser pekerjaan yang dapat dengan mudah diimplementasikan pada tumpukan yang sudah dikenal.  Saya meninggalkan ide proyek selama beberapa bulan, sampai saya tidak sengaja melihat berita tentang hackathon dari Kementerian Keuangan.  Disarankan menggunakan salah satu daftar sumber data terbuka untuk membuat layanan.  Antara lain, Sistem Alamat Informasi Federal (FIAS) juga diindikasikan.  Sayangnya, hackathon sudah berakhir saat itu. </p><br><p>  Saya belajar tentang FIAS untuk pertama kalinya, tetapi tugas itu tampak menarik.  Nilailah sendiri: sekitar 30 GB file XML, sekitar 60 juta baris dalam database dan, lebih lanjut, pustaka nanti terbukti berguna dalam pekerjaan.  Ada beberapa solusi siap pakai di Github, tetapi itu tidak menghentikan saya.  Sebaliknya, berdasarkan analisis mereka, saya membuat persyaratan tambahan yang akan menyoroti implementasi saya. </p><br><p>  Ke depan, saya perhatikan bahwa saya menemui kesulitan jauh lebih sedikit daripada yang saya harapkan. </p><br><h2 id="formulirovka-zadachi">  Pernyataan tugas </h2><br><p>  90% kesuksesan adalah pernyataan masalah yang benar.  Setelah beberapa tahun bekerja dengan template, cukup sulit untuk membuat diri Anda merumuskan masalah dengan jelas.  Saya hanya ingin mulai bekerja, tetapi sudah dalam proses semuanya akan beres dengan sendirinya.  Setelah satu jam berjuang dengan penundaan, saya akhirnya menulis: membuat perpustakaan di PHP untuk mengimpor data FIAS. </p><br><p>  Kemudian, setelah mencicipi, saya menambahkan beberapa persyaratan tambahan: </p><br><ul><li>  implementasi dalam PHP tanpa menggunakan utilitas pihak ketiga, secara eksklusif kode dalam PHP dan ekstensi dari PECL, </li><li>  impor semua data dari set FIAS, </li><li>  instalasi penuh dan siklus pembaruan: mencari versi yang diperlukan, menerima arsip, membongkar, menulis ke database, </li><li>  fleksibilitas maksimum: kemampuan untuk mengubah lokasi penyimpanan, memodifikasi data sebelum merekam, memfilter yang diperlukan, dll., </li><li>  Perpustakaan harus dengan mudah diintegrasikan ke dalam proyek yang ada. </li></ul><br><h2 id="fias">  FIAS </h2><br><p>  FIAS memiliki <a href="https://fias.nalog.ru/" rel="nofollow">situs web resmi</a> yang memberi kami definisi dan tujuan membuat sistem </p><br><blockquote>  Sistem Informasi Alamat Federal (FIAS) adalah sistem informasi negara bagian federal yang menyediakan untuk pembentukan, pemeliharaan, dan penggunaan register alamat negara bagian. <br><br>  Tujuan menciptakan FIAS adalah pembentukan sumber daya federal tunggal yang berisi informasi alamat terstruktur yang dapat diandalkan, seragam, tersedia untuk umum.  Berkat implementasi FIAS, informasi ini dapat diperoleh secara gratis melalui Internet di portal FIAS yang terdaftar secara resmi. </blockquote><p>  Materi dengan deskripsi cukup memadai baik di <a href="https://fias.nalog.ru/Updates.aspx" rel="nofollow">situs web FIAS</a> dan di <a href="https://habr.com/ru/search/%3Fq%3D%25D0%25A4%25D0%2598%25D0%2590%25D0%25A1">HabrÃ©</a> , oleh karena itu saya tidak akan fokus pada ini. </p><br><p>  Singkatnya.  FIAS hadir dalam dua format: FIAS dan KLADR.  Yang kedua sudah usang dan tidak lagi digunakan.  Informasi disimpan baik dalam DBF atau dalam XML.  Setiap perubahan dalam komposisi FIAS ditandai dengan versi baru.  Anda dapat meminta paket dengan data lengkap yang terkini saat ini, atau hanya berisi perubahan di antara kedua versi.  Tautan menyediakan layanan SOAP.  Paket ini adalah arsip RAR yang berisi file dengan nama yang dibentuk khusus.  Mereka terdiri dari awalan, nama dataset, dan tanggal pembuatan.  Ada dua jenis awalan: AS_ untuk file yang datanya harus ditambahkan ke database, dan AS <em>DEL</em> untuk file yang datanya harus dihapus dari database. </p><br><p>  FIAS berisi data berikut: </p><br><ul><li>  daftar elemen pembentuk alamat (ini adalah grafik alamat: wilayah, kota dan jalan), </li><li>  elemen alamat yang mengidentifikasi objek yang dapat dialamatkan (nomor rumah dan data rumah), </li><li>  informasi tentang bidang tanah </li><li>  informasi tentang tempat (apartemen, kantor, kamar, dll), </li><li>  informasi tentang dokumen normatif, yang merupakan dasar untuk penugasan nama ke elemen alamat. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Serta beberapa kamus</b> <div class="spoiler_text"><ul><li>  daftar kemungkinan nilai interval rumah (reguler, genap, ganjil), </li><li>  daftar status relevansi entri elemen alamat oleh classifier KLADR4.0, </li><li>  daftar status relevansi entri elemen alamat sesuai dengan FIAS, </li><li>  daftar lengkap, nama singkatan dari jenis elemen alamat dan tingkat klasifikasi mereka, </li><li>  daftar jenis bangunan, </li><li>  daftar kemungkinan jenis kepemilikan </li><li>  daftar kode operasi dengan objek yang dapat dialamatkan, </li><li>  daftar kemungkinan kondisi real estat, </li><li>  daftar jenis tempat atau kantor, </li><li>  daftar jenis kamar, </li><li>  daftar kemungkinan status (pusat) objek alamat unit administratif, </li><li>  jenis dokumen peraturan. </li></ul></div></div><br><p>  Struktur data dijelaskan dalam dokumen, yang dapat ditemukan <a href="https://fias.nalog.ru/Updates.aspx" rel="nofollow">di bagian pembaruan</a> . </p><br><p>  Pada akhirnya, kami memiliki algoritma instalasi FIAS yang cukup sederhana dan linier: </p><br><ul><li>  dapatkan dari layanan SOAP tautan ke arsip dan nomor versi saat ini, </li><li>  unduh arsip, </li><li>  membongkar </li><li>  menulis ke database semua data dari file dengan awalan AS_, </li><li>  hapus dari database semua data dari file dengan awalan AS <em>DEL</em> (ya, itu benar, selama instalasi Anda juga harus menghapus beberapa data), </li><li>  tuliskan nomor versi yang diinstal. </li></ul><br><p>  Dan algoritma pembaruan tidak kalah sederhana: </p><br><ul><li>  dapatkan dari layanan SOAP daftar dengan nomor versi dan tautan ke file dengan perubahan, </li><li>  jika versi saat ini di database lokal adalah yang terbaru, maka hentikan eksekusi, </li><li>  dapatkan tautan ke arsip dengan perubahan ke versi berikutnya, </li><li>  unduh arsip, </li><li>  membongkar </li><li>  menulis ke database semua data dari file dengan awalan AS_, </li><li>  hapus dari database semua data dari file dengan awalan AS <em>DEL</em> , </li><li>  tuliskan nomor versi yang diperbarui, </li><li>  kembali ke langkah pertama. </li></ul><br><p>  FIAS meninggalkan kesan yang bertentangan.  Di satu sisi: otomatisasi penuh dari seluruh proses, format terbuka, dokumentasi yang baik.  Di sisi lain: keputusan aneh untuk menggunakan RAR berpemilik untuk data terbuka;  perbedaan antara dokumentasi dan kenyataan (terutama terkait dengan atribut wajib), yang menyebabkan banyak masalah kecil tetapi tidak menyenangkan;  kadang-kadang arsip datang yang tidak dapat dibongkar di Linux;  beberapa delta antar versi menempati 4-5 GB. </p><br><h2 id="arhitektura">  Arsitektur </h2><br><p>  Setiap perpustakaan harus didasarkan pada ide dasar, inti di mana fungsi lainnya akan tumbuh.  Pola "rantai tugas" bagi saya merupakan pilihan terbaik untuk peran gagasan semacam itu.  Pertama, ini ideal: beberapa operasi berurutan yang akan dilakukan seseorang jika dia ingin menginstal FIAS secara manual jelas bagi pengembang dan cocok dengan kelas kecil yang ditulis dalam gaya SOLID.  Kedua, rantai seperti itu sangat mudah diperluas dengan operasi baru di hampir semua tahap, yang memberikan fleksibilitas yang baik.  Ketiga, saya sudah lama ingin menulis implementasi saya sendiri. </p><br><p>  Selain operasi, saya telah membuat beberapa layanan yang dapat ditransfer menggunakan DI.  Mereka memungkinkan Anda untuk menggunakan kembali kode, dengan mudah mengganti implementasi untuk tugas-tugas sistem tingkat rendah (mengunduh file, membongkar arsip, menulis ke database dan lain-lain) dan memberikan cakupan yang baik dengan tes berkat ejekan. </p><br><p>  Akibatnya, perpustakaan berisi empat jenis objek utama, yang masing-masing bidang tanggung jawabnya didefinisikan dengan jelas: </p><br><ul><li>  layanan - menyediakan alat untuk melakukan tugas sistem tingkat rendah, </li><li>  objek negara - menyimpan informasi untuk transmisi antar operasi, </li><li>  operasi - menggunakan layanan dan menyatakan mereka menerapkan bagian atom dari logika bisnis, </li><li>  rantai operasi - melakukan operasi dan mentransfer keadaan di antara mereka. </li></ul><br><p>  Menggunakan tautan operasi dan layanan yang disediakan oleh perpustakaan, Anda dapat dengan mudah mendapatkan rantai baru atau menambah yang sudah ada hanya menggunakan file konfigurasi. </p><br><h2 id="freymvorki">  Kerangka kerja </h2><br><p>  Dengan istirahat panjang dan refactoring yang konstan, saya bekerja di perpustakaan selama satu setengah tahun. </p><br><p>  Versi relatif stabil pertama sudah siap dalam dua bulan kerja di malam hari.  Bahkan, itu bisa ada secara terpisah dari kerangka kerja dan berisi semua yang diperlukan: skrip input untuk dijalankan di konsol, wadah DI, add-on lebih dari PDO, migrasi logger dan struktur database sendiri - yang saya sangat bangga. </p><br><p>  Tentu saja, rekan-rekannya menolaknya tanpa ampun. </p><br><p>  Argumen utama yang menentang hal ini adalah kurangnya dukungan untuk kerangka kerja populer.  Tidak ada yang mau menulis bungkus terpisah untuk perpustakaan.  Karena itu, saya membuat kesalahan paling mahal dalam waktu: Saya mulai mendukung versi mandiri dan pembungkus individu untuk setiap kerangka kerja.  File FIAS nyata berbeda dari apa yang tertulis dalam dokumentasi.  Setiap kali itu perlu untuk menghapus atau menambahkan, misalnya, bukan nol dalam deskripsi kolom, saya harus membuat perubahan pada tiga repositori.  Karena kebosanan proses, pekerjaan terhenti selama enam bulan. </p><br><p>  Perasaan ketidaklengkapan menyiksa saya selama ini dan setelah pertempuran berdarah dengan kemalasan memaksa saya untuk kembali merancang versi baru.  Untuk mulai dengan, saya memutuskan bahwa tidak ada yang membutuhkan perpustakaan mandiri, yang berarti Anda harus meninggalkan semua layanan yang menyediakan kerangka kerja dari paket, menggantinya dengan antarmuka.  Jadi kami pergi di bawah pisau: skrip input untuk dijalankan di konsol, wadah DI, add-on lebih dari PDO, logger kami sendiri dan migrasi struktur database.  Selanjutnya, saya memutuskan untuk membuat paket terpisah untuk setiap kerangka kerja, yang akan menghubungkan semua bagian dari skrip utama ke skrip yang berfungsi dan memberikan implementasi layanan yang spesifik. </p><br><p>  Poin kuncinya adalah model.  Terus-menerus memperbarui set objek heterogen di beberapa repositori tidak mau.  Pada saat yang sama, di pekerjaan utama, saya mendapat proyek tentang Symfony.  Setelah mengenalnya dengan cepat, saya memutuskan bahwa fitur SF yang paling berguna adalah pembuatan kode dan itu akan menyelesaikan semua masalah saya.  Saya membuat <a href="" rel="nofollow">file yaml</a> di paket utama, yang berisi deskripsi deklaratif dari data FIAS.  Kemudian saya menambahkan generator kode yang membuat kelas spesifik untuk model berdasarkan pada deskripsi ini: Entitas doktrin untuk objek Symfony dan Eloquent untuk Laravel.  Selama pengembangan generator, saya menyadari bahwa tempelan ranting tidak cocok untuk ini, dan memilih solusi khusus - <a href="https://github.com/nette/php-generator" rel="nofollow">Nette PHP Generator</a> . </p><br><p>  Sebagai bukti konsep, saya membuat bundel untuk <a href="https://github.com/liquetsoft/fias-laravel" rel="nofollow">Laravel</a> dan <a href="https://github.com/liquetsoft/fias-symfony" rel="nofollow">Symfony</a> .  Karena saya bekerja lebih lama dengan yang kedua, saya akan menjelaskan semuanya dalam konteksnya. </p><br><h2 id="infrastruktura">  Infrastruktur </h2><br><p>  Sebagian besar proyek tempur saya ditulis pada teknologi yang sudah ketinggalan zaman, jadi saya tidak bisa menggunakan penganalisa kode modern pada salah satu dari mereka.  Menyingkirkan penindasan sebelumnya, saya menginstal dan mengkonfigurasi semua alat kontrol kualitas kode yang saya dapat: </p><br><ul><li>  <a href="https://github.com/vimeo/psalm" rel="nofollow">Mazmur</a> untuk pemeriksaan tipe, </li><li>  <a href="https://scrutinizer-ci.com/" rel="nofollow">Scrutinizer</a> untuk penilaian kualitas umum ( <a href="https://scrutinizer-ci.com/" rel="nofollow">banyak</a> membantu dengan kompleksitas siklomatik) </li><li>  <a href="https://github.com/FriendsOfPHP/PHP-CS-Fixer" rel="nofollow">Pemecah Standar Pengodean PHP</a> untuk memeriksa gaya kode, </li><li>  <a href="https://github.com/sebastianbergmann/phpcpd" rel="nofollow">PHP Copy / Paste Detector</a> untuk menemukan duplikat, </li><li>  <a href="https://github.com/sebastianbergmann/phpunit" rel="nofollow">PHPUnit</a> untuk menjalankan tes unit. </li></ul><br><p>  Validasi terintegrasi di Github menggunakan <a href="https://travis-ci.org/" rel="nofollow">Travis</a> .  Sebagai sentuhan terakhir, ia menambahkan file Docker untuk membuat lingkungan pengembang lokal lengkap dengan file make yang berisi perintah dasar untuk wadah (meluncurkan pemeriksaan, tes, membuat model, dan lainnya). </p><br><h2 id="itogi-obucheniya">  Hasil belajar </h2><br><h3 id="php-7">  PHP 7 </h3><br><p>  Sebelum mulai bekerja di perpustakaan, saya tidak pernah benar-benar menggunakan <a href="https://www.php.net/manual/ru/migration70.new-features.php" rel="nofollow">fitur-fitur baru dari PHP 7</a> .  Mereka cantik: dari tipe ketat hingga peningkatan signifikan dalam produktivitas.  Terima kasih khusus kepada pengembang untuk operator penggabungan nol.  Saya belum melihat penurunan serius pada basis kode setelah memperkenalkan satu operator. </p><br><h3 id="rar">  Rar </h3><br><p>  Anehnya, di PECL ada <a href="https://www.php.net/manual/ru/book.rar.php" rel="nofollow">paket untuk bekerja dengan RAR</a> .  Biasanya, ekstensi semacam itu tidak tepercaya dan saya mencoba menghindarinya.  Itu ternyata sangat stabil: itu dipasang di 7.2 tanpa masalah, itu mampu membongkar arsip besar relatif cepat dan dengan konsumsi RAM rendah (6 GB dibongkar dalam 10-20 menit tergantung pada sumber daya sistem yang tersedia).  Saya masih takut bahwa ini adalah manifestasi dari hukum Murphy. </p><br><h3 id="xmlreader">  Xmlreader </h3><br><p>  Membaca file xml raksasa bukanlah tugas yang sepele.  Dan lagi ekstensi PECL datang untuk menyelamatkan - <a href="https://www.php.net/manual/ru/book.xmlreader.php" rel="nofollow">XmlReader</a> .  Saya tidak segera menyadari semua kekuatannya, tetapi dalam beberapa pendekatan saya mengadaptasinya bersamaan dengan <a href="https://symfony.com/doc/current/components/serializer.html" rel="nofollow">serializer Symfony</a> untuk secara cepat dan ekonomis memperoleh data dari file FIAS.  Di sisi pustaka, objek pembaca mengimplementasikan antarmuka iterator, yang secara berurutan mengembalikan string xml yang terkait dengan satu catatan dalam file.  Menggunakan serializer Symfony, string ini dikonversi menjadi objek.  File 20 GB dapat dibaca dalam 3-4 menit saat menggunakan tidak lebih dari 50 MB RAM. </p><br><h3 id="zapis-v-bazu-dannyh">  Menulis ke basis data </h3><br><p>  Tentu saja, saya mulai dengan array asosiatif dengan data dan deskripsi tabel besar.  Kode dengan cepat berubah menjadi hash konfigurasi dan kelas konverter. </p><br><p>  Keajaiban entitas Ajaran menunjukkan bagaimana objek dapat menggambarkan dirinya sendiri.  Saya memutuskan untuk menggunakan pendekatan yang sama, tetapi pada saat yang sama menyingkirkan implementasi saya sendiri menulis data ke database menggunakan PDO.  Sebagai gantinya, saya membuat antarmuka penyimpanan yang menjelaskan metode untuk memproses objek.  Berdasarkan kelas entitas, implementasi Storage tertentu memutuskan dengan tepat bagaimana dan di mana harus menulis data.  Pendekatan ini membuatnya mudah untuk menghubungkan berbagai penyimpanan: dari MySql ke file csv. </p><br><h3 id="optimizaciya-vstavki-dannyh">  Optimalisasi Penyisipan Data </h3><br><p>  Saya menghentikan impor pertama setelah melebihi dalam 48 jam.  Menjadi jelas bahwa Anda perlu mengoptimalkan proses memasukkan data. </p><br><p>  Pertama, saya beralih ke <a href="https://www.postgresql.org/docs/12/datatype-uuid.html" rel="nofollow">kolom tipe ugid</a> untuk kunci primer yang <a href="https://www.postgresql.org/docs/12/datatype-uuid.html" rel="nofollow">dibangun ke dalam PostgreSql</a> .  Menulis ke kolom uuid dengan indeks jauh lebih cepat daripada menulis ke string. </p><br><p>  Setelah ini, saya meninggalkan semua indeks dan kunci asing yang tidak kritis, karena kepedulian terhadap integritas data sepenuhnya berada di sisi tim FIAS. </p><br><p> Lalu saya redid antarmuka Storage sehingga skrip eksternal dapat secara eksplisit menginformasikannya tentang penyelesaian impor.  Ini memungkinkan penggunaan insert massal, yang mempercepat rekaman pada waktu-waktu tertentu.  <a href="https://www.postgresql.org/docs/current/populate.html" rel="nofollow">Mencari informasi,</a> saya juga menemukan perintah <a href="https://www.postgresql.org/docs/current/sql-copy.html" rel="nofollow"><code>copy</code></a> bersama dengan <a href="https://www.postgresql.org/docs/current/functions-xml.html" rel="nofollow"><code>query_to_xml</code></a> .  Itu memiliki dua kelemahan utama: pertama, pengguna PostgreSql harus membaca izin untuk file, yang saya tidak bisa menjamin, dan kedua, kemampuan untuk memodifikasi data di dalam skrip sebelum penulisan hilang. </p><br><p>  Meskipun ada perubahan ini, waktu impor melebihi 30 jam.  Diperlukan perubahan pendekatan yang radikal. </p><br><h3 id="parallelnye-processy">  Proses paralel </h3><br><p>  Internet penuh dengan artikel tentang asinkron dalam PHP.  Pilihan saya jatuh pada <a href="https://amphp.org/" rel="nofollow">Amp</a> .  Itu hanya tidak berhasil secara tidak sinkron.  Pertama, kode itu dengan cepat berubah menjadi lembar panggilan balik yang mengerikan dan panggilan yang tidak jelas (ini mungkin salah saya, bukan pendekatan yang tidak sinkron).  Kedua, saya harus meninggalkan penggunaan ORM standar karena panggilan non-blocking ke database melalui <a href="https://github.com/amphp/mysql" rel="nofollow">kerangka kerja khusus</a> diperlukan.  Ketiga, meskipun ada kondisi di mana PostgreSql dapat menyisipkan baris secara paralel, mereka <a href="" rel="nofollow">sangat</a> <a href="https://wiki.postgresql.org/wiki/Parallel_Query" rel="nofollow">sulit</a> dipenuhi.  Akibatnya, setelah 5 jam beroperasi, saya menyaksikan bagaimana semua permintaan asinkron saya secara paksa "disinkronkan" di sisi basis data. </p><br><p>  Tetapi impor dibagi dengan baik ke dalam proses paralel: beberapa tugas yang sepenuhnya independen yang tidak memiliki sumber daya bersama untuk bersaing, dan data yang dapat mereka tukar.  Selain itu, dalam kerangka satu utas, saya menerima kode yang indah dan linier. </p><br><p>  Yang pertama saya memutuskan untuk mencoba ekstensi <a href="https://www.php.net/manual/ru/book.parallel.php" rel="nofollow">Paralel</a> .  Ini memiliki satu kesalahan fatal - penerjemah harus dibangun dengan dukungan untuk ZTS (Zend Thread Safety).  Karena ZTS tidak berfungsi dalam skrip web biasa, orang harus memiliki dua versi juru bahasa yang berbeda.  Satu, tanpa ZTS, untuk web, yang kedua, dengan ZTS, untuk menginstal FIAS.  Peningkatan kinerja potensial melebihi ketidaknyamanan ini, terutama mengingat betapa mudahnya untuk merakit wadah Docker baru dan menggunakannya bersamaan dengan yang lama.  Sayangnya, memulai Symfony di dalam utas baru menyebabkan tumpukan PHP meluap, dan saya tidak siap untuk menolak wadah DI dan konfigurasi yang mudah. </p><br><p>  Akhirnya, saya menemukan <a href="https://symfony.com/doc/current/components/process.html" rel="nofollow">proses symfony</a> .  Bahkan, ia memulai proses baru untuk perintah konsol yang ditentukan dan memonitor penyelesaiannya.  Saya harus menambahkan dua rantai tambahan.  Yang pertama mengunduh arsip, membongkar dan memulai proses paralel untuk pemrosesan data.  Yang kedua mengambil daftar file dari argumen baris perintah dan menulis kontennya ke database. </p><br><p>  Karena kurangnya pengalaman dengan proses paralel, saya tampaknya telah membuat semua kesalahan pemula. </p><br><p>  Sebagai contoh, proses inisiasi saya memeriksa penyelesaian anak-anak menggunakan loop tak terbatas dan, tentu saja, menghabiskan banyak sumber daya prosesor untuk hal ini.  Panggilan tidur antara iterasi membantu. </p><br><p>  Dalam implementasi pertama, file didistribusikan secara tidak merata di antara proses.  Dua terbesar jatuh ke dalam satu aliran, yang diproses selama lebih dari 20 jam.  Dalam implementasi kedua, saya menambahkan manajer khusus yang mendistribusikan file berdasarkan waktu yang diperlukan untuk mengimpornya.  Sekarang proses dimuat secara merata. </p><br><p>  Setelah pengeditan ini, saya dapat mengimpor versi lengkap FIAS dalam 16-20 jam, tergantung pada sumber daya server.  Tidak sebagus yang kita inginkan, tetapi saya terus bekerja pada optimasi.  Langkah selanjutnya adalah penolakan lengkap PostgreSql yang mendukung Elasticsearch. </p><br><h2 id="vyvody">  Kesimpulan </h2><br><p>  Apakah itu sepadan?  Dua tahun bekerja di perpustakaan yang tidak pernah masuk ke proyek pertempuran apa pun? </p><br><p>  Ya, sepenuhnya. </p><br><p>  Saya mengubah pekerjaan saya.  Selama tur selusin wawancara, saya menjawab banyak pertanyaan rumit hanya berkat proyek kesayangan saya. </p><br><p>  Kepanikan bahwa PHP sedang sekarat semakin kuat.  Saya tidak akan menyembunyikan fakta bahwa saya sendiri berpikir tentang migrasi ke bahasa lain. </p><br><p>  Setelah saya melihat pekerjaan besar yang dimasukkan tim PHP ke versi 7;  dia diyakinkan oleh teladan pribadi betapa matangnya bahasa itu dan betapa kaya ekosistem itu telah tumbuh;  Saya bisa mengatakan bahwa rumor tentang kematian PHP sangat dibesar-besarkan.  Dan ini baru permulaan: di masa depan kita sedang menunggu JIT, tidak sinkron di luar kotak dan banyak lagi. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479122/">https://habr.com/ru/post/id479122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479102/index.html">Berkenalan dengan Yandex.Maps atau Seberapa saya suka dokumentasi</a></li>
<li><a href="../id479106/index.html">Berapa biaya trik sulap</a></li>
<li><a href="../id479108/index.html">Kehidupan Knight - Arena online dengan elemen RPG</a></li>
<li><a href="../id479116/index.html">Tayangan pada pencarian Y. Langsung: mengapa Anda membayar 1,5 kali lebih banyak per klik</a></li>
<li><a href="../id479120/index.html">Jumlah pemilih gagal: kami membawa AgentTesla ke air bersih. Bagian 2</a></li>
<li><a href="../id479124/index.html">[Infografis] Kecerdasan Buatan dalam Fiksi Ilmiah</a></li>
<li><a href="../id479126/index.html">Python dalam pengembangan Mobile</a></li>
<li><a href="../id479128/index.html">Bagaimana cara kerja layanan medis bandara</a></li>
<li><a href="../id479132/index.html">Komponen eksternal untuk platform 1C Mobile (BroadcastReceiver)</a></li>
<li><a href="../id479136/index.html">Komputasi kuantum: akhir dari blockchain?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>