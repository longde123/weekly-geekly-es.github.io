<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜³ ğŸ‘©ğŸ½â€ğŸ¤â€ğŸ‘©ğŸ» ğŸ‘©ğŸ½â€ğŸš’ Bot Ant Modular dengan Memori âšªï¸ ğŸ¥• ğŸˆšï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salah satu proyek yang telah lama saya impikan untuk diimplementasikan adalah bot tugas modular dengan memori. Tujuan akhir dari proyek ini adalah unt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bot Ant Modular dengan Memori</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443252/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/nt/w1/te/ntw1telvkd_gywv-7drpcook6ua.gif"></div><br>  Salah satu proyek yang telah lama saya impikan untuk diimplementasikan adalah bot tugas modular dengan memori.  Tujuan akhir dari proyek ini adalah untuk menciptakan dunia dengan makhluk yang mampu bertindak secara mandiri dan kolektif. <br><br>  Saya biasa memprogram generator dunia, jadi saya ingin mengisi dunia dengan bot sederhana yang menggunakan AI untuk menentukan perilaku dan interaksi mereka.  Jadi, berkat pengaruh aktor di dunia, adalah mungkin untuk meningkatkan detailnya. <br><br>  Saya sudah menerapkan sistem pipeline tugas Javascript dasar (karena menyederhanakan hidup saya), tetapi saya menginginkan sesuatu yang lebih dapat diandalkan dan terukur, jadi saya menulis proyek ini dalam C ++.  Persaingan untuk implementasi kebun prosedural dalam generasi subreddit / r / prosedural membawa saya ke ini (maka topik yang sesuai). <br><br>  Dalam sistem saya, simulasi terdiri dari tiga komponen: dunia, populasi, dan serangkaian tindakan yang menghubungkan mereka.  Karena itu, saya perlu membuat tiga model, yang akan saya bahas dalam artikel ini. <br><br>  Untuk meningkatkan kompleksitas, saya ingin para aktor menyimpan informasi tentang pengalaman sebelumnya dengan dunia dan menggunakan pengetahuan tentang interaksi ini dalam tindakan di masa depan. <br><a name="habracut"></a><br>  Saat membuat model dunia, saya memilih jalur sederhana dan menggunakan suara Perlin untuk meletakkannya di permukaan air.  Semua benda lain di dunia terletak secara acak. <br><br>  Untuk model populasi (dan "ingatannya"), saya cukup membuat kelas dengan beberapa karakteristik dan koordinat.  Ini seharusnya merupakan simulasi resolusi rendah.  Memori adalah antrian, bot melihat sekeliling, menyimpan informasi tentang lingkungan mereka, menulis ke antrian dan mengelola antrian ini sebagai interpretasi dari memori mereka. <br><br>  Untuk menghubungkan kedua sistem tindakan ini, saya ingin membuat kerangka kerja tugas-tugas primitif di dalam sistem hirarki tugas antrian sehingga entitas individu dapat menerapkan perilaku kompleks di dunia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/571/a8c/77b/571a8c77bb291d6802fe9c87b8aa8986.png"></div><br>  <i>Peta contoh.</i>  <i>Air mengambil bentuk sungai sepenuhnya tanpa sengaja.</i>  <i>Semua elemen lain terletak secara acak, termasuk sarang semut, yang pada benih ini bergeser terlalu jauh ke tepi (tetapi sungai terlihat indah).</i> <br><br>  Saya memutuskan bahwa sekelompok semut dalam pengumpulan daun rumput akan menjadi model pengujian yang baik yang menjamin keandalan pelaksanaan fungsi dasar (dan sistem antrian tugas secara keseluruhan) dan mencegah kebocoran memori (ada banyak). <br><br>  Saya ingin menjelaskan secara lebih rinci struktur sistem tugas dan memori, dan juga menunjukkan bagaimana kompleksitas diciptakan dari (sebagian besar) fungsi dasar primitif.  Saya juga ingin menunjukkan beberapa â€œmemori semutâ€ yang lucu yang mungkin Anda temui ketika semut mulai berputar-putar mencari rumput atau berdiri diam dan membuat program melambat. <br><br><h3>  Struktur umum </h3><br>  Saya menulis simulasi ini di C ++, dan menggunakan SDL2 untuk rendering (saya sudah menulis kelas presentasi kecil untuk SLD2 sebelumnya).  Saya juga menggunakan implementasi A * (sedikit dimodifikasi) yang saya temukan di github karena <em>implementasi saya</em> sangat lambat dan saya tidak bisa mengerti mengapa. <br><br>  Peta hanyalah kotak 100 Ã— 100 dengan dua lapisan - lapisan tanah (digunakan untuk mencari jalur) dan lapisan isi (untuk menyelesaikan interaksi dan jalur pencarian).  Kelas dunia juga menangani berbagai fungsi kosmetik, seperti pertumbuhan rumput dan tumbuh-tumbuhan.  Saya berbicara tentang ini sekarang karena ini adalah satu-satunya bagian yang tidak akan dijelaskan dalam artikel ini. <br><br><h2>  Populasi </h2><br>  Bot berada di kelas dengan properti yang menggambarkan makhluk tunggal.  Beberapa di antaranya bersifat kosmetik, yang lain memengaruhi eksekusi tindakan (misalnya, kemampuan terbang, jangkauan penglihatan, apa yang dimakannya, dan apa yang bisa dikenakan makhluk itu). <br><br>  Yang paling penting di sini adalah nilai tambahan yang menentukan perilaku.  Yaitu: vektor yang berisi jalur mereka saat ini A *, sehingga tidak perlu dihitung dalam setiap siklus jam (ini menghemat waktu komputasi dan memungkinkan Anda untuk mensimulasikan lebih banyak bot), dan antrian memori yang menentukan interpretasi makhluk itu terhadap lingkungan mereka. <br><br><h3>  Antrian memori </h3><br>  Antrian memori adalah antrian sederhana yang berisi sekumpulan objek memori yang ukurannya dibatasi oleh properti bot.  Setiap kali ingatan baru ditambahkan, mereka didorong ke depan, dan segala sesuatu yang melampaui batas di belakang terputus.  Berkat ini, beberapa kenangan bisa lebih "segar" daripada yang lain. <br><br>  Jika bot ingin mengingat informasi dari memori, maka ia membuat objek memori (permintaan) dan membandingkannya dengan apa yang ada di memori.  Kemudian fungsi recall mengembalikan vektor kenangan yang cocok dengan salah satu atau semua kriteria yang ditentukan dalam kueri. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Memory</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Recall Score int recallScore = 1; //Memory Queryable? Array bool queryable[4] = {false, false, false, false}; //Memory Attributes std::string object; std::string task; Point location; bool reachable;</span></span></code> </pre> <br>  Kenangan terdiri dari objek sederhana yang berisi beberapa properti.  Properti memori ini dianggap "terkait" satu sama lain.  Setiap memori juga diberi nilai "recallScore", yang diulang setiap kali memori diingat oleh fungsi recall.  Setiap kali bot mengingat memori, bot melakukan penyortiran sekali jalan, mulai dari belakang, mengubah urutan memori jika memori recall dari memori yang lebih lama lebih tinggi daripada memori yang baru.  Berkat ini, beberapa memori mungkin lebih "penting" (dengan ukuran memori besar) dan disimpan lebih lama dalam antrian.  Seiring waktu, mereka akan digantikan oleh yang baru. <br><br><h3>  Antrian memori </h3><br>  Saya juga menambahkan beberapa operator kelebihan beban ke kelas ini sehingga perbandingan langsung antara antrian memori dan kueri dapat dilakukan, membandingkan properti "apa saja" atau "semua", sehingga hanya properti yang ditentukan yang ditimpa ketika memori ditimpa.  Berkat ini, kita dapat memiliki memori objek yang dikaitkan dengan suatu tempat, tetapi jika kita melihat tempat ini lagi dan objek tidak ada di sana, kita dapat memperbarui memori dengan menimpanya dengan memori yang berisi kotak isian baru, menggunakan kueri yang sesuai dengan tempat ini . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Bot::updateMemory(Memory &amp;query, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> all, Memory &amp;memory){ <span class="hljs-comment"><span class="hljs-comment">//Loop through all existing Memories //"memories" queue is a member of Bot for(unsigned int i = 0; i &lt; memories.size(); i++){ //If all matches are required and we have all matches if(all &amp;&amp; (memories[i] == query)){ //We have a memory that needs to be updated memories[i] = memory; continue; } //If not all matches are required and any query elements are contained else if(!all &amp;&amp; (memories[i] || query)){ //When overwriting, only overwrite specified quantities memories[i] = memory; continue; } } }</span></span></code> </pre> <br>  Dalam proses membuat kode untuk sistem ini, saya belajar banyak. <br><br><h2>  Sistem tugas </h2><br>  Sifat dari loop game atau rendering adalah bahwa fungsi yang sama diulang dalam setiap ukuran, namun, saya ingin menerapkan perilaku non-siklik di bot saya. <br><br>  Di bagian ini, saya akan menjelaskan dua pandangan tentang struktur sistem tugas yang dirancang untuk melawan efek ini. <br><br><h3>  Struktur bottom-up </h3><br>  Saya memutuskan untuk pindah dari bawah ke atas dan membuat satu set "tindakan primitif" yang harus dilakukan bot.  Masing-masing tindakan ini hanya berlangsung satu ketukan.  Dengan pustaka fungsi primitif yang baik, kita dapat menggabungkannya ke dalam tindakan kompleks yang terdiri dari beberapa fungsi primitif. <br><br>  Contoh tindakan primitif tersebut: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Primitives bool wait(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool look(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool step(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool swap(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool store(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool consume(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool move(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Continue with secondaries here...</span></span></code> </pre> <br>  Perhatikan bahwa tindakan ini berisi referensi ke dunia dan populasi, memungkinkan Anda untuk mengubahnya. <br><br><ul><li>  Tunggu menyebabkan makhluk itu tidak melakukan apa pun dalam lingkaran ini. </li><li>  Lihatlah mem-parsing lingkungan dan mengantri memori baru. </li><li>  Swap mengambil objek di tangan makhluk itu dan menggantinya dengan yang terbaring di tanah. </li><li>  Konsumsi menghancurkan item di tangan makhluk itu. </li><li>  Langkah mengambil jalur terhitung saat ini ke tujuan dan melakukan satu langkah (dengan banyak pemeriksaan kesalahan). </li><li>  ... dan seterusnya. </li></ul><br>  Semua fungsi tugas adalah anggota kelas tugas saya;  setelah pengujian yang ketat, mereka telah membuktikan keandalan dan kemampuan mereka untuk bergabung ke dalam tugas yang lebih kompleks. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Secondaries bool walk(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool idle(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool search(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool forage(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool take(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Species Masters bool Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool Bee(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); };</span></span></code> </pre> <br>  Dalam fungsi-fungsi sekunder ini, kami membangun fungsi hanya dengan merantai tugas-tugas lain: <br><br><ul><li>  Tugas berjalan hanya beberapa langkah (dengan penanganan kesalahan) </li><li>  Tugas take adalah tugas look and swap (diperlukan karena pemrosesan memori semut, yang akan saya jelaskan nanti) </li><li>  Tugas idle adalah memilih tempat acak dan pindah ke sana (menggunakan jalan kaki), menunggu beberapa siklus (menggunakan menunggu), dan ulangi siklus ini selama beberapa kali </li><li>  ... dan seterusnya </li></ul><br>  Tugas-tugas lain lebih rumit.  Tugas pencarian mengeksekusi kueri memori untuk mencari setiap memori tempat yang mengandung objek "makanan" (dapat dimakan untuk bot jenis ini).  Dia mengunduh kenangan ini dan berkeliling di sekitar mereka semua, â€œmencariâ€ makanan (dalam hal semut, ini adalah rumput).  Jika tidak ada ingatan makanan, tugas itu membuat makhluk itu secara acak berkeliaran di dunia dan melihat-lihat.  Dengan menonton dan mempelajari (dengan melakukan "tampilan" dengan viewRadius = 1; yaitu, hanya melihat ubin di bawahnya), makhluk itu dapat memperbarui ingatannya dengan informasi tentang lingkungannya, secara cerdas dan sengaja mencari makanan. <br><br>  Tugas mencari makan yang lebih umum terdiri dari mencari makanan, mengambil makanan, memeriksa (untuk memperbarui memori dan menemukan makanan di lingkungan), kembali ke rumah dan menyimpan makanan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c90/df8/2d8/c90df82d8de8bcf8a9d0de594d2c2e89.gif"></div><br>  <i>Anda mungkin memperhatikan bahwa semut keluar dari sarang semut dan mencari makanan dengan sengaja.</i>  <i>Karena inisialisasi, jalur awal semut diarahkan ke titik acak, karena ingatan mereka pada t = 0 kosong.</i>  <i>Kemudian mereka diberi perintah untuk mengambil makanan dalam tugas mencari makan, dan mereka juga melihat sekeliling, memastikan bahwa tidak ada lagi makanan.</i>  <i>Dari waktu ke waktu mereka mulai mengembara, karena mereka kehabisan tempat di mana mereka melihat makanan (rabun dekat).</i> <br><br>  Dan akhirnya, bot memiliki "tampilan" yang menentukan jenis AI yang ditugaskan padanya.  Setiap tampilan dikaitkan dengan satu tugas kontrol yang mendefinisikan semua perilakunya: terdiri dari serangkaian tugas yang semakin kecil, mudah ditentukan oleh satu set antrian memori dan tugas primitif.  Ini adalah tugas-tugas seperti Ant dan Bee. <br><br><h3>  Struktur top-down </h3><br>  Jika Anda melihat dari atas ke bawah, sistem terdiri dari kelas master tugas yang mengoordinasikan tugas kontrol dan pelaksanaannya untuk setiap bot individu di peta. <br><br>  Taskmaster memiliki vektor tugas kontrol, yang masing-masing dikaitkan dengan bot.  Setiap tugas kontrol, pada gilirannya, memiliki antrian subtugas yang dimuat selama inisialisasi pertama objek tugas dengan fungsi tugas terkait. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Members std::stack&lt;Task&gt; queue; bool initFlag = true; int args[10]; bool (Task::*handle)(Garden&amp;, Population&amp;, int (&amp;)[10]); int botID; std::string name; //Constructor Task(std::string taskName, int taskBotID, bool (Task::*taskHandle)(Garden&amp;, Population&amp;, int (&amp;)[10])){ name = taskName; botID = taskBotID; handle = taskHandle; } //Launch a Task bool perform(Garden &amp;garden, Population &amp;population); //Continue with primitives here...</span></span></code> </pre> <br>  Setiap objek tugas dalam antrian menyimpan array argumen, yang diteruskan ke penangan fungsi terkait.  Argumen-argumen ini menentukan perilaku tugas-tugas primitif yang dibuat seluas mungkin.  Argumen dilewatkan dengan referensi, sehingga objek tugas dalam antrian dapat menyimpan argumennya dan memungkinkan subfungsi untuk diubah, sehingga Anda dapat mengimplementasikan hal-hal seperti iterasi untuk menunggu sejumlah kutu atau permintaan untuk mengumpulkan sejumlah item tertentu, dll.  Subfungsi mengubah nilai iterator (argumen [n]) dari fungsi induk dengan referensi dan menjadikan kondisi keberhasilannya bergantung pada nilainya. <br><br>  Dalam setiap ukuran, pemberi tugas memeriksa daftar tugas kontrol dan menjalankannya dengan memanggil metode performanya.  Metode perform, pada gilirannya, melihat elemen teratas dari antrian di dalam tugas dan mengeksekusinya dengan argumen dari tugas.  Dengan demikian, Anda dapat menurunkan antrian tugas, selalu melakukan tugas tertinggi.  Kemudian nilai balik tugas menentukan penyelesaian tugas. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Execute Task Function bool Task::perform(Garden &amp;garden, Population &amp;population){ //Debug Message if(debug){std::cout&lt;&lt;"Bot with ID: "&lt;&lt;botID&lt;&lt;" performing task: "&lt;&lt;name&lt;&lt;std::endl;} //Change the Name and Execute the Task population.bots[botID].task = name; return (*this.*handle)(garden, population, args); }</span></span></code> </pre> <br>  Ketika tugas primitif mengembalikan true, ia telah mencapai titik stabilnya, atau setidaknya tidak boleh diulangi (misalnya, langkah mengembalikan true ketika makhluk telah mencapai titik akhir).  Artinya, kondisi pengembaliannya terpenuhi dan dihapus dari antrian sehingga tugas berikutnya dapat diselesaikan pada langkah berikutnya. <br><br>  Tugas yang berisi antrian tugas mengembalikan true setelah antrian kosong.  Karena ini, dimungkinkan untuk membuat tugas-tugas kompleks dengan struktur antrian dan sub-antrian di mana fungsi yang sama terus-menerus dipanggil, tetapi masing-masing panggilan iterates status permainan dan status tugas dengan satu langkah. <br><br>  Akhirnya, tugas kontrol menggunakan struktur sederhana - mereka dipanggil di setiap siklus, memuat tugas hanya jika mereka kosong, dan melakukan tugas yang dimuat dalam antrian mereka. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Species Functions bool Task::Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]){ //Initial Condition if(initFlag){ Task forage("Search for Food", botID, &amp;Task::forage); forage.args[0] = population.bots[botID].forage; //What are we looking for? queue.push(forage); initFlag = false; } //Queue Loop if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ queue.push(newtask); return false; } //If it was successful, we leave it off return false; } //Return Case for Mastertask initFlag = true; return false; }</span></span></code> </pre> <br>  Dengan bantuan loop antrian saya (lihat kode), saya dapat berulang kali menjalankan satu fungsi dan setiap kali menjalankan elemen teratas dalam antriannya, mendorong elemen keluar dari itu jika memanggil metode performanya mengembalikan true. <br><br><h2>  Hasil </h2><br>  Semua ini dibungkus dengan libconfig, sehingga parameter simulasi sangat mudah diubah.  Anda dapat mengkodekan banyak tugas kontrol tanpa masalah (saya membuat semut dan lebah), dan mendefinisikan dan memuat spesies baru menggunakan libconfig sangat sederhana. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Anthill General Configuration File debug = true; //World Generation Parameters seed = 15; water = true; //Species that the simulation recognizes Species: { //Ant Species Ant: { masterTask = "Ant"; color = (0, 0, 0); viewDistance = 2; memorySize = 5; forage = 2; trail = true; fly = false; } Bee: { masterTask = "Bee"; color = (240, 210, 30); viewDistance = 4; memorySize = 30; forage = 4; trail = false; fly = true; } Worm: { masterTask = "Bee"; color = (255, 154, 171); viewDistance = 1; memorySize = 5; forage = 3; trail = true; fly = false; } } Population: ( {species = "Ant"; number = 40;}//, //{species = "Bee"; number = 12;}, //{species = "Worm"; number = 5;} )</span></span></code> </pre> <br>  Mereka dimuat dengan elegan ke dalam simulasi.  Berkat pencarian baru yang ditingkatkan untuk jalur, saya dapat mensimulasikan sejumlah besar bot aktif individu mengumpulkan makanan di pesawat dua dimensi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c30/991/682/c309916821a8538a0dd92db88caf6b6b.gif"></div><br>  <i>Simulasi 40 semut mengumpulkan rumput secara bersamaan.</i>  <i>Jalan yang mereka buat di pasir disebabkan oleh peningkatan berat yang diberikan pada tanah yang "masih alami".</i>  <i>Ini mengarah pada penciptaan karakteristik "jalan raya semut."</i>  <i>Mereka juga dapat diartikan sebagai feromon, tetapi akan lebih seperti kebenaran jika semut benar-benar bertukar ingatan.</i> <br><br>  Modularitas sistem ini memastikan penciptaan spesies baru secara cepat yang perilakunya ditentukan oleh tugas kontrol yang sederhana.  Dalam kode di atas, Anda dapat melihat bahwa saya membuat cacing dan lebah AI hanya dengan mengubah warnanya, membatasi pencarian jalur (mereka tidak bisa terbang), jarak pandang dan ukuran memori.  Pada saat yang sama, saya mengubah perilaku umum mereka, karena semua parameter ini digunakan oleh fungsi tugas primitif. <br><br><h3>  Debugging Ant Memories </h3><br>  Struktur tugas dan memori yang kompleks telah menyebabkan kesulitan yang tak terduga dan kebutuhan untuk menangani pengecualian. <br><br>  Berikut adalah tiga bug memori yang sangat rumit yang membuat saya mengulang subsistem: <br><br><h4>  Semut berlari dalam lingkaran </h4><br>  Salah satu serangga pertama yang harus saya hadapi: semut berlari dengan gila di sepanjang pola yang tertutup di lapangan untuk mencari rumput di tanah kosong.  Masalah ini muncul karena pada saat itu saya belum menerapkan pembaruan memori.  Semut memiliki ingatan tentang lokasi makanan, dan segera setelah mereka mengambil rumput dan melihat sekeliling lagi, ingatan baru terbentuk. <br><br>  Masalahnya adalah ingatan baru itu pada titik yang sama, tetapi ingatan lama tetap dipertahankan.  Ini berarti bahwa dalam proses mencari makanan, semut mengingat dan menyimpan lokasi makanan yang tidak lagi berlaku, tetapi ingatan lama ini dipertahankan dan menggantikan yang baru (mereka ingat ramuan lezat ini). <br><br>  Saya memperbaikinya sebagai berikut: data objek hanya ditimpa dalam ingatan lama, jika kita melihat tempat yang sama dan objek telah berubah (misalnya, makhluk itu melihat bahwa tidak ada lagi rumput di sana, tetapi tidak ingat bahwa dulu ada rumput).  Mungkin di masa depan saya hanya akan menambahkan properti "tidak valid" ke dalam memori saya sehingga bot dapat mengingat informasi lama yang mungkin penting, tetapi informasi yang tidak lagi valid "muncul" ("Saya melihat beruang di sini, tetapi sekarang tidak ada di sana"). <br><br><h4>  Semut mengambil benda di bawah semut lain </h4><br>  Dari waktu ke waktu (terutama dengan sejumlah besar semut dan kepadatan rumput yang tinggi), dua semut dapat naik ke satu ubin rumput dalam satu ukuran dan mencoba mengambilnya.  Ini berarti bahwa semut pertama memasuki ubin, melihat sekeliling dan mengambil item dalam 3 langkah.  Pada gilirannya, semut kedua melakukan hal yang sama, tepat sebelum mengangkat objek, semut lain mengambilnya dari bawah hidungnya.  Dengan tenang dia melanjutkan tugasnya, memeriksa lingkungan yang sama dengan semut lainnya pada ukuran sebelumnya, dan memproses garis ingatannya dengan cara yang sama (karena pada tahap ini ingatan mereka identik).  Hal ini menyebabkan semut kedua menyalin yang pertama, tidak pernah mengambil benda dan mengikuti yang pertama, yang benar-benar melakukan semua pekerjaan.  Saya perhatikan ini karena dalam simulasi lima semut, hanya tiga yang terlihat.  Butuh waktu lama untuk menemukan penyebabnya. <br><br>  Saya memecahkan masalah ini dengan membuat tugas swap menjadi primitif dan membuat tugas take, yang pertama kali melihat ke tanah untuk melihat apakah ada objek di sana.  Jika ya, ia "bertukar", dan jika tidak, ia "menunggu" untuk dua gerakan sehingga semut lainnya pasti akan pergi.  Dalam satu kasus, tindakan ini untuk dua ukuran, di yang lain - untuk satu ukuran. <br><br><h4>  Lokasi yang tidak terjangkau </h4><br>  Bug lain yang tidak menyenangkan yang memaksa saya untuk mengulang pemrosesan memori adalah bahwa beberapa tempat yang bisa dilihat semut itu tidak terjangkau baginya.  Mereka muncul karena penempatan "salib rumput" saya yang malas di tanah, yang terkadang tergantung di atas air.  Ini membuat saya menggeneralisasi tugas langkah. <br><br>  Ketika mengirimkan permintaan untuk pencarian makanan, semut sering memiliki ingatan tentang tempat-tempat yang benar-benar tidak dapat dijangkau (mereka melihat rumput di atas air dan dengan <em>gila</em> - <em>gilaan</em> ingin mengumpulkannya).  Jika tidak ditandai dalam ingatan mereka (misalnya, variabel boolean "dapat dijangkau"), maka mereka terus mengingat ini dan menulis ke antrian hingga tindakan ini adalah satu-satunya.  Hal ini menyebabkan penghambatan yang parah, karena mereka <em>terus melakukan operasi pencarian jalur di setiap langkah, berusaha untuk sampai ke sana, dan gagal</em> . <br><br>  Solusinya adalah memperbarui memori dalam tugas langkah jika tidak dapat menemukan jalur ke tempat itu, menandainya dalam memori sebagai tidak dapat dicapai.  Selain itu, tugas pencarian hanya menanyakan tempat dengan makanan untuk kenangan yang bisa dijangkau. <br><br><h2>  Sistem secara umum </h2><br>  Secara umum, saya ingin mengatakan - ya, saya menyesal telah menghabiskan satu minggu hidup saya di maraton pemrograman karena saya terinspirasi untuk membuat bot yang melakukan apa yang saya katakan kepada mereka (dan juga apa yang ingin mereka lakukan!).  Saya harus melakukan beberapa trik dan belajar banyak. <br><br>  Sistem yang saya buat tidak 100% andal, dan saya masih melihat beberapa artefak.  Misalnya, sebagai arah untuk mem-parsing tampilan, aksinya digunakan atas-bawah dan kiri-kanan, yaitu, memori terakhir ada di sudut kanan bawah.  Saat mengingat informasi untuk mencari item, ini berarti makhluk cenderung bergerak ke tenggara.  Ini terutama terlihat dalam simulasi besar, ketika, rumput tumbuh dengan cepat dan sedikit membungkuk ke arah tenggara, terlepas dari biji. <br><br><h3>  Perangkat tambahan </h3><br>  Saya pikir diperlukan perbaikan signifikan untuk mensimulasikan ingatan yang lebih kompleks dari makhluk yang lebih kompleks. <br><br>  Ini termasuk meningkatkan keandalan fungsi pemrosesan memori, serta menambahkan primitif baru, seperti "berpikir", dan turunan dari tugas tingkat tinggi, seperti "memutuskan" atau "mimpi".  "Berpikir" mungkin merupakan tindakan primitif dari permintaan memori.  "Mimpi", pada gilirannya, dapat terdiri dari beberapa panggilan "pikir": memilih memori acak, mendapatkan properti acak, dan mengulanginya berulang kali untuk memperkuat tema umum atau asosiasi penting. <br><br>  Untuk masa depan, saya merencanakan tiga tambahan khusus: <br><br><ul><li>  Tambahkan penanganan terputus dan prioritas tugas </li><li>  Tambahkan komunikasi antar entitas </li><li>  Tambahkan struktur grup sehingga entitas dapat secara resmi mengidentifikasi satu sama lain </li></ul><br>  Memproses gangguan dan memprioritaskan tugas mungkin diperlukan untuk interaksi antar entitas, karena bot tidak dapat secara membabi buta melanjutkan aktivitasnya ketika mereka berkomunikasi dengannya (entah bagaimana harus "mendengarkan") atau diserang ("melarikan diri" atau "melawan" ) <br><br>  Komunikasi antara entitas mungkin terdiri dari satu atau dua tugas primitif untuk bertukar memori atau membuat permintaan ke memori bot lain (misalnya, "katakan" atau "tanya").  Dengan cara ini, informasi seperti lokasi makanan atau sumber daya lainnya dapat dikirimkan. <br><br>  Saya berharap dapat melaksanakan tugas-tugas ini dan menyusun grafik tingkat akumulasi sumber daya oleh kelompok besar dengan dan tanpa komunikasi.  Populasi sudah melacak jumlah makanan yang dikumpulkan dalam setiap ukuran.  Akan menarik untuk menunjukkan bahwa berbagi kenangan dapat memengaruhi efisiensi. <br><br><h3>  Masa depan </h3><br>  Fungsi yang paling penting untuk mensimulasikan masyarakat adalah menambah struktur kelompok dan memberikan sifat-sifat tingkat makro pada kelompok-kelompok ini, misalnya, â€œtujuan dan tanggung jawabâ€ bersama mereka.  Ini memberi kita semacam "benih" dari mana kita bisa mendapatkan tugas tingkat tinggi yang didelegasikan ke dalam hierarki struktur kelompok untuk tugas tingkat tinggi "lebih rendah" yang secara langsung mempengaruhi dunia.  Ini juga memungkinkan Anda untuk membuat bentuk struktur politik. <br><br>  Sistem seperti itu cukup mandiri, dan visualisasi hanya ditumpangkan di atasnya.  Akan sangat sederhana untuk mengganti serangga dengan humanoids, mengumpulkan sumber daya dan menyimpannya di suatu tempat, sehingga tumbuh dalam ukuran.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sifat pertumbuhan rumah mereka dapat, misalnya, sangat tergantung atau sepenuhnya independen dari aksi bot. </font><font style="vertical-align: inherit;">Spesies yang berbeda mungkin memiliki suku yang berbeda dengan karakteristik dan tren yang berbeda pula. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, saya dapat menggabungkan sistem ini dengan generator peta yang dibuat sebelumnya (memperluas kelas dunia) untuk membuat dunia lebih nyata.</font></font><br><br><h2>  Kesimpulannya </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam waktu dekat, saya berencana untuk mengganti makhluk dengan orang-orang dan mengimplementasikan beberapa fungsi terakhir. </font><font style="vertical-align: inherit;">Mungkin saya akan menerbitkan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode sumber lengkap</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ketika saya meningkatkan kualitas sistem (di beberapa tempat kode agak kacau). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tunggu artikel selanjutnya. </font><font style="vertical-align: inherit;">Sementara itu, di sini ada video dengan lebah mencari serbuk sari dalam bunga; </font><font style="vertical-align: inherit;">mereka dikodekan menggunakan kerangka kerja yang sama.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/b31/7d5/332b317d547edc53f2b2ffee6c3d4861.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya memilih benih ini karena titik awalnya terletak di sebuah pulau kecil. </font><font style="vertical-align: inherit;">Namun, lebah tidak diprogram untuk kembali ke sarang, tetapi hanya terus mengumpulkan serbuk sari. </font><font style="vertical-align: inherit;">Anda mungkin memperhatikan bahwa jangkauan penglihatan mereka lebih tinggi dan terkadang mereka dengan sengaja pindah ke bunga yang baru saja mereka lihat. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... dan di sini adalah fungsi anggota Tugas Bee:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Task::Bee(Garden &amp;garden, Population &amp;population, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (&amp;arguments)[<span class="hljs-number"><span class="hljs-number">10</span></span>]){ <span class="hljs-comment"><span class="hljs-comment">//Just Search for Flowers if(initFlag){ //Define our Tasks Task take("Take Food", botID, &amp;Task::take); Task eat("Eat Food", botID, &amp;Task::consume); Task search("Locate Food", botID, &amp;Task::search); search.args[0] = population.bots[botID].forage; queue.push(eat); queue.push(take); queue.push(search); initFlag = false; } //Work off our allocated queue. if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ //Put the Task back on queue.push(newtask); } //If it was successful, we leave it off return false; } initFlag = true; return true; }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443252/">https://habr.com/ru/post/id443252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443242/index.html">Quarkus adalah Jawa subatom supersonik. Tinjauan singkat kerangka kerja</a></li>
<li><a href="../id443244/index.html">Tugas pembekalan. Beanpoisk_1</a></li>
<li><a href="../id443246/index.html">Bagaimana kami menciptakan kembali Askozia IP PBX setelah proyek dijual dan ditutup oleh pengembang</a></li>
<li><a href="../id443248/index.html">Protokol reservasi mulus PRP dan HSR</a></li>
<li><a href="../id443250/index.html">Pengumpul Sampah Homemade untuk OpenJDK</a></li>
<li><a href="../id443254/index.html">Triton adalah virus paling mematikan</a></li>
<li><a href="../id443256/index.html">PowerShell, dump dari pengalaman saya</a></li>
<li><a href="../id443258/index.html">Gotify - proyek sumber terbuka untuk mengirimkan pemberitahuan dan mengirim pesan ke server</a></li>
<li><a href="../id443260/index.html">Bermigrasi ke Zimbra tanpa mempertaruhkan bisnis dengan domain umum</a></li>
<li><a href="../id443262/index.html">Saran buruk: bagaimana cara menulis dokumentasi teknis? Bagian Tiga dan Terakhir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>