<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔜 👨🏻‍✈️ 👨🏼‍🔧 Jaringan saraf dan filosofi bahasa 👃🏽 😮 🤞🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa teori Wittgenstein tetap menjadi dasar dari semua NLP modern 

 Representasi vektor kata-kata mungkin salah satu ide paling indah dan romantis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jaringan saraf dan filosofi bahasa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435984/"> <font color="gray">Mengapa teori Wittgenstein tetap menjadi dasar dari semua NLP modern</font> <br><br>  Representasi vektor kata-kata mungkin salah satu ide paling indah dan romantis dalam sejarah kecerdasan buatan.  Filsafat bahasa adalah cabang filsafat yang mengeksplorasi hubungan antara bahasa dan realitas dan bagaimana membuat pembicaraan bermakna dan dimengerti.  Representasi vektor kata adalah metode yang sangat spesifik dalam Pemrosesan Bahasa Alami (NLP) modern.  Dalam arti tertentu, ini adalah bukti empiris dari teori Ludwig Wittgenstein, salah satu filsuf paling relevan di abad terakhir.  Bagi Wittgenstein, penggunaan kata-kata adalah langkah dalam <i>permainan</i> bahasa sosial yang dimainkan oleh anggota komunitas yang saling memahami.  Arti kata hanya tergantung pada kegunaannya dalam suatu konteks, itu tidak sesuai satu dengan satu dengan objek dari dunia nyata. <br><br><blockquote>  Untuk kelas besar kasus di mana kita menggunakan kata "makna", itu dapat didefinisikan sebagai <b>arti dari kata itu penggunaannya dalam bahasa</b> . </blockquote><a name="habracut"></a><br>  Tentu saja, memahami makna kata yang tepat sangat sulit.  Ada banyak aspek yang perlu dipertimbangkan: <br><br><ul><li>  objek mana kata dapat merujuk; </li><li>  bagian mana dari pidato itu; </li><li>  apakah itu ekspresi idiomatik; </li><li>  semua nuansa makna; </li><li>  dan sebagainya. </li></ul><br>  Semua aspek ini, pada akhirnya, datang ke satu hal: untuk mengetahui cara menggunakan kata. <br><br>  Konsep <i>makna</i> dan mengapa serangkaian karakter yang diperintahkan memiliki konotasi yang pasti dalam bahasa tidak hanya pertanyaan filosofis, tetapi juga mungkin masalah terbesar yang harus ditangani oleh spesialis AI yang bekerja dengan NLP.  Sangat jelas bagi orang yang berbahasa Rusia bahwa "anjing" adalah "hewan", dan itu lebih mirip "kucing" daripada "lumba-lumba", tetapi tugas ini jauh dari sederhana untuk solusi sistematis. <br><br>  Setelah sedikit mengoreksi teori Wittgenstein, kita dapat mengatakan bahwa anjing terlihat seperti kucing karena mereka sering muncul dalam konteks yang sama: Anda mungkin dapat menemukan anjing dan kucing yang terkait dengan kata "rumah" dan "taman" daripada dengan kata "laut" dan "lautan".  Intuisi inilah yang mendasari <b>Word2Vec</b> , salah satu implementasi vektor representasi kata yang paling terkenal dan sukses.  Saat ini, mesin jauh dari <i>pemahaman</i> nyata teks panjang dan bagian, tetapi representasi vektor kata tidak diragukan lagi satu-satunya metode yang memungkinkan kita untuk mengambil langkah terbesar ke arah ini selama dekade terakhir. <br><br><h1>  Dari BoW ke Word2Vec </h1><br>  Dalam banyak masalah komputer, masalah pertama adalah menyajikan data dalam bentuk numerik;  kata-kata dan kalimat mungkin yang paling sulit dibayangkan dalam bentuk ini.  Dalam pengaturan kami, kata-kata <b>D</b> dipilih dari kamus, dan setiap kata dapat diberi indeks angka <b>i</b> . <br><br>  Selama beberapa dekade, pendekatan klasik telah diambil untuk mewakili setiap kata sebagai vektor dimensi-D numerik dari semua nol kecuali satu di posisi i.  Sebagai contoh, pertimbangkan kamus tiga kata: "anjing", "kucing" dan "lumba-lumba" (D = 3).  Setiap kata dapat direpresentasikan sebagai vektor tiga dimensi: "anjing" sesuai dengan [1,0,0], "kucing" hingga [0,1,0], dan "lumba-lumba", jelas, [0,0,1].  Dokumen dapat direpresentasikan sebagai vektor dimensi-D, di mana setiap elemen menghitung kemunculan kata ke-i dalam dokumen.  Model ini disebut Bag-of-words (BoW), dan telah digunakan selama beberapa dekade. <br><br>  Meskipun sukses di tahun 90-an, BoW tidak memiliki satu-satunya fungsi kata yang menarik: artinya.  Kita tahu bahwa dua kata yang sangat berbeda dapat memiliki arti yang sama, bahkan jika mereka sama sekali berbeda dari sudut pandang ejaan.  "Kucing" dan "anjing" keduanya adalah hewan peliharaan, "raja" dan "ratu" dekat satu sama lain, "apel" dan "rokok" sama sekali tidak terkait.  Kita <i>tahu</i> ini, tetapi dalam model BoW, semua kata ini berada pada jarak yang sama dalam ruang vektor: 1. <br><br>  Masalah yang sama berlaku untuk dokumen: menggunakan BoW, kita dapat menyimpulkan bahwa dokumen hanya serupa jika mengandung kata yang sama beberapa kali.  Dan inilah Word2Vec, yang memperkenalkan istilah pembelajaran banyak pertanyaan filosofis yang dibahas Wittgenstein dalam <i>Studi Filosofisnya</i> 60 tahun yang lalu. <br><br>  Dalam kamus ukuran D, di mana kata itu diidentifikasi oleh indeksnya, tujuannya adalah untuk menghitung representasi vektor N-dimensi dari setiap kata untuk N &lt;&lt; D.  Idealnya, kami ingin itu menjadi vektor padat yang mewakili beberapa aspek makna semantik tertentu.  Sebagai contoh, kami idealnya ingin "anjing" dan "kucing" memiliki representasi yang sama, dan "apel" dan "rokok" sangat jauh dalam ruang vektor. <br><br>  Kami ingin melakukan beberapa operasi aljabar dasar pada vektor, seperti <code>+−=</code> .  Saya ingin jarak antara vektor "aktor" dan "aktris" untuk secara substansial bertepatan dengan jarak antara "pangeran" dan "putri".  Meskipun hasil ini sangat utopis, percobaan menunjukkan bahwa vektor Word2Vec menunjukkan properti yang sangat dekat dengan ini. <br><br>  Word2Vec tidak secara langsung mempelajari pandangan dari ini, tetapi menerimanya sebagai produk sampingan dari klasifikasi tanpa guru.  Rata-rata dataset kata corpus NLP terdiri dari serangkaian kalimat;  setiap kata dalam kalimat muncul dalam konteks kata-kata di sekitarnya.  Tujuan dari pengklasifikasi adalah untuk memprediksi kata target, dengan mempertimbangkan kata-kata kontekstual sebagai input.  Untuk kalimat "brown dog plays in the garden" kata-kata [brown, plays, in, garden] disediakan untuk model sebagai input, dan dia harus memprediksi kata "dog".  Tugas ini dianggap sebagai pembelajaran tanpa guru, karena corpus tidak perlu ditandai dengan sumber kebenaran eksternal: jika Anda memiliki serangkaian kalimat, Anda selalu dapat secara otomatis membuat contoh positif dan negatif.  Melihat “anjing coklat bermain di kebun” sebagai contoh positif, kita dapat membuat banyak pola negatif, seperti “pesawat cokelat bermain di taman” atau “bermain anggur coklat di kebun”, menggantikan kata target “anjing” dengan kata-kata acak dari kumpulan data. <br><br>  Dan sekarang penerapan teori Wittgenstein sangat jelas: konteksnya sangat penting untuk representasi vektor kata-kata, karena penting untuk melampirkan makna pada kata dalam teorinya.  Jika dua kata memiliki makna yang sama, mereka akan memiliki representasi yang sama (jarak kecil dalam ruang dimensi N) hanya karena mereka sering muncul dalam konteks yang sama.  Dengan demikian, "kucing" dan "anjing" pada akhirnya akan memiliki vektor dekat karena mereka sering muncul dalam konteks yang sama: berguna bagi model untuk menggunakan representasi vektor yang sama untuk mereka, karena ini adalah hal yang paling nyaman yang bisa dia lakukan, untuk mendapatkan hasil yang lebih baik dalam memprediksi dua kata berdasarkan konteksnya. <br><br>  Artikel asli menawarkan dua arsitektur yang berbeda: CBOW dan Skip-gram.  Dalam kedua kasus, representasi verbal diajarkan bersama dengan tugas klasifikasi tertentu, memberikan representasi vektor kata terbaik yang memaksimalkan kinerja model. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b9/e32/ee7/2b9e32ee767ad0c402e214a566d848a0.png"><br>  <i><font color="gray">Gambar 1. Perbandingan arsitektur CBOW dan Skip-gram</font></i> <br><br>  <b>CBOW</b> adalah singkatan dari Continuous Bag of Words, dan tugasnya adalah menebak kata dengan konteks sebagai input.  Input dan output direpresentasikan sebagai vektor dimensi-D yang diproyeksikan dalam ruang dimensi-N dengan bobot yang sama.  Kami hanya mencari bobot proyeksi.  Bahkan, representasi vektor kata adalah matriks D × N, di mana setiap baris mewakili kata kamus.  Semua kata konteks diproyeksikan dalam satu posisi, dan representasi vektornya dirata-ratakan;  oleh karena itu, urutan kata tidak mempengaruhi hasilnya. <br><br>  <b>Lewati-gram</b> melakukan hal yang sama, tetapi sebaliknya: mencoba untuk memprediksi kata konteks <b>C</b> , mengambil kata target sebagai input.  Tugas memprediksi beberapa kata kontekstual dapat dirumuskan kembali menjadi satu set masalah klasifikasi biner independen, dan sekarang tujuannya adalah untuk memprediksi keberadaan (atau tidak adanya) kata-kata kontekstual. <br><br>  Sebagai aturan, Skip-gram membutuhkan lebih banyak waktu untuk pelatihan dan sering memberikan hasil yang sedikit lebih baik, tetapi, seperti biasa, aplikasi yang berbeda memiliki persyaratan yang berbeda, dan sulit untuk memperkirakan sebelumnya mana yang akan menunjukkan hasil terbaik.  Meskipun konsepnya sederhana, mempelajari arsitektur semacam ini adalah mimpi buruk karena jumlah data dan daya pemrosesan yang diperlukan untuk mengoptimalkan bobot.  Untungnya, di Internet Anda dapat menemukan beberapa representasi vektor pra-terlatih kata-kata, dan Anda dapat mempelajari ruang vektor - yang paling menarik - hanya dengan beberapa baris kode Python. <br><br><h1>  Kemungkinan peningkatan: GloVe dan fastText </h1><br>  Selama Word2Vec klasik dalam beberapa tahun terakhir, banyak kemungkinan perbaikan telah diusulkan.  Dua yang paling menarik dan umum digunakan adalah GloVe (Stanford University) dan fastText (dikembangkan oleh Facebook).  Mereka berusaha mengidentifikasi dan mengatasi keterbatasan algoritma asli. <br><br>  Dalam sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ilmiah asli</a> , penulis GloVe menekankan bahwa pelatihan model pada konteks lokal yang terpisah membuat penggunaan statistik korpus global yang buruk.  Langkah pertama untuk mengatasi batasan ini adalah membuat matriks global <b>X</b> , di mana setiap elemen <b>i, j</b> menghitung jumlah referensi ke kata <b>j</b> dalam konteks kata <b>i</b> .  Gagasan penting kedua dari dokumen ini adalah pemahaman bahwa hanya probabilitas saja tidak cukup untuk prediksi nilai yang andal, dan matriks co-kejadian juga diperlukan, dari mana aspek-aspek tertentu dari nilai dapat langsung diekstraksi. <br><br><blockquote>  Pertimbangkan dua kata i dan j yang sangat menarik.  Untuk konkret, anggaplah kita tertarik pada konsep keadaan termodinamika, yang dengannya kita dapat mengambil <code>i = </code> dan <code>j = </code> .  Hubungan kata-kata ini dapat diselidiki dengan mempelajari rasio probabilitas mereka untuk kejadian bersama menggunakan kata-kata yang terdengar berbeda, k.  Untuk kata-kata k yang terkait dengan es tetapi bukan uap, katakan <code>k = </code> [padatan, keadaan materi], kami berharap bahwa rasio Pik / Pjk akan lebih besar.  Demikian pula, untuk kata k yang terkait dengan uap, tetapi tidak dengan es, katakan <code>k = </code> , rasionya harus kecil.  Untuk kata-kata seperti "air" atau "mode", yang sama-sama terkait dengan es dan uap, atau tidak ada hubungannya dengan mereka, rasio ini harus dekat dengan persatuan. </blockquote><br>  Rasio probabilitas ini menjadi titik awal untuk mempelajari representasi vektor kata-kata.  Kami ingin dapat menghitung vektor yang, dalam kombinasi dengan fungsi spesifik <b>F,</b> menjaga rasio ini konstan dalam ruang representasi vektor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/d5d/137/4dcd5d13763ca26ad997565ec2e6e513.jpg"></div><br>  <i><font color="gray">Gambar 2. Rumus paling umum untuk representasi vektor kata-kata dalam model GloVe</font></i> <br><br>  Fungsi F dan ketergantungan pada kata k dapat disederhanakan dengan mengganti eksponensial dan perbaikan offset, yang memberikan fungsi meminimalkan kesalahan dengan metode kuadrat terkecil <b>J</b> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/049/738/e48049738a71657b998f5630dac792c4.jpg"></div><br>  <i><font color="gray">Gambar 3. Fungsi akhir dari komputasi representasi vektor kata-kata dalam model GloVe</font></i> <br><br>  Fungsi <b>f</b> adalah fungsi penghitungan yang mencoba untuk tidak membebani kecocokan yang sangat sering dan langka, sedangkan <b>bi</b> dan <b>bj</b> adalah offset untuk mengembalikan simetri fungsi.  Dalam paragraf terakhir artikel ini terlihat bahwa pelatihan model ini pada akhirnya tidak jauh berbeda dengan pelatihan model Skip-gram klasik, meskipun dalam tes empiris GloVe lebih unggul daripada kedua implementasi Word2Vec. <br><br>  Di sisi lain, <b>fastText</b> mengoreksi kelemahan Word2Vec yang sama sekali berbeda: jika pelatihan model dimulai dengan pengkodean langsung satu vektor dimensi-D, maka struktur internal kata-kata diabaikan.  Alih-alih langsung menyandikan kode kata yang mempelajari representasi verbal, fastText menawarkan untuk mempelajari N-gram karakter dan mewakili kata-kata sebagai jumlah vektor N-gram.  Misalnya, dengan N = 3, kata "bunga" dikodekan sebagai 6 gram 3 berbeda [&lt;fl, flo, low, Debt, wer, er&gt;] ditambah urutan khusus &lt;flower&gt;.  Perhatikan bagaimana kurung sudut digunakan untuk menunjukkan awal dan akhir kata.  Dengan demikian, sebuah kata diwakili oleh indeksnya dalam kamus kata-kata dan sekumpulan N-gram yang dikandungnya, dipetakan ke bilangan bulat menggunakan fungsi hash.  Peningkatan sederhana ini memungkinkan Anda untuk membagi representasi N-gram antara kata-kata dan menghitung representasi vektor kata-kata yang tidak ada dalam kasus pembelajaran. <br><br><h1>  Eksperimen dan kemungkinan aplikasi </h1><br>  Seperti yang telah kami katakan, untuk <b>menggunakan</b> representasi vektor ini, Anda hanya perlu beberapa baris kode Python.  Saya melakukan beberapa percobaan dengan <a href="">model GloVe 50-dimensi</a> , dilatih pada 6 miliar kata dari kalimat Wikipedia, serta dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model fastText 300-dimensi, dilatih pada Common Crawl</a> (yang memberikan 600 miliar token).  Bagian ini menyediakan tautan ke hasil dari kedua percobaan hanya untuk membuktikan konsep dan memberikan pemahaman umum tentang topik tersebut. <br><br>  Pertama-tama, saya ingin memeriksa beberapa kesamaan dasar kata-kata, fitur paling sederhana tetapi penting dari representasi vektor mereka.  Seperti yang diharapkan, kata yang paling mirip dengan kata "anjing" adalah "kucing" (0,92), "anjing" (0,85), "kuda" (0,79), "anak anjing" (0,78) dan "hewan peliharaan" (0,77).  Perhatikan bahwa bentuk jamak memiliki arti yang hampir sama dengan bentuk tunggal.  Sekali lagi, cukup sepele bagi kita untuk mengatakan itu, tetapi untuk mobil itu sama sekali bukan fakta.  Sekarang makanan: kata-kata yang paling mirip untuk "pizza" adalah "sandwich" (0,87), "sandwich" (0,86), "camilan" (0,81), "makanan yang dipanggang" (0,79), "kentang goreng" (0,79) dan "burger" ( 0,78).  Masuk akal, hasilnya memuaskan, dan modelnya berperilaku cukup baik. <br><br>  Langkah selanjutnya adalah melakukan beberapa perhitungan dasar dalam ruang vektor dan memeriksa seberapa benar model telah memperoleh beberapa properti penting.  Memang, sebagai hasil dari penghitungan vektor <code>+-</code> , hasilnya adalah “aktris” (0,94), dan sebagai hasil dari penghitungan <code>+-</code> , kata “raja” (0,86) diperoleh.  Secara umum, jika nilainya adalah <code>a:b=c:d</code> , maka kata <b>d</b> harus diperoleh sebagai <code>d=b-a+c</code> .  Pindah ke tingkat berikutnya, tidak mungkin untuk membayangkan bagaimana operasi vektor ini bahkan menggambarkan aspek geografis: kita tahu bahwa Roma adalah ibu kota Italia, karena Berlin adalah ibu kota Jerman, bahkan <code>+-= (0.88)</code> , dan <code>+-= (0.83)</code> . <br><br>  Dan sekarang untuk bagian yang menyenangkan.  Mengikuti ide yang sama, kami akan mencoba menambah dan mengurangi konsep.  Misalnya, Apa yang setara dengan pizza Amerika untuk Italia?  <code>+-= (0.60)</code> , lalu <code> (0.59)</code> .  Sejak saya pindah ke Belanda, saya selalu mengatakan bahwa negara ini adalah campuran dari tiga hal: sedikit kapitalisme Amerika, dingin dan kualitas hidup Swedia, dan, akhirnya, sejumput kekayaan Neapolitan.  Dengan sedikit mengubah teorema asli, menghilangkan sedikit presisi Swiss, kita mendapatkan Holland (0,68) sebagai hasil dari <code>++-</code> : cukup mengesankan, jujur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd8/f76/e41/fd8f76e41d78598394d1613652f44f26.png"><br>  <i><font color="gray">Gambar 4. Untuk semua pembaca Belanda: anggap ini sebagai pujian, oke?</font></i> <br><br>  Sumber daya praktis yang baik dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> untuk menggunakan representasi vektor pra-terlatih ini.  <b>Gensim</b> adalah perpustakaan Python sederhana dan lengkap dengan beberapa fungsi aljabar dan kesamaan siap pakai.  Representasi vektor pra-terlatih ini dapat digunakan dengan berbagai cara (dan berguna), misalnya, untuk meningkatkan kinerja penganalisa suasana hati atau model bahasa.  Apa pun tugasnya, menggunakan vektor dimensi-N akan secara signifikan meningkatkan efisiensi model dibandingkan dengan pengkodean langsung.  Tentu saja, pelatihan representasi vektor dalam area spesifik akan semakin meningkatkan hasilnya, tetapi ini mungkin memerlukan, mungkin, upaya dan waktu yang berlebihan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435984/">https://habr.com/ru/post/id435984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435970/index.html">Panduan Pemula untuk Pengembangan Server Web dengan Node.js</a></li>
<li><a href="../id435972/index.html">Memperkenalkan pemrograman reaktif di Spring</a></li>
<li><a href="../id435974/index.html">Three.js - lakukan kontrol untuk ruang atau planetarium</a></li>
<li><a href="../id435976/index.html">WebMerupakan produksi dan "ladang ranjau" Smart TV: wawancara dengan Andrei Nagih</a></li>
<li><a href="../id435978/index.html">Solusi Perlindungan Biometrik</a></li>
<li><a href="../id435986/index.html">Windows akan memesan 7 GB untuk pembaruan sistem untuk menghindari kehabisan ruang hard disk</a></li>
<li><a href="../id435988/index.html">Pengantar anotasi jenis Python. Lanjutan</a></li>
<li><a href="../id435990/index.html">Bagaimana cara beralih?</a></li>
<li><a href="../id435992/index.html">Pemain Fallout 76, yang akan ditangkap di lokasi rahasia pengembang, akan diblokir</a></li>
<li><a href="../id435994/index.html">Apakah itu Karma, sayang, atau mengapa serangan pada jaringan nirkabel yang seharusnya tenggelam terlupakan masih hidup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>