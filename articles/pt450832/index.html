<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèø üí≥ üë®‚Äç‚ù§Ô∏è‚Äçüë® A hist√≥ria de uma anima√ß√£o üö∂üèª üñïüèΩ üõÄüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uma vez, o designer ligou para o front-end e pediu para fazer uma "teia de aranha" atr√°s do vidro emba√ßado. Mas ent√£o descobriu-se que essa n√£o era um...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A hist√≥ria de uma anima√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/450832/"> Uma vez, o designer ligou para o front-end e pediu para fazer uma "teia de aranha" atr√°s do vidro emba√ßado.  Mas ent√£o descobriu-se que essa n√£o era uma ‚Äúteia de aranha‚Äù, mas uma grade hexagonal, e n√£o atr√°s do vidro, mas foi para longe, e o front-end n√£o estava familiarizado com o WebGL, e eu tive que aprender toda a anima√ß√£o no processo de desenho.  Esse front-end foi <b>Yuri Artyukh</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">akella</a> ). <br><br><img src="https://habrastorage.org/webt/4b/db/la/4bdblauwhfg83othzzcjlfdjzf0.jpeg"><br><br>  Yuri se dedica a escrever h√° muito tempo e, aos domingos, registra fluxos com an√°lises de projetos reais.  Ele n√£o √© profissional no WebGL, n√£o faz mapas, n√£o escreve no Web assembler, mas gosta de aprender algo novo.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FrontendConf</a> RIT ++, Yuri contou como conduzir uma anima√ß√£o do layout √† entrega ao cliente para que todos ficassem felizes e aprendesse o WebGL ao longo do caminho.  A hist√≥ria vem da perspectiva da primeira pessoa e inclui: Three.js, GLSL, Canvas 2D, gr√°ficos e um pouco de matem√°tica. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Eq_rXOyOX0I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Teia de aranha por tr√°s do vidro emba√ßado </h2><br>  De alguma forma, sentei-me e trabalhei em um projeto importante.  Em seguida, o designer do est√∫dio telefona, no qual gosta de efeitos especiais, e pergunta: "Voc√™ pode fazer uma teia de aranha, como se estivesse atr√°s de um vidro emba√ßado?" <br><br>  Isso, √© claro, descreve imediatamente todo o problema.  Como se viu depois, a "teia de aranha" atr√°s do vidro emba√ßado era essa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/da/0z/bn/da0zbnmw-g-0_jwatgdtvlevqk4.jpeg" width="600"></div><br><br>  Esta √© uma grade hexagonal, mas para o designer, por algum motivo, uma "teia de aranha".  Vidro emba√ßado - essa grade fica distante.  Dificuldades de comunica√ß√£o.  Imagine como √© dif√≠cil ser introvertido e fazer anima√ß√µes?  Mas sou assim e √© isso que estou fazendo. <br><br>  Essa "web" n√£o se parece com uma anima√ß√£o, ap√≥s a qual voc√™ pode escrever um relat√≥rio sobre um caso de sucesso, abrir uma startup, obter um bilh√£o de investimentos, ter um monte de f√£s e lan√ßar um foguete no espa√ßo.  O que √© isso tudo?  Uma linha marrom em um fundo branco-cinza, como se estivesse desenhada por um mouse.  Mais tarde, descobriu-se que ela deveria ir al√©m dos limites, mas mais sobre isso depois.  Em geral, o codinome √© "a web por tr√°s do vidro emba√ßado". <br><br>  No site com essa anima√ß√£o, havia v√°rias outras op√ß√µes para a ‚Äúteia de aranha‚Äù: em um fundo cinza no topo, em um branco abaixo.  Era necess√°rio torn√°-lo interativo para responder ao movimento do mouse do usu√°rio. <br><br>  A primeira coisa que os designers me perguntaram √© qu√£o dif√≠cil e quanto vai custar.  Alguns pensamentos passaram pela minha cabe√ßa: como desenhar uma linha e uma grade assim, como faz√™-la n√£o desacelerar, como deveria funcionar.  Eu nunca encontrei isso antes.  Mas, como uma pessoa envolvida no desenvolvimento, ele respondeu: " <i>√â f√°cil, vamos fazer isso ..."</i> <br><br>  Eu gosto de me envolver em aventuras estranhas, porque quando fa√ßo isso, geralmente sofro. <br><br><blockquote>  Atrav√©s do sofrimento vem o crescimento.  √â inevitavelmente associado ao sofrimento - voc√™ n√£o pode ser feliz com tudo, viver feliz e, ao mesmo tempo, se desenvolver profissionalmente. </blockquote><br><h2>  Three.js </h2><br>  Comecei imediatamente a pensar em como resolver o problema.  Como tudo estava em 3D, lembrei-me do <b>Three.js</b> .  Esta √© a biblioteca mais popular mencionada em todas as confer√™ncias.  Essa biblioteca torna o WebGL mais simples, mais conveniente e mais agrad√°vel do que apenas o WebGL nativo. <br><br>  O Three.js possui muitos objetos prontos.  <b>PlaneGeometry</b> √© o primeiro objeto que me pareceu perfeito.  Este √© um plano primitivo.  A biblioteca possui todos os tipos de hex√°gonos, dodecaedros, icosaedros, cilindros, mas existe um plano simples de muitos tri√¢ngulos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1b/d6/zh/1bd6zhhmntwqmvhlzc6fe8pt5u8.jpeg" width="600"></div><br>  <i>Existem muitos tri√¢ngulos, porque preciso de ondas detalhadas - a superf√≠cie deve se preocupar.</i> <br><br>  Se voc√™ olhar dentro do Three.js, na verdade esse plano √© um objeto JS simples, com uma lista de todas as coordenadas dos pontos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/4l/2s/ma4l2so6e_q2_njrkzrjsdibylu.jpeg" width="600"></div><br><br>  No meu caso, eu tenho um plano de 50 √ó 50 quadrados, ent√£o eu precisava de 2601 v√©rtices.  Por que 50 √ó 50 = 2601?  Isso √© matem√°tica da escola.  A coordenada z = 0, porque o plano, y = 1, porque esta √© a primeira linha de v√©rtices de 50 pe√ßas, e x muda. <br><br>  Mas por que preciso de um avi√£o, preciso dobr√°-lo de alguma forma?  A primeira coisa que voc√™ pode fazer com uma matriz √© executar opera√ß√µes matem√°ticas nela.  Por exemplo, percorra o <code>for each</code> loop e atribua a coordenada z ao valor senoidal da coordenada x. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rl/4t/vx/rl4tvxjhweazbjcjjakkaxv38nw.jpeg" width="600"></div><br><br>  Aconteceu algo semelhante a uma onda senoidal, porque o valor da altura de cada v√©rtice ser√° igual ao seno desse valor ao longo do eixo x.  Para complicar isso de alguma forma (agora ser√° um momento matem√°tico dif√≠cil, prepare-se) - acrescentarei tempo ao seno e essa tela se mover√°, simplesmente porque a matem√°tica funciona dessa maneira.  Se voc√™ adicionar tempo √† coordenada x, o gr√°fico se mover√° horizontalmente.  Se coordenar y - se mover√° verticalmente.  Eu estava interessado em movimento horizontal - queria que meu oceano se preocupasse. <br><br>  O designer n√£o esperava que eu tivesse um senoide que se arrasta da esquerda para a direita.  Ele queria que fosse bonito, como uma teia de aranha, um oceano ou o que quer que estivesse em sua cabe√ßa.  Portanto, a op√ß√£o com um senoide n√£o se encaixava.  Demorou algum tipo de aleatoriedade.  O avi√£o n√£o deveria ter sido previs√≠vel como uma onda senoidal.  Mas se voc√™ chamar aleatoriamente para cada um desses picos, obteremos a pr√≥pria imprevisibilidade. <br><br>  A ess√™ncia da aleatoriedade √© que √© aleat√≥ria e independente.  Cada v√©rtice aleat√≥rio n√£o depende de seus vizinhos de forma alguma.  Aleatoriamente, nenhum par√¢metro √© passado, ele n√£o se importa com os vizinhos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xi/_i/-z/xi_i-z1fxtzdkobj8rvyw5zdwum.jpeg" width="600"></div><br><br>  O resultado √© uma curva quebrada que se assemelha ao oceano ou √† web apenas remotamente.  Mais adequado como ilustra√ß√£o para um filme sobre "hackers" e arrombamentos cibern√©ticos. <br><br>  Se voc√™ olhar aleatoriamente do ponto de vista de cada ponto da tela, parecer√° ru√≠do branco - muitos pequenos pontos brancos e pretos.  Cada ponto √© preto e branco - 0 ou 1. <br><br>  Mas o que eu preciso para criar um oceano de ondas deve ficar assim. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ko/gf/4r/kogf4rlg2l22xip6a0bnppd2oym.jpeg" width="600"></div><br>  <i>Assemelha-se a nevoeiro, nuvens e montanhas.</i> <br><br>  Existem fun√ß√µes aleat√≥rias que retornam essas imagens.  Eles s√£o chamados de ru√≠dos ou <b>ru√≠do</b> : ru√≠do simples, ru√≠do Perlin.  Perlin em nome do ru√≠do √© o nome do criador do algoritmo de ru√≠do do gradiente, que retorna um belo aleat√≥rio.  Ele o criou trabalhando nos efeitos especiais da primeira parte do filme "Tron".  Esse algoritmo matem√°tico j√° existia antes, mas agora √© usado ativamente em filmes e jogos. <br><br>  Quando mapas aleat√≥rios s√£o gerados em "Heroes of Might and Magic III" (para maiores de 30 anos) ou em estrat√©gias., Geralmente voc√™ pode ver algo semelhante.  √â sempre a mesma fun√ß√£o que retorna esses ru√≠dos. <br><br>  Existe todo um movimento "arte generativa".  Os participantes geram obras de arte, paisagens, usando a fun√ß√£o de ru√≠do.  Por exemplo, na figura abaixo, uma paisagem pseudo-natural de um dos artistas.  N√£o est√° claro imediatamente se √© matem√°tica ou a topografia de uma montanha.  A tarefa da arte Generativa √© precisamente gerar matematicamente uma paisagem indistingu√≠vel do presente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qe/lw/ky/qelwkyrefwhms3hhd_gbd7azazs.jpeg" width="600"></div><br><br>  Verificou-se que, diferentemente da aleatoriedade, essa fun√ß√£o recebe par√¢metros, porque os pontos devem depender dos vizinhos mais pr√≥ximos.  Se voc√™ usar a fun√ß√£o de ru√≠do em vez da aleatoriedade usual, obter√° algo assim. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ce/og/ti/ceogtizjdrzw3kfbrdz6n1cnqra.jpeg" width="600"></div><br>  <i>Preto e branco √© simplesmente altura: 0 s√£o vales pretos, 1 s√£o picos brancos.</i>  <i>Acontece uma superf√≠cie ondulada.</i> <br><br>  Esta fun√ß√£o est√° em todos os PLs porque √© apenas um algoritmo - senos, cossenos, multiplica√ß√£o. <br><br>  Eu posso fazer a distor√ß√£o da mesma maneira, percorrendo todos os v√©rtices do meu objeto PlaneGeometry, atribuindo cada valor √† fun√ß√£o de ru√≠do: <br><br><pre> <code class="javascript hljs">geometry.vertices.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { vz = noise(vx, vy, time); });</code> </pre> <br>  A fun√ß√£o ocupa apenas 30-40 linhas, mas √© matematicamente complexa. <br><br>  Existem fun√ß√µes de ru√≠do de todas as dimens√µes: unidimensional, bidimensional e tridimensional.  No meu caso, isso √© ru√≠do tridimensional, porque tr√™s par√¢metros s√£o passados ‚Äã‚Äãpara ele.  Al√©m das coordenadas espaciais dos planos x e y, transmito tempo - a superf√≠cie se torce constantemente, muda de posi√ß√£o. <br><br><h2>  Three.js!  == GPU </h2><br>  Quando iniciei o algoritmo, as ondas come√ßaram a se mover.  Quando fa√ßo algo para a Web, sempre olho no criador de perfil e agora tamb√©m procurei.√â assim que as ondas estavam l√°. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9r/os/qg/9rosqgaqfwrqwxnnzmxhhw-1szq.jpeg" width="600"></div><br><br>  Na tela, h√° um quadro desenhado pelo navegador.  Os quadros s√£o indicados por linhas tracejadas cinzas verticais.  Dentro do quadro, 2/3 do tempo √© ocupado pela execu√ß√£o da fun√ß√£o de ru√≠do.  Quando voc√™ anima algo na Web, usa o quadro de anima√ß√£o de solicita√ß√£o, que √© executado a cada 16 ms, na melhor das hip√≥teses.  O quadro a cada 16 ms conta a fun√ß√£o de ru√≠do para 2600 v√©rtices.  Para cada v√©rtice, s√£o considerados um movimento para cima e para baixo e a altura.  Em cada quadro subsequente, os valores s√£o recalculados, porque a superf√≠cie deve viver no tempo. <br><br>  Acontece que a fun√ß√£o de ru√≠do, que girou 2600 vezes, j√° ocupa 2/3 do quadro no meu computador.  E este n√£o √© o quadro todo.  Ao desenvolver anima√ß√µes, isso j√° √© uma bandeira vermelha. <br><br><blockquote>  Nenhuma anima√ß√£o deve ocupar mais da metade do quadro. </blockquote><br>  Se houver mais, existe um alto risco de perder o quadro durante qualquer intera√ß√£o, qualquer bot√£o, qualquer passagem do mouse. <br><br>  Portanto, era uma bandeira vermelha dura.  Percebi que o Three.js n√£o √© necessariamente WebGL.  Apesar de parecer usar o Three.js, desenhei tudo em 3D, foi renderizado no WebGL, n√£o obtive um desempenho fant√°stico do WebGL.  Eu tenho apenas 2.600 v√©rtices - isso n√£o √© suficiente para o WebGL.  Por exemplo, em cada mapa existem milhares de objetos, cada um consistindo em dezenas de tri√¢ngulos.  Estime a escala: centenas de milhares s√£o normais, mas existem apenas 2600 picos. <br><br><h2>  Vertex Shader </h2><br>  Ap√≥s um problema com os quadros, descobri que existem shaders.  Existem apenas dois tipos deles: <br><br><ul><li>  Vertex Shader; <br></li><li>  Shader de fragmento. <br></li></ul><br>  Eu estava interessado no vertex shader - Vertex Shader.  Se reescrevermos a anima√ß√£o, ela ficar√° assim: <br><br><pre> <code class="javascript hljs">position.z = noise( vec3(position.x, position.y, time) );</code> </pre> <br>  <code>Position.z</code> - coordenadas z do componente de cada ponto com seus pr√≥prios tipos de dados.  <code>vec3</code> indica que haver√° tr√™s par√¢metros. <br><br><blockquote>  N√£o h√° loop no shader. </blockquote><br>  Antes disso, no script, coloquei um <code>for each</code> loop e, para cada v√©rtice, os c√°lculos ocorreram em um loop.  A diferen√ßa entre shaders e n√£o shaders √© a aus√™ncia de um ciclo. <br><br><blockquote>  Shader - este √© o ciclo. </blockquote><br>  √â executado em paralelo para todos os v√©rtices de uma s√≥ vez.  Este √© o seu principal significado, e miss√£o, e chip e miss√£o. <br><br>  A GPU na placa de v√≠deo possui um n√∫cleo maior, diferente da CPU do processador principal.  No processador, h√° muito menos deles, mas √© capaz de executar c√°lculos universais mais rapidamente.  C√°lculos muito simples est√£o dispon√≠veis na placa de v√≠deo, mas existem muitos n√∫cleos, permitindo paralelizar muitos c√°lculos.  Isso √© o que geralmente acontece em shaders.  O significado do sombreador de v√©rtice √© que o ru√≠do ser√° calculado em paralelo para 2600 v√©rtices no sombreador na placa de v√≠deo. <br><br>  Se voc√™ olhar para o criador de perfil, a apar√™ncia da anima√ß√£o n√£o ser√° alterada, mas ser√° parecida com esta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/xv/et/k7xvetot_x1xphmbrtsfkifz8mc.jpeg" width="600"></div><br><br>  <b>Nada √© executado na CPU</b> .  Obviamente, outro segmento na GPU foi adicionado abaixo.  Tamb√©m existem threads na GPU, CPU, trabalhadores da Web, mas esses c√°lculos j√° ser√£o realizados em um thread separado na placa de v√≠deo. <br><br>  Claro, isso n√£o √© gratuito.  A placa de v√≠deo no trabalho √© aquecida mais que o processador principal.  Portanto, frequentemente quando voc√™ visita sites com anima√ß√µes semelhantes, os f√£s come√ßam a trabalhar para voc√™.  Isso ocorre porque, quando a placa de v√≠deo √© ligada, ela requer resfriamento, ao contr√°rio do resto do tempo.  Em dispositivos m√≥veis, isso √© mais importante do que em computadores de mesa - os telefones celulares simplesmente acabam mais r√°pido.  Mas, ao mesmo tempo, voc√™ obt√©m um ganho de desempenho bastante radical. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hh/x-/zr/hhx-zrjk_c8ftrd4hjdqhohcn1a.jpeg" width="600"></div><br>  <i>O resultado √© essa superf√≠cie - esse √© o ru√≠do perlin habitual.</i>  <i>Se voc√™ iniciar e alterar apenas o tempo, s√£o obtidas ondas frias.</i> <br><br>  Mas isso n√£o √© tudo.  Eu ainda era obrigado a "teia de aranha" - uma grade hexagonal na superf√≠cie.  Tendo experi√™ncia em layout, a maneira mais simples e √≥bvia √© selecionar um fragmento que possa ser repetido.  Curiosamente, para uma grade hexagonal, ela n√£o √© quadrada, mas retangular.  Se voc√™ repetir o padr√£o como um ret√¢ngulo, obt√©m uma grade.  A biblioteca Three.js permite sobrepor png e n√£o aprender todo o WebGL antes disso.  Eu cortei png e coloquei na superf√≠cie, ficou algo assim. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8n/gc/p0/8ngcp0pi_2s1st4ubwo8sgh8zps.jpeg" width="600"></div><br><br>  √Ä primeira vista, o que voc√™ precisa!  Mas s√≥ a princ√≠pio.  Isso n√£o me agradou, j√° que a anima√ß√£o era necess√°ria para o site de criptomoeda - tudo deveria ser "caro, rico". <br><br>  Quando voc√™ usa texturas png e elas est√£o pr√≥ximas da c√¢mera, voc√™ pode ver que as bordas do elemento mais pr√≥ximo est√£o emba√ßadas.  N√£o h√° sensa√ß√£o de que a imagem esteja clara.  O png parece ter se estendido no navegador.  O problema √© que, no WebGL, n√£o h√° como usar texturas de vetor no sentido pleno da palavra.  Ent√£o eu chorei e li na Internet que o <b>GLSL</b> resolve esse problema. <br><br>  GLSL √© uma linguagem do tipo C na qual os shaders s√£o escritos.  Todo mundo tem medo de us√°-lo, porque esses s√£o shaders, WebGL - nada est√° claro!  Mas descobri que √© poss√≠vel criar imagens n√≠tidas e voltei para o segundo tipo de sombreador. <br><br><h2>  Tonalizador de fragmentos </h2><br>  Esse shader faz a mesma coisa que o v√©rtice.  Por√©m, se o v√©rtice construir uma superf√≠cie de polilinha, executando c√°lculos para cada v√©rtice, o sombreador de fragmento calcular√° a cor de cada pixel da superf√≠cie. <br><br>  A fun√ß√£o mais b√°sica de <code>fragment shader ‚Äì step(a,b)</code> .  Retorna apenas 0 e 1: <br><br><ul><li>  se a&gt; b, ent√£o 0; <br></li><li>  se a &lt;b, ent√£o 1. <br></li></ul><br>  Fiz uma pseudo-implementa√ß√£o em JS para deixar claro como essa fun√ß√£o √© simples. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">step</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Quando voc√™ trabalha no WebGL, geralmente em qualquer objeto, existe um sistema de coordenadas.  Se for um objeto quadrado, o sistema de coordenadas √© primitivo: pontos (0,0), (0,1), (1,0), (1,1). <br><br>  Um sombreador de fragmento √© executado para cada pixel.  Se o Vertex Shader for 2600 vezes por quadro, o Fragment Shader ser√° executado quantas vezes houver pixels.  Talvez um milh√£o de vezes para cada quadro, se a superf√≠cie for 1000 √ó 1000 px.  Parece assustador, mas simplesmente porque poucas pessoas est√£o familiarizadas com os recursos das placas de v√≠deo em nosso tempo. <br><br>  Se voc√™ usar a fun√ß√£o step (a, b) com as coordenadas desses pixels, poder√° executar a fun√ß√£o step com o par√¢metro 0.4 e passar a coordenada x de cada pixel para cada ponto. <br><br>  Acontece que tudo que for menor que 0,4 ser√° 0, tudo que for maior que 1. No WebGL, n√∫meros e cores s√£o iguais.  Cada cor √© um n√∫mero.  Branco - 1, preto - 0. Existem tr√™s deles em RGB, mas ainda s√£o 0.0.0 e 1.1.1. <br><br><img src="https://habrastorage.org/webt/0g/yn/u8/0gynu8ekf6ms9lbsxses7zlnsq8.jpeg"><br><br>  Se executarmos essa fun√ß√£o passo mais complicado, ficaremos brancos √† esquerda.  Esta fun√ß√£o ser√° executada para cada ponto da tela e considerar√° que √© 0 ou 1. Isso √© normal, n√£o se preocupe. <br><br>  Se voc√™ multiplicar essas duas express√µes, obter√° uma faixa branca vertical.  Se voc√™ fizer o mesmo em um eixo diferente, poder√° desenhar um quadrado branco: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/-m/bd/ed-mbd_kkdxv-lfxhmgk4iixr3o.jpeg" width="600"></div><br>  <i>Deveria ser o cl√≠max - desenh√°mos um quadrado branco!</i> <br><br><blockquote>  Usando combina√ß√µes de apenas uma fun√ß√£o, voc√™ pode desenhar o que quiser. </blockquote><br>  Se voc√™ se lembra, os elementos do padr√£o estavam em √¢ngulo.  Se voc√™ criar uma superf√≠cie inclinada, que consiste apenas em cores preto e branco, ela ser√° nervurada, n√£o suavizada.  Nervuras chamam sua aten√ß√£o - √© feio.  Para tornar a superf√≠cie mais suave para os olhos, s√£o necess√°rios n√£o apenas pixels em preto e branco, mas tamb√©m meios-tons cinza. <br><br><h3>  Smoothstep </h3><br>  Os shaders t√™m uma fun√ß√£o de passo suave.  Faz o mesmo que passo, mas interpola entre 0 e 1 para que haja um gradiente. <br><br><img src="https://habrastorage.org/webt/70/ie/sj/70iesjc9whr9omw98d6vgdegn7u.jpeg"><br>  <i>Da esquerda para a direita, ap√≥s a compacta√ß√£o m√°xima.</i> <br><br>  Se voc√™ compactar essa fun√ß√£o o m√°ximo poss√≠vel, obter√° uma linha com gradiente m√≠nimo.  √â exatamente isso que voc√™ precisa para gerar uma linha perfeitamente suave em qualquer √¢ngulo no sombreador Fragment. <br><br>  Ent√£o eu pude fazer um quadrado branco com bordas suaves.  Se houver um quadrado branco, voc√™ pode fazer 3 quadrados brancos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mk/vj/yj/mkvjyjhkpspu2gyr07ljvav8f0e.jpeg" width="600"></div><br>  <i>Quadrados podem ser girados, use as fun√ß√µes de seno e cosseno.</i> <br><br>  Ent√£o eu tive que usar papel e uma folha para quebrar meu padr√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hp/a4/yz/hpa4yzizs2urt92ucauxlgwr3ny.jpeg" width="600"></div><br>  <i>Captura de tela da produ√ß√£o.</i> <br><br>  L√° tudo est√° conectado com 23 graus diferentes de multiplicidade, por isso n√£o foi muito dif√≠cil calcular as coordenadas de todos esses pontos.  E ent√£o voc√™ pode obter esse padr√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wr/81/kt/wr81ktna90gxloib0ainetldwrk.jpeg" width="600"></div><br><br>  Desenhei um fragmento e o repeti v√°rias vezes.  Voc√™ pode ver claramente o modo de depura√ß√£o, onde o padr√£o se repete.  Todos os fragmentos s√£o realizados usando as fun√ß√µes param√©tricas <code>step</code> e <code>smoothstep</code> .  Isso significa que, ao criar um padr√£o para inclinar o plano, voc√™ pode gerar um n√∫mero infinito desses padr√µes.  Se dentro do fragmento alteramos a espessura da linha ou o tamanho dos hex√°gonos, obtemos muitos outros padr√µes. <br><br>  Torci os par√¢metros e encontrei um n√∫mero infinito de padr√µes.  √â como "arte generativa" - n√£o est√° claro o que foi feito, mas de maneira bonita. <br><br><h3>  SDF </h3><br>  Ent√£o descobri que tamb√©m existem <b>campos de dist√¢ncia assinados - gerando imagens com um mapa de dist√¢ncia</b> .  O SDF √© usado em cart√µes ou em jogos de computador para desenhar textos e objetos, porque √© ideal.  No WebGL, √© dif√≠cil desenhar texto de uma maneira diferente, especialmente suave e delineada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-k/il/9h/-kil9h7eyazgilry_p6tqdmqvxw.jpeg" width="600"></div><br><br>  Este √© um formato matem√°tico dif√≠cil de usar fora do WebGL.  A ideia √© simples, mas elegante e d√° um efeito bonito. <br><br>  Se quisermos desenhar uma estrela clara, precisamos salvar a imagem √† direita - esta √© a imagem gerada da imagem.  J√° existe um algoritmo que transforma qualquer imagem clara em desfocada.  Depois disso, ele pode ser usado para gerar uma vers√£o clara, mas, ao mesmo tempo, n√£o temos uma imagem, mas muitas.  A partir de uma imagem clara do mesmo tamanho, voc√™ pode gerar o mesmo, mas maior.  Ser√° com erros, mas a abordagem √© matematicamente interessante. <br><br>  Por exemplo, se voc√™ tirar uma foto com um tamanho de 128 √ó 128 px, a partir de uma foto em tamanho pequeno, poder√° obter uma imagem n√≠tida v√°rias vezes maior que a origem.  Essa √© uma das raz√µes pelas quais eles usam SDF - uma fonte borrada geralmente pesa menos do que em um formato vetorial otimizado. <br><br>  Claro, h√° uma limita√ß√£o.  √â imposs√≠vel aumentar as letras para 1000 px, mesmo 100 px parecer√£o feios.  Mas com que frequ√™ncia s√£o necess√°rias fontes desse tamanho? <br><br>  Shader de fragmentos, desenhando ret√¢ngulos, espalhados - com a ajuda dessas perturba√ß√µes, finalmente consegui encontrar a superf√≠cie desejada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t1/nf/5h/t1nf5hhliercxy0q6axrs4bmosm.jpeg" width="600"></div><br><br><h2>  Novas condi√ß√µes </h2><br>  Ela era como deveria: se contorcendo, todos os elementos estavam claros.  Tudo estava como eu queria, mas aconteceu que havia mais: <br><br>  <i>- E deixe-o se mover com o mouse e um novo caminho est√° sendo tra√ßado.</i>  <i>E os favos de mel s√£o destacados!</i> <br><br>  Supunha-se que, quando o usu√°rio move o mouse, ele metaforicamente abre seu caminho espinhoso ao longo da "teia de aranha" quebrada usando o servi√ßo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/da/0z/bn/da0zbnmw-g-0_jwatgdtvlevqk4.jpeg" width="600"></div><br><br>  N√£o √© dif√≠cil descrever a tarefa em palavras, mas como implement√°-la?  A primeira coisa que pensei - como tenho uma grade hexagonal, provavelmente j√° foi estudada.  Ent√£o me deparei com um artigo interessante ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia de refer√™ncia e implementa√ß√£o de grade hexagonal</a> ‚Äù.  Nele, o autor coletou materiais por 20 anos.  Ele √© legal sem questionar, e o artigo √© divino para quem gosta de algoritmos e matem√°tica.  Ele cont√©m muitos dados interessantes sobre malhas hexagonais. <br><br>  O artigo √© longo, mas cont√©m abordagens matem√°ticas interessantes: como construir um sistema de coordenadas em uma grade hexagonal, como numerar esses hex√°gonos e depois se referir a eles onde √© usado.  Acontece que isso sempre esteve diante dos meus olhos, porque em jogos antigos de computador s√£o usadas redes hexagonais em todos os lugares. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hp/l5/eb/hpl5ebbnsk_y4wwpe68txgddw3a.jpeg" width="600"></div><br>  <i>Se voc√™ j√° est√° afinado com um traste hexagonal - olhe para o castelo.</i>  <i>Em outras texturas, uma grade hexagonal tamb√©m √© adivinhada.</i> <i><br><br></i> <div style="text-align:center;"> <i><img src="https://habrastorage.org/webt/pm/t3/dr/pmt3dricwm2bhfavsrk4alsb_4i.jpeg" width="600"></i> </div> <i><br></i>  <i>Em "Civiliza√ß√£o", tudo √© geralmente √≥bvio.</i> <br><br>  Tamb√©m foi interessante saber que, se voc√™ faz uma se√ß√£o transversal ao longo da diagonal de um cubo tridimensional, que consiste em muitos cubos pequenos, ent√£o, por um lado, s√£o cubos e, por outro, hex√°gonos regulares. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yi/or/en/yiorenlgrsykxcxcajtomaq-rf0.jpeg" width="600"></div><br><br>  A se√ß√£o transversal de um cubo tridimensional fornece uma grade hexagonal bidimensional.  Foi divertido aprender que cubos tridimensionais est√£o de alguma forma conectados com hex√°gonos bidimensionais. <br><br>  No artigo, inclusive, havia um algoritmo para encontrar o caminho ao longo da grade hexagonal.  Eu tive que procurar uma maneira de altura atrav√©s do mouse. <br><br>  Os algoritmos de busca de caminhos s√£o complexos e simples.  O mais primitivo √© desenhar uma linha entre os pontos e ver em quais hex√°gonos essa linha se encaixa.  Acontece que, antigamente, as unidades passavam do ponto A ao ponto B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/f1/qj/gzf1qjc4ygip7wfnbfam_x3gl1c.jpeg" width="600"></div><br>  <i>Eu precisava de algo assim.</i> <br><br>  Mas n√£o √© disso que eu preciso.  Aqui o caminho √© colocado ao longo das √°reas dos hex√°gonos, e eu preciso ao longo das bordas.  Eu tive que resolver o problema de maneira diferente. <br><br><h3>  Canvas2d </h3><br>  Talvez haja maneiras melhores, mas a minha √© mais interessante.  No come√ßo, desenhei o <b>Canvas2D</b> para minha depura√ß√£o - etapa 1. <br><br><img src="https://habrastorage.org/webt/c0/jb/sx/c0jbsx3mwra1bhrek7v7lsmzs6u.jpeg"><br><br>  Antes disso, havia WebGL, Three.js, shaders, e isso √© apenas o Canvas2D!  Eu desenhei todos os pontos da grade hexagonal nela.  Se voc√™ olhar de perto, esses s√£o os mesmos hex√°gonos.  Ent√£o me lembrei dos gr√°ficos que armazenam informa√ß√µes sobre como os pontos s√£o conectados entre si, e os conectamos com os tr√™s vizinhos e obtemos um gr√°fico - passo n√∫mero 2. Para isso, usei Open Source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Beautiful Graphs</a> . <br><br>  Um gr√°fico √© simplesmente uma cole√ß√£o de pontos e informa√ß√µes sobre como eles est√£o conectados.  Eles s√£o bem estudados, existem muitos bons algoritmos para todos os gostos, para encontrar o caminho do ponto A ao ponto B dentro do gr√°fico.  Todos os cart√µes usam esse tipo de algoritmo. <br><br>  Parece algo assim. <br><br><pre> <code class="javascript hljs">graph = createGraph( ); graph.addNode(..); <span class="hljs-comment"><span class="hljs-comment">// 1000 nodes graph.addLink(..); // 3000 links graph.pathFinder(Start, Finish); //0.01s</span></span></code> </pre> <br>  Constru√≠mos um gr√°fico, adicionamos 1000 pontos e todas as conex√µes entre eles. Em seguida, passamos o <code>id</code> cada ponto - o primeiro est√° conectado ao terceiro, o terceiro ao quinto.  N√£o h√° necessidade de inventar nada, existe um algoritmo otimizado com uma fun√ß√£o pronta que permitir√° que voc√™ encontre esse caminho. <br><br>  Esse algoritmo executa menos de um quadro.  Obviamente, √© preciso algum tipo de recurso, mas voc√™ n√£o precisa execut√°-lo a cada 16 ms, mas apenas quando o caminho muda. <br><br>  Ent√£o, eu pude construir essa rota no passo n√∫mero 3. No Canvas2D, ele come√ßou a ficar assim: o caminho mais curto do ponto A ao ponto B - tudo, como na vida.  √Ä primeira vista, parece que este n√£o √© o caminho mais curto, mas acontece que existem muitos caminhos mais curtos do ponto A ao ponto B ao longo da grade hexagonal. <br><br>  No WebGL, todas as imagens s√£o n√∫meros.  L√° voc√™ pode transferir texturas no shader, por exemplo, tentei transferir png.  N√£o h√° diferen√ßa para o navegador - ele √© passado png ou Canvas2D.  Para o navegador Canvas2D, √© o mesmo que a imagem final, bitmap.  Portanto, eu primeiro desenhei essa imagem na forma de uma cobra.      ‚Ññ 4. <br><br>  Canvas2D       .     Canvas2D    ,     ‚Äî        .  ,   .   ,       Canvas2D  3D,  ,       . <br><br>  , ,   WebGL     ‚Äî  ,     ¬´, ¬ª,     . <br><br> ,     ,      Canvas2D,     ,          ,    .     Canvas2D   ,         WebGL,       . <br><br><img src="https://habrastorage.org/webt/z6/uk/kv/z6ukkv00x1pzffhp1ctfd7q7tiw.jpeg"><br> <i> :  ,     ,    .</i> <br><br>   ,   --. ,    ,         ¬´¬ª . <br><br><h2>     ? </h2><br>    : ¬´   ?   ?¬ª  ,     : ¬´,  !¬ª.    ,  .       . <br><br>   ,      WebGL. ,      .          ,     WebGL.     2  ‚Äî ,    . <br><br> , ,    . ,   . <br><br><img src="https://habrastorage.org/webt/yx/0s/kk/yx0skkl_xmwk-ekewducomsgvxs.jpeg">        ,     .   ,   ,  ,     3D   ‚Äî      . <br><br>   ,            .     ,   ,      . <br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FrontendConf</a>   .       ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    Canvas</a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  RxJS</a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JSX  React</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>    30     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> .       ,  ,   . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt450832/">https://habr.com/ru/post/pt450832/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt450822/index.html">Estruturas desaparecendo</a></li>
<li><a href="../pt450824/index.html">O estado do css</a></li>
<li><a href="../pt450826/index.html">Como falar com o microcontrolador da JS</a></li>
<li><a href="../pt450828/index.html">Quando a cidade adormece ...</a></li>
<li><a href="../pt450830/index.html">Nikita Dubko sobre confer√™ncias, s√≠ndrome de impostor e relat√≥rios</a></li>
<li><a href="../pt450834/index.html">An√°lise de sites - e isso geralmente √© legal na R√∫ssia?</a></li>
<li><a href="../pt450836/index.html">Nos trilhos atr√°s das nuvens: como lavar o vidro em um arranha-c√©u</a></li>
<li><a href="../pt450838/index.html">Por que a unidade n√£o √© atribu√≠da a n√∫meros primos e quando geralmente era considerada um n√∫mero</a></li>
<li><a href="../pt450840/index.html">A √∫ltima lanterna est√° cansada ou o piscar salvar√° a Bielorr√∫ssia (atual. Spinner?)</a></li>
<li><a href="../pt450844/index.html">Introdu√ß√£o ao mapeamento de exemplo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>