<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏻 💸 👩🏿‍🎨 文本编辑器不是您的最高数学，这里您需要考虑 🧝🏻 🧗🏽 🛳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="现代的文本编辑器不仅可以发出提示音，而且不能离开程序。 事实证明，它们内部代谢非常复杂。 想知道正在采取什么技巧来快速重新计算坐标，如何将样式，折叠和软包装附加到文本上以及如何对其进行全部更新，功能数据结构和优先级队列与文本有什么关系以及如何欺骗用户-欢迎来到猫！ 



 本文基于Alexei K...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>文本编辑器不是您的最高数学，这里您需要考虑</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/424763/">现代的文本编辑器不仅可以发出提示音，而且不能离开程序。 事实证明，它们内部代谢非常复杂。 想知道正在采取什么技巧来快速重新计算坐标，如何将样式，折叠和软包装附加到文本上以及如何对其进行全部更新，功能数据结构和优先级队列与文本有什么关系以及如何欺骗用户-欢迎来到猫！ <br><br><img src="https://habrastorage.org/webt/sr/i0/vg/sri0vg3jog_-mc16jc5zz-wjxw0.jpeg"><br><br> 本文基于Alexei Kudryavtsev与Joker 2017的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报道</a> 。Alexei在JetBrains中编写Intellij IDEA已有大约10年的时间。 在剪切下，您将找到报告的视频和文本成绩单。 <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YzWr9CN6cGQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h1> 文本编辑器内部的数据结构 </h1><br> 要了解编辑器的工作原理，让我们编写它。 <br><br><img src="https://habrastorage.org/webt/q9/nb/-n/q9nb-nr675yuu19v6loydkq3nrm.png"><br><br> 就是这样，我们最简单的编辑器已准备就绪。 <br><br> 在编辑器内部，文本最容易存储在Java类StringBuffer中的字符数组中，或者存储相同的字符（就内存组织而言）。 要通过偏移量获取某些字符，我们调用StringBuffer.charAt（i）方法。 为了将在键盘上键入的字符插入其中，我们调用StringBuffer.insert（）方法，该方法会将字符插入到中间的某个位置。 <br><br> 尽管此编辑器简单易用，但最有趣的是，您可以发明出最好的主意。 它既简单又几乎总是很快。 <br><br> 不幸的是，此编辑器出现了比例尺问题。 想象一下，我们在其中打印了很多文本，并且打算在中间插入另一个字母。 将会发生以下情况。 我们迫切需要通过将所有其他字母向前移动一个字符来释放该字母的空间。 为此，我们将字母移动一个位置，然后移动下一个位置，依此类推，直到文本的最后。 <br><br> 这是它在内存中的外观： <br><br><img src="https://habrastorage.org/webt/ec/uk/r4/ecukr4oxdmj0tlxojojwuf9k8i4.gif"><br><br> 转移所有这么多兆字节不是很好：这很慢。 当然，对于现代计算机而言，这是一件小事-来回移动的某种可悲的兆字节。 但是对于非常活跃的文本更改，这可能会很明显。 <br><br> 为了解决在中间插入字符的问题，很久以前提出了一种称为“间隙缓冲区”的解决方法。 <br><br><h3> 间隙缓冲 </h3><br> 差距就是差距。 正如您可能想象的那样，缓冲区是一个缓冲区。  Gap Buffer数据结构是一个空缓冲区，以防万一，我们将其保留在文本中间。 如果需要打印某些内容，可以使用此小型文本缓冲区进行快速键入。 <br><br><img src="https://habrastorage.org/webt/vc/ca/v4/vccav4jbt0zboaf_fuo985dzerc.png"><br><br> 数据结构有所变化-数组保留在原位，但是出现了两个指针：在缓冲区的开头和结尾。 要从编辑器获取某个偏移量的字符，我们需要了解它是在此缓冲区之前还是之后，并稍微校正偏移量。 要插入一个字符，我们首先需要将间隙缓冲区移到该位置并用这些字符填充它。 而且，当然，如果我们超出了缓冲区的范围，则将以某种方式重新创建它。 这就是图片中的样子。 <br><br><img src="https://habrastorage.org/webt/bu/4a/gs/bu4ags_jk9vobq_9rxegbww01nw.gif"><br><br> 如您所见，我们首先在一个小的间隙缓冲区（蓝色矩形）上移动了很长时间到编辑位置（简单地依次从其左右边缘交换字符）。 然后，我们使用此缓冲区，在其中键入字符。 <br><br> 如您所见，没有兆字节字符的移动，插入速度非常快，而且持续了一定的时间，似乎每个人都很高兴。 一切似乎都很好，但是如果我们的处理器非常慢，则来回移动间隙缓冲区和文本会浪费大量时间。 在兆赫兹很小的时候，这一点尤其明显。 <br><br><h3> 件表 </h3><br> 就在那时，一家名为Microsoft的公司编写了文本编辑器Word。 他们决定采用另一种想法来加快编辑速度，即“ Piece Table”，即“ Piece Table”。 他们建议将编辑器的文本保存在最简单的相同字符数组中，该字符数组将不会更改，并将所有更改与这些相同的编辑片段放在单独的表中。 <br><br><img src="https://habrastorage.org/webt/gf/gt/gu/gfgtgutww7ymm-bx-4v7tytyjt4.png"><br><br> 因此，如果我们需要按偏移量查找某个字符，则需要找到我们编辑过的片段并从中提取该字符，如果不存在，请转到原始文本。 插入符号变得更加容易，我们只需要创建这个新片段并将其添加到表中即可。 这是图片中的外观： <br><br><img src="https://habrastorage.org/webt/94/8w/3u/948w3uylg_cuxh8mywws-owxs_i.gif"><br><br> 在这里，我们要删除偏移量5处的空间。为此，我们在切片表中添加了两个新片段：一个指示第一个片段（“ Bummer”），第二个指示编辑后的片段（“ sheep”）。 事实证明，它们之间的缝隙消失了，这两部分被粘合在一起，我们得到的新文本已经没有空格：“ Oblomovtsy”。 然后，我们在末尾添加新文本（“遭受Oblomovism的折磨”）。 使用额外的缓冲区，并将新的切片添加到计件表中，以指向此最新添加的文本。 <br><br> 如您所见，没有来回移动，所有文本都保留在原位。 坏消息是，越来越难以找到该符号，因为对所有这些片段进行分类非常困难。 <br><br> 总结一下。 <br><br>  <b>Piece Table有</b>什么好处： <br><br><ul><li> 快速嵌入； </li><li> 容易撤消； </li><li> 仅追加。 </li></ul><br> 不好的是： <br><br><ul><li> 访问文档非常困难； </li><li> 实施起来非常困难。 </li></ul><br> 让我们看看我们通常使用什么。 <br><br>  NetBeans，Eclipse和Emacs使用Gap Buffer-做得好！  Vi不会打扰，仅使用行列表。  Word使用计件表（它们最近列出了它们的古老种类，您甚至可以在其中了解一些内容）。 <br><br> 原子更有趣。 直到最近，他们才开始使用JavaScript行列表。 然后他们决定用C ++重写所有内容，并堆积了一个相当复杂的结构，该结构似乎类似于Piece Table。 但是这些片段不是存储在列表中，而是存储在树中以及所谓的splay树中-这是一棵在插入其中时会自动调整的树，因此最近的插入操作更快。 他们做了一件非常复杂的事情。 <br><br>  Intellij IDEA使用什么？ <br> 不，不是间隙缓冲。 不，你也是错的，不是一张桌子。 <br> 是的，非常正确，您自己的自行车。 <br><br> 事实是，IDE对存储文本的要求与常规文本编辑器中的要求略有不同。  IDE需要支持各种棘手的事情，例如竞争力，即从编辑器并行访问文本。 例如，使许多不同的烘焙食品可以阅读并做某事。  （检查是一小段代码，以一种或另一种方式解析程序-例如，查找引发NullPointerException的位置）。  IDE还需要可编辑的文本版本支持。 在处理文档时，多个版本同时存储在内存中，以便这些漫长的过程继续分析旧版本。 <br><br><h1> 问题所在 </h1><br><h3> 竞争力/版本控制 </h3><br> 为了保持并行性，通常将文本操作包装在“同步”或“读/写锁”中。 不幸的是，这不能很好地扩展。 另一种方法是不可变文本，即不可变文本存储库。 <br><br><img src="https://habrastorage.org/webt/ov/ia/sa/oviasaeniuwmhiaebpsic_mxm88.png"><br><br> 这是一个将不可变文档作为支持数据结构的编辑器的外观。 <br><br> 数据结构如何工作？ <br><br> 而不是字符数组，我们将拥有一个类型为ImmutableText的新对象，该对象以树的形式存储文本，其中小的子字符串存储在工作表中。 当以一定的偏移量访问时，他尝试到达该树的最底端，并且已经向他询问了我们所指的符号。 并且当您插入文本时，他会创建一棵新树并将其保存在旧位置。 <br><br><img src="https://habrastorage.org/webt/_2/xx/rh/_2xxrh9kohjwodn3ub-gyt2z8la.gif"><br><br> 例如，我们有一个文本为“无热量”的文档。 它被实现为具有两张替换“ Demon”和“ high-calorie”的树。 当我们要在中间插入“ pretty”行时，将创建文档的新版本。 确切地说，创建了一个新的根，上面已经附加了三张纸：“ Demon”，“足够”和“高热量”。 此外，这些新表中的两个可能引用了我们文档的第一版。 对于我们插入“ pretty”行的图纸，将分配一个新的顶点。 在这里，第一个版本和第二个版本都可以同时使用，并且它们都是不可变的。 一切看起来都很好。 <br><br> 谁使用棘手的结构？ <br><br><img src="https://habrastorage.org/webt/yf/mt/eh/yfmtehxbzlale_95bblpk2msh2k.jpeg"><br><br> 例如，在GNOME中，它们的一些标准小部件使用称为Rope的结构。  Xi-Editor是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Raf Levien</a>的新任出色编辑，使用了Persistent Rope。  Intellij IDEA使用此不可变树。 实际上，所有这些名称的后面或多或少都是相同的数据结构，并以树状表示。 除了GtkTextBuffer使用可变绳索外，即具有可变顶点的树，以及Intellij IDEA和Xi-Editor-不可变。 <br><br> 在现代IDE中开发字符存储库时，要考虑的下一件事称为多猫。 此功能使您可以使用多个笔架一次在多个位置进行打印。 <br><br><img src="https://habrastorage.org/webt/qb/ak/9t/qbak9tqjnu7v_iiciaouw-qqeug.gif"><br><br> 我们可以打印一些内容，同时在文档的多个位置插入我们打印的内容。 如果我们查看我们检查过的数据结构对多重插入符的反应，我们将看到一些有趣的东西。 <br><br><img src="https://habrastorage.org/webt/ty/4p/8k/ty4p8kuqs1rgeanxr9y3n9i8wz4.jpeg"><br><br> 如果我们在第一个原始编辑器中插入一个字符，则自然会花费线性时间来回移动一堆字符。 这写为O（N）。 反过来，对于基于Gap Buffer的编辑器，需要恒定的时间，为此他被创造了出来。 <br><br> 对于不可变的树，时间在对数上取决于大小，因为您必须首先从树的顶部到其叶子-这是对数，然后对于路径上的所有顶点为新树创建新顶点-这又是对数。 计件表也需要一个常数。 <br> 但是，如果我们尝试测量将字符插入到具有多笔架的编辑器中的时间（即在多个位置同时插入）的时间，则一切都会有所变化。 乍一看，时间似乎成比例地增加了C，即插入符号的位置数。 这就是实际发生的情况，除了Gap Buffer。 在他的情况下，时间（而不是C倍）意外地增加了一些难以理解的C * L倍，其中L是滑架之间的平均距离。 为什么会这样呢？ <br><br> 想象一下，我们需要在文档的两个位置插入“，on”行。 <br><br><img src="https://habrastorage.org/webt/ec/n3/jd/ecn3jdpnsvqscfbvjxivopbs5uq.gif"><br><br> 这就是此时在编辑器中发生的情况。 <br><br><ul><li> 在编辑器中创建一个间隙缓冲区（图片中的一个蓝色小矩形）； </li><li> 我们开始两辆马车（黑色粗线）。 </li><li> 我们正在尝试打印； </li><li> 在我们的Gap Buffer中插入一个逗号； </li><li> 您现在应该将其插入第二个支架的位置； </li><li> 为此，我们需要将间隙缓冲区移至下一个托架的位置。 </li><li> 将逗号打在第二位； </li><li> 现在，您需要在第一个笔架的位置插入下一个字符； </li><li> 而且我们必须将间隙缓冲区推回去； </li><li> 插入字母“ n”； </li><li> 然后，我们将受苦的缓冲区移到第二个滑架的位置。 </li><li> 我们在其中插入“ n”； </li><li> 将缓冲区移回以插入下一个字符。 </li></ul><br> 感觉一切都在哪里？ <br><br> 是的，事实证明，由于缓冲区的这种来回移动，我们的总时间增加了。 老实说，并不是因为它的增加而直接被吓到-在现代计算机上来回移动可悲的兆字节，千兆字节不是问题，但是有趣的是，这种数据结构在多猫的情况下工作原理截然不同。 <br><br><h3> 行太多？  LineSet！ </h3><br> 常规文本编辑器还有什么其他问题？ 最困难的问题是滚动，即在将笔架移至下一行时重新绘制编辑器。 <br><br><img src="https://habrastorage.org/webt/yt/0d/rn/yt0drnu1rsxyciwb4pruefmufyu.gif"><br><br> 当编辑器滚动时，我们需要了解从哪一行，从哪个符号开始在小窗口中绘制文本。 为此，我们需要快速了解哪条线对应于哪个偏移量。 <br><br><img src="https://habrastorage.org/webt/kn/ak/gm/knakgm1aq7-wnjwbruefxeyouh0.png"><br><br> 当我们需要通过行号了解其在文本中的偏移量时，有一个明显的接口。 反之亦然，通过在文本中的偏移量了解它在哪一行。 如何快速完成？ <br><br> 例如，像这样： <br><br> 将这些线组织成一棵树，并通过移动线的起点和线的终点来标记该树的每个顶点。 然后，为了通过偏移量了解它所在的行，您只需要在此树中运行对数搜索并找到它。 <br><br><img src="https://habrastorage.org/webt/x1/jq/3w/x1jq3w1gwiytzsrdytznnltc_l0.png"><br><br> 另一种方法甚至更容易。 <br><br> 在表格中写出行首与行尾的偏移量。 然后，要找到行号开头和结尾的偏移量，您将需要访问索引。 <br><br><img src="https://habrastorage.org/webt/wq/ls/wy/wqlswyl-k5brg4fsbgoxaqxkj1u.png"><br><br> 有趣的是，在现实世界中，两种方法都被使用。 <br><br><img src="https://habrastorage.org/webt/ii/w6/qu/iiw6quo2j0clh8xnovh0mfn5ow0.jpeg"><br><br> 例如，Eclipse使用了这样一种木制结构，如您所见，它在对数时间内可用于读取和更新。  IDEA使用表结构，其读取是一个快速常数，它是表中的索引反转，但是重建相当慢，因为更改行的长度时需要重建整个表。 <br><br><h3> 还是行太多？ 折叠！ </h3><br> 跨文本编辑器绊倒的还有什么不好？ 例如，折叠。 这些是您可以“折叠”并显示其他内容的文本。 <br><br><img src="https://habrastorage.org/webt/tp/g1/fc/tpg1fcoak4ahpzd1mbf9wex_jvi.png"><br><br> 图片中绿色背景上的这些点在我们后面隐藏了许多符号，但是如果我们对查看它们不感兴趣（例如，对于最长的无聊Java文档或导入列表而言），我们会将其隐藏起来，将其折叠省略号。 <br><br> 在这里，您需要再次了解它何时结束以及何时需要显示的区域开始，以及如何快速更新它们？ 这是如何组织的，我稍后再讲。 <br><br><h3> 太长的线？ 保鲜膜！ </h3><br><img src="https://habrastorage.org/webt/yu/lb/hg/yulbhgos7wf3ilx0gqtxg2lrkpq.jpeg"><br><br> 同样，没有软包装，现代编辑也无法生存。 图片显示开发人员在最小化后打开了JavaScript文件，并立即感到遗憾。 当我们尝试在编辑器中显示该巨大的JavaScript行时，它将不会适合任何屏幕。 因此，保鲜膜将其强行撕成几行，然后推入屏幕。 <br> 如何组织-稍后。 <br><br><h3> 太美了 </h3><br><img src="https://habrastorage.org/webt/md/yh/d0/mdyhd06genl8kiaehxjectze9g4.jpeg"><br><br> 最后，我也想给文字编辑带来美感。 例如，突出显示一些单词。 在上图中，关键字以粗体蓝色突出显示，一些静态方法用斜体显示，一些注释也用不同的颜色显示。 <br><br> 那么，如何仍然存储和处理折页，软包装和高光呢？ <br> 事实证明，所有这些原则上都是一项任务。 <br><br><h3> 太美了吗？ 范围荧光笔！ </h3><br><img src="https://habrastorage.org/webt/jj/rl/t7/jjrlt7sisz9curcqa5lotpzjfya.jpeg"><br><br> 为了支持所有这些功能，我们需要做的就是将某些文本属性粘贴到文本中的给定偏移处，例如颜色，字体或要折叠的文本。 而且，这些文本属性必须在此位置始终进行更新，以便它们能够经受各种插入和删除操作。 <br><br> 通常如何实施？ 自然地，以树的形式。 <br><br><h3> 问题：美丽太多？ 间隔树！ </h3><br><img src="https://habrastorage.org/webt/0e/ux/le/0euxleajuom5pdsa02kwxuudyny.jpeg"><br><br> 例如，在这里我们有几个要突出显示的黄色高光。 我们将这些突出显示的间隔添加到搜索树中，即所谓的间隔树。 这是同一棵搜索树，但是有点棘手，因为我们需要存储间隔而不是数字。 <br><br> 而且，由于既有健康间隔又有小间隔，如何对它们进行排序，相互比较以及将它们放入树中是一项相当艰巨的任务。 尽管在计算机科学中非常广为人知。 然后以某种方式查看您的休闲方式。 因此，我们将所有间隔都放在一棵树中，然后中间的某处文本的每次更改都会导致该树的对数更改。 例如，插入一个字符应导致更新该字符右边的所有间隔。 为此，我们找到该符号的所有主要顶点，并指出所有其顶点必须向右移动一个符号。 <br><br><h3> 还想要美丽吗？ 连字！ </h3><br><img src="https://habrastorage.org/webt/iv/j-/tb/ivj-tb9_w2ata-tiwclrmqfjs_a.jpeg"><br><br> 还有这么可怕的一件事-连字，我也想支持。 这些是不同的美，例如符号“！=”以大字形“不相等”的形式绘制，依此类推。 幸运的是，这里我们依靠一种摆动机制来支持这些连字。 而且，根据我们的经验，他显然是以最简单的方式工作。 在字体内部，存储了所有这些对字符的列表，将它们组合在一起时会形成某种棘手的连字。 然后，在画线时，Swing会简单地遍历所有这些对，找到必要的对并相应地进行绘制。 如果字体中有许多连字，则显然，显示它会成比例地减慢速度。 <br><br><h3> 刹车倾翻 </h3><br> 最重要的是，现代复杂编辑器中遇到的另一个问题是提示的优化，即按键并显示结果。 <br><br><img src="https://habrastorage.org/webt/fq/yb/wi/fqybwipttxn9pvl3phzc5qts6_k.jpeg"><br><br> 如果您进入Intellij IDEA并查看按下按钮时会发生什么，那么可能会发生以下恐怖事件： <br><br><ul><li> 单击按钮时，例如，如果键入一些“ Enter”，则必须查看是否在完成弹出窗口中以关闭菜单以完成操作。 </li><li> 您需要查看文件是否在某些棘手的版本控制系统下，例如Perforce，该系统需要采取一些措施才能开始编辑。 </li><li> 检查文档中是否有任何无法打印的特殊区域，例如一些自动生成的文本。 </li><li> 如果文档被尚未结束的操作阻塞，则需要完成格式化，然后再继续。 </li><li>  injected-,      ,       ,   -  . </li><li>     auto popup handler,    , ,       . </li><li>   info  ,     ,    .     selection remove,    selection  ,   .    selection ,    . </li><li>     typed handler,       ,      . </li><li>    . </li><li>  undo,  virtual space'   write action. </li><li> ,     . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">万岁！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不，这还不是全部。</font><font style="vertical-align: inherit;">如果缓冲区已满，请删除字符。</font><font style="vertical-align: inherit;">例如，在控制台中，调用侦听器，以便每个人都知道某些更改。</font><font style="vertical-align: inherit;">滚动编辑器视图。</font><font style="vertical-align: inherit;">叫其他一些愚蠢的听众。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当他发现文档已更改并调用DocumentListener时，现在在编辑器中会发生什么？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Editor.documentChanged（）中，将发生以下情况：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 更新错误条带； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 重新计算装订线尺寸，重新绘制； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 重新计算编辑器组件的大小，更改时发送事件； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 计算改变的线及其坐标； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果更改影响到他，则重新计算软包装； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 调用repaint（）。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此repaint（）只是Swing指示屏幕上的区域应重绘的指示。当Swing消息队列处理Repaint事件时，将发生真正的重绘。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，在半小时左右的某个时间里，将处理事件的队列出现，将在相应的组件上调用repaint方法，该方法将执行以下操作：</font></font><br><br><img src="https://habrastorage.org/webt/je/qh/cy/jeqhcytdxkun3ft_r7azwrby2eu.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，将调用一堆不同的Paint方法来绘制世界上所有可能的东西。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，也许我们会优化所有这些？</font></font><br><br><img src="https://habrastorage.org/webt/sm/mo/xq/smmoxqrmfayyfodciwe75svwdzw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至少可以说，这非常复杂。因此，Intellij IDEA决定欺骗用户。</font></font><br><br><img src="https://habrastorage.org/webt/5u/x8/as/5ux8ashfsenwboudd_u07ubtjmk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在所有这些令人恐惧的事情重新叙述并写下来之前，我们调用了一个小的方法，该方法可以在用户键入该字母的位置绘制该不幸的字母。</font><font style="vertical-align: inherit;">就是这样！</font><font style="vertical-align: inherit;">用户之所以高兴是因为他认为一切都已改变，但实际上-不！</font><font style="vertical-align: inherit;">在引擎盖下，它只是刚刚开始，但是字母已经在它前面燃烧。</font><font style="vertical-align: inherit;">因此，每个人都很高兴。</font><font style="vertical-align: inherit;">此功能称为“零延迟键入”。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 协同编辑 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在有一种时髦的东西-所谓的协作编辑器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是什么 </font><font style="vertical-align: inherit;">这是当一个用户坐在印度，另一个用户在日本时，他们试图在同一Google文档上打印内容，并希望获得某种可预测的结果。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有什么特别之处：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 数以千计的用户； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 大延迟。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里的特点是大量用户可以同时执行此操作，并且信号可以在很长一段时间内从印度传到日本。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，通常在协作编辑中，他们使用诸如免疫之类的新事物。</font><font style="vertical-align: inherit;">他们提出了不同的建议，以确保一切正常进行。</font><font style="vertical-align: inherit;">这些是一些标准。</font><font style="vertical-align: inherit;">第一个标准是意图的保留，即“意图保留”。</font><font style="vertical-align: inherit;">这意味着，如果有人在商标上留下印记，那么来自印度的商标迟早会来到日本，而日本人将确切地看到印度人的意图。</font><font style="vertical-align: inherit;">第二个准则是收敛。</font><font style="vertical-align: inherit;">这意味着来自印度和日本的符号迟早会转变为对日本和印度而言相同的事物。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 运营转型 </font></font></h3><br><img src="https://habrastorage.org/webt/h9/e8/pq/h9e8pqu3ljnoh4y70_759peizn0.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为支持该功能而发明的第一个算法称为“操作转换”。它就是这样。印度人和日本人坐在一起，输入内容：一个从结尾处删除字母，另一个从开头开始。操作转换框架将这些操作发送到所有其他地方。他必须了解如何遏制他的操作，以便至少获得明智的选择。例如，同时删除并显示该字母。他必须或多或少地在那儿工作，并保持一致。不幸的是，从我困惑的解释中可以看出，这是一件相当复杂的事情。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当该框架的第一个实现开始出现时，惊奇的开发人员发现有一个通用的示例可以破坏所有内容。这个不幸的例子称为“ TP2拼图”。</font></font><br><br><img src="https://habrastorage.org/webt/c1/5i/cs/c15icsdnqbjqykloe_pfbxahz-e.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个用户在行的开头绘制了一些字符，另一个用户删除了所有这些字符，而第三个则绘制到了结尾。在所有此Operation转换尝试合并到同一事物之后，从理论上讲，这行（“ DANA”）应该出现。但是，某些实现方式做到了这一点（“ NADA”）。因为不清楚在哪里插入它。在上面的图片中，您可以看到所有有关操作转换的科学都位于什么级别，如果由于这样的原始示例而一切都破了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是尽管如此，还是有人可以做到这一点，例如Google Docs，Google Wave和一些分布式Etherpad编辑器。</font><font style="vertical-align: inherit;">尽管有列出的问题，他们仍使用操作转换。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 无冲突的复制数据类型 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里的人们绞尽脑汁，决定：“让我们比OT更容易！” </font><font style="vertical-align: inherit;">需要处理和合并在一起的各种棘手的操作组合的数量正呈平方增长。</font><font style="vertical-align: inherit;">因此，无需处理所有组合，我们只需将状态和操作一起发送给所有其他主机，这样就可以在保证100％保证的前提下将其合并为同一文本。</font><font style="vertical-align: inherit;">这称为“ CRDT”（无冲突的复制数据类型）。</font></font><br><br><img src="https://habrastorage.org/webt/kn/82/9n/kn829n91st7gpykcp905spuy_ki.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，您需要一个状态和一个函数，两个状态中的一个与操作一起构成一个新状态。此外，该函数应该是可交换的，联想的，幂等的和单调的。然后很明显，所有东西都可以简单地工作，并且是钢筋混凝土。由于功能上的这些严格限制，我们不再担心网络中的混乱（功能w是可交换的），优先级（关联）和数据包丢失（幂等和单调）。</font></font><br><br><img src="https://habrastorage.org/webt/vs/9-/i7/vs9-i7bdfpjonh_z1cgie6qj4kk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自然界中是否存在这样的功能，如何应用？</font></font><br><br> 是的<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，对于所谓的G计数器，即计数器仅在增长。您可以为此计数器编写一个真正单调的函数，依此类推。因为如果我们在日本进行“ +1”操作，而在印度进行另一次“ +1”操作，则很明显如何从它们中建立一个新州-只需添加“ 2”即可。但是事实证明，您也可以以相同的方式创建一个任意计数器，该计数器可以递增和递减。为此，只需使用一个G计数器，该计数器会一直增长，然后对其应用所有增量操作。并将所有减量应用于另一个G计数器，该计数器将逐渐减小。要获得当前状态，您只需要减去它们的内容，就可以得到相同的单调性。可以扩展到任意集合。但是最重​​要的是在任意行上。是的，使用CRDT也可以编辑任意字符串。事实证明这很容易。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 无冲突的复制插入 </font></font></h3><br><img src="https://habrastorage.org/webt/pz/bg/ta/pzbgta8bteajr0embilmbnpxifc.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我们将命名文档中的所有字符，以便即使进行任何编辑后也始终可以唯一标识它们。</font><font style="vertical-align: inherit;">好吧，例如，我们将与每个字母一起存储一个唯一的数字。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们不是向所有人发送信息，而是在某个偏移处插入符号，而是在要插入的符号之间进行讨论。</font><font style="vertical-align: inherit;">然后很显然，没有任何差异，即使在任何其他操作之后，无论插入到哪里，我们都一定会知道该位置。</font><font style="vertical-align: inherit;">例如，不是发送要在偏移2处插入“ RZhU”的操作，而是将发送在“ U”和“ Y”之间插入“ RZhU”的信息。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 无冲突的复制删除 </font></font></h3><br><img src="https://habrastorage.org/webt/jt/w1/fb/jtw1fbphe5mjcyhbye4ua-mjf7s.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您还可以实现字符删除。</font><font style="vertical-align: inherit;">由于我们已对所有字符进行了唯一重命名，因此我们只需要确切说出要删除的字符，而不是一些偏移量即可。</font><font style="vertical-align: inherit;">但是，我们不会采用并实际删除这些字符，而是将其标记为已删除。</font><font style="vertical-align: inherit;">为了让随后的并发插入或删除操作知道，如果它们影响到这些刚刚删除的字符，它们应该去哪里。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，这整个新科学都是行得通的。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 无冲突的复制编辑 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而且，实际上，CRDT甚至在某个地方实现，例如在Xi-Editor中，它将被插入其新型的秘密操作系统Fuchsia中。</font><font style="vertical-align: inherit;">老实说，我不知道其他示例，但是它确实有效。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 拉链式 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我也想谈谈在这个新的不可变世界中使用的东西，叫做“拉链”。在我们使结构不变之后，出现了一些与它们合作的细微差别。例如，在这里，我们有带有文本的不可变树。我们要更改它（如您所知，此处的“更改”是指“创建新版本”）。此外，我们希望在某个特定位置进行更改，并且要非常积极。在编辑器中，当我们不断在光标位置不断打印，粘贴和删除某些内容时，这是很常见的。为此，工作人员提出了一种称为“拉链”的结构。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它的概念是所谓的光标或当前编辑位置，同时保持完全不变。这是操作方法。</font></font><br><br><img src="https://habrastorage.org/webt/ap/ne/p2/apnep2miklsburr5xhtqgcwbzri.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为我们的文档创建一个拉链，其中包含用于编辑的行（“好，您必须”）。我们在此Zipper上调用一个操作以沿直线移动到编辑位置。在我们的情况下，请从右上角向下移动。为此，我们创建一个与当前顶点相对应的新顶点（红色），并将链接从我们的树连接到子顶点。现在，要移动Zipper的光标，我们向下移动到右侧并创建一个新的顶点，而不是我们站立的那个顶点。同时，在顶部添加一个链接，以免忘记其来源（红色箭头）。这样就到达了编辑位置，我们创建了一个新的工作表来代替已编辑的文本（红色矩形）。现在我们回过头来，沿着红色的向上箭头，并用正确的指向子顶点的链接替换它们。当我们到达顶部时，我们将获得带有已编辑工作表的新树。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意，光标如何帮助我们编辑树的当前部分。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我想向您传达什么结论？</font><font style="vertical-align: inherit;">首先，很奇怪，在文本编辑器主题中，尽管有很多要求，但还是有很多有趣的事情。</font><font style="vertical-align: inherit;">此外，同一主题中有时会出现新的，有时会出乎意料的发现。</font><font style="vertical-align: inherit;">第三，有时它们太新了，以至于第一次都不起作用。</font><font style="vertical-align: inherit;">但这很有趣，您可以保持温暖。</font></font>谢谢啦 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储库</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> → </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">邮件</font></font></a> <br><br><h1> 参考文献 </h1><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Zipper data structure</a> <br> <a href="">  CRDT in Xi Editor</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">       </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   </a> <br><br>     ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> Visual Studio Code editor  Piece Table</a> . <br>  ,   -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . <br><br><blockquote>是否需要更强大的报告，包括Java 11？ 然后我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Joker 2018</a>等您。 今年的演讲者：Josh Long，John McClean，Marcus Hirth，Robert Scholte和其他同样出色的演讲者。 会议还剩17天。 网站上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">门票</a> 。 </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424763/">https://habr.com/ru/post/zh-CN424763/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424751/index.html">统一生物识别系统如何工作</a></li>
<li><a href="../zh-CN424753/index.html">YouTrack 2018.3的新增功能</a></li>
<li><a href="../zh-CN424755/index.html">金钱喜欢账单：汽车如何分类账单</a></li>
<li><a href="../zh-CN424757/index.html">2018年10月IT领域人力资源专业人员的事件摘要</a></li>
<li><a href="../zh-CN424761/index.html">Linux内核启动和启动过程简介</a></li>
<li><a href="../zh-CN424765/index.html">Flutter应用程序中的状态管理</a></li>
<li><a href="../zh-CN424767/index.html">我们用哈伯做蛋糕。 再来一次</a></li>
<li><a href="../zh-CN424771/index.html">个人经验：从想法和空白表到网站的草稿版本</a></li>
<li><a href="../zh-CN424773/index.html">生物制药和数值模拟：安进的经验和实践</a></li>
<li><a href="../zh-CN424777/index.html">使用领事扩展有状态服务</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>