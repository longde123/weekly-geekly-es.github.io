<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõéÔ∏è üëàüèø ‚ò£Ô∏è Hacer de Tower Defense un juego de unidad - Parte 1 ‚öíÔ∏è üê™ ‚úÇÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los juegos de defensa de la torre est√°n ganando popularidad, y esto no es sorprendente: ¬°poco se puede comparar con el placer de observar sus propias ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hacer de Tower Defense un juego de unidad - Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413837/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png" alt="imagen"></div><br>  Los juegos de defensa de la torre est√°n ganando popularidad, y esto no es sorprendente: ¬°poco se puede comparar con el placer de observar sus propias l√≠neas de defensa que destruyen a los malvados enemigos!  ¬°En este tutorial de dos partes, crearemos un juego de torre de defensa en el motor de <em>Unity</em> ! <br><br>  Aprender√° a hacer lo siguiente: <br><br><ul><li>  Crea oleadas de enemigos </li><li>  Haz que sigan los puntos de ruta </li><li>  Construye y mejora torres, y tambi√©n ens√©√±ales c√≥mo dividir a los enemigos en p√≠xeles peque√±os </li></ul><br>  Al final, obtenemos el marco del juego, que puede desarrollarse a√∫n m√°s. <br><a name="habracut"></a><br><blockquote>  <em>Nota</em> : necesita conocimientos b√°sicos de Unity (por ejemplo, necesita saber c√≥mo se agregan los activos y componentes, qu√© son los prefabricados) y los conceptos b√°sicos de <em>C #</em> .  Para aprender todo esto, le recomiendo que lea los tutoriales sobre Unity de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sean Duffy</a> o la serie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Beginning C # with Unity</a> de Brian Mockley. </blockquote><br>  Trabajar√© en Unity para OS X, pero este tutorial tambi√©n es adecuado para Windows. <br><br><h2>  A trav√©s de las ventanas de la torre de marfil </h2><br>  En este tutorial, crearemos un juego de defensa de la torre en el que los enemigos (peque√±os insectos) se arrastran hacia una galleta que te pertenece a ti y a tus secuaces (por supuesto, ¬°estos son monstruos!).  El jugador puede colocar monstruos en puntos estrat√©gicos y mejorarlos para obtener oro. <br><br>  El jugador debe matar a todos los errores hasta que lleguen a la cookie.  Cada nueva ola de enemigos se est√° volviendo cada vez m√°s dif√≠cil de vencer.  El juego termina cuando sobrevives a todas las olas (¬°victoria!) O cuando cinco enemigos se arrastran hacia las galletas (¬°p√©rdida!). <br><br>  Aqu√≠ hay una captura de pantalla del juego terminado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/782/a94/fef/782a94fefd675365aba52fbfc4008ab6.png"></div><br>  <i>¬°Monstruos, un√≠os!</i>  <i>¬°Protege la galleta!</i> <br><br><h2>  Llegar al trabajo </h2><br>  Descargue este <a href="">proyecto en blanco</a> , descompr√≠malo y abra el proyecto <em>TowerDefense-Part1-Starter</em> en Unity. <br><br>  El proyecto borrador tiene recursos de gr√°ficos y sonidos, animaciones listas para usar y varios scripts √∫tiles.  Los guiones no est√°n directamente relacionados con los juegos de defensa de la torre, por lo que no hablar√© de ellos aqu√≠.  Sin embargo, si desea obtener m√°s informaci√≥n sobre la creaci√≥n de animaciones 2D en Unity, consulte este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="Tutorial de Unity 2D">tutorial de Unity 2D</a> . <br><br>  El proyecto tambi√©n contiene prefabricados, que agregaremos m√°s adelante para crear personajes.  Finalmente, hay una escena en el proyecto con un fondo y una interfaz de usuario personalizada. <br><br>  Abra el <em>GameScene</em> ubicado en la carpeta <em>Escenas</em> y configure el modo Juego en una relaci√≥n de aspecto de <em>4: 3</em> para que todas las etiquetas coincidan con el fondo correctamente.  En el modo Juego, ver√° lo siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb7/050/bda/fb7050bda1d91c148f65e70a7c217083.png"></div><br>  <em>Autor√≠a:</em> <br><br><ul><li>  ¬°Los gr√°ficos para el proyecto est√°n tomados del paquete gratuito Wiki Wenderlich!  Otros trabajos gr√°ficos se pueden encontrar en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="gameartguppy">sitio</a> web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="gameartguppy">gameartguppy</a> . </li><li>  ¬° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="Benound">Buena</a> m√∫sica tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="Benound">BenSound</a> , que tiene otras bandas sonoras incre√≠bles! </li><li>  Tambi√©n agradezco a Michael Jesper por la √∫til funci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="sacudida de la c√°mara">movimiento de la c√°mara.</a> </li></ul>  . <br><h2>  El lugar est√° marcado con una cruz: la ubicaci√≥n de los monstruos. </h2><br>  Los monstruos solo se pueden colocar en puntos marcados con una <em>x</em> . <br><br>  Para agregarlos a la escena, arrastre <em>Im√°genes \ Objetos \ Openspot</em> desde el <em>Navegador de proyectos</em> a la ventana <em>Escena</em> .  Si bien la posici√≥n no es importante para nosotros. <br><br>  Una vez que haya seleccionado <em>Openspot</em> en la jerarqu√≠a, haga clic en <em>Agregar componente</em> en el <em><em>Inspector</em></em> y seleccione <em>Box Collider 2D</em> .  En la ventana Escena, Unity mostrar√° un colisionador rectangular con una l√≠nea verde.  Utilizaremos este colisionador para reconocer los clics del mouse en esta ubicaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/6a9/3da/2716a93da69de6b5cf73a7edfc794210.png"></div><br>  Agregue el componente <em>Audio \ Audio Source</em> a <em>Openspot de la</em> misma manera.  Para el par√°metro <em>AudioClip</em> del componente Fuente de audio, seleccione el archivo <em>tower_place</em> ubicado en la carpeta <em>Audio</em> y desactive <em>Play On Awake</em> . <br><br>  Necesitamos crear 11 puntos m√°s.  Aunque existe la tentaci√≥n de repetir todos estos pasos, Unity tiene una mejor soluci√≥n: ¬° <em>Prefab</em> ! <br><br>  Arrastre <em>Openspot</em> desde la <em>Jerarqu√≠a</em> a la carpeta <em>Prefabs</em> dentro del <em>Navegador de proyectos</em> .  Su nombre se volver√° azul en la Jerarqu√≠a, lo que significa que est√° adjunto al prefabricado.  Algo como esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad3/cb2/6a0/ad3cb26a0d51c893dd040e8f4f5dfea6.gif"></div><br>  Ahora que tenemos el espacio prefabricado en blanco, podemos crear tantas copias como queramos.  Simplemente arrastre y suelte <em>Openspot</em> desde la carpeta <em>Prefabs</em> dentro del <em>Navegador de proyectos</em> en la ventana <em>Escena</em> .  Repita esto 11 veces y aparecer√°n 12 objetos Openspot en la escena. <br><br>  Ahora use el <em>Inspector</em> para configurar estos 12 objetos Openspot con las siguientes coordenadas: <br><br><ul><li>  (X: -5.2, Y: 3.5, Z: 0) </li><li>  (X: -2.2, Y: 3.5, Z: 0) </li><li>  (X: 0.8, Y: 3.5, Z: 0) </li><li>  (X: 3.8, Y: 3.5, Z: 0) </li><li>  (X: -3.8, Y: 0.4, Z: 0) </li><li>  (X: -0.8, Y: 0.4, Z: 0) </li><li>  (X: 2.2, Y: 0.4, Z: 0) </li><li>  (X: 5.2, Y: 0.4, Z: 0) </li><li>  (X: -5.2, Y: -3.0, Z: 0) </li><li>  (X: -2.2, Y: -3.0, Z: 0) </li><li>  (X: 0.8, Y: -3.0, Z: 0) </li><li>  (X: 3.8, Y: -3.0, Z: 0) </li></ul><br>  Cuando haces esto, la escena se ver√° as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/248/fb2/69e248fb213cfee35ce43f5f9c14baeb.png"></div><br><h2>  Colocamos monstruos </h2><br>  Para simplificar la colocaci√≥n, hay una prefabricada de <em>Monster</em> en la carpeta <em>Prefab</em> del proyecto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c65/908/80a/c6590880acbdbac94bd15ec023311235.png"></div><br>  <i>Monster Prefab listo para usar</i> <br><br>  Por el momento, consiste en un objeto de juego vac√≠o con tres sprites diferentes y animaciones de disparos cuando eran ni√±os. <br><br>  Cada sprite es un monstruo con diferentes niveles de poder.  El prefabricado tambi√©n contiene el componente <em>Fuente de audio</em> , que se lanzar√° para reproducir sonido cuando un monstruo dispara un l√°ser. <br><br>  Ahora crearemos un script que alojar√° a <em>Monster</em> en <em>Openspot</em> . <br><br>  En el <em>Navegador de proyectos,</em> seleccione el objeto <em>Openspot</em> en la carpeta <em>Prefabs</em> .  En el <em>Inspector,</em> haga clic en <em>Agregar componente</em> y luego seleccione <em>Nuevo gui√≥n</em> y <em>asigne un</em> nombre al gui√≥n <em>PlaceMonster</em> .  Seleccione <em>C Sharp</em> como el idioma y haga clic en <em>Crear y Agregar</em> .  Como agregamos el script al prefabricado de <i>Openspot</i> , todos los objetos de Openspot en la escena ahora tendr√°n este script.  Genial <br><br>  Haga doble clic en el script para abrirlo en el IDE.  Luego agregue dos variables: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject monsterPrefab; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject monster;</code> </pre> <br>  Crearemos una instancia del objeto almacenado en <code>monsterPrefab</code> para crear el monstruo y lo almacenaremos en un <code>monster</code> para que pueda manipularse durante el juego. <br><br><h3>  Un monstruo por punto </h3><br>  Para que solo se pueda poner un monstruo en un punto, agregue el siguiente m√©todo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanPlaceMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  En <code>CanPlaceMonster()</code> podemos verificar si la variable <code>monster</code> sigue siendo <code>null</code> .  Si es as√≠, entonces no hay ning√∫n monstruo en el punto, y podemos ubicarlo. <br><br>  Ahora agregue el siguiente c√≥digo para colocar el monstruo cuando el jugador haga clic en este GameObject: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 void OnMouseUp() { //2 if (CanPlaceMonster()) { //3 monster = (GameObject) Instantiate(monsterPrefab, transform.position, Quaternion.identity); //4 AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br>  Este c√≥digo localiza al monstruo cuando haces clic con el mouse o tocas la pantalla.  Como trabaja el <br><br><ol><li>  Unity llama autom√°ticamente a <code>OnMouseUp</code> cuando un jugador toca el colisionador f√≠sico GameObject. </li><li>  Cuando se llama, este m√©todo pone un monstruo si <code>CanPlaceMonster()</code> devuelve <code>true</code> . </li><li>  Creamos un monstruo usando el m√©todo <code>Instantiate</code> , que crea una instancia del prefabricado dado con la posici√≥n y rotaci√≥n especificadas.  En este caso, copiamos <code>monsterPrefab</code> , le damos la posici√≥n actual de GameObject y no giramos, transferimos el resultado a <code>GameObject</code> y lo <code>GameObject</code> en <code>monster</code> </li><li>  Al final, llamamos a <code>PlayOneShot</code> para reproducir el efecto de sonido adjunto al componente <code>AudioSource</code> del objeto. </li></ol><br>  Ahora nuestro script <code>PlaceMonster</code> puede tener un nuevo monstruo, pero a√∫n necesitamos especificar un prefabricado. <br><br><h3>  Usando el prefabricado correcto </h3><br>  Guarde el archivo y regrese a Unity. <br><br>  Para configurar la variable <em>monsterPrefab</em> , primero seleccione el objeto <em>Openspot</em> de la carpeta <em>Prefabs</em> en el navegador del proyecto. <br><br>  En el <em><em>Inspector,</em></em> haga clic en el c√≠rculo a la derecha del campo <em>Monster Prefab</em> del componente <em>PlaceMonster (Script)</em> y seleccione <em>Monster</em> en el cuadro de di√°logo que aparece. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/8bc/9c7/b878bc9c77c6e7c63a54f4a87d2a7c42.gif"></div><br>  Eso es todo  Inicie la escena y cree monstruos en diferentes lugares haciendo clic con el mouse o tocando la pantalla. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/f08/01d/095f0801ddbbc91ce0eca144a22d4f7b.png"></div><br>  Genial  Ahora podemos crear monstruos.  Sin embargo, se ven como un desastre extra√±o, porque todos los ni√±os sprites del monstruo est√°n dibujados.  Ahora lo arreglaremos. <br><br><h2>  Elevar el nivel de monstruos </h2><br>  La siguiente figura muestra que con un aumento en el nivel, los monstruos se ven cada vez m√°s aterradores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a92/23d/480/a9223d480dda51f941c3b0b82f9f0dd6.png"></div><br>  <i>¬°Qu√© linda!</i>  <i>Pero si intentas robarle las galletas, este monstruo se convertir√° en un asesino.</i> <br><br>  El script se utiliza como base para la implementaci√≥n del sistema de niveles de monstruos.  Rastrea el poder del monstruo en cada nivel y, por supuesto, el nivel actual del monstruo. <br><br>  Agrega este script. <br><br>  Seleccione <em>Prefabs / Monster prefab</em> en <em>Project Browser</em> .  Agregue un nuevo script de <em>C #</em> llamado <em>MonsterData</em> .  Abra el script en el IDE y agregue el siguiente c√≥digo <i>sobre</i> la clase <code>MonsterData</code> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MonsterLevel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject visualization; }</code> </pre> <br>  Entonces creamos <code>MonsterLevel</code> .  Agrupa el precio (en oro, que apoyaremos a continuaci√≥n) y una representaci√≥n visual del nivel del monstruo. <br><br>  Agregamos encima de <code>[System.Serializable]</code> para que las instancias de clase se puedan modificar en el inspector.  Esto nos permite cambiar r√°pidamente todos los valores de la clase Level, incluso cuando el juego se est√° ejecutando.  Esto es incre√≠blemente √∫til para equilibrar el juego. <br><br><h3>  Establecer niveles de monstruos </h3><br>  En nuestro caso, almacenaremos el <code>MonsterLevel</code> especificado en la <code>List&lt;T&gt;</code> . <br><br>  ¬øPor qu√© no usar <code>MonsterLevel[]</code> ?  Necesitaremos el √≠ndice de un objeto <code>MonsterLevel</code> espec√≠fico varias veces.  Aunque es f√°cil escribir c√≥digo para esto, todav√≠a tenemos que usar <code>IndexOf()</code> , que implementa la funcionalidad <code>Lists</code> .  No tiene sentido reinventar la rueda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aae/85f/785/aae85f7854f44c8f418c5fde22153a53.jpg"></div><br>  <i>Reinventar la bicicleta suele ser una mala idea.</i> <br><br>  En la parte superior de <em>MonsterData.cs,</em> agregue lo siguiente <code>using</code> construct: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic;</code> </pre> <br>  Nos da acceso a estructuras de datos generalizadas para que podamos usar la clase <code>List&lt;T&gt;</code> en el script. <br><br><blockquote>  <em>Nota</em> : las generalizaciones son un poderoso concepto de C #.  Le permiten especificar estructuras de datos de tipo seguro sin tener que adherirse al tipo.  Esto es √∫til para clases de contenedor como listas y conjuntos.  Para obtener m√°s informaci√≥n sobre las estructuras gen√©ricas, lea el libro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="Introducci√≥n a los gen√©ricos de C #">Introducci√≥n a los gen√©ricos de C #</a> . </blockquote><br>  Ahora agregue la siguiente variable a <code>MonsterData</code> para mantener la lista <code>MonsterLevel</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;MonsterLevel&gt; levels;</code> </pre> <br>  Gracias a las generalizaciones, podemos garantizar que la <code>List</code> del <code>level</code> solo contendr√° objetos <code>MonsterLevel</code> . <br><br>  Guarde el archivo y cambie a Unity para configurar cada nivel. <br><br>  Seleccione <em>Prefabs / Monster</em> en <em>Project Browser</em> .  El <em><em>Inspector</em></em> ahora muestra el campo <em>Niveles</em> del componente <em>MonsterData (Script)</em> .  Establezca el <em>tama√±o</em> en <em>3</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/660/dda/a18/660ddaa185b824721453ca1c892eedff.png"></div><br>  A continuaci√≥n, establezca el <em>costo</em> para cada nivel: <br><br><ul><li>  <em>Elemento 0</em> : <em>200</em> </li><li>  <em>Elemento 1</em> : <em>110</em> </li><li>  <em>Elemento 2</em> : <em>120</em> </li></ul><br>  Ahora asignamos los valores de los campos de visualizaci√≥n. <br><br>  Expanda <em>Prefabs / Monster</em> en el navegador de proyectos para ver sus elementos <em>secundarios</em> .  Arrastre el ni√±o <em>Monster0</em> al campo <em>Elemento de</em> <em>visualizaci√≥n</em> <em>0</em> . <br><br>  A continuaci√≥n, establezca el <em>Elemento 1</em> en <em>Monster1</em> y el <em>Elemento 2</em> en <em>Monster2</em> .  El GIF muestra este proceso: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/662/404/e30/662404e30bd808e1cf9a9d34b47d4d61.gif"></div><br>  Cuando selecciona <em>Prefabs / Monster</em> , el prefab deber√≠a verse as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80b/e4d/17e/80be4d17e9894cf291b7be8a44152044.png"></div><br><h3>  Establecer nivel actual </h3><br>  Regrese a <em>MonsterData.cs</em> en el IDE y agregue otra variable a <code>MonsterData</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MonsterLevel currentLevel;</code> </pre> <br>  En la variable privada <code>currentLevel</code> almacenaremos el nivel actual del monstruo. <br><br>  Ahora configure <code>currentLevel</code> y <code>currentLevel</code> visible para otros scripts.  Agregue las siguientes l√≠neas a <code>MonsterData</code> junto con la declaraci√≥n de variables de instancia: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 public MonsterLevel CurrentLevel { //2 get { return currentLevel; } //3 set { currentLevel = value; int currentLevelIndex = levels.IndexOf(currentLevel); GameObject levelVisualization = levels[currentLevelIndex].visualization; for (int i = 0; i &lt; levels.Count; i++) { if (levelVisualization != null) { if (i == currentLevelIndex) { levels[i].visualization.SetActive(true); } else { levels[i].visualization.SetActive(false); } } } } }</span></span></code> </pre> <br>  Bastante gran parte del c√≥digo C #, ¬øverdad?  Tom√©moslo en orden: <br><br><ol><li>  Establezca la <em>propiedad de la</em> variable privada <code>currentLevel</code> .  Al establecer la propiedad, podemos llamarla como cualquier otra variable: ya sea como <code>CurrentLevel</code> (dentro de la clase) o como <code>monster.CurrentLevel</code> (fuera).  Podemos definir cualquier comportamiento en el m√©todo getter o setter de una propiedad, y al crear solo un getter, setter o ambos, puede controlar las propiedades de la propiedad: solo lectura, solo escritura y escritura / lectura. </li><li>  En el captador, devolvemos el valor de <code>currentLevel</code> . </li><li>  En el setter, asignamos a <code>currentLevel</code> nuevo valor.  Luego obtenemos el √≠ndice del nivel actual.  Finalmente, recorremos todos los <em>niveles</em> y habilitamos / deshabilitamos la visualizaci√≥n visual dependiendo de <code>currentLevelIndex</code> .  Esto es genial porque cuando <code>currentLevel</code> cambia, el sprite se actualiza autom√°ticamente.  ¬°Las propiedades son una cosa muy conveniente! </li></ol><br>  Agregue la siguiente implementaci√≥n de <code>OnEnable</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentLevel = levels[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br>  Aqu√≠ establecemos <code>CurrentLevel</code> al colocar.  Esto asegura que solo se muestre el sprite deseado. <br><br><blockquote>  <em>Nota</em> : es importante inicializar la propiedad en <code>OnEnable</code> , y no en <code>OnStart</code> , porque llamamos a los m√©todos ordinales al crear instancias prefabricadas. <br><br>  <code>OnEnable</code> se llamar√° inmediatamente cuando se <code>OnEnable</code> (si el prefab se guard√≥ en el estado habilitado), pero no se llama a <code>OnStart</code> hasta que el objeto comience a ejecutarse como parte de la escena. <br><br>  Necesitamos verificar estos datos antes de colocar el monstruo, por lo que lo inicializamos en <code>OnEnable</code> . </blockquote><br>  Guarde el archivo y regrese a Unity.  Ejecute el proyecto y coloque los monstruos;  ahora muestran los sprites correctos del nivel m√°s bajo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08e/16e/549/08e16e5498d12f78d106d873d34c8d1b.png"></div><br><h3>  Actualizaci√≥n de monstruo </h3><br>  Regrese al IDE y agregue el siguiente m√©todo a <code>MonsterData</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MonsterLevel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNextLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf (currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxLevelIndex = levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; maxLevelIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> levels[currentLevelIndex+<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br>  En <code>GetNextLevel</code> obtenemos el √≠ndice <code>currentLevel</code> y el √≠ndice de nivel m√°s alto;  Si el monstruo no ha alcanzado el nivel m√°ximo, el siguiente nivel regresa.  De lo contrario, <code>null</code> devuelve <code>null</code> . <br><br>  Puede usar este m√©todo para averiguar si es posible una actualizaci√≥n monstruosa. <br><br>  Para elevar el nivel del monstruo, agregue el siguiente m√©todo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf(currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>) { CurrentLevel = levels[currentLevelIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>]; } }</code> </pre> <br>  Aqu√≠ obtenemos el √≠ndice del nivel actual, y luego nos aseguramos de que este no sea el nivel m√°ximo, verificando que sea inferior a los <code>levels.Count - 1</code> .  Si es as√≠, <code>CurrentLevel</code> al siguiente nivel. <br><br><h3>  Comprobaci√≥n de la funcionalidad de actualizaci√≥n </h3><br>  Guarde el archivo y regrese a <em>PlaceMonster.cs</em> en el IDE.  Agrega un nuevo m√©todo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanUpgradeMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (monster != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { MonsterData monsterData = monster.GetComponent&lt;MonsterData&gt;(); MonsterLevel nextLevel = monsterData.GetNextLevel(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextLevel != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Primero verificamos si hay un monstruo que pueda mejorarse comparando la variable del <code>monster</code> con <code>null</code> .  Si esto es cierto, obtenemos el nivel de monstruo actual de su <code>MonsterData</code> . <br><br>  Luego verificamos si el siguiente nivel est√° disponible, es decir, si <code>GetNextLevel()</code> no devuelve <code>null</code> .  Si es posible un aumento de nivel, entonces devolvemos <code>true</code> ;  de lo contrario, devuelve <code>false</code> . <br><br><h3>  Implementamos mejoras para el oro. </h3><br>  Para habilitar la opci√≥n de actualizaci√≥n, agregue el <code>else if</code> <code>OnMouseUp</code> a <code>OnMouseUp</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanPlaceMonster()) { <span class="hljs-comment"><span class="hljs-comment">//      } else if (CanUpgradeMonster()) { monster.GetComponent&lt;MonsterData&gt;().IncreaseLevel(); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   }</span></span></code> </pre> <br>  Verificamos la posibilidad de una actualizaci√≥n usando <code>CanUpgradeMonster()</code> .  Si es posible, accedemos al componente <code>MonsterData</code> usando <code>GetComponent()</code> y llamamos a <code>IncreaseLevel()</code> , que aumenta el nivel del monstruo.  Finalmente, lanzamos Monster <em>AudioSource</em> . <br><br>  Guarde el archivo y regrese a Unity.  Ejecuta el juego, coloca y actualiza <i>cualquier cantidad de</i> monstruos (pero por ahora). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/495/bed/cb7495bed8ebcd3993439de25a08a0e7.png"></div><br><h2>  Paying Gold - Game Manager </h2><br>  Si bien podemos construir y mejorar de inmediato cualquier monstruo, ¬øser√° interesante en el juego? <br><br>  Veamos el tema del oro.  El problema con el seguimiento es que tenemos que transferir informaci√≥n entre diferentes objetos del juego. <br><br>  La siguiente figura muestra todos los objetos que deber√≠an participar en esto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e35/8cd/6f4/e358cd6f461c75385f61f1c12862a16b.png"></div><br>  <i>Todos los objetos de juego seleccionados deben saber cu√°nto oro tiene un jugador.</i> <br><br>  Para almacenar estos datos, utilizaremos un objeto com√∫n al que pueden acceder otros objetos. <br><br>  Haga clic derecho en la <em>Jerarqu√≠a</em> y seleccione <em>Crear vac√≠o</em> .  Nombra el nuevo objeto <em>GameManager</em> . <br><br>  Agregue un nuevo script <em>C #</em> llamado <em>GameManagerBehavior a GameManager</em> , y luego √°bralo en el IDE.  Mostraremos la cantidad total de oro del jugador en la etiqueta, por lo que en la parte superior del archivo agregue la siguiente l√≠nea: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI;</code> </pre> <br>  Esto nos permitir√° acceder a clases de IU como <code>Text</code> , que se usa para etiquetas.  Ahora agregue la siguiente variable a la clase: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text goldLabel;</code> </pre> <br>  Almacenar√° un enlace al componente de <code>Text</code> utilizado para mostrar la cantidad de oro que tiene un jugador. <br><br>  Ahora que <code>GameManager</code> conoce la etiqueta, ¬øc√≥mo sincronizamos la cantidad de oro almacenada en la variable y el valor que se muestra en la etiqueta?  Crearemos una propiedad. <br><br>  Agregue el siguiente c√≥digo a <code>GameManagerBehavior</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gold; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Gold { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gold; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { gold = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; goldLabel.GetComponent&lt;Text&gt;().text = <span class="hljs-string"><span class="hljs-string">"GOLD: "</span></span> + gold; } }</code> </pre> <br>  ¬øTe parece familiar?  El c√≥digo es similar a <code>CurrentLevel</code> , que configuramos en <code>Monster</code> .  Primero creamos un <code>gold</code> variable privado para contener la cantidad actual de oro.  Luego establecemos la propiedad <code>Gold</code> (inesperadamente, ¬øverdad?) E implementamos el getter y setter. <br><br>  El captador simplemente devuelve el valor del <code>gold</code> .  El setter es m√°s interesante.  Adem√°s de establecer el valor de la variable, tambi√©n establece el campo de <code>text</code> para que <code>goldLabel</code> muestre el nuevo valor de oro. <br><br>  ¬øCu√°n generosos seremos?  Agregue la siguiente l√≠nea a <code>Start()</code> para darle al jugador <em>1000 de</em> oro, o menos si siente pena por el dinero: <br><br><pre> <code class="cs hljs">Gold = <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br><h3>  Asignaci√≥n de un objeto de etiqueta a un script </h3><br>  Guarde el archivo y regrese a Unity.  En la <em>Jerarqu√≠a,</em> seleccione <em>GameManager</em> .  En el <em><em>Inspector,</em></em> haga clic en el c√≠rculo a la derecha de la <em>etiqueta dorada</em> .  En el cuadro de di√°logo <em>Seleccionar texto</em> , seleccione la pesta√±a <em>Escena</em> y seleccione <em>GoldLabel</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05e/82e/956/05e82e95690113e0086020a817e2718c.png"></div><br>  Ejecute la escena y la etiqueta mostrar√° <em>Gold: 1000</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a97/b8f/b45/a97b8fb455f50659176371e484a280e6.png"></div><br><h3>  Comprobando la "billetera" del jugador </h3><br>  Abra el script <em>PlaceMonster.cs</em> en el IDE y agregue la siguiente variable de instancia: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager;</code> </pre> <br>  Utilizaremos <code>gameManager</code> para acceder al componente <code>GameManagerBehavior</code> objeto <code>GameManagerBehavior</code> <em>en la</em> escena.  Para especificarlo, agregue lo siguiente a <code>Start()</code> : <br><br><pre> <code class="cs hljs">gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br>  Obtenemos un GameObject llamado GameManager usando la funci√≥n <code>GameObject.Find()</code> , que devuelve el primer objeto del juego encontrado con ese nombre.  Luego obtenemos su componente <code>GameManagerBehavior</code> y lo <code>GameManagerBehavior</code> para el futuro. <br><br><blockquote>  <em>Nota</em> : puede hacer esto configurando un campo en el editor de Unity o agregando un m√©todo est√°tico a <code>GameManager</code> que devuelva una instancia del singleton del que podemos obtener <code>GameManagerBehavior</code> . <br><br>  Sin embargo, en el bloque de c√≥digo que se muestra arriba hay un caballo oscuro: el m√©todo <code>Find</code> , que funciona m√°s lentamente durante la ejecuci√≥n de la aplicaci√≥n;  pero es conveniente y se puede usar con moderaci√≥n. </blockquote><br><h3>  Toma mi dinero! </h3><br>  Todav√≠a no hemos restado el oro, por lo que agregaremos esta l√≠nea <em>dos veces</em> a <code>OnMouseUp()</code> , reemplazando cada uno de los comentarios <code>// TODO:  </code> : <br><br><pre> <code class="cs hljs">gameManager.Gold -= monster.GetComponent&lt;MonsterData&gt;().CurrentLevel.cost;</code> </pre> <br>  Guarde el archivo y regrese a Unity, actualice algunos monstruos y mire la actualizaci√≥n del valor Gold.  Ahora deducimos oro, pero los jugadores pueden construir monstruos siempre que tengan suficiente espacio;  solo piden prestado dinero. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/581/2fe/eaf/5812feeafd4b9d316f8294db56d55789.png"></div><br>  <i>Cr√©dito infinito?</i>  <i>Genial</i>  <i>Pero no podemos permitirlo.</i>  <i>El jugador debe poder apostar monstruos mientras tenga suficiente oro.</i> <br><br><h3>  Cheque de oro para monstruos </h3><br>  Cambie el IDE a <em>PlaceMonster.cs</em> y reemplace el contenido de <code>CanPlaceMonster()</code> siguiente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost = monsterPrefab.GetComponent&lt;MonsterData&gt;().levels[<span class="hljs-number"><span class="hljs-number">0</span></span>].cost; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; gameManager.Gold &gt;= cost;</code> </pre> <br>  Obtenemos <code>MonsterData</code> precio de colocaci√≥n de monstruos de los <code>levels</code> en su <code>MonsterData</code> .  Luego verificamos que el <code>monster</code> no <code>monster</code> <code>null</code> , y que <code>gameManager.Gold</code> m√°s que este precio. <br><br>  La tarea para usted: agregar independientemente a <code>CanUpgradeMonster()</code> cheque si el jugador tiene suficiente oro. <br><br><div class="spoiler">  <b class="spoiler_title">Soluci√≥n en el interior</b> <div class="spoiler_text">  Reemplace la l√≠nea: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  en esto: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gameManager.Gold &gt;= nextLevel.cost;</code> </pre> <br>  Verificar√° si el jugador tiene m√°s <em>Oro</em> que el precio de actualizaci√≥n. </div></div><br>  Guarda y ejecuta la escena en Unity.  ¬°Ahora prueba c√≥mo agregar monstruos ilimitadamente! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24b/f58/b6a/24bf58b6a0a1d4258295902f5d05c6bd.png"></div><br>  <i>Ahora solo podemos construir un n√∫mero limitado de monstruos.</i> <br><br><h2>  Pol√≠tica de la torre: enemigos, olas y puntos de referencia </h2><br>  Es hora de "allanar el camino" a nuestros enemigos.  Los enemigos aparecen en el primer punto de la ruta, se mueven al siguiente y repiten el proceso hasta que alcanzan la cookie. <br><br>  Puedes hacer que los enemigos se muevan as√≠: <br><br><ol><li>  Establece el camino que seguir√°n los enemigos </li><li>  Mueve al enemigo por el camino </li><li>  Gira al enemigo para que mire hacia adelante </li></ol><br><h3>  Creando un camino desde waypoints </h3><br>  Haga clic derecho en la <em>Jerarqu√≠a</em> y seleccione <em>Crear vac√≠o</em> para crear un nuevo objeto de juego vac√≠o.  N√≥mbrelo <em>Road</em> y col√≥quelo en <em>(0, 0, 0)</em> . <br><br>  Ahora haz clic derecho en <em>Road</em> en la <em>Jerarqu√≠a</em> y crea otro objeto de juego vac√≠o como hijo de Road.  N√≥mbralo <em>Waypoint0</em> y <em>col√≥calo</em> en el punto <em>(-12, 2, 0)</em> : desde aqu√≠, los enemigos comenzar√°n su movimiento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78a/21a/044/78a21a0443e9b71b4c28064196cd0f8f.png"></div><br>  Del mismo modo, cree cinco puntos de ruta m√°s con los siguientes nombres y posiciones: <br><br><ul><li>  Waypoint1: (X: 7, Y: 2, Z: 0) </li><li>  Waypoint2: (X: 7, Y: -1, Z: 0) </li><li>  Waypoint3: (X: -7.3, Y: -1, Z: 0) </li><li>  Waypoint4: (X: -7.3, Y: -4.5, Z: 0) </li><li>  Waypoint5: (X: 7, Y: -4.5, Z: 0) </li></ul><br>  La captura de pantalla siguiente muestra los puntos de ruta y la ruta resultante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png"></div><br><h2>  Haciendo enemigos </h2><br>  Ahora crea algunos enemigos para que puedan moverse por el camino.  Hay un <em>prefab</em> <em>Enemigo</em> en la carpeta <em>Prefabs</em> .  Su posici√≥n es <em>(-20, 0, 0)</em> , por lo que se crear√°n nuevas instancias fuera de la pantalla. <br><br>  En todos los dem√°s aspectos, est√° configurado casi de la misma manera que el monstruo prefabricado, tiene <code>AudioSource</code> y un ni√±o <code>Sprite</code> , y podemos rotar este sprite en el futuro sin girar la barra de salud. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/5c7/b09/d465c7b0950d7c718abcb8869263753c.png"></div><br><h3>  Movemos enemigos por el camino </h3><br>  Agregue un nuevo script de <em>C #</em> llamado <em>MoveEnemy</em> al <em>prefabricado Prefabs \ Enemy</em> .  Abra el script en el IDE y agregue las siguientes variables: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">HideInInspector</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentWaypoint = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastWaypointSwitchTime; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>;</code> </pre> <br>  En los <code>waypoints</code> , una copia de los <code>waypoints</code> se almacena en la matriz, y la l√≠nea <code>[HideIn <em>inspector</em> ]</code> encima de los <code>waypoints</code> asegura que no podemos cambiar accidentalmente este campo en el <em><em>Inspector</em></em> , pero a√∫n tendremos acceso a √©l desde otros scripts. <br><br>  <code>currentWaypoint</code> realiza un seguimiento de d√≥nde proviene la ruta del enemigo en el momento actual, y <code>lastWaypointSwitchTime</code> almacena el tiempo que el enemigo pas√≥ por ella.  Adem√°s, almacenamos la <code>speed</code> enemigo. <br><br>  Agregue esta l√≠nea a <code>Start()</code> : <br><br><pre> <code class="cs hljs">lastWaypointSwitchTime = Time.time;</code> </pre> <br>  Entonces inicializamos <code>lastWaypointSwitchTime</code> con el valor de la hora actual. <br><br>  Para que el enemigo se mueva a lo largo de la ruta, agrega el siguiente c√≥digo a <code>Update()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 Vector3 startPosition = waypoints [currentWaypoint].transform.position; Vector3 endPosition = waypoints [currentWaypoint + 1].transform.position; // 2 float pathLength = Vector3.Distance (startPosition, endPosition); float totalTimeForPath = pathLength / speed; float currentTimeOnPath = Time.time - lastWaypointSwitchTime; gameObject.transform.position = Vector2.Lerp (startPosition, endPosition, currentTimeOnPath / totalTimeForPath); // 3 if (gameObject.transform.position.Equals(endPosition)) { if (currentWaypoint &lt; waypoints.Length - 2) { // 3.a currentWaypoint++; lastWaypointSwitchTime = Time.time; // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">     } else { // 3.b Destroy(gameObject); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); AudioSource.PlayClipAtPoint(audioSource.clip, transform.position); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br>  Analicemos el c√≥digo paso a paso: <br><br><ol><li>  Del conjunto de puntos de ruta obtenemos las posiciones de inicio y finalizaci√≥n del segmento de ruta actual. </li><li>  Calculamos el tiempo requerido para cubrir toda la distancia usando la f√≥rmula <em>tiempo = distancia / velocidad</em> , y luego determinamos el tiempo actual en la ruta.  Usando <code>Vector2.Lerp</code> , interpolamos la posici√≥n actual del enemigo entre el segmento exacto inicial y final. </li><li>  Comprueba si el enemigo ha llegado al <code>endPosition</code> .  En caso afirmativo, procesamos dos escenarios posibles: <br><ol><li>  El enemigo a√∫n no ha alcanzado el √∫ltimo punto de la ruta, as√≠ que aumente el valor de <code>currentWaypoint</code> y actualice <code>lastWaypointSwitchTime</code> .  M√°s tarde agregaremos un c√≥digo para convertir al enemigo para que mire en la direcci√≥n de su movimiento. </li><li>  El enemigo ha llegado al √∫ltimo punto de la ruta, luego lo destruimos y comenzamos el efecto de sonido.  M√°s adelante agregaremos un c√≥digo que reduce la <code>health</code> del jugador. </li></ol></li></ol><br>  Guarde el archivo y regrese a Unity. <br><br><h3>  Informamos a los enemigos de la direcci√≥n del movimiento. </h3><br>  En su estado actual, los enemigos no conocen el orden de los puntos de ruta. <br><br>  Seleccione <em>Road</em> en la <em>Jerarqu√≠a</em> y agregue un nuevo script de <em>C #</em> llamado <em>SpawnEnemy</em> .  √Åbralo en el IDE y agregue la siguiente variable: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints;</code> </pre> <br>  Utilizaremos <code>waypoints</code> para almacenar referencias al waypoint en la escena en el orden deseado. <br><br>  Guarde el archivo y regrese a Unity.  Seleccione <em>Carretera</em> en la <em>Jerarqu√≠a</em> y establezca el <em>Tama√±o de</em> la matriz de <em>Waypoints</em> en <em>6</em> . <br><br>  Arrastre cada uno de los elementos secundarios de Road a los campos pegando <em>Waypoint0</em> en el <em>Elemento 0</em> , <em>Waypoint1</em> en el <em>Elemento 1,</em> y as√≠ sucesivamente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95a/1e3/251/95a1e3251247a04f62f8a618b681c052.gif"></div><br>  Ahora tenemos una matriz que contiene los puntos de ruta en el orden correcto: ten en cuenta que los enemigos nunca retroceden, se esfuerzan persistentemente por una dulce recompensa. <br><br><h3>  Mira c√≥mo funciona todo </h3><br>  Abra <em>SpawnEnemy</em> en el IDE y agregue la siguiente variable: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject testEnemyPrefab;</code> </pre> <br>  Almacenar√° una referencia al <code>testEnemyPrefab</code> <em>enemigo</em> en <code>testEnemyPrefab</code> . <br><br>  Para crear un enemigo al ejecutar el script, agregue el siguiente c√≥digo a <code>Start()</code> : <br><br><pre> <code class="cs hljs">Instantiate(testEnemyPrefab).GetComponent&lt;MoveEnemy&gt;().waypoints = waypoints;</code> </pre> <br>  Entonces crearemos una nueva copia del <code>testEnemy</code> almacenado en <code>testEnemy</code> y le asignaremos una ruta. <br><br>  Guarde el archivo y regrese a Unity.  Seleccione el objeto <em>Road</em> en la <em>Jerarqu√≠a</em> y seleccione el prefabricado <em>Enemigo</em> para el par√°metro <em>Test Enemy</em> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicie el proyecto y vea c√≥mo se mueve el enemigo a lo largo del camino (en GIF, para mayor claridad, la velocidad aumenta en 20 veces). </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b6/b10/384/0b6b1038491a74c27d6b42860e44365e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNot√≥ que no siempre mira a d√≥nde va? </font><font style="vertical-align: inherit;">Es divertido, pero estamos tratando de hacer un juego profesional. </font><font style="vertical-align: inherit;">Por lo tanto, en la segunda parte del tutorial, ense√±aremos a los enemigos a mirar hacia adelante.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øA d√≥nde ir despu√©s? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya hemos hecho mucho y estamos avanzando r√°pidamente hacia la creaci√≥n de nuestro propio juego de defensa de la torre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los jugadores pueden crear un n√∫mero limitado de monstruos, y el enemigo corre a lo largo del camino, en direcci√≥n a nuestra galleta. </font><font style="vertical-align: inherit;">Los jugadores tienen oro y pueden actualizar monstruos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargue el resultado final </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segunda parte,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consideraremos la creaci√≥n de enormes oleadas de enemigos y su destrucci√≥n. </font><font style="vertical-align: inherit;">Hasta pronto!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413837/">https://habr.com/ru/post/es413837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413817/index.html">Procesamiento de datos competitivos heterog√©neos en tiempo real estrictamente una vez</a></li>
<li><a href="../es413819/index.html">Sinceramente sobre el mercado de TI en Rusia</a></li>
<li><a href="../es413823/index.html">El boom del empleo sin sentido</a></li>
<li><a href="../es413827/index.html">Proyecto Kubernetes cumple 4 a√±os</a></li>
<li><a href="../es413831/index.html">La nueva versi√≥n del piloto autom√°tico Tesla se lanzar√° en agosto, por primera vez con "caracter√≠sticas de conducci√≥n totalmente aut√≥nomas".</a></li>
<li><a href="../es413839/index.html">AI, curso pr√°ctico. Colecci√≥n e investigaci√≥n de im√°genes.</a></li>
<li><a href="../es413841/index.html">Alternativas a los productos de Google</a></li>
<li><a href="../es413843/index.html">Waymo por delante del resto: los robom√≥viles de la compa√±√≠a han rodado 11 millones de kil√≥metros</a></li>
<li><a href="../es413847/index.html">Monumento desencadenante "vivo"</a></li>
<li><a href="../es413849/index.html">Historia de la marca Sennheiser: libertad y visi√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>