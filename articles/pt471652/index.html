<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧‍👧 👨🏼 🧑🏽‍🤝‍🧑🏻 Minha vida com a Boost Graph Library 🍪 👩🏽‍⚕️ 🧚🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O artigo, cuja primeira parte é apresentada aqui, contém várias considerações do autor, acumuladas durante o longo desenvolvimento de um sistema espec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Minha vida com a Boost Graph Library</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471652/">  O artigo, cuja primeira parte é apresentada aqui, contém várias considerações do autor, acumuladas durante o longo desenvolvimento de um sistema especializado para busca de conexões sociais, com base na Boost Graph Library (BGL).  Esta seção (técnica) resume as impressões do autor de trabalhar com esta biblioteca, levanta questões de instrumentação ao criar aplicativos gráficos e aborda alguns problemas práticos da metaprogramação em C ++. <br><a name="habracut"></a><br><h3>  BGL e com o que é consumido </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A biblioteca de modelos BGL</a> provavelmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">é</a> conhecida por qualquer desenvolvedor que tenha encontrado tarefas gráficas.  Aparecendo no Boost 1.18.1 em 2000, ela imediatamente ganhou críticas de aprovação de clássicos do gênero como Alexander Stepanov.  O guia da biblioteca, compilado por Jeremy Sik, Lai-Kwan Lee e Andrew Lamsdane, foi publicado em russo em 2006 por Peter (original - Jeremy G. Siek, Lie-Quan Lee e Andrew Lumsdaine, “The Boost Graph Library”, 2001 Addison-Wesley).  A biblioteca foi intensamente atualizada e desenvolvida quase até o final de 2013 (Boost 1.55.0).  Em particular, em 2005, apareceu o anúncio de sua versão distribuída (PBGL), que foi incluída no Boost da versão 1.40 em 2009 e até hoje continua sendo uma espécie de padrão de fato para computação gráfica em clusters de alto desempenho, em qualquer caso, no mundo acadêmico.  Tanto quanto a história dos commits pode ser julgada, até 2005, o principal desenvolvedor da biblioteca foi Jeremy Sik, depois de 2005 - Douglas Gregor, e em geral várias vezes uma quantidade considerável de diversas pessoas trabalhava na biblioteca.  As publicações dedicadas a ele apareceram repetidamente no habr.com: em primeiro lugar, uma série de artigos de Vadim Androsov deve ser observada: [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3</a> ].  Assim, em princípio, boa e diversa literatura é dedicada à biblioteca, mas sua própria documentação, também, de um modo geral, bastante extensa, sofre um pouco devido ao fato de que: <br><br><ol><li>  Seu índice e seções raiz, que pretendem fornecer uma lista exaustiva das principais entidades, não foram alterados desde 2001.  Por exemplo, o autor dessas linhas, que ingenuamente acreditava que: <blockquote>  Atualmente, o BGL fornece duas classes de gráficos e um adaptador de lista de arestas: <br><br>  adjacency_list <br>  adjacency_matrix <br>  edge_list </blockquote>  , depois de algum tempo, fiquei surpreso ao encontrar a representação compressed_sparse_row_graph (matriz esparsa) implementada em 2005.  Uma história semelhante ocorreu com o algoritmo Bron-Kerbosch.  Não acredite no índice, use uma pesquisa direta nos arquivos de cabeçalho; <br></li><li>  Não há uma única lista comentada das categorias internas da biblioteca (categoria_contêiner, características_alterna_ paralela, estabilidade_do_erador etc.) necessárias para implementar suas próprias visualizações.  Os problemas de compreensão do que está acontecendo ultrapassam, aparentemente, todos os usuários da biblioteca que desejam ir mais fundo, o que leva à aparência de um "tipo de código funcional", que leva muito tempo e esforço para trazê-lo a um estado completo: veja, por exemplo, uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">discussão típica</a> . </li></ol><br>  O número de categorias e vários seletores, incluindo aqueles que são confusamente semelhantes, é tão grande que os próprios autores às vezes se confundem neles.  Por exemplo, nos construtores do compressed_sparse_row_graph já mencionado acima, na versão atual, há um erro sistemático que causa falhas ao tentar copiar uma lista de adjacências não direcionadas: <br><br><img src="https://habrastorage.org/webt/5r/1e/se/5r1esesty1oui-pwco4b2pkfxei.jpeg"><br><br>  Pode-se notar aqui ocasionalmente que o teste completo de um mecanismo tão flexível é um problema separado, uma vez que é acompanhado por uma explosão combinatória do número de possíveis substituições. <br><br>  Deve-se notar com pesar que, atualmente, os principais desenvolvedores aparentemente tenham perdido o interesse em mais trabalhos na biblioteca e, nos últimos seis anos, ela, de maneira alguma esgotou seu potencial de desenvolvimento e nem mesmo se libertou completamente de inconsistências internas e erros diretos, está em voo livre.  Os planos expressados ​​na região de 2011 para expandir significativamente o conjunto de métodos e abranger novas áreas da teoria dos grafos (incluindo a adição de suporte interno ao particionamento de gráficos à capacidade de ler o formato METIS) permaneceram por cumprir.  Parece também que a biblioteca poderia se beneficiar muito (pelo menos em termos de legibilidade) com o amplo uso de novos produtos que se tornaram padrão após 2011. <br><br>  Assim, as questões de escolher uma biblioteca de referência para aplicativos gráficos ao olhar para 2019 não parecem tão claras quanto gostaríamos, e nos últimos 5 anos, a incerteza aumentou e não diminuiu. <br><br>  Essa situação causa tristeza, porque a criação de um mecanismo universal semelhante ao BGL é em si uma espécie de façanha intelectual, tanto em termos de poder da abordagem quanto da riqueza do arsenal de métodos universais implementados (uma boa e meia centena de thread único e duas dúzias distribuídas) a biblioteca, até onde o autor dessas linhas é conhecido, ainda não tem igual. <br><br>  No momento, somente essa biblioteca permite, em princípio, sem perda de desempenho, impor acordos estritos sobre a apresentação de dados e perda de controle sobre os mecanismos internos da própria biblioteca, para separar completamente os algoritmos e representações gráficas, tornando a última completamente independente da apresentação de metadados associados a arestas e vértices ( que, em princípio, é obviamente a maneira mais correta de fazer as coisas). <br><br>  A palavra "fundamentalmente" é usada aqui por uma razão.  Considerando uma situação específica usando o exemplo da longa classe compressed_sparse_row_graph já mencionada acima, podemos observar, por exemplo, os seguintes desvios em relação aos altos padrões: <br><br><ol><li>  O operador [] para a lista de adjacência e a matriz esparsa lida com as propriedades internas e externas das arestas de maneira diferente (Propriedades Internas e Agrupadas): o primeiro retorna apenas propriedades externas (internas são acessíveis apenas com property_map), o segundo retorna uma propriedade de estrutura de estrutura que contém uma lista comum de propriedades. </li><li>  A função get para obter o índice de borda usando boost :: property_map &lt;compressed_sparse_row_graph, boost :: edge_index_t&gt; :: type caiu em boost :: detail e não em boost, como em todos os outros casos. </li></ol><br>  Finalmente, no modelo compressed_sparse_row_graph, a especialização para o gráfico não direcionado (boost :: undirectedS) permaneceu não preenchida. <br><br>  Nesse sentido, ao usar a propriedade edge_index (número de série da borda), surgem dificuldades adicionais devido ao fato de que, para a lista de adjacências, essa propriedade deve ser explicitamente definida como interna e, como tal, pode ser alterada arbitrariamente, mas para um gráfico não direcionado, seu valor não depende da direção onde a costela passa.  Para uma matriz esparsa (sempre direcional), é uma constante constante property_map de uma forma especial (calculada como um índice em uma matriz de arestas).  Consequentemente, os valores para as arestas próximas (representando um gráfico não direcionado) não podem ser alterados e sempre serão diferentes. <br><br>  Todas essas discrepâncias levam à impossibilidade de "simplesmente substituir a representação gráfica por uma equivalente" ao chamar funções algorítmicas, o que prejudica significativamente a principal vantagem da biblioteca.  Na prática, nesses casos, é necessária uma especialização excessiva de código ou seu processamento para excluir elementos com comportamentos diferentes, ou um ajuste de modelos de gráfico para que eles "se comportem de forma idêntica" com diferentes definições de atributo ou, finalmente, remoção de arquivos individuais da biblioteca e criação "Versão de reforço pessoal." <br><br>  Além disso, os seguintes inconvenientes, não tão significativos, podem ser observados: <br><br><ul><li>  As dimensões dos descritores internos das representações gráficas têm um impacto significativo no consumo de memória necessário para armazenar o gráfico e, algumas vezes, afetam o desempenho dos algoritmos. <br><br>  Algumas visualizações (a mesma compressed_sparse_row_graph) permitem controlar essas dimensões.  Outros (adjacency_list) não possuem esses parâmetros e sempre usam números inteiros de 64 bits (geralmente redundantes), que não podem ser substituídos sem modificar o código; <br></li><li>  Apesar de os autores da biblioteca fornecerem muito, muito, algumas primitivas obviamente necessárias não foram incluídas na biblioteca.  Por exemplo, não há função como reverse_edge que executa inversão de borda. <br><br>  A implementação de tais funções, é claro, depende da representação gráfica: nesse caso, pode ser implementada por uma troca trivial de elementos de um par, pesquisa mais ou menos eficiente por contêiner ou não.  É difícil para o usuário final entender toda essa variedade de opções, principalmente porque, de acordo com a ideologia da biblioteca, os membros internos dos descritores não devem lhe interessar. <br></li><li>  Da mesma forma, alguns scripts longe de inúteis caíram da biblioteca.  Por exemplo, você pode definir predicados de aresta que usam o filter_graph para transformar um gráfico não direcionado em um gráfico direcionado, mas não há como chamar essa transformação à atenção da biblioteca.  Consequentemente, algoritmos regulares para gráficos direcionados não serão compilados com esse objeto, e algoritmos para gráficos não direcionados não funcionarão corretamente com ele. <br><br>  Em algum lugar da vizinhança, há o tópico de suporte para gráficos tecnicamente não direcionais que têm um marcador de direção de serviço nas bordas.  No entanto, maior atenção a essa visão pode ser devida à natureza específica das tarefas que o autor resolve, e o amplo interesse em apoiar esses objetos não é óbvio. <br></li><li>  Quanto à função reverse_edge, tomada como exemplo acima, não existe uma opção incrível de que a função desejada esteja presente em algum lugar nas entranhas da biblioteca, mas por algum motivo recebeu um nome não óbvio.  Isso leva ao seguinte problema, que à primeira vista não é sério, mas diminui significativamente o trabalho com bibliotecas de modelos complexas (não apenas o BGL, embora esteja claramente entre os líderes por esse critério): trabalhe com sistemas extensos de funções relacionadas implicitamente sem digitar explicitamente os parâmetros e com a semântica não óbvia do uso (geralmente a menos transparente que a mais bem pensada) é fisicamente difícil, e os ambientes de desenvolvimento existentes não fornecem suporte para isso no desenvolvedor: <br><br> <abbr title="Obrigado, você ajudou muito."><img src="https://habrastorage.org/webt/bn/ad/fq/bnadfqng3f4ryjrc8qkwaxtf78e.png"></abbr> <br><br>  De fato, assistentes automáticos: <br><br><ol><li>  Projetado principalmente para suporte a OOP, quando um conjunto de funções é vinculado ao objeto à direita, de acordo com seu tipo.  Com funções globais que podem ficar à esquerda de um tipo (muito menos um conjunto de tipos), elas ajudam muito pior, mesmo que todos os tipos sejam conhecidos. </li><li>  Eles ridiculamente nem são capazes de trabalhar com modelos simples.  A versão do assistente visual usada pelo autor, tendo à sua frente a definição de uma classe de modelo com parâmetros padrão, oferece a especificação de uma “substituição de teste” para poder gerar uma dica para a classe.  Se você a conhecer, absolutamente nada acontece. </li><li>  Além disso, eles são menos capazes de entender qualificadores de metaprograma, mesmo os mais simples, como enable_if. </li><li>  Sobre um cenário típico: “estamos dentro de uma função de modelo chamada a partir de um número indefinido de cadeias de comprimento indefinido de outras funções, incluindo as de modelo”, é impossível falar sem lágrimas.  Nesse caso, o vim realmente continua sendo o melhor amigo do programador. </li></ol><br>  Outro aspecto da mesma situação pode ser ilustrado usando a primeira linha do fragmento de código mostrado na figura anterior.  O leitor é convidado a concluir as consultas "aumentar a hora atual" versus "hora atual da CRT" e comparar os resultados.  Sim, o boost :: date_time (agora parcialmente movido para std) torna possível fazer muitas coisas complexas corretamente, enquanto o CRT permite executar várias operações triviais incorretamente, mas em situações domésticas comuns, o CRT é mais conveniente de todos os pontos de vista e polinomiais construções do formato posix_time :: second_clock :: local_time (um exemplo simples) tendem a se transformar em hieróglifos vagando no programa.  Privar o desenvolvedor de acesso à biblioteca pessoal de tais hieróglifos e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a velocidade de desenvolvimento será zero</a> . <br><br>  O Boost :: string_algo torna possível fazer qualquer coisa com strings, mas, honestamente, cada operação não muito trivial é acompanhada de uma sessão de releitura da documentação para atualizar a lógica geral da biblioteca, os nomes dos predicados e um exercício separado para descobrir a compatibilidade dos parâmetros.  Uma situação semelhante ocorre com operações de tokenização no boost :: regexp, com lógica interna impecável do último. <br><br>  Se tal situação ocorrer com as bibliotecas mais usadas, não surpreende que o BGL, como uma biblioteca mais especializada, na qual, por exemplo, existam funções make_property_map_function e make_function_property_map que não estejam relacionadas entre si, assim como uma função get sacramental que seja recarregada para qualquer o número de argumentos de qualquer tipo gera os mesmos problemas, mas de forma hipertrofiada.  Sim, qualquer tarefa pode ser resolvida pela cadeia de chamadas get, mas, infelizmente, nem toda cadeia get resolve esse problema. <br><br>  Ler um código como esse pode ser fácil e agradável, pode até parecer uma sinopse de um algoritmo formalmente escrito em uma linguagem natural, mas ao escrevê-lo, a impossibilidade de substituir palavras por sinônimos, etc. manifestações de rigidez, não é característica de um real. <br></li><li>  Em ordem geral, não se pode deixar de repetir a observação banal, mas não se tornando menos verdadeira, de que a metaprogramação em C ++ ainda é literalmente baseada em efeitos colaterais de ferramentas de linguagem cujo objetivo original era diferente e até nas idéias mais simples com base em Como resultado, é difícil expressar e ler a metalinguagem, e vincular o código do modelo ao sistema arcaico dos arquivos incluídos não facilita a vida do desenvolvedor e não reduz a quantidade de código processado pelo compilador. <br><br>  (Por outro lado, as atualizações periódicas de boost e std trazem muitas construções não muito triviais e muitas vezes extremamente úteis e soluções inesperadas, o que realmente permite escrever códigos mais claros e compactos a um custo menor. No entanto, o fluxo de novos produtos é tão amplo, desigual e mal estruturado que os mais importantes adições à biblioteca padrão, mesmo as mais óbvias, como as opções / apply_visitor ou qualquer outra mencionada abaixo, se as vantagens conceituais de sua aplicação no contexto de um projeto específico não forem relevantes  Por óbvio, sem a ajuda de um evento feliz, eles podem ficar fora de foco por um longo tempo, se você não gastar uma parte significativa do tempo de trabalho rastreando cuidadosamente novos produtos, estudando exemplos não triviais de uso e tentativas mentais de aplicá-los a um código existente. para lidar com esse problema - manter para cada cinco programadores de C ++ em prática um C ++ - um teórico ocupado apenas com questões prioritárias de novos produtos, sua implementação  ções no projeto e os profissionais da educação seletiva.  Conclusão: <s>não inicie projetos C ++ com menos desenvolvedores</s> ). <br></li><li>  Por fim, objetivamente, o problema mais sério que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ocorre ao trabalhar com o código padrão da BGL</a> .  Suponha que estamos usando algum algoritmo de gabarito que faz uma passagem através de um gráfico e toma uma representação do gráfico G como argumento.  Em um caso típico, essa representação depende dos filtros sobrepostos nos vértices e nas arestas <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>F</mi><mi>v</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.524ex" height="2.419ex" viewBox="0 -780.1 1086.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgD21NktMCTffX08ozlZr5WwiJRcA#MJMATHI-46" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgD21NktMCTffX08ozlZr5WwiJRcA#MJMATHI-76" x="910" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>F</mi><mi>v</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-1"> F_v </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>F</mi><mi>e</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.493ex" height="2.419ex" viewBox="0 -780.1 1073.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgD21NktMCTffX08ozlZr5WwiJRcA#MJMATHI-46" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgD21NktMCTffX08ozlZr5WwiJRcA#MJMATHI-65" x="910" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>F</mi><mi>e</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-2"> F_e </script>  e esquema de peso <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.435ex" height="2.057ex" viewBox="0 -780.1 1048.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgD21NktMCTffX08ozlZr5WwiJRcA#MJMATHI-57" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>W</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> W </script>  .  Para trabalhar com gráficos filtrados, o BGL oferece a classe de modelo filter_graph mencionada acima, a maneira de anexar o esquema de ponderação é a critério do usuário.  Functors representando <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>F</mi><mi>v</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.524ex" height="2.419ex" viewBox="0 -780.1 1086.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgD21NktMCTffX08ozlZr5WwiJRcA#MJMATHI-46" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgD21NktMCTffX08ozlZr5WwiJRcA#MJMATHI-76" x="910" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>F</mi><mi>v</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-4"> F_v </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>F</mi><mi>e</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.493ex" height="2.419ex" viewBox="0 -780.1 1073.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgD21NktMCTffX08ozlZr5WwiJRcA#MJMATHI-46" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgD21NktMCTffX08ozlZr5WwiJRcA#MJMATHI-65" x="910" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>F</mi><mi>e</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-5"> F_e </script>  e <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.435ex" height="2.057ex" viewBox="0 -780.1 1048.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/471652/&amp;usg=ALkJrhgD21NktMCTffX08ozlZr5WwiJRcA#MJMATHI-57" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>W</mi></math></span></span><script type="math/tex" id="MathJax-Element-6"> W </script>  pode incluir pelo menos as seguintes visualizações: <br><br><ul><li>  Diretamente um wrapper para uma função que representa um esquema de ponderação e predicados que representam filtros (lentamente, sem perda de inicialização); </li><li>  Caches sobre esses wrappers, mapeando descritores de borda / nó para índices de borda / nó, abordando o bitmap e a matriz de valores (sem perdas de inicialização, com um aumento gradual na velocidade conforme usado); </li><li>  Mapeamento direto de descritores de nó / borda para matrizes de valor preenchidas (requer inicialização, mas pode ser construído com base na representação anterior; a velocidade atinge o máximo). </li></ul><br>  Portanto, se esse algoritmo fosse escrito em um estilo tradicional, três seletores com pelo menos três ramificações em cada apareceriam em seu corpo (e a necessidade de ajustar o corpo quando novas representações aparecerem).  Como cada ramificação no corpo do algoritmo, que executa um grande número de vezes ao passar pelo gráfico, resulta em perda de tempo perceptível, o desejo de evitar essas perdas enquanto mantém o código do mesmo estilo tradicional pode levar a mais de 27 implementações do algoritmo para várias combinações de representações. <br><br>  O estilo do metaprograma deve salvá-lo desses problemas, permitindo que você suporte uma metafunção que descreve o algoritmo que gera implicitamente todas as implementações necessárias (e também, possivelmente, algumas e possivelmente uma quantidade considerável de desnecessária se as estruturas de código de tempo de execução não gerarem de fato algumas combinações de tipos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">      </a> ),        . <br><br>   ,  ,          inline-    ,           –O2.           -      (              1:3  1:5,           – <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  ,  ,  </a> ). <br><br>           ,    .               . ,    ( )     ,      «»  «»  .   ,       .       :    «»      «»  ,                 «» ,                 «» . <br><br>    ,         :    ,   100%         ,       ,   «»  . ( ,    ,     - ,   ,    , ,      ,  ). <br></li><li>         ,   ,     ,     .     C++   , -,  ,          . <br><br>   ,   ,    : <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_selector_fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type_a a, type_b b, ...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition_1(a, b, ...)) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> arg = get_type_1_obj(a, b, ...); run_calc(arg, a, b, ...); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition_1(a, b, ...)) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> arg = get_type_2_obj(a, b, ...); run_calc(arg, a, b, ...); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... }</code> </pre> <br>  Ele pode ser reescrito de forma um pouco mais compacta usando a variante &lt;...&gt; aproximadamente da seguinte forma: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_selector_fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type_a a, type_b b, ...)</span></span></span><span class="hljs-function"> </span></span>{ variant&lt;type_1, type_2, ...&gt; arg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition_1(a, b, ...)) { arg = get_type_1_obj(a, b, ...); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ... ... apply_visitor([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> arg_){run_calc(arg_, a, b, ...); }, arg); }</code> </pre><br>  A desvantagem dessa forma de escrita é a necessidade de enumeração explícita dos tipos type_1, type_2, ... na declaração da variante.  Esses tipos podem ser complicados, a gravação usando declval / result_of_t não pode ser menos complicada. <br><br>  Ao usar qualquer, não há necessidade de listar tipos, mas não há como obter um apply_visitor analógico. <br><br>  O uso de alguma função de modelo make_variant, que permite escrever código do seguinte tipo, sugere-se: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> arg = make_variant ( bind(condition_1, a, b, ...), bind(get_type_1_obj, a, b, ...), bind(condition_2, a, b, ...), bind(get_type_2_obj, a, b, ...), ... );</code> </pre><br>  mas a cura não parece melhor que a doença. <br><br>  Em geral, existe uma situação típica para a metaprogramação em C ++, quando, para expressar uma idéia muito simples, é necessário usar todo um arsenal de ferramentas auxiliares com um resultado que não é muito satisfatório em termos de legibilidade e facilidade de gravação.  Essencialmente, eu gostaria de poder escrever algo como o seguinte: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   variant&lt;...&gt;      //  ,   : type_1, type_2 etc. variant&lt;auto...&gt; get_type_obj(typa_a a, type_b b, ...) { if (condition_1(a, b, ...)) { return get_type_1_obj(a, b, ...); } else if (condition_2(a, b, ...)) { return get_type_2_obj(a, b, ...); } else ... }</span></span></code> </pre><br>  ou até: <br><br><pre> <code class="cpp hljs"> select_value_type(arg) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition_1(a, b, ...)) { arg = get_type_1_obj(a, b, ...); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... ... } run_calc(arg, a, b, …);</code> </pre><br>  A última opção, embora seja completamente eliminada do estilo C ++, parece mais prática, pois pode haver mais de uma variável arg para a qual o tipo é selecionado e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">não há motivo para antecipar a lógica de sua construção</a> . <br></li><li>  O outro lado da mesma situação é o uso de estruturas auxiliares (por exemplo, armazenamento em cache) que implementam um script que merece o nome de uma "variável de modelo", mas difere da extensão padrão C ++ 14 com o mesmo nome. <br><br>  O código correspondente pode ser algo como isto: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheHolder</span></span></span><span class="hljs-class"> {</span></span> boost::variant&lt; container&lt;T1&gt;, container&lt;T2&gt;, <span class="hljs-comment"><span class="hljs-comment">// ... container&lt;TN&gt;&gt; ct; template&lt;typename T&gt; struct result_type_selector { typedef typename if_c&lt;is_compatible&lt;T, T1&gt;::value, T1, if_c&lt;is_compatible&lt;T, T2&gt;::value, T2, // ... if_c&lt;is_compatible&lt;T, TN&gt;::value, TN, std::decay_t&lt;T&gt;&gt;&gt;&gt;::type type; }; template&lt;typename T&gt; auto get() const -&gt; const container&lt;typename result_type_selector&lt;T&gt;::type&gt;&amp; { return boost::get&lt;container&lt;typename result_type_selector&lt;T&gt;::type&gt;&gt;(ct); } };</span></span></code> </pre><br>  Aqui, como acima, construções longas expressam a idéia simples de acessar uma variável que representa o cache por um nome específico, independentemente da dimensão do valor em cache (passando de maneira transparente pelo código de chamada). <br><br>  Por uma questão de brevidade, o código é fornecido para o caso em que apenas um tipo pode estar ativo, mas na prática a situação é mais comum quando vários contêineres podem existir simultaneamente (ele pode ser facilmente implementado no mesmo estilo usando tupla e opcional). <br><br>  A implementação da função get &lt;...&gt; supõe que o código de chamada tenha alguma idéia de que tipo de valor em cache ele deseja acessar (por exemplo, número inteiro ou ponto flutuante). <br><br>  Não menos comum é a situação em que o valor exato do tipo não é importante para o chamador.  Nesse caso, o script select_value_type / apply_visitor do parágrafo anterior é reproduzido (ajustado para a possível multiplicidade de valores, o que implica a visualização de tipos em ordem decrescente de prioridade). <br></li><li>  Até agora, praticamente não houve menção ao PBGL neste texto.  Isso é explicado pela experiência cada vez menor do autor de trabalhar com essa parte da biblioteca (em relação à qual o próprio autor, com um certo ceticismo, se refere a tudo o que está escrito abaixo neste parágrafo e apela a outros para o mesmo).  De fato, esse experimento se resume a vários experimentos, no mesmo tipo de problemas de pesquisa que demonstraram em dados práticos a perda de uma versão distribuída para uma solução local 3-5 vezes na memória e 15-20 vezes no desempenho geral (a origem dessa figura assustadora é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">explicada aqui</a> e comentada adicionalmente nos parágrafos seguintes) .  Dada a maior complexidade de trabalhar com estruturas distribuídas, a escolha a favor da versão local era evidente em tal situação. <br><br>  Vamos explicar a mecânica da operação PBGL usando um exemplo típico do algoritmo delta-walking.  Nesta versão paralela do algoritmo de Dijkstra, a fila de prioridade é substituída por uma matriz de "buckets".  Os elementos que se enquadram em um "bloco" são processados ​​em paralelo.  Na sua forma original, o ritmo delta é um algoritmo típico para sistemas de memória compartilhada. <br><br>  Na versão distribuída, acontece o seguinte: no PBGL, ao carregar, o gráfico é espalhado entre os processos, e cada processo possui um intervalo contínuo de números de vértices.  Assim, pelo número do vértice global, é fácil saber a qual processo ele pertence.  Consequentemente, cada processo em cada turno do algoritmo armazena uma parte do "bucket" que contém os vértices pertencentes a esse processo.  Todos os processos simultaneamente selecionam e processam os vértices de suas partes dos "buckets", um de cada vez, enquanto enviam mensagens sobre a necessidade de atualizar os seguintes "buckets" para processos que possuem os vértices vizinhos.  É fácil ver que, ceteris paribus, um aumento no número de processos leva a um aumento no número de mensagens que eles enviam.  Como resultado, o tempo de execução do algoritmo pode não apenas diminuir, mas até aumentar.  Em particular, o lançamento de vários processos MPI para resolver esse problema em uma máquina física com uma certa probabilidade só levará a um aumento na carga total do processador sem nenhum ganho de tempo. <br><br>  Deve-se observar que o ritmo delta é o algoritmo de pesquisa distribuído mais rápido (dos três suportados pela biblioteca). <br><br>  Portanto, se o gráfico não for preparado anteriormente, ele deverá ser dividido em blocos de tamanho máximo, um bloco por máquina física.  Por preparação preliminar, entendemos aqui a renumeração dos vértices do gráfico para que os intervalos contínuos de números usados ​​pelo PBGL, se possível, correspondam a subgráficos vagamente conectados.  Pacotes como METIS, paraMETIS e Zoltan são usados ​​para esses fins.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhar com gráficos dinâmicos nesse modo é difícil.</a> <br><br>  Em geral, de acordo com os resultados dos experimentos descritos, o autor teve a impressão de que a operação normal do cluster PBGL é possível apenas com equipamentos de comunicação especiais, e faz sentido usar máquinas com um número mínimo de núcleos e desempenho máximo do encadeamento como nós desse cluster.  Os autores do <a href="">Trinity,</a> em seu artigo, argumentam que o armazenamento distribuído funciona com muito mais eficiência - o autor acha difícil comentar sobre essa afirmação, mas, dadas as circunstâncias acima, considera bastante possível: a arquitetura PBGL tem um selo distinto do tempo em que as máquinas com vários núcleos ainda não receberam ampla distribuição. <br><br>  O PBGL também compartilha os problemas da versão single-threaded: alguma sincronização de código, documentação e exemplos, agravados pela maior complexidade do sistema e menos usuários dispostos a compartilhar experiências úteis. <br></li></ul><br><h3>  BGL e outros animais </h3><br>  Levando em conta uma lista bastante longa de reclamações específicas, não será inapropriado perguntar: o autor pode recomendar a BGL para novos projetos em 2019.  A resposta é a seguinte: o autor acredita que as bibliotecas desse estilo e aplicativos baseados neles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">devem ter um futuro</a> .  Quanto à escolha de uma biblioteca de referência para um projeto em particular, devemos considerar seriamente a instrumentação, sem perder de vista os problemas listados acima.  A resposta, obviamente, depende de muitas circunstâncias, incluindo, entre outras, as listadas nos parágrafos seguintes: <br><br><ul><li>  Se trabalhar com gráficos em um projeto é a base da funcionalidade ou uma tarefa opcional; </li><li>  Um projeto pode obter vantagem com o uso de várias representações ou trabalhar com algoritmos de tipo rígido o suficiente; </li><li>  O tipo mais benéfico de simultaneidade para o projeto; </li><li>  Nuanças organizacionais: o desejo de metaprogramação em C ++ entre funcionários (especialmente programadores de matemática), etc. </li></ul><br>  Provavelmente, ceteris paribus, o uso de BGL pode ser justificado no caso de um uso único muito pequeno (para extrudar ou copiar um código de trabalho e esquecer), ou para um sistema grande para o qual uma maior flexibilidade pagará entrada pesada e outros custos ao longo do tempo.  Em outros casos, faz sentido estudar cuidadosamente outras opções. <br><br>  Quanto às possíveis alternativas, sua lista inclui pelo menos os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seguintes itens</a> : <br><div class="scrollable-table"><table><tbody><tr><td>  Título </td><td>  Lemon </td></tr><tr><td>  Tipo de biblioteca </td><td>  Cabeçalho do modelo C ++ </td></tr><tr><td>  URL </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lemon.cs.elte.hu</a> </td></tr><tr><td>  Distribuído </td><td>  não </td></tr><tr><td>  Multithread </td><td>  não </td></tr><tr><td>  OS </td><td>  qualquer </td></tr><tr><td>  Versão mais recente </td><td>  2014 <br>  Distribuído pelo arquivo </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Stackoverflow menciona</a> </td><td>  ~ 100 (36 na seção [lemon-graph-library]) </td></tr><tr><td>  Comentário </td><td>  Segundo alguns relatórios, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no modo de thread único excede significativamente a velocidade do BGL</a> . <br>  A atitude dos autores em relação ao multithreading <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">é evidente no diálogo a seguir</a> .  Em vista do exposto na seção sobre PBGL, essa posição é duvidosa. </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><td>  Título </td><td>  SNAP </td></tr><tr><td>  Tipo de biblioteca </td><td>  C ++ </td></tr><tr><td>  URL </td><td>  <a href="">github.com/snap-stanford/snap.git</a> </td></tr><tr><td>  Distribuído </td><td>  não </td></tr><tr><td>  Multithread </td><td>  sim (parte dos métodos) </td></tr><tr><td>  OS </td><td>  Linux, Mac, Cygwin </td></tr><tr><td>  Versão mais recente </td><td>  2018 <br>  O repositório está sendo atualizado ativamente. </td></tr><tr><td>  O Stackoverflow menciona </td><td>  &lt;50 </td></tr><tr><td>  Comentário </td><td>  Uma das maiores bibliotecas de análise de rede (com mais de 10 Mb de código) (Network Ananlysis), que se desenvolve ativamente há muitos anos.  De uma maneira estranha, é comparativamente ignorado pela atenção do público. <br>  Veja a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descrição da ideologia do sistema</a> .  A atitude em relação à implementação de métodos paralelos, expressa na página 12, é próxima ao autor deste artigo.  Sob as condições operacionais de um parque de máquinas moderno típico, é o mais natural.  A mudança de paradigma ocorreu em 2011 condicional, a que a declaração LEMON acima se refere. </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><td>  Título </td><td>  MTGL </td></tr><tr><td>  Tipo de biblioteca </td><td>  Cabeçalho do modelo C ++ </td></tr><tr><td>  URL </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">software.sandia.gov/svn/public/mtgl/trunk</a> </td></tr><tr><td>  Distribuído </td><td>  ? </td></tr><tr><td>  Multithread </td><td>  sim </td></tr><tr><td>  OS </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">qualquer</a> </td></tr><tr><td>  Versão mais recente </td><td>  ? </td></tr><tr><td>  O Stackoverflow menciona </td><td>  3 </td></tr><tr><td>  Comentário </td><td>  Membro misterioso da reunião.  A biblioteca estava se desenvolvendo ativamente entre 2005 e 2012.  As fontes foram carregadas em 2017.  Status não claro, menção do projeto no site Sandia removida.  Ideologicamente inspirado pelo mesmo BGL, mas o código é completamente independente.  A quantidade total de código fonte (incluindo vários testes e exemplos) atinge 17 MB.  O código parece bem projetado.  Veja a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descrição</a> . </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><td>  Título </td><td>  igraph </td></tr><tr><td>  Tipo de biblioteca </td><td>  C </td></tr><tr><td>  URL </td><td>  <a href="">github.com/igraph/igraph.git</a> </td></tr><tr><td>  Distribuído </td><td>  não </td></tr><tr><td>  Multithread </td><td>  não </td></tr><tr><td>  OS </td><td>  alguma? </td></tr><tr><td>  Versão mais recente </td><td>  2014 <br>  O repositório está sendo atualizado ativamente. <br></td></tr><tr><td>  O Stackoverflow menciona </td><td>  Cerca de 100 nas seções [igraph] [c ++] e [igraph] [c] e mais de 500 no total (para todos os idiomas) <br></td></tr><tr><td>  Comentário </td><td>  Outra biblioteca de análise de redes, aparentemente, é muito popular (principalmente entre pythonists, etc.).  Descrição <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><td>  Título </td><td>  ferramenta gráfica </td></tr><tr><td>  Tipo de biblioteca </td><td>  C ++ python lib </td></tr><tr><td>  URL </td><td>  <a href="">git.skewed.de/count0/graph-tool.git</a> </td></tr><tr><td>  Distribuído </td><td>  não </td></tr><tr><td>  Multithread </td><td>  sim </td></tr><tr><td>  OS </td><td>  A julgar pelo uso do autoconf - * nix, apenas uma provável adaptação a outros sistemas </td></tr><tr><td>  Versão mais recente </td><td>  2019 </td></tr><tr><td>  O Stackoverflow menciona </td><td>  &lt;20 </td></tr><tr><td>  Comentário </td><td>  Outra biblioteca de análise de rede em desenvolvimento ativo com um longo histórico de confirmações que usa diretamente o BGL (na versão corrigida local). <br>  Consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tabela de comparação de desempenho.</a> </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><td>  Título </td><td>  LEDA </td></tr><tr><td>  Tipo de biblioteca </td><td>  C ++ </td></tr><tr><td>  URL </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.algorithmic-solutions.com/index.php/products/leda-for-c</a> </td></tr><tr><td>  Distribuído </td><td>  não </td></tr><tr><td>  Multithread </td><td>  ? </td></tr><tr><td>  OS </td><td>  qualquer </td></tr><tr><td>  Versão mais recente </td><td>  ? </td></tr><tr><td>  O Stackoverflow menciona </td><td>  ~ 10 </td></tr><tr><td>  Comentário </td><td>  Licença comercial.  Uma grande (e, pode-se dizer, antiga) biblioteca de computação científica e tecnológica, incluindo uma seção de gráficos.  Aparentemente, depende de sua própria infraestrutura, e não de stl / boost, e nesse sentido é arcaico. </td></tr></tbody></table></div><br>  De particular interesse geral é a questão da classificação de vários produtos de software orientados para trabalhar com gráficos.  Sua diversidade, para não mencionar o número, é muito grande.  Sem pretender concluir (e até mesmo formalmente) a classificação, podemos tentar, no entanto, destacar as seguintes áreas importantes no desenvolvimento de aplicativos gráficos: <br><ol><li>  Gráfico de DBMS (neo4j, etc.). <br><br>  Sistemas desse tipo estão focados na execução de operações transacionais em gráficos grandes (disco distribuído).  Embora a API desse sistema possa ser altamente desenvolvida, a velocidade de execução dos próprios algoritmos gráficos, até onde se pode julgar, não é a primeira prioridade.  O sistema pode nem tentar carregar o gráfico inteiro na memória.  Para modificação e passagem de gráfico, são suportadas linguagens declarativas (SPARQL, Cypher, Gremlin).  É de grande importância garantir a continuidade dos sistemas SQL tradicionais. </li><li>  Extensões gráficas de sistemas de processamento de big data que trabalham no paradigma mapear / reduzir (GraphX ​​no Spark, Pegasus e Giraph para Hadoop) e sistemas de cluster independentes ( <a href="">MS Trinity / MS Graph Engine</a> , GraphLab).  Os primeiros a executar operações no gráfico implementam o modelo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google Pregel</a> (mas não apenas ele) e podem ser configurados para uso, incluindo nós de computação paralela em massa.  Esses e outros podem ser usados, entre outras coisas, como base para projetos de software corporativo. <br><br>  Embora a API desses sistemas possa ser bastante desenvolvida (entre outras coisas, o GraphX ​​suporta SPARQL e Cypher), o foco principal ao trabalhar com eles é a solução de problemas de infraestrutura.  O GraphX ​​é caracterizado pela imutabilidade dos dados e um viés no pipelining de todas as operações.  Atualmente, o MS Trinity não inclui métodos de alto nível e fornece apenas um conjunto de primitivas para trabalhar com nós e arestas.  Os sistemas executados no topo do Hadoop são, em princípio, de pouca utilidade para resolver problemas gráficos arbitrários. <br></li><li>  Bibliotecas de ferramentas realmente universais que implementam conjuntos de métodos mais ou menos amplos (BGL / PBGL, LEMON etc.), incluindo os massivamente paralelos (nvGraph, Gunrock). <br><br>  Com base neles, podem ser criados sistemas de aplicativos que adaptam algoritmos gráficos a áreas específicas. </li><li>  Sistemas e bibliotecas especializados em problemas complexos e de importância universal (METIS, paraMETIS, Zoltran: particionamento de gráficos, GraphViz, Gephi: visualização, GraphBLAS: algoritmos algébricos para trabalhar com gráficos, etc.). <br><br>  Muitos aplicativos gráficos independentes podem ser atribuídos condicionalmente a essa categoria, cuja análise detalhada exigiria muito tempo.  Este último contém aplicações de todas as variedades possíveis: acadêmicas e comerciais, de usuário único e multiusuário, surgiram recentemente e existem há mais de uma década, etc. </li></ol><br>  Uma parte obscura, mas significativa, dos aplicativos gráficos é focada nas tarefas de Análise de Rede e, já, Análise de Rede Social (Detecção de Comunidade).  Curiosamente, os sistemas de Análise de Link (usados, geralmente, por vários "combatentes do crime") são muito menos comuns, que têm uma certa semelhança com o sistema que estamos desenvolvendo.  Em todos os casos, sem uma verificação especial, é difícil determinar a natureza dos modelos de dados usados ​​por vários sistemas e as limitações de desempenho associadas, volumes suportados, conjuntos de operações etc. <br><br><h3>  Anotações </h3><br><ol><li><a name="P1"></a>  O BGL não é uma biblioteca puramente de cabeçalho, mas, no momento, a única funcionalidade que precisa de vinculação é (bastante opcional) trabalhar com arquivos DOT do GraphViz.  Portanto, na grande maioria dos casos, não há necessidade de vincular e vincular automaticamente a versão adequada do libbost-graph para incluir cabeçalhos BGL na configuração do Boost.  Portanto, para obter consistência com a biblioteca libboost-regex usada por funções BGL sem cabeçalho, é conveniente simplesmente conectar o cabeçalho boost \ regex.hpp do código do projeto, mesmo que este último não use expressões regulares. </li><li><a name="P2"></a>  Caos adicional é introduzido pela presença de entidades cuja aparente equivalência <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">incentiva a caça a (possivelmente ausentes) gatos pretos em salas escuras</a> . </li><li><a name="P3"></a>  Antes de prosseguir com sua descrição (usando um exemplo específico, onde ele se manifestou de maneira especialmente forte e desagradável), observamos que o autor está entre as poucas pessoas de sorte que trabalham com um projeto carregado em um poderoso sistema operacional Windows e a linha salva de Deus de compiladores MSVC.  É possível que os problemas descritos abaixo sejam artefatos dessa linha de compiladores: uma variedade de circunstâncias particulares dificulta a realização de um experimento comparativo com o gcc / clang no ambiente * nix.  Nesse caso, você só pode parabenizar usuários de outros compiladores. </li><li><a name="P4"></a>  Para suavizar o que, em alguns casos, o recentemente apareceu constexpr if provavelmente ajudará. </li><li><a name="P5"></a>  No nosso caso, isso levou a uma atenção especial à função de economia de estado, que permite a depuração com conveniência, primeiro levando o sistema ao estado inicial desejado em uma montagem otimizada. </li><li><a name="P6"></a>  Na minha prática, por várias razões, havia a necessidade de converter parâmetros de tempo de execução em argumentos de modelo, e muitas vezes eu tive que recorrer a formas muito elaboradas (com muita precisão) (inspiradas nas implementações desatualizadas de boost typeof e boost lambda para C ++ 98, que atingiam diretamente o (tratar a técnica de programação em C ++ como uma solução para o rébus), entre as quais a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estrela brilha na seleção do argumento dividindo-a ao meio</a> , mas, em geral, os principais problemas com essas operações sempre foram associados à incapacidade de exportar  tipo selecionado fora do escopo, que deu origem a padrões exóticos. </li><li><a name="P6X1"></a>       (   —  80   4      50    200  ,     )     (  )       -   . ,                .    ,  6-8      —   ,        . </li><li><a name="P7"></a>        ,        . (  ,       -  ,      .  ,     ,  ,     ,  ,       , ,        ). </li><li><a name="P8"></a>   ,    ,    –   ,     ,   «»     (--  ..)     .  (  ,   ),    ,   «»    ,     —     (              ).  ,  ,      , -   .  ,    ,   : «»  (   )  ,     «» (   ),         ,     .           .         ,   - ,      «      »,      .        ,   «  »     ? ,        ,         ,   :  –    , ,       ,    ,          . </li><li><a name="P9"></a>    .         ,     ,             . </li><li><a name="P10"></a>    «LIBNAME C++ graph»  ,           stackoverflow.  ,  BGL   500    [boost-graph]. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471652/">https://habr.com/ru/post/pt471652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471636/index.html">Veículo não tripulado: algoritmos de animação. Relatório Yandex</a></li>
<li><a href="../pt471640/index.html">Uma visão geral das técnicas de análise de blockchain anônimas</a></li>
<li><a href="../pt471642/index.html">Assassino de infância</a></li>
<li><a href="../pt471644/index.html">Novamente sobre o phpQuery</a></li>
<li><a href="../pt471650/index.html">Pizza AI: como usamos duas redes neurais recorrentes</a></li>
<li><a href="../pt471654/index.html">Como desenvolvemos um dispositivo de Internet resistente às geadas</a></li>
<li><a href="../pt471658/index.html">Golpistas por telefone. A primeira ação em que sou gentilmente informado sobre outros golpistas</a></li>
<li><a href="../pt471660/index.html">Palestra sobre Psicologia do Jogador</a></li>
<li><a href="../pt471662/index.html">Web - autenticação javascript, ofuscação e código nativo. Solução de problemas com o r0ot-mi Web - Client. Parte 1</a></li>
<li><a href="../pt471664/index.html">Estágio na ABBYY: uma empresa com a qual você pode ser “você”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>