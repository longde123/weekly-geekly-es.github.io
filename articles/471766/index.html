<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÆ üàöÔ∏è ‚ú≥Ô∏è Manejo de errores de Kotlin / Java: ¬øc√≥mo hacerlo bien? ü•ò üò≤ üë´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fuente 


 El manejo de errores en cualquier desarrollo juega un papel crucial. Casi todo puede salir mal en el programa: el usuario ingresar√° datos i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manejo de errores de Kotlin / Java: ¬øc√≥mo hacerlo bien?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/471766/"><img src="https://habrastorage.org/webt/hw/w3/mc/hww3mcjps5hwhykuwyzwj8upunu.jpeg"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuente</a> </p><br><p>  El manejo de errores en cualquier desarrollo juega un papel crucial.  Casi todo puede salir mal en el programa: el usuario ingresar√° datos incorrectos, o pueden venir a trav√©s de http, o cometimos un error al escribir la serializaci√≥n / deserializaci√≥n y durante el procesamiento, el programa se bloquea con un error.  S√≠, puede quedarse sin espacio en el disco. </p><br><div class="spoiler">  <b class="spoiler_title">spoiler</b> <div class="spoiler_text"><p>  ¬Ø_ („ÉÑ) _ / ¬Ø, no existe una √∫nica forma, y ‚Äã‚Äãen cada situaci√≥n espec√≠fica tendr√° que elegir la opci√≥n m√°s adecuada, pero hay recomendaciones sobre c√≥mo hacerlo mejor. </p></div></div><a name="habracut"></a><br><h3 id="predislovie">  Pr√≥logo </h3><br><p>  Desafortunadamente (¬øo tal vida?), Esta lista sigue y sigue.  El desarrollador necesita pensar constantemente en el hecho de que en alg√∫n lugar puede ocurrir un error, y hay 2 situaciones: </p><br><ul><li>  cuando se produce el error esperado al llamar a la funci√≥n que hemos proporcionado y que puede intentar procesar; </li><li>  cuando ocurre un error inesperado durante la operaci√≥n que no previmos. </li></ul><br><p>  Y si los errores esperados est√°n al menos localizados, el resto puede suceder en casi todas partes.  Si no procesamos nada importante, simplemente podemos bloquearnos con un error (aunque este comportamiento no es suficiente y al menos debe agregar un mensaje al registro de errores).  Pero si en este momento el pago se est√° procesando y simplemente no puede caer, pero al menos necesita devolver una respuesta sobre la operaci√≥n fallida. </p><br><p>  Antes de ver formas de manejar errores, algunas palabras sobre Excepci√≥n (excepciones): </p><br><h3 id="exception">  Excepci√≥n </h3><br><img src="https://habrastorage.org/webt/hn/mx/yz/hnmxyzwyfbelfe32oqi1nyite4o.png"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuente</a> </p><br><p> La jerarqu√≠a de excepciones est√° bien descrita y puede encontrar mucha informaci√≥n al respecto, por lo que no tiene sentido describirla aqu√≠.  Lo que a veces todav√≠a causa una discusi√≥n acalorada se <code>checked</code> y se <code>unchecked</code> errores.  Y aunque la mayor√≠a acept√≥ excepciones <code>unchecked</code> como preferidas (en Kotlin no hay excepciones <code>checked</code> ), no todos est√°n de acuerdo con esto. </p><br><p>  Las excepciones <code>checked</code> realmente ten√≠an una buena intenci√≥n de convertirlas en un mecanismo conveniente para el manejo de errores, pero la realidad hizo sus ajustes, aunque la idea de introducir todas las excepciones que se pueden lanzar desde esta funci√≥n a la firma es comprensible y l√≥gica. </p><br><p>  Veamos un ejemplo.  Supongamos que tenemos una funci√≥n de <code>method</code> que puede lanzar una <code>PanicException</code> marcada.  Tal funci√≥n se ver√≠a as√≠: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> PanicException </span></span>{ }</code> </pre> <br><p>  Seg√∫n su descripci√≥n, est√° claro que puede lanzar una excepci√≥n y que solo puede haber una excepci√≥n.  ¬øSe ve bastante c√≥modo?  Y si bien tenemos un peque√±o programa, eso es todo.  Pero si el programa es un poco m√°s grande y hay m√°s funciones, aparecen algunos problemas. </p><br><p>  Las excepciones marcadas requieren la especificaci√≥n de que <strong>todas las posibles</strong> excepciones marcadas (o un antecesor com√∫n para ellas) se enumeran en la firma de la funci√≥n.  Por lo tanto, si tenemos una cadena de llamadas <code>a</code> -&gt; <code>b</code> -&gt; <code>c</code> y la funci√≥n m√°s anidada arroja alg√∫n tipo de excepci√≥n, entonces se debe poner para todos en la cadena.  Y si hay varias excepciones, entonces la funci√≥n superior de la firma debe tener una descripci√≥n de todas ellas. </p><br><p>  Entonces, a medida que el programa se vuelve m√°s complejo, este enfoque lleva al hecho de que las excepciones en la funci√≥n superior se colapsan gradualmente a antepasados ‚Äã‚Äãcomunes y finalmente se reducen a <code>Exception</code> .  Lo que en este formulario se vuelve similar a una excepci√≥n <code>unchecked</code> y niega todas las ventajas de las excepciones marcadas. </p><br><p>  Y dado que el programa, como organismo vivo, cambia y evoluciona constantemente, es casi imposible prever de antemano qu√© excepciones pueden surgir en √©l.  Y como resultado, la situaci√≥n es que cuando agregamos una nueva funci√≥n con una nueva excepci√≥n, tenemos que pasar por toda la cadena de su uso y cambiar las firmas de todas las funciones.  De acuerdo, esta no es la tarea m√°s agradable (incluso teniendo en cuenta que los IDE modernos hacen esto por nosotros). </p><br><p>  Pero el √∫ltimo, y probablemente el mayor clavo en las excepciones marcadas "condujo" lambdas de Java 8. No hay excepciones marcadas ¬Ø_ („ÉÑ) _ / ¬Ø en su firma (ya que cualquier funci√≥n se puede llamar en lambda, con cualquier firma), por lo que cualquier llamada de funci√≥n con una excepci√≥n marcada de lambda obliga a que se envuelva en un reenv√≠o de excepci√≥n como desmarcado: </p><br><pre> <code class="java hljs">Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>).forEach(item -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { functionWithCheckedException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"rethrow"</span></span>, e); } });</code> </pre> <br><p>  Afortunadamente, en la especificaci√≥n JVM no hay excepciones comprobadas, por lo que en Kotlin no puede envolver nada en el mismo lambda, sino simplemente llamar a la funci√≥n deseada. </p><br><div class="spoiler">  <b class="spoiler_title">aunque a veces ...</b> <div class="spoiler_text"><p>  Aunque esto a veces conduce a consecuencias inesperadas, como, por ejemplo, el funcionamiento incorrecto de <code>@Transactional</code> en <code>Spring Framework</code> , que "espera" solo excepciones sin <code>unckecked</code> .  Pero esto es m√°s una caracter√≠stica del marco, y tal vez este comportamiento en la primavera cambiar√° en el pr√≥ximo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema de github</a> . </p></div></div><br><p>  Las excepciones en s√≠ mismas son objetos especiales.  Adem√°s del hecho de que pueden "lanzarse" a trav√©s de m√©todos, tambi√©n recopilan stacktrace en la creaci√≥n.  Luego, esta caracter√≠stica ayuda con el an√°lisis de problemas y la b√∫squeda de errores, pero tambi√©n puede generar algunos problemas de rendimiento si la l√≥gica de la aplicaci√≥n est√° fuertemente ligada a las excepciones lanzadas.  Como se muestra en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> , deshabilitar el ensamblaje stacktrace puede aumentar significativamente su rendimiento en este caso, ¬°pero debe recurrir a √©l solo en casos excepcionales cuando realmente sea necesario! </p><br><h3 id="obrabotka-oshibok">  Manejo de errores </h3><br><p>  Lo principal que debe hacer con los errores "inesperados" es encontrar un lugar donde pueda interceptarlos.  En los lenguajes JVM, este puede ser un punto de creaci√≥n de flujo o un punto de filtro / entrada para el m√©todo http, donde puede poner un try-catch con el manejo de errores <code>unchecked</code> .  Si usa alg√∫n marco, lo m√°s probable es que ya tenga la capacidad de crear controladores de errores comunes, como, por ejemplo, en Spring Framework, puede usar m√©todos con la anotaci√≥n <code>@ExceptionHandler</code> . </p><br><p>  Puede "aumentar" las excepciones a estos puntos de procesamiento central que no queremos manejar en lugares espec√≠ficos lanzando las mismas excepciones sin <code>unckecked</code> (cuando, por ejemplo, no sabemos qu√© hacer en un lugar en particular y c√≥mo manejar el error).  Pero este m√©todo no siempre es adecuado, porque a veces puede requerir manejar el error en su lugar, y debe verificar que todos los lugares de las llamadas a funciones se procesen correctamente.  Considere formas de hacer esto. </p><br><ol><li><p>  Todav√≠a usa excepciones y el mismo try-catch: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { sum = calculateSum(a,b); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { sum = -<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  El principal inconveniente es que podemos "olvidar" envolverlo en un try-catch en el lugar de la llamada y omitir el intento de procesarlo en su lugar, por lo que la excepci√≥n se lanzar√° al punto com√∫n de procesamiento de errores.  Aqu√≠ podemos ir a excepciones <code>checked</code> (para Java), pero luego obtendremos todas las desventajas mencionadas anteriormente.  Este enfoque es conveniente de usar si no siempre se requiere el manejo de errores, pero en casos raros es necesario. </p><br></li><li><p>  Use la clase sellada como resultado de una llamada (Kotlin). <br>  En Kotlin, puede limitar el n√∫mero de herederos de clase, hacerlos computables en la etapa de compilaci√≥n; esto permite que el compilador verifique que todas las opciones posibles se analicen en el c√≥digo.  En Java, puede crear una interfaz com√∫n y varios descendientes, sin embargo, perder las comprobaciones de nivel de compilaci√≥n. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuccessResult</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>): Result() <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExceptionResult</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exception: Exception): Result() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = calculateSum(a,b)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SuccessResult -&gt; result.value <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ExceptionResult -&gt; { result.exception.printStackTrace() -<span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre> <br><p>  Aqu√≠ obtenemos algo as√≠ como un <code>golang</code> error de <code>golang</code> cuando necesita verificar expl√≠citamente los valores resultantes (o ignorar expl√≠citamente).  El enfoque es bastante pr√°ctico y especialmente conveniente cuando necesita arrojar muchos par√°metros en cada situaci√≥n.  La clase de <code>Result</code> se puede ampliar con varios m√©todos que facilitan la obtenci√≥n del resultado con una excepci√≥n lanzada arriba, si la hay (es decir, no necesitamos manejar el error en el lugar de la llamada).  El principal inconveniente ser√° solo la creaci√≥n de objetos superfluos intermedios (y una entrada un poco m√°s detallada), pero tambi√©n se puede eliminar usando clases en <code>inline</code> (si un argumento es suficiente para nosotros).  y, como ejemplo particular, hay una clase <code>Result</code> de Kotlin.  Es cierto que es solo para uso interno, ya que  en el futuro, su implementaci√≥n puede cambiar ligeramente, pero si desea usarlo, puede agregar el indicador de compilaci√≥n <code>-Xallow-result-return-type</code> . </p><br></li><li><p>  Como uno de los tipos posibles de la reivindicaci√≥n 2, el uso de un tipo de programaci√≥n funcional <code>Either</code> , que puede ser un resultado o un error.  El tipo en s√≠ puede ser una clase <code>sealed</code> o una clase en <code>inline</code> .  A continuaci√≥n se muestra un ejemplo del uso de la implementaci√≥n de la biblioteca de <code>arrow</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = calculateSum(a,b)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Either.Left -&gt; { result.a.printStackTrace() -<span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Either.Right -&gt; result.b }</code> </pre> <br><p>  <code>Either</code> m√°s adecuado para aquellos que aman un enfoque funcional y que les gusta construir cadenas de llamadas. </p><br></li><li><p>  Use <code>Option</code> o tipo <code>nullable</code> de Kotlin: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = calculateSum(a,b) ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"some exception"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>?</code> </pre> <br><p>  Este enfoque es adecuado si la causa del error no es muy importante y solo es una.  Una respuesta vac√≠a se considera un error y se arroja m√°s alto.  El registro m√°s corto, sin crear objetos adicionales, pero este enfoque no siempre se puede aplicar. </p><br></li><li><p>  Similar al elemento 4, solo utiliza un valor de c√≥digo duro como marcador de error: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = calculateSum(a,b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RuntimeException(‚Äúerror‚Äù) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span></code> </pre> <br><p>  Este es probablemente el enfoque de manejo de errores m√°s antiguo que regres√≥ de <code>C</code> (o incluso de Algol).  No hay gastos generales, solo un c√≥digo que no est√° completamente claro (junto con restricciones en la elecci√≥n del resultado), pero, a diferencia del p√°rrafo 4, es posible hacer varios c√≥digos de error si se requiere m√°s de una posible excepci√≥n. </p><br></li></ol><br><h3 id="vyvody">  Conclusiones </h3><br><p>  Todos los enfoques se pueden combinar seg√∫n la situaci√≥n, y ninguno de ellos es adecuado en todos los casos. </p><br><p>  Entonces, por ejemplo, puede lograr un enfoque de <code>golang</code> para los errores usando clases <code>sealed</code> , y donde no sea muy conveniente, pasar a errores <code>unchecked</code> . </p><br><p>  O, en la mayor√≠a de los lugares, <code>nullable</code> tipo <code>nullable</code> como marcador de que no fue posible calcular el valor u obtenerlo de alguna parte (por ejemplo, como un indicador de que el valor no se encontr√≥ en la base de datos). </p><br><p>  Y si tiene un c√≥digo completamente funcional junto con la <code>arrow</code> o alguna otra biblioteca similar, lo m√°s probable es que use <code>Either</code> . </p><br><p>  En cuanto a los servidores http, es m√°s f√°cil elevar todos los errores a puntos centrales y solo en algunos lugares se combina el enfoque <code>nullable</code> con clases <code>sealed</code> . </p><br><p>  ¬øMe alegrar√° ver en los comentarios que est√° utilizando esto, o tal vez hay otros m√©todos convenientes para el manejo de errores? </p><br><p>  ¬°Y gracias a todos los que leyeron hasta el final! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471766/">https://habr.com/ru/post/471766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471748/index.html">Optimizaci√≥n de farmacia: lo que hicimos con las matem√°ticas</a></li>
<li><a href="../471750/index.html">Gesti√≥n de acceso privilegiado como tarea prioritaria en seguridad de la informaci√≥n (por ejemplo, Fudo PAM)</a></li>
<li><a href="../471756/index.html">C√≥mo se inicia el servidor</a></li>
<li><a href="../471758/index.html">¬øC√≥mo traducir texto a un idioma diferente?</a></li>
<li><a href="../471760/index.html">Edward Snowden: El campo de batalla - Cifrado</a></li>
<li><a href="../471770/index.html">Conozca las herramientas de Big Data: compatibilidad con port√°tiles Spark y Zeppelin en IntelliJ IDEA</a></li>
<li><a href="../471772/index.html">Herramientas para iniciar y desarrollar aplicaciones Java, compilaci√≥n, ejecuci√≥n en la JVM</a></li>
<li><a href="../471774/index.html">Android Camera2 API de la tetera, parte 2, escribir un video</a></li>
<li><a href="../471776/index.html">Laravel: explica los conceptos b√°sicos. Segunda parte: pr√°ctica</a></li>
<li><a href="../471778/index.html">Rompiendo Micosoft Lunix en HackQuest 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>