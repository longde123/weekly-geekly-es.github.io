<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☢️ 🐉 🐣 Sistem perlindungan kebocoran untuk mesin cuci ☦️ 🚴🏻 🍊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Saya pikir setiap rumah memiliki mesin cuci. Biasanya terhubung ke pasokan air melalui selang fleksibel. Tetapi gangguan besar dapat ter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistem perlindungan kebocoran untuk mesin cuci</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472296/"><img src="https://habrastorage.org/webt/7q/2r/xp/7q2rxpr6f9jntwgc-3ai-qwqglo.jpeg"><br><br><h2>  Pendahuluan </h2><br>  Saya pikir setiap rumah memiliki mesin cuci.  Biasanya terhubung ke pasokan air melalui selang fleksibel.  Tetapi gangguan besar dapat terjadi dengan selang: kadang-kadang meledak, yang akan menyebabkan banjir baik di apartemen Anda dan tetangga Anda.  Oleh karena itu, mesin cuci terhubung ke pasokan air melalui faucet khusus, yang harus dibuka sebelum dicuci dan ditutup sesudahnya.  Saya tidak tahu tentang Anda, tetapi saya memiliki bangau ini di tempat yang sangat tidak nyaman.  Ya, dan saya lebih memilih untuk mulai mencuci sebelum berangkat kerja, sehingga sebagian besar selang di bawah tekanan dan bisa pecah pada saat saya tidak di rumah.  Akan lebih bagus jika crane membuka dan menutup sendiri pada waktu yang tepat! <br><br>  Gagasan itu bagi saya tampaknya cukup mampu dan saya memutuskan untuk mengimplementasikannya: pada mikrokontroler dan dengan katup bermotor. <br><a name="habracut"></a><br>  Untuk memulai, saya merumuskan persyaratan untuk sistem yang dikembangkan: <br><br><ul><li>  memantau keadaan mesin cuci: air terbuka pada awal pencucian dan tutup pada akhirnya; </li><li>  kemampuan untuk mengontrol katup secara manual; </li><li>  operasi baterai dan menutup katup jika baterai habis; </li><li>  Kehadiran sensor kebocoran: tutup katup jika kebocoran terdeteksi. </li></ul><br>  Lalu ia menemukan bagian mana yang terdiri dari: monitor yang dipasang di mesin cuci dan pengontrol yang menerima sinyal dari monitor dan mengendalikan katup bermotor.  Komunikasi antara monitor dan pengontrol adalah melalui saluran radio satu arah. <br><br>  Tampaknya ini sudah cukup untuk tugas teknis.  Ayo mulai! <br><br><h2>  Pemilihan MCU </h2><br>  Karena seluruh sistem terdiri dari dua perangkat, maka harus ada dua mikrokontroler.  Saya mencari-cari nyali dan menemukan dua Atmega8: satu di paket DIP, dan yang lain di TQFP.  Yang di DIP - pergi ke monitor, dan TQFP - ke controller.  Kemudian ternyata firmware controller yang terlalu banyak tidak lagi cocok dengan Atmega8 8KB, jadi saya harus meng-upgrade ke Atmega328 - analog yang lengkap, tetapi sekarang ada memori empat kali lebih banyak untuk program ini. <br>  Ngomong-ngomong, salah satu motif saya untuk melakukan proyek seperti itu adalah pembuangan sampah elektronik, yang telah saya kumpulkan selama bertahun-tahun.  Benar, pada akhir proyek, sampah tidak menjadi lebih kecil.  Itu menjadi lebih besar! <br><br><h2>  Bagian Satu  Monitor </h2><br><h3>  Interaksi dengan mesin cuci </h3><br>  Masalah pertama: bagaimana menentukan apa yang sedang dilakukan mesin cuci sekarang?  Pada awal proyek, bagian tugas ini tampak sangat sederhana bagi saya.  Yang harus dilakukan hanyalah menentukan saat-saat awal dan akhir pencucian.  Di panel depan mesin ada LED yang menyala dan padam tepat saat dibutuhkan.  Saya berharap untuk mensolder GPIO dengan kaki mikrokontroler, jadi selama durasi debugging, saya cukup meniru acara yang diperlukan pada monitor dengan tombol.  Saya menekan tombol - LED menyala, pencucian dimulai.  Lepaskan - kebalikannya benar.  Namun, setelah parsing mesin cuci, ternyata LED ini adalah bagian dari tampilan dinamis, dan, sayangnya, tidak mudah untuk menentukan apakah itu hidup atau mati. <br><br>  Menghidupkan panel kontrol di tangan saya (beberapa hari), saya menemukan bahwa itu diimplementasikan pada pengontrol PIC.  Selain itu, terhubung ke papan utama dengan kaki merespons ke perangkat keras I2C.  Ya, saya pikir, Anda bisa mengendus bus I2C dan dengan demikian menentukan apa yang harus dilakukan mesin cuci sekarang.  Saya menemukan kode sniffer I2C untuk Atmega di Internet.  Tentu saja, saya harus memainkan sesuatu. <br><br>  Terus terang: Saya tidak bisa melihat protokol sepenuhnya (dan saya tidak mencobanya terlalu banyak), tetapi ternyata untuk menentukan pola awal dan akhir mencuci (serta menyalakan dan mematikan daya) dengan cukup akurat.  Butuh waktu sekitar seminggu. <br><br>  Model: <b>Permen GC4 1072 D.</b>  Komputer secara berkala mengirimkan serangkaian urutan lima byte ke unit display.  Empat urutan pertama dalam format: <br><br> <code>12 A7 00 – NN – X0 X1 X2 X3 X4 X5 X6 X7 – CS</code> <br>  di mana: 12 A7 00 - header, NN - nomor urut, X [0..7] - 8 byte data, CS - checksum.  Urutan kelima adalah beberapa sampah ukuran variabel, esensi yang bagi saya tetap menjadi misteri. <br><br>  Saya berhasil memecahkan pola berikut: <br><br>  <b>Nyalakan</b> <br><br> <code>12 A7 00 – 01 – X0 X1 X2 X3 X4 X5 X6 X7 – CS <br> 12 A7 00 – 02 – X0 X1 X2 X3 X4 X5 X6 X7 – CS</code> <br>  di mana X [0..7] setidaknya satu tidak sama dengan 0 <br><br>  <b>MULAI</b> <br><br> <code>12 A7 00 – 03 – X0 X1 X2 X3 01 01 01 01 – CS</code> <br>  di mana X [0..3] adalah angka apa pun <br><br>  <b>BERHENTI</b> <br><br> <code>12 A7 00 – 03 – X0 X1 X2 X3 00 00 00 00 – CS</code> <br>  di mana X [0..3] adalah angka apa pun <br><br>  Dapat dilihat bahwa ini bukan urutan yang ketat, yaitu template, jadi saya harus mengotak-atik parser. <br><br>  Logika kerjanya kira-kira sebagai berikut: jika kita mendapatkan urutan POWER ON, tetapi tidak ada MULAI, maka kita mulai menyiarkan paket dengan status 0. Jika urutan MULAI muncul, ubah status menjadi 1. Dalam kasus lain, tidak ada helm. <br><br>  Kami akan berbicara tentang paket dan status selanjutnya. <br><br>  Ini lucu, tetapi ketika saya memata-matai paket I2C, saya tidak memiliki kesempatan untuk terhubung ke komputer sniffer.  Saya menggunakan powerbank'om Raspberry Pi ini, yang memiliki case aluminium.  Jadi, segera setelah bangunan ini bersentuhan dengan kasing mesin cuci, sebuah RCD ditarik keluar di perisai, lampu padam di apartemen dan saya mulai mencari senter dengan matyuki.  :) Mengapa sampah seperti itu terjadi - masih menjadi misteri bagi saya. <br><br><h3>  Saluran radio </h3><br>  Awalnya, saya tidak ingin kabel tambahan datang dari mesin cuci.  Artinya, koneksi itu seharusnya nirkabel.  Dari sini, ada tiga solusi yang mungkin untuk masalah ini: WiFi, Bluetooth dan modul RF untuk Arduino.  Saya memilih yang terakhir dengan memilih modul FS1000A. <br><br>  Tentu saja, di Habré akan ada banyak orang yang mencela saya dengan pilihan ini.  Mereka akan mengisyaratkan bahwa pada Ali-Express dimungkinkan untuk membeli modul ESP dengan WiFi penuh dengan harga murah.  Tapi saya pikir ini akan sangat menyulitkan proyek, dan memutuskan untuk bertindak lebih sederhana. <br><br>  Seperti yang Anda ketahui, modul RF FS1000A tidak dapat dihubungkan langsung ke antarmuka RS232: urutan panjang nol atau yang merusak sinkronisasi penerima.  Pustaka VirtualWire dibuat untuk mengatasi masalah ini.  Namun, perpustakaan ini ditulis untuk Arduino, dan program saya secara eksklusif asli di bawah Atmega di C. Untungnya, kode untuk Arduino sangat mirip dengan C murni, dan dengan sedikit modifikasi, perpustakaan berhasil dipindahkan. <br><br>  Ada beberapa kesulitan: pada awalnya, paket tidak ingin menjangkau penerima.  Saya menyalahkan tangan saya yang bengkok untuk semuanya, tetapi dengan langsung menghubungkan terminal penerima dan pengendali pemancar, saya yakin bahwa semuanya berfungsi di bagian perangkat lunak.  Pemancar yang dipesan dari Cina ternyata rusak.  Saya harus membeli kit lain.  Kemudian saya memperbaiki yang lama dan sekarang saya memiliki dua set pemancar-penerima.  Ingat apa yang saya tulis tentang mengurangi sampah? <br><br>  Data telah dikirim, tetapi apa sebenarnya yang terkandung dalam data ini?  Inilah paket yang ditransmisikan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dst; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> src; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WMP_MSG_STATUS_ALIVE _BV(0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WMP_MSG_STATUS_VALVE _BV(1) uint8_t status; } wmp_msg_t; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WMP_ADDR_MONITOR 0x4d504d57 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WMP_ADDR_CONTROLLER 0x43504d57</span></span></code> </pre><br>  Dua kata ganda pertama adalah alamat fisik penerima dan pemancar.  Dalam kasus saya, mereka benar-benar diperbaiki: 0x43504d57 - penerima (pengontrol) dan 0x4d504d57 - pemancar (monitor).  Sebenarnya, 8 byte pertama adalah tanda tangan paket ini.  Informasi penting hanya ditemukan di byte terakhir - bendera bit.  Set nol bit dari bendera ini berarti monitor dihidupkan dan berfungsi - harus selalu 1. Bit pertama adalah status katup: 0 - katup harus ditutup, 1 - terbuka.  Itu saja. <br><br>  Diasumsikan bahwa monitor secara berkala harus mengirim paket ke pengontrol, mengonfirmasi operasinya dan kemudahan servis saluran data.  Jika terjadi kehilangan saluran komunikasi, pengontrol harus menutup katup secara darurat. <br><br>  Perpustakaan VirtualWire memantau integritas data yang dikirimkan menggunakan CRC32.  Saya tidak perlu melakukan upaya tambahan ke arah ini.  Cantik! <br><br><h3>  Konstruksi </h3><br>  Secara struktural, monitor dibuat dalam bentuk papan kecil, yang dilem pada lem panas "Paman Liao ingus" di dalam panel depan mesin cuci. Dengan konektor, papan terhubung ke celah antara komputer dan papan display.  Mesin itu sendiri belum mengalami modifikasi: setiap saat dapat dibawa ke keadaan semula. <br><br><h2>  Bagian Dua  Pengendali </h2><br><h3>  Saluran radio </h3><br>  Semuanya sederhana di sini: penerima kit FS1000A dan penerima perpustakaan VirtualWire diinstal.  Paket diuraikan dan statusnya ditransmisikan ke output.  Penerima VirtualWire menempati TIMER1 di mikrokontroler. <br><br><h3>  Kontrol katup </h3><br>  Di toko online China, katup bermotor 3/4 ”dipilih dengan catu daya 5 volt dan dengan sensor terminal yang terhubung ke kabel.  Katup ini dipasang antara katup bola dan selang mesin cuci.  Untuk mengontrol katup, di situs Cina yang sama, driver motor stepper daya rendah dipesan pada driver L9110.  Saya menghubungkannya ke controller sebagai berikut: <br><br><img src="https://habrastorage.org/webt/0a/dr/h9/0adrh9lsveasvy1hpqc6ogngsac.png"><br><br>  Dari sudut pandang perangkat lunak, tidak ada kesulitan khusus: oleh input VALVE_CLOSE dan VALVE_OPEN kami menentukan status katup saat ini.  Jika status ini perlu diubah, hidupkan motor untuk membuka atau menutup dan menunggu hingga 0 logis didirikan pada input yang sesuai.Namun, karena membuka atau menutup membutuhkan waktu, saya ingin tidak kehilangan kendali atas semuanya pada saat itu perangkat.  Oleh karena itu, pada pengatur waktu Atmega, penjadwal primitif dibangun dan kontrol katup dipindahkan ke tugas khusus.  Pada saat yang sama, modul perangkat lunak WatchDog khusus mengukur waktu yang dibutuhkan katup untuk beralih, dan jika terlalu lama, sinyal tentang kerusakannya dihasilkan.  Kemudian, hal-hal menarik lainnya digantung pada penjadwal ini, seperti lampu LED berkedip dan polling sensor kebocoran.  Tetapi lebih lanjut tentang itu nanti. <br><br>  Selain itu, LED status tiga warna dan sakelar sakelar kontrol manual tiga posisi milik sirkuit kontrol katup.  Di posisi tengah sakelar sakelar, kontrol otomatis diaktifkan sesuai dengan sinyal dari mesin cuci dan sensor lainnya.  Jika terjadi kerusakan katup, warna merah dan hijau secara bergantian menyala. <br><br><h3>  Indikasi LED dan suara </h3><br>  Dengan LED, semuanya sederhana: mereka melekat langsung ke port I / O melalui resistor yang membatasi.  Arus di sana tidak besar, dan port-port di Atmega cukup kuat. <br><br>  Tapi suaranya harus mengotak-atik.  Pertama, saya tidak menemukan emitor piezo yang besar dan keras.  Tampaknya orang-orang seperti itu ada di alam, tetapi begitu saya menghadiri pembelian, ternyata pilihannya tidak besar sama sekali.  Hal paling keren yang saya dapat terdengar sangat sunyi.  Saya harus menjelajahi Internet untuk resep. <br><br>  Saya menetap di sirkuit dengan satu transistor dan autotransformer, yang mengayunkan tegangan suara dari 5V ke 50V.  Dan itu ternyata relatif keras.  Tidak sama sekali frekuensi, tentu saja, tetapi lebih dekat dengan resonansi. <br><br>  Hanya selama generasi suara kecerahan kecerahan LED (kusen dengan daya) sedikit menurun, tetapi mikrokontroler tidak membeku dan program kontrol tidak pecah.  Saya pikir ini adalah fitur tata letak debug dan semuanya akan berfungsi dengan baik di papan final.  Saya salah - itu tidak menjadi lebih baik.  Lebih buruk, bagaimanapun juga. <br><br><img src="https://habrastorage.org/webt/w8/ca/pb/w8capblzyb0abagztoygcputhsi.png"><br><br>  Masalah lain adalah saya kehabisan timer dan di latar belakang saya tidak bisa menghasilkan suara.  Saya harus meminta periode mencicit dengan tidur.  Jadi, selama generasi suara Atmega dapat melakukan apa-apa selain interupsi, juga harus dinonaktifkan, jika nada tidak jelas.  Tetapi ini ternyata tidak terlalu menakutkan karena output suara tidak bersinggungan dengan tugas-tugas penting lainnya, seperti mengendalikan katup atau menerima data melalui radio. <br><br>  Selanjutnya, saya memilih konstanta tidur sehingga mereka sesuai dengan catatan dan muncul dengan beberapa kombinasi yang kurang lebih harmonis: "katup terbuka", "katup ditutup", "mencuci selesai" dan "kebocoran".  Saya akan memberi tahu Anda secara terpisah tentang sinyal "selesai mencuci" nanti. <br><br><h3>  Detektor kebocoran </h3><br>  Detektor kebocoran awalnya direncanakan untuk dilakukan pada ADC built-in mikrokontroler.  Eksperimen telah menunjukkan bahwa ini adalah solusi yang berfungsi dengan baik.  Namun, saya bertemu bahwa kadang-kadang kapasitor ditambahkan ke sensor dengan kontak sehingga terhubung dan jika tidak ada kerusakan pada kabel di suatu tempat.  Anda dapat memeriksa keberadaan kapasitor (dan mengukur kapasitansinya) menggunakan: rantai RC, komparator, dan jam.  Sebagai pembanding, input GPIO konvensional digunakan (ini juga merupakan input logis dan beralih dari 0 ke 1 pada tegangan tertentu), dan ada cukup waktu dalam mikrokontroler. <br><br><img src="https://habrastorage.org/webt/sh/um/rn/shumrnvjljzhpc_m7fdyye9ugwi.png"><br><br>  Diasumsikan bahwa dari waktu ke waktu saya akan memeriksa keberadaan kapasitor di telepon, dan kemudian menggunakan ADC untuk menentukan apakah kontak sensor ada di dalam air.  Ternyata, itu hanya cukup untuk mengukur kapasitansi kapasitor: jika Anda menurunkannya ke dalam air, maka waktu pengisian akan meningkat, dan debit akan berkurang.  Selain itu, waktu akan berubah dengan jumlah yang cukup sehingga dapat dideteksi dengan penuh percaya diri. <br><br>  Untuk sistem saya, saya memilih untuk mengukur waktu pengisian: jika kapasitor tidak terhubung, maka nol, jika kering itu relatif kecil, dan jika dalam air, maka waktu pengisian jauh lebih lama.  Nilai pastinya ditentukan menggunakan cawan dengan air dan serangkaian percobaan. <br><br>  Detektor kebocoran memiliki LED indikator merah sendiri.  Jika sensor tidak terdeteksi, sensor akan menyala dan perintah untuk menutup katup ditransmisikan ke udara.  Seseorang hanya perlu memulihkan komunikasi dengan sensor, LED mati dan katup dapat dibuka (jika saja mesin dalam keadaan mencuci, tentu saja).  Hal lain adalah jika sensor mendeteksi air.  Dalam hal ini, indikator mulai berkedip, suara terputus-putus yang buruk terdengar, dan katup ditutup secara paksa.  Tetapi yang paling penting, controller tidak pernah meninggalkan kondisi ini.  Kebocoran dianggap sebagai kecelakaan serius, dan persediaan air tidak akan dilanjutkan sampai Anda dengan paksa me-restart perangkat. <br><br><h3>  Nutrisi </h3><br>  Makanan adalah bagian yang paling tidak bisa saya mengerti dalam proyek ini.  Jika saya sedikit berpengalaman dalam sirkuit digital, maka dalam analog, secara halus - tidak benar-benar.  Tapi, terima kasih kepada orang Cina: Saya bisa membeli modul yang sudah jadi untuk konverter DC-DC dengan pengontrol pengisian daya baterai, dan berdasarkan itu saya bisa memikirkan sesuatu yang bisa diterapkan. <br><br>  Sejak awal, sudah direncanakan untuk membuat perangkat swadaya, sehingga dalam kasus pemadaman listrik, pastikan bahwa air akan dimatikan.  Selain itu, saya memiliki catu daya 9V yang perlu dipasang di suatu tempat.  Secara total, hasil pengantar adalah sebagai berikut: <br><br><ul><li>  9V berasal dari jaringan; </li><li>  3.4 ~ 3.7V berasal dari baterai; </li><li>  untuk mengisi baterai Anda membutuhkan 5V; </li><li>  5V diperlukan untuk memberi daya pada logika dan rangkaian daya; </li><li>  jika tegangan listrik gagal, alihkan daya ke baterai; </li><li>  perlu untuk mengirimkan sinyal pengisian baterai, tegangan pada baterai dan sinyal operasi dari jaringan ke pengontrol. </li></ul><br>  Diagram blok ternyata seperti pada gambar. <br><br><img src="https://habrastorage.org/webt/7g/ma/5l/7gma5lv_yub5aunjhing_cbnmjw.jpeg"><br><br>  Dua dioda Schottky digunakan sebagai elemen switching.  Pengontrol muatan memiliki dua LED: CHARGE dan STANDBY.  Sinyal dari yang pertama terhubung ke port GPIO controller sehingga monitor bisa tahu bahwa baterai sedang diisi.  Juga, sinyal dari konverter DC-DC pertama diterapkan ke port mikrokontroler untuk menentukan apakah perangkat beroperasi pada listrik atau baterai.  Untuk mengontrol level pengisian, tegangan dari baterai disuplai ke ADC controller.  Jika voltase terlalu rendah, monitor menutup katup dan beralih ke mode siaga: itu tidak merespons perintah apa pun sampai voltase listrik muncul. <br><br>  Sayangnya, ada beberapa kusen di sini: karena suatu alasan, motor katup mengambil sebagian energi dari baterai.  Rupanya, saya membuat kesalahan dengan kekuatan konverter jaringan DC / DC atau dengan ketebalan trek daya di papan tulis.  Akibatnya: setelah membuka atau menutup katup, baterai mulai mengisi. <br><br>  Untuk memantau status daya ada LED dua warna khusus.  Jika berwarna hijau, maka perangkat beroperasi di jaringan.  Jika merah - maka dari baterai.  Jika berwarna hijau, tetapi merah berkedip, baterai sedang diisi. <br><br><h3>  Logika kerja </h3><br>  Ya, kami memiliki semua perangkat keras dan dukungan perangkat lunaknya, sekarang kami harus membuat semua ini saling berinteraksi.  Awalnya, saya melihat implementasi logika kerja dalam bentuk loop besar (apa yang disebut loop utama) dengan sekelompok ifs di dalamnya. <br><br>  Dalam prosesnya, ada kebutuhan untuk penjadwal tugas untuk tindakan sederhana seperti: mengedipkan LED, menyurvei sensor kebocoran, melacak waktu penggantian katup dan kontrol daya, yang saya posting di TIMER0.  Penjadwal sendiri tidak memulai fungsi yang terkait dengan tugas, tetapi hanya mengatur bit sinkronisasi ke satu di deskriptor yang terkait dengan tugas.  Tugas itu masih dilakukan dalam siklus utama, kami berhasil menyingkirkan interval waktu pelacakan, yang membuatnya sangat sederhana. <br><br>  Dari kebun binatang ifs, yang memeriksa status berbagai subsistem pengendali dan membuat keputusan: perlu menolak untuk membuka atau menutup katup.  Sangat sulit untuk men-debug ini dan sangat mudah untuk bingung.  Sebaliknya, saya menyukai ide dari buku kuno D. Hazerman: "Cara membuat robot sendiri."  Buku ini menyarankan agar setiap modul menghasilkan sinyal kontrolnya sendiri: maju, mundur, rotasi, dll. Selanjutnya, hanya satu yang berasal dari blok dengan prioritas lebih tinggi yang dipilih dari sinyal-sinyal ini.  Saya melakukan hal yang sama. <br><br>  Saya memprioritaskan blok sebagai berikut: <br><br><ol><li>  Blok bocor </li><li>  Unit Kontrol Baterai </li><li>  Unit kontrol katup manual </li><li>  Unit kontrol katup kontrol radio </li><li>  Katup pengatur waktu blok WatchDog </li></ol><br>  Setiap blok menghasilkan tiga perintah: TIDAK DIKENAL, BUKA dan TUTUP. <br><br>  Blok kebocoran memiliki prioritas tertinggi, tetapi tidak memiliki perintah OPEN, tetapi perintah CLOSE-nya pasti menutup katup, tidak peduli apa kata blok lainnya.  Unit kontrol manual dapat mengganggu sinyal unit saluran radio, yang memungkinkan Anda untuk mengontrol katup terlepas dari apa yang ditunjukkan mesin cuci kepada kami.  Baik dan sebagainya.  Artinya, struktur hierarki logis telah muncul yang mudah dipahami dan didebug. <br><br>  Sekarang, mari kita kembali ke sinyal: "mencuci selesai."  Sayangnya, model mesin cuci saya tidak memiliki kesempatan untuk menginformasikan tentang akhir pekerjaannya dengan bantuan suara: Insinyur permen tidak memberikan kesempatan seperti itu.  Di sisi lain, saya memiliki perangkat tambahan yang memiliki emitor piezo dan setiap saat tahu apa yang dilakukan mesin cuci.  Mengapa tidak membuatnya melaporkan akhir pencucian?  Baiklah, mari kita buat pengontrolnya keras dan tidak enak (pada frekuensi resonansi) mencicit ketika katup menutup sinyal.  Tambahkan lagi interval jaga lima menit agar tidak mendengarkan derit ini setiap kali Anda menghidupkan dan mematikan mesin.  Katup terbuka selama lima menit - pencucian sudah pasti dimulai. <br><br><h2>  Hasil </h2><br>  Pembangunan membutuhkan waktu sekitar setahun untuk pekerjaan yang tidak terburu-buru (sangat tidak terburu-buru).  Perangkat telah berfungsi selama dua tahun sekarang.  Dalam operasi, itu terbukti cukup memuaskan.  Tapi bukan tanpa cacat.  Mari kita daftarkan mereka dengan jujur: <br><br><ol><li>  Saya mengacaukan sesuatu dengan kekuatan: motor katup mengambil bagian dari energi dari baterai. </li><li>  Rangkaian pembangkit suara menghasilkan tegangan suplai.  Anda dapat dengan jelas melihat bagaimana LED mengubah kecerahan saat suara dimainkan. </li><li>  Saluran radio tidak terlalu stabil.  Pertama, sinyal menghilang jika seseorang berdiri dekat dengan mesin cuci.  Dan kedua, terkadang sinyal memburuk dengan sendirinya.  Dalam hal ini, Anda harus menggunakan sakelar sakelar manual, tetapi ini jarang terjadi. </li><li>  Unit monitor di mesin cuci tergantung beberapa kali.  Blok pengontrol tidak menggantung sekali pun. </li><li>  Suara dari emitor piezo sangat tenggelam di dalam case.  Saya mengebor sebuah lubang di koprus: itu menjadi lebih baik, tetapi tidak benar-benar.  Saya harus menyolder emitor dari papan dan menempelkannya ke kasing, tepat di seberang lubang. </li></ol><br>  Secara umum, saya menganggap pengembangannya berhasil dan sangat bermanfaat.  Saya menyalakan mesin di pagi hari dan dengan tenang berangkat kerja: Saya tahu bahwa pada saat yang tepat keran pasokan air akan dimatikan. <br><br>  Arsip dengan file proyek dapat diunduh di <a href="">sini</a> . <br><br><h3>  Beberapa gambar. </h3><br><div class="spoiler">  <b class="spoiler_title">Tampilan atas dengan penutup atas dihapus</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pk/ac/1q/pkac1q7wwkmwbptyd814mobigx4.jpeg"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Tampak belakang, dari sisi konektor</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/-z/3g/zq/-z3gzqv3s-dwhfuvlco9jkkqbcm.jpeg"><br></div></div><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/kc/cv/sx/kccvsxlyr0qtrtirqf_c5hthamq.jpeg"><br></div></div><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bg/kh/yy/bgkhyyih1i083nb9omlxrqxo9be.jpeg"><br></div></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/p5/qu/2y/p5qu2ygeapyr_ivwdguhkjmkcxs.jpeg"><br></div></div><br> <i>  <br> -  «»</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472296/">https://habr.com/ru/post/id472296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472280/index.html">Tugas menentukan keberadaan telapak tangan pada pemindai vena</a></li>
<li><a href="../id472288/index.html">9 ekstensi browser yang berguna untuk pengembang (daftar untuk 2020)</a></li>
<li><a href="../id472290/index.html">Struktur vs. Kelas</a></li>
<li><a href="../id472292/index.html">Pemblokiran Konten: Panggung Dunia</a></li>
<li><a href="../id472294/index.html">Buat game dan video di YouTube. Percobaan interaksi saya dan penghasilan dari ini</a></li>
<li><a href="../id472298/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 385 (14-20 Oktober 2019)</a></li>
<li><a href="../id472300/index.html">Stochastic gradient descent (SGD) untuk fungsi kehilangan logaritmik (LogLoss) dalam masalah klasifikasi biner</a></li>
<li><a href="../id472304/index.html">NASA merekrut insinyur untuk mengembangkan robot humanoid generasi berikutnya</a></li>
<li><a href="../id472306/index.html">PHP Digest No. 166 (7-21 Oktober, 2019)</a></li>
<li><a href="../id472310/index.html">Identifikasi klien di situs tanpa kata sandi dan cookie: aplikasi untuk standar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>