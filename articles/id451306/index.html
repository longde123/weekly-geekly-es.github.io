<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏼 🧑🏼 ↩️ QEMU.js: sekarang serius dan dengan WASM 👩🏻‍🚒 👨🏻 🤵🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekali waktu, demi tawa, saya memutuskan untuk membuktikan reversibilitas proses dan belajar bagaimana menghasilkan JavaScript (atau lebih tepatnya, A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>QEMU.js: sekarang serius dan dengan WASM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451306/"><p>  Sekali waktu, demi tawa, saya memutuskan untuk <em>membuktikan reversibilitas proses</em> dan belajar bagaimana menghasilkan JavaScript (atau lebih tepatnya, Asm.js) dari kode mesin.  QEMU dipilih untuk percobaan, beberapa waktu kemudian sebuah artikel ditulis di Habr.  Dalam komentar, saya disarankan untuk membuat kembali proyek di WebAssembly, dan saya sendiri tidak merasa ingin meninggalkan proyek yang <em>hampir selesai</em> sendiri ... Pekerjaan berjalan, tetapi sangat lambat, dan sekarang, dalam artikel itu, sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar</a> muncul pada topik "Jadi bagaimana akhirnya?".  Untuk jawaban terperinci saya, saya mendengar "Itu menarik artikel."  Nah, jika menarik, akan ada artikel.  Mungkin seseorang akan berguna.  Dari sini, pembaca belajar beberapa fakta tentang perangkat yang menghasilkan kode QEMU, serta cara menulis kompiler Just-in-Time untuk aplikasi web. </p><a name="habracut"></a><br><h2 id="zadachi">  Tugasnya </h2><br><p>  Karena saya sudah belajar cara "port" QEMU ke JavaScript, kali ini diputuskan untuk melakukannya dengan bijak dan tidak mengulangi kesalahan lama. </p><br><h3 id="oshibka-nomer-raz-otvetvitsya-ot-point-release">  Kesalahan berapa kali: bercabang dari rilis titik </h3><br><p> Kesalahan pertama saya adalah melakukan percabangan versi saya dari versi hulu 2.4.1.  Lalu menurut saya ide yang bagus: jika rilis titik ada, maka mungkin lebih stabil daripada 2.4 sederhana, dan bahkan lebih dari <code>master</code> branch.  Dan karena saya berencana untuk menambahkan bug yang cukup banyak, saya tidak membutuhkan orang asing sama sekali.  Jadi itu mungkin terjadi.  Tapi ini nasib buruk: QEMU tidak tinggal diam, dan pada titik tertentu mereka bahkan mengumumkan optimalisasi kode persen yang dihasilkan oleh 10. "Ya, sekarang aku kedinginan," pikirku <del>  dan putus </del>  .  Di sini kita harus melakukan penyimpangan: karena sifat single-threaded dari QEMU.js dan fakta bahwa QEMU asli tidak menyiratkan tidak adanya multithreading (yaitu, sangat penting untuk dapat mengoperasikan beberapa jalur kode yang tidak terkait pada saat yang sama, dan bukan hanya "pasang semua kernel"), fungsi utama dari thread harus "berubah" untuk kemungkinan panggilan dari luar.  Ini menciptakan beberapa masalah penggabungan alami.  Namun, fakta bahwa beberapa perubahan dari cabang <code>master</code> , yang dengannya saya mencoba untuk menggabungkan kode saya, juga ceri dipilih dalam rilis titik (dan, karena itu, di cabang saya), juga, mungkin, tidak akan menambah kenyamanan. </p><br><p>  Secara umum, saya memutuskan bahwa prototipe itu masuk akal <del>  membuang </del>  membongkar untuk bagian dan membangun versi baru dari awal berdasarkan sesuatu yang lebih segar dan sekarang dari <code>master</code> . </p><br><h3 id="oshibka-nomer-dva-tlp-metodologiya">  Kesalahan Nomor Dua: Metodologi TLP </h3><br><p>  Sebenarnya, ini bukan kesalahan, secara umum, ini hanya fitur membuat proyek dalam kondisi kesalahpahaman total tentang "ke mana dan bagaimana untuk pindah?", Dan secara umum "apakah kita akan sampai di sana?"  Di bawah kondisi ini, <em>pemrograman</em> adalah pilihan yang dapat dibenarkan, tetapi, tentu saja, saya benar-benar tidak ingin mengulanginya secara tidak perlu.  Kali ini saya ingin melakukannya dengan bijak: komit atom, perubahan kode yang disengaja (dan tidak “merangkai karakter acak bersama-sama sampai dikompilasi (dengan peringatan)”, seperti yang pernah dikatakan Linus Torvalds tentang seseorang, jika Anda percaya Wikitatnik), dll. </p><br><h3 id="oshibka-nomer-tri-ne-znaya-brodu-lezt-v-vodu">  Kesalahan nomor tiga: tidak tahu harus naik ke air </h3><br><p>  Saya belum benar-benar menyingkirkan ini, tetapi sekarang saya memutuskan untuk tidak mengikuti jalan perlawanan paling sedikit, dan melakukannya "dengan cara dewasa", yaitu, menulis backend TCG saya dari awal sehingga saya tidak mengatakan nanti, "Ya, itu Tentu saja, pelan-pelan, tapi saya tidak bisa mengendalikan semuanya - TCI ditulis seperti itu ... ".  Selain itu, awalnya ini sepertinya solusi yang jelas, karena <em>saya menghasilkan kode biner</em> .  Seperti kata pepatah, "Saya mengumpulkan Ghent, tapi bukan yang itu": kodenya, tentu saja, biner, tetapi kontrol tidak dapat ditransfer begitu saja - itu perlu secara eksplisit didorong ke browser untuk kompilasi, menghasilkan objek tertentu dari dunia JS, yang masih perlu menyimpan di suatu tempat.  Namun demikian, pada <del>  normal </del>  Untuk arsitektur RISC, seperti yang saya pahami, situasi tipikal adalah kebutuhan untuk secara otomatis membilas cache instruksi untuk kode yang dibuat ulang - jika ini bukan yang kita butuhkan, maka setidaknya itu sudah dekat.  Selain itu, dari upaya terakhir saya, saya mengetahui bahwa kontrol tampaknya tidak ditransfer ke tengah-tengah blok terjemahan, oleh karena itu, kami tidak benar-benar memerlukan kode bytec ditafsirkan dari offset apa pun, dan kami hanya dapat menghasilkan dengan fungsi pada TB. </p><br><h2 id="prishli-i-pnuli">  Datang dan menendang </h2><br><p>  Meskipun saya mulai menulis ulang kode pada bulan Juli, Pendel yang ajaib itu merayap tanpa disadari: biasanya surat-surat dari GitHub datang sebagai pemberitahuan tanggapan atas Masalah dan permintaan Tarik, dan kemudian, <em>tiba-tiba</em> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Binaryen sebagai backend qemu</a> dalam konteks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan</a> , "Ini dia- dia melakukan sesuatu seperti itu, mungkin dia akan mengatakan sesuatu. "  Itu tentang menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Binaryen yang</a> berhubungan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Emscripten</a> untuk membuat JIT WASM.  Yah, saya katakan bahwa Anda memiliki lisensi Apache 2.0 di sana, dan QEMU secara keseluruhan didistribusikan di bawah GPLv2, dan mereka tidak terlalu kompatibel.  Tiba-tiba ternyata lisensi itu <em>entah bagaimana</em> bisa <em>diperbaiki</em> (saya tidak tahu: mungkin, berubah, mungkin melipatgandakan lisensi, mungkin sesuatu yang lain ...).  Ini, tentu saja, membuat saya bahagia, karena saya sudah melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">format biner</a> WebAssembly beberapa kali pada saat itu, dan entah bagaimana sedih dan tidak dapat dimengerti oleh saya.  Ada perpustakaan di sini yang akan melahap blok dasar dengan grafik transisi, dan mengeluarkan bytecode, dan bahkan meluncurkannya di interpreter jika perlu. </p><br><p>  Lalu ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">surat</a> di milis QEMU, tetapi ini lebih cenderung pada pertanyaan, "Siapa yang butuh itu?"  Dan itu, <strong>tiba-tiba</strong> , diperlukan.  Minimal, Anda dapat mengikis bersama kasus penggunaan tersebut jika berfungsi lebih atau kurang cerdas: </p><br><ul><li>  meluncurkan pengajaran apa pun tanpa instalasi sama sekali </li><li>  virtualisasi di iOS, di mana menurut rumor satu-satunya aplikasi yang memiliki hak untuk membuat kode on the fly adalah mesin JS (apakah itu benar?) </li><li>  demonstrasi mini-OS - disk tunggal, bawaan, semua jenis firmware, dll ... </li></ul><br><h2 id="osobennosti-brauzernoy-sredy-vypolneniya">  Fitur runtime browser </h2><br><p>  Seperti yang saya katakan, QEMU terkait dengan multithreading, tetapi tidak di browser.  Ya, itu seperti, tidak ... Awalnya tidak ada sama sekali, kemudian WebWorkers muncul - seperti yang saya pahami, ini multithreading berdasarkan pesan yang lewat <strong>tanpa variabel variabel yang</strong> saling terkait.  Secara alami, ini menciptakan masalah signifikan ketika porting kode yang ada berdasarkan pada model memori bersama.  Kemudian, di bawah tekanan dari publik, itu diimplementasikan dengan nama <code>SharedArrayBuffers</code> .  Mereka secara bertahap memperkenalkannya, merayakan peluncurannya di browser yang berbeda, kemudian merayakan tahun baru, dan kemudian Meltdown ... Setelah itu mereka sampai pada kesimpulan bahwa pengukuran waktu yang kasar, tidak kasar, tetapi dengan bantuan memori bersama dan aliran yang menambah penghitung, itu masih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cukup akurat</a> .  Jadi mereka mematikan multithreading dengan memori bersama.  Tampaknya mereka kemudian menyalakannya kembali, tetapi, setelah menjadi jelas dari percobaan pertama, ada kehidupan tanpa itu, dan jika demikian, kami akan mencoba melakukannya tanpa mengandalkan multithreading. </p><br><p>  Fitur kedua adalah ketidakmungkinan manipulasi tingkat rendah dengan tumpukan: Anda tidak bisa hanya mengambil, menyimpan konteks saat ini dan beralih ke yang baru dengan tumpukan baru.  Tumpukan panggilan dikelola oleh mesin virtual JS.  Tampaknya, apa masalahnya, karena kami masih memutuskan untuk mengelola aliran yang sebelumnya sepenuhnya secara manual?  Faktanya adalah bahwa blok input-output dalam QEMU diimplementasikan melalui coroutine, dan di sini manipulasi tumpukan tingkat rendah akan berguna bagi kita.  Untungnya, Emscipten sudah mengandung mekanisme untuk operasi asinkron, bahkan dua: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Asyncify</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Emterpreter</a> .  Yang pertama bekerja melalui kembung signifikan dari kode JavaScript yang dihasilkan dan tidak lagi didukung.  Yang kedua adalah "cara yang benar" saat ini dan bekerja melalui generasi bytecode untuk penerjemahnya sendiri.  Ini berfungsi, tentu saja, secara perlahan, tetapi itu tidak mengembang kode.  Benar, dukungan coroutine untuk mekanisme ini harus dikaitkan sendiri (sudah ada coroutine yang ditulis di bawah Asyncify dan ada implementasi API yang kira-kira sama untuk Emterpreter, Anda hanya perlu menghubungkannya). </p><br><p>  Saat ini, saya belum berhasil membagi kode menjadi dikompilasi dalam WASM dan ditafsirkan menggunakan Emterpreter, sehingga perangkat blok belum berfungsi (lihat seri berikutnya, seperti yang mereka katakan ...).  Artinya, pada akhirnya, Anda harus mendapatkan sesuatu yang lucu seperti lapisan: </p><br><ul><li>  blok I / O yang diartikan  Nah, apa, apakah Anda benar-benar mengharapkan NVMe yang ditiru dengan kinerja asli?  :) </li><li>  kode QEMU utama yang dikompilasi secara statis (penerjemah, perangkat lain yang diemulasikan, dll.) </li><li>  WASM mengkompilasi kode tamu secara dinamis </li></ul><br><h2 id="osobennosti-ishodnikov-qemu">  Fitur sumber QEMU </h2><br><p>  Seperti yang mungkin sudah Anda tebak, kode emulasi untuk arsitektur tamu dan kode untuk menghasilkan instruksi mesin host dari QEMU terpisah.  Bahkan, ada yang sedikit lebih rumit: </p><br><ul><li>  ada arsitektur tamu </li><li>  ada <em>akselerator</em> , yaitu, KVM untuk virtualisasi perangkat keras di Linux (untuk sistem host dan host yang kompatibel), TCG untuk pembuatan kode JIT di mana saja.  Dimulai dengan QEMU 2.9, dukungan untuk standar virtualisasi perangkat keras HAXM pada Windows muncul ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">detail</a> ) </li><li>  jika TCG digunakan, dan bukan virtualisasi perangkat keras, maka TCG memiliki dukungan terpisah untuk pembuatan kode untuk setiap arsitektur host, serta untuk interpreter universal </li><li>  ... dan sekitarnya - periferal yang ditiru, antarmuka pengguna, migrasi, rekam ulangan, dll. </li></ul><br><p>  <em>Omong-omong, tahukah Anda:</em> QEMU tidak hanya dapat mengemulasi seluruh komputer, tetapi juga prosesor untuk proses pengguna terpisah di kernel host, yang digunakan, misalnya, oleh fuzzer AFL untuk instrumentasi binari.  Mungkin seseorang ingin mem-porting mode operasi QEMU ini ke JS?  ;) </p><br><p>  Seperti kebanyakan program gratis yang sudah lama ada, QEMU dibangun melalui panggilan untuk <code>configure</code> dan <code>make</code> .  Misalkan Anda memutuskan untuk menambahkan sesuatu: backend TCG, implementasi utas, sesuatu yang lain.  Jangan terburu-buru untuk bersukacita / ngeri (garis bawahi seperlunya) prospek berkomunikasi dengan Autoconf - pada kenyataannya, <code>configure</code> di QEMU tampaknya ditulis sendiri dan tidak ada yang menghasilkan dari. </p><br><h2 id="webassembly">  Perakitan web </h2><br><p>  Jadi apa benda ini - WebAssembly (alias WASM)?  Ini adalah pengganti Asm.js, sekarang tidak lagi berpura-pura menjadi kode JavaScript yang valid.  Sebaliknya, itu murni biner dan dioptimalkan, dan bahkan hanya menulis bilangan bulat ke dalamnya tidak terlalu sederhana: disimpan dalam format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LEB128</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kekompakan</a> . </p><br><p>  Anda mungkin pernah mendengar tentang algoritma reload untuk Asm.js - memulihkan instruksi kontrol aliran eksekusi "tingkat tinggi" (yaitu, jika-maka-yang lain, loop, dll.) Di mana mesin JS disetel dari LLVM IR tingkat rendah, lebih dekat ke kode mesin yang dijalankan oleh prosesor.  Secara alami, representasi perantara QEMU lebih dekat ke yang kedua.  Tampaknya di sinilah, bytecode, akhir dari siksaan ... Dan kemudian blok, jika-maka-lain dan loop! .. </p><br><p>  Dan ini adalah alasan lain mengapa Binaryen berguna: ia tentu saja dapat menerima blok tingkat tinggi dekat dengan apa yang akan disimpan dalam WASM.  Tetapi juga dapat menghasilkan kode dari grafik blok dasar dan transisi di antara mereka.  Yah, saya sudah mengatakan bahwa menyembunyikan format penyimpanan WebAssembly di belakang API C / C ++ yang nyaman. </p><br><h2 id="tcg-tiny-code-generator">  TCG (Tiny Code Generator) </h2><br><p>  TCG <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">awalnya merupakan</a> backend untuk kompiler C. Kemudian, tampaknya, ia tidak tahan persaingan dengan GCC, tetapi pada akhirnya ia menemukan tempatnya di QEMU sebagai mekanisme pembuatan kode untuk platform host.  Ada juga backend TCG yang menghasilkan beberapa bytecode abstrak, yang segera dieksekusi oleh penerjemah, tetapi saya memutuskan untuk pergi kali ini.  Namun, fakta bahwa QEMU sudah memiliki kemampuan untuk mengaktifkan transisi ke TB yang dihasilkan melalui fungsi <code>tcg_qemu_tb_exec</code> sangat membantu saya. </p><br><p>  Untuk menambahkan backend TCG baru ke QEMU, Anda perlu membuat <code>tcg/&lt; &gt;</code> (dalam hal ini, <code>tcg/binaryen</code> ), dan ada dua file di dalamnya: <code>tcg-target.h</code> dan <code>tcg-target.inc.c</code> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendaftarkan</a> semuanya ini <code>configure</code> .  Anda dapat meletakkan file-file lain di sana, tetapi, seperti yang dapat Anda tebak dari nama-nama keduanya, keduanya akan dimasukkan di suatu tempat: satu sebagai file header biasa (itu akan dimasukkan dalam <code>tcg/tcg.h</code> , dan yang sudah ada dalam file lain di direktori <code>tcg</code> , <code>accel</code> dan bukan hanya), yang lain hanya sebagai potongan kode di <code>tcg/tcg.c</code> , tetapi memiliki akses ke fungsi statisnya. </p><br><p>  Setelah memutuskan bahwa saya akan menghabiskan terlalu banyak waktu pada proses terperinci, cara kerjanya, saya cukup menyalin "kerangka" dari dua file ini dari implementasi backend lain, dengan jujur ​​menunjukkan ini di header lisensi. </p><br><p>  File <code>tcg-target.h</code> terutama berisi pengaturan dalam bentuk <code>#define</code> s: </p><br><ul><li>  berapa banyak register dan seberapa luas pada arsitektur target (kami memiliki - sebanyak yang kami inginkan, ada begitu banyak - pertanyaannya adalah lebih dari apa yang akan dihasilkan oleh browser dalam kode yang lebih efisien pada arsitektur "sepenuhnya target" ...) </li><li>  penyelarasan instruksi host: pada x86, dan di TCI, instruksinya tidak sejajar sama sekali, tapi saya akan memasukkan buffer kode bukan instruksi sama sekali, tetapi menunjuk ke struktur perpustakaan Binaryen, jadi saya akan mengatakan: 4 byte </li><li>  instruksi opsional apa yang dapat dihasilkan backend - nyalakan semua yang kami temukan di Binaryen, biarkan akselerator memecah sisanya menjadi yang lebih sederhana </li><li>  perkiraan ukuran cache TLB yang diminta oleh backend.  Faktanya adalah bahwa dalam QEMU semuanya serius: meskipun ada fungsi pembantu yang memuat / menyimpan dengan mempertimbangkan MMU tamu (dan di mana sekarang tanpa itu?), Mereka menyimpan cache terjemahan mereka dalam bentuk struktur, proses yang nyaman untuk ditanamkan langsung ke blok terjemahan.  Pertanyaannya adalah, offset apa dalam struktur ini yang paling efisien ditangani oleh urutan perintah yang kecil dan cepat </li><li>  di sini Anda dapat memutar tujuan satu atau dua register yang dipesan, mengaktifkan panggilan TB melalui suatu fungsi dan secara opsional menggambarkan beberapa fungsi <code>inline</code> kecil seperti <code>flush_icache_range</code> (tetapi ini bukan kasus kami) </li></ul><br><p>  File <code>tcg-target.inc.c</code> , tentu saja, biasanya jauh lebih besar dan berisi beberapa fungsi yang diperlukan: </p><br><ul><li>  inisialisasi, menunjukkan, antara lain, pembatasan instruksi mana yang dapat digunakan operan.  Tidak sengaja saya salin dari backend lain </li><li>  fungsi menerima satu instruksi bytecode internal </li><li>  di sini Anda dapat meletakkan fungsi bantu, dan juga di sini Anda dapat menggunakan fungsi statis dari <code>tcg/tcg.c</code> </li></ul><br><p>  Bagi saya sendiri, saya memilih strategi berikut: dalam kata-kata pertama dari blok terjemahan berikutnya, saya menuliskan empat petunjuk: tanda awal (nilai tertentu di sekitar <code>0xFFFFFFFF</code> , yang menentukan status TB saat ini), konteks, modul yang dihasilkan, dan angka ajaib untuk debugging.  Pertama, label ditetapkan ke <code>0xFFFFFFFF - n</code> , di mana <code>n</code> adalah angka positif yang kecil, dan setiap kali melalui penerjemah, angka tersebut bertambah 1. Ketika mencapai <code>0xFFFFFFFE</code> , kompilasi terjadi, modul disimpan di tabel fungsi, diimpor ke “peluncur” kecil, ke mana eksekusi meninggalkan <code>tcg_qemu_tb_exec</code> , dan modul dihapus dari memori QEMU. </p><br><p>  Mengutip klasik, "Crutch, berapa banyak proger telah terjalin dalam suara ini untuk jantung ...".  Namun, memori itu bocor entah ke mana.  Dan itu adalah memori yang dikelola oleh QEMU!  Saya punya kode yang, ketika menuliskan instruksi selanjutnya (yah, itu adalah sebuah pointer), menghapus satu tautan yang ada di tempat ini sebelumnya, tetapi itu tidak membantu.  Sebenarnya, dalam kasus paling sederhana, QEMU mengalokasikan memori saat startup dan menulis kode yang dihasilkan di sana.  Ketika buffer berakhir, kode tersebut dibuang, dan yang berikutnya mulai ditulis di tempatnya. </p><br><p>  Setelah mempelajari kodenya, saya menyadari bahwa tongkat penyangga dengan angka ajaib memungkinkan kami untuk tidak jatuh pada kehancuran tumpukan, membebaskan sesuatu yang salah pada buffer yang tidak diinisialisasi pada lintasan pertama.  Tetapi siapa yang akan menimpa penyangga melewati fungsi saya nanti?  Seperti yang disarankan pengembang Emscripten, setelah mengalami masalah, saya mem-porting kode yang dihasilkan kembali ke aplikasi asli, mengatur Mozilla Record-Replay di atasnya ... Secara umum, sebagai hasilnya, saya menyadari hal sederhana: <code>struct TranslationBlock</code> dengan deskripsi dialokasikan untuk setiap blok.  Tebak di mana ... Itu benar, tepat di depan blok tepat di buffer.  Setelah menyadari ini, saya memutuskan untuk mengikatnya dengan kruk (setidaknya beberapa), dan cukup membuang angka ajaib, dan mentransfer kata-kata yang tersisa ke <code>struct TranslationBlock</code> , membuat daftar tautan tunggal yang dapat Anda lalui dengan cepat saat mengatur ulang cache terjemahan dan membebaskan memori. </p><br><p>  Beberapa kruk tetap: misalnya, penunjuk yang ditandai di buffer kode - beberapa di antaranya hanya <code>BinaryenExpressionRef</code> , yaitu, mereka melihat ekspresi yang perlu dimasukkan secara linear ke dalam unit dasar yang dihasilkan, sebagian - kondisi transisi antara WB, bagian - ke mana harus pergi.  Nah, sudah ada blok yang disiapkan untuk Relooper, yang harus terhubung sesuai dengan kondisi.  Untuk membedakannya, asumsi digunakan bahwa mereka semua disejajarkan setidaknya empat byte, sehingga Anda dapat menggunakan dua bit label dengan aman, Anda hanya perlu mengingat untuk menghapusnya jika perlu.  Omong-omong, label semacam itu sudah digunakan di QEMU untuk menunjukkan alasan untuk keluar dari siklus TCG. </p><br><h2 id="ispolzovanie-binaryen">  Menggunakan Binaryen </h2><br><p>  Modul di WebAssembly berisi fungsi, yang masing-masing berisi tubuh yang mewakili ekspresi.  Ekspresi adalah operasi unary dan biner, blok yang terdiri dari daftar ekspresi lain, aliran kontrol, dll.  Seperti yang sudah saya katakan, aliran kendali di sini diatur persis seperti cabang tingkat tinggi, loop, pemanggilan fungsi, dll.  Argumen untuk fungsi dilewatkan bukan pada stack, tetapi secara eksplisit, seperti pada JS.  Ada variabel global, tetapi saya tidak menggunakannya, jadi saya tidak akan membicarakannya. </p><br><p>  Fungsinya juga memiliki variabel lokal, dinomori dari awal, dengan tipe: int32 / int64 / float / double.  Variabel lokal n pertama adalah argumen yang diteruskan ke fungsi.  Harap dicatat bahwa meskipun semuanya di sini tidak sepenuhnya level rendah dalam hal aliran kontrol, bilangan bulat masih tidak membawa tanda / tanda tanpa tanda: bagaimana nomor akan berperilaku tergantung pada kode operasi. </p><br><p>  Secara umum, Binaryen menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C-API sederhana</a> : Anda membuat modul, <strong>di dalamnya Anda</strong> membuat ekspresi - unary, binary, blok dari ekspresi lain, aliran kontrol, dll.  Kemudian Anda membuat fungsi, yang tubuhnya Anda perlu menentukan ekspresi.  Jika Anda, seperti saya, memiliki grafik transisi level rendah, komponen relooper akan membantu Anda.  Sejauh yang saya mengerti, adalah mungkin untuk menggunakan kontrol tingkat tinggi dari aliran eksekusi di blok, selama itu tidak melampaui batas blok - yaitu, adalah mungkin untuk membuat jalur cepat internal / cabang jalur lambat di dalam kode pemrosesan cache TLB built-in, tetapi tidak ada gangguan dengan aliran kontrol "eksternal" .  Ketika Anda melepaskan relooper, bloknya dilepaskan, ketika Anda melepaskan modul, ekspresi, fungsi, dll., Yang dialokasikan di <em>arena</em> menghilang. </p><br><p>  Namun, jika Anda ingin menafsirkan kode saat bepergian tanpa membuat dan menghapus instance interpreter yang tidak perlu, mungkin masuk akal untuk mentransfer logika ini ke file C ++, dan dari sana langsung mengontrol seluruh perpustakaan C ++ API, mem-bypass pembungkus yang sudah jadi. </p><br><p>  Jadi, untuk menghasilkan kode, Anda perlu </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    (  ) BinaryenSetAPITracing(0); BinaryenSetOptimizeLevel(3); BinaryenSetShrinkLevel(2); //   BinaryenModuleRef MODULE = BinaryenModuleCreate(); //    ( ,   ) helper_type BinaryenAddFunctionType(MODULE, "helper-func", BinaryenTypeInt32(), int32_helper_args, ARRAY_SIZE(int32_helper_args)); // (int23_helper_args ^W ) //  -  // ...     -  :) //    BinaryenAddFunction(MODULE, "tb_fun", tb_func_type, func_locals, FUNC_LOCALS_COUNT, expr); BinaryenAddFunctionExport(MODULE, "tb_fun", "tb_fun"); ... BinaryenSetMemory(MODULE, (1 &lt;&lt; 15) - 1, -1, NULL, NULL, NULL, NULL, NULL, 0, 0); BinaryenAddMemoryImport(MODULE, NULL, "env", "memory", 0); BinaryenAddTableImport(MODULE, NULL, "env", "tb_funcs"); //       assert (BinaryenModuleValidate(MODULE)); BinaryenModuleOptimize(MODULE);</span></span></code> </pre> <br><p> …    — ,     ,   —   . </p><br><p>    --,  : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>]; BinaryenModuleOptimize(MODULE); BinaryenSetMemory(MODULE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sz = BinaryenModuleWrite(MODULE, buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf)); BinaryenModuleDispose(MODULE); EM_ASM({ var <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebAssembly.Module(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uint8Array(wasmMemory.buffer, $<span class="hljs-number"><span class="hljs-number">0</span></span>, $<span class="hljs-number"><span class="hljs-number">1</span></span>)); var fptr = $<span class="hljs-number"><span class="hljs-number">2</span></span>; var instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebAssembly.Instance(<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>, { <span class="hljs-string"><span class="hljs-string">'env'</span></span>: { <span class="hljs-string"><span class="hljs-string">'memory'</span></span>: wasmMemory, <span class="hljs-comment"><span class="hljs-comment">// ... } ); //       instance! }, buf, sz);</span></span></code> </pre> <br><p>  -     QEMU  JS        ,    (     ),     .    ,         translation block,   ,           <code>struct TranslationBlock</code> . </p><br><p> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> <em>(    )</em>     Firefox.  Chrome  <em>-  </em>  ,  -       WebAssembly,          ... </p><br><p>     . ,    ,   - .  ,    <em> </em>    . ,      WebAssembly  ,       JS,      ,     ,     . </p><br><p> <strong><strong> :</strong></strong>     32- ,         Binaryen, -     -   2  32-  .   ,     Binaryen       .   ? </p><br><div class="spoiler"> <b class="spoiler_title">-</b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak menguji ini pada akhirnya, tetapi pikiran pertama saya adalah "Bagaimana jika saya meletakkan Linux 32-bit?" </font><font style="vertical-align: inherit;">Kemudian bagian atas dari ruang alamat akan ditempati oleh kernel. </font><font style="vertical-align: inherit;">Satu-satunya pertanyaan adalah berapa banyak yang akan ditempati: 1 atau 2 Gb.</font></font></p></div></div><br><div class="spoiler"> <b class="spoiler_title">- (  )</b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengembang gelembung di bagian atas ruang alamat. </font><font style="vertical-align: inherit;">Saya sendiri tidak mengerti mengapa ini bekerja - </font><font style="vertical-align: inherit;">seharusnya </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sudah</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ada tumpukan </font><font style="vertical-align: inherit;">di tempat yang sama </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tapi "kami adalah praktisi: semuanya bekerja untuk kami, tetapi tidak ada yang tahu mengapa ...".</font></font></p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2gbubble.c // Usage: LD_PRELOAD=2gbubble.so &lt;program&gt; #include &lt;sys/mman.h&gt; #include &lt;assert.h&gt; void __attribute__((constructor)) constr(void) { assert(MAP_FAILED != mmap(1u &gt;&gt; 31, (1u &gt;&gt; 31) - (1u &gt;&gt; 20), PROT_NONE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0)); }</span></span></code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... itu tidak kompatibel dengan Valgrind, tetapi, untungnya, Valgrind sangat efektif dalam memadatkan semua orang dari sana :) </font></font></p><br><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin seseorang akan memberikan penjelasan yang lebih baik tentang bagaimana kode saya berfungsi ...</font></font></em> </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451306/">https://habr.com/ru/post/id451306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451294/index.html">Ketika saya menambahkan fungsi ke mobil melalui CAN, tidak dapat memprogram</a></li>
<li><a href="../id451296/index.html">Diumumkan oleh ML.NET 1.0</a></li>
<li><a href="../id451298/index.html">Cara membuat konsol game dengan kasing dengan memesan satu papan sirkuit tercetak</a></li>
<li><a href="../id451302/index.html">Perusahaan alih daya TI teratas</a></li>
<li><a href="../id451304/index.html">"Tip" Yandex: bagaimana memaksimalkan keuntungan pada langganan berbayar</a></li>
<li><a href="../id451310/index.html">Apakah Anda melewatkan PDA?</a></li>
<li><a href="../id451314/index.html">Produksi papan sirkuit cetak LUT'om dari A hingga Z</a></li>
<li><a href="../id451316/index.html">Tentang Fakultas Fisika</a></li>
<li><a href="../id451318/index.html">Dart 2.3 diumumkan: dioptimalkan untuk pengembangan antarmuka pengguna</a></li>
<li><a href="../id451320/index.html">Mengapa firmware terbuka penting untuk keamanan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>