<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûø üÜò üë®‚Äç‚úàÔ∏è Entwickeln Sie Ihren Browser von Grund auf neu. Erster Teil: HTML üëáüèæ üåù ‚è∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 


 Wir setzen die Artikelserie zur Entwicklung der Browser-Engine fort. 


 In diesem Artikel werde ich Ihnen erkl√§ren, wie Sie den...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwickeln Sie Ihren Browser von Grund auf neu. Erster Teil: HTML</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430736/"><p><img src="https://habrastorage.org/webt/qu/3l/02/qu3l02mug029as5w74y2zznn0yc.jpeg"></p><br><p>  Hallo allerseits! </p><br><p>  Wir setzen die Artikelserie zur Entwicklung der Browser-Engine fort. </p><br><p>  In diesem Artikel werde ich Ihnen erkl√§ren, wie Sie den schnellsten HTML-Parser mit DOM erstellen.  Wir werden uns die HTML-Spezifikation ansehen und herausfinden, warum sie hinsichtlich der Leistung und des Ressourcenverbrauchs beim Parsen von HTML schlecht ist. </p><br><p>  Mit diesem Thema habe ich √ºber das vergangene HighLoad ++ berichtet.  Nicht jeder kann an der Konferenz teilnehmen, und der Artikel enth√§lt weitere Details. </p><br><p>  Ich gehe davon aus, dass der Leser Grundkenntnisse in HTML hat: Tags, Knoten, Elemente, Namespace. </p><a name="habracut"></a><br><h2 id="specifikaciya-html">  HTML-Spezifikation </h2><br><p>  Bevor Sie sich mit der Implementierung des HTML-Parsers befassen, m√ºssen Sie wissen, welche HTML-Spezifikationen Sie glauben m√ºssen. </p><br><p>  Es gibt zwei HTML-Spezifikationen: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WAS</a> <br><ul><li> Apple, Mozilla, Google, Microsoft </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">W3c</a> <br><ul><li>  Gro√üe Liste von Unternehmen </li></ul></li></ol><br><p> Nat√ºrlich fiel die Wahl auf Branchenf√ºhrer - <strong><code>WHATWG</code></strong> .  Lebensstandard, gro√üe Unternehmen mit jeweils eigenem Browser / eigener Browser-Engine. </p><br><p>  UPDATE: Leider √∂ffnen sich die angegebenen Links zu den Spezifikationen nicht aus Russland.  Anscheinend das "Echo des Krieges" mit Telegrammen. </p><br><h2 id="process-parsinga-html">  HTML-Analyseprozess </h2><br><p>  Der Prozess zum Erstellen eines HTML-Baums kann in vier Teile unterteilt werden: </p><br><ol><li>  Decoder </li><li>  Vorbehandlung </li><li>  Tokenizer </li><li>  Einen Baum bauen </li></ol><br><p>  Wir betrachten jede Stufe einzeln. </p><br><h3 id="dekoder">  Decoder </h3><br><p>  Der Tokenizer akzeptiert Unicode-Zeichen (Codepunkte) als Eingabe.  Dementsprechend m√ºssen wir den aktuellen Bytestream in Unicode-Zeichen konvertieren.  Verwenden Sie dazu die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codierungsspezifikation</a> . </p><br><p>  Wenn wir HTML mit einer unbekannten Codierung haben (kein HTTP-Header), m√ºssen wir es bestimmen, bevor die Decodierung beginnt.  Zu diesem Zweck verwenden wir den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codierungs-Sniffing-Algorithmus</a> . </p><br><p>  Wenn es nur sehr kurz ist, besteht die Essenz des Algorithmus darin, dass wir <strong><code>500</code></strong> oder die ersten <strong><code>1024 </code></strong> vom Byte-Stream warten und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prescan-Byte-Stream-</a> Algorithmus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausf√ºhren, um seine Codierung zu bestimmen,</a> die versucht, das <strong><code>&lt;meta&gt;</code></strong> mit den Attributen <strong><code>http-equiv</code></strong> , <strong><code>content</code></strong> oder <strong><code>charset</code></strong> und zu versuchen Verstehen Sie, welche Codierung der HTML-Entwickler angegeben hat. </p><br><p>  Die <strong><code>Encoding</code></strong> legt den Mindestsatz unterst√ºtzter Codierungen durch die Browser-Engine fest (insgesamt 21): UTF-8, ISO-8859-2, ISO-8859-7, ISO-8859-8, Windows-874, Windows-1250, Windows-1251, Windows -1252, Windows-1254, Windows-1255, Windows-1256, Windows-1257, Windows-1258, GB18030, Big5, ISO-2022-JP, Shift_JIS, EUC-KR, UTF-16BE, UTF-16LE und X-User -definiert. </p><br><h3 id="predvaritelnaya-obrabotka">  Vorbehandlung </h3><br><p>  Nachdem wir die Bytes in Unicode-Zeichen dekodiert haben, m√ºssen wir "bereinigen".  Ersetzen Sie n√§mlich alle Wagenr√ºcklaufzeichen ( <strong><code>\r</code></strong> ) gefolgt von einem Zeilenvorschubzeichen ( <strong><code>\n</code></strong> ) durch ein Wagenr√ºcklaufzeichen ( <strong><code>\r</code></strong> ).  Ersetzen Sie dann alle Wagenr√ºcklaufzeichen durch ein Zeilenumbruchzeichen ( <strong><code>\n</code></strong> ). </p><br><p>  So beschrieben in der Spezifikation.  Das hei√üt, <strong><code>\r\n</code></strong> =&gt; <strong><code>\r</code></strong> , <strong><code>\r</code></strong> =&gt; <strong><code>\n</code></strong> . </p><br><p>  Tats√§chlich tut es aber niemand.  Machen Sie es einfacher: </p><br><p>  Wenn Sie ein Wagenr√ºcklaufzeichen ( <strong><code>\r</code></strong> ) erhalten, pr√ºfen Sie, ob ein Zeilenvorschubzeichen ( <strong><code>\n</code></strong> ) vorhanden ist.  Wenn dies der Fall ist, √§ndern wir beide Zeichen in das Zeilenvorschubzeichen ( <strong><code>\n</code></strong> ). Wenn nicht, √§ndern wir nur das erste Zeichen ( <strong><code>\r</code></strong> ) in das Zeilenvorschubzeichen ( <strong><code>\n</code></strong> ). </p><br><p>  Damit ist die vorl√§ufige Datenverarbeitung abgeschlossen.  Ja, Sie m√ºssen nur die Wagenr√ºcklaufsymbole entfernen, damit sie nicht in den Tokenizer fallen.  Der Tokenizer erwartet nicht und wei√ü nicht, was mit dem Wagenr√ºcklaufsymbol zu tun ist. </p><br><h3 id="oshibki-parsinga">  Analysefehler </h3><br><p>  Damit es in Zukunft keine Fragen mehr gibt, sollten Sie sofort feststellen, was ein <code> </code> ( <strong><code>parse error</code></strong> ). </p><br><p>  Nichts wirklich falsch.  Es klingt bedrohlich, aber tats√§chlich ist dies nur eine Warnung, dass wir einen erwartet haben, aber wir haben einen anderen. </p><br><p>  Ein Analysefehler stoppt nicht die Datenverarbeitung oder die Baumbildung.  Dies ist eine Nachricht, die signalisiert, dass wir kein g√ºltiges HTML haben. </p><br><p>  Parsig-Fehler k√∂nnen f√ºr Ersatzpaare, <code>\0</code> , falsche Tag-Position, falsches <strong><code>&lt;!DOCTYPE&gt;</code></strong> und alle m√∂glichen anderen Dinge erhalten werden. </p><br><p>  √úbrigens f√ºhren einige Analysefehler zu Konsequenzen.  Wenn Sie beispielsweise "bad" <strong><code>&lt;!DOCTYPE&gt;</code></strong> angeben, wird der HTML-Baum als <strong><code>QUIRKS</code></strong> markiert und die Logik einiger DOM-Funktionen √§ndert sich. </p><br><h3 id="tokenizator">  Tokenizer </h3><br><p>  Wie bereits erw√§hnt, akzeptiert der Tokenizer Unicode-Zeichen als Eingabe.  Dies ist eine Zustandsmaschine mit <strong><code>80</code></strong> Zust√§nden.  In jedem Zustand Bedingungen f√ºr Unicode-Zeichen.  Abh√§ngig vom empfangenen Zeichen kann der Tokenizer: </p><br><ol><li>  √Ñndern Sie Ihren Zustand </li><li>  Generieren Sie ein Token und √§ndern Sie den Status </li><li>  Tu nichts, warte auf den n√§chsten Charakter </li></ol><br><p>  Der Tokenizer erstellt sechs Arten von Token: DOCTYPE, Start-Tag, End-Tag, Kommentar, Zeichen, Dateiende.  Welche betreten die Phase des Baumbaus. </p><br><p>  Es ist bemerkenswert, dass der Tokenizer nicht √ºber alle seine Zust√§nde Bescheid wei√ü, aber wo ungef√§hr 40% (zum Beispiel von der Decke genommen).  "Warum der Rest?"  - Du fragst.  Etwa die restlichen 60% kennen das Stadium des Baumbaus. </p><br><p>  Dies geschieht, um Tags wie <strong><code>&lt;textarea&gt;</code></strong> , <strong><code>&lt;style&gt;</code></strong> , <strong><code>&lt;script&gt;</code></strong> , <strong><code>&lt;title&gt;</code></strong> usw. korrekt zu analysieren.  Das hei√üt, normalerweise jene Tags, bei denen wir keine anderen Tags erwarten, sondern nur uns selbst schlie√üen. </p><br><p>  Beispielsweise kann das <strong><code>&lt;title&gt;</code></strong> keine anderen Tags enthalten.  Alle Tags in <strong><code>&lt;title&gt;</code></strong> werden als Text wahrgenommen, bis sie auf ein schlie√üendes Tag f√ºr sich selbst sto√üen. <strong><code>&lt;/title&gt;</code></strong> . </p><br><p>  Warum wird das gemacht?  Schlie√ülich k√∂nnte man dem Tokenizer einfach sagen, dass wir, wenn wir das <strong><code>&lt;title&gt;</code></strong> treffen <strong><code>&lt;title&gt;</code></strong> den "Pfad gehen, den wir brauchen".  Und das w√§re wahr, wenn nicht Namespaces!  Ja, der Namespace wirkt sich auf das Verhalten der Baumerstellungsphase aus, was wiederum das Verhalten des Tokenizers √§ndert. </p><br><p>  Betrachten Sie als Beispiel das Verhalten des <strong><code>&lt;title&gt;</code></strong> in HTML- und SVG-Namespaces: </p><br><p>  <strong>HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Das Ergebnis des Baumbaus: </p><br><pre> <code class="plaintext hljs">&lt;title&gt; "&lt;span&gt;&lt;/span&gt;"</code> </pre> <br><p>  <strong>Svg</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Das Ergebnis des Baumbaus: </p><br><pre> <code class="plaintext hljs">&lt;svg&gt; &lt;title&gt; &lt;span&gt; ""</code> </pre> <br><p>  Wir sehen, dass im ersten Fall (HTML-Namespace) das <strong><code>&lt;span&gt;</code></strong> Text ist und das <strong><code>span</code></strong> Element nicht erstellt wurde.  Im zweiten Fall (SVG-Namespace) wurde ein Element basierend auf dem <strong><code>&lt;span&gt;</code></strong> -Tag erstellt.  Das hei√üt, je nach Namespace verhalten sich Tags unterschiedlich. </p><br><p>  Aber das ist noch nicht alles.  Der Kuchen bei dieser "Feier des Lebens" ist die Tatsache, dass der Tokenizer selbst wissen muss, in welchem ‚Äã‚ÄãNamespace sich die Phase der Baumkonstruktion befindet.  Und dies ist nur notwendig, um <strong><code>CDATA</code></strong> richtig zu handhaben. </p><br><p>  Betrachten Sie zwei Beispiele mit <strong><code>CDATA</code></strong> , zwei Namespaces: </p><br><p>  <strong>HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Das Ergebnis des Baumbaus: </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;!--[CDATA[  ]]--&gt;</code> </pre> <br><p>  <strong>Svg</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Das Ergebnis des Baumbaus: </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;svg&gt; "  "</code> </pre> <br><p>  Im ersten Fall (HTML-Namespace) nahm der Tokenizer <strong><code>CDATA</code></strong> als Kommentar.  Im zweiten Fall zerlegte der Tokenizer die <strong><code>CDATA</code></strong> Struktur und empfing Daten von ihr.  Im Allgemeinen lautet die Regel: Wenn wir <strong><code>CDATA</code></strong> nicht im HTML-Namespace treffen, analysieren wir es, andernfalls betrachten wir es als Kommentar. </p><br><p>  Dies ist die enge Verbindung zwischen dem Tokenizer und der Konstruktion des Baums.  Der Tokenizer muss wissen, in welchem ‚Äã‚ÄãNamespace sich die Phase der Baumkonstruktion gerade befindet, und die Phase der Baumkonstruktion kann den Status des Tokenizers √§ndern. </p><br><h3 id="tokeny">  Token </h3><br><p>  Im Folgenden werden alle sechs Arten von Token betrachtet, die vom Tokenizer erstellt wurden.  Es ist erw√§hnenswert, dass alle Token Daten vorbereitet haben, dh bereits verarbeitet und "gebrauchsfertig" sind.  Dies bedeutet, dass alle benannten Zeichenreferenzen wie <strong><code>&amp;copy</code></strong> in Unicode-Zeichen konvertiert werden. </p><br><h3 id="doctype-token">  DOCTYPE-Token </h3><br><p>  Das DOCTYPE-Token hat eine eigene Struktur, die anderen Tags nicht √§hnlich ist.  Das Token enth√§lt: </p><br><ol><li>  Vorname </li><li>  √ñffentliche Kennung </li><li>  Systemkennung </li></ol><br><p>  In modernem HTML sollte der einzige g√ºltige / g√ºltige DOCTYPE folgenderma√üen aussehen: </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span></code> </pre> <br><p>  Alle anderen <strong><code>&lt;!DOCTYPE&gt;</code></strong> werden als <strong><code>&lt;!DOCTYPE&gt;</code></strong> betrachtet. </p><br><h3 id="start-tag-token">  Tag-Token starten </h3><br><p>  Das Er√∂ffnungs-Tag kann enthalten: </p><br><ol><li>  Tag-Name </li><li>  Attribute </li><li>  Flaggen </li></ol><br><p>  Z.B, </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  Das √∂ffnende Tag kann ein <strong><code>self-closing</code></strong> Flag enthalten.  Dieses Flag wirkt sich nicht auf das Schlie√üen des Tags aus, kann jedoch einen Analysefehler f√ºr nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">leere</a> Elemente verursachen. </p><br><h3 id="end-tag-token">  Tag-Token beenden </h3><br><p>  Tag schlie√üen.  Es hat alle Eigenschaften des Tokens des √∂ffnenden Tags, aber einen Schr√§gstrich <strong><code>/</code></strong> vor dem Tag-Namen. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  Das schlie√üende Tag kann ein <strong><code>self-closing</code></strong> Flag enthalten, das einen Analysefehler verursacht.  Der Analysefehler wird auch durch die Attribute des schlie√üenden Tags verursacht.  Sie werden korrekt analysiert, aber im Stadium des Baumbaus weggeworfen. </p><br><h3 id="comment-token">  Kommentar-Token </h3><br><p>  Das Kommentartoken enth√§lt den gesamten Kommentartext.  Das hei√üt, es wird vollst√§ndig vom Stream auf das Token kopiert. </p><br><p>  Beispiel </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  --&gt;</span></span></code> </pre> <br><h3 id="character-token">  Zeichen-Token </h3><br><p>  Vielleicht das interessanteste Zeichen.  Unicode-Token-Symbol.  Kann ein (nur ein) Zeichen enthalten. </p><br><p>  F√ºr jedes Zeichen in HTML wird ein Token erstellt und an die Phase der Baumkonstruktion gesendet.  Das ist sehr teuer. <br>  Mal sehen, wie es funktioniert. </p><br><p>  Nehmen Sie die HTML-Daten: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> ! &amp;reg;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Was denkst du, wie viele Token f√ºr dieses Beispiel erstellt werden?  Antwort: 22. </p><br><p>  Betrachten Sie die Liste der erstellten Token: </p><br><pre> <code class="plaintext hljs">Start tag token: &lt;span&gt; Character token:  Character token:  Character token:  Character token:  Character token:  Character token: Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token: ! Character token: Character token: End tag token: &lt;/span&gt; End-of-file token</code> </pre> <br><p>  Nicht tr√∂stlich, oder?  Aber nat√ºrlich haben viele Ersteller von HTML-Parsern w√§hrend der Verarbeitung tats√§chlich nur ein Token.  F√ºhren Sie es in einem Kreis aus und √ºberschreiben Sie es jedes Mal mit neuen Daten. </p><br><p>  Lassen Sie uns weitermachen und die Frage beantworten: Warum wird das getan?  Warum nicht diesen Text in einem St√ºck aufnehmen?  Die Antwort liegt in der Bauphase des Baumes. </p><br><p>  Ein Tokenizer ist ohne die Phase der Erstellung eines HTML-Baums nutzlos.  W√§hrend des Baus eines Baumes wird der Text unter verschiedenen Bedingungen zusammengeklebt. </p><br><p>  Die Bedingungen sind ungef√§hr wie folgt: </p><br><ol><li>  Wenn ein Zeichentoken mit <strong><code>U+0000</code></strong> ( <strong><code>NULL</code></strong> ) eintrifft, verursachen wir einen Analysefehler und ignorieren das Token. </li><li>  Wenn eines der Zeichen-Token <strong><code>U+0009</code></strong> ( <strong><code>CHARACTER TABULATION</code></strong> ), <strong><code>U+000A</code></strong> ( <strong><code>LINE FEED (LF)</code></strong> ), <strong><code>U+000C</code></strong> ( <strong><code>FORM FEED (FF)</code></strong> ) oder <strong><code>U+0020</code></strong> ( <strong><code>SPACE</code></strong> ) gekommen ist, rufen Sie den Algorithmus auf, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um die aktiven Formatierungselemente</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wiederherzustellen</a> F√ºgen Sie den Token in den Baum ein. </li></ol><br><p>  Das Symbol-Token wird dem Baum gem√§√ü dem Algorithmus hinzugef√ºgt: </p><br><ol><li>  Wenn die aktuelle Einf√ºgeposition kein Textknoten ist, erstellen Sie einen Textknoten, f√ºgen Sie ihn in den Baum ein und f√ºgen Sie Daten aus dem Token hinzu. </li><li>  Andernfalls f√ºgen Sie Daten aus dem Token zu einem vorhandenen Textknoten hinzu. </li></ol><br><p>  Dieses Verhalten verursacht viele Probleme.  Die Notwendigkeit, dass jedes Symbol ein Token erstellt und zur Analyse an die Phase der Erstellung eines Baums sendet.  Wir kennen die Gr√∂√üe des Textknotens nicht und m√ºssen entweder im Voraus viel Speicher zuweisen oder Realoks erstellen.  All dies ist aus Speicher- oder Zeitgr√ºnden extrem teuer. </p><br><h3 id="end-of-file-token">  Token f√ºr das Dateiende </h3><br><p>  Einfaches und klares Zeichen.  Die Daten sind vorbei - lassen Sie sich √ºber diese Phase des Baumbaus informieren. </p><br><h3 id="postroenie-dereva">  Einen Baum bauen </h3><br><p>  Tree Building ist eine Zustandsmaschine mit <strong><code>23</code></strong> Zust√§nden mit vielen Bedingungen f√ºr Token (Tags, Text).  Das Stadium der Baumkonstruktion ist das gr√∂√üte, nimmt einen erheblichen Teil der Spezifikation ein und kann auch lethargischen Schlaf und Reizungen verursachen. </p><br><p>  Alles ist sehr einfach angeordnet.  Token werden am Eingang empfangen und abh√§ngig vom Token wird der Status der Baumkonstruktion umgeschaltet.  Am Ausgang haben wir ein echtes DOM. </p><br><h2 id="problemy">  Probleme? </h2><br><p>  Die folgenden Probleme scheinen ziemlich offensichtlich zu sein: </p><br><p>  <strong>Zeichen f√ºr Zeichen kopieren</strong> </p><br><p>  Jeder Tokenizer-Status erh√§lt an der Eingabe ein Zeichen, das er bei Bedarf kopiert / konvertiert: Tag-Namen, Attribute, Kommentare, Symbole. </p><br><p>  Dies ist sowohl im Ged√§chtnis als auch in der Zeit sehr verschwenderisch.  Wir sind gezwungen, f√ºr jedes Attribut, jeden Tag-Namen, jeden Kommentar usw. eine unbekannte Speichermenge vorzuweisen.  Und das f√ºhrt dementsprechend zu Realoks und Realoks zu Zeitverlust. </p><br><p>  Und wenn Sie sich vorstellen, dass HTML 1000 Tags enth√§lt und jedes Tag mindestens ein Attribut hat, erhalten wir einen h√∂llisch langsamen Parser. </p><br><p>  <strong>Zeichen-Token</strong> </p><br><p>  Das zweite Problem ist das Zeichen-Token.  Es stellt sich heraus, dass wir f√ºr jedes Symbol ein Token erstellen und es zum Erstellen eines Baums geben.  Das Erstellen eines Baums wei√ü nicht, wie viele dieser Token wir haben werden, und kann nicht sofort Speicher f√ºr die erforderliche Anzahl von Zeichen zuweisen.  Dementsprechend pr√ºft hier alle gleichen Realoks + Konstanten auf das Vorhandensein eines Textknotens im aktuellen Zustand des Baumes. </p><br><p>  <strong>Monolithisches System</strong> </p><br><p>  Das gro√üe Problem ist die Abh√§ngigkeit von allem von allem.  Das hei√üt, der Tokenizer h√§ngt vom Status des Aufbaus des Baums ab, und die Konstruktion des Baums kann den Tokenizer steuern.  Und alles ist schuld an den Namespaces. </p><br><h2 id="kak-budem-reshat-problemy">  Wie werden wir die Probleme l√∂sen? </h2><br><p>  Als n√§chstes beschreibe ich die Implementierung des HTML-Parsers in meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lexbor-</a> Projekt sowie die L√∂sung aller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angesprochenen</a> Probleme. </p><br><h3 id="predvaritelnaya-obrabotka-1">  Vorbehandlung </h3><br><p>  Wir entfernen die vorl√§ufige Datenverarbeitung.  Wir werden den Tokenizer trainieren, um den Wagenr√ºcklauf ( <strong><code>\r</code></strong> ) als Leerzeichen zu verstehen.  So wird er in die Phase des Baumbaus geworfen, wo wir es herausfinden werden. </p><br><h3 id="tokeny-1">  Token </h3><br><p>  Mit einem Handgriff vereinen wir alle Token.  Wir werden f√ºr alles einen Token haben.  Im Allgemeinen gibt es im gesamten Analyseprozess nur ein Token. </p><br><p>  Unser einheitliches Token enth√§lt die folgenden Felder: </p><br><ol><li>  Tag-ID </li><li>  Beginnen Sie </li><li>  Ende </li><li>  Attribute </li><li>  Flaggen </li></ol><br><h4 id="tag-id">  Tag-ID </h4><br><p>  Wir werden nicht mit der Textdarstellung des Tag-Namens arbeiten.  Wir √ºbersetzen alles in Zahlen.  Die Zahlen sind leicht zu vergleichen und leichter zu bearbeiten. </p><br><p>  Wir erstellen eine statische Hash-Tabelle aus allen bekannten Tags.  Wir erstellen eine Aufz√§hlung aus allen bekannten Tags.  Das hei√üt, wir m√ºssen jedem Tag einen festen Bezeichner zuweisen.  Dementsprechend ist in der Hash-Tabelle der Schl√ºssel der Name des Tags, und der Wert wird aus der Aufz√§hlung geschrieben. </p><br><p>  Beispielsweise: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_TAG__UNDEF = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_TAG__END_OF_FILE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_TAG__TEXT = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_TAG__DOCUMENT = <span class="hljs-number"><span class="hljs-number">0x0003</span></span>, LXB_TAG__EM_COMMENT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_TAG__EM_DOCTYPE = <span class="hljs-number"><span class="hljs-number">0x0005</span></span>, LXB_TAG_A = <span class="hljs-number"><span class="hljs-number">0x0006</span></span>, LXB_TAG_ABBR = <span class="hljs-number"><span class="hljs-number">0x0007</span></span>, LXB_TAG_ACRONYM = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_TAG_ADDRESS = <span class="hljs-number"><span class="hljs-number">0x0009</span></span>, LXB_TAG_ALTGLYPH = <span class="hljs-number"><span class="hljs-number">0x000a</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Wie Sie dem Beispiel entnehmen k√∂nnen, haben wir Tags f√ºr das Token <strong>END-OF-FILE</strong> f√ºr Text f√ºr ein Dokument erstellt.  All dies aus Gr√ºnden der weiteren Bequemlichkeit.  Wenn ich den Vorhang √∂ffne, sage ich, dass wir im Knoten ( <strong><code>DOM Node Interface</code></strong> Knotenschnittstelle) eine <strong><code>Tag ID</code></strong> .  Dies geschieht, um keine zwei Vergleiche anzustellen: den Knotentyp und das Element.  Das hei√üt, wenn wir ein <strong><code>DIV</code></strong> Element ben√∂tigen, f√ºhren wir eine √úberpr√ºfung im Knoten durch: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Best code */</span></span> }</code> </pre> <br><p>  Aber nat√ºrlich k√∂nnen Sie dies tun: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;type == LXB_DOM_NODE_TYPE_ELEMENT &amp;&amp; node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Oh, code */</span></span> }</code> </pre> <br><p>  Zwei Unterstriche in <strong><code>LXB_TAG__</code></strong> sind erforderlich, um allgemeine Tags von System-Tags zu trennen.  Mit anderen Worten, der Benutzer kann ein Tag mit dem Namenstext oder dem <strong><code>end-of-file</code></strong> Wenn wir dann nach dem Tag-Namen suchen, treten keine Fehler auf.  Alle System-Tags beginnen mit einem <strong><code>#</code></strong> . </p><br><p>  Ein Knoten kann jedoch eine Textdarstellung des Tag-Namens speichern.  F√ºr 98,99999% Knoten ist dieser Parameter <strong><code>NULL</code></strong> .  In einigen Namespaces m√ºssen wir ein Pr√§fix oder einen Tag-Namen mit einem festen Register angeben.  Beispiel: <strong><code>baseProfile</code></strong> im SVG-Namespace. </p><br><p>  Die Logik der Arbeit ist einfach.  Wenn wir ein Tag mit einem klar definierten Register haben, dann: </p><br><ol><li>  F√ºgen Sie es der allgemeinen Basis von Tags in Kleinbuchstaben hinzu.  Holen Sie sich die Tag-ID. </li><li>  F√ºgen Sie dem Knoten die Tag-ID und den urspr√ºnglichen Tag-Namen in der Textdarstellung hinzu. </li></ol><br><p>  <strong>Benutzerdefinierte Tags</strong> </p><br><p>  Ein Entwickler kann beliebige Tags in HTML erstellen.  Da wir nur die Tags haben, die wir in einer statischen Hash-Tabelle kennen, und der Benutzer jede erstellen kann, ben√∂tigen wir eine dynamische Hash-Tabelle. </p><br><p>  Alles sieht sehr einfach aus.  Wenn das Tag zu uns kommt, werden wir sehen, ob es in der statischen Hash-Tabelle ist.  Wenn es kein Tag gibt, schauen wir uns das dynamische an. Wenn es kein gibt, erh√∂hen wir den Bezeichnerz√§hler um eins und f√ºgen das Tag der dynamischen Tabelle hinzu. </p><br><p>  Alles, was beschrieben wird, geschieht in der Phase des Tokenizers.  Im Tokenizer und nach allen Vergleichen nach <strong><code>Tag ID</code></strong> (mit seltenen Ausnahmen). </p><br><h4 id="begin-and-end">  Anfang und Ende </h4><br><p>  Jetzt im Tokenizer haben wir keine Datenverarbeitung mehr.  Wir werden nichts kopieren und konvertieren.  Wir zeigen nur auf den Anfang und das Ende der Daten. </p><br><p>  Alle Datenverarbeitungen, wie z. B. symbolische Verkn√ºpfungen, finden in der Phase der Baumbildung statt. <br>  Somit kennen wir die Gr√∂√üe der Daten f√ºr die nachfolgende Speicherzuweisung. </p><br><h4 id="attributes">  Attribute </h4><br><p>  Hier ist alles genauso einfach.  Wir kopieren nichts, sondern speichern einfach Zeiger auf den Anfang / das Ende des Namens und der Attributwerte.  Alle Transformationen erfolgen zum Zeitpunkt der Erstellung des Baums. </p><br><h4 id="flags">  Flaggen </h4><br><p>  Da wir Token vereinheitlicht haben, m√ºssen wir das Baumgeb√§ude irgendwie √ºber die Art des Tokens informieren.  Verwenden Sie dazu das Bitmap-Feld Flags. </p><br><p>  Das Feld kann folgende Werte enthalten: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_HTML_TOKEN_TYPE_OPEN = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE_SELF = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_HTML_TOKEN_TYPE_TEXT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_HTML_TOKEN_TYPE_DATA = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_HTML_TOKEN_TYPE_RCDATA = <span class="hljs-number"><span class="hljs-number">0x0010</span></span>, LXB_HTML_TOKEN_TYPE_CDATA = <span class="hljs-number"><span class="hljs-number">0x0020</span></span>, LXB_HTML_TOKEN_TYPE_NULL = <span class="hljs-number"><span class="hljs-number">0x0040</span></span>, LXB_HTML_TOKEN_TYPE_FORCE_QUIRKS = <span class="hljs-number"><span class="hljs-number">0x0080</span></span>, LXB_HTML_TOKEN_TYPE_DONE = <span class="hljs-number"><span class="hljs-number">0x0100</span></span> };</code> </pre> <br><p>  Neben dem Typ des Tokens, der ge√∂ffnet oder geschlossen wird, gibt es Werte f√ºr den Datenkonverter.  Nur der Tokenizer wei√ü, wie die Daten korrekt konvertiert werden.  Dementsprechend markiert der Tokenizer im Token, wie die Daten verarbeitet werden sollen. </p><br><h4 id="character-token-1">  Zeichen-Token </h4><br><p>  Aus dem zuvor beschriebenen k√∂nnen wir schlie√üen, dass das Symbol-Token von uns verschwunden ist.  Ja, jetzt haben wir einen neuen Token-Typ: <strong><code>LXB_HTML_TOKEN_TYPE_TEXT</code></strong> .  Jetzt erstellen wir ein Token f√ºr den gesamten Text zwischen den Tags und markieren, wie er in Zukunft verarbeitet werden soll. </p><br><p>  Aus diesem Grund m√ºssen wir die Bedingungen f√ºr die Konstruktion des Baumes √§ndern.  Wir m√ºssen ihn trainieren, nicht mit symbolischen Token, sondern mit Text-Token zu arbeiten: konvertieren, unn√∂tige Zeichen l√∂schen, Leerzeichen √ºberspringen und so weiter. </p><br><p>  Aber es gibt nichts Kompliziertes.  In der Phase des Baumbaus sind die √Ñnderungen minimal.  Aber der Tokenizer stimmt jetzt √ºberhaupt nicht mehr mit der Spezifikation des Wortes √ºberein.  Aber wir brauchen ihn nicht, es ist normal.  Unsere Aufgabe ist es, einen HTML / DOM-Baum zu erhalten, der den Spezifikationen vollst√§ndig entspricht. </p><br><h3 id="stadii-tokenizatora">  Tokenizer-Stufen </h3><br><p>  Um eine schnelle Datenverarbeitung im Tokenizer sicherzustellen, f√ºgen wir jeder Stufe unseren Iterator hinzu.  Gem√§√ü der Spezifikation akzeptiert jede Stufe ein Symbol f√ºr uns und trifft je nach angekommenem Symbol Entscheidungen.  Aber die Wahrheit ist, dass es sehr teuer ist. </p><br><p>  Um beispielsweise von der Stufe <strong><code>ATTRIBUTE_VALUE</code></strong> Stufe <strong><code>ATTRIBUTE_NAME</code></strong> zu <strong><code>ATTRIBUTE_VALUE</code></strong> m√ºssen Sie im Attributnamen einen Leerraum finden, der das Ende angibt.  Gem√§√ü der Spezifikation sollten wir der Stufe <strong><code>ATTRIBUTE_NAME</code></strong> nach Zeichen <strong><code>ATTRIBUTE_NAME</code></strong> bis ein Leerzeichen <strong><code>ATTRIBUTE_NAME</code></strong> und diese Stufe nicht zu einer anderen wechselt.  Dies ist sehr teuer, normalerweise wird es durch einen Funktionsaufruf f√ºr jedes Zeichen oder einen R√ºckruf wie "tkz-&gt; next_code_point ()" implementiert. </p><br><p>  Wir f√ºgen der Stufe <strong><code>ATTRIBUTE_NAME</code></strong> eine Schleife <strong><code>ATTRIBUTE_NAME</code></strong> und √ºbergeben den gesamten eingehenden Puffer.  In der Schleife suchen wir nach den Symbolen, die wir wechseln m√ºssen, und arbeiten weiter an der n√§chsten Stufe.  Hier bekommen wir viele Gewinne, sogar Compiler-Optimierungen. </p><br><p>  Aber!  Das Schlimmste ist, dass wir dadurch die Unterst√ºtzung von Brocken (Brocken) aus der Schachtel gerissen haben.  Dank der zeichenweisen Verarbeitung in jeder Phase des Tokenizers hatten wir Unterst√ºtzung f√ºr Chunks, und jetzt haben wir sie gebrochen. </p><br><p>  Wie kann ich das beheben?  Wie implementiere ich Unterst√ºtzung f√ºr Chunks ?!  Es ist ganz einfach, wir f√ºhren das Konzept der eingehenden Puffer (Incoming Buffer) ein. </p><br><h3 id="incoming-buffer">  Eingehender Puffer </h3><br><p>  Oft analysiert HTML in Bl√∂cken.  Zum Beispiel, wenn wir Daten √ºber das Netzwerk empfangen.  Um nicht unt√§tig zu bleiben, w√§hrend auf die verbleibenden Daten gewartet wird, k√∂nnen wir bereits empfangene Daten zur Verarbeitung / Analyse senden.  Nat√ºrlich k√∂nnen Daten √ºberall zerrissen werden.  Zum Beispiel haben wir zwei Puffer: </p><br><p>  <strong>Zuerst</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">clas</span></span></span></span></code> </pre> <br><p>  <strong>Zweitens</strong> </p><br><pre> <code class="html hljs xml">s="oh-no-oh-no"&gt;</code> </pre> <br><p>  Da wir in der Tokenisierungsphase nichts kopieren, sondern nur Zeiger auf den Anfang und das Ende der Daten nehmen, haben wir ein Problem.  Zeiger auf verschiedene Benutzerpuffer.  Angesichts der Tatsache, dass Entwickler h√§ufig denselben Puffer f√ºr Daten verwenden, handelt es sich um einen Zeiger auf den Anfang nicht vorhandener Daten. </p><br><p>               . <br>   : </p><br><ol><li>              (Incoming Buffer). </li><li>     ( )  ,        ?  ,          .       ,           .  99%        . </li></ol><br><p>  "  "  .      . </p><br><p> ,      .      ,       ( )          .     . ,  ,   ,  .         . </p><br><h3 id="problema-dannye-v-tokene"> :    </h3><br><p>      ,  . ,        :          .     .             (    ),      .              . </p><br><p>    :      .  ,                . </p><br><h2 id="stadiya-postroeniya-dereva">    </h2><br><p>   . </p><br><p>      ,    . ,         . </p><br><p>  So sieht es aus: </p><br><p> <strong> </strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error, ignore token */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == whitespaces) { <span class="hljs-comment"><span class="hljs-comment">/* Insert element */</span></span><span class="hljs-string"><span class="hljs-string">' } /* ... */ }</span></span></code> </pre> <br><p> <strong> Lexbor HTML</strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">lexbor_str_t</span></span> str = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">lxb_html_parser_char_t</span></span> pc = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; pc.drop_null = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; tree-&gt;status = lxb_html_token_parse_data(token, &amp;pc, &amp;str, tree-&gt;document-&gt;mem-&gt;text); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token-&gt;type &amp; LXB_HTML_TOKEN_TYPE_NULL) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* Insert element if not empty */</span></span> }</code> </pre> <br><p>   ,               .           : </p><br><pre> <code class="cpp hljs">pc.replace_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0'    (REPLACEMENT CHARACTER (U+FFFD)) */</span></span> pc.drop_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0' */</span></span> pc.is_attribute <span class="hljs-comment"><span class="hljs-comment">/*          " " */</span></span> pc.state <span class="hljs-comment"><span class="hljs-comment">/*  .        . */</span></span></code> </pre> <br><p>           . -   <strong><code>\0</code></strong> ,  -    <strong><code>REPLACEMENT CHARACTER</code></strong> . -    ,  - .        . </p><br><p>  ,     .      .  ,       <strong><code>&lt;head&gt;</code></strong>   .  ,           ,   : "    ".              ,           . </p><br><div class="spoiler"> <b class="spoiler_title">  &lt;sarcasm&gt;</b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die HTML-Spezifikation (im Abschnitt zum Erstellen von B√§umen) befasst sich mit dem Tag </font></font><strong><code>sarcasm</code></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich habe mehr als einmal gesehen, wie Parser-Entwickler die Verarbeitung dieses Tags blind eingeschaltet haben.</font></font></p><br><pre> <code class="plaintext hljs">An end tag whose tag name is "sarcasm" Take a deep breath, then act as described in the "any other end tag" entry below.</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spezifikationsschreiber scherzen. </font></font></p></div></div><br><h2 id="itog">  </h2><br><p>            HTML    DOM/HTML Interfaces   HTML/DOM    HTML . </p><br><p>    ,   : </p><br><ol><li>    (  ) </li><li>  <br><ul><li>  Incoming Buffer </li><li>   </li><li>   Tag ID </li><li> ÃÜ :  ,  N+  </li><li> ÃÜ     </li><li>      </li><li>    Ãà </li></ul></li><li>   <br><ul><li>      </li></ul></li></ol><br><p>  i7 2012 ,   ,      235MB   (Amazon-). </p><br><p>  ,        1.5/2 ,     . ,    . ,    CSS     (Grammar,  ,       Grammar).     HTML,  CSS  ,    "". </p><br><h2 id="ishodniki">  Quellcode </h2><br><p>      HTML    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lexbor HTML</a> . </p><br><h2 id="ps">  PS </h2><br><p>      CSS  Grammar.  ,     .  - 6-8 . </p><br><div class="spoiler"> <b class="spoiler_title"> ,    </b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºhlen Sie sich frei, das Projekt zu helfen. </font><font style="vertical-align: inherit;">Zum Beispiel, wenn Sie in Ihrer Freizeit Dokumentation schreiben m√∂chten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºhlen Sie sich frei, das Projekt in Rubel zu unterst√ºtzen (ich werde auch nicht von anderen W√§hrungen beleidigt sein). </font><font style="vertical-align: inherit;">Dar√ºber in PM.</font></font></p></div></div><br><p>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430736/">https://habr.com/ru/post/de430736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430724/index.html">DEFCON 21. DNS-Konferenzen k√∂nnen gesundheitssch√§dlich sein. Teil 1</a></li>
<li><a href="../de430728/index.html">Lehre mich, Feedback zu geben</a></li>
<li><a href="../de430730/index.html">Was macht F & E ABBYY: NLP Advanced Research Group</a></li>
<li><a href="../de430732/index.html">Zur Frage der Teilung und TI</a></li>
<li><a href="../de430734/index.html">Intelligente Updates im Vergleich zu intelligenten Vertr√§gen</a></li>
<li><a href="../de430738/index.html">Sei ein Sicherheits-Ninja: geheime Ebene</a></li>
<li><a href="../de430740/index.html">Wie man K√ºhe mit Robotern melkt und ein industrielles Startup darauf macht. R-SEPT Entwicklungsgeschichte</a></li>
<li><a href="../de430742/index.html">Studentenolympiade "Ich bin ein Profi": Richtung "Programmierung und Informationstechnologie"</a></li>
<li><a href="../de430746/index.html">Warum Tesla-Batterien im Lufttaxi nicht funktionieren</a></li>
<li><a href="../de430748/index.html">Der Kampf um Ressourcen, Teil 6: cpuset oder Sharing ist nicht immer richtig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>