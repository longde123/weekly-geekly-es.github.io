<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙 🍝 🦖 Hohe Daten 👨🏼‍✈️ 🏜️ 🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ja, ja, du hast nicht geträumt und richtig gehört - es ist von hoher Art. Art ist ein typentheoretischer Begriff, der im Wesentlichen eine Art von Typ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hohe Daten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429104/">  Ja, ja, du hast nicht geträumt und richtig gehört - es ist von hoher Art.  Art ist ein typentheoretischer Begriff, der im Wesentlichen eine Art von Typ [Daten] bedeutet. <br><br>  Aber zuerst einige Texte. <br><br>  Auf Habré wurden mehrere Artikel veröffentlicht, in denen die Methode der Datenvalidierung in funktionalen Sprachen ausführlich beschrieben wurde. <br><br>  Dieser Artikel ist meine fünf Cent in diesem Hype.  Wir werden die Datenvalidierung in Haskell in Betracht ziehen. <br><br><h2>  Typüberprüfung </h2><br>  Ein Beispiel für eine Validierungstechnik unter Verwendung der Typvalidierung wurde zuvor betrachtet: <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailContactInfo</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PostalContactInfo</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ContactInfo</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailOnly</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailContactInfo</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PostOnly</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PostalContactInfo</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailAndPost</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailContactInfo</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PostalContactInfo</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pName</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pContactInfo</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ContactInfo</span></span></span><span class="hljs-class">, }</span></span></code> </pre> <br>  Mit dieser Methode ist es einfach unmöglich, falsche Daten zu erstellen.  Trotz der Tatsache, dass eine solche Validierung sehr einfach zu erstellen und zu lesen ist, müssen Sie bei ihrer Verwendung viel Routine schreiben und viele Änderungen am Code vornehmen.  Dies bedeutet, dass die Verwendung einer solchen Methode nur für wirklich wichtige Daten beschränkt ist. <br><br><h2>  Hohe Datenvalidierung </h2><br><img src="https://habrastorage.org/webt/gr/0_/a4/gr0_a4salxhcmnrbszknetxoddy.jpeg"><br><br>  In diesem Artikel werden wir uns mit einer anderen Validierungsmethode befassen - unter Verwendung hochwertiger Daten. <br><br>  Angenommen, wir haben einen Datentyp: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pName</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pAge</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br>  Und wir werden die Daten nur validieren, wenn alle Felder des Datensatzes gültig sind. <br>  Da Haskell den meisten funktionalen Sprachen in seiner Funktionalität überlegen ist, kann er die meisten Routinen leicht loswerden. <br><br>  Hier ist es möglich und daher ist diese Methode unter Autoren von Bibliotheken in Haskell weit verbreitet. <br><a name="habracut"></a><br>  Stellen wir uns zu Diskussionszwecken vor, dass ein Benutzer persönliche Informationen über ein Webformular oder etwas anderes ausfüllen soll.  Mit anderen Worten, es ist möglich, dass sie das Ausfüllen eines Teils der Informationen verderben können, wodurch der Rest der Datenstruktur nicht unbedingt ungültig wird.  Wenn sie die gesamte Struktur erfolgreich gefüllt haben, möchten wir einen gefüllten <b>Personenpinsel erhalten</b> . <br><br>  Eine Möglichkeit zum Modellieren besteht darin, einen zweiten Datentyp zu verwenden: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybePerson</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybePerson</span></span></span><span class="hljs-class">  { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mpName</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">  , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mpAge</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">  }</span></span></code> </pre> <br>  Ich erinnere mich, dass der optionale Typ verwendet wird: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Prelude data Maybe a = Nothing | Just a</span></span></code> </pre> <br>  Von hier aus ist die Validierungsfunktion ganz einfach: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">validate</span></span> :: <span class="hljs-type"><span class="hljs-type">MaybePerson</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span> validate (<span class="hljs-type"><span class="hljs-type">MaybePerson</span></span> name age) =  <span class="hljs-type"><span class="hljs-type">Person</span></span> &lt;$&gt; name &lt;*&gt; age</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Ein bisschen mehr Details zu den Funktionen (&lt;$&gt;) und (&lt;*&gt;)</b> <div class="spoiler_text">  Die Funktion <b>(&lt;$&gt;)</b> ist nur ein Infix-Synonym für <b>fmap</b> Functor <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Prelude fmap :: Functor f =&gt; (a -&gt; b) -&gt; fa -&gt; fb (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; fa -&gt; fb (&lt;$&gt;) = fmap</span></span></code> </pre> <br>  AND <b>(&lt;*&gt;)</b> ist eine Funktion zum Anwenden des Applicative Functor <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Prelude (&lt;*&gt;) :: Applicative f =&gt; f (a -&gt; b) -&gt; fa -&gt; fb</span></span></code> </pre> <br>  Für einen optionalen Typ haben diese Funktionen die folgende Definition <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Prelude (&lt;$&gt;) :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b _ &lt;$&gt; Nothing = Nothing f &lt;$&gt; (Just a) = Just (fa) (&lt;*&gt;) :: Maybe (a -&gt; b) -&gt; Maybe a -&gt; Maybe b (Just f) &lt;*&gt; m = f &lt;$&gt; m Nothing &lt;*&gt; _ = Nothing</span></span></code> </pre><br></div></div><br>  Unsere Validierung funktioniert, aber es ist ärgerlich, zusätzlichen Routinecode von Hand zu schreiben, da dies vollständig mechanisch erfolgt.  Darüber hinaus bedeutet die Verdoppelung dieser Bemühungen, dass wir in Zukunft unser Gehirn einsetzen müssen, um sicherzustellen, dass alle drei Definitionen synchron bleiben.  Wäre es toll, wenn der Compiler damit umgehen könnte? <br><br>  ÜBERRASCHUNG!  ER KANN!  Eine große Familie wird uns helfen! <br><br>  In Haskell gibt es so etwas wie eine Gattung, es ist eine <b>Art</b> , und die einfachste und genaueste Erklärung ist, dass eine Gattung eine Art von Typ [Daten] ist.  Die am weitesten verbreitete Gattung ist <b>*</b> , die als "final" bezeichnet werden kann. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; :k <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> :: * ghci&gt; :k <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> :: * ghci&gt; :k <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> :: * ghci&gt; :k <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> :: * ghci&gt; :k [<span class="hljs-type"><span class="hljs-type">Int</span></span>] [<span class="hljs-type"><span class="hljs-type">Int</span></span>] :: *</code> </pre> <br>  Und was für ein <b>Vielleicht</b> ? <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; :k <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Maybe</span></span> :: * -&gt; * ghci&gt; :k [] [] :: * -&gt; *</code> </pre> <br>  Dies ist ein Beispiel von hoher Art. <br><br>  Beachten Sie, dass wir sowohl <b>Person</b> als auch <b>MaybePerson mit den</b> folgenden einzelnen, <b>hochwertigen</b> Daten beschreiben können: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person'</span></span></span><span class="hljs-class"> f = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pName</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pAge</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br>  Hier parametrisieren wir <b>Person '</b> über etwas <b>f</b> (mit Geschlecht <b>* -&gt; *</b> ), wodurch wir Folgendes tun können, um die ursprünglichen Typen zu verwenden: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person'</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Identity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybePerson</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person'</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span></span></code> </pre> <br>  Hier verwenden wir einen einfachen Wrapper-Typ von Identität <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Prelude newtype Identity a = Identity { runIdentity :: a }</span></span></code> </pre> <br>  Obwohl dies funktioniert, ist es im Fall von <b>Person</b> etwas ärgerlich, da jetzt alle unsere Daten in <b>Identity</b> verpackt sind: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; :t pName @<span class="hljs-type"><span class="hljs-type">Identity</span></span> pName :: <span class="hljs-type"><span class="hljs-type">Person</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Identity</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> ghci&gt; :t runIdentity. pName runIdentity. pName :: <span class="hljs-type"><span class="hljs-type">Person</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre> <br>  Wir können diesen Ärger trivial beseitigen, woraufhin wir untersuchen werden, warum eine solche Definition von <b>Person</b> wirklich nützlich ist.  Um Bezeichner zu entfernen, können wir eine Typenfamilie (eine Funktion auf Textebene) verwenden, die sie löscht: <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE TypeFamilies #-}</span></span> <span class="hljs-comment"><span class="hljs-comment">-- "Higher-Kinded Data" type family HKD fa where HKD Identity a = a HKD fa = fa data Person' f = Person  { pName :: HKD f String  , pAge :: HKD f Int  } deriving (Generic)</span></span></code> </pre> <br>  Wir brauchen den Abschluss von <b>Generic</b> für den 2. Teil des Artikels. <br><br>  Die Verwendung der <b>HKD-Typfamilie</b> bedeutet, dass der GHC alle <b>Identitäts-</b> Wrapper in unseren Ansichten automatisch löscht: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; :t pName @<span class="hljs-type"><span class="hljs-type">Identity</span></span> pName :: <span class="hljs-type"><span class="hljs-type">Person</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> ghci&gt; :t pName @<span class="hljs-type"><span class="hljs-type">Maybe</span></span> pName :: <span class="hljs-type"><span class="hljs-type">Person</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre> <br>  und genau diese Version der <b>Person der</b> höchsten Art kann am besten als Ersatz für einen Ersatz für unsere ursprüngliche verwendet werden. <br><br>  Die offensichtliche Frage ist, was wir uns bei all dieser Arbeit gekauft haben.  Kehren wir zum Wortlaut der Validierung zurück, um diese Frage zu beantworten. <br><br>  Wir können es jetzt mit unserer neuen Technik umschreiben: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">validate</span></span> :: <span class="hljs-type"><span class="hljs-type">Person'</span></span> <span class="hljs-type"><span class="hljs-type">Maybe</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span> validate (<span class="hljs-type"><span class="hljs-type">Person</span></span> name age) = <span class="hljs-type"><span class="hljs-type">Person</span></span> &lt;$&gt; name &lt;*&gt; age</code> </pre> <br>  Keine sehr interessante Änderung?  Aber die Intrige ist, wie wenig geändert werden muss.  Wie Sie sehen können, stimmen nur unser Typ und Muster mit unserer ursprünglichen Implementierung überein.  Was hier ordentlich ist, ist, dass wir jetzt <b>Person</b> und <b>MaybePerson</b> in derselben Ansicht konsolidiert haben und sie daher nicht mehr nur im nominellen Sinne verbunden sind. <br><br><h2>  Generika und die allgemeinere Validierungsfunktion </h2><br>  Die aktuelle Version der Validierungsfunktion muss für jeden neuen Datentyp geschrieben werden, obwohl der Code ziemlich routinemäßig ist. <br><br>  Wir können eine Validierungsversion schreiben, die für jeden höheren Datentyp funktioniert. <br><br>  Man könnte Template Haskell verwenden, aber es generiert Code und wird nur in extremen Fällen verwendet.  Wir werden nicht. <br><br>  Das Geheimnis ist, <b>GHC.Generics</b> zu kontaktieren.  Wenn Sie mit der Bibliothek nicht vertraut sind, bietet sie einen Isomorphismus vom regulären Datentyp Haskell zu einer allgemeinen Darstellung, die von einem intelligenten Programmierer (dh uns) strukturell gesteuert werden kann. Durch die Bereitstellung von Code, mit dem wir konstante Typen, Produkte und Nebenprodukte ändern, können wir erzwingen GHC schreibt einen typunabhängigen Code für uns.  Dies ist eine sehr nette Technik, die Ihre Zehen kitzelt, wenn Sie sie noch nicht gesehen haben. <br><br>  Am Ende wollen wir so etwas wie: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">validate</span></span> :: _ =&gt; d <span class="hljs-type"><span class="hljs-type">Maybe</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> (d <span class="hljs-type"><span class="hljs-type">Identity</span></span>)</code> </pre> <br>  Aus Sicht von <b>Generics kann</b> jeder Typ am häufigsten in mehrere Designs unterteilt werden: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- undefined data, lifted version of Empty data V1 p -- Unit: used for constructors without arguments, lifted version of () data U1 p = U1 -- a container for ac, Constants, additional parameters and recursion of kind * newtype K1 icp = K1 { unK1 :: c } -- a wrapper, Meta-information (constructor names, etc.) newtype M1 itfp = M1 { unM1 :: fp } -- Sums: encode choice between constructors, lifted version of Either data (:+:) fgp = L1 (fp) | R1 (gp) -- Products: encode multiple arguments to constructors, lifted version of (,) data (:*:) fgp = (fp) :*: (gp)</span></span></code> </pre> <br>  Das heißt, es können nicht initialisierte Strukturen, argumentfreie Strukturen, konstante Strukturen, Metainformationen (Konstruktoren usw.) existieren.  Und auch Assoziationen von Strukturen - Gesamt oder Assoziationen vom Typ OR-OR und animiert, sind sie auch Kurzformassoziationen oder Datensätze. <br><br>  Zuerst müssen wir eine Klasse definieren, die das Arbeitstier unserer Transformation sein wird.  Aus Erfahrung ist dies immer der schwierigste Teil - die Arten dieser verallgemeinerten Transformationen sind äußerst abstrakt und meiner Meinung nach sehr schwer zu begründen.  Verwenden wir: <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE MultiParamTypeClasses #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-type"><span class="hljs-type">GValidate</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gvalidate :: ip -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> (op)</code> </pre> <br>  Sie können die "weichen und langsamen" Regeln verwenden, um zu überlegen, wie Ihr Klassentyp aussehen soll. Im Allgemeinen benötigen Sie jedoch sowohl einen Eingabe- als auch einen Ausgabeparameter.  Beide müssen der Gattung <b>* -&gt; * angehören</b> und dann dieses existentialisierte <b>p</b> aus dunklen, unheiligen Gründen übertragen, die der Menschheit nicht bekannt sind.  Dann gehen wir mit einer kleinen Checkliste durch, um unsere Köpfe um diese schreckliche höllische Landschaft zu wickeln, die wir später nacheinander umrunden werden. <br><br>  In jedem Fall ist unsere Klasse bereits in unseren Händen, jetzt müssen wir nur noch Instanzen unserer Klasse für verschiedene Arten von <b>GHC.Generic schreiben</b> .  Wir können mit dem Basisfall beginnen, den wir überprüfen müssen, nämlich <b>Vielleicht k</b> : <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE FlexibleInstances #-}</span></span> <span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE TypeOperators #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GValidate</span></span> (<span class="hljs-type"><span class="hljs-type">K1</span></span> a (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> k)) (<span class="hljs-type"><span class="hljs-type">K1</span></span> ak) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-comment"><span class="hljs-comment">-- gvalidate :: K1 a (Maybe k) -&gt; Maybe (K1 ak) gvalidate (K1 k) = K1 &lt;$&gt; k {-# INLINE gvalidate #-}</span></span></code> </pre> <br>  <b>K1</b> ist ein "konstanter Typ", was bedeutet, dass hier unsere strukturelle Rekursion endet.  Im Beispiel mit unserer <b>Person 'ist</b> dies <b>pName :: HKD f String</b> . <br><br>  In den meisten Fällen, wenn Sie einen Basisfall haben, sind die restlichen nur mechanisch definierte Instanzen für andere Typen.  Sofern Sie nicht überall Zugriff auf Metadaten zum Quelltyp benötigen, handelt es sich bei diesen Instanzen fast immer um triviale Homomorphismen. <br><br>  Wir können mit multiplikativen Strukturen beginnen - wenn wir <b>GValidate io</b> und <b>GValidate i 'o' haben</b> , sollten wir sie parallel ausführen können: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GValidate</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GValidate</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i'</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">o'</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GValidate</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> :*: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i'</span></span></span><span class="hljs-class">) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">o</span></span></span><span class="hljs-class"> :*: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">o'</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gvalidate (l :*: r) = (:*:) &lt;$&gt; gvalidate l &lt;*&gt; gvalidate r <span class="hljs-meta"><span class="hljs-meta">{-# INLINE gvalidate #-}</span></span></code> </pre> <br>  Wenn sich <b>K1</b> direkt auf <b>die</b> Selektoren unserer <b>Person</b> bezieht, entspricht (: * :) ungefähr der Syntax des Kommas, durch das wir unsere Felder im Datensatz trennen. <br><br>  Wir können eine ähnliche <b>GValidate-</b> Instanz für <b>Nebenprodukte</b> oder Zusammenfassungsstrukturen definieren (die entsprechenden Werte sind in der Datendefinition getrennt): <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GValidate</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GValidate</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i'</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">o'</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GValidate</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> :+: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i'</span></span></span><span class="hljs-class">) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">o</span></span></span><span class="hljs-class"> :+: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">o'</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gvalidate (<span class="hljs-type"><span class="hljs-type">L1</span></span> l) = <span class="hljs-type"><span class="hljs-type">L1</span></span> &lt;$&gt; gvalidate l gvalidate (<span class="hljs-type"><span class="hljs-type">R1</span></span> r) = <span class="hljs-type"><span class="hljs-type">R1</span></span> &lt;$&gt; gvalidate r <span class="hljs-meta"><span class="hljs-meta">{-# INLINE gvalidate #-}</span></span></code> </pre> <br>  Da es uns nicht <b>wichtig ist</b> , Metadaten zu finden, können wir <b>GValidate io</b> einfach über den Metadatenkonstruktor definieren: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GValidate</span></span></span><span class="hljs-class"> io =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GValidate</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_a</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_b</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_a'</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_b'</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">o</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gvalidate (<span class="hljs-type"><span class="hljs-type">M1</span></span> x) = <span class="hljs-type"><span class="hljs-type">M1</span></span> &lt;$&gt; gvalidate x <span class="hljs-meta"><span class="hljs-meta">{-# INLINE gvalidate #-}</span></span></code> </pre> <br>  Jetzt bleiben uns uninteressante Strukturen für eine vollständige Beschreibung.  Wir werden ihnen die folgenden trivialen Instanzen für Nichtwohnungsarten ( <b>V1</b> ) und für Designer ohne Parameter ( <b>U1</b> ) zur Verfügung stellen: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GValidate</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">V1</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">V1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gvalidate = undefined <span class="hljs-meta"><span class="hljs-meta">{-# INLINE gvalidate #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GValidate</span></span> <span class="hljs-type"><span class="hljs-type">U1</span></span> <span class="hljs-type"><span class="hljs-type">U1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gvalidate <span class="hljs-type"><span class="hljs-type">U1</span></span> = <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-type"><span class="hljs-type">U1</span></span> <span class="hljs-meta"><span class="hljs-meta">{-# INLINE gvalidate #-}</span></span></code> </pre> <br>  Die Verwendung von <b>undefined</b> ist hier sicher, da es nur mit einem Wert von <b>V1</b> aufgerufen werden kann.  Zum Glück ist <b>V1</b> unbewohnt und nicht initialisiert, so dass dies niemals passieren kann, was bedeutet, dass wir moralisch richtig mit <b>undefiniert umgehen</b> . <br><br>  Jetzt, da wir diesen ganzen Mechanismus haben, können wir ohne weiteres endlich eine nicht allgemeine Version der Validierung schreiben: <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE FlexibleContexts #-}</span></span> validate :: ( <span class="hljs-type"><span class="hljs-type">Generic</span></span> (f <span class="hljs-type"><span class="hljs-type">Maybe</span></span>) , <span class="hljs-type"><span class="hljs-type">Generic</span></span> (f <span class="hljs-type"><span class="hljs-type">Identity</span></span>) , <span class="hljs-type"><span class="hljs-type">GValidate</span></span> (<span class="hljs-type"><span class="hljs-type">Rep</span></span> (f <span class="hljs-type"><span class="hljs-type">Maybe</span></span>)) (<span class="hljs-type"><span class="hljs-type">Rep</span></span> (f <span class="hljs-type"><span class="hljs-type">Identity</span></span>)) ) =&gt; f <span class="hljs-type"><span class="hljs-type">Maybe</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> (f <span class="hljs-type"><span class="hljs-type">Identity</span></span>) validate = fmap to . gvalidate . from</code> </pre> <br>  Jedes Mal können Sie ein breites Lächeln erhalten, wenn die Signatur für die Funktion länger als die tatsächliche Implementierung ist.  Dies bedeutet, dass wir einen Compiler beauftragt haben, Code für uns zu schreiben.  Was hier für die Validierung wichtig ist, ist, dass die <b>Person</b> nicht erwähnt wird.  Diese Funktion funktioniert für jeden Typ, der als qualitativ hochwertige Daten definiert ist.  Voila! <br><br><h3>  Zusammenfassung </h3><br>  Das ist alles für heute Jungs.  Wir haben uns mit der Idee qualitativ hochwertiger Daten vertraut gemacht, festgestellt, dass sie dem auf traditionellere Weise definierten Datentyp vollständig entsprechen, und einen Blick darauf geworfen, was mit diesem Ansatz möglich ist. <br><br>  Sie können damit alle Arten von erstaunlichen Dingen ausführen, z. B.: Objektive für beliebige Datentypen generieren, ohne auf Template Haskell zurückgreifen zu müssen;  <b>Reihenfolge</b> nach Datentyp;  und verfolgen automatisch Abhängigkeiten für die Verwendung von Datensatzfeldern. <br><br>  Glückliche Anwendung der hohen Geburt! <br><br>  <i>Original: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Höhere Daten</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429104/">https://habr.com/ru/post/de429104/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429090/index.html">Einführung in verstärktes Lernen</a></li>
<li><a href="../de429092/index.html">Warum ist Stealth im Weltraum immer noch da?</a></li>
<li><a href="../de429094/index.html">Directional Sound: Technologie, die Kopfhörer ersetzen kann - wie es funktioniert</a></li>
<li><a href="../de429096/index.html">Antiquitäten: ZX Spectrum, Kassettenprogramme und High Definition</a></li>
<li><a href="../de429102/index.html">Verkauf von Elektrofahrzeugen in Kanada</a></li>
<li><a href="../de429106/index.html">GUS für Infrastruktur</a></li>
<li><a href="../de429108/index.html">Google: Das Entfernen von "Raubkopien" -Links aus der Ausgabe löst das Problem illegaler Inhalte nicht</a></li>
<li><a href="../de429110/index.html">CSS-Tipps, die Sie in Tutorials wahrscheinlich nicht finden</a></li>
<li><a href="../de429112/index.html">So bestehen Sie einen Cyber-Test am Checkpoint</a></li>
<li><a href="../de429114/index.html">So bestehen Sie einen Cyber-Test am Checkpoint Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>