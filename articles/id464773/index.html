<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèΩ üó≥Ô∏è ‚òùüèº Asinkron Naskah dalam Aplikasi Internet Kaya dan Dekorator untuk Memeranginya ü§∞üèº üèóÔ∏è üíÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sejak munculnya async / await , Typescript telah menerbitkan banyak artikel yang memuji pendekatan pengembangan ini ( hackernoon , blog.bitsrc.io , ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asinkron Naskah dalam Aplikasi Internet Kaya dan Dekorator untuk Memeranginya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464773/"><p> Sejak munculnya <code>async</code> / <code>await</code> , Typescript telah menerbitkan banyak artikel yang memuji pendekatan pengembangan ini ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hackernoon</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog.bitsrc.io</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com</a> ).  Kami menggunakannya sejak awal di sisi klien (ketika ES6 Generator mendukung kurang dari 50% browser).  Dan sekarang saya ingin berbagi pengalaman saya, karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eksekusi paralel</a> tidak semua yang baik untuk diketahui di sepanjang jalan ini. </p><a name="habracut"></a><br><p>  Saya tidak begitu suka artikel terakhir: sesuatu mungkin tidak bisa dimengerti.  Sebagian karena fakta bahwa saya tidak dapat memberikan kode kepemilikan - hanya untuk menguraikan pendekatan umum.  Oleh karena itu: </p><br><ul><li>  jangan ragu untuk menutup tab tanpa membaca </li><li>  jika Anda mengelolanya, mintalah detail yang tidak jelas </li><li>  Saya dengan senang hati akan menerima saran dan kritik dari yang paling gigih dan sepenuhnya ditemukan sampai saat ini. </li></ul><br><p>  <strong>Daftar teknologi inti:</strong> </p><br><ul><li>  Proyek ini ditulis terutama dalam naskah menggunakan beberapa perpustakaan Javascript.  Perpustakaan utama adalah ExtJS.  Ini lebih rendah dalam hal fashionable untuk Bereaksi, tetapi paling cocok untuk produk perusahaan dengan antarmuka yang kaya: banyak komponen yang sudah jadi, tabel yang dirancang dengan baik di luar kotak, ekosistem kaya produk terkait untuk menyederhanakan pengembangan. </li><li>  Server multithreaded asinkron. </li><li>  RPC melalui Websocket digunakan sebagai transportasi antara klien dan server.  Implementasinya mirip dengan .NET WCF. <br><ul><li>  Objek apa pun adalah layanan. </li><li>  Objek apa pun dapat ditransmisikan oleh nilai dan referensi. </li></ul></li><li>  Antarmuka permintaan data menyerupai GraphQL dari Facebook, hanya pada Filescript. </li><li>  Komunikasi dua arah: inisialisasi pembaruan data dapat diluncurkan baik dari klien maupun dari server. </li><li>  Kode asinkron ditulis secara berurutan melalui penggunaan fungsi <code>async</code> / <code>await</code> Typercipt. </li><li>  API server dihasilkan dalam Script: jika diubah, build akan segera menampilkannya jika terjadi kesalahan. </li></ul><br><p>  <strong>Apa outputnya</strong> </p><br><p>  Saya akan memberi tahu Anda bagaimana kami bekerja dengan ini dan apa yang kami lakukan untuk pelaksanaan kode asinkron yang aman dan tidak bersaing: dekorator Typesrcipt kami yang menerapkan fungsi antrian.  Dari dasar-dasar ke solusi kondisi ras dan kesulitan lain yang muncul selama proses pengembangan. </p><br><h2 id="kak-strukturirovany-dannye-poluchaemye-s-servera">  Bagaimana data yang diterima dari server disusun </h2><br><p>  Server mengembalikan objek induk yang berisi data (objek lain, koleksi objek, baris, dll.) Dalam propertinya dalam bentuk grafik.  Hal ini disebabkan, antara lain, ke aplikasi itu sendiri: </p><br><ul><li>  itu membuat analisis data / ML grafik diarahkan dari node handler. </li><li>  setiap node pada gilirannya dapat berisi grafik yang disematkan sendiri </li><li>  grafik memiliki dependensi: node dapat "diwarisi", dan node baru dibuat oleh "kelas" mereka. </li></ul><br><p>  Tetapi struktur permintaan dalam bentuk grafik dapat diterapkan di hampir semua aplikasi, dan GraphQL, sejauh yang saya tahu, juga menyebutkan ini dalam spesifikasinya. </p><br><p>  Contoh struktur data: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   interface IParent { ServerId: string; Nodes: INodes; // INodes -     INode } //     interface INodes&lt;TNode extends INode&gt; extends ICollection { IndexOf(item: TNode): number; Item(index: number): TNode; // ...     } //    interface INode extends IItem { Guid: string; Name: string; DisplayName: string; Links: ILinks; // ILinks -    Info: INodeInfo; //    -  } //      interface ILink { Guid: string; DisplayName: string; SourceNode: INode; //   -  TargetNode: INode; //   ,   } interface INodeInfo { Component: IComponent; ConfigData: IData; }</span></span></code> </pre><br><h2 id="kak-klient-poluchaet-dannye">  Bagaimana cara klien menerima data </h2><br><p>  Sederhana: ketika Anda meminta properti dari objek jenis non-skalar, RPC mengembalikan <code>Promise</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Nodes = Parent.Nodes; <span class="hljs-comment"><span class="hljs-comment">// Nodes -&gt; Promise&lt;INodes&gt;</span></span></code> </pre><br><h3 id="asinhronnost-bez-callback-hell">  Sinkronisasi tanpa "Panggilan Balik Neraka". </h3><br><p>  Untuk mengatur kode asinkron "sekuensial", digunakan fungsi Script <code>async</code> / <code>await</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowNodes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parent: IParent</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    let Nodes = await parent.Nodes; //       await Nodes.forEachParallel(async function(node): Promise&lt;void&gt; { await RenderNode(node); //          }); }</span></span></code> </pre><br><p>  Tidak masuk akal untuk memikirkannya secara rinci, pada hub sudah ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">materi yang</a> cukup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rinci</a> .  Mereka muncul di belakang pada 2016.  Kami telah menggunakan pendekatan ini sejak muncul di cabang fitur dari repositori Typecript, jadi kami telah mendapatkan benjolan untuk waktu yang lama dan sekarang kami bekerja dengan senang hati.  Untuk beberapa waktu sekarang, dan dalam produksi. </p><br><p>  Secara singkat, esensi bagi mereka yang tidak terbiasa dengan subjek: </p><br><p>  Segera setelah Anda menambahkan kata kunci <code>async</code> ke fungsi, itu akan secara otomatis mengembalikan <code>Promise&lt;_&gt;</code> .  Fitur fungsi tersebut: </p><br><ul><li>  Ekspresi di dalam fungsi <code>async</code> dengan <code>await</code> (yang mengembalikan <code>Promise</code> ) akan menghentikan pelaksanaan fungsi dan melanjutkan setelah menyelesaikan <code>Promise</code> diharapkan. </li><li>  Jika pengecualian terjadi dalam fungsi <code>async</code> , <code>Promise</code> dikembalikan akan ditolak dengan pengecualian ini. </li><li>  Saat mengkompilasi dalam kode Javascript, akan ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">generator</a> untuk standar ES6 ( <code>function*</code> alih-alih <code>async function</code> dan <code>yield</code> alih-alih <code>await</code> ) atau kode menakutkan dengan <code>switch</code> untuk ES5 (mesin negara).  <code>await</code> adalah kata kunci yang menunggu hasil dari janji.  Pada saat rapat, selama eksekusi kode, fungsi <code>ShowNodes</code> berhenti, dan sambil menunggu data, Javascript dapat menjalankan beberapa kode lainnya. </li></ul><br><p>  Dalam kode di atas, koleksi memiliki metode <code>forEachParallel</code> yang memanggil callback asinkron untuk setiap node secara paralel.  Pada saat yang sama, <code>await</code> sebelum <code>Nodes.forEachParallel</code> akan menunggu semua panggilan balik.  Di dalam implementasinya - <code>Promise.all</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *            * @param items  * @param callbackfn  * @param [thisArg]   ,      this  callbackfn */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEachParallel</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items: IItemArray&lt;T&gt;, callbackfn: (value: T, index: int, items: IItemArray&lt;T&gt;</span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">&gt;, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thisArg</span></span></span><span class="hljs-function">?: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xCount = items ? <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> items.Count : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!xCount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xActions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> | any&gt;&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xCount</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">for</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">let</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; xCount; i++</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">let</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xItem</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Item</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xActions</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">] = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecuteCallback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xItem, callbackfn, i, items, thisArg</span></span></span><span class="hljs-function">); } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">await</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Promise</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">all</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xActions</span></span></span><span class="hljs-function">); } /**   </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">   </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callbackfn</span></span></span><span class="hljs-function"> */ </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecuteCallback</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Promise</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; | T, callbackfn: (value: T, index: int, items: IItemArray&lt;T&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> | any&gt;, <span class="hljs-attr"><span class="hljs-attr">index</span></span>: int, <span class="hljs-attr"><span class="hljs-attr">items</span></span>: IItemArray&lt;T&gt;, thisArg?: any): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xItem = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> item; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> callbackfn.call(thisArg, xItem, index, items); }</code> </pre><br><p>  Ini adalah gula sintaksis: metode seperti itu harus digunakan tidak hanya untuk koleksi mereka, tetapi juga untuk array Javascript standar. </p><br><p>  Fungsi <code>ShowNodes</code> terlihat sangat tidak optimal: ketika kami meminta entitas lain, kami menunggu setiap kali.  Kemudahannya adalah kode tersebut dapat ditulis dengan cepat, sehingga pendekatan ini baik untuk pembuatan prototipe cepat.  Di versi final, Anda perlu menggunakan bahasa permintaan untuk mengurangi jumlah panggilan ke server. </p><br><h2 id="yazyk-zaprosov">  Bahasa Pertanyaan </h2><br><p>  Ada beberapa fungsi yang digunakan untuk "membangun" permintaan data dari server.  Mereka ‚Äúmemberi tahu‚Äù server mana simpul dari grafik data yang akan dikembalikan dalam respons: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *       item    Promise  , *      properties */</span></span> selectAsync&lt;T extends IItem&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item: T, properties: (</span></span></span><span class="hljs-function">) =&gt;</span></span> any[]): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;T&gt;; <span class="hljs-comment"><span class="hljs-comment">/** *   items,       properties */</span></span> selectAsyncAll&lt;T extends ICollection&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items: T[], properties: (</span></span></span><span class="hljs-function">) =&gt;</span></span> any[]): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;T[]&gt;; <span class="hljs-comment"><span class="hljs-comment">/**    selectAsync     */</span></span> select&lt;T&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item: T, properties: (</span></span></span><span class="hljs-function">) =&gt;</span></span> any[]): T; <span class="hljs-comment"><span class="hljs-comment">/**    selectAsync     */</span></span> selectAll&lt;T&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items: T[], properties: (</span></span></span><span class="hljs-function">) =&gt;</span></span> any[]): T[];</code> </pre><br><p>  Sekarang mari kita lihat aplikasi fungsi-fungsi ini untuk meminta data tertanam yang diperlukan dengan satu panggilan ke server: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowNodes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parentPoint: IParent</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       IParent -    selectAsync ( // Promise,  ). let Parent = await selectAsync(parentPoint, parent =&gt; [ //           selectAll(parent.Nodes, nodes =&gt; [node.Name, node.DisplayName]) // [node.Name, node.DisplayName] -        ]); //      Parent.Nodes ... }</span></span></code> </pre><br><p>  Contoh permintaan yang sedikit lebih kompleks dengan informasi yang tertanam mendalam: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     parent.Nodes  selectAsyncAll,    let Parent = await selectAsyncAll(parent.Nodes, nodes =&gt; [ //    : select(node, node =&gt; [ node.Name, node.DisplayName, selectAll(node.Links, link =&gt; [ link.Guid, link.DisplayName, select(link.TargetNode, targetNode =&gt; [targetNode.Guid]) ]), select(node.Info, info =&gt; [info.Component]) //    IInfo    IComponent,   ,   ,        ]) ]);</span></span></code> </pre><br><p>  Bahasa permintaan membantu menghindari permintaan yang tidak perlu ke server.  Tetapi kodenya tidak pernah sempurna, dan pasti akan berisi beberapa permintaan kompetitif dan, sebagai hasilnya, kondisi balapan. </p><br><h2 id="race-condition-i-puti-resheniya">  Kondisi dan Solusi Ras </h2><br><p>  Karena kami berlangganan acara server dan menulis kode dengan sejumlah besar permintaan asinkron, kondisi balapan dapat terjadi ketika fungsi <code>FuncOne</code> <code>async</code> terganggu, menunggu <code>Promise</code> .  Pada saat ini, peristiwa server (atau dari aksi pengguna berikutnya) dapat datang dan, setelah dijalankan secara kompetitif, ubah model pada klien.  Kemudian <code>FuncOne</code> setelah menyelesaikan janji, dapat mengubah, misalnya, ke sumber daya yang sudah dihapus. </p><br><p>  Bayangkan situasi yang disederhanakan: objek <code>IParent</code> memiliki delegasi server <code>IParent</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/**   */</span></span> Parent.OnSynchronize.AddListener(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  .   ,  . });</span></span></code> </pre><br><p>  Disebut ketika daftar node <code>INodes</code> di server diperbarui.  Kemudian, dalam skenario berikut, kondisi balapan dimungkinkan: </p><br><ol><li>  Kami menyebabkan penghapusan simpul yang tidak sinkron dari klien, menunggu penyelesaian untuk menghapus objek klien <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnClickRemoveNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node: INode</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> removedOnServer: boolean = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Parent.RemoveNode(node); <span class="hljs-comment"><span class="hljs-comment">//     if (removedOnServer) .... }</span></span></code> </pre> </li><li>  Melalui <code>Parent.OnSynchronize</code> , pembaruan acara daftar simpul terjadi. </li><li>  <code>Parent.OnSynchronize</code> diproses dan menghapus objek klien. </li><li>  <code>async OnClickRemoveNode()</code> terus dijalankan setelah <code>await</code> pertama dan upaya dilakukan untuk menghapus objek klien yang sudah dihapus. </li></ol><br><p>  Anda bisa melakukan pengecekan tentang keberadaan objek klien di <code>OnClickRemoveNode</code> .  Ini adalah contoh yang disederhanakan dan di dalamnya pemeriksaan serupa adalah normal.  Tetapi bagaimana jika rantai panggilan lebih rumit?  Oleh karena itu, menggunakan pendekatan yang sama setelah setiap <code>await</code> adalah praktik yang buruk: </p><br><ul><li>  Kode yang kembung sangat rumit untuk didukung dan diperluas. </li><li>  Kode tidak berfungsi sebagaimana dimaksud: penghapusan di <code>OnClickRemoveNode</code> , dan penghapusan aktual objek klien terjadi di tempat lain.  Seharusnya tidak ada pelanggaran terhadap urutan yang ditentukan oleh pengembang, jika tidak akan ada kesalahan regresi. </li><li>  Ini tidak cukup andal: jika Anda lupa melakukan pemeriksaan di suatu tempat, maka akan ada kesalahan.  Bahayanya adalah, pertama-tama, bahwa pemeriksaan yang dilupakan mungkin tidak menyebabkan kesalahan secara lokal dan dalam lingkungan pengujian, dan bagi pengguna dengan penundaan jaringan yang lebih lama akan terjadi. </li><li>  Dan jika pengontrol yang dimiliki penangan ini dapat dihancurkan?  Setelah masing-masing <code>await</code> untuk memeriksa kehancurannya? </li></ul><br><p>  Pertanyaan lain muncul: bagaimana jika ada banyak metode kompetitif serupa?  Bayangkan ada lebih banyak: </p><br><ul><li>  Menambahkan Node </li><li>  Pembaruan node </li><li>  Tambah / Hapus Tautan </li><li>  Metode Konversi Beberapa Node </li><li>  Perilaku aplikasi yang kompleks: kami mengubah status satu simpul dan server mulai memperbarui simpul yang bergantung padanya. </li></ul><br><p>  Diperlukan implementasi arsitektur, yang pada prinsipnya menghilangkan kemungkinan kesalahan karena kondisi ras, aksi pengguna paralel, dll.  Solusi yang tepat untuk menghilangkan perubahan simultan model dari klien atau server adalah dengan mengimplementasikan bagian penting dengan antrian panggilan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dekorator pengetik naskah</a> akan berguna di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> untuk menandai fungsi pengontrol asinkron yang kompetitif secara deklaratif. </p><br><p>  <strong>Kami menguraikan persyaratan dan fitur utama dari dekorator tersebut:</strong> </p><br><ol><li>  Di dalam, antrian panggilan ke fungsi asinkron harus diterapkan.  Bergantung pada jenis dekorator, panggilan fungsi dapat antri atau ditolak jika ada panggilan lain di dalamnya. </li><li>  Fungsi yang ditandai akan memerlukan konteks eksekusi untuk mengikat ke antrian.  Anda harus membuat antrian secara eksplisit, atau melakukannya secara otomatis berdasarkan Tampilan yang dimiliki pengontrol. </li><li>  Informasi diperlukan tentang penghancuran instance controller (misalnya, properti <code>IsDestroyed</code> ).  Untuk mencegah dekorator membuat panggilan antrian setelah pengontrol dihancurkan. </li><li>  Untuk pengontrol tampilan, kami menambahkan fungsionalitas menerapkan masker transparan untuk mengecualikan tindakan pada saat antrian dieksekusi dan secara visual menunjukkan pemrosesan sedang berlangsung. </li><li>  Semua dekorator harus diakhiri dengan panggilan ke <code>Promise.done()</code> .  Dalam metode ini, Anda perlu menerapkan <code>handler</code> pengecualian yang tidak ditangani.  Suatu hal yang sangat berguna: <br><ul><li>  pengecualian yang terjadi dalam <code>Promise</code> tidak tertangkap oleh penangan kesalahan standar (yang, misalnya, menampilkan jendela dengan teks dan jejak taruhan), jadi Anda mungkin tidak melihatnya (jika Anda tidak memantau konsol sepanjang waktu selama pengembangan).  Dan pengguna tidak akan melihat mereka sama sekali - ini akan membuat dukungan sulit.  Catatan: dimungkinkan untuk berlangganan untuk menangani acara <code>unhandledrejection</code> yang <code>unhandledrejection</code> ditangani, tetapi masih hanya Chrome dan Edge yang mendukungnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'unhandledrejection'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// handling... });</span></span></code> </pre> </li><li>  karena kami menandai fungsi pengendali event <code>async</code> tertinggi sebagai dekorator, kami mendapatkan seluruh kesalahan jejak tumpukan. </li></ul></li></ol><br><p>  Sekarang kami memberikan daftar perkiraan dekorator tersebut dengan deskripsi dan kemudian menunjukkan bagaimana mereka dapat diterapkan. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * : * 1.      * 2.      ,   . * *  ,  :   ,         */</span></span> @Lock <span class="hljs-comment"><span class="hljs-comment">/** * : *     ,     . * *  ,     :   ,   . */</span></span> @LockQueue <span class="hljs-comment"><span class="hljs-comment">/** *  LockQueue .  -         * *   ,       . ,   . */</span></span> @LockBetween <span class="hljs-comment"><span class="hljs-comment">/** * : *       ,   . *     . :     ,     300 .       . */</span></span> @LockDeferred(<span class="hljs-number"><span class="hljs-number">300</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ,    ,     : interface ILockTarget { /** * ,   View,   .   ,        ,     ,        */ GetControllerView?(): IView; /**  true     */ IsDestroyed: boolean; }</span></span></code> </pre><br><p>  Uraiannya cukup abstrak, tetapi begitu Anda melihat contoh penggunaan dengan penjelasan, semuanya akan menjadi lebih jelas: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GraphController</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ILockTarget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** ,      .      */</span></span> private View: IView; public GetControllerView(): IView { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.View; } <span class="hljs-comment"><span class="hljs-comment">/**      . */</span></span> @Lock private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnClickRemoveNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**     . */</span></span> @Lock private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnClickRemoveLink(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**     */</span></span> @Lock private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnClickAddNewNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    " " */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerUpdateNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    " " */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerAddLink(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    " " */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerAddNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    -   */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerRemoveNode(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    -       */</span></span> @LockBetween private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerSynchronize(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**    -    (/warning/error/...) */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnServerUpdateNodeStatus(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } <span class="hljs-comment"><span class="hljs-comment">/**       */</span></span> @LockDeferred(<span class="hljs-number"><span class="hljs-number">300</span></span>) private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnSearchFieldChange(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { ... } }</code> </pre><br><p>  Sekarang kita akan menganalisis beberapa skenario tipikal dari kemungkinan kesalahan dan penghapusannya oleh dekorator: </p><br><ol><li>  Pengguna memulai tindakan: <code>OnClickRemoveNode</code> , <code>OnClickRemoveLink</code> .  Untuk pemrosesan yang tepat, perlu bahwa tidak ada penangan pelaksana lainnya dalam antrian (baik klien atau server).  Kalau tidak, misalnya, kesalahan seperti itu dimungkinkan: <br><ul><li>  Model pada klien masih diperbarui ke kondisi server saat ini </li><li>  Kami memulai penghapusan objek sebelum pembaruan selesai (ada penangan <code>OnServerSynchronize</code> dalam antrian).  Tetapi objek ini sebenarnya sudah tidak ada lagi - hanya sinkronisasi penuh belum selesai dan masih ditampilkan pada klien. <br>  Oleh karena itu, semua tindakan yang dilakukan oleh pengguna, Penghias <code>Lock</code> harus menolak jika ada penangan lain dalam antrian dengan konteks antrian yang sama.  Mengingat bahwa server tidak sinkron, ini sangat penting.  Ya, Websocket mengirimkan permintaan secara berurutan, tetapi jika klien memecah urutan, kami mendapatkan kesalahan di server. </li></ul></li><li>  Kami memulai penambahan node: <code>OnClickAddNewNode</code> .  <code>OnServerSynchronize</code> , peristiwa <code>OnServerAddNode</code> berasal dari server. <br><ul><li>  <code>OnClickAddNewNode</code> mengambil antrian (jika ada sesuatu di dalamnya, <code>OnClickAddNewNode</code> <code>Lock</code> metode ini akan menolak panggilan) </li><li>  <code>OnServerSynchronize</code> , <code>OnServerAddNode</code> , dijalankan secara berurutan setelah <code>OnClickAddNewNode</code> , tidak bersaing dengannya. </li></ul></li><li>  Antrian memiliki <code>OnServerUpdateNode</code> dan <code>OnServerUpdateNode</code> .  Misalkan selama eksekusi yang pertama, pengguna menutup <code>GraphController</code> .  Maka panggilan kedua ke <code>OnServerUpdateNode</code> tidak boleh dilakukan secara otomatis agar tidak mengambil tindakan pada controller yang hancur, yang dijamin akan menyebabkan kesalahan.  Untuk ini, antarmuka <code>ILockTarget</code> telah <code>IsDestroyed</code> - dekorator memeriksa bendera tanpa mengeksekusi handler berikutnya dari antrian. <br>  Keuntungan: tidak perlu menulis <code>if (!this.IsDestroyed())</code> setelah masing-masing <code>await</code> . </li><li>  Perubahan ke beberapa node dimulai.  <code>OnServerSynchronize</code> , peristiwa <code>OnServerUpdateNode</code> berasal dari server.  Eksekusi kompetitif mereka akan menyebabkan kesalahan yang tidak dapat direproduksi.  Tapi sejak itu  <code>LockQueue</code> mereka ditandai oleh <code>LockBetween</code> dan <code>LockBetween</code> , mereka akan dieksekusi secara berurutan. </li><li>  Bayangkan bahwa simpul dapat memiliki grafik simpul bersarang di dalamnya.  <code>GraphController #1</code> ,       ‚Äî   <code>GraphController #2</code> . , <code>GraphController</code> -    ,   (  ‚Äî         ), ..     .  : <br><ul><li>  </li><li>    </li><li>    <code>GraphController #2</code> ,     ,    . </li></ul></li><li> <code>OnSearchFieldChange</code>   ,       .         -  .  <code>@LockDeferred(300)</code>     300 :         ,     ,    300 .  ,       .  : <br><ul><li>   ,   500 ,         .     ‚Äî        <code>OnSearchFieldChange</code> ,     . </li><li>      <code>OnSearchFieldChange</code>    ‚Äî        ,   . </li></ul></li></ol><br><h2 id="chto-nuzhno-znat-pri-ispolzovanii-dekoratorov">       </h2><br><ol><li>  Deadlock:     <code>Handler1</code> ,    ,   <code>await</code>   <code>Handler2</code> ,  <code>LockQueue</code> ,    <code>Handler2</code> ‚Äî <code>Handler1</code>    . </li><li>  ,     View      . :            ,      ‚Äî                . </li></ol><br><h2 id="profilirovanie-zaprosov-k-serveru">     </h2><br><p>    ,     ,        .  : </p><br><ul><li>       - <code>&lt;Class&gt;</code> . <code>&lt;Method&gt;</code> =&gt; <code>&lt;Time&gt;</code> (  ). </li><li>       . </li><li>        . </li></ul><br><h2 id="desert">  </h2><br><p> ,    ,           ,    .        ?         ?  : </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GraphController</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ILockTarget</span></span></span><span class="hljs-class"> </span></span>{ private View: IView; public GetControllerView(): IView { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.View; } <span class="hljs-comment"><span class="hljs-comment">/**     . */</span></span> @Lock private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> RunBigDataCalculations(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Start(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UpdateSmth(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> End(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> CleanUp(); } <span class="hljs-comment"><span class="hljs-comment">/**   . */</span></span> @LockQueue private <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> OnChangeNodeState(node: INode): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> GetNodeData(node); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UpdateNode(node); } }</code> </pre><br><p>   : </p><br><ol><li>  <code>RunBigDataCalculations</code> . </li><li>  <code>await Start();</code> </li><li>   /  (  ) </li><li>   <code>await Start();</code> ,   <code>await UpdateSmth();</code>      . </li></ol><br><p> : </p><br><ol><li>  <code>RunBigDataCalculations</code> . </li><li>    <code>OnChangeNodeState</code> ,          (..  ). </li><li>   <code>await GetNodeData(node);</code> </li><li>   /  (  ) </li><li>   <code>await GetNodeData(node);</code> ,   <code>await UpdateNode(node);</code>      . </li></ol><br><p>      - .  : </p><br><ul><li>   : </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *       ,      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface IQueuedDisposableLockTarget extends ILockTarget { <span class="hljs-comment"><span class="hljs-comment">/**     . Lock          IsDisposing() === true */</span></span> IsDisposing(): boolean; SetDisposing(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; }</code> </pre> <br><ul><li>        : </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueuedDispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">controller: IQueuedDisposableLockTarget</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      let xQueue = GetQueue(controller); // 1. ,     -,   -   if (xQueue.Empty) { controller.Dispose(); return; } // 2.  ,     " ",     ,   . controller.SetDisposing(); // 3.   finally   xQueue.finally(() =&gt; { debug.assert(!IsDisposed(controller), "-      ,  "); controller.Dispose(); }); }</span></span></code> </pre><br><p>  ,          .    <code>QueuedDispose</code>     : </p><br><ul><li>         .       . </li><li>   <code>QueuedDispose</code>     <code>controller</code> .         ‚Äî  ExtJS     . </li></ul><br><p> <strong></strong> </p><br><p>  ,          , ..         . ,      ?    ,  . </p><br><p>    ,      : </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    vk.com</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    Telegram</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464773/">https://habr.com/ru/post/id464773/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464759/index.html">Lusinan Buku Agile Yang Diperlukan Manajer Proyek pada 2020</a></li>
<li><a href="../id464761/index.html">Mod kecil mengubah Tesla menjadi stasiun pengawas video</a></li>
<li><a href="../id464763/index.html">Tolok ukur untuk server di Linux: pilihan alat terbuka</a></li>
<li><a href="../id464765/index.html">Mengkonfigurasi FreePBX + GoIP</a></li>
<li><a href="../id464769/index.html">Bagaimana Badoo memungkinkan untuk memberikan 200 ribu foto per detik</a></li>
<li><a href="../id464775/index.html">21 September Badoo Rapat PHP # 3: Kinerja</a></li>
<li><a href="../id464777/index.html">Mengapa const tidak mempercepat kode C / C ++?</a></li>
<li><a href="../id464779/index.html">Tentang lebah hedonis, cara orang membuatnya bekerja dan drone</a></li>
<li><a href="../id464781/index.html">Smart TV: CRT ke HDR</a></li>
<li><a href="../id464785/index.html">Manfaat Langsung Menuju Yang Tidak Kompetitif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>