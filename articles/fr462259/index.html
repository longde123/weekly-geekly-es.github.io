<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàµ üßëüèº‚Äçü§ù‚Äçüßëüèº üë®‚Äçüî¨ Faire un contr√¥leur pour une maison intelligente üëæ üîµ üöç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous fabriquons un contr√¥leur pour une maison intelligente et pas seulement. 

 Dans un article pr√©c√©dent, j'ai d√©crit le d√©veloppement du syst√®me dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Faire un contr√¥leur pour une maison intelligente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462259/">  Nous fabriquons un contr√¥leur pour une maison intelligente et pas seulement. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dans un article pr√©c√©dent,</a> j'ai d√©crit le d√©veloppement du syst√®me dans son ensemble.  Dans ce document, je d√©crirai le d√©veloppement d'un contr√¥leur responsable de l'interrogation des capteurs et des modules d'E / S.  "Pourquoi r√©inventer la roue?"  - demandez-vous.  Premi√®rement, c'est int√©ressant, et deuxi√®mement, curieusement, il n'y a pas de solution OpenSource pour un tel contr√¥leur couvrant √† la fois le logiciel et le mat√©riel.  L'article est destin√© aux personnes qui connaissent un peu l'√©lectronique et le d√©veloppement Linux embarqu√©. <br><br>  Faire un contr√¥leur, dites-vous, est si compliqu√© - vous devez faire une carte, √©crire un logiciel, imprimer le bo√Ætier.  Mais en r√©alit√©, tout est un peu plus compliqu√©, c'est ce que √ßa m'a apport√©, mais vous avez raison en principe: <br><a name="habracut"></a><br>  1. mat√©riel du contr√¥leur <br><br>  - choix de la carte cpu pour le contr√¥leur <br>  - choix du contr√¥leur IO <br>  - choix de l'alimentation <br>  - sch√©ma fonctionnel du contr√¥leur <br>  - d√©veloppement d'un tableau crois√© pour le contr√¥leur <br>  - d√©veloppement de cartes pour modules RS-485 <br>  - production de planches <br><br>  2. logiciel pour le contr√¥leur <br><br>  - choix du syst√®me de construction pour le noyau linux et rootfs <br>  - structure de partition de la carte SD <br>  - choix du bootloader et chargement des rootfs n√©cessaires <br>  - changements dans l'arborescence des appareils <br>  - le choix d'un syst√®me de collecte des d√©bits n√©goci√©s <br>  - √©crire un syst√®me de build <br>  - √©crire un noyau de communication <br>  - √©criture de la passerelle mqtt (points de contr√¥leur discrets / analogiques -&gt; rubriques mqtt) <br>  - √©crire un analyseur Google et cr√©er un fichier de configuration json pour la passerelle <br>  - √©crire un moniteur de points pour acc√©der aux points du contr√¥leur <br>  - monter le syst√®me de fichiers en lecture seule <br><br>  3. bo√Ætier de contr√¥leur <br><br>  - ce qui devrait √™tre, connecteurs, refroidissement, si√®ges pour une planche, hypoth√®ques pour clips pour supports sur un dinrake. <br>  - conception et impression <br><br>  Quelques mots sur le mat√©riel. <br><br>  Probablement, seuls les plus d√©sesp√©r√©s prennent maintenant un processeur s√©par√©, une m√©moire, un flash, un contr√¥leur d'alimentation, quelques centaines de composants suppl√©mentaires et commencent √† tout sculpter ensemble.  Les autres utilisent les fruits du travail des autres, c'est plus rapide et plus facile.  Il vous suffit d'ouvrir un navigateur et d'√©crire ¬´ordinateur monocarte¬ª et de passer le reste de la journ√©e √† choisir le bon.  J'avais besoin de beaucoup de ports s√©rie et il est souhaitable que la carte supporte -40 ¬∞ C √† + 85 ¬∞ C, donc le choix s'est port√© sur BeagleBone Black (BBB).  Toujours sur BBB, tous les p√©riph√©riques sont connect√©s √† deux connecteurs PBD de 46 broches par incr√©ments de 2,54, ce qui est pratique pour le prototypage et le d√©veloppement d'une carte crois√©e.  Une carte crois√©e est n√©cessaire pour combiner tous les composants sur une seule carte, pour moi, c'est une carte CPU, une alimentation, un contr√¥leur IO et des cartes de canaux RS485.  De plus, c'est la carte transversale qui doit √™tre fix√©e au bo√Ætier et il y a des connecteurs pour l'alimentation et le c√¢ble RS485. <br><br><img src="https://habrastorage.org/webt/oy/jo/6j/oyjo6jzy2qtidg-9ehm5zmtnqtg.jpeg"><br><br>  Donc, nous avons compris la carte CPU, la prochaine chose √† d√©cider est de savoir s'il est n√©cessaire de mettre un contr√¥leur d'entr√©e / sortie (IO) sur la carte transversale ou non.  Je l'ai pos√© sur le plateau et je ne l'ai pas encore utilis√© avec succ√®s.  La seule chose qu'il fait est de reporter le d√©marrage du BBB pendant 1s apr√®s avoir mis sous tension et sert le bouton de r√©initialisation. <br><br>  L'alimentation du contr√¥leur, j'ai pris le MeanWell NSD10-12S5 pr√™t √† l'emploi, le d√©velopper pour un seul appareil est une entreprise vide de sens, je viens de le ramasser pour la consommation et c'est tout.  Ne faites pas attention √† l'√©cran LCD, il est sur la carte, mais je n'ai pas impl√©ment√© de support. <br><br><img src="https://habrastorage.org/webt/uu/ub/hx/uuubhxrvgg7imxkdmtk6rjsojtu.jpeg"><br><br><img src="https://habrastorage.org/webt/hd/wn/l2/hdwnl2uo05wm6isu1pudumcx8zk.jpeg"><br><br>  Quelques mots sur les cartes canaux RS485. <br><br>  Il y a 4 interfaces BBB s√©rie sur la carte crois√©e.  Vous pouvez donc y mettre tout type de canal dont vous avez besoin, RS485, CAN, module Zigbee ... <br><br>  J'avais besoin de canaux RS485, donc je les ai faits uniquement, ils sont avec contr√¥le automatique de transmission / r√©ception et avec isolation galvanique.  Pourquoi ne pas utiliser le contr√¥le de l'√©metteur-r√©cepteur avec BBB, car TI a officiellement arr√™t√© de prendre en charge le stroboscope pour RS485 dans le pilote de p√©riph√©rique s√©rie.  Vous pouvez trouver un patch pour le pilote, vous pouvez l'ajouter vous-m√™me, mais pourquoi?  Apr√®s avoir rendu le canal autobloquant, vous pouvez le placer sur n'importe quelle carte, par exemple sur RaspberyPi, o√π il n'y a jamais eu un tel support, s'il y en avait, corrigez-moi.  Le stroboscope pour le pilote rs485 est configur√© sur attiny10, bon march√© et joyeux. <br><br>  Nous revenons au logiciel. <br><br>  Choisir un syst√®me de construction pour le noyau linux et rootfs. <br><br>  Il existe plusieurs syst√®mes de ce type, les plus populaires sont Yocto et BuildRoot.  Si vous avez besoin de d√©velopper un grand projet, si vous avez beaucoup de temps et que vous souhaitez √©crire des recettes, alors Yocto est votre choix.  Avec l'aide de BuildRoot, vous pouvez collecter tout ce dont vous avez besoin pour un simple lancement de la carte est tr√®s, tr√®s simple, car  Je fais un syst√®me sur Beaglebone Black (ci-apr√®s BBB) puis: <br><br><ol><li>  lire ce qui est √©crit ici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/en/post/448638</a> </li><li>  nettoyer </li><li>  faire beaglebone_defconfig </li><li>  faire </li></ol><br>  C‚Äôest tout.  Maintenant, tout ce dont vous avez besoin pour faire fonctionner la carte se trouve dans le dossier / buildroot / output / images. <br><br>  Tout semble tr√®s simple et pas int√©ressant, vous pouvez donc faire un peu plus compliqu√©: <br><br><ol><li>  int√©grez buildroot dans votre syst√®me de build, t√©l√©chargez-le avec un script, n'oubliez pas d'utiliser une balise stable et de ne pas prendre le dernier d√©veloppement </li><li>  √©crivez votre defconfig et lancez le script dans le dossier / buildroot / configs avant d'assembler buildroot, n'oubliez pas que tous les defconfigs doivent se terminer par * _defconfig, sinon buildroot ne le voit pas </li><li>  copiez votre post-build.sh dans board / beaglebone / post-build.sh </li><li>  faire pr√©parer un script qui fera n1, n2 et n3 pour vous </li></ol><br>  Par cons√©quent, buildroot g√©n√©rera zImage et rootfs.tar <br><br>  S√©lection de la structure de partition de la carte SD: <br><br>  √Ä ce sujet, je pense qu'il n'est pas n√©cessaire de concentrer beaucoup d'attention. <br>  J'ai fait 4 sections BOOT / ROOT_1 / ROOT_2 / DATA. <br>  La section BOOT contient tout ce dont vous avez besoin pour l'amor√ßage: MLO, barebox.bin, barebox.env, am335x-boneblack.dtb, zImage, boot.txt. <br><br>  ROOT_1 et ROOT_2 contiennent des rootfs, dont la s√©lection est √©crite dans le fichier boot.txt (voir ci-dessous).  Toutes ces partitions sont mont√©es en lecture seule pour √©viter les pannes du syst√®me de fichiers lorsque l'alimentation est coup√©e.  DATA contient des configurations de conception, lors de la modification, il n'est pas n√©cessaire de reconstruire le code. <br><br>  Une telle structure de partitions √† l'avenir facilitera l'√©criture d'un composant de mise √† jour logicielle.  Ce composant remplacera l'une des sections ROOT_1 / ROOT_2, qui n'est pas utilis√©e maintenant, puis modifiera simplement le fichier boot.txt si vous n'avez pas besoin de changer le noyau. <br><br>  Choisir un chargeur de d√©marrage. <br><br>  J'ai eu beaucoup d'exp√©riences avec des bootloaders pour BBB.  Au d√©but, j'ai utilis√©, comme tout le monde, le U-Boot g√©n√©r√© par BuildRoot.  Mais je n'aimais pas √ßa, peut-√™tre, bien s√ªr, c'est une question d'habitude, mais il me semblait que c'√©tait trop, c'est tr√®s lourd et difficile √† configurer.  Ensuite, j'ai pens√© qu'il ne serait pas mauvais de d√©marrer le syst√®me rapidement, en 2-3 secondes, et de d√©poser le X-Loader pour qu'il charge le noyau, j'ai r√©ussi, mais l√† encore il y avait un probl√®me de configuration, et l'heure de d√©part pour moi pas critique (le syst√®me sur systemd d√©marre lentement par lui-m√™me, m√™me si vous supprimez tout ce qui n'est pas n√©cessaire). <br><br>  Au final, je me suis install√© sur barebox, j'ai beaucoup aim√© sa simplicit√©, en plus le site a toute la documentation (www.barebox.org). <br><br>  Par exemple, pour charger rootfs √† partir de la premi√®re ou de la deuxi√®me partition, il vous suffit de: <br><br>  1. dans la section boot, faites le fichier boot.txt qui va exporter une variable de type "export BOOT_NUM = X" <br><br>  2. cr√©ez deux scripts / env / boot / sdb1 / env / boot / sdb2 dans lesquels d√©crire les options de d√©marrage, par exemple: <br><br><pre><code class="plaintext hljs">echo "botting with mmcblk0p2 as rootfs..." global.bootm.image=/boot/zImage global.bootm.oftree=/boot/am335x-boneblack.dtb global.linux.bootargs.console="console=ttyO0,115200" global.linux.bootargs.debug="earlyprintk ignore_loglevel" global.linux.bootargs.base="root=/dev/mmcblk0p2 ro rootfstype=ext4 rootwait"</code> </pre> <br>  3. cr√©er un script / env / boot / sd dans lequel, en fonction de BOOT_NUM, d√©marrer le script sdb1 ou sdb2 <br><br>  4. d√©finissez la variable boot.default <br><br><pre> <code class="plaintext hljs">nv boot.default=sd saveenv</code> </pre> <br>  5. En modifiant encore BOOT_NUM dans boot.txt, nous chargerons rootfs √† partir de la premi√®re ou de la deuxi√®me partition, qui √† l'avenir peut √™tre utilis√©e pour la mise √† jour logicielle. <br><br>  Modifications apport√©es √† l'arborescence des p√©riph√©riques. <br><br>  Puisque j'utilise MODBUS RTU via RS485 pour communiquer avec les modules, j'avais besoin d'activer presque tous les ports s√©rie qui existent sur le BBB.  Pour ce faire, vous devez les r√©activer dans l'arborescence des p√©riph√©riques, car  Par d√©faut, la plupart d'entre eux sont d√©sactiv√©s. <br><br>  Il serait correct de cr√©er votre correctif pour le fichier am335x-bone-common.dtsi √† partir du package buildrut et de l'appliquer √† chaque fois avant de l'assembler, mais la paresse a gagn√©, et j'ai simplement retir√© tous les fichiers dont j'avais besoin, chang√© tout ce dont j'avais besoin et cr√©√© avec mes mains. <br><br>  Parce que  cela se fait une fois, c'est possible et donc: <br><br>  1. Cr√©ez un dossier avec les fichiers n√©cessaires √† l'assemblage: <br><br><pre> <code class="plaintext hljs">am335x-bone-common.dtsi am335x-boneblack-common.dtsi am335x-boneblack.dts am33xx-clocks.dtsi am33xx.dtsi am33xx.h gpio.h omap.h tps65217.dtsi</code> </pre> <br>  2. Dans le fichier am335x-bone-common.dtsi, vous devez configurer correctement les broches et d√©sactiver les pilotes de port: <br><br><pre> <code class="plaintext hljs">uart1_pins: pinmux_uart1_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x980, PIN_INPUT_PULLUP | MUX_MODE0) AM33XX_IOPAD(0x984, PIN_OUTPUT_PULLDOWN | MUX_MODE0) &gt;; }; uart2_pins: pinmux_uart2_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x950, PIN_INPUT_PULLUP | MUX_MODE1) AM33XX_IOPAD(0x954, PIN_OUTPUT_PULLDOWN | MUX_MODE1) &gt;; }; uart4_pins: pinmux_uart4_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x870, PIN_INPUT_PULLUP | MUX_MODE6) AM33XX_IOPAD(0x874, PIN_OUTPUT_PULLDOWN | MUX_MODE6) &gt;; }; uart5_pins: pinmux_uart5_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x8C4, PIN_INPUT_PULLUP | MUX_MODE4) AM33XX_IOPAD(0x8C0, PIN_OUTPUT_PULLDOWN | MUX_MODE4) &gt;; }; &amp;uart1 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart1_pins&gt;; status = "okay"; }; &amp;uart2 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart2_pins&gt;; status = "okay"; }; &amp;uart4 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart4_pins&gt;; status = "okay"; }; &amp;uart5 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart5_pins&gt;; status = "okay"; };</code> </pre><br>  3. Ensuite, un peu de magie, et le fichier fini am335x-boneblack.dtb se trouve dans le m√™me r√©pertoire: <br><br><pre> <code class="plaintext hljs">a. sudo apt-get install device-tree-compiler</code> </pre> <br>  b.  ex√©cutez le pr√©processeur: <br><br><pre> <code class="plaintext hljs">cpp -Wp,-MD,am335x-boneblack.dtb.d.pre.tmp -nostdinc -Iinclude -Isrc -Itestcase-data -undef -D__DTS__ -x assembler-with-cpp -o am335x-boneblack.dtb.dts.tmp am335x-boneblack.dts</code> </pre> <br>  c.  ex√©cutez le compilateur lui-m√™me: <br><br><pre> <code class="plaintext hljs">dtc -O dtb -o am335x-boneblack.dtb -b 0 -i src -d am335x-boneblack.dtb.d.dtc.tmp am335x-boneblack.dtb.dts.tmp</code> </pre> <br>  4. am335x-boneblack.dtb doit √™tre plac√© sur la partition de d√©marrage √† c√¥t√© du noyau et dans le script de d√©marrage de barebox, ajoutez la ligne suivante - " <code>global.bootm.oftree=/boot/am335x-boneblack.dtb</code> " <br><br>  Choisir un syst√®me de collecte des d√©bits n√©goci√©s. <br><br>  Comme vous le savez, les syst√®mes sans bugs n'existent pas, ainsi que l'analyse d'un syst√®me multi-thread sans traces.  Il est tr√®s pratique que ces traces ne s'affichent pas simplement dans la console, mais soient collect√©es √† l'aide de quelque chose de sp√©cialement cr√©√© pour cela, afin qu'il soit possible de les trier par processus, d'appliquer des filtres, etc.  Et je connais juste un bon syst√®me qui est facile √† construire sous l'h√¥te et la cible.  Il s'agit de DLT, si vous n'en avez jamais entendu parler, cela n'a pas d'importance, toutes les lacunes dans les connaissances peuvent √™tre facilement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">combl√©es en</a> lisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">at.projects.genivi.org/wiki/display/PROJ/Diagnostic+Log+and+Trace</a> . <br>  Ce syst√®me se compose de dlt-daemon et dlt-viewer.  Comme son nom l'indique, dlt-daemon s'ex√©cute sur la cible et dlt-viewer sur l'h√¥te.  De plus √† tout cela, √† votre binaire, √† partir duquel nous voulons collecter des traces, vous devez lier la lib dlt. <br><br><img src="https://habrastorage.org/webt/oi/go/b-/oigob-peuxj5pdvmkdr0vzu5wkc.png"><br><br>  En g√©n√©ral, tout est pratique, comment collecter des traces et les analyser, je recommande. <br><br>  Ecrire un syst√®me de build. <br><br>  Pourquoi √©crire un syst√®me de construction, car vous pouvez tout t√©l√©charger √† partir des r√©f√©rentiels, le construire avec vos mains, construire sur la base de ces rootfs et de ce voile, le contr√¥leur fonctionne.  Mais r√©p√©ter une telle astuce en un mois sera plus difficile, et en deux - c'est g√©n√©ralement impossible.  Encore une fois, vous devez vous rappeler quoi, o√π mettre, quoi construire et comment commencer.  Par cons√©quent, apr√®s avoir pass√© beaucoup de temps au d√©but, vous l'enregistrez plus tard, et vous avez la possibilit√© de cr√©er facilement sous l'h√¥te et la cible.  Le syst√®me de construction se compose d'un ensemble de scripts qui pr√©parent d'abord l'h√¥te pour la construction, t√©l√©chargent des composants tiers, tels que buildroot, moustique, d√©mon DLT, √† partir de leurs r√©f√©rentiels, les construisent, les mettent √† leur place.  Et puis vous pouvez lancer la construction de votre projet.  Si la construction sous l'h√¥te n'est pas difficile √† faire, alors vous devez toujours bricoler la construction sous la cible, et ce serait mieux si le script le faisait. <br><br>  Buildroot peut √™tre configur√© pour invoquer un script post-build apr√®s avoir form√© rootfs, qui se trouvera dans buildroot / output / target.  Cela vous donne une excellente occasion d'y mettre tout ce dont vous avez besoin.  Et puis, l'image du syst√®me de fichiers contiendra d√©j√† tout ce dont vous avez besoin pour d√©marrer votre syst√®me. <br><br>  La recette est quelque chose comme √ßa: <br><br><ol><li>  vous devez copier vos fichiers binaires quelque part dans buildroot / output / target, par exemple dans / opt / bin </li><li>  s'il y a des configurations, alors faites de m√™me avec elles, uniquement dans / opt / etc </li><li>  copier des binaires tiers, pour moi c'est le moustique, le d√©mon DLT, leurs libs et configs </li><li>  Afin de d√©marrer le syst√®me lui-m√™me lors du chargement du contr√¥leur, vous devez copier vos services systemd, il est pr√©f√©rable de les combiner dans votre cible et de le r√©activer en cr√©ant un lien symbolique en multi-utilisateurs. </li><li>  copier le fstab modifi√© (pourquoi, je vous le dirai plus tard) </li></ol><br>  Apr√®s cela, il vous suffit de d√©compresser buildroot / output / images / rootfs.tar vers la section souhait√©e de la carte SD et de mettre sous tension. <br><br><pre> <code class="plaintext hljs">build git repo: https://github.com/azhigaylo/build</code> </pre> <br>  R√©daction d'un noyau de communication. <br><br>  Le concept est aussi ancien que le modbus lui-m√™me. <br><br>  Chaque p√©riph√©rique d'E / S d'un r√©seau Modbus dispose de registres (16 bits) disponibles pour la lecture, la lecture / l'√©criture, dans lesquels les donn√©es sont stock√©es et √† travers lesquelles ces p√©riph√©riques sont contr√¥l√©s.  Le contr√¥leur, √† son tour, dispose de tableaux de points discrets (√©tat et valeur d'octet) et analogiques (√©tat et valeur flottante), dans lesquels il stocke l'√©tat de tous les param√®tres. <br><br>  Ainsi, la t√¢che du c≈ìur de communication est simple: collecter des donn√©es √† partir des p√©riph√©riques d'E / S √† l'aide du protocole Modbus, les mapper aux points du contr√¥leur et fournir un acc√®s √† ces points pour le niveau sup√©rieur.  Et si vous avez besoin de g√©rer quelque chose, alors tout est dans l'autre sens - le p√©riph√©rique logique (plus √† ce sujet plus tard) doit √™tre abonn√© au point du contr√¥leur et l'√©criture √† ce point lance la traduction de ce param√®tre vers le p√©riph√©rique physique de sortie d'eau. <br><br><img src="https://habrastorage.org/webt/1v/zb/x4/1vzbx4smmroaleak2dy4jol9gno.jpeg"><br><br>  Afin de structurer les donn√©es et de travailler avec des appareils, vous pouvez introduire le concept d'un appareil logique qui affichera l'√©tat d'un appareil physique dans votre logiciel. <br><br>  J'ai √©galement d√©cid√© de diviser les p√©riph√©riques logiques en deux groupes: <br><br><ol><li>  Standard (modules B√©lier d'entr√©es / sorties discr√®tes), pour lesquels le nombre de registres Modbus avec des donn√©es est connu √† l'avance, et il suffit juste de d√©terminer les points du contr√¥leur o√π enregistrer ces donn√©es. </li><li>  Les appareils utilisateurs, pour eux, il est n√©cessaire de d√©crire ind√©pendamment le mappage des registres Modbus aux points du contr√¥leur. </li></ol><br>  De tout ce qui pr√©c√®de, il est logique d'avoir une sorte de configurateur pour le contr√¥leur, que ce soit juste une configuration json ou un outil auto-√©crit g√©n√©rant une configuration binaire, tout convient.  J'ai la deuxi√®me option, car il y avait des id√©es pour √©crire un noyau de communication afin qu'il puisse √™tre facilement ex√©cut√© non seulement sur la carte Linux mais aussi sur Arduin avec FreeRtos, en changeant le niveau PAL dans le logiciel. <br><br>  Dans le configurateur de chaque p√©riph√©rique, vous devez d√©finir le num√©ro de port du contr√¥leur rs485, l'adresse du p√©riph√©rique et le point du contr√¥leur vers lequel l'√©tat de la communication avec le p√©riph√©rique est affich√©, plus pour chaque p√©riph√©rique standard ses canaux sont d√©crits, et pour un p√©riph√©rique utilisateur, il est mapp√© sur des registres. <br><br><img src="https://habrastorage.org/webt/p7/gh/cu/p7ghcubristizrus5hzq_zlfo5i.jpeg"><br><br><img src="https://habrastorage.org/webt/xr/go/nk/xrgonkcogvsn-6j2vjktiiryrlw.jpeg"><br><br>  Un tel fichier de configuration, contenant toutes les donn√©es n√©cessaires √† la construction du r√©seau Modbus, vous permet de ne pas modifier le code source du projet si vous avez besoin d'ajouter / supprimer / changer des p√©riph√©riques d'entr√©e / sortie, il suffit de changer les param√®tres dans le configurateur et de les enregistrer dans le fichier de configuration. <br><br>  Au d√©marrage, le noyau de communication analyse la configuration et cr√©e sur sa base des listes de p√©riph√©riques logiques pour chaque port rs485 du contr√¥leur, puis des threads sont cr√©√©s sur chaque port et une interrogation cyclique des p√©riph√©riques physiques commence. <br><br><pre> <code class="plaintext hljs">core git repo: https://github.com/azhigaylo/homebrain_core</code> </pre> <br>  √âcriture de la passerelle mqtt. <br><br>  En fait - vos points de contr√¥leur, √† la fois discrets et analogiques, avec une interface propri√©taire pour y acc√©der, sont de peu d'int√©r√™t pour personne.  Il n'y a donc qu'une seule issue: mqtt.  Je pense que je n'exag√®re pas si je dis que c'est actuellement le protocole le plus courant pour l'√©change de petits messages, en plus il est tr√®s simple et compr√©hensible √† utiliser.  Donc, quand j'avais besoin de transmettre des donn√©es √† partir du contr√¥leur - je ne pensais pas longtemps √† quoi utiliser. <br><br><img src="https://habrastorage.org/webt/o_/sf/w0/o_sfw0yj5i-ptu7ohxdqdvnmw68.jpeg"><br><br>  Parce que  J'ai beaucoup de param√®tres, puis il y avait toujours des confusions dans le fichier de configuration de la passerelle, o√π le mappage des points du contr√¥leur vers les sujets de la passerelle mqtt √©tait enregistr√©.  Google a aid√© la table et √©crit un analyseur csv de cette table dans le fichier de configuration json pour la passerelle. <br><br><img src="https://habrastorage.org/webt/b-/wt/zm/b-wtzmutugygf-_8mj5odnnrguw.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">passerelle git repo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parser git repo</a> <br><br>  Moniteur de point d'√©criture. <br><br>  Parfois, il est tr√®s utile de voir ce qui se passe avec les points du contr√¥leur, pour cela j'ai √©crit une petite application qui se connecte directement au noyau de communication et lit l'√©tat des points discrets et analogiques.  Je suis assez proche de l'interface utilisateur, j'ai donc √©t√© en mesure de lancer l'application en QML, cela a fonctionn√© avec un craquement, vous pouvez compter le point, vous pouvez l'√©crire, mais je n'en ai pas besoin de plus. <br><br><pre> <code class="plaintext hljs">pointmonitor git repo: https://github.com/azhigaylo/pointmonitor</code> </pre> <br>  Montez le syst√®me de fichiers en lecture seule. <br><br>  Habituellement, peu de gens y pr√™tent attention, et m√™me dans les projets de production, vous pouvez trouver des p√©riph√©riques dans lesquels la partition avec rootfs est accessible en √©criture.  T√¥t ou tard, cela entra√Æne le crash de tout syst√®me de fichiers, m√™me le plus stable.  Parce que  √âtant donn√© que le contr√¥leur peut √™tre √©teint √† tout moment, ce n'est qu'une question de temps / cas lorsque cela se produit.  Pour minimiser cette probabilit√©, vous devez bricoler un peu avec fstab, et avant de construire l'image rootfs, placez-la comme d√©crit ci-dessus.  Dans fstab, premi√®rement, vous devez monter le syst√®me de fichiers en lecture seule, et deuxi√®mement, tout ce qui peut changer peut √™tre mapp√© dans tmpfs. <br><br>  Mon fstab est le suivant, il peut diff√©rer pour vous: <br><br><pre> <code class="plaintext hljs">/dev/root / auto ro 0 1 tmpfs /tmp tmpfs nodev,nosuid,size=50M 0 0 tmpfs /srv tmpfs nodev,size=50M 0 0 tmpfs /var/log tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/tmp tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/run tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/lib tmpfs defaults,noatime,size=10M 0 0</code> </pre> <br>  Corps du contr√¥leur <br><br>  Une imprimante 3D a longtemps √©t√© incluse dans les sections de t√™te de m√¢t pour chaque ing√©nieur agriculteur collectif, malheureusement je ne l'ai pas, mais elle est √† l'≈ìuvre.  R√©cemment, l'excitation des autres employ√©s pour lui a disparu, je l'utilise lors de l'impression de tout ce dont j'ai besoin et dont je n'ai pas besoin, vous pouvez en √™tre convaincu en lisant mon post pr√©c√©dent. <br><br>  Nous dessinons dans FreeCAD, nous g√©n√©rons le gcode dans Cura et nous obtenons un bo√Ætier, sans oublier de faire des si√®ges pour la carte, des d√©coupes pour les connecteurs et le refroidissement et des hypoth√®ques pour les clips sur un rail DIN. <br><br><img src="https://habrastorage.org/webt/7m/yc/y6/7mycy6gz9axqfvspdk_cmyz5oc8.jpeg"><br><br><img src="https://habrastorage.org/webt/j5/i3/dv/j5i3dvtfcb8wkpn1t0uphq7d9lg.jpeg"><br><br>  Eh bien, c‚Äôest tout, nous avons maintenant une carte, un logiciel sur une carte SD et un √©tui.  Nous prenons un fichier (je ne plaisante pas) et connectons tout ensemble, connectons l'alimentation, les c√¢bles RS485 et tout commence √† fonctionner.  Et tu as dit difficile, difficile ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462259/">https://habr.com/ru/post/fr462259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462243/index.html">Am√©lioration des performances frontales de Magento avec ReactJS</a></li>
<li><a href="../fr462245/index.html">auto git bisect comme exemple du noyau Linux</a></li>
<li><a href="../fr462251/index.html">Le mode navigation priv√©e dans le navigateur est-il une fiction?</a></li>
<li><a href="../fr462253/index.html">Les premi√®res exp√©riences utilisant le protocole de streaming sur l'exemple de communication CPU et processeur dans le FPGA Redd</a></li>
<li><a href="../fr462257/index.html">Kafka sur Kubernetes - est-ce bien?</a></li>
<li><a href="../fr462263/index.html">P√©dalez jusqu'au sol: cr√©ez un autre manipulateur de pied pour PC</a></li>
<li><a href="../fr462265/index.html">Python et cubes</a></li>
<li><a href="../fr462267/index.html">Apprenez √† conna√Ætre l'analyseur statique PVS-Studio pour Java</a></li>
<li><a href="../fr462269/index.html">John Romero √† Doom: 80s Game Dev</a></li>
<li><a href="../fr462271/index.html">Code de verrouillage dans iOS: comment Apple est pass√© de la d√©fense en d√©fense √† la protection d'une seule fronti√®re</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>