<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👧‍👧 🤦🏾 👩‍👦 我如何编写标准的C ++ 11库，或者为什么boost如此令人恐惧。 第4.1章 👨🏽‍🔬 🖐🏾 🏴󠁧󠁢󠁥󠁮󠁧󠁿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="先前部分的摘要 
 由于使用C ++ 11编译器的能力受到限制，并且由于缺乏替代性，boost希望在编译器随附的C ++ 98 / C ++ 03库之上编写自己的标准C ++ 11库实现。 

 实现了static_assert ， noexcept ， countof ，并且在考虑了所有非标准定义...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我如何编写标准的C ++ 11库，或者为什么boost如此令人恐惧。 第4.1章</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417547/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="我们继续冒险。" width="300" height="350" align="left"><h3> 先前部分的摘要 </h3><br> 由于使用C ++ 11编译器的能力受到限制，并且由于缺乏替代性，boost希望在编译器随附的C ++ 98 / C ++ 03库之上编写自己的标准C ++ 11库实现。 <br><br>  <b>实现了static_assert</b> ， <b>noexcept</b> ， <b>countof</b> ，并且在考虑了所有非标准定义和编译器功能之后，出现了有关当前编译器支持的功能的信息。  <b>包含了</b>自己的<b>nullptr</b>实现，该实现在编译阶段选择。 <br><br> 现在是使用<b>type_traits</b>和所有这些“特殊模板魔术”的时候了。 <br><br> 链接到GitHub，为不耐烦的读者和非读者提供今天的结果： <br><br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">欢迎有建设性的批评和批评</a></b> </blockquote><br> 将自己沉浸在“模板魔术” C ++的世界中。 <br><a name="habracut"></a><br><h4> 目录 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引言</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1章。Viam supervadet vadens</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2章。#ifndef __CPP11_SUPPORT__＃定义__COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3章。找到理想的nullptr实现</a> <br>  <b>第4章C ++模板魔术</b> <br>  .... <b>4.1我们从小处着手</b> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.2关于日志为我们编译了多少个奇迹般的错误</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.3指针和所有所有</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.4模板库还需要什么</a> <br> 第五章 <br>  ... <br><br><h3> 第4章C ++模板魔术 </h3><br> 完成了C ++ 11关键字以及它们的实现之间的所有依赖定义的“开关”之后，我开始填写<b>type_traits</b> 。 实际上，我已经有很多类似于标准模板类的模板类，它们已经在项目中使用了很长时间，因此仍然需要将所有这些都以相同的形式呈现，并添加缺少的功能。 <br><br><img src="https://habrastorage.org/webt/g_/vn/rg/g_vnrg9in04st7-ysvmivnbablo.png" alt="图片" width="300" height="200" align="left"> 老实说，我受到模板编程的启发。 尤其是意识到所有这些都是多种选择的：在编译过程中执行计算，代码分支，条件，错误检查，而在执行阶段则不花任何代价最终程序。 并且由于C ++中的模板本质上是一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图灵完备的编程语言</a> ，所以我期待着实现与模板编程相关的标准部分的优雅和相对容易。 但是，为了立即消除所有幻想，我将说整个图灵完整性理论被分解为编译器中模板的具体实现。 而编写库的这一部分，而不是优雅的解决方案和模板编程的“技巧”，变成了与编译器的激烈斗争，而每个人都以自己的方式“崩溃”了，如果它陷入了严重的内部编译器错误，或者甚至崩溃了，那就很好了。未处理的异常。  GCC（g ++）表现出了自己最好的一面，它从逻辑上“咀嚼”了所有模板的构造，并且仅在缺少显式<b>typename的</b>地方诅咒（在这种情况下）。 <br><br><h4>  4.1从小做起 </h4><br> 我从简单的模板开始，分别是<i>std :: integral_constant</i> ， <i>std :: bool_constant</i>和类似的小模板。 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Val</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">integral_constant</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// convenient template for integral constant types static const _Tp value = Val; typedef const _Tp value_type; typedef integral_constant&lt;_Tp, Val&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } }; typedef integral_constant&lt;bool, true&gt; true_type; typedef integral_constant&lt;bool, false&gt; false_type; template&lt;bool Val&gt; struct bool_constant : public integral_constant&lt;bool, Val&gt; {}; // Primary template. // Define a member typedef @c type to one of two argument types. template&lt;bool _Cond, class _Iftrue, class _Iffalse&gt; struct conditional { typedef _Iftrue type; }; // Partial specialization for false. template&lt;class _Iftrue, class _Iffalse&gt; struct conditional&lt;false, _Iftrue, _Iffalse&gt; { typedef _Iffalse type; };</span></span></code> </pre> <br> 基于<i>条件，</i>您可以为类型上的逻辑操作{“ and”，“ or”，“ not”}输入方便的模板（所有这些操作都在编译阶段就被认为是正确的！这很好，不是吗？）： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void_type</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//typedef void void_type; template&lt;class _B1 = void_type, class _B2 = void_type, class _B3 = void_type, class _B4 = void_type&gt; struct _or_ : public conditional&lt;_B1::value, _B1, _or_&lt;_B2, _or_&lt;_B3, _B4&gt; &gt; &gt;::type { }; template&lt;&gt; struct _or_&lt;void_type, void_type, void_type, void_type&gt;; template&lt;class _B1&gt; struct _or_&lt;_B1, void_type, void_type, void_type&gt; : public _B1 { }; template&lt;class _B1, class _B2&gt; struct _or_&lt;_B1, _B2, void_type, void_type&gt; : public conditional&lt;_B1::value, _B1, _B2&gt;::type { }; template&lt;class _B1, class _B2, class _B3&gt; struct _or_&lt;_B1, _B2, _B3, void_type&gt; : public conditional&lt;_B1::value, _B1, _or_&lt;_B2, _B3&gt; &gt;::type { }; template&lt;class _B1 = void_type, class _B2 = void_type, class _B3 = void_type, class _B4 = void_type&gt; struct _and_; template&lt;&gt; struct _and_&lt;void_type, void_type, void_type, void_type&gt;; template&lt;class _B1&gt; struct _and_&lt;_B1, void_type, void_type, void_type&gt; : public _B1 { }; template&lt;class _B1, class _B2&gt; struct _and_&lt;_B1, _B2, void_type, void_type&gt; : public conditional&lt;_B1::value, _B2, _B1&gt;::type { }; template&lt;class _B1, class _B2, class _B3&gt; struct _and_&lt;_B1, _B2, _B3, void_type&gt; : public conditional&lt;_B1::value, _and_&lt;_B2, _B3&gt;, _B1&gt;::type { }; template&lt;class _Pp&gt; struct _not_ { static const bool value = !bool(_Pp::value); typedef const bool value_type; typedef integral_constant&lt;bool, _not_::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } }; }</span></span></code> </pre><br><blockquote> 这里有三点值得关注： <br><br>  1）务必在模板的尖括号（'&lt;'和'&gt;'）之间放置一个空格，这是很重要的，因为在C ++ 11之前，标准中尚无关于如何解释<i>_or _ &lt;_ B2</i>等代码中的'&gt;&gt;'和'&lt;&lt;'的说明<i>， _或_ &lt;_ B3，_B4 &gt;&gt;</i> ，因此几乎所有编译器都将其视为移位运算符，这会导致编译错误。 <br><br>  2）在某些编译器（例如Visual Studio 6.0）中，存在一个错误，该错误在于无法将<b>void</b>类型用作模板参数。 为此，在上面的段落中引入了一个单独的<i>void_type</i>类型，以替换需要默认模板参数值的<b>void</b>类型。 <br><br>  3）非常老的编译器（例如，Borland C ++ Builder）具有弯曲的实现类型<b>bool</b> ，在某些情况下，该类型突然“转变”为<b>int</b> （ <b>true-</b> &gt; 1， <b>false-</b> &gt; 0），以及该类型的常量静态变量类型<b>bool</b> （不仅限于它们），如果它们包含在模板类中。 由于所有这些混乱，因此，对于<i>my_template_type :: static_bool_value == <b>false</b></i>样式的完全无害的比较<i><b>，</b></i>编译器可以轻松地发出<i>无法将'undefined type'</i> <i>强制转换</i> <i>为int（0）之类</i>的<i>附魔</i> 。 因此，有必要始终尝试明确指出要比较的值的类型，从而帮助编译器确定其处理的类型。 </blockquote><br><br> 使用<b>const</b>和<b>volatile</b>值添加更多工作。 首先，简单地实现<i>remove_</i> ...，在这里我们只是简单地对某些类型修饰符进行模板专用化-如果类型带有修饰符，则编译器必须在查看了模板的所有特定性（从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一章中</a>回顾了SFINAE原理）后，选择最合适的（明确指出了所需的修饰符） ： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remove_const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// remove top level const qualifier typedef _Tp type; }; template&lt;class _Tp&gt; struct remove_const&lt;const _Tp&gt; { // remove top level const qualifier typedef _Tp type; }; template&lt;class _Tp&gt; struct remove_const&lt;const volatile _Tp&gt; { // remove top level const qualifier typedef volatile _Tp type; }; // remove_volatile template&lt;class _Tp&gt; struct remove_volatile { // remove top level volatile qualifier typedef _Tp type; }; template&lt;class _Tp&gt; struct remove_volatile&lt;volatile _Tp&gt; { // remove top level volatile qualifier typedef _Tp type; }; // remove_cv template&lt;class _Tp&gt; struct remove_cv { // remove top level const and volatile qualifiers typedef typename remove_const&lt;typename remove_volatile&lt;_Tp&gt;::type&gt;::type type; };</span></span></code> </pre><br> 然后我们实现<i>add_</i>模板...一切都已经有些复杂了： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsFunction</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add_const_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add_const_helper</span></span></span><span class="hljs-class">&lt;_Tp, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsFunction</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add_volatile_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add_volatile_helper</span></span></span><span class="hljs-class">&lt;_Tp, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsFunction</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add_cv_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add_cv_helper</span></span></span><span class="hljs-class">&lt;_Tp, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp type; }; } <span class="hljs-comment"><span class="hljs-comment">// add_const template&lt;class _Tp&gt; struct add_const: public detail::_add_const_helper&lt;_Tp, is_function&lt;_Tp&gt;::value&gt; { }; template&lt;class _Tp&gt; struct add_const&lt;_Tp&amp;&gt; { typedef _Tp &amp; type; }; // add_volatile template&lt;class _Tp&gt; struct add_volatile : public detail::_add_volatile_helper&lt;_Tp, is_function&lt;_Tp&gt;::value&gt; { }; template&lt;class _Tp&gt; struct add_volatile&lt;_Tp&amp;&gt; { typedef _Tp &amp; type; }; // add_cv template&lt;class _Tp&gt; struct add_cv : public detail::_add_cv_helper&lt;_Tp, is_function&lt;_Tp&gt;::value&gt; { }; template&lt;class _Tp&gt; struct add_cv&lt;_Tp&amp;&gt; { typedef _Tp &amp; type; };</span></span></code> </pre><br> 在这里，我们仔细地分别处理引用类型，以免丢失链接。 同样，我们不会忘记原则上不可能使<b>volatile</b>或<b>const</b>成为可能的函数类型，因此我们将它们保持“原样”。 我可以说所有这些看起来非常简单，但是当“魔鬼在细节中”，或者“错误在实现的细节中”时，情况就是这样。 <br><br> 第四章第一部分结束。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分中，</a>我将讨论如何对编译器进行硬模板编程，并且还会有更多很棒的模板魔术。 嗯，但是-根据当今的一些编译器<b>，</b>为什么<b>长久以来</b>都不是<b>整数常数</b> 。 <br><br> 谢谢您的关注。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN417547/">https://habr.com/ru/post/zh-CN417547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN417537/index.html">“您的游戏很无聊”，或者如何提高第一天已经很高的保留率</a></li>
<li><a href="../zh-CN417539/index.html">谷歌因违反欧洲反托拉斯法被罚款50亿美元</a></li>
<li><a href="../zh-CN417541/index.html">与美国国家航空航天局（NASA）飞行控制中心数字化的阿波罗飞行任务记录</a></li>
<li><a href="../zh-CN417543/index.html">一名中国大学生因其父亲的低“社会等级”而几乎被开除。</a></li>
<li><a href="../zh-CN417545/index.html">信息技术有其特殊的氛围。</a></li>
<li><a href="../zh-CN417549/index.html">问伊森：整个不可观察的宇宙有多大？</a></li>
<li><a href="../zh-CN417551/index.html">CRISPR倡导平等访问基因编辑</a></li>
<li><a href="../zh-CN417553/index.html">公开网络研讨会“ CSS预处理程序”</a></li>
<li><a href="../zh-CN417555/index.html">莫斯科举行货运崇拜研讨会：营销反击</a></li>
<li><a href="../zh-CN417557/index.html">激光数控机床概述LaserSolid</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>