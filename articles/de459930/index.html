<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèΩ üè¥‚Äç‚ò†Ô∏è ‚ÅâÔ∏è Python-Importautomatisierung üåò üò≠ üë©üèø‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zu  Nachher 

import math import os.path import requests # 100500 other imports print(math.pi) print(os.path.join('my', 'path')) print(requests.get)  ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python-Importautomatisierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459930/"><div class="scrollable-table"><table><tbody><tr><th>  Zu </th><th>  Nachher </th></tr><tr><td><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-comment"><span class="hljs-comment"># 100500 other imports print(math.pi) print(os.path.join('my', 'path')) print(requests.get)</span></span></code> </pre> </td><td><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> smart_imports smart_imports.all() print(math.pi) print(os_path.join(<span class="hljs-string"><span class="hljs-string">'my'</span></span>, <span class="hljs-string"><span class="hljs-string">'path'</span></span>)) print(requests.get)</code> </pre></td></tr></tbody></table></div>  So kam es, dass ich seit 2012 als einziger Programmierer einen Open-Source-Browser entwickle.  In Python f√ºr sich.  Der Browser ist nicht die einfachste Sache, jetzt gibt es im Hauptteil des Projekts mehr als 1000 Module und mehr als 120.000 Zeilen Python-Code.  Insgesamt wird es bei Satellitenprojekten eineinhalb Mal so viel sein. <br><br>  Irgendwann hatte ich es satt, am Anfang jeder Datei mit den Importb√∂den herumzuspielen, und entschied mich, dieses Problem ein f√ºr alle Mal zu l√∂sen.  So wurde die <b>smart_imports-</b> Bibliothek geboren ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pypi</a> ). <br><br>  Die Idee ist ganz einfach.  Jedes komplexe Projekt bildet schlie√ülich eine eigene Vereinbarung √ºber die Benennung von allem.  <b>Wenn diese Vereinbarung in formellere Regeln umgewandelt wird, kann jede Entit√§t automatisch unter dem Namen der ihr zugeordneten Variablen importiert werden.</b> <br><br>  Zum Beispiel m√ºssen Sie keine <code>import math</code> schreiben, <code>import math</code> auf <code>math.pi</code> - wir k√∂nnen <code>math.pi</code> verstehen, dass <code>math</code> in diesem Fall ein Modul der Standardbibliothek ist. <br><br>  Intelligente Importe unterst√ºtzen Python&gt; = 3.5. Die Bibliothek wird vollst√§ndig durch Tests abgedeckt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abdeckung&gt; 95%</a> .  Ich benutze es jetzt seit einem Jahr selbst. <br><br>  F√ºr Details lade ich Sie zu Cat ein. <br><a name="habracut"></a><br><h2>  Wie funktioniert es im Allgemeinen? </h2><br>  Der Code aus dem Header-Bild funktioniert also wie folgt: <br><br><ol><li>  W√§hrend eines Aufrufs von <code>smart_imports.all()</code> Bibliothek den <abbr title="Abstrakter Syntaxbaum">AST des</abbr> Moduls, von dem aus der Aufruf erfolgt. </li><li>  Finden Sie nicht initialisierte Variablen; </li><li>  Wir f√ºhren den Namen jeder Variablen durch eine Folge von Regeln, die versuchen, das Modul (oder Modulattribut) zu finden, das f√ºr den Import nach Namen ben√∂tigt wird.  Wenn eine Regel die erforderliche Entit√§t gefunden hat, werden die folgenden Regeln nicht √ºberpr√ºft. </li><li>  Die gefundenen Module werden geladen, initialisiert und im globalen Namespace abgelegt (oder die erforderlichen Attribute dieser Module werden dort abgelegt). </li></ol><br>  Nicht initialisierte Variablen werden im gesamten Code durchsucht, einschlie√ülich der neuen Syntax. <br><br>  Der automatische Import ist nur f√ºr Projektkomponenten aktiviert, die explizit <code>smart_imoprts.all()</code> aufrufen.  Dar√ºber hinaus verbietet die Verwendung intelligenter Importe nicht die Verwendung herk√∂mmlicher Importe.  Auf diese Weise k√∂nnen Sie die Bibliothek schrittweise implementieren und komplexe zyklische Abh√§ngigkeiten aufl√∂sen. <br><br>  Ein akribischer Leser wird feststellen, dass das AST-Modul zweimal aufgebaut ist: <br><br><ul><li>  CPython erstellt es zum ersten Mal w√§hrend des Modulimports. </li><li>  Das zweite Mal, wenn smart_imports es w√§hrend eines Aufrufs von <code>smart_imports.all()</code> . </li></ul><br>  AST kann wirklich nur einmal erstellt werden (dazu m√ºssen Sie mithilfe von in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEP-0302</a> implementierten Import-Hooks in den Importprozess von Modulen integrieren, aber diese L√∂sung verlangsamt den Import. <br><br><div class="spoiler">  <b class="spoiler_title">Warum denkst du so?</b> <div class="spoiler_text">  Beim Vergleich der Leistung von zwei Implementierungen (mit und ohne Hooks) kam ich zu dem Schluss, dass CPython beim Importieren eines Moduls AST in seinen internen (C-shh) Datenstrukturen erstellt.  Das Konvertieren in Python-Datenstrukturen ist teurer als das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen</a> eines Baums aus der Quelle mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ast-</a> Modul. <br></div></div><br>  Nat√ºrlich wird der AST jedes Moduls nur einmal pro Start erstellt und analysiert. <br><br><h2>  Standardimportregeln </h2><br>  Die Bibliothek kann ohne zus√§tzliche Konfiguration verwendet werden.  Standardm√§√üig werden Module nach folgenden Regeln importiert: <br><br><ol><li>  Durch genaues Zusammentreffen des Namens wird nach dem Modul neben dem aktuellen (im selben Verzeichnis) gesucht. </li><li>  √úberpr√ºft die Module der Standardbibliothek: <br><ul><li>  durch genaue √úbereinstimmung des Namens f√ºr Pakete der obersten Ebene; </li><li>  Bei verschachtelten Paketen und Modulen wird nach zusammengesetzten Namen gesucht und Punkte durch Unterstriche ersetzt.  Beispielsweise wird <code>os.path</code> importiert, wenn die Variable <code>os_path</code> . </li></ul></li><li>  Durch die genaue √úbereinstimmung des Namens wird nach installierten Paketen von Drittanbietern gesucht.  Zum Beispiel die bekannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paketanfragen</a> . </li></ol><br><h2>  Leistung </h2><br>  Intelligente Importe wirken sich nicht auf die Leistung des Programms aus, erh√∂hen jedoch die Startzeit. <br><br>  Aufgrund des Umbaus des AST erh√∂ht sich die Zeit des ersten Laufs um das 1,5- bis 2-fache.  F√ºr kleine Projekte ist dies nicht von Bedeutung.  In gro√üen Projekten leidet die Startzeit eher unter der Abh√§ngigkeitsstruktur zwischen den Modulen als unter der Importzeit eines bestimmten Moduls. <br><br>  <s>Wenn</s> intelligente Importe popul√§r werden, schreibe ich die Arbeit von AST auf C um - dies sollte die Startkosten erheblich senken. <br><br>  Um das Laden zu beschleunigen, k√∂nnen die Ergebnisse der Verarbeitung von AST-Modulen im Dateisystem zwischengespeichert werden.  Das Caching ist in der Konfiguration aktiviert.  Nat√ºrlich ist der Cache deaktiviert, wenn Sie die Quelle √§ndern. <br><br>  Die Startzeit wird sowohl von der Liste der Modul-Suchregeln als auch von deren Reihenfolge beeinflusst.  Da einige Regeln die Standard-Python-Funktionalit√§t verwenden, um nach Modulen zu suchen.  Sie k√∂nnen diese Kosten ausschlie√üen, indem Sie die √úbereinstimmung von Namen und Modulen mithilfe der Regel "Benutzerdefinierte Namen" explizit angeben (siehe unten). <br><br><h2>  Konfiguration </h2><br>  Die Standardkonfiguration wurde bereits beschrieben.  Es sollte ausreichen, in kleinen Projekten mit der Standardbibliothek zu arbeiten. <br><br><div class="spoiler">  <b class="spoiler_title">Standardkonfiguration</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"cache_dir"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: [{<span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"rule_local_modules"</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"rule_stdlib"</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"rule_predefined_names"</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"rule_global_modules"</span></span>}] }</code> </pre> <br></div></div><br>  Bei Bedarf kann eine komplexere Konfiguration in das Dateisystem eingef√ºgt werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Beispiel f√ºr eine komplexe Konfiguration</a> (√ºber einen Browser). <br><br>  W√§hrend eines Aufrufs von <code>smart_import.all()</code> ermittelt <code>smart_import.all()</code> Bibliothek die Position des aufrufenden Moduls im Dateisystem und sucht nach der Datei <code>smart_imports.json</code> in der Richtung vom aktuellen Verzeichnis zum Stammverzeichnis.  Wenn eine solche Datei gefunden wird, wird sie als Konfiguration f√ºr das aktuelle Modul betrachtet. <br><br>  Sie k√∂nnen mehrere verschiedene Konfigurationen verwenden (in verschiedenen Verzeichnissen ablegen). <br><br>  Derzeit gibt es nicht viele Konfigurationsoptionen: <br><br><pre> <code class="json hljs">{ //     AST. //     null ‚Äî   . <span class="hljs-attr"><span class="hljs-attr">"cache_dir"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>|<span class="hljs-string"><span class="hljs-string">"string"</span></span>, //       . <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: [] }</code> </pre> <br><h2>  Regeln importieren </h2><br>  Die Reihenfolge der Angabe von Regeln in der Konfiguration bestimmt die Reihenfolge ihrer Anwendung.  Die erste Regel, die funktioniert hat, stoppt die weitere Suche nach Importen. <br><br>  In den Beispielen f√ºr Konfigurationen wird die Regel rule_predefined_names h√§ufig <code>rule_predefined_names</code> angezeigt. Es ist erforderlich, dass die integrierten Funktionen (z. B. <code>print</code> ) korrekt erkannt werden. <br><br><h3>  Regel 1: Vordefinierte Namen </h3><br>  Mit dieser Regel k√∂nnen Sie vordefinierte Namen wie <code>__file__</code> und integrierte Funktionen wie <code>print</code> ignorieren. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}] # } import smart_imports smart_imports.all() #        __file__ #        print(__file__)</span></span></code> </pre> </div></div><br><h3>  Regel 2: Lokale Module </h3><br>  √úberpr√ºft, ob sich neben dem aktuellen Modul (im selben Verzeichnis) ein Modul mit dem angegebenen Namen befindet.  Wenn ja, importiert es. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_local_modules"}] # } # #    : # # my_package # |-- __init__.py # |-- a.py # |-- b.py # b.py import smart_imports smart_imports.all() #    "a.py" print(a)</span></span></code> </pre> </div></div><br><h3>  Regel 3: Globale Module </h3><br>  Versucht, ein Modul direkt nach Namen zu importieren.  Zum Beispiel das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anforderungsmodul</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_global_modules"}] # } # #    # # pip install requests import smart_imports smart_imports.all() #    requests print(requests.get('http://example.com'))</span></span></code> </pre> </div></div><br><h3>  Regel 4: Benutzerdefinierte Namen </h3><br>  Entspricht dem Namen eines bestimmten Moduls oder seines Attributs.  Die Konformit√§t wird in der Regelkonfiguration angegeben. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_custom", # "variables": {"my_import_module": {"module": "os.path"}, # "my_import_attribute": {"module": "random", "attribute": "seed"}}}] # } import smart_imports smart_imports.all() #       #        print(my_import_module) print(my_import_attribute)</span></span></code> </pre> </div></div><br><h3>  Regel 5: Standardmodule </h3><br>  √úberpr√ºft, ob der Name ein Standardbibliotheksmodul ist.  Zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">math</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">os.path,</a> das sich in <code>os_path</code> verwandelt. <br><br>  Es funktioniert schneller als die Regel zum Importieren globaler Module, da √ºberpr√ºft wird, ob ein Modul in einer zwischengespeicherten Liste vorhanden ist.  Listen f√ºr jede Python-Version finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/jackmaney/python-stdlib-list</a> <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_stdlib"}] # } import smart_imports smart_imports.all() print(math.pi)</span></span></code> </pre> </div></div><br><h3>  Regel 6: Import nach Pr√§fix </h3><br>  Importiert ein Modul nach Namen aus dem Paket, das seinem Pr√§fix zugeordnet ist.  Dies ist praktisch, wenn im gesamten Code mehrere Pakete verwendet werden.  Beispielsweise kann auf die <code>utils</code> <code>utils_</code> mit dem Pr√§fix <code>utils_</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_prefix", # "prefixes": [{"prefix": "utils_", "module": "my_package.utils"}]}] # } # #    : # # my_package # |-- __init__.py # |-- utils # |-- |-- __init__ # |-- |-- a.py # |-- |-- b.py # |-- subpackage # |-- |-- __init__ # |-- |-- c.py # c.py import smart_imports smart_imports.all() print(utils_a) print(utils_b)</span></span></code> </pre> </div></div><br><h3>  Regel 7: Das Modul aus dem √ºbergeordneten Paket </h3><br>  Wenn Sie in verschiedenen Teilen des Projekts Unterpakete mit demselben Namen haben (z. B. <code>tests</code> oder <code>migrations</code> ), k√∂nnen Sie ihnen erlauben, nach Modulen zu suchen, die in den √ºbergeordneten Paketen nach Namen importiert werden sollen. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_local_modules_from_parent", # "suffixes": [".tests"]}] # } # #    : # # my_package # |-- __init__.py # |-- a.py # |-- tests # |-- |-- __init__ # |-- |-- b.py # b.py import smart_imports smart_imports.all() print(a)</span></span></code> </pre> </div></div><br><h3>  Regel 8: Bindung an ein anderes Paket </h3><br>  F√ºr Module aus einem bestimmten Paket erm√∂glicht es die Suche nach Importen nach Namen in anderen Paketen (in der Konfiguration angegeben).  In meinem Fall war diese Regel n√ºtzlich f√ºr F√§lle, in denen ich die Arbeit der vorherigen Regel (Modul aus dem √ºbergeordneten Paket) nicht auf das gesamte Projekt ausweiten wollte. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : # { # "rules": [{"type": "rule_predefined_names"}, # {"type": "rule_local_modules_from_namespace", # "map": {"my_package.subpackage_1": ["my_package.subpackage_2"]}}] # } # #    : # # my_package # |-- __init__.py # |-- subpackage_1 # |-- |-- __init__ # |-- |-- a.py # |-- subpackage_2 # |-- |-- __init__ # |-- |-- b.py # a.py import smart_imports smart_imports.all() print(b)</span></span></code> </pre> </div></div><br><h3>  Hinzuf√ºgen eigener Regeln </h3><br>  Das Hinzuf√ºgen einer eigenen Regel ist ziemlich einfach: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir erben</a> von der Klasse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">smart_imports.rules.BaseRule</a> . </li><li>  Wir erkennen die notwendige Logik. </li><li>  Registrieren Sie eine Regel mit der Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">smart_imports.rules.register</a> </li><li>  F√ºgen Sie die Regel zur Konfiguration hinzu. </li><li>  ??? </li><li>  Gewinn </li></ol><br>  Ein Beispiel findet sich in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umsetzung der aktuellen Regeln.</a> <br><br><h2>  Gewinn </h2><br>  Mehrzeilige Importlisten am Anfang jeder Quelle sind verschwunden. <br><br>  Die Anzahl der Zeilen hat abgenommen.  Bevor der Browser auf intelligente Importe umstellte, waren 6688 Zeilen f√ºr den Import verantwortlich.  Nach dem √úbergang blieb 2084 √ºbrig (zwei Zeilen smart_imports pro Datei + 130 Importe, die explizit von Funktionen und √§hnlichen Stellen aufgerufen wurden). <br><br>  Ein sch√∂ner Bonus war die Standardisierung der Namen im Projekt.  Code ist leichter zu lesen und leichter zu schreiben.  Sie m√ºssen nicht √ºber die Namen der importierten Entit√§ten nachdenken - es gibt einige klare Regeln, die leicht zu befolgen sind. <br><br><h2>  Entwicklungspl√§ne </h2><br>  Ich mag die Idee, Codeeigenschaften durch Variablennamen zu definieren, daher werde ich versuchen, sie sowohl in intelligenten Importen als auch in anderen Projekten zu entwickeln. <br><br>  In Bezug auf intelligente Importe plane ich: <br><br><ol><li>  Unterst√ºtzung f√ºr neue Versionen von Python hinzuf√ºgen. </li><li>  Erkunden Sie die M√∂glichkeit, sich bei der Typanmerkung von Code auf die aktuellen Community-Praktiken zu verlassen. </li><li>  Entdecken Sie die M√∂glichkeit, faul zu importieren. </li><li>  Implementieren Sie Dienstprogramme zur automatischen Generierung einer Konfiguration aus Quellcodes und zum Refactoring von Quellen f√ºr die Verwendung von smart_imports. </li><li>  Schreiben Sie einen Teil des C-Codes neu, um die Arbeit mit dem AST zu beschleunigen. </li><li>  Entwicklung der Integration mit Lintern und IDEs, wenn diese Probleme mit der Codeanalyse ohne explizite Importe haben. </li></ol><br>  Dar√ºber hinaus interessiert mich Ihre Meinung zum Standardverhalten der Bibliothek und zu den Importregeln. <br><br>  Vielen Dank, dass Sie dieses Textblatt √ºberw√§ltigt haben :-D </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459930/">https://habr.com/ru/post/de459930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459914/index.html">SQL Index Manager - ein kostenloses Tool zum Defragmentieren und Verwalten von Indizes</a></li>
<li><a href="../de459918/index.html">Probleml√∂sung mit pwnable.kr 03 - bof. Puffer√ºberlauf auf Stapel</a></li>
<li><a href="../de459922/index.html">Entfernen von hochfrequenten Ger√§uschen aus den Signalen von Schwingungssensoren w√§hrend der Schwingungsdiagnose von Lagern</a></li>
<li><a href="../de459924/index.html">Vollst√§ndiger Reaktionstestzyklus. Auto.ru-Bericht</a></li>
<li><a href="../de459928/index.html">Der Weg des Sch√ºlers zur Entwicklung mobiler Apps</a></li>
<li><a href="../de459934/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 306 (vom 8. bis 14. Juli)</a></li>
<li><a href="../de459936/index.html">9 weitere Tricks f√ºr die Arbeit mit Visual Studio</a></li>
<li><a href="../de459948/index.html">Implementierung physikalisch korrekter volumetrischer Wolken wie in Horizon Zero Dawn</a></li>
<li><a href="../de459952/index.html">Ein wenig Erfahrung mit Backup & Storage</a></li>
<li><a href="../de459954/index.html">Warum eines der gr√∂√üten IT-Unternehmen zu CNCF kam - einem Fonds zur Entwicklung der Cloud-Infrastruktur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>