<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõë üèÇüèæ üçì Historia olvidada de OOP üöÉ üôãüèº üìã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La mayor√≠a de los paradigmas de programaci√≥n que usamos hoy se estudiaron matem√°ticamente por primera vez en la d√©cada de 1930 utilizando las ideas de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Historia olvidada de OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/428582/"> La mayor√≠a de los paradigmas de programaci√≥n que usamos hoy se estudiaron matem√°ticamente por primera vez en la d√©cada de 1930 utilizando las ideas del c√°lculo lambda y la m√°quina de Turing, que son variantes del modelo de computaci√≥n universal (estos son sistemas formalizados que pueden realizar c√°lculos de prop√≥sito general).  La tesis de Church-Turing mostr√≥ que el c√°lculo lambda y las m√°quinas de Turing son funcionalmente equivalentes.  Es decir, estamos hablando del hecho de que todo lo que se puede calcular usando una m√°quina de Turing tambi√©n se puede calcular usando el c√°lculo lambda, y viceversa. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/hq/so/jp/hqsojpds8ed1zxx9g7lelnfknbu.jpeg"></a> <br><a name="habracut"></a><br>  Existe una idea err√≥nea de que las m√°quinas de Turing pueden calcular todo lo que se puede calcular.  Hay clases de problemas (por ejemplo, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema de la detenci√≥n</a> ) que pueden calcularse utilizando m√°quinas de Turing solo en algunos casos.  Cuando la palabra "computablemente" se usa en este texto, significa "computablemente por una m√°quina de Turing". <br><br>  El c√°lculo de Lambda demuestra el enfoque de aplicar funciones a los c√°lculos de arriba hacia abajo.  Una m√°quina de cinta Turing es un enfoque imperativo (paso a paso) para la inform√°tica, implementado de abajo hacia arriba. <br><br>  Los lenguajes de programaci√≥n de bajo nivel, como el c√≥digo de m√°quina o el ensamblador, aparecieron en la d√©cada de 1940 y, a fines de la d√©cada de 1950, surgieron los primeros lenguajes populares de alto nivel que implementaron enfoques funcionales e imperativos.  Entonces, los dialectos del lenguaje Lisp todav√≠a se usan ampliamente, entre ellos Clojure, Scheme, AutoLisp, etc.  En los a√±os cincuenta aparecieron idiomas como FORTRAN y COBOL.  Son ejemplos de lenguajes imperativos de alto nivel que a√∫n est√°n vivos.  Aunque debe tenerse en cuenta que los lenguajes de la familia C, en la mayor√≠a de las √°reas, reemplazaron COBOL y FORTRAN. <br><br>  Las ra√≠ces de la programaci√≥n imperativa y funcional se encuentran en las matem√°ticas formales de la inform√°tica, aparecieron antes que las computadoras digitales.  La Programaci√≥n Orientada a Objetos (OOP), lleg√≥ m√°s tarde, se origina en la revoluci√≥n de la programaci√≥n estructural, que tuvo lugar en los a√±os sesenta y setenta del siglo pasado. <br><br>  El primer objeto que conoc√≠ fue utilizado por Ivan Sutherland en su fat√≠dica aplicaci√≥n Sketchpad, creada entre 1961 y 1962, que describi√≥ en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> trabajo en 1963.  Los objetos eran caracteres gr√°ficos que se mostraban en una pantalla de osciloscopio (tal vez este es el primer caso en la historia del uso de un monitor gr√°fico de computadora) y apoyaban la herencia a trav√©s de delegados din√°micos, que Ivan Sutherland llam√≥ "maestros" en su trabajo.  Cualquier objeto podr√≠a convertirse en un objeto maestro, las instancias adicionales del objeto se denominaron "ocurrencias".  Esto convirti√≥ al sistema Sketchpad en el propietario del primero de los famosos lenguajes de programaci√≥n que implementaron la herencia del prototipo. <br><br>  El primer lenguaje de programaci√≥n, com√∫nmente conocido como "orientado a objetos", fue el lenguaje Simula, cuyas especificaciones se desarrollaron en 1965.  Al igual que Sketchpad, Silmula proporcion√≥ para trabajar con objetos, pero tambi√©n incluy√≥ clases, herencia basada en clases, subclases y m√©todos virtuales. <br><br>  <i><font color="#999999">Un m√©todo virtual es un m√©todo definido en una clase que est√° dise√±ada para ser redefinida por subclases.</font></i>  <i><font color="#999999">Los m√©todos virtuales permiten que los programas invoquen m√©todos que pueden no existir en el momento en que se compila el c√≥digo, mediante el env√≠o din√°mico para determinar qu√© m√©todo en particular se debe llamar durante la ejecuci√≥n del programa.</font></i>  <i><font color="#999999">JavaScript tiene tipos din√°micos y utiliza una cadena de delegaci√≥n para determinar qu√© m√©todo invocar. Como resultado, este lenguaje no necesita introducir el concepto de m√©todos virtuales a los programadores.</font></i>  <i><font color="#999999">En otras palabras, todos los m√©todos en JavaScript usan despacho en tiempo de ejecuci√≥n, como resultado, los m√©todos en JavaScript no necesitan ser declarados "virtuales" para admitir esta funci√≥n.</font></i> <br><br><h2>  <font color="#3AC1EF">Opini√≥n del padre de OOP sobre OOP</font> </h2><br>  <i><font color="#999999">"Acu√±√© el t√©rmino" orientado a objetos "y puedo decir que no quise decir C ++".</font></i>  <i><font color="#999999">Alan Kay, Conferencia OOPSLA, 1997.</font></i> <br><br>  Alan Kay acu√±√≥ el t√©rmino "programaci√≥n orientada a objetos", refiri√©ndose al lenguaje de programaci√≥n Smalltalk (1972).  Este lenguaje fue desarrollado por Alan Kay, Dan Ingles y otros empleados del Centro de Investigaci√≥n Xerox PARC como parte del proyecto del dispositivo Dynabook.  Smalltalk estaba m√°s orientado a objetos que Simula.  En Smalltalk, todo es un objeto, incluidas clases, enteros y bloques (cierres).  La implementaci√≥n inicial del lenguaje, Smalltalk-72, no ten√≠a la capacidad de subclase.  Esta caracter√≠stica apareci√≥ en Smalltalk-76. <br><br>  Si bien Smalltalk apoy√≥ clases y, como resultado, subclases, Smalltalk no puso estas ideas a la vanguardia.  Era un lenguaje funcional que Lisp influy√≥ tanto como Simula.  Seg√∫n Alan Kay, tratar las clases como un mecanismo de reutilizaci√≥n de c√≥digo es un error.  La industria de la programaci√≥n presta gran atenci√≥n a la creaci√≥n de subclases, lo que distrae las ventajas reales de la programaci√≥n orientada a objetos. <br><br>  JavaScript y Smalltalk tienen mucho en com√∫n.  Yo dir√≠a que JavaScript es la venganza de Smalltalk en el mundo por malinterpretar los conceptos de OOP.  Ambos idiomas admiten las siguientes caracter√≠sticas: <br><br><ul><li>  Objetos </li><li>  Funciones y cierres de primera clase. </li><li>  Tipos din√°micos </li><li>  Enlace tard√≠o (las funciones y m√©todos se pueden reemplazar durante la ejecuci√≥n del programa). </li><li>  OOP sin un sistema de herencia basado en clases. </li></ul><br>  <i><font color="#999999">"Lamento haber inventado el t√©rmino" objetos "para este fen√≥meno hace mucho tiempo, ya que su uso lleva al hecho de que muchas personas le dan una importancia primordial a una idea que no es tan importante como la principal.</font></i>  <i><font color="#999999">La idea principal es la mensajer√≠a ".</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  En una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">correspondencia por</a> correo electr√≥nico de 2003, Alan Kay aclar√≥ lo que ten√≠a en mente cuando llam√≥ a Smalltalk "un lenguaje orientado a objetos". <br><br>  <i><font color="#999999">"Para m√≠, OOP solo significa mensajer√≠a, almacenamiento local y protecci√≥n, y estado de ocultaci√≥n, y enlace muy tard√≠o".</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  En otras palabras, de acuerdo con las ideas de Alan Kay, los ingredientes OOP m√°s importantes son los siguientes: <br><br><ul><li>  Mensajer√≠a </li><li>  Encapsulaci√≥n </li><li>  Enlace din√°mico. </li></ul><br>  Es importante tener en cuenta que Alan Kay, el hombre que invent√≥ el t√©rmino "OOP" y lo trajo a las masas, no consider√≥ que la herencia y el polimorfismo fueran los componentes m√°s importantes de OOP. <br><br><h2>  <font color="#3AC1EF">La esencia de OOP</font> </h2><br>  La combinaci√≥n de mensajer√≠a y encapsulaci√≥n sirve para varios prop√≥sitos importantes: <br><br><ul><li>  Evitar el estado mutable compartido de un objeto encapsulando el estado y aislando otros objetos de los cambios locales en su estado.  La √∫nica forma de influir en el estado de otro objeto es pedirle (en lugar de darle una orden) que cambie envi√°ndole un mensaje.  Los cambios de estado se controlan a nivel local, celular, el estado no est√° disponible para otros objetos. </li><li>  Separaci√≥n de objetos entre s√≠.  El remitente del mensaje se acopla libremente al destinatario a trav√©s de la API de mensajer√≠a. </li><li>  Adaptabilidad y resistencia a los cambios durante la ejecuci√≥n del programa a trav√©s del enlace tard√≠o.  La adaptaci√≥n a los cambios durante la ejecuci√≥n del programa ofrece muchas ventajas significativas, que Alan Kay considera muy importantes para la POO. </li></ul><br>  Alan Kay, quien expres√≥ estas ideas, se inspir√≥ en su conocimiento de la biolog√≠a y lo que sab√≠a sobre ARPANET (esta es una versi√≥n temprana de Internet).  Es decir, estamos hablando de c√©lulas biol√≥gicas y de computadoras individuales conectadas a la red.  Incluso entonces, Alan Kay imagin√≥ c√≥mo los programas se ejecutan en grandes computadoras distribuidas (Internet), mientras que las computadoras individuales act√∫an como c√©lulas biol√≥gicas, trabajando independientemente con su propio estado aislado e intercambiando datos con otras computadoras mediante el env√≠o de mensajes. <br><br>  <i><font color="#999999">"Me di cuenta de que una met√°fora para una c√©lula o computadora ayudar√° a eliminar los datos [...]".</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Al decir "ayudar a deshacerse de los datos", Alan Kay, por supuesto, era consciente de los problemas causados ‚Äã‚Äãpor el estado mutable compartido y la fuerte conectividad causada por el intercambio de datos.  Hoy, estos temas son ampliamente escuchados.  Pero a fines de la d√©cada de 1960, los programadores de ARPANET no estaban contentos con la necesidad de elegir una representaci√≥n de modelo de datos para sus programas antes de desarrollar programas.  Los desarrolladores quer√≠an alejarse de esta pr√°ctica, ya que, al haberse introducido en el marco definido por la presentaci√≥n de los datos, es m√°s dif√≠cil cambiar algo en el futuro. <br><br>  El problema era que se necesitaban diferentes formas de presentar los datos, para acceder a ellos, diferentes c√≥digos y diferentes sintaxis en los lenguajes de programaci√≥n utilizados en alg√∫n momento.  El Santo Grial aqu√≠ ser√≠a una forma universal de acceder y administrar datos.  Si todos los datos tuvieran el mismo aspecto para el programa, esto resolver√≠a muchos problemas de los desarrolladores con respecto al desarrollo y mantenimiento de los programas. <br>  Alan Kay intent√≥ "deshacerse" de la idea, seg√∫n la cual los datos y los programas eran, en cierto sentido, entidades independientes.  No se consideran como tales en List o Smalltalk.  No hay separaci√≥n entre lo que se puede hacer con datos (con valores, variables, estructuras de datos, etc.) y construcciones de software como funciones.  Las funciones son "ciudadanos de primera clase" y los programas pueden cambiar durante su ejecuci√≥n.  En otras palabras, Smalltalk no tiene una relaci√≥n especial y privilegiada con los datos. <br><br>  Alan Kay, adem√°s, consideraba los objetos como estructuras algebraicas, lo que daba garant√≠as definidas y matem√°ticamente comprobables de su comportamiento. <br><br>  <i><font color="#999999">"Mi formaci√≥n matem√°tica me permiti√≥ comprender que cada objeto puede tener varios modelos algebraicos asociados, que puede haber grupos enteros de modelos similares y que pueden ser muy, muy √∫tiles".</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Se demostr√≥ que es as√≠, y esto form√≥ la base para objetos, como promesas y lentes, adem√°s, la teor√≠a de la categor√≠a fue influenciada por ambos. <br>  La naturaleza algebraica de c√≥mo Alan Kay vio los objetos permitir√≠a a los objetos proporcionar verificaci√≥n formal, comportamiento determinista y mejorar la capacidad de prueba, ya que los modelos algebraicos son, en esencia, operaciones que obedecen a varias reglas en forma de ecuaciones. <br><br>  En la jerga de los programadores, los "modelos algebraicos" son abstracciones creadas a partir de funciones (operaciones) que van acompa√±adas de ciertas reglas, impuestas por pruebas unitarias que estas funciones deben aprobar (axiomas, ecuaciones). <br><br>  Estas ideas se han olvidado durante d√©cadas en la mayor√≠a de los lenguajes orientados a objetos de la familia C, incluidos C ++, Java, C #, etc.  Pero estas ideas comienzan la b√∫squeda del viaje de regreso, en versiones recientes de los lenguajes orientados a objetos m√°s utilizados. <br><br>  En esta ocasi√≥n, alguien puede decir que el mundo de la programaci√≥n redescubre los beneficios de la programaci√≥n funcional y proporciona argumentos racionales en el contexto de los lenguajes orientados a objetos. <br><br>  Al igual que JavaScript y Smalltalk anteriormente, la mayor√≠a de los lenguajes modernos orientados a objetos se est√°n volviendo cada vez m√°s "multi-paradigm√°ticos".  No hay raz√≥n para elegir entre programaci√≥n funcional y OOP.  Cuando miramos la esencia hist√≥rica de cada uno de estos enfoques, se ven no solo como compatibles, sino tambi√©n como ideas complementarias. <br><br>  ¬øCu√°l, de acuerdo con los pensamientos de Alan Kay, es lo m√°s importante en la OLP? <br><br><ul><li>  Encapsulaci√≥n </li><li>  Mensajer√≠a </li><li>  Enlace din√°mico (la capacidad de los programas para desarrollarse y adaptarse a los cambios durante su ejecuci√≥n). </li></ul><br>  ¬øQu√© es insignificante en OOP? <br><br><ul><li>  Clases </li><li>  Herencia basada en clases. </li><li>  Relaci√≥n particular con objetos, funciones o datos. </li><li> Palabra clave <code>new</code> . </li><li>  Polimorfismo </li><li>  Mecanograf√≠a est√°tica. </li><li>  Actitud hacia las clases como "tipos". </li></ul><br>  Si conoce Java o C #, podr√≠a pensar que la tipificaci√≥n est√°tica o el polimorfismo son los ingredientes m√°s importantes de la POO, pero Alan Kay prefiere tratar con patrones de comportamiento universal en forma algebraica.  Aqu√≠ hay un ejemplo escrito en Haskell: <br><br><pre> <code class="hljs erlang-repl">fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br>  Esta es la firma del functor de <code>map</code> universal, que funciona con los tipos indefinidos <code>b</code> , aplicando la funci√≥n de <code>a</code> a <code>b</code> en el contexto del functor <code>a</code> para crear el functor <code>b</code> .  "Functor" es una palabra de la jerga matem√°tica, cuyo significado se reduce a "soporte de la operaci√≥n de visualizaci√≥n".  Si est√° familiarizado con el m√©todo <code>[].map()</code> en JavaScript, ya sabe lo que esto significa. <br><br>  Aqu√≠ hay un par de ejemplos de JavaScript: <br><br><pre> <code class="hljs powershell">// isEven = Number =&gt; Boolean const isEven = n =&gt; n % <span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">0</span></span>; const nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; //  map   `a =&gt; b`    `a` ( `this`) //     `b` //    `a`   `Number`,   `b`  `Boolean` const results = nums.map(isEven); console.log(results); // [<span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>]</code> </pre> <br>  El m√©todo <code>.map()</code> es universal, en el sentido de que <code>b</code> pueden ser de cualquier tipo, y este m√©todo hace frente a una situaci√≥n similar sin problemas, ya que las matrices son estructuras de datos que implementan las leyes algebraicas de los functores.  Los tipos para <code>.map()</code> no importan, ya que este m√©todo no intenta trabajar directamente con los valores correspondientes.  En cambio, utiliza una funci√≥n que espera y devuelve valores de los tipos correspondientes que son correctos desde el punto de vista de la aplicaci√≥n. <br><br><pre> <code class="hljs pgsql">// matches = a =&gt; <span class="hljs-type"><span class="hljs-type">Boolean</span></span> //  `a`    ,   const matches = control =&gt; input =&gt; input === control; const strings = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>]; const results = strings.map(matches(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>)); console.log(results); // [<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>]</code> </pre> <br>  La relaci√≥n de tipos universales puede ser dif√≠cil de expresar correcta y completamente en lenguajes como TypeScript, pero es muy simple de hacer en el sistema de tipos Hindley-Milner utilizado en Haskell, que admite tipos superiores (tipos de tipos). <br><br>  La mayor√≠a de los sistemas de tipos imponen restricciones demasiado fuertes para permitir la libre expresi√≥n de ideas din√°micas y funcionales, como la composici√≥n de funciones, la composici√≥n libre de objetos, la expansi√≥n de objetos durante la ejecuci√≥n del programa, el uso de combinadores, lentes, etc.  En otras palabras?  Los tipos est√°ticos a menudo dificultan la escritura de software utilizando m√©todos de compilaci√≥n. <br><br>  Si su sistema de tipos tiene demasiadas restricciones (como en TypeScript o Java), entonces, para lograr los mismos objetivos, debe escribir un c√≥digo m√°s complejo que cuando usa idiomas con un enfoque m√°s libre para escribir.  Esto no significa que el uso de tipos est√°ticos sea una idea desafortunada, o que todas las implementaciones de tipos est√°ticos tengan las mismas limitaciones.  Por ejemplo, he encontrado muchos menos problemas al trabajar con el sistema de tipo Haskell. <br><br>  Si eres fan√°tico de los tipos est√°ticos y no est√°s en contra de las restricciones, te deseo siete pies debajo de la quilla.  Pero si encuentra que algunas de las ideas expresadas aqu√≠ son dif√≠ciles de implementar porque no es f√°cil escribir funciones obtenidas al componer otras funciones y estructuras algebraicas compuestas, entonces culpe al sistema de tipos y no a la idea.  A los conductores les gustan las comodidades que les brindan los SUV cuadro a cuadro, pero nadie se queja de que no vuelan.  Para volar, necesita un veh√≠culo que tenga m√°s grados de libertad. <br><br>  Si las restricciones simplifican su c√≥digo, ¬°excelente!  Pero si las restricciones lo obligan a escribir c√≥digo m√°s complejo, entonces tal vez algo est√© mal con estas restricciones. <br><br><h2>  <font color="#3AC1EF">¬øQu√© es un "objeto"?</font> </h2><br>  La palabra "objeto", con el tiempo, ha adquirido muchas connotaciones secundarias de significado.  Lo que llamamos "objetos" en JavaScript son simplemente tipos de datos compuestos, sin ning√∫n indicio de la programaci√≥n basada en la clase o las ideas de mensaje de Alan Kay. <br><br>  En JavaScript, estos objetos pueden admitir, y a menudo admiten, la encapsulaci√≥n, el paso de mensajes, la separaci√≥n del comportamiento a trav√©s de m√©todos, incluso el polimorfismo utilizando subclases (aunque utilizando una cadena de delegaci√≥n en lugar de un env√≠o basado en tipos). <br><br>  Alan Kay quer√≠a deshacerse de la diferencia entre el programa y sus datos.  JavaScript, en cierta medida, logra este objetivo colocando los m√©todos de objeto en el mismo lugar que las propiedades que almacenan los datos.  A cualquier propiedad, por ejemplo, se le puede asignar cualquier funci√≥n.  Puede construir el comportamiento del objeto din√°micamente y cambiar el contenido sem√°ntico del objeto durante la ejecuci√≥n del programa. <br><br>  Un objeto es solo una estructura de datos compuesta, y no necesita nada especial para ser considerado un objeto.  Sin embargo, la programaci√≥n usando objetos no conduce al hecho de que dicho c√≥digo resulta estar "orientado a objetos", as√≠ como el uso de funciones no hace que el c√≥digo sea "funcional". <br><br><h2>  <font color="#3AC1EF">OOP ya no es una verdadera OOP</font> </h2><br>  Dado que el concepto de "objeto" en los lenguajes de programaci√≥n modernos significa mucho menos de lo que Alan Kay quiso decir, uso la palabra "componente" en lugar de la palabra "objeto" para describir las reglas de esta OOP.  Muchos objetos son propiedad y control directo de alg√∫n c√≥digo JavaScript de terceros, pero los componentes deben encapsular su propio estado y controlarlo. <br><br>  Esto es lo que es la verdadera OOP: <br><br><ul><li>  Programaci√≥n utilizando componentes (Alan Kay los llama "objetos"). </li><li>  El estado del componente debe estar encapsulado. </li><li>  Para la comunicaci√≥n entre entidades, se utiliza la mensajer√≠a. </li><li>  Los componentes se pueden agregar, modificar y reemplazar en tiempo de ejecuci√≥n. </li></ul><br>  La mayor√≠a de los comportamientos de los objetos se pueden definir de manera universal utilizando estructuras de datos algebraicos.  No hay necesidad de herencia.  Los componentes pueden reutilizar comportamientos de funciones p√∫blicas y m√≥dulos de importaci√≥n, sin tener que hacer p√∫blicos sus datos. <br><br>  Manipular objetos en JavaScript o usar una herencia basada en clases no significa que alguien est√© involucrado en la programaci√≥n de OOP.  Pero el uso de componentes de tal manera - significa.  Pero es muy dif√≠cil deshacerse de las ideas establecidas sobre los t√©rminos, por lo que tal vez deber√≠amos dejar el t√©rmino "OOP" y llamar a lo que los "componentes" anteriores se usan como "Programaci√≥n Orientada a Mensajes (MOP)".  Utilizaremos el t√©rmino "MOP" a continuaci√≥n para hablar sobre la programaci√≥n orientada a mensajes. <br><br>  Por casualidad, la palabra inglesa "trapeador" se traduce como "trapeador" y, como saben, se utilizan para restablecer el orden. <br><br><h2>  <font color="#3AC1EF">¬øC√≥mo se ve un buen MOP?</font> </h2><br>  La mayor√≠a de los programas modernos tienen una determinada interfaz de usuario (Interfaz de usuario, UI) responsable de interactuar con el usuario, alg√∫n c√≥digo dedicado a administrar el estado de la aplicaci√≥n (datos del usuario) y un c√≥digo que funciona con el sistema o es responsable del intercambio de datos con la red. <br><br>  Para admitir el funcionamiento de cada uno de estos sistemas, pueden ser necesarios procesos de larga duraci√≥n, como los oyentes de eventos.  Aqu√≠ necesitar√° el estado de la aplicaci√≥n: para almacenar informaci√≥n como las conexiones de red, el estado de las cosas con los controles de la interfaz y la aplicaci√≥n en s√≠. <br><br>  Un buen MOP significa que, en lugar de que todos esos sistemas tengan acceso al estado del otro y puedan controlarlos directamente, interact√∫an entre s√≠ a trav√©s de mensajes.  Cuando el usuario hace clic en el bot√≥n <code>"SAVE"</code> , se puede enviar el mensaje <code>"SAVE"</code> .  El componente de la aplicaci√≥n de gesti√≥n de estado puede interpretar este mensaje y redirigirlo al controlador responsable de la actualizaci√≥n desde el estado (como una funci√≥n reductora pura).  Quiz√°s, despu√©s de actualizar el estado, el componente responsable de administrar el estado env√≠a el mensaje <code>"STATE_UPDATED"</code> componente de interfaz de usuario, que, a su vez, interpreta el estado, decide qu√© partes de la interfaz deben actualizarse y transfiere el estado actualizado a los subcomponentes responsables de trabajar con Elementos de interfaz espec√≠ficos. <br><br>  Mientras tanto, el componente responsable de las conexiones de red puede monitorear la conexi√≥n del usuario a otra computadora en la red, escuchar mensajes y enviar una vista actualizada del estado para guardarlo en la m√°quina remota.  Dicho componente es responsable de trabajar con mecanismos de red, sabe si la conexi√≥n funciona o no, y as√≠ sucesivamente. <br><br>  Sistemas de aplicaci√≥n similares no deben conocer los detalles de sus otras partes.  Solo deber√≠an preocuparse por resolver sus propios problemas.  Los componentes del sistema pueden desmontarse y ensamblarse como constructor.  Implementan interfaces estandarizadas, lo que significa que pueden interactuar entre s√≠.  Mientras se cumplan los requisitos bien conocidos para la interfaz de los componentes, dichos componentes pueden ser reemplazados por otros, con las mismas interfaces, pero haciendo lo mismo de manera diferente, o realizando, recibiendo los mismos mensajes, algo completamente diferente.  Puede cambiar un componente a otro incluso durante la ejecuci√≥n del programa; esto no interrumpir√° su trabajo. <br><br>  Los componentes de un sistema de software ni siquiera tienen que estar en la misma computadora.  El sistema puede ser descentralizado.  El almacenamiento en red puede colocar datos en un sistema de almacenamiento descentralizado como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IPFS</a> , como resultado, el usuario es independiente del estado de una m√°quina en particular, lo que garantiza la seguridad de sus datos.  Con este enfoque, los datos se almacenan de manera confiable y se protegen de intrusos. <br><br>  La OLP, en parte, qued√≥ bajo la influencia de las ideas de ARPANET, y uno de los objetivos de este proyecto era crear una red descentralizada que fuera resistente a ataques como un ataque nuclear. <br><br>  Un buen sistema MOP puede caracterizarse por un nivel similar de estabilidad utilizando componentes que admiten el intercambio en caliente mientras la aplicaci√≥n se est√° ejecutando.  Podr√° continuar funcionando si el usuario trabaja con √©l desde un tel√©fono celular y est√° fuera de la cobertura de la red debido a que ha entrado en el t√∫nel.  Si un hurac√°n interrumpi√≥ el suministro de energ√≠a de uno de los centros de datos en los que se encuentran sus servidores, tambi√©n continuar√° funcionando. <br><br>  Es hora de que el mundo del software se libere de un exitoso experimento de herencia basado en clases y adopte los principios matem√°ticos y cient√≠ficos que estuvieron a la vanguardia de la POO. <br><br>  Es hora de que los desarrolladores creemos programas m√°s flexibles, estables y hermosos utilizando una combinaci√≥n armoniosa de MOP y programaci√≥n funcional. <br>  Por cierto, el acr√≥nimo "MOP" ya est√° en uso, describiendo "Programaci√≥n orientada al monitoreo", pero este concepto, a diferencia de OOP, simplemente desaparecer√° silenciosamente. <br><br>  Por lo tanto, no se desanime si el t√©rmino "MOP" no parece una palabra de la jerga de los programadores.  Simplemente ordena tu OOP con los principios de MOP anteriores. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428582/">https://habr.com/ru/post/es428582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428572/index.html">Componentes de orden superior en reacci√≥n</a></li>
<li><a href="../es428574/index.html">Lleve la comunicaci√≥n corporativa al siguiente nivel con Zextras Chat</a></li>
<li><a href="../es428576/index.html">[marcador] Versi√≥n en PDF del tutorial de Node.js y nueva gu√≠a de JavaScript</a></li>
<li><a href="../es428578/index.html">C√≥mo comenzar con Hibernate Search</a></li>
<li><a href="../es428580/index.html">Buena gu√≠a de comunicaci√≥n</a></li>
<li><a href="../es428588/index.html">Resumen de los eventos de TI en noviembre (segunda parte)</a></li>
<li><a href="../es428590/index.html">Microinteracciones y micro indicaciones en la interfaz</a></li>
<li><a href="../es428592/index.html">Deje de contratar "gerentes efectivos". No solo son in√∫tiles, sino da√±inos</a></li>
<li><a href="../es428596/index.html">Elon Musk despidi√≥ a los gerentes de proyectos de Internet satelital de Starlink debido al incumplimiento de los plazos</a></li>
<li><a href="../es428598/index.html">Redes neuronales profundas para la evaluaci√≥n autom√°tica de llamadas.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>