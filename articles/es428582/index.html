<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Historia olvidada de OOP   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La mayor铆a de los paradigmas de programaci贸n que usamos hoy se estudiaron matem谩ticamente por primera vez en la d茅cada de 1930 utilizando las ideas de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Historia olvidada de OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/428582/"> La mayor铆a de los paradigmas de programaci贸n que usamos hoy se estudiaron matem谩ticamente por primera vez en la d茅cada de 1930 utilizando las ideas del c谩lculo lambda y la m谩quina de Turing, que son variantes del modelo de computaci贸n universal (estos son sistemas formalizados que pueden realizar c谩lculos de prop贸sito general).  La tesis de Church-Turing mostr贸 que el c谩lculo lambda y las m谩quinas de Turing son funcionalmente equivalentes.  Es decir, estamos hablando del hecho de que todo lo que se puede calcular usando una m谩quina de Turing tambi茅n se puede calcular usando el c谩lculo lambda, y viceversa. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/hq/so/jp/hqsojpds8ed1zxx9g7lelnfknbu.jpeg"></a> <br><a name="habracut"></a><br>  Existe una idea err贸nea de que las m谩quinas de Turing pueden calcular todo lo que se puede calcular.  Hay clases de problemas (por ejemplo, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema de la detenci贸n</a> ) que pueden calcularse utilizando m谩quinas de Turing solo en algunos casos.  Cuando la palabra "computablemente" se usa en este texto, significa "computablemente por una m谩quina de Turing". <br><br>  El c谩lculo de Lambda demuestra el enfoque de aplicar funciones a los c谩lculos de arriba hacia abajo.  Una m谩quina de cinta Turing es un enfoque imperativo (paso a paso) para la inform谩tica, implementado de abajo hacia arriba. <br><br>  Los lenguajes de programaci贸n de bajo nivel, como el c贸digo de m谩quina o el ensamblador, aparecieron en la d茅cada de 1940 y, a fines de la d茅cada de 1950, surgieron los primeros lenguajes populares de alto nivel que implementaron enfoques funcionales e imperativos.  Entonces, los dialectos del lenguaje Lisp todav铆a se usan ampliamente, entre ellos Clojure, Scheme, AutoLisp, etc.  En los a帽os cincuenta aparecieron idiomas como FORTRAN y COBOL.  Son ejemplos de lenguajes imperativos de alto nivel que a煤n est谩n vivos.  Aunque debe tenerse en cuenta que los lenguajes de la familia C, en la mayor铆a de las 谩reas, reemplazaron COBOL y FORTRAN. <br><br>  Las ra铆ces de la programaci贸n imperativa y funcional se encuentran en las matem谩ticas formales de la inform谩tica, aparecieron antes que las computadoras digitales.  La Programaci贸n Orientada a Objetos (OOP), lleg贸 m谩s tarde, se origina en la revoluci贸n de la programaci贸n estructural, que tuvo lugar en los a帽os sesenta y setenta del siglo pasado. <br><br>  El primer objeto que conoc铆 fue utilizado por Ivan Sutherland en su fat铆dica aplicaci贸n Sketchpad, creada entre 1961 y 1962, que describi贸 en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> trabajo en 1963.  Los objetos eran caracteres gr谩ficos que se mostraban en una pantalla de osciloscopio (tal vez este es el primer caso en la historia del uso de un monitor gr谩fico de computadora) y apoyaban la herencia a trav茅s de delegados din谩micos, que Ivan Sutherland llam贸 "maestros" en su trabajo.  Cualquier objeto podr铆a convertirse en un objeto maestro, las instancias adicionales del objeto se denominaron "ocurrencias".  Esto convirti贸 al sistema Sketchpad en el propietario del primero de los famosos lenguajes de programaci贸n que implementaron la herencia del prototipo. <br><br>  El primer lenguaje de programaci贸n, com煤nmente conocido como "orientado a objetos", fue el lenguaje Simula, cuyas especificaciones se desarrollaron en 1965.  Al igual que Sketchpad, Silmula proporcion贸 para trabajar con objetos, pero tambi茅n incluy贸 clases, herencia basada en clases, subclases y m茅todos virtuales. <br><br>  <i><font color="#999999">Un m茅todo virtual es un m茅todo definido en una clase que est谩 dise帽ada para ser redefinida por subclases.</font></i>  <i><font color="#999999">Los m茅todos virtuales permiten que los programas invoquen m茅todos que pueden no existir en el momento en que se compila el c贸digo, mediante el env铆o din谩mico para determinar qu茅 m茅todo en particular se debe llamar durante la ejecuci贸n del programa.</font></i>  <i><font color="#999999">JavaScript tiene tipos din谩micos y utiliza una cadena de delegaci贸n para determinar qu茅 m茅todo invocar. Como resultado, este lenguaje no necesita introducir el concepto de m茅todos virtuales a los programadores.</font></i>  <i><font color="#999999">En otras palabras, todos los m茅todos en JavaScript usan despacho en tiempo de ejecuci贸n, como resultado, los m茅todos en JavaScript no necesitan ser declarados "virtuales" para admitir esta funci贸n.</font></i> <br><br><h2>  <font color="#3AC1EF">Opini贸n del padre de OOP sobre OOP</font> </h2><br>  <i><font color="#999999">"Acu帽茅 el t茅rmino" orientado a objetos "y puedo decir que no quise decir C ++".</font></i>  <i><font color="#999999">Alan Kay, Conferencia OOPSLA, 1997.</font></i> <br><br>  Alan Kay acu帽贸 el t茅rmino "programaci贸n orientada a objetos", refiri茅ndose al lenguaje de programaci贸n Smalltalk (1972).  Este lenguaje fue desarrollado por Alan Kay, Dan Ingles y otros empleados del Centro de Investigaci贸n Xerox PARC como parte del proyecto del dispositivo Dynabook.  Smalltalk estaba m谩s orientado a objetos que Simula.  En Smalltalk, todo es un objeto, incluidas clases, enteros y bloques (cierres).  La implementaci贸n inicial del lenguaje, Smalltalk-72, no ten铆a la capacidad de subclase.  Esta caracter铆stica apareci贸 en Smalltalk-76. <br><br>  Si bien Smalltalk apoy贸 clases y, como resultado, subclases, Smalltalk no puso estas ideas a la vanguardia.  Era un lenguaje funcional que Lisp influy贸 tanto como Simula.  Seg煤n Alan Kay, tratar las clases como un mecanismo de reutilizaci贸n de c贸digo es un error.  La industria de la programaci贸n presta gran atenci贸n a la creaci贸n de subclases, lo que distrae las ventajas reales de la programaci贸n orientada a objetos. <br><br>  JavaScript y Smalltalk tienen mucho en com煤n.  Yo dir铆a que JavaScript es la venganza de Smalltalk en el mundo por malinterpretar los conceptos de OOP.  Ambos idiomas admiten las siguientes caracter铆sticas: <br><br><ul><li>  Objetos </li><li>  Funciones y cierres de primera clase. </li><li>  Tipos din谩micos </li><li>  Enlace tard铆o (las funciones y m茅todos se pueden reemplazar durante la ejecuci贸n del programa). </li><li>  OOP sin un sistema de herencia basado en clases. </li></ul><br>  <i><font color="#999999">"Lamento haber inventado el t茅rmino" objetos "para este fen贸meno hace mucho tiempo, ya que su uso lleva al hecho de que muchas personas le dan una importancia primordial a una idea que no es tan importante como la principal.</font></i>  <i><font color="#999999">La idea principal es la mensajer铆a ".</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  En una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">correspondencia por</a> correo electr贸nico de 2003, Alan Kay aclar贸 lo que ten铆a en mente cuando llam贸 a Smalltalk "un lenguaje orientado a objetos". <br><br>  <i><font color="#999999">"Para m铆, OOP solo significa mensajer铆a, almacenamiento local y protecci贸n, y estado de ocultaci贸n, y enlace muy tard铆o".</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  En otras palabras, de acuerdo con las ideas de Alan Kay, los ingredientes OOP m谩s importantes son los siguientes: <br><br><ul><li>  Mensajer铆a </li><li>  Encapsulaci贸n </li><li>  Enlace din谩mico. </li></ul><br>  Es importante tener en cuenta que Alan Kay, el hombre que invent贸 el t茅rmino "OOP" y lo trajo a las masas, no consider贸 que la herencia y el polimorfismo fueran los componentes m谩s importantes de OOP. <br><br><h2>  <font color="#3AC1EF">La esencia de OOP</font> </h2><br>  La combinaci贸n de mensajer铆a y encapsulaci贸n sirve para varios prop贸sitos importantes: <br><br><ul><li>  Evitar el estado mutable compartido de un objeto encapsulando el estado y aislando otros objetos de los cambios locales en su estado.  La 煤nica forma de influir en el estado de otro objeto es pedirle (en lugar de darle una orden) que cambie envi谩ndole un mensaje.  Los cambios de estado se controlan a nivel local, celular, el estado no est谩 disponible para otros objetos. </li><li>  Separaci贸n de objetos entre s铆.  El remitente del mensaje se acopla libremente al destinatario a trav茅s de la API de mensajer铆a. </li><li>  Adaptabilidad y resistencia a los cambios durante la ejecuci贸n del programa a trav茅s del enlace tard铆o.  La adaptaci贸n a los cambios durante la ejecuci贸n del programa ofrece muchas ventajas significativas, que Alan Kay considera muy importantes para la POO. </li></ul><br>  Alan Kay, quien expres贸 estas ideas, se inspir贸 en su conocimiento de la biolog铆a y lo que sab铆a sobre ARPANET (esta es una versi贸n temprana de Internet).  Es decir, estamos hablando de c茅lulas biol贸gicas y de computadoras individuales conectadas a la red.  Incluso entonces, Alan Kay imagin贸 c贸mo los programas se ejecutan en grandes computadoras distribuidas (Internet), mientras que las computadoras individuales act煤an como c茅lulas biol贸gicas, trabajando independientemente con su propio estado aislado e intercambiando datos con otras computadoras mediante el env铆o de mensajes. <br><br>  <i><font color="#999999">"Me di cuenta de que una met谩fora para una c茅lula o computadora ayudar谩 a eliminar los datos [...]".</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Al decir "ayudar a deshacerse de los datos", Alan Kay, por supuesto, era consciente de los problemas causados por el estado mutable compartido y la fuerte conectividad causada por el intercambio de datos.  Hoy, estos temas son ampliamente escuchados.  Pero a fines de la d茅cada de 1960, los programadores de ARPANET no estaban contentos con la necesidad de elegir una representaci贸n de modelo de datos para sus programas antes de desarrollar programas.  Los desarrolladores quer铆an alejarse de esta pr谩ctica, ya que, al haberse introducido en el marco definido por la presentaci贸n de los datos, es m谩s dif铆cil cambiar algo en el futuro. <br><br>  El problema era que se necesitaban diferentes formas de presentar los datos, para acceder a ellos, diferentes c贸digos y diferentes sintaxis en los lenguajes de programaci贸n utilizados en alg煤n momento.  El Santo Grial aqu铆 ser铆a una forma universal de acceder y administrar datos.  Si todos los datos tuvieran el mismo aspecto para el programa, esto resolver铆a muchos problemas de los desarrolladores con respecto al desarrollo y mantenimiento de los programas. <br>  Alan Kay intent贸 "deshacerse" de la idea, seg煤n la cual los datos y los programas eran, en cierto sentido, entidades independientes.  No se consideran como tales en List o Smalltalk.  No hay separaci贸n entre lo que se puede hacer con datos (con valores, variables, estructuras de datos, etc.) y construcciones de software como funciones.  Las funciones son "ciudadanos de primera clase" y los programas pueden cambiar durante su ejecuci贸n.  En otras palabras, Smalltalk no tiene una relaci贸n especial y privilegiada con los datos. <br><br>  Alan Kay, adem谩s, consideraba los objetos como estructuras algebraicas, lo que daba garant铆as definidas y matem谩ticamente comprobables de su comportamiento. <br><br>  <i><font color="#999999">"Mi formaci贸n matem谩tica me permiti贸 comprender que cada objeto puede tener varios modelos algebraicos asociados, que puede haber grupos enteros de modelos similares y que pueden ser muy, muy 煤tiles".</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Se demostr贸 que es as铆, y esto form贸 la base para objetos, como promesas y lentes, adem谩s, la teor铆a de la categor铆a fue influenciada por ambos. <br>  La naturaleza algebraica de c贸mo Alan Kay vio los objetos permitir铆a a los objetos proporcionar verificaci贸n formal, comportamiento determinista y mejorar la capacidad de prueba, ya que los modelos algebraicos son, en esencia, operaciones que obedecen a varias reglas en forma de ecuaciones. <br><br>  En la jerga de los programadores, los "modelos algebraicos" son abstracciones creadas a partir de funciones (operaciones) que van acompa帽adas de ciertas reglas, impuestas por pruebas unitarias que estas funciones deben aprobar (axiomas, ecuaciones). <br><br>  Estas ideas se han olvidado durante d茅cadas en la mayor铆a de los lenguajes orientados a objetos de la familia C, incluidos C ++, Java, C #, etc.  Pero estas ideas comienzan la b煤squeda del viaje de regreso, en versiones recientes de los lenguajes orientados a objetos m谩s utilizados. <br><br>  En esta ocasi贸n, alguien puede decir que el mundo de la programaci贸n redescubre los beneficios de la programaci贸n funcional y proporciona argumentos racionales en el contexto de los lenguajes orientados a objetos. <br><br>  Al igual que JavaScript y Smalltalk anteriormente, la mayor铆a de los lenguajes modernos orientados a objetos se est谩n volviendo cada vez m谩s "multi-paradigm谩ticos".  No hay raz贸n para elegir entre programaci贸n funcional y OOP.  Cuando miramos la esencia hist贸rica de cada uno de estos enfoques, se ven no solo como compatibles, sino tambi茅n como ideas complementarias. <br><br>  驴Cu谩l, de acuerdo con los pensamientos de Alan Kay, es lo m谩s importante en la OLP? <br><br><ul><li>  Encapsulaci贸n </li><li>  Mensajer铆a </li><li>  Enlace din谩mico (la capacidad de los programas para desarrollarse y adaptarse a los cambios durante su ejecuci贸n). </li></ul><br>  驴Qu茅 es insignificante en OOP? <br><br><ul><li>  Clases </li><li>  Herencia basada en clases. </li><li>  Relaci贸n particular con objetos, funciones o datos. </li><li> Palabra clave <code>new</code> . </li><li>  Polimorfismo </li><li>  Mecanograf铆a est谩tica. </li><li>  Actitud hacia las clases como "tipos". </li></ul><br>  Si conoce Java o C #, podr铆a pensar que la tipificaci贸n est谩tica o el polimorfismo son los ingredientes m谩s importantes de la POO, pero Alan Kay prefiere tratar con patrones de comportamiento universal en forma algebraica.  Aqu铆 hay un ejemplo escrito en Haskell: <br><br><pre> <code class="hljs erlang-repl">fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br>  Esta es la firma del functor de <code>map</code> universal, que funciona con los tipos indefinidos <code>b</code> , aplicando la funci贸n de <code>a</code> a <code>b</code> en el contexto del functor <code>a</code> para crear el functor <code>b</code> .  "Functor" es una palabra de la jerga matem谩tica, cuyo significado se reduce a "soporte de la operaci贸n de visualizaci贸n".  Si est谩 familiarizado con el m茅todo <code>[].map()</code> en JavaScript, ya sabe lo que esto significa. <br><br>  Aqu铆 hay un par de ejemplos de JavaScript: <br><br><pre> <code class="hljs powershell">// isEven = Number =&gt; Boolean const isEven = n =&gt; n % <span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">0</span></span>; const nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; //  map   `a =&gt; b`    `a` ( `this`) //     `b` //    `a`   `Number`,   `b`  `Boolean` const results = nums.map(isEven); console.log(results); // [<span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>]</code> </pre> <br>  El m茅todo <code>.map()</code> es universal, en el sentido de que <code>b</code> pueden ser de cualquier tipo, y este m茅todo hace frente a una situaci贸n similar sin problemas, ya que las matrices son estructuras de datos que implementan las leyes algebraicas de los functores.  Los tipos para <code>.map()</code> no importan, ya que este m茅todo no intenta trabajar directamente con los valores correspondientes.  En cambio, utiliza una funci贸n que espera y devuelve valores de los tipos correspondientes que son correctos desde el punto de vista de la aplicaci贸n. <br><br><pre> <code class="hljs pgsql">// matches = a =&gt; <span class="hljs-type"><span class="hljs-type">Boolean</span></span> //  `a`    ,   const matches = control =&gt; input =&gt; input === control; const strings = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>]; const results = strings.map(matches(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>)); console.log(results); // [<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>]</code> </pre> <br>  La relaci贸n de tipos universales puede ser dif铆cil de expresar correcta y completamente en lenguajes como TypeScript, pero es muy simple de hacer en el sistema de tipos Hindley-Milner utilizado en Haskell, que admite tipos superiores (tipos de tipos). <br><br>  La mayor铆a de los sistemas de tipos imponen restricciones demasiado fuertes para permitir la libre expresi贸n de ideas din谩micas y funcionales, como la composici贸n de funciones, la composici贸n libre de objetos, la expansi贸n de objetos durante la ejecuci贸n del programa, el uso de combinadores, lentes, etc.  En otras palabras?  Los tipos est谩ticos a menudo dificultan la escritura de software utilizando m茅todos de compilaci贸n. <br><br>  Si su sistema de tipos tiene demasiadas restricciones (como en TypeScript o Java), entonces, para lograr los mismos objetivos, debe escribir un c贸digo m谩s complejo que cuando usa idiomas con un enfoque m谩s libre para escribir.  Esto no significa que el uso de tipos est谩ticos sea una idea desafortunada, o que todas las implementaciones de tipos est谩ticos tengan las mismas limitaciones.  Por ejemplo, he encontrado muchos menos problemas al trabajar con el sistema de tipo Haskell. <br><br>  Si eres fan谩tico de los tipos est谩ticos y no est谩s en contra de las restricciones, te deseo siete pies debajo de la quilla.  Pero si encuentra que algunas de las ideas expresadas aqu铆 son dif铆ciles de implementar porque no es f谩cil escribir funciones obtenidas al componer otras funciones y estructuras algebraicas compuestas, entonces culpe al sistema de tipos y no a la idea.  A los conductores les gustan las comodidades que les brindan los SUV cuadro a cuadro, pero nadie se queja de que no vuelan.  Para volar, necesita un veh铆culo que tenga m谩s grados de libertad. <br><br>  Si las restricciones simplifican su c贸digo, 隆excelente!  Pero si las restricciones lo obligan a escribir c贸digo m谩s complejo, entonces tal vez algo est茅 mal con estas restricciones. <br><br><h2>  <font color="#3AC1EF">驴Qu茅 es un "objeto"?</font> </h2><br>  La palabra "objeto", con el tiempo, ha adquirido muchas connotaciones secundarias de significado.  Lo que llamamos "objetos" en JavaScript son simplemente tipos de datos compuestos, sin ning煤n indicio de la programaci贸n basada en la clase o las ideas de mensaje de Alan Kay. <br><br>  En JavaScript, estos objetos pueden admitir, y a menudo admiten, la encapsulaci贸n, el paso de mensajes, la separaci贸n del comportamiento a trav茅s de m茅todos, incluso el polimorfismo utilizando subclases (aunque utilizando una cadena de delegaci贸n en lugar de un env铆o basado en tipos). <br><br>  Alan Kay quer铆a deshacerse de la diferencia entre el programa y sus datos.  JavaScript, en cierta medida, logra este objetivo colocando los m茅todos de objeto en el mismo lugar que las propiedades que almacenan los datos.  A cualquier propiedad, por ejemplo, se le puede asignar cualquier funci贸n.  Puede construir el comportamiento del objeto din谩micamente y cambiar el contenido sem谩ntico del objeto durante la ejecuci贸n del programa. <br><br>  Un objeto es solo una estructura de datos compuesta, y no necesita nada especial para ser considerado un objeto.  Sin embargo, la programaci贸n usando objetos no conduce al hecho de que dicho c贸digo resulta estar "orientado a objetos", as铆 como el uso de funciones no hace que el c贸digo sea "funcional". <br><br><h2>  <font color="#3AC1EF">OOP ya no es una verdadera OOP</font> </h2><br>  Dado que el concepto de "objeto" en los lenguajes de programaci贸n modernos significa mucho menos de lo que Alan Kay quiso decir, uso la palabra "componente" en lugar de la palabra "objeto" para describir las reglas de esta OOP.  Muchos objetos son propiedad y control directo de alg煤n c贸digo JavaScript de terceros, pero los componentes deben encapsular su propio estado y controlarlo. <br><br>  Esto es lo que es la verdadera OOP: <br><br><ul><li>  Programaci贸n utilizando componentes (Alan Kay los llama "objetos"). </li><li>  El estado del componente debe estar encapsulado. </li><li>  Para la comunicaci贸n entre entidades, se utiliza la mensajer铆a. </li><li>  Los componentes se pueden agregar, modificar y reemplazar en tiempo de ejecuci贸n. </li></ul><br>  La mayor铆a de los comportamientos de los objetos se pueden definir de manera universal utilizando estructuras de datos algebraicos.  No hay necesidad de herencia.  Los componentes pueden reutilizar comportamientos de funciones p煤blicas y m贸dulos de importaci贸n, sin tener que hacer p煤blicos sus datos. <br><br>  Manipular objetos en JavaScript o usar una herencia basada en clases no significa que alguien est茅 involucrado en la programaci贸n de OOP.  Pero el uso de componentes de tal manera - significa.  Pero es muy dif铆cil deshacerse de las ideas establecidas sobre los t茅rminos, por lo que tal vez deber铆amos dejar el t茅rmino "OOP" y llamar a lo que los "componentes" anteriores se usan como "Programaci贸n Orientada a Mensajes (MOP)".  Utilizaremos el t茅rmino "MOP" a continuaci贸n para hablar sobre la programaci贸n orientada a mensajes. <br><br>  Por casualidad, la palabra inglesa "trapeador" se traduce como "trapeador" y, como saben, se utilizan para restablecer el orden. <br><br><h2>  <font color="#3AC1EF">驴C贸mo se ve un buen MOP?</font> </h2><br>  La mayor铆a de los programas modernos tienen una determinada interfaz de usuario (Interfaz de usuario, UI) responsable de interactuar con el usuario, alg煤n c贸digo dedicado a administrar el estado de la aplicaci贸n (datos del usuario) y un c贸digo que funciona con el sistema o es responsable del intercambio de datos con la red. <br><br>  Para admitir el funcionamiento de cada uno de estos sistemas, pueden ser necesarios procesos de larga duraci贸n, como los oyentes de eventos.  Aqu铆 necesitar谩 el estado de la aplicaci贸n: para almacenar informaci贸n como las conexiones de red, el estado de las cosas con los controles de la interfaz y la aplicaci贸n en s铆. <br><br>  Un buen MOP significa que, en lugar de que todos esos sistemas tengan acceso al estado del otro y puedan controlarlos directamente, interact煤an entre s铆 a trav茅s de mensajes.  Cuando el usuario hace clic en el bot贸n <code>"SAVE"</code> , se puede enviar el mensaje <code>"SAVE"</code> .  El componente de la aplicaci贸n de gesti贸n de estado puede interpretar este mensaje y redirigirlo al controlador responsable de la actualizaci贸n desde el estado (como una funci贸n reductora pura).  Quiz谩s, despu茅s de actualizar el estado, el componente responsable de administrar el estado env铆a el mensaje <code>"STATE_UPDATED"</code> componente de interfaz de usuario, que, a su vez, interpreta el estado, decide qu茅 partes de la interfaz deben actualizarse y transfiere el estado actualizado a los subcomponentes responsables de trabajar con Elementos de interfaz espec铆ficos. <br><br>  Mientras tanto, el componente responsable de las conexiones de red puede monitorear la conexi贸n del usuario a otra computadora en la red, escuchar mensajes y enviar una vista actualizada del estado para guardarlo en la m谩quina remota.  Dicho componente es responsable de trabajar con mecanismos de red, sabe si la conexi贸n funciona o no, y as铆 sucesivamente. <br><br>  Sistemas de aplicaci贸n similares no deben conocer los detalles de sus otras partes.  Solo deber铆an preocuparse por resolver sus propios problemas.  Los componentes del sistema pueden desmontarse y ensamblarse como constructor.  Implementan interfaces estandarizadas, lo que significa que pueden interactuar entre s铆.  Mientras se cumplan los requisitos bien conocidos para la interfaz de los componentes, dichos componentes pueden ser reemplazados por otros, con las mismas interfaces, pero haciendo lo mismo de manera diferente, o realizando, recibiendo los mismos mensajes, algo completamente diferente.  Puede cambiar un componente a otro incluso durante la ejecuci贸n del programa; esto no interrumpir谩 su trabajo. <br><br>  Los componentes de un sistema de software ni siquiera tienen que estar en la misma computadora.  El sistema puede ser descentralizado.  El almacenamiento en red puede colocar datos en un sistema de almacenamiento descentralizado como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IPFS</a> , como resultado, el usuario es independiente del estado de una m谩quina en particular, lo que garantiza la seguridad de sus datos.  Con este enfoque, los datos se almacenan de manera confiable y se protegen de intrusos. <br><br>  La OLP, en parte, qued贸 bajo la influencia de las ideas de ARPANET, y uno de los objetivos de este proyecto era crear una red descentralizada que fuera resistente a ataques como un ataque nuclear. <br><br>  Un buen sistema MOP puede caracterizarse por un nivel similar de estabilidad utilizando componentes que admiten el intercambio en caliente mientras la aplicaci贸n se est谩 ejecutando.  Podr谩 continuar funcionando si el usuario trabaja con 茅l desde un tel茅fono celular y est谩 fuera de la cobertura de la red debido a que ha entrado en el t煤nel.  Si un hurac谩n interrumpi贸 el suministro de energ铆a de uno de los centros de datos en los que se encuentran sus servidores, tambi茅n continuar谩 funcionando. <br><br>  Es hora de que el mundo del software se libere de un exitoso experimento de herencia basado en clases y adopte los principios matem谩ticos y cient铆ficos que estuvieron a la vanguardia de la POO. <br><br>  Es hora de que los desarrolladores creemos programas m谩s flexibles, estables y hermosos utilizando una combinaci贸n armoniosa de MOP y programaci贸n funcional. <br>  Por cierto, el acr贸nimo "MOP" ya est谩 en uso, describiendo "Programaci贸n orientada al monitoreo", pero este concepto, a diferencia de OOP, simplemente desaparecer谩 silenciosamente. <br><br>  Por lo tanto, no se desanime si el t茅rmino "MOP" no parece una palabra de la jerga de los programadores.  Simplemente ordena tu OOP con los principios de MOP anteriores. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428582/">https://habr.com/ru/post/es428582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428572/index.html">Componentes de orden superior en reacci贸n</a></li>
<li><a href="../es428574/index.html">Lleve la comunicaci贸n corporativa al siguiente nivel con Zextras Chat</a></li>
<li><a href="../es428576/index.html">[marcador] Versi贸n en PDF del tutorial de Node.js y nueva gu铆a de JavaScript</a></li>
<li><a href="../es428578/index.html">C贸mo comenzar con Hibernate Search</a></li>
<li><a href="../es428580/index.html">Buena gu铆a de comunicaci贸n</a></li>
<li><a href="../es428588/index.html">Resumen de los eventos de TI en noviembre (segunda parte)</a></li>
<li><a href="../es428590/index.html">Microinteracciones y micro indicaciones en la interfaz</a></li>
<li><a href="../es428592/index.html">Deje de contratar "gerentes efectivos". No solo son in煤tiles, sino da帽inos</a></li>
<li><a href="../es428596/index.html">Elon Musk despidi贸 a los gerentes de proyectos de Internet satelital de Starlink debido al incumplimiento de los plazos</a></li>
<li><a href="../es428598/index.html">Redes neuronales profundas para la evaluaci贸n autom谩tica de llamadas.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>