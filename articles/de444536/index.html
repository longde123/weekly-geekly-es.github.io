<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìä üë®üèø‚Äçü§ù‚Äçüë®üèº üßúüèº MVCC-2. Ebenen, Dateien, Seiten üéØ üå¶Ô∏è üòí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das letzte Mal haben wir √ºber Datenkonsistenz gesprochen, den Unterschied zwischen verschiedenen Ebenen der Transaktionsisolation mit den Augen des Be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-2. Ebenen, Dateien, Seiten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444536/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das letzte Mal haben</a> wir √ºber Datenkonsistenz gesprochen, den Unterschied zwischen verschiedenen Ebenen der Transaktionsisolation mit den Augen des Benutzers untersucht und herausgefunden, warum es wichtig ist, dies zu wissen.  Jetzt lernen wir, wie PostgreSQL die Snapshot-basierte Isolierung und Multi-Versionierung implementiert. <br><br>  In diesem Artikel wird untersucht, wie sich Daten physisch in Dateien und Seiten befinden.  Dies f√ºhrt uns vom Thema Isolation weg, aber ein solcher Exkurs ist notwendig, um weiteres Material zu verstehen.  Wir m√ºssen verstehen, wie die Datenspeicherung auf niedriger Ebene funktioniert. <br><br><h1>  Beziehungen </h1><br>  Wenn Sie sich die Tabellen und Indizes ansehen, stellt sich heraus, dass sie √§hnlich angeordnet sind.  Sowohl das als auch andere Basisobjekte, die einige Daten enthalten, die aus Linien bestehen. <br><br>  Die Tatsache, dass die Tabelle aus Zeilen besteht, steht au√üer Zweifel.  F√ºr den Index ist dies weniger offensichtlich.  Stellen Sie sich jedoch einen B-Baum vor: Er besteht aus Knoten, die indizierte Werte und Verkn√ºpfungen zu anderen Knoten oder zu Tabellenzeilen enthalten.  Diese Knoten k√∂nnen als Indexlinien betrachtet werden - tats√§chlich so wie sie sind. <br><br>  Tats√§chlich gibt es immer noch eine Reihe von Objekten, die auf √§hnliche Weise angeordnet sind: Sequenzen (im Wesentlichen einzeilige Tabellen), materialisierte Ansichten (im Wesentlichen Tabellen, die sich an die Abfrage erinnern).  Und dann gibt es die √ºblichen Ansichten, die selbst keine Daten speichern, aber in allen anderen Sinnen Tabellen √§hnlich sind. <br><br>  Alle diese Objekte in PostgreSQL werden als allgemeine Wortbeziehung <em>bezeichnet</em> .  Das Wort ist √§u√üerst ungl√ºcklich, weil es ein Begriff aus der relationalen Theorie ist.  Sie k√∂nnen eine Parallele zwischen der Beziehung und der Tabelle (Ansicht) ziehen, aber sicherlich nicht zwischen der Beziehung und dem Index.  Aber es ist so passiert: Die akademischen Wurzeln von PostgreSQL machen sich bemerkbar.  Ich denke, dass es zuerst Tabellen und Ansichten genannt wurde und der Rest im Laufe der Zeit wuchs. <br><a name="habracut"></a><br>  Der Einfachheit halber werden wir nur √ºber Tabellen und Indizes sprechen, aber der Rest der <em>Beziehungen</em> ist genau gleich strukturiert. <br><br><h1>  Ebenen (Gabeln) und Dateien </h1><br>  Normalerweise hat jede Beziehung mehrere <em>Schichten</em> (Gabeln).  Es gibt verschiedene Arten von Ebenen, von denen jede eine bestimmte Art von Daten enth√§lt. <br><br>  Wenn es eine Ebene gibt, wird sie zun√§chst durch eine einzelne <em>Datei dargestellt</em> .  Der Dateiname besteht aus einer numerischen Kennung, zu der die dem Namen der Ebene entsprechende Endung hinzugef√ºgt werden kann. <br><br>  Die Datei w√§chst allm√§hlich und wenn ihre Gr√∂√üe 1 GB erreicht, wird die n√§chste Datei derselben Ebene erstellt (solche Dateien werden manchmal als <em>Segmente bezeichnet</em> ).  Die Segmentnummer wird an das Ende des Dateinamens angeh√§ngt. <br><br>  Die Beschr√§nkung der Dateigr√∂√üe auf 1 GB ist in der Vergangenheit aufgetreten, um verschiedene Dateisysteme zu unterst√ºtzen, von denen einige nicht mit gro√üen Dateien funktionieren k√∂nnen.  Die Einschr√§nkung kann beim <code>./configure --with-segsize</code> PostgreSQL ge√§ndert werden ( <code>./configure --with-segsize</code> ). <br><br>  Somit k√∂nnen mehrere Dateien einer Beziehung auf einer Festplatte entsprechen.  F√ºr einen kleinen Tisch gibt es beispielsweise 3 davon. <br><br>  Alle Dateien von Objekten, die zu einem Tabellenbereich und einer Datenbank geh√∂ren, werden in einem Verzeichnis abgelegt.  Dies muss ber√ºcksichtigt werden, da Dateisysteme normalerweise mit einer gro√üen Anzahl von Dateien in einem Verzeichnis nicht sehr gut funktionieren. <br><br>  Beachten Sie nur, dass die Dateien wiederum in <em>Seiten</em> (oder <em>Bl√∂cke</em> ) unterteilt sind, normalerweise 8 KB.  Wir werden √ºber die interne Struktur der folgenden Seiten sprechen. <br><br><img src="https://habrastorage.org/webt/oz/ur/4z/ozur4zenihys-v-7wl5rnxyi8em.png"><br><br>  Schauen wir uns nun die Arten von Ebenen an. <br><br>  <strong>Die Hauptschicht</strong> sind die Daten selbst: dieselbe Tabelle oder dieselben Indexzeilen.  Die Hauptebene ist f√ºr jede Beziehung vorhanden (mit Ausnahme von Darstellungen, die keine Daten enthalten). <br><br>  Die Namen der Dateien in der Hauptebene bestehen nur aus einer numerischen Kennung.  Hier ist ein Beispielpfad zu der Tabellendatei, die wir zuletzt erstellt haben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41496 (1 row)</code> </pre><br>  Woher kommen diese Kennungen?  Das Basisverzeichnis entspricht dem Tabellenbereich pg_default, das n√§chste Unterverzeichnis entspricht der Datenbank und die Datei, an der wir interessiert sind, befindet sich bereits darin: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = <span class="hljs-string"><span class="hljs-string">'test'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> oid ------- 41493 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfilenode ------------- 41496 (1 row)</code> </pre><br>  Der Pfad ist relativ und wird aus dem Datenverzeichnis (PGDATA) gez√§hlt.  Dar√ºber hinaus werden fast alle Pfade in PostgreSQL von PGDATA aus gez√§hlt.  Dank dessen k√∂nnen Sie PGDATA sicher an einen anderen Ort √ºbertragen - es enth√§lt nichts (es sei denn, Sie m√ºssen m√∂glicherweise den Pfad zu den Bibliotheken in LD_LIBRARY_PATH konfigurieren). <br><br>  Wir schauen weiter im Dateisystem: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41496</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41496</code> </pre><br>  <strong>Eine Initialisierungsebene ist</strong> nur f√ºr nicht journalisierte Tabellen (erstellt mit UNLOGGED) und deren Indizes vorhanden.  Solche Objekte unterscheiden sich nicht von normalen Objekten, au√üer dass Aktionen mit ihnen nicht im Voraufzeichnungsprotokoll aufgezeichnet werden.  Aus diesem Grund ist die Arbeit mit ihnen schneller, aber im Falle eines Fehlers ist es unm√∂glich, Daten in einem konsistenten Zustand wiederherzustellen.  Daher l√∂scht PostgreSQL bei der Wiederherstellung einfach alle Ebenen solcher Objekte und schreibt die Initialisierungsebene an die Stelle der Hauptebene.  Das Ergebnis ist ein "Dummy".  Wir werden ausf√ºhrlich √ºber Journaling sprechen, aber in einem anderen Zyklus. <br><br>  Die Kontentabelle wird protokolliert, daher gibt es keine Initialisierungsebene daf√ºr.  F√ºr das Experiment k√∂nnen Sie die Protokollierung deaktivieren: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41507 (1 row)</code> </pre><br>  Die M√∂glichkeit, das Journaling im laufenden Betrieb zu aktivieren und zu deaktivieren, wie aus dem Beispiel ersichtlich, umfasst das √úberschreiben von Daten in Dateien mit unterschiedlichen Namen. <br><br>  Die Initialisierungsebene hat denselben Namen wie die Hauptebene, jedoch mit dem Suffix "_init": <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 0 /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><br>  <strong>Karte des freien Speicherplatzes</strong> ( <strong>Karte des freien Speicherplatzes</strong> ) - eine Ebene, in der sich innerhalb der Seiten ein leerer Speicherplatz befindet.  Dieser Ort √§ndert sich st√§ndig: Wenn neue Versionen von Zeichenfolgen hinzugef√ºgt werden, nimmt sie w√§hrend der Reinigung ab - sie nimmt zu.  Die Freiraumkarte wird beim Einf√ºgen neuer Zeilenversionen verwendet, um schnell eine geeignete Seite zu finden, auf die die hinzuzuf√ºgenden Daten passen. <br><br>  Die Freiraumkarte hat das Suffix "_fsm".  Die Datei wird jedoch nicht sofort angezeigt, sondern nur bei Bedarf.  Der einfachste Weg, dies zu erreichen, besteht darin, den Tisch zu reinigen (warum - lassen Sie uns rechtzeitig sprechen): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> accounts;</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 24576 /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><br>  <strong>Eine</strong> Sichtbarkeitskarte ist eine Ebene, in der Seiten, die nur aktuelle Versionen von Zeichenfolgen enthalten, mit einem Bit markiert sind.  Grob gesagt bedeutet dies, dass beim Versuch einer Transaktion, eine Zeile von einer solchen Seite zu lesen, die Zeile angezeigt werden kann, ohne ihre Sichtbarkeit zu √ºberpr√ºfen.  Wie dies geschieht, werden wir in den folgenden Artikeln im Detail untersuchen. <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><br><h1>  Seiten </h1><br>  Wie bereits erw√§hnt, werden Dateien logisch in Seiten unterteilt. <br><br>  Normalerweise ist eine Seite 8 KB gro√ü.  Die Gr√∂√üe kann innerhalb einiger Grenzen ge√§ndert werden (16 KB oder 32 KB), jedoch nur w√§hrend der Montage ( <code>./configure --with-blocksize</code> ).  Die zusammengestellte und laufende Instanz kann mit Seiten nur einer Gr√∂√üe arbeiten. <br><br>  Unabh√§ngig davon, zu welcher Ebene die Dateien geh√∂ren, werden sie vom Server ungef√§hr auf die gleiche Weise verwendet.  Seiten werden zuerst in den Puffercache eingelesen, wo Prozesse sie lesen und √§ndern k√∂nnen.  Bei Bedarf werden die Seiten dann auf die Festplatte zur√ºckgeschoben. <br><br>  Jede Seite hat ein internes Markup und enth√§lt im Allgemeinen die folgenden Abschnitte: <br><br><pre>        0 + ----------------------------------- +
           |  √úberschrift |
       24 + ----------------------------------- +
           |  Array von Zeigern auf Versionszeichenfolgen |
    niedriger + ----------------------------------- +
           |  freier Speicherplatz |
    obere + ----------------------------------- +
           |  Zeilenversionen |
  spezielle + ----------------------------------- +
           |  Sonderbereich |
 Seitengr√∂√üe + ----------------------------------- +
</pre><br>  Die Gr√∂√üe dieser Abschnitte l√§sst sich mit der pageinspect-Erweiterung ‚ÄûForschung‚Äú leicht herausfinden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, special, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | special | pagesize -------+-------+---------+---------- 40 | 8016 | 8192 | 8192 (1 row)</code> </pre><br>  Hier sehen wir uns den <strong>Titel der</strong> allerersten (Null-) Seite der Tabelle an.  Neben der Gr√∂√üe der verbleibenden Bereiche enth√§lt die Kopfzeile weitere Informationen zur Seite, die uns jedoch noch nicht interessieren. <br><br>  Am Ende der Seite befindet sich ein <strong>spezieller Bereich</strong> , in unserem Fall leer.  Es wird nur f√ºr Indizes und dann nicht f√ºr alle verwendet.  Der "Boden" hier entspricht dem Bild;  Vielleicht w√§re es richtiger, ‚Äûan hohen Adressen‚Äú zu sagen. <br><br>  Dem speziellen Bereich folgen <strong>die Zeilenversionen</strong> - genau die Daten, die wir in der Tabelle speichern, sowie einige Overhead-Informationen. <br><br>  Am oberen Rand der Seite, unmittelbar nach der √úberschrift, befindet sich das Inhaltsverzeichnis: ein <strong>Array von Zeigern</strong> auf die Version der auf der Seite verf√ºgbaren Zeilen. <br><br>  Zwischen Versionen von Linien und Zeigern kann <strong>freier Speicherplatz vorhanden sein</strong> (der in der Freiraumkarte markiert ist).  Beachten Sie, dass es innerhalb der Seite keine Fragmentierung gibt. Der gesamte freie Speicherplatz wird immer durch ein Fragment dargestellt. <br><br><h2>  Zeiger </h2><br>  Warum sind Zeiger auf String-Versionen notwendig?  Tatsache ist, dass sich Indexzeilen irgendwie auf die Version der Zeilen in der Tabelle beziehen m√ºssen.  Es ist klar, dass der Link die Dateinummer, die Seitenzahl in der Datei und einige Angaben zur Version der Zeile enthalten sollte.  Ein Versatz vom Anfang der Seite k√∂nnte als solche Anzeige verwendet werden, dies ist jedoch unpraktisch.  Wir k√∂nnten die Version der Zeile nicht innerhalb der Seite verschieben, da dadurch vorhandene Links besch√§digt w√ºrden.  Dies w√ºrde zu einer Fragmentierung des Raums innerhalb der Seiten und anderen unangenehmen Folgen f√ºhren.  Daher bezieht sich der Index auf die Indexnummer und der Zeiger auf die aktuelle Position der Zeilenversion auf der Seite.  Es stellt sich heraus, indirekte Adressierung. <br><br>  Jeder Zeiger belegt genau 4 Bytes und enth√§lt: <br><br><ul><li>  Link zur Version des Strings; </li><li>  die L√§nge dieser Version der Zeichenfolge; </li><li>  mehrere Bits, die den Versionsstatus einer Zeichenfolge bestimmen. </li></ul><br><h2>  Datenformat </h2><br>  Das Datenformat auf der Festplatte stimmt vollst√§ndig mit der Darstellung der Daten im RAM √ºberein.  Die Seite wird "wie sie ist" ohne Transformationen in den Puffercache eingelesen.  Daher sind Datendateien von einer Plattform nicht mit anderen Plattformen kompatibel. <br><br>  In der x86-Architektur wird beispielsweise die Bytereihenfolge von der niedrigstwertigen zur h√∂chsten (Little-Endian) √ºbernommen, z / Architecture verwendet die umgekehrte Reihenfolge (Big-Endian) und in ARM die Switch-Reihenfolge. <br><br>  Viele Architekturen bieten Datenausrichtung √ºber Maschinenwortgrenzen hinweg.  Auf einem x86-32-Bit-System werden beispielsweise Ganzzahlen (Ganzzahltyp, belegt 4 Byte) am Rand von 4-Byte-W√∂rtern sowie Gleitkommazahlen mit doppelter Genauigkeit (Typ mit doppelter Genauigkeit, 8 Byte) ausgerichtet.  Bei einem 64-Bit-System werden Doppelwerte am Rand von 8-Byte-W√∂rtern ausgerichtet.  Dies ist ein weiterer Grund f√ºr die Inkompatibilit√§t. <br><br>  Aufgrund der Ausrichtung h√§ngt die Gr√∂√üe der Tabellenzeile von der Reihenfolge der Felder ab.  Normalerweise ist dieser Effekt nicht sehr auff√§llig, kann aber in einigen F√§llen zu einer signifikanten Vergr√∂√üerung f√ºhren.  Wenn Sie beispielsweise die Felder char (1) und integer vertauscht platzieren, werden normalerweise 3 Bytes zwischen ihnen verschwendet.  Mehr dazu erfahren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> in Nikolai Shaplovs Pr√§sentation " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">What's Inside It</a> ". <br><br><h1>  String- und TOAST-Versionen </h1><br>  Wir werden beim n√§chsten Mal ausf√ºhrlich darauf eingehen, wie Versionen von Zeichenfolgen von innen angeordnet sind.  Bisher ist f√ºr uns nur wichtig, dass jede Version vollst√§ndig auf eine Seite passt: PostgreSQL bietet keine M√∂glichkeit, die Zeile auf der n√§chsten Seite "fortzusetzen".  Stattdessen wird eine Technologie namens TOAST (The Oversized Attributes Storage Technique) verwendet.  Der Name selbst legt nahe, dass die Schnur in Toast geschnitten werden kann. <br><br>  Im Ernst, TOAST beinhaltet mehrere Strategien.  "Lange" Attributwerte k√∂nnen an eine separate Servicetabelle gesendet werden, die zuvor in kleine Toastst√ºcke geschnitten wurde.  Eine andere M√∂glichkeit besteht darin, den Wert so zu komprimieren, dass die Version der Zeile weiterhin auf eine normale Tabellenseite passt.  Und es ist sowohl das als auch das andere m√∂glich: zuerst zu komprimieren und erst dann zu schneiden und zu senden. <br><br>  Falls erforderlich, wird f√ºr jede Haupttabelle eine separate TOAST-Tabelle (und ein spezieller Index daf√ºr) f√ºr alle Attribute erstellt.  Die Notwendigkeit wird durch das Vorhandensein potenziell langer Attribute in der Tabelle bestimmt.  Wenn eine Tabelle beispielsweise eine Spalte vom Typ "numerisch" oder "Text" enth√§lt, wird sofort eine TOAST-Tabelle erstellt, auch wenn keine langen Werte verwendet werden. <br><br>  Da es sich bei der TOAST-Tabelle im Wesentlichen um eine regul√§re Tabelle handelt, weist sie immer noch die gleichen Ebenen auf.  Dies verdoppelt die Anzahl der Dateien, die die Tabelle "bedienen". <br><br>  Strategien werden zun√§chst durch Spaltendatentypen bestimmt.  Sie k√∂nnen sie mit dem Befehl <code>\d+</code> in psql anzeigen. Da jedoch auch viele andere Informationen angezeigt werden, verwenden wir die Anforderung an das Systemverzeichnis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attname, atttypid::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> attstorage <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'external'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'extended'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attrelid = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attnum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | extended client | text | extended amount | numeric | main (4 rows)</code> </pre><br>  Die Namen der Strategien haben folgende Bedeutung: <br><br><ul><li>  plain - TOAST wird nicht verwendet (wird f√ºr offensichtlich ‚Äûkurze‚Äú Datentypen wie Integer verwendet); </li><li>  erweitert - Komprimierung und Speicherung in einer separaten TOAST-Tabelle sind zul√§ssig. </li><li>  extern - lange Werte werden unkomprimiert in der TOAST-Tabelle gespeichert; </li><li>  main - long - Werte werden zuerst und nur in der TOAST - Tabelle komprimiert, wenn die Komprimierung nicht geholfen hat. </li></ul><br>  Im Allgemeinen ist der Algorithmus wie folgt.  PostgreSQL m√∂chte, dass mindestens 4 Zeilen auf eine Seite passen.  Wenn die Gr√∂√üe der Zeile den vierten Teil der Seite unter Ber√ºcksichtigung der √úberschrift √ºberschreitet (bei einer normalen 8-KB-Seite sind dies 2040 Byte), sollte TOAST auf einen Teil der Werte angewendet werden.  Wir handeln in der unten beschriebenen Reihenfolge und halten an, sobald die Leitung den Schwellenwert nicht mehr √ºberschreitet: <br><br><ol><li>  Zun√§chst sortieren wir Attribute mit externen und erweiterten Strategien und wechseln von der l√§ngsten zur k√ºrzeren.  Erweiterte Attribute werden komprimiert (sofern dies Auswirkungen hat). Wenn der Wert selbst ein Viertel der Seite √ºberschreitet, wird er sofort an die TOAST-Tabelle gesendet.  Externe Attribute werden auf die gleiche Weise behandelt, jedoch nicht komprimiert. </li><li>  Wenn nach dem ersten Durchgang die Version der Zeile immer noch nicht passt, senden wir die verbleibenden Attribute mit den externen und erweiterten Strategien an die TOAST-Tabelle. </li><li>  Wenn dies auch nicht hilft, versuchen Sie, die Attribute mit der Hauptstrategie zu komprimieren, w√§hrend Sie sie auf der Tabellenseite belassen. </li><li>  Und nur wenn die Zeile danach noch nicht kurz genug ist, werden die Hauptattribute an die TOAST-Tabelle gesendet. </li></ol><br>  Manchmal kann es n√ºtzlich sein, die Strategie f√ºr einige Spalten zu √§ndern.  Wenn beispielsweise im Voraus bekannt ist, dass die Daten in der Spalte nicht komprimiert sind, k√∂nnen Sie eine externe Strategie daf√ºr festlegen. Dies erspart unn√∂tige Komprimierungsversuche.  Dies geschieht wie folgt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORAGE external</span></span>;</code> </pre><br>  Wenn wir die Anfrage wiederholen, erhalten wir: <br><br><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | external client | text | extended amount | numeric | main</code> </pre><br>  TOAST-Tabellen und -Indizes befinden sich in einem separaten pg_toast-Schema und sind daher normalerweise nicht sichtbar.  F√ºr tempor√§re Tabellen wird das Schema pg_toast_temp_N verwendet, √§hnlich dem √ºblichen Schema pg_temp_N <em>.</em> <br><br>  Wenn gew√ºnscht, macht sich nat√ºrlich niemand die M√ºhe, einen Blick auf die internen Mechanismen des Prozesses zu werfen.  Angenommen, die Kontentabelle enth√§lt drei potenziell lange Attribute, daher muss eine TOAST-Tabelle vorhanden sein.  Da ist sie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relnamespace::<span class="hljs-type"><span class="hljs-type">regnamespace</span></span>, relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltoastrelid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> relnamespace | relname --------------+---------------- pg_toast | pg_toast_33953 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ pg_toast.pg_toast_33953</code> </pre><pre> <code class="plaintext hljs">TOAST table "pg_toast.pg_toast_33953" Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plain</code> </pre><br>  Es ist logisch, dass f√ºr die ‚ÄûToasts‚Äú, in die die Linie geschnitten wird, die einfache Strategie angewendet wird: TOAST der zweiten Ebene existiert nicht. <br><br>  Der PostgreSQL-Index wird sorgf√§ltiger ausgeblendet, ist aber auch leicht zu finden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'pg_toast_33953'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> indexrelid ------------------------------- pg_toast.pg_toast_33953_index (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d pg_toast.pg_toast_33953_index</code> </pre><pre> <code class="plaintext hljs">Unlogged index "pg_toast.pg_toast_33953_index" Column | Type | Key? | Definition -----------+---------+------+------------ chunk_id | oid | yes | chunk_id chunk_seq | integer | yes | chunk_seq primary key, btree, for table "pg_toast.pg_toast_33953"</code> </pre><br>  Die Client-Spalte verwendet die erweiterte Strategie: Die darin enthaltenen Werte werden komprimiert.  √úberpr√ºfen Sie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = repeat(<span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | chunk_data ----------+-----------+------------ (0 rows)</code> </pre><br>  Die TOAST-Tabelle enth√§lt nichts: Wiederholte Zeichen werden perfekt komprimiert, und danach passt der Wert in eine regul√§re Tabellenseite. <br><br>  Lassen Sie den Client-Namen nun aus zuf√§lligen Zeichen bestehen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> string_agg( chr(trunc(<span class="hljs-number"><span class="hljs-number">65</span></span>+random()*<span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> left(client,<span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(client,<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ------------------------- TCKGKZZSLI...RHQIOLWRRX (1 row)</code> </pre><br>  Diese Sequenz kann nicht komprimiert werden und f√§llt in die TOAST-Tabelle: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> chunk_id, chunk_seq, length(chunk_data), left(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | length | ?column? ----------+-----------+--------+------------------------- 34000 | 0 | 2000 | TCKGKZZSLI...ZIPFLOXDIW 34000 | 1 | 1000 | DDXNNBQQYH...RHQIOLWRRX (2 rows)</code> </pre><br>  Wie Sie sehen k√∂nnen, werden die Daten in Fragmente von 2000 Bytes geschnitten. <br><br>  Beim Zugriff auf einen "langen" Wert stellt PostgreSQL automatisch, f√ºr die Anwendung transparent, den urspr√ºnglichen Wert wieder her und gibt ihn an den Client zur√ºck. <br><br>  Nat√ºrlich werden ziemlich viele Ressourcen f√ºr die Komprimierung in Scheiben und die anschlie√üende Wiederherstellung aufgewendet.  Daher ist das Speichern umfangreicher Daten in PostgreSQL keine gute Idee, insbesondere wenn sie aktiv verwendet werden und f√ºr sie keine Transaktionslogik erforderlich ist (Beispiel: gescannte Originale von Buchhaltungsdokumenten).  Eine rentablere Alternative k√∂nnte darin bestehen, solche Daten im Dateisystem und im DBMS die Namen der entsprechenden Dateien zu speichern. <br><br>  Eine TOAST-Tabelle wird nur verwendet, wenn auf einen ‚Äûlangen‚Äú Wert verwiesen wird.  Dar√ºber hinaus verf√ºgt die Toasttabelle √ºber eine eigene Versionierung: Wenn sich die Datenaktualisierung nicht auf den Wert "long" auswirkt, verweist die neue Version der Zeile auf denselben Wert in der TOAST-Tabelle - dies spart Platz. <br><br>  Beachten Sie, dass TOAST nur f√ºr Tabellen funktioniert, nicht jedoch f√ºr Indizes.  Dadurch wird die Gr√∂√üe der indizierten Schl√ºssel begrenzt. <br><blockquote>  Weitere Informationen zur internen Datenorganisation finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Dokumentation</a> . <br></blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444536/">https://habr.com/ru/post/de444536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444524/index.html">Lambdas: von C ++ 11 bis C ++ 20. Teil 1</a></li>
<li><a href="../de444526/index.html">DOTS-Stapel: C ++ & C #</a></li>
<li><a href="../de444528/index.html">Situation: Japan kann das Herunterladen von Inhalten aus dem Netzwerk einschr√§nken - wir verstehen und diskutieren</a></li>
<li><a href="../de444530/index.html">Die Zukunft der Abh√§ngigkeitsinjektion in Android</a></li>
<li><a href="../de444534/index.html">Schwachstellen-Scan und sichere Entwicklung. Teil 1</a></li>
<li><a href="../de444540/index.html">Intel ist bereit, mit der Produktion von MRAM-Speicher zu beginnen</a></li>
<li><a href="../de444542/index.html">Live-Stream und Konferenzplan f√ºr SmartMail Conf: Maschinelles Lernen</a></li>
<li><a href="../de444544/index.html">Etwas √ºber verteilte Rechenzentren f√ºr Unternehmen</a></li>
<li><a href="../de444546/index.html">Wie und warum langsamer arbeiten? Die Methode von Sergey Korolev</a></li>
<li><a href="../de444548/index.html">Pers√∂nliche Erfahrung: Wie wir uns in Lateinamerika f√ºr die F√∂rderung hispanischer Startups engagiert haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>