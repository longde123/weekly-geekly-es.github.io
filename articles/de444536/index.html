<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📊 👨🏿‍🤝‍👨🏼 🧜🏼 MVCC-2. Ebenen, Dateien, Seiten 🎯 🌦️ 😒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das letzte Mal haben wir über Datenkonsistenz gesprochen, den Unterschied zwischen verschiedenen Ebenen der Transaktionsisolation mit den Augen des Be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-2. Ebenen, Dateien, Seiten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444536/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das letzte Mal haben</a> wir über Datenkonsistenz gesprochen, den Unterschied zwischen verschiedenen Ebenen der Transaktionsisolation mit den Augen des Benutzers untersucht und herausgefunden, warum es wichtig ist, dies zu wissen.  Jetzt lernen wir, wie PostgreSQL die Snapshot-basierte Isolierung und Multi-Versionierung implementiert. <br><br>  In diesem Artikel wird untersucht, wie sich Daten physisch in Dateien und Seiten befinden.  Dies führt uns vom Thema Isolation weg, aber ein solcher Exkurs ist notwendig, um weiteres Material zu verstehen.  Wir müssen verstehen, wie die Datenspeicherung auf niedriger Ebene funktioniert. <br><br><h1>  Beziehungen </h1><br>  Wenn Sie sich die Tabellen und Indizes ansehen, stellt sich heraus, dass sie ähnlich angeordnet sind.  Sowohl das als auch andere Basisobjekte, die einige Daten enthalten, die aus Linien bestehen. <br><br>  Die Tatsache, dass die Tabelle aus Zeilen besteht, steht außer Zweifel.  Für den Index ist dies weniger offensichtlich.  Stellen Sie sich jedoch einen B-Baum vor: Er besteht aus Knoten, die indizierte Werte und Verknüpfungen zu anderen Knoten oder zu Tabellenzeilen enthalten.  Diese Knoten können als Indexlinien betrachtet werden - tatsächlich so wie sie sind. <br><br>  Tatsächlich gibt es immer noch eine Reihe von Objekten, die auf ähnliche Weise angeordnet sind: Sequenzen (im Wesentlichen einzeilige Tabellen), materialisierte Ansichten (im Wesentlichen Tabellen, die sich an die Abfrage erinnern).  Und dann gibt es die üblichen Ansichten, die selbst keine Daten speichern, aber in allen anderen Sinnen Tabellen ähnlich sind. <br><br>  Alle diese Objekte in PostgreSQL werden als allgemeine Wortbeziehung <em>bezeichnet</em> .  Das Wort ist äußerst unglücklich, weil es ein Begriff aus der relationalen Theorie ist.  Sie können eine Parallele zwischen der Beziehung und der Tabelle (Ansicht) ziehen, aber sicherlich nicht zwischen der Beziehung und dem Index.  Aber es ist so passiert: Die akademischen Wurzeln von PostgreSQL machen sich bemerkbar.  Ich denke, dass es zuerst Tabellen und Ansichten genannt wurde und der Rest im Laufe der Zeit wuchs. <br><a name="habracut"></a><br>  Der Einfachheit halber werden wir nur über Tabellen und Indizes sprechen, aber der Rest der <em>Beziehungen</em> ist genau gleich strukturiert. <br><br><h1>  Ebenen (Gabeln) und Dateien </h1><br>  Normalerweise hat jede Beziehung mehrere <em>Schichten</em> (Gabeln).  Es gibt verschiedene Arten von Ebenen, von denen jede eine bestimmte Art von Daten enthält. <br><br>  Wenn es eine Ebene gibt, wird sie zunächst durch eine einzelne <em>Datei dargestellt</em> .  Der Dateiname besteht aus einer numerischen Kennung, zu der die dem Namen der Ebene entsprechende Endung hinzugefügt werden kann. <br><br>  Die Datei wächst allmählich und wenn ihre Größe 1 GB erreicht, wird die nächste Datei derselben Ebene erstellt (solche Dateien werden manchmal als <em>Segmente bezeichnet</em> ).  Die Segmentnummer wird an das Ende des Dateinamens angehängt. <br><br>  Die Beschränkung der Dateigröße auf 1 GB ist in der Vergangenheit aufgetreten, um verschiedene Dateisysteme zu unterstützen, von denen einige nicht mit großen Dateien funktionieren können.  Die Einschränkung kann beim <code>./configure --with-segsize</code> PostgreSQL geändert werden ( <code>./configure --with-segsize</code> ). <br><br>  Somit können mehrere Dateien einer Beziehung auf einer Festplatte entsprechen.  Für einen kleinen Tisch gibt es beispielsweise 3 davon. <br><br>  Alle Dateien von Objekten, die zu einem Tabellenbereich und einer Datenbank gehören, werden in einem Verzeichnis abgelegt.  Dies muss berücksichtigt werden, da Dateisysteme normalerweise mit einer großen Anzahl von Dateien in einem Verzeichnis nicht sehr gut funktionieren. <br><br>  Beachten Sie nur, dass die Dateien wiederum in <em>Seiten</em> (oder <em>Blöcke</em> ) unterteilt sind, normalerweise 8 KB.  Wir werden über die interne Struktur der folgenden Seiten sprechen. <br><br><img src="https://habrastorage.org/webt/oz/ur/4z/ozur4zenihys-v-7wl5rnxyi8em.png"><br><br>  Schauen wir uns nun die Arten von Ebenen an. <br><br>  <strong>Die Hauptschicht</strong> sind die Daten selbst: dieselbe Tabelle oder dieselben Indexzeilen.  Die Hauptebene ist für jede Beziehung vorhanden (mit Ausnahme von Darstellungen, die keine Daten enthalten). <br><br>  Die Namen der Dateien in der Hauptebene bestehen nur aus einer numerischen Kennung.  Hier ist ein Beispielpfad zu der Tabellendatei, die wir zuletzt erstellt haben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41496 (1 row)</code> </pre><br>  Woher kommen diese Kennungen?  Das Basisverzeichnis entspricht dem Tabellenbereich pg_default, das nächste Unterverzeichnis entspricht der Datenbank und die Datei, an der wir interessiert sind, befindet sich bereits darin: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = <span class="hljs-string"><span class="hljs-string">'test'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> oid ------- 41493 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfilenode ------------- 41496 (1 row)</code> </pre><br>  Der Pfad ist relativ und wird aus dem Datenverzeichnis (PGDATA) gezählt.  Darüber hinaus werden fast alle Pfade in PostgreSQL von PGDATA aus gezählt.  Dank dessen können Sie PGDATA sicher an einen anderen Ort übertragen - es enthält nichts (es sei denn, Sie müssen möglicherweise den Pfad zu den Bibliotheken in LD_LIBRARY_PATH konfigurieren). <br><br>  Wir schauen weiter im Dateisystem: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41496</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41496</code> </pre><br>  <strong>Eine Initialisierungsebene ist</strong> nur für nicht journalisierte Tabellen (erstellt mit UNLOGGED) und deren Indizes vorhanden.  Solche Objekte unterscheiden sich nicht von normalen Objekten, außer dass Aktionen mit ihnen nicht im Voraufzeichnungsprotokoll aufgezeichnet werden.  Aus diesem Grund ist die Arbeit mit ihnen schneller, aber im Falle eines Fehlers ist es unmöglich, Daten in einem konsistenten Zustand wiederherzustellen.  Daher löscht PostgreSQL bei der Wiederherstellung einfach alle Ebenen solcher Objekte und schreibt die Initialisierungsebene an die Stelle der Hauptebene.  Das Ergebnis ist ein "Dummy".  Wir werden ausführlich über Journaling sprechen, aber in einem anderen Zyklus. <br><br>  Die Kontentabelle wird protokolliert, daher gibt es keine Initialisierungsebene dafür.  Für das Experiment können Sie die Protokollierung deaktivieren: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41507 (1 row)</code> </pre><br>  Die Möglichkeit, das Journaling im laufenden Betrieb zu aktivieren und zu deaktivieren, wie aus dem Beispiel ersichtlich, umfasst das Überschreiben von Daten in Dateien mit unterschiedlichen Namen. <br><br>  Die Initialisierungsebene hat denselben Namen wie die Hauptebene, jedoch mit dem Suffix "_init": <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 0 /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><br>  <strong>Karte des freien Speicherplatzes</strong> ( <strong>Karte des freien Speicherplatzes</strong> ) - eine Ebene, in der sich innerhalb der Seiten ein leerer Speicherplatz befindet.  Dieser Ort ändert sich ständig: Wenn neue Versionen von Zeichenfolgen hinzugefügt werden, nimmt sie während der Reinigung ab - sie nimmt zu.  Die Freiraumkarte wird beim Einfügen neuer Zeilenversionen verwendet, um schnell eine geeignete Seite zu finden, auf die die hinzuzufügenden Daten passen. <br><br>  Die Freiraumkarte hat das Suffix "_fsm".  Die Datei wird jedoch nicht sofort angezeigt, sondern nur bei Bedarf.  Der einfachste Weg, dies zu erreichen, besteht darin, den Tisch zu reinigen (warum - lassen Sie uns rechtzeitig sprechen): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> accounts;</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 24576 /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><br>  <strong>Eine</strong> Sichtbarkeitskarte ist eine Ebene, in der Seiten, die nur aktuelle Versionen von Zeichenfolgen enthalten, mit einem Bit markiert sind.  Grob gesagt bedeutet dies, dass beim Versuch einer Transaktion, eine Zeile von einer solchen Seite zu lesen, die Zeile angezeigt werden kann, ohne ihre Sichtbarkeit zu überprüfen.  Wie dies geschieht, werden wir in den folgenden Artikeln im Detail untersuchen. <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><br><h1>  Seiten </h1><br>  Wie bereits erwähnt, werden Dateien logisch in Seiten unterteilt. <br><br>  Normalerweise ist eine Seite 8 KB groß.  Die Größe kann innerhalb einiger Grenzen geändert werden (16 KB oder 32 KB), jedoch nur während der Montage ( <code>./configure --with-blocksize</code> ).  Die zusammengestellte und laufende Instanz kann mit Seiten nur einer Größe arbeiten. <br><br>  Unabhängig davon, zu welcher Ebene die Dateien gehören, werden sie vom Server ungefähr auf die gleiche Weise verwendet.  Seiten werden zuerst in den Puffercache eingelesen, wo Prozesse sie lesen und ändern können.  Bei Bedarf werden die Seiten dann auf die Festplatte zurückgeschoben. <br><br>  Jede Seite hat ein internes Markup und enthält im Allgemeinen die folgenden Abschnitte: <br><br><pre>        0 + ----------------------------------- +
           |  Überschrift |
       24 + ----------------------------------- +
           |  Array von Zeigern auf Versionszeichenfolgen |
    niedriger + ----------------------------------- +
           |  freier Speicherplatz |
    obere + ----------------------------------- +
           |  Zeilenversionen |
  spezielle + ----------------------------------- +
           |  Sonderbereich |
 Seitengröße + ----------------------------------- +
</pre><br>  Die Größe dieser Abschnitte lässt sich mit der pageinspect-Erweiterung „Forschung“ leicht herausfinden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, special, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | special | pagesize -------+-------+---------+---------- 40 | 8016 | 8192 | 8192 (1 row)</code> </pre><br>  Hier sehen wir uns den <strong>Titel der</strong> allerersten (Null-) Seite der Tabelle an.  Neben der Größe der verbleibenden Bereiche enthält die Kopfzeile weitere Informationen zur Seite, die uns jedoch noch nicht interessieren. <br><br>  Am Ende der Seite befindet sich ein <strong>spezieller Bereich</strong> , in unserem Fall leer.  Es wird nur für Indizes und dann nicht für alle verwendet.  Der "Boden" hier entspricht dem Bild;  Vielleicht wäre es richtiger, „an hohen Adressen“ zu sagen. <br><br>  Dem speziellen Bereich folgen <strong>die Zeilenversionen</strong> - genau die Daten, die wir in der Tabelle speichern, sowie einige Overhead-Informationen. <br><br>  Am oberen Rand der Seite, unmittelbar nach der Überschrift, befindet sich das Inhaltsverzeichnis: ein <strong>Array von Zeigern</strong> auf die Version der auf der Seite verfügbaren Zeilen. <br><br>  Zwischen Versionen von Linien und Zeigern kann <strong>freier Speicherplatz vorhanden sein</strong> (der in der Freiraumkarte markiert ist).  Beachten Sie, dass es innerhalb der Seite keine Fragmentierung gibt. Der gesamte freie Speicherplatz wird immer durch ein Fragment dargestellt. <br><br><h2>  Zeiger </h2><br>  Warum sind Zeiger auf String-Versionen notwendig?  Tatsache ist, dass sich Indexzeilen irgendwie auf die Version der Zeilen in der Tabelle beziehen müssen.  Es ist klar, dass der Link die Dateinummer, die Seitenzahl in der Datei und einige Angaben zur Version der Zeile enthalten sollte.  Ein Versatz vom Anfang der Seite könnte als solche Anzeige verwendet werden, dies ist jedoch unpraktisch.  Wir könnten die Version der Zeile nicht innerhalb der Seite verschieben, da dadurch vorhandene Links beschädigt würden.  Dies würde zu einer Fragmentierung des Raums innerhalb der Seiten und anderen unangenehmen Folgen führen.  Daher bezieht sich der Index auf die Indexnummer und der Zeiger auf die aktuelle Position der Zeilenversion auf der Seite.  Es stellt sich heraus, indirekte Adressierung. <br><br>  Jeder Zeiger belegt genau 4 Bytes und enthält: <br><br><ul><li>  Link zur Version des Strings; </li><li>  die Länge dieser Version der Zeichenfolge; </li><li>  mehrere Bits, die den Versionsstatus einer Zeichenfolge bestimmen. </li></ul><br><h2>  Datenformat </h2><br>  Das Datenformat auf der Festplatte stimmt vollständig mit der Darstellung der Daten im RAM überein.  Die Seite wird "wie sie ist" ohne Transformationen in den Puffercache eingelesen.  Daher sind Datendateien von einer Plattform nicht mit anderen Plattformen kompatibel. <br><br>  In der x86-Architektur wird beispielsweise die Bytereihenfolge von der niedrigstwertigen zur höchsten (Little-Endian) übernommen, z / Architecture verwendet die umgekehrte Reihenfolge (Big-Endian) und in ARM die Switch-Reihenfolge. <br><br>  Viele Architekturen bieten Datenausrichtung über Maschinenwortgrenzen hinweg.  Auf einem x86-32-Bit-System werden beispielsweise Ganzzahlen (Ganzzahltyp, belegt 4 Byte) am Rand von 4-Byte-Wörtern sowie Gleitkommazahlen mit doppelter Genauigkeit (Typ mit doppelter Genauigkeit, 8 Byte) ausgerichtet.  Bei einem 64-Bit-System werden Doppelwerte am Rand von 8-Byte-Wörtern ausgerichtet.  Dies ist ein weiterer Grund für die Inkompatibilität. <br><br>  Aufgrund der Ausrichtung hängt die Größe der Tabellenzeile von der Reihenfolge der Felder ab.  Normalerweise ist dieser Effekt nicht sehr auffällig, kann aber in einigen Fällen zu einer signifikanten Vergrößerung führen.  Wenn Sie beispielsweise die Felder char (1) und integer vertauscht platzieren, werden normalerweise 3 Bytes zwischen ihnen verschwendet.  Mehr dazu erfahren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> in Nikolai Shaplovs Präsentation " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">What's Inside It</a> ". <br><br><h1>  String- und TOAST-Versionen </h1><br>  Wir werden beim nächsten Mal ausführlich darauf eingehen, wie Versionen von Zeichenfolgen von innen angeordnet sind.  Bisher ist für uns nur wichtig, dass jede Version vollständig auf eine Seite passt: PostgreSQL bietet keine Möglichkeit, die Zeile auf der nächsten Seite "fortzusetzen".  Stattdessen wird eine Technologie namens TOAST (The Oversized Attributes Storage Technique) verwendet.  Der Name selbst legt nahe, dass die Schnur in Toast geschnitten werden kann. <br><br>  Im Ernst, TOAST beinhaltet mehrere Strategien.  "Lange" Attributwerte können an eine separate Servicetabelle gesendet werden, die zuvor in kleine Toaststücke geschnitten wurde.  Eine andere Möglichkeit besteht darin, den Wert so zu komprimieren, dass die Version der Zeile weiterhin auf eine normale Tabellenseite passt.  Und es ist sowohl das als auch das andere möglich: zuerst zu komprimieren und erst dann zu schneiden und zu senden. <br><br>  Falls erforderlich, wird für jede Haupttabelle eine separate TOAST-Tabelle (und ein spezieller Index dafür) für alle Attribute erstellt.  Die Notwendigkeit wird durch das Vorhandensein potenziell langer Attribute in der Tabelle bestimmt.  Wenn eine Tabelle beispielsweise eine Spalte vom Typ "numerisch" oder "Text" enthält, wird sofort eine TOAST-Tabelle erstellt, auch wenn keine langen Werte verwendet werden. <br><br>  Da es sich bei der TOAST-Tabelle im Wesentlichen um eine reguläre Tabelle handelt, weist sie immer noch die gleichen Ebenen auf.  Dies verdoppelt die Anzahl der Dateien, die die Tabelle "bedienen". <br><br>  Strategien werden zunächst durch Spaltendatentypen bestimmt.  Sie können sie mit dem Befehl <code>\d+</code> in psql anzeigen. Da jedoch auch viele andere Informationen angezeigt werden, verwenden wir die Anforderung an das Systemverzeichnis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attname, atttypid::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> attstorage <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'external'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'extended'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attrelid = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attnum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | extended client | text | extended amount | numeric | main (4 rows)</code> </pre><br>  Die Namen der Strategien haben folgende Bedeutung: <br><br><ul><li>  plain - TOAST wird nicht verwendet (wird für offensichtlich „kurze“ Datentypen wie Integer verwendet); </li><li>  erweitert - Komprimierung und Speicherung in einer separaten TOAST-Tabelle sind zulässig. </li><li>  extern - lange Werte werden unkomprimiert in der TOAST-Tabelle gespeichert; </li><li>  main - long - Werte werden zuerst und nur in der TOAST - Tabelle komprimiert, wenn die Komprimierung nicht geholfen hat. </li></ul><br>  Im Allgemeinen ist der Algorithmus wie folgt.  PostgreSQL möchte, dass mindestens 4 Zeilen auf eine Seite passen.  Wenn die Größe der Zeile den vierten Teil der Seite unter Berücksichtigung der Überschrift überschreitet (bei einer normalen 8-KB-Seite sind dies 2040 Byte), sollte TOAST auf einen Teil der Werte angewendet werden.  Wir handeln in der unten beschriebenen Reihenfolge und halten an, sobald die Leitung den Schwellenwert nicht mehr überschreitet: <br><br><ol><li>  Zunächst sortieren wir Attribute mit externen und erweiterten Strategien und wechseln von der längsten zur kürzeren.  Erweiterte Attribute werden komprimiert (sofern dies Auswirkungen hat). Wenn der Wert selbst ein Viertel der Seite überschreitet, wird er sofort an die TOAST-Tabelle gesendet.  Externe Attribute werden auf die gleiche Weise behandelt, jedoch nicht komprimiert. </li><li>  Wenn nach dem ersten Durchgang die Version der Zeile immer noch nicht passt, senden wir die verbleibenden Attribute mit den externen und erweiterten Strategien an die TOAST-Tabelle. </li><li>  Wenn dies auch nicht hilft, versuchen Sie, die Attribute mit der Hauptstrategie zu komprimieren, während Sie sie auf der Tabellenseite belassen. </li><li>  Und nur wenn die Zeile danach noch nicht kurz genug ist, werden die Hauptattribute an die TOAST-Tabelle gesendet. </li></ol><br>  Manchmal kann es nützlich sein, die Strategie für einige Spalten zu ändern.  Wenn beispielsweise im Voraus bekannt ist, dass die Daten in der Spalte nicht komprimiert sind, können Sie eine externe Strategie dafür festlegen. Dies erspart unnötige Komprimierungsversuche.  Dies geschieht wie folgt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORAGE external</span></span>;</code> </pre><br>  Wenn wir die Anfrage wiederholen, erhalten wir: <br><br><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | external client | text | extended amount | numeric | main</code> </pre><br>  TOAST-Tabellen und -Indizes befinden sich in einem separaten pg_toast-Schema und sind daher normalerweise nicht sichtbar.  Für temporäre Tabellen wird das Schema pg_toast_temp_N verwendet, ähnlich dem üblichen Schema pg_temp_N <em>.</em> <br><br>  Wenn gewünscht, macht sich natürlich niemand die Mühe, einen Blick auf die internen Mechanismen des Prozesses zu werfen.  Angenommen, die Kontentabelle enthält drei potenziell lange Attribute, daher muss eine TOAST-Tabelle vorhanden sein.  Da ist sie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relnamespace::<span class="hljs-type"><span class="hljs-type">regnamespace</span></span>, relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltoastrelid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> relnamespace | relname --------------+---------------- pg_toast | pg_toast_33953 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ pg_toast.pg_toast_33953</code> </pre><pre> <code class="plaintext hljs">TOAST table "pg_toast.pg_toast_33953" Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plain</code> </pre><br>  Es ist logisch, dass für die „Toasts“, in die die Linie geschnitten wird, die einfache Strategie angewendet wird: TOAST der zweiten Ebene existiert nicht. <br><br>  Der PostgreSQL-Index wird sorgfältiger ausgeblendet, ist aber auch leicht zu finden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'pg_toast_33953'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> indexrelid ------------------------------- pg_toast.pg_toast_33953_index (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d pg_toast.pg_toast_33953_index</code> </pre><pre> <code class="plaintext hljs">Unlogged index "pg_toast.pg_toast_33953_index" Column | Type | Key? | Definition -----------+---------+------+------------ chunk_id | oid | yes | chunk_id chunk_seq | integer | yes | chunk_seq primary key, btree, for table "pg_toast.pg_toast_33953"</code> </pre><br>  Die Client-Spalte verwendet die erweiterte Strategie: Die darin enthaltenen Werte werden komprimiert.  Überprüfen Sie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = repeat(<span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | chunk_data ----------+-----------+------------ (0 rows)</code> </pre><br>  Die TOAST-Tabelle enthält nichts: Wiederholte Zeichen werden perfekt komprimiert, und danach passt der Wert in eine reguläre Tabellenseite. <br><br>  Lassen Sie den Client-Namen nun aus zufälligen Zeichen bestehen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> string_agg( chr(trunc(<span class="hljs-number"><span class="hljs-number">65</span></span>+random()*<span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> left(client,<span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(client,<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ------------------------- TCKGKZZSLI...RHQIOLWRRX (1 row)</code> </pre><br>  Diese Sequenz kann nicht komprimiert werden und fällt in die TOAST-Tabelle: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> chunk_id, chunk_seq, length(chunk_data), left(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | length | ?column? ----------+-----------+--------+------------------------- 34000 | 0 | 2000 | TCKGKZZSLI...ZIPFLOXDIW 34000 | 1 | 1000 | DDXNNBQQYH...RHQIOLWRRX (2 rows)</code> </pre><br>  Wie Sie sehen können, werden die Daten in Fragmente von 2000 Bytes geschnitten. <br><br>  Beim Zugriff auf einen "langen" Wert stellt PostgreSQL automatisch, für die Anwendung transparent, den ursprünglichen Wert wieder her und gibt ihn an den Client zurück. <br><br>  Natürlich werden ziemlich viele Ressourcen für die Komprimierung in Scheiben und die anschließende Wiederherstellung aufgewendet.  Daher ist das Speichern umfangreicher Daten in PostgreSQL keine gute Idee, insbesondere wenn sie aktiv verwendet werden und für sie keine Transaktionslogik erforderlich ist (Beispiel: gescannte Originale von Buchhaltungsdokumenten).  Eine rentablere Alternative könnte darin bestehen, solche Daten im Dateisystem und im DBMS die Namen der entsprechenden Dateien zu speichern. <br><br>  Eine TOAST-Tabelle wird nur verwendet, wenn auf einen „langen“ Wert verwiesen wird.  Darüber hinaus verfügt die Toasttabelle über eine eigene Versionierung: Wenn sich die Datenaktualisierung nicht auf den Wert "long" auswirkt, verweist die neue Version der Zeile auf denselben Wert in der TOAST-Tabelle - dies spart Platz. <br><br>  Beachten Sie, dass TOAST nur für Tabellen funktioniert, nicht jedoch für Indizes.  Dadurch wird die Größe der indizierten Schlüssel begrenzt. <br><blockquote>  Weitere Informationen zur internen Datenorganisation finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Dokumentation</a> . <br></blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444536/">https://habr.com/ru/post/de444536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444524/index.html">Lambdas: von C ++ 11 bis C ++ 20. Teil 1</a></li>
<li><a href="../de444526/index.html">DOTS-Stapel: C ++ & C #</a></li>
<li><a href="../de444528/index.html">Situation: Japan kann das Herunterladen von Inhalten aus dem Netzwerk einschränken - wir verstehen und diskutieren</a></li>
<li><a href="../de444530/index.html">Die Zukunft der Abhängigkeitsinjektion in Android</a></li>
<li><a href="../de444534/index.html">Schwachstellen-Scan und sichere Entwicklung. Teil 1</a></li>
<li><a href="../de444540/index.html">Intel ist bereit, mit der Produktion von MRAM-Speicher zu beginnen</a></li>
<li><a href="../de444542/index.html">Live-Stream und Konferenzplan für SmartMail Conf: Maschinelles Lernen</a></li>
<li><a href="../de444544/index.html">Etwas über verteilte Rechenzentren für Unternehmen</a></li>
<li><a href="../de444546/index.html">Wie und warum langsamer arbeiten? Die Methode von Sergey Korolev</a></li>
<li><a href="../de444548/index.html">Persönliche Erfahrung: Wie wir uns in Lateinamerika für die Förderung hispanischer Startups engagiert haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>