<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍✈️ 🚴🏿 🐯 Tiefengenauigkeit klar 🚰 🚶 🤜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tiefengenauigkeit ist ein Schmerz im Arsch, dem sich jeder Grafikprogrammierer früher oder später stellen muss. Zu diesem Thema wurden viele Artikel u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tiefengenauigkeit klar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434322/">  Tiefengenauigkeit ist ein Schmerz im Arsch, dem sich jeder Grafikprogrammierer früher oder später stellen muss.  Zu diesem Thema wurden viele Artikel und Werke verfasst.  In verschiedenen Spielen und Engines sowie auf verschiedenen Plattformen können Sie viele verschiedene Formate und Einstellungen für den <b>Tiefenpuffer sehen</b> . <br><br>  Die Tiefenkonvertierung auf einer GPU scheint aufgrund der Wechselwirkung mit der perspektivischen Projektion nicht offensichtlich zu sein, und das Studium der Gleichungen verdeutlicht die Situation nicht.  Um zu verstehen, wie dies funktioniert, ist es hilfreich, einige Bilder zu zeichnen. <br><br><img src="https://developer.nvidia.com/sites/default/files/styles/main_image/public/akamai/gameworks/blog/Depthprecision/graph.jpg?itok=tLMbXLov" alt="Bild"><br><br>  Dieser Artikel ist in 3 Teile gegliedert: <br><br><ol><li>  Ich werde versuchen, die Motivation für die <b>nichtlineare</b> Tiefenumwandlung zu erklären. </li><li>  Ich werde einige Diagramme vorstellen, die Ihnen helfen zu verstehen, wie die nichtlineare Tiefenkonvertierung in verschiedenen Situationen intuitiv und visuell funktioniert. </li><li>  Eine Diskussion der wichtigsten Ergebnisse der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verschärfung der Präzision des perspektivischen</a> Renderns [Paul Upchurch, Mathieu Desbrun (2012)] hinsichtlich der Auswirkung von Rundungs-Gleitkommafehlern auf die Tiefengenauigkeit. </li></ol><br><a name="habracut"></a><br><h2>  Warum 1 / z? </h2><br>  Ein Hardware-GPU- <b>Tiefenpuffer</b> speichert normalerweise keine lineare Darstellung des Abstands zwischen dem Objekt und der Kamera, im Gegensatz zu dem, was beim ersten Treffen naiv erwartet wird.  Stattdessen speichert der Tiefenpuffer Werte, die umgekehrt proportional zur Tiefe des Ansichtsraums sind.  Ich möchte kurz die Motivation für eine solche Entscheidung beschreiben. <br><br>  In diesem Artikel werde ich <b>d verwenden</b> , um die im Tiefenpuffer gespeicherten Werte darzustellen (im Bereich [0, 1] für DirectX), und <b>z</b> , um den Tiefenansichtsraum darzustellen, d. H.  Die tatsächliche Entfernung von der Kamera, in Welteinheiten, z. B. Meter.  Im Allgemeinen hat die Beziehung zwischen ihnen die folgende Form: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math1.jpg" alt="Bild"><br><br>  Dabei sind <b>a, b</b> die Konstanten, die den Nah- und Ferneinstellungen der Ebenen zugeordnet sind.  Mit anderen Worten, <b>d</b> ist immer eine lineare Transformation von <b>1 / z</b> . <br><br>  Auf den ersten Blick scheint es, dass jede Funktion von <b>z</b> als <b>d angenommen werden kann</b> .  Warum sieht sie so aus?  Dafür gibt es zwei Hauptgründe. <br><br>  Erstens passt <b>1 / z</b> natürlich in die perspektivische Projektion.  Und dies ist die grundlegendste Klasse von Transformationen, bei der garantiert gerade Linien erhalten bleiben.  Daher ist die perspektivische Projektion für die Hardware-Rasterung geeignet, da die geraden Kanten der Dreiecke gerade auf dem Bildschirm bleiben.  Wir können eine lineare Transformation von <b>1 / z erhalten</b> , indem wir die Perspektiventeilung nutzen, die die GPU bereits durchführt: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math2.jpg" alt="Bild"><br><br>  Die wahre Stärke dieses Ansatzes besteht natürlich darin, dass die Projektionsmatrix mit anderen Matrizen multipliziert werden kann, sodass Sie viele Transformationen zu einer kombinieren können. <br><br>  Der zweite Grund ist, dass <b>1 / z</b> im Bildschirmbereich linear ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie Emil Persson feststellte</a> .  Dies macht es einfach, d im Dreieck während der Rasterung zu interpolieren, und Dinge wie <b>hierarchische Z-Puffer</b> , <b>frühes Z-Culling</b> und <b>Komprimierungstiefenpuffer</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Kurz aus dem Artikel</b> <div class="spoiler_text">  Während der Wert von <b>w (Ansichtsraumtiefe)</b> im Ansichtsraum linear ist, ist er im Bildschirmraum nicht linear.  <b>z (Tiefe)</b> , nicht linear im Sichtraum, andererseits linear im Bildschirmraum.  Dies kann leicht mit einem einfachen DX10-Shader überprüft werden: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dx = ddx(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dy = ddy(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000.0</span></span> * float4(<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dx), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dy), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Hier ist In.position SV_Position.  Das Ergebnis sieht ungefähr so ​​aus: <br><br><img src="http://www.humus.name/News/ZGradient.png" alt="Bild"><br><br>  Beachten Sie, dass alle Oberflächen monochrom aussehen.  Der Unterschied in <b>z</b> von Pixel zu Pixel ist für jedes Grundelement gleich.  Dies ist sehr wichtig für die GPU.  Ein Grund ist, dass die <b>z-</b> Interpolation billiger ist als die <b>w-</b> Interpolation.  Für <b>z ist</b> keine perspektivische Korrektur erforderlich.  Mit billigeren Hardwareeinheiten können Sie mehr Pixel pro Zyklus mit dem gleichen Budget für Transistoren verarbeiten.  Dies ist natürlich sehr wichtig für die <b>Pre-Z-Pass-</b> und <b>Schattenkarte</b> .  Bei moderner Hardware ist die Linearität des Bildschirmbereichs auch eine sehr nützliche Funktion für Z-Optimierungen.  Da der Gradient für das gesamte Grundelement linear ist, ist es auch relativ einfach, den genauen Tiefenbereich innerhalb der Kachel für das <b>Hi-z-Keulen</b> zu berechnen.  Dies bedeutet auch, dass eine <b>Z-Komprimierung</b> möglich ist.  Mit einer Konstanten <b>Δz</b> in <b>x</b> und <b>y müssen</b> Sie nicht viele Informationen speichern, um alle <b>z-</b> Werte in einer Kachel vollständig wiederherstellen zu können, vorausgesetzt, das Grundelement hat die gesamte Kachel abgedeckt. <br></div></div><br><h2>  Tiefendiagramme </h2><br>  Gleichungen sind kompliziert, schauen wir uns ein paar Bilder an! <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph1.jpg" alt="Bild"><br><br>  Sie können diese Diagramme von links nach rechts und dann von unten lesen.  Beginnen Sie mit <b>d</b> auf der linken Achse.  Da <b>d</b> eine beliebige lineare Transformation von <b>1 / z sein kann</b> , können wir 0 und 1 an jeder geeigneten Stelle auf der Achse anordnen.  Markierungen zeigen unterschiedliche <b>Tiefenpufferwerte an</b> .  Aus Gründen der Übersichtlichkeit modelliere ich einen normalisierten 4-Bit-Ganzzahl-Tiefenpuffer, sodass 16 Markierungen mit gleichmäßigem Abstand vorhanden sind. <br><br>  Die obige Grafik zeigt die Standard-Vanille-Tiefenkonvertierung in D3D und ähnliche APIs.  Sie können sofort feststellen, dass aufgrund der <b>1 / z-</b> Kurve Werte nahe der nahen Ebene gruppiert und Werte nahe der fernen Ebene gestreut werden. <br><br>  Es ist auch leicht zu verstehen, warum die Nähe einer Ebene die Tiefengenauigkeit so stark beeinflusst.  Der Abstand in der Nähe der Ebene führt zu einem raschen Anstieg der Werte von <b>d</b> relativ zu den Werten von <b>z</b> , was zu einer noch ungleichmäßigeren Verteilung der Werte führt: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph2.jpg" alt="Bild"><br><br>  In ähnlicher Weise ist in diesem Zusammenhang leicht zu erkennen, warum das Verschieben der fernen Ebene ins Unendliche keinen so großen Effekt hat.  Es bedeutet nur, den Bereich von <b>d</b> auf <b>1 / z = 0 zu erweitern</b> : <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph3.jpg" alt="Bild"><br><br>  Aber was ist mit der Gleitkommatiefe?  Dem folgenden Diagramm wurden Markierungen hinzugefügt, die dem Float-Format mit 3 Bits des Exponenten und 3 Bits der Mantisse entsprechen: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph4.jpg" alt="Bild"><br><br>  Jetzt gibt es im Bereich [0,1] 40 verschiedene Werte - etwas mehr als 16 Werte früher, aber die meisten von ihnen sind nutzlos nahe der nahen Ebene gruppiert (näher an 0 hat der Schwimmer eine höhere Genauigkeit), wo wir wirklich nicht viel Genauigkeit benötigen. <br><br>  Ein bekannter Trick besteht nun darin, die Tiefe umzukehren und die nahe Ebene auf <b>d = 1</b> und die ferne Ebene auf <b>d = 0</b> anzuzeigen: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph5.jpg" alt="Bild"><br><br>  Viel besser!  Jetzt kompensiert die quasi-logarithmische Verteilung des Schwimmers irgendwie die Nichtlinearität von <b>1 / z</b> , während sie näher an der nahen Ebene eine Genauigkeit ergibt, die dem ganzzahligen Tiefenpuffer ähnlich ist, und an anderer Stelle eine signifikant größere Genauigkeit ergibt.  Die Tiefengenauigkeit verschlechtert sich sehr langsam, wenn Sie sich weiter von der Kamera entfernen. <br><br>  Der <b>umgekehrte Z-</b> Trick wurde möglicherweise mehrmals unabhängig voneinander neu erfunden, aber zumindest die erste Erwähnung erfolgte in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Veröffentlichung von SIGGRAPH '99</a> [Eugene Lapidous und Guofang Jiao (leider nicht öffentlich verfügbar)].  Und kürzlich wurde er auf dem Blog von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Matt Petineo</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brano Kemen</a> sowie in einer Rede von Emil Persson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Creating Vast Game Worlds</a> SIGGRAPH 2012 erneut erwähnt. <br><br>  Alle vorherigen Diagramme nahmen nach der Projektion einen Tiefenbereich [0,1] an, was in D3D eine Konvention ist.  Was ist mit <b>OpenGL</b> ? <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph6.jpg" alt="Bild"><br><br>  <b>OpenGL</b> nimmt standardmäßig nach der Projektion einen Tiefenbereich [-1, 1] an.  Bei ganzzahligen Formaten ändert sich nichts, aber bei Gleitkommazahlen konzentriert sich jede Genauigkeit nutzlos auf die Mitte.  (Der Tiefenwert wird für die anschließende Speicherung im Tiefenpuffer auf den Bereich [0,1] abgebildet, dies hilft jedoch nicht weiter, da die anfängliche Zuordnung zu [-1,1] bereits die gesamte Genauigkeit in der anderen Hälfte des Bereichs zerstört hat.) Und aufgrund der Symmetrie <b>umgekehrt-Z</b> funktioniert hier nicht. <br><br>  Glücklicherweise kann dies in Desktop-OpenGL mit der weit verbreiteten Erweiterung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ARB_clip_control behoben werden</a> (ebenfalls ab OpenGL 4.5 ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">glClipControl Standard</a> ).  Leider ist GL ES im Flug. <br><br><h2>  Die Auswirkung von Rundungsfehlern </h2><br>  Die <b>1 / z-</b> Konvertierung und die Wahl zwischen <b>Float und Int-Tiefenpuffer</b> sind ein großer Teil der Geschichte der Genauigkeit, aber nicht alle.  Selbst wenn Sie über eine ausreichende Tiefengenauigkeit verfügen, um die Szene darzustellen, die Sie rendern möchten, kann die Genauigkeit während des Scheitelpunktkonvertierungsprozesses leicht durch Rechenfehler beeinträchtigt werden. <br><br>  Zu Beginn des Artikels wurde erwähnt, dass Upchurch und Desbrun dieses Problem untersucht haben.  Sie schlugen zwei Hauptempfehlungen vor, um Rundungsfehler zu minimieren: <br><br><ol><li>  Verwenden Sie die unendliche Fernebene. </li><li>  Halten Sie die Projektionsmatrix von anderen Matrizen getrennt und wenden Sie sie als separate Operation im Vertex-Shader an, anstatt sie mit der Ansichtsmatrix zu kombinieren. </li></ol><br>  Upchurch und Desbrun gaben diese Empfehlungen unter Verwendung einer Analysemethode ab, die auf der Verarbeitung von Rundungsfehlern als kleine zufällige Fehler basiert, die in jeder arithmetischen Operation dargestellt werden, und deren Verfolgung in der ersten Reihenfolge im Konvertierungsprozess.  Ich beschloss, die Ergebnisse in der Praxis zu testen. <br><br>  Die Quellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> sind Python 3.4 und numpy.  Das Programm funktioniert wie folgt: Es wird eine Folge von zufälligen Punkten erzeugt, die nach Tiefe geordnet sind und linear oder logarithmisch zwischen nahen und fernen Ebenen liegen.  Dann werden die Punkte mit der Ansicht multipliziert und die Matrix projiziert, und die Perspektiventeilung wird unter Verwendung von 32-Bit-Gleitkommazahlen durchgeführt, und optional wird das Endergebnis in ein 24-Bit-Int konvertiert.  Am Ende durchläuft es die Sequenz und zählt, wie oft 2 benachbarte Punkte (die anfangs unterschiedliche Tiefen hatten) entweder identisch wurden, weil sie dieselbe Tiefe hatten oder die Reihenfolge überhaupt geändert wurde.  Mit anderen Worten, das Programm misst in verschiedenen Szenarien die Häufigkeit, mit der Tiefenvergleichsfehler auftreten - was Problemen wie <b>Z-Kämpfen</b> entspricht. <br><br>  Hier sind die Ergebnisse für nah = 0,1, fern = 10 K mit einer linearen Tiefe von 10 K.  (Ich habe das logarithmische Tiefenintervall und andere Nah / Fern-Verhältnisse ausprobiert, und obwohl die spezifischen Zahlen variierten, waren die allgemeinen Trends in den Ergebnissen dieselben.) <br><br>  In der Tabelle werden "eq" - zwei Punkte mit der nächsten Tiefe erhalten den gleichen Wert im Tiefenpuffer und "swap" - zwei Punkte mit der nächsten Tiefe werden getauscht. <br><table><tbody><tr><td colspan="1" rowspan="2"></td><td colspan="2" rowspan="1">  <b>Zusammengesetzte Ansichtsprojektionsmatrix</b> </td><td colspan="2" rowspan="1">  <b>Separate Ansichts- und Projektionsmatrizen</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>Unveränderte Z-Werte (Kontrolltest)</b> </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Standardprojektion</b> </td><td colspan="1" rowspan="1">  45% Äq <br>  18% Swap </td><td colspan="1" rowspan="1">  45% Äq <br>  18% Swap </td><td colspan="1" rowspan="1">  77% Äq <br>  0% Swap </td><td colspan="1" rowspan="1">  77% Äq <br>  0% Swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Unendlich weit</b> </td><td colspan="1" rowspan="1">  45% Äq <br>  18% Swap </td><td colspan="1" rowspan="1">  45% Äq <br>  18% Swap </td><td colspan="1" rowspan="1">  76% Äq <br>  0% Swap </td><td colspan="1" rowspan="1">  76% Äq <br>  0% Swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Umgekehrt z</b> </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  76% Äq <br>  0% Swap </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  76% Äq <br>  0% Swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Unendlich + umgekehrt-Z</b> </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  76% Äq <br>  0% Swap </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  76% Äq <br>  0% Swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Standard + GL-Stil</b> </td><td colspan="1" rowspan="1">  56% Äq <br>  12% Swap </td><td colspan="1" rowspan="1">  56% Äq <br>  12% Swap </td><td colspan="1" rowspan="1">  77% Äq <br>  0% Swap </td><td colspan="1" rowspan="1">  77% Äq <br>  0% Swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Unendlich + GL-Stil</b> </td><td colspan="1" rowspan="1">  59% Äq <br>  10% Swap </td><td colspan="1" rowspan="1">  59% Äq <br>  10% Swap </td><td colspan="1" rowspan="1">  77% Äq <br>  0% Swap </td><td colspan="1" rowspan="1">  77% Äq <br>  0% Swap </td></tr></tbody></table><br>  Ich entschuldige mich für die Tatsache, dass es ohne Grafik hier zu viele Dimensionen gibt und ich sie einfach nicht erstellen kann!  In jedem Fall sind bei Betrachtung der Zahlen die folgenden Schlussfolgerungen offensichtlich: <br><br><ul><li>  In den meisten Fällen gibt es keinen Unterschied zwischen <b>int-</b> und <b>float-Tiefenpuffer</b> .  Arithmetische Fehler zur Berechnung von Tiefenüberschreibungsfehlern bei der Konvertierung in int.  Zum Teil, weil float32 und int24 fast gleich ULP haben (die Einheit mit der geringsten Genauigkeit ist der Abstand zur nächsten benachbarten Zahl), und zwar um [0.5.1] (da float32 eine 23-Bit-Mantisse hat), sodass ein Konvertierungsfehler nicht über fast den gesamten Tiefenbereich hinzugefügt wird in int. </li><li>  In den meisten Fällen verbessert die Trennung von <b>Ansichts-</b> und <b>Projektionsmatrizen</b> (gemäß den Empfehlungen von Upchurch und Desbrun) das Ergebnis.  Trotz der Tatsache, dass die Gesamtfehlerrate nicht abnimmt, werden „Swaps“ zu gleichen Werten, und dies ist ein Schritt in die richtige Richtung. </li><li>  Die unendliche Fernebene ändert die Fehlerhäufigkeit geringfügig.  Upchurch und Desbrun sagten eine Verringerung der Häufigkeit numerischer Fehler (Genauigkeitsfehler) um 25% voraus, dies scheint jedoch nicht zu einer Verringerung der Häufigkeit von Vergleichsfehlern zu führen. </li></ul><br>  Die obigen Befunde sind jedoch im Vergleich zu Magic <b>Reverse-Z</b> nicht real.  Überprüfen Sie: <br><br><ul><li>  Reversed-Z mit Float-Tiefenpuffer ergibt im Test eine <i>Fehlerrate von Null</i> .  Jetzt können natürlich einige Fehler auftreten, wenn Sie das Intervall der Eingabetiefenwerte weiter erhöhen.  Reverse-Z mit Float ist jedoch lächerlich genauer als jede andere Option. </li><li>  Reversed-Z mit Integer-Tiefenpuffer ist genauso gut wie andere Integer-Optionen. </li><li>  Reversed-Z verwischt die Unterscheidung zwischen zusammengesetzten und separaten Ansichts- / Projektionsmatrizen sowie endlichen und unendlichen Fernebenen.  Mit anderen Worten, mit umgekehrtem Z können Sie die Projektion mit anderen Matrizen multiplizieren und jede gewünschte ferne Ebene verwenden, ohne die Genauigkeit zu beeinträchtigen. </li></ul><br><h2>  Fazit </h2><br>  Ich denke, die Schlussfolgerung ist klar.  Verwenden Sie in jeder Situation bei der perspektivischen Projektion einfach den <b>Float-Tiefenpuffer und das umgekehrte Z</b> !  Und wenn Sie den Float-Tiefenpuffer nicht verwenden können, sollten Sie immer noch das umgekehrte Z verwenden.  Dies ist kein Allheilmittel für alle Krankheiten, insbesondere wenn Sie eine offene Umgebung mit extremen Tiefenbereichen schaffen.  Aber das ist ein guter Anfang. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434322/">https://habr.com/ru/post/de434322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434308/index.html">Funktionsweise des Ivideon-Videoüberwachungssystems: Überblick über die PC-Software</a></li>
<li><a href="../de434312/index.html">Konferenzzeit! Fazit 2018</a></li>
<li><a href="../de434314/index.html">Alternativen zu LastPass. Vergleichende Bewertung von sechs Passwort-Managern</a></li>
<li><a href="../de434316/index.html">Geheimer Weihnachtsmann, Quests, Quiz und Eisbahn - wie wir ABBYY New Year kennengelernt haben</a></li>
<li><a href="../de434320/index.html">Wie wir Sberbank Online unter iOS testen</a></li>
<li><a href="../de434326/index.html">Ballett in der Luft: kontrollierte Partikelschwebung durch Schallwellen</a></li>
<li><a href="../de434328/index.html">Elektronische Signatur für die Teilnahme an der Beschaffung</a></li>
<li><a href="../de434330/index.html">Was ist neu in YouTrack 2018.4?</a></li>
<li><a href="../de434332/index.html">Und noch einmal zu KIB SearchInform: Wir beschäftigen uns mit den neuesten Entwicklungen</a></li>
<li><a href="../de434334/index.html">Wie Baghunter Luftpostbriefe auf ZeroNights abfingen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>