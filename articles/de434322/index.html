<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äç‚úàÔ∏è üö¥üèø üêØ Tiefengenauigkeit klar üö∞ üö∂ ü§ú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tiefengenauigkeit ist ein Schmerz im Arsch, dem sich jeder Grafikprogrammierer fr√ºher oder sp√§ter stellen muss. Zu diesem Thema wurden viele Artikel u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tiefengenauigkeit klar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434322/">  Tiefengenauigkeit ist ein Schmerz im Arsch, dem sich jeder Grafikprogrammierer fr√ºher oder sp√§ter stellen muss.  Zu diesem Thema wurden viele Artikel und Werke verfasst.  In verschiedenen Spielen und Engines sowie auf verschiedenen Plattformen k√∂nnen Sie viele verschiedene Formate und Einstellungen f√ºr den <b>Tiefenpuffer sehen</b> . <br><br>  Die Tiefenkonvertierung auf einer GPU scheint aufgrund der Wechselwirkung mit der perspektivischen Projektion nicht offensichtlich zu sein, und das Studium der Gleichungen verdeutlicht die Situation nicht.  Um zu verstehen, wie dies funktioniert, ist es hilfreich, einige Bilder zu zeichnen. <br><br><img src="https://developer.nvidia.com/sites/default/files/styles/main_image/public/akamai/gameworks/blog/Depthprecision/graph.jpg?itok=tLMbXLov" alt="Bild"><br><br>  Dieser Artikel ist in 3 Teile gegliedert: <br><br><ol><li>  Ich werde versuchen, die Motivation f√ºr die <b>nichtlineare</b> Tiefenumwandlung zu erkl√§ren. </li><li>  Ich werde einige Diagramme vorstellen, die Ihnen helfen zu verstehen, wie die nichtlineare Tiefenkonvertierung in verschiedenen Situationen intuitiv und visuell funktioniert. </li><li>  Eine Diskussion der wichtigsten Ergebnisse der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versch√§rfung der Pr√§zision des perspektivischen</a> Renderns [Paul Upchurch, Mathieu Desbrun (2012)] hinsichtlich der Auswirkung von Rundungs-Gleitkommafehlern auf die Tiefengenauigkeit. </li></ol><br><a name="habracut"></a><br><h2>  Warum 1 / z? </h2><br>  Ein Hardware-GPU- <b>Tiefenpuffer</b> speichert normalerweise keine lineare Darstellung des Abstands zwischen dem Objekt und der Kamera, im Gegensatz zu dem, was beim ersten Treffen naiv erwartet wird.  Stattdessen speichert der Tiefenpuffer Werte, die umgekehrt proportional zur Tiefe des Ansichtsraums sind.  Ich m√∂chte kurz die Motivation f√ºr eine solche Entscheidung beschreiben. <br><br>  In diesem Artikel werde ich <b>d verwenden</b> , um die im Tiefenpuffer gespeicherten Werte darzustellen (im Bereich [0, 1] f√ºr DirectX), und <b>z</b> , um den Tiefenansichtsraum darzustellen, d. H.  Die tats√§chliche Entfernung von der Kamera, in Welteinheiten, z. B. Meter.  Im Allgemeinen hat die Beziehung zwischen ihnen die folgende Form: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math1.jpg" alt="Bild"><br><br>  Dabei sind <b>a, b</b> die Konstanten, die den Nah- und Ferneinstellungen der Ebenen zugeordnet sind.  Mit anderen Worten, <b>d</b> ist immer eine lineare Transformation von <b>1 / z</b> . <br><br>  Auf den ersten Blick scheint es, dass jede Funktion von <b>z</b> als <b>d angenommen werden kann</b> .  Warum sieht sie so aus?  Daf√ºr gibt es zwei Hauptgr√ºnde. <br><br>  Erstens passt <b>1 / z</b> nat√ºrlich in die perspektivische Projektion.  Und dies ist die grundlegendste Klasse von Transformationen, bei der garantiert gerade Linien erhalten bleiben.  Daher ist die perspektivische Projektion f√ºr die Hardware-Rasterung geeignet, da die geraden Kanten der Dreiecke gerade auf dem Bildschirm bleiben.  Wir k√∂nnen eine lineare Transformation von <b>1 / z erhalten</b> , indem wir die Perspektiventeilung nutzen, die die GPU bereits durchf√ºhrt: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math2.jpg" alt="Bild"><br><br>  Die wahre St√§rke dieses Ansatzes besteht nat√ºrlich darin, dass die Projektionsmatrix mit anderen Matrizen multipliziert werden kann, sodass Sie viele Transformationen zu einer kombinieren k√∂nnen. <br><br>  Der zweite Grund ist, dass <b>1 / z</b> im Bildschirmbereich linear ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie Emil Persson feststellte</a> .  Dies macht es einfach, d im Dreieck w√§hrend der Rasterung zu interpolieren, und Dinge wie <b>hierarchische Z-Puffer</b> , <b>fr√ºhes Z-Culling</b> und <b>Komprimierungstiefenpuffer</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Kurz aus dem Artikel</b> <div class="spoiler_text">  W√§hrend der Wert von <b>w (Ansichtsraumtiefe)</b> im Ansichtsraum linear ist, ist er im Bildschirmraum nicht linear.  <b>z (Tiefe)</b> , nicht linear im Sichtraum, andererseits linear im Bildschirmraum.  Dies kann leicht mit einem einfachen DX10-Shader √ºberpr√ºft werden: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dx = ddx(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dy = ddy(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000.0</span></span> * float4(<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dx), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dy), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Hier ist In.position SV_Position.  Das Ergebnis sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="http://www.humus.name/News/ZGradient.png" alt="Bild"><br><br>  Beachten Sie, dass alle Oberfl√§chen monochrom aussehen.  Der Unterschied in <b>z</b> von Pixel zu Pixel ist f√ºr jedes Grundelement gleich.  Dies ist sehr wichtig f√ºr die GPU.  Ein Grund ist, dass die <b>z-</b> Interpolation billiger ist als die <b>w-</b> Interpolation.  F√ºr <b>z ist</b> keine perspektivische Korrektur erforderlich.  Mit billigeren Hardwareeinheiten k√∂nnen Sie mehr Pixel pro Zyklus mit dem gleichen Budget f√ºr Transistoren verarbeiten.  Dies ist nat√ºrlich sehr wichtig f√ºr die <b>Pre-Z-Pass-</b> und <b>Schattenkarte</b> .  Bei moderner Hardware ist die Linearit√§t des Bildschirmbereichs auch eine sehr n√ºtzliche Funktion f√ºr Z-Optimierungen.  Da der Gradient f√ºr das gesamte Grundelement linear ist, ist es auch relativ einfach, den genauen Tiefenbereich innerhalb der Kachel f√ºr das <b>Hi-z-Keulen</b> zu berechnen.  Dies bedeutet auch, dass eine <b>Z-Komprimierung</b> m√∂glich ist.  Mit einer Konstanten <b>Œîz</b> in <b>x</b> und <b>y m√ºssen</b> Sie nicht viele Informationen speichern, um alle <b>z-</b> Werte in einer Kachel vollst√§ndig wiederherstellen zu k√∂nnen, vorausgesetzt, das Grundelement hat die gesamte Kachel abgedeckt. <br></div></div><br><h2>  Tiefendiagramme </h2><br>  Gleichungen sind kompliziert, schauen wir uns ein paar Bilder an! <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph1.jpg" alt="Bild"><br><br>  Sie k√∂nnen diese Diagramme von links nach rechts und dann von unten lesen.  Beginnen Sie mit <b>d</b> auf der linken Achse.  Da <b>d</b> eine beliebige lineare Transformation von <b>1 / z sein kann</b> , k√∂nnen wir 0 und 1 an jeder geeigneten Stelle auf der Achse anordnen.  Markierungen zeigen unterschiedliche <b>Tiefenpufferwerte an</b> .  Aus Gr√ºnden der √úbersichtlichkeit modelliere ich einen normalisierten 4-Bit-Ganzzahl-Tiefenpuffer, sodass 16 Markierungen mit gleichm√§√üigem Abstand vorhanden sind. <br><br>  Die obige Grafik zeigt die Standard-Vanille-Tiefenkonvertierung in D3D und √§hnliche APIs.  Sie k√∂nnen sofort feststellen, dass aufgrund der <b>1 / z-</b> Kurve Werte nahe der nahen Ebene gruppiert und Werte nahe der fernen Ebene gestreut werden. <br><br>  Es ist auch leicht zu verstehen, warum die N√§he einer Ebene die Tiefengenauigkeit so stark beeinflusst.  Der Abstand in der N√§he der Ebene f√ºhrt zu einem raschen Anstieg der Werte von <b>d</b> relativ zu den Werten von <b>z</b> , was zu einer noch ungleichm√§√üigeren Verteilung der Werte f√ºhrt: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph2.jpg" alt="Bild"><br><br>  In √§hnlicher Weise ist in diesem Zusammenhang leicht zu erkennen, warum das Verschieben der fernen Ebene ins Unendliche keinen so gro√üen Effekt hat.  Es bedeutet nur, den Bereich von <b>d</b> auf <b>1 / z = 0 zu erweitern</b> : <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph3.jpg" alt="Bild"><br><br>  Aber was ist mit der Gleitkommatiefe?  Dem folgenden Diagramm wurden Markierungen hinzugef√ºgt, die dem Float-Format mit 3 Bits des Exponenten und 3 Bits der Mantisse entsprechen: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph4.jpg" alt="Bild"><br><br>  Jetzt gibt es im Bereich [0,1] 40 verschiedene Werte - etwas mehr als 16 Werte fr√ºher, aber die meisten von ihnen sind nutzlos nahe der nahen Ebene gruppiert (n√§her an 0 hat der Schwimmer eine h√∂here Genauigkeit), wo wir wirklich nicht viel Genauigkeit ben√∂tigen. <br><br>  Ein bekannter Trick besteht nun darin, die Tiefe umzukehren und die nahe Ebene auf <b>d = 1</b> und die ferne Ebene auf <b>d = 0</b> anzuzeigen: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph5.jpg" alt="Bild"><br><br>  Viel besser!  Jetzt kompensiert die quasi-logarithmische Verteilung des Schwimmers irgendwie die Nichtlinearit√§t von <b>1 / z</b> , w√§hrend sie n√§her an der nahen Ebene eine Genauigkeit ergibt, die dem ganzzahligen Tiefenpuffer √§hnlich ist, und an anderer Stelle eine signifikant gr√∂√üere Genauigkeit ergibt.  Die Tiefengenauigkeit verschlechtert sich sehr langsam, wenn Sie sich weiter von der Kamera entfernen. <br><br>  Der <b>umgekehrte Z-</b> Trick wurde m√∂glicherweise mehrmals unabh√§ngig voneinander neu erfunden, aber zumindest die erste Erw√§hnung erfolgte in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ver√∂ffentlichung von SIGGRAPH '99</a> [Eugene Lapidous und Guofang Jiao (leider nicht √∂ffentlich verf√ºgbar)].  Und k√ºrzlich wurde er auf dem Blog von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Matt Petineo</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brano Kemen</a> sowie in einer Rede von Emil Persson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Creating Vast Game Worlds</a> SIGGRAPH 2012 erneut erw√§hnt. <br><br>  Alle vorherigen Diagramme nahmen nach der Projektion einen Tiefenbereich [0,1] an, was in D3D eine Konvention ist.  Was ist mit <b>OpenGL</b> ? <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph6.jpg" alt="Bild"><br><br>  <b>OpenGL</b> nimmt standardm√§√üig nach der Projektion einen Tiefenbereich [-1, 1] an.  Bei ganzzahligen Formaten √§ndert sich nichts, aber bei Gleitkommazahlen konzentriert sich jede Genauigkeit nutzlos auf die Mitte.  (Der Tiefenwert wird f√ºr die anschlie√üende Speicherung im Tiefenpuffer auf den Bereich [0,1] abgebildet, dies hilft jedoch nicht weiter, da die anf√§ngliche Zuordnung zu [-1,1] bereits die gesamte Genauigkeit in der anderen H√§lfte des Bereichs zerst√∂rt hat.) Und aufgrund der Symmetrie <b>umgekehrt-Z</b> funktioniert hier nicht. <br><br>  Gl√ºcklicherweise kann dies in Desktop-OpenGL mit der weit verbreiteten Erweiterung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ARB_clip_control behoben werden</a> (ebenfalls ab OpenGL 4.5 ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">glClipControl Standard</a> ).  Leider ist GL ES im Flug. <br><br><h2>  Die Auswirkung von Rundungsfehlern </h2><br>  Die <b>1 / z-</b> Konvertierung und die Wahl zwischen <b>Float und Int-Tiefenpuffer</b> sind ein gro√üer Teil der Geschichte der Genauigkeit, aber nicht alle.  Selbst wenn Sie √ºber eine ausreichende Tiefengenauigkeit verf√ºgen, um die Szene darzustellen, die Sie rendern m√∂chten, kann die Genauigkeit w√§hrend des Scheitelpunktkonvertierungsprozesses leicht durch Rechenfehler beeintr√§chtigt werden. <br><br>  Zu Beginn des Artikels wurde erw√§hnt, dass Upchurch und Desbrun dieses Problem untersucht haben.  Sie schlugen zwei Hauptempfehlungen vor, um Rundungsfehler zu minimieren: <br><br><ol><li>  Verwenden Sie die unendliche Fernebene. </li><li>  Halten Sie die Projektionsmatrix von anderen Matrizen getrennt und wenden Sie sie als separate Operation im Vertex-Shader an, anstatt sie mit der Ansichtsmatrix zu kombinieren. </li></ol><br>  Upchurch und Desbrun gaben diese Empfehlungen unter Verwendung einer Analysemethode ab, die auf der Verarbeitung von Rundungsfehlern als kleine zuf√§llige Fehler basiert, die in jeder arithmetischen Operation dargestellt werden, und deren Verfolgung in der ersten Reihenfolge im Konvertierungsprozess.  Ich beschloss, die Ergebnisse in der Praxis zu testen. <br><br>  Die Quellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> sind Python 3.4 und numpy.  Das Programm funktioniert wie folgt: Es wird eine Folge von zuf√§lligen Punkten erzeugt, die nach Tiefe geordnet sind und linear oder logarithmisch zwischen nahen und fernen Ebenen liegen.  Dann werden die Punkte mit der Ansicht multipliziert und die Matrix projiziert, und die Perspektiventeilung wird unter Verwendung von 32-Bit-Gleitkommazahlen durchgef√ºhrt, und optional wird das Endergebnis in ein 24-Bit-Int konvertiert.  Am Ende durchl√§uft es die Sequenz und z√§hlt, wie oft 2 benachbarte Punkte (die anfangs unterschiedliche Tiefen hatten) entweder identisch wurden, weil sie dieselbe Tiefe hatten oder die Reihenfolge √ºberhaupt ge√§ndert wurde.  Mit anderen Worten, das Programm misst in verschiedenen Szenarien die H√§ufigkeit, mit der Tiefenvergleichsfehler auftreten - was Problemen wie <b>Z-K√§mpfen</b> entspricht. <br><br>  Hier sind die Ergebnisse f√ºr nah = 0,1, fern = 10 K mit einer linearen Tiefe von 10 K.  (Ich habe das logarithmische Tiefenintervall und andere Nah / Fern-Verh√§ltnisse ausprobiert, und obwohl die spezifischen Zahlen variierten, waren die allgemeinen Trends in den Ergebnissen dieselben.) <br><br>  In der Tabelle werden "eq" - zwei Punkte mit der n√§chsten Tiefe erhalten den gleichen Wert im Tiefenpuffer und "swap" - zwei Punkte mit der n√§chsten Tiefe werden getauscht. <br><table><tbody><tr><td colspan="1" rowspan="2"></td><td colspan="2" rowspan="1">  <b>Zusammengesetzte Ansichtsprojektionsmatrix</b> </td><td colspan="2" rowspan="1">  <b>Separate Ansichts- und Projektionsmatrizen</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>Unver√§nderte Z-Werte (Kontrolltest)</b> </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Standardprojektion</b> </td><td colspan="1" rowspan="1">  45% √Ñq <br>  18% Swap </td><td colspan="1" rowspan="1">  45% √Ñq <br>  18% Swap </td><td colspan="1" rowspan="1">  77% √Ñq <br>  0% Swap </td><td colspan="1" rowspan="1">  77% √Ñq <br>  0% Swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Unendlich weit</b> </td><td colspan="1" rowspan="1">  45% √Ñq <br>  18% Swap </td><td colspan="1" rowspan="1">  45% √Ñq <br>  18% Swap </td><td colspan="1" rowspan="1">  76% √Ñq <br>  0% Swap </td><td colspan="1" rowspan="1">  76% √Ñq <br>  0% Swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Umgekehrt z</b> </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  76% √Ñq <br>  0% Swap </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  76% √Ñq <br>  0% Swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Unendlich + umgekehrt-Z</b> </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  76% √Ñq <br>  0% Swap </td><td colspan="1" rowspan="1">  0% Gl <br>  0% Swap </td><td colspan="1" rowspan="1">  76% √Ñq <br>  0% Swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Standard + GL-Stil</b> </td><td colspan="1" rowspan="1">  56% √Ñq <br>  12% Swap </td><td colspan="1" rowspan="1">  56% √Ñq <br>  12% Swap </td><td colspan="1" rowspan="1">  77% √Ñq <br>  0% Swap </td><td colspan="1" rowspan="1">  77% √Ñq <br>  0% Swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Unendlich + GL-Stil</b> </td><td colspan="1" rowspan="1">  59% √Ñq <br>  10% Swap </td><td colspan="1" rowspan="1">  59% √Ñq <br>  10% Swap </td><td colspan="1" rowspan="1">  77% √Ñq <br>  0% Swap </td><td colspan="1" rowspan="1">  77% √Ñq <br>  0% Swap </td></tr></tbody></table><br>  Ich entschuldige mich f√ºr die Tatsache, dass es ohne Grafik hier zu viele Dimensionen gibt und ich sie einfach nicht erstellen kann!  In jedem Fall sind bei Betrachtung der Zahlen die folgenden Schlussfolgerungen offensichtlich: <br><br><ul><li>  In den meisten F√§llen gibt es keinen Unterschied zwischen <b>int-</b> und <b>float-Tiefenpuffer</b> .  Arithmetische Fehler zur Berechnung von Tiefen√ºberschreibungsfehlern bei der Konvertierung in int.  Zum Teil, weil float32 und int24 fast gleich ULP haben (die Einheit mit der geringsten Genauigkeit ist der Abstand zur n√§chsten benachbarten Zahl), und zwar um [0.5.1] (da float32 eine 23-Bit-Mantisse hat), sodass ein Konvertierungsfehler nicht √ºber fast den gesamten Tiefenbereich hinzugef√ºgt wird in int. </li><li>  In den meisten F√§llen verbessert die Trennung von <b>Ansichts-</b> und <b>Projektionsmatrizen</b> (gem√§√ü den Empfehlungen von Upchurch und Desbrun) das Ergebnis.  Trotz der Tatsache, dass die Gesamtfehlerrate nicht abnimmt, werden ‚ÄûSwaps‚Äú zu gleichen Werten, und dies ist ein Schritt in die richtige Richtung. </li><li>  Die unendliche Fernebene √§ndert die Fehlerh√§ufigkeit geringf√ºgig.  Upchurch und Desbrun sagten eine Verringerung der H√§ufigkeit numerischer Fehler (Genauigkeitsfehler) um 25% voraus, dies scheint jedoch nicht zu einer Verringerung der H√§ufigkeit von Vergleichsfehlern zu f√ºhren. </li></ul><br>  Die obigen Befunde sind jedoch im Vergleich zu Magic <b>Reverse-Z</b> nicht real.  √úberpr√ºfen Sie: <br><br><ul><li>  Reversed-Z mit Float-Tiefenpuffer ergibt im Test eine <i>Fehlerrate von Null</i> .  Jetzt k√∂nnen nat√ºrlich einige Fehler auftreten, wenn Sie das Intervall der Eingabetiefenwerte weiter erh√∂hen.  Reverse-Z mit Float ist jedoch l√§cherlich genauer als jede andere Option. </li><li>  Reversed-Z mit Integer-Tiefenpuffer ist genauso gut wie andere Integer-Optionen. </li><li>  Reversed-Z verwischt die Unterscheidung zwischen zusammengesetzten und separaten Ansichts- / Projektionsmatrizen sowie endlichen und unendlichen Fernebenen.  Mit anderen Worten, mit umgekehrtem Z k√∂nnen Sie die Projektion mit anderen Matrizen multiplizieren und jede gew√ºnschte ferne Ebene verwenden, ohne die Genauigkeit zu beeintr√§chtigen. </li></ul><br><h2>  Fazit </h2><br>  Ich denke, die Schlussfolgerung ist klar.  Verwenden Sie in jeder Situation bei der perspektivischen Projektion einfach den <b>Float-Tiefenpuffer und das umgekehrte Z</b> !  Und wenn Sie den Float-Tiefenpuffer nicht verwenden k√∂nnen, sollten Sie immer noch das umgekehrte Z verwenden.  Dies ist kein Allheilmittel f√ºr alle Krankheiten, insbesondere wenn Sie eine offene Umgebung mit extremen Tiefenbereichen schaffen.  Aber das ist ein guter Anfang. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434322/">https://habr.com/ru/post/de434322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434308/index.html">Funktionsweise des Ivideon-Video√ºberwachungssystems: √úberblick √ºber die PC-Software</a></li>
<li><a href="../de434312/index.html">Konferenzzeit! Fazit 2018</a></li>
<li><a href="../de434314/index.html">Alternativen zu LastPass. Vergleichende Bewertung von sechs Passwort-Managern</a></li>
<li><a href="../de434316/index.html">Geheimer Weihnachtsmann, Quests, Quiz und Eisbahn - wie wir ABBYY New Year kennengelernt haben</a></li>
<li><a href="../de434320/index.html">Wie wir Sberbank Online unter iOS testen</a></li>
<li><a href="../de434326/index.html">Ballett in der Luft: kontrollierte Partikelschwebung durch Schallwellen</a></li>
<li><a href="../de434328/index.html">Elektronische Signatur f√ºr die Teilnahme an der Beschaffung</a></li>
<li><a href="../de434330/index.html">Was ist neu in YouTrack 2018.4?</a></li>
<li><a href="../de434332/index.html">Und noch einmal zu KIB SearchInform: Wir besch√§ftigen uns mit den neuesten Entwicklungen</a></li>
<li><a href="../de434334/index.html">Wie Baghunter Luftpostbriefe auf ZeroNights abfingen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>