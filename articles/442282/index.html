<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏾 ↕️ 😸 Dart 2. Programación asincrónica: futuros 🙌🏽 😭 😁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programación asincrónica: futuros 


 Contenido 


- Introduccion 
- ¿Cuál es el futuro? 
- Asíncrono - espera Manejo de errores Ejecución secuencial ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dart 2. Programación asincrónica: futuros</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442282/"><h1 id="asinhronnoe-programmirovanie-futures">  Programación asincrónica: futuros </h1><br><p>  <strong>Contenido</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Cuál es el futuro?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asíncrono - espera</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manejo de errores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejecución secuencial</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API futura</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manejo de errores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Llamando a múltiples funciones devolviendo el futuro</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Qué más leer?</a> </li></ul><br><p>  <strong>Lo que es importante:</strong> </p><br><ul><li>  El código en Dart se ejecuta en una ejecución de subproceso único ( <em>subproceso de nota - subproceso</em> ). </li><li>  Debido al código que toma (bloquea) el hilo durante mucho tiempo, el programa puede congelarse. </li><li> <code>Future</code> objetos <code>futures</code> ( <code>futures</code> ) representan los resultados de operaciones asincrónicas: procesamiento o E / S, que se completarán más adelante. </li><li>  Para suspender la ejecución hasta su finalización en el futuro, use <code>await</code> en la función asincrónica (o <code>then()</code> cuando use la API <code>Future</code> ). </li><li>  Para detectar errores, use la construcción <code>try-catch</code> (o <code>catchError()</code> cuando use la API <code>Future</code> ) en la función asincrónica. </li><li>  Para el procesamiento simultáneo, cree un aislamiento (o trabajador para la aplicación web). <a name="habracut"></a></li></ul><br><p>  El código en Dart se ejecuta en un solo hilo de ejecución.  Si el código está ocupado con cálculos largos o está esperando una operación de E / S, entonces todo el programa está en pausa. </p><br><p>  Las operaciones asincrónicas permiten que su programa complete otras tareas mientras espera que se complete la operación.  Dart usa <code>futures</code> para presentar los resultados de operaciones asincrónicas.  También puede usar async and await o Future API para trabajar con <code>futures</code> . </p><br><p>  <em>Una nota</em> </p><br><blockquote>  Todo el código se ejecuta en el contexto del aislamiento, que posee toda la memoria utilizada por el código.  No se puede iniciar más de una ejecución de código en el mismo aislamiento. <br><br>  Para la ejecución paralela de bloques de código, puede separarlos en aislamientos separados.  (Las aplicaciones web utilizan trabajadores en lugar de aislamientos). Normalmente, cada uno de los aislamientos se ejecuta en su propio núcleo de procesador.  Los aislamientos no comparten memoria, y la única forma en que pueden interactuar es enviándose mensajes entre ellos.  Para profundizar en el tema, consulte la documentación para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aislamientos</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trabajadores</a> . </blockquote><br><h2 id="vvedenie">  Introduccion </h2><br><p>  Veamos un ejemplo de código que puede "congelar" la ejecución del programa: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Synchronous code void printDailyNewsDigest() { var newsDigest = gatherNewsReports(); // Can take a while. print(newsDigest); } main() { printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore(); }</span></span></code> </pre> <br><p>  Nuestro programa lee las noticias del archivo del día, las muestra y luego muestra información que todavía es de interés para el usuario: </p><br><pre> <code class="plaintext hljs">&lt;gathered news goes here&gt; Winning lotto numbers: [23, 63, 87, 26, 2] Tomorrow's forecast: 70F, sunny. Baseball score: Red Sox 10, Yankees 0</code> </pre> <br><p>  En este ejemplo, el problema es que todas las operaciones después de llamar a <code>gatherNewsReports()</code> esperarán hasta que <code>gatherNewsReports()</code> devuelva el contenido del archivo, sin importar cuánto tiempo tarde.  Si leer el archivo lleva mucho tiempo, el usuario se verá obligado a esperar los resultados de la lotería, el pronóstico del tiempo y el ganador de un juego reciente. </p><br><p>  Para mantener la capacidad de respuesta de la aplicación, los autores de Dart utilizan un modelo asincrónico para identificar funciones que realizan un trabajo potencialmente costoso.  Dichas funciones devuelven su valor utilizando <code>futures</code> . </p><br><h2 id="chto-takoe-future">  ¿Cuál es el futuro? </h2><br><p>  <code>future</code> es una instancia de la clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Future &lt;T&gt;</a> , que es una operación asincrónica que devuelve un resultado de tipo T. Si no se utiliza el resultado de la operación, <code>Future&lt;void&gt;</code> indica el tipo de <code>future</code> .  Cuando se llama a una función que devuelve el <code>future</code> , suceden dos cosas: </p><br><ol><li>  La función se pone en cola para su ejecución y devuelve un objeto <code>Future</code> incompleto. </li><li>  Más tarde, cuando se completa la operación, el <code>future</code> termina con un valor o error. </li></ol><br><p>  Para escribir código dependiente del <code>future</code> , tiene dos opciones: </p><br><ul><li>  Usar <code>async</code> - <code>await</code> </li><li>  Use <code>Future</code> API </li></ul><br><h2 id="async---await">  Asíncrono - espera </h2><br><p>  Las palabras clave <code>async</code> y en <code>await</code> son parte del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soporte</a> <code>async</code> de Dart.  Le permiten escribir código asincrónico que se parece a un código síncrono y no utiliza la API <code>Future</code> .  <em>Una función asincrónica</em> es una función con la palabra clave <code>async</code> frente a su cuerpo.  La palabra clave <code>await</code> solo funciona en funciones asincrónicas. </p><br><blockquote>  Nota: en Dart 1.x, las funciones asincrónicas retrasan inmediatamente la ejecución.  En Dart 2, en lugar de pausar inmediatamente, las funciones asincrónicas se ejecutan sincrónicamente hasta que la primera <code>await</code> o <code>return</code> . </blockquote><p>  El siguiente código simula la lectura de noticias de un archivo usando <code>async</code> - <code>await</code> .  Abra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DartPad con la aplicación</a> , inicie y haga clic en CONSOLA para ver el resultado. </p><br><div class="spoiler">  <b class="spoiler_title">Código de ejemplo</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2013, the Dart project authors. Please see the AUTHORS file // for details. All rights reserved. Use of this source code is governed by a // BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;void&gt; printDailyNewsDigest() async { var newsDigest = await gatherNewsReports(); print(newsDigest); } main() { printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore(); } printWinningLotteryNumbers() { print('Winning lotto numbers: [23, 63, 87, 26, 2]'); } printWeatherForecast() { print("Tomorrow's forecast: 70F, sunny."); } printBaseballScore() { print('Baseball score: Red Sox 10, Yankees 0'); } const news = '&lt;gathered news goes here&gt;'; const oneSecond = Duration(seconds: 1); // Imagine that this function is more complex and slow. :) Future&lt;String&gt; gatherNewsReports() =&gt; Future.delayed(oneSecond, () =&gt; news); // Alternatively, you can get news from a server using features // from either dart:io or dart:html. For example: // // import 'dart:html'; // // Future&lt;String&gt; gatherNewsReportsFromServer() =&gt; HttpRequest.getString( // 'https://www.dartlang.org/f/dailyNewsDigest.txt', // );</span></span></code> </pre> </div></div><br><p>  Tenga en cuenta que primero llamamos a <code>printDailyNewsDigest()</code> , pero las noticias se imprimen en último lugar, incluso si el archivo contiene solo una línea.  Esto se debe a que el código que lee e imprime el archivo se ejecuta de forma asincrónica. </p><br><p>  En este ejemplo, <code>printDailyNewsDigest()</code> hace una llamada a <code>gatherNewsReports()</code> , que no bloquea.  Llamar al método <code>gatherNewsReports()</code> trabajo, pero no detiene la ejecución del resto del código.  El programa muestra los números de lotería, el pronóstico y la puntuación de un juego de béisbol;  El programa imprime las noticias después de que se <code>gatherNewsReports()</code> la recopilación de <code>gatherNewsReports()</code> .  Si <code>gatherNewsReports()</code> tarda un tiempo en completar su trabajo, no pasa nada malo: el usuario puede leer otras cosas antes de que se imprima el resumen de noticias diario. </p><br><p>  Presta atención a los tipos de devolución.  El tipo de retorno de la función <code>gatherNewsReports()</code> es <code>Future&lt;String&gt;</code> , lo que significa que devuelve un <code>future</code> que termina con un valor de cadena.  La función <code>printDailyNewsDigest()</code> , que no devuelve un valor, tiene un tipo de retorno de <code>Future&lt;void&gt;</code> . </p><br><p>  El siguiente diagrama muestra los pasos de ejecución del código. </p><br><p><img src="https://habrastorage.org/webt/cs/ez/9h/csez9hgmhhk6r1fyu8c4jryuydi.png"></p><br><ol><li>  La aplicación comienza a ejecutarse. </li><li>  La función <code>main()</code> se <code>printDailyNewsDigest()</code> función asincrónica <code>printDailyNewsDigest()</code> , que comienza a ejecutarse sincrónicamente. </li><li>  <code>printDailyNewsDigest()</code> utiliza <code>printDailyNewsDigest()</code> para llamar a la función <code>gatherNewsReports()</code> , que comienza a ejecutarse. </li><li>  <code>gatherNewsReports()</code> devuelve un <code>future</code> inacabado (una instancia de <code>Future&lt;String&gt;</code> ). </li><li>  Dado que <code>printDailyNewsDigest()</code> es una función asincrónica y espera un valor, detiene la ejecución y devuelve el <code>future</code> incompleto (en este caso, <code>Future&lt;void&gt;</code> ) a la función <code>main ()</code> llama. </li><li>  El resto de las funciones de salida se realizan.  Como son sincrónicos, cada función se realiza por completo antes de pasar a la siguiente.  Por ejemplo, todos los números de lotería ganadores se mostrarán antes del pronóstico del tiempo. </li><li>  Después de completar <code>main()</code> las funciones asincrónicas pueden reanudar la ejecución.  Primero obtenemos el <code>future</code> con noticias sobre la finalización de <code>gatherNewsReports()</code> .  Luego <code>printDailyNewsDigest()</code> continúa la ejecución, mostrando las noticias. </li><li>  Al final de la ejecución de <code>printDailyNewsDigest()</code> , <code>future</code> recibido originalmente y se cierra la aplicación. </li></ol><br><p>  Tenga en cuenta que la función asincrónica comienza inmediatamente (sincrónicamente).  La función detiene la ejecución y devuelve un <code>future</code> inacabado cuando ocurre la primera ocurrencia de cualquiera de los siguientes: </p><br><ul><li>  La primera expresión de <code>await</code> (después de que la función obtiene el <code>future</code> incompleto de esta expresión). </li><li>  Cualquier <code>return</code> en una función. </li><li>  El final del cuerpo de la función. </li></ul><br><h3 id="obrabotka-oshibok">  Manejo de errores </h3><br><p>  Lo más probable es que desee "detectar" un error en la ejecución de la función que devuelve el <code>future</code> .  En funciones asincrónicas, puede manejar errores usando <code>try-catch</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDailyNewsDigest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newsDigest = <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gatherNewsReports</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; print(newsDigest); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-comment"><span class="hljs-comment">// Handle error... } }</span></span></code> </pre> <br><p>  Un <code>try-catch</code> con código asincrónico se comporta igual que con el código síncrono: si el código en el bloque <code>try</code> produce una excepción, se ejecuta el código dentro de <code>catch</code> . </p><br><h3 id="posledovatelnoe-vypolnenie">  Ejecución secuencial </h3><br><p>  Puede usar múltiples expresiones de <code>await</code> para asegurarse de que cada declaración se complete antes de ejecutar lo siguiente: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Sequential processing using async and await. main() async { await expensiveA(); await expensiveB(); doSomethingWith(await expensiveC()); }</span></span></code> </pre> <br><p>  <code>expensiveB()</code> no se ejecuta hasta que se complete <code>expensiveA()</code> , y así sucesivamente. </p><br><h2 id="future-api">  API futura </h2><br><p>  Antes de agregar <code>async</code> y <code>await</code> en Dart 1.9, tenía que usar la API <code>Future</code> .  Todavía puede ver el uso de <code>Future</code> API en el código antiguo y en el código que necesita más funcionalidades que <code>async–await</code> tiene para ofrecer. </p><br><p>  Para escribir código asincrónico usando la API <code>Future</code> , use el método <code>then()</code> para registrar la devolución de llamada.  Esta devolución de llamada funcionará cuando se complete el <code>future</code> . </p><br><p>  El siguiente código simula la lectura de noticias de un archivo utilizando la API <code>Future</code> .  Abra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DartPad con la aplicación</a> , inicie y haga clic en CONSOLA para ver el resultado. </p><br><div class="spoiler">  <b class="spoiler_title">Código de ejemplo</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2013, the Dart project authors. Please see the AUTHORS file // for details. All rights reserved. Use of this source code is governed by a // BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;void&gt; printDailyNewsDigest() { final future = gatherNewsReports(); return future.then(print); // You don't *have* to return the future here. // But if you don't, callers can't await it. } main() { printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore(); } printWinningLotteryNumbers() { print('Winning lotto numbers: [23, 63, 87, 26, 2]'); } printWeatherForecast() { print("Tomorrow's forecast: 70F, sunny."); } printBaseballScore() { print('Baseball score: Red Sox 10, Yankees 0'); } const news = '&lt;gathered news goes here&gt;'; const oneSecond = Duration(seconds: 1); // Imagine that this function is more complex and slow. :) Future&lt;String&gt; gatherNewsReports() =&gt; Future.delayed(oneSecond, () =&gt; news); // Alternatively, you can get news from a server using features // from either dart:io or dart:html. For example: // // import 'dart:html'; // // Future&lt;String&gt; gatherNewsReportsFromServer() =&gt; HttpRequest.getString( // 'https://www.dartlang.org/f/dailyNewsDigest.txt', // );</span></span></code> </pre> </div></div><br><p>  Tenga en cuenta que primero llamamos a <code>printDailyNewsDigest()</code> , pero las noticias se imprimen en último lugar, incluso si el archivo contiene solo una línea.  Esto se debe a que el código que lee e imprime el archivo se ejecuta de forma asincrónica. </p><br><p>  Esta aplicación se ejecuta de la siguiente manera: </p><br><ol><li>  La aplicación comienza a ejecutarse. </li><li>  La función principal llama a <code>printDailyNewsDigest()</code> , que no devuelve el resultado inmediatamente, pero primero llama a <code>gatherNewsReports()</code> . </li><li>  <code>gatherNewsReports()</code> comienza a leer noticias y regresa en el <code>future</code> . </li><li>  <code>printDailyNewsDigest()</code> usa <code>then()</code> para registrar una devolución de llamada que tomará como parámetro el valor obtenido al final del <code>future</code> .  La llamada <code>then()</code> devuelve un nuevo <code>future</code> , que termina con el valor devuelto por la devolución de llamada de <code>then()</code> . </li><li>  El resto de las funciones de salida se ejecutan.  Como son sincrónicos, cada función se realiza por completo antes de pasar a la siguiente.  Por ejemplo, todos los números de lotería ganadores se mostrarán antes del pronóstico del tiempo. </li><li>  Cuando se han recibido todas las noticias, el <code>future</code> devuelto por la función <code>gatherNewsReports()</code> termina con una cadena que contiene las noticias recopiladas. </li><li>  El código especificado en <code>then()</code> en <code>printDailyNewsDigest()</code> se ejecuta para <code>printDailyNewsDigest()</code> noticias. </li><li>  La aplicación se está cerrando. </li></ol><br><blockquote>  Nota: en la función <code>printDailyNewsDigest()</code> , el código <code>future.then(print)</code> equivalente a lo siguiente: <code>future.then((newsDigest) =&gt; print(newsDigest))</code> . </blockquote><p>  Además, el código dentro de <code>then()</code> puede usar llaves: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDailyNewsDigest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> future = gatherNewsReports(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> future.then((newsDigest) { print(newsDigest); <span class="hljs-comment"><span class="hljs-comment">// Do something else... }); }</span></span></code> </pre> <br><p>  Debe especificar el argumento de devolución de llamada en <code>then()</code> , incluso si <code>future</code> es del tipo <code>Future&lt;void&gt;</code> .  Por convención, un argumento no utilizado se define a través de <code>_</code> (guión bajo). </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> future = printDailyNewsDigest(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> future.then((_) { <span class="hljs-comment"><span class="hljs-comment">// Code that doesn't use the `_` parameter... print('All reports printed.'); });</span></span></code> </pre> <br><h3 id="obrabotka-oshibok-1">  Manejo de errores </h3><br><p>  Usando la API <code>Future</code> , puede detectar el error usando <code>catchError()</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDailyNewsDigest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; gatherNewsReports().then(print).catchError(handleError);</code> </pre> <br><p>  Si las noticias no son legibles, el código anterior se ejecuta de la siguiente manera: </p><br><ol><li>  <code>future</code> devuelto por <code>gatherNewsReports()</code> falla. </li><li>  <code>future</code> devuelto por <code>then()</code> falla, no se llama a <code>print()</code> . </li><li>  La <code>catchError()</code> de <code>catchError()</code> en <code>catchError()</code> ( <code>handleError()</code> ) <code>handleError()</code> el error, el <code>future</code> devuelto por <code>catchError()</code> completa normalmente y el error no se propaga más. </li></ol><br><blockquote>  La cadena <code>catchError()</code> - <code>catchError()</code> es un patrón común cuando se usa la API <code>Future</code> .  Considere este par como el equivalente de un <code>try-catch</code> en la API <code>Future</code> . </blockquote><p>  Al igual que then (), catchError () devuelve un nuevo <code>future</code> que termina con el valor de retorno de la devolución de llamada.  Para profundizar en el tema, lea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Futuros y manejo de errores</a> . </p><br><h3 id="vyzov-neskolkih-funkciy-vozvraschayuschih-future">  Llamar a múltiples funciones que devuelven el <code>future</code> </h3><br><p>  Consideremos tres funciones: <code>expensiveA()</code> , <code>expensiveB()</code> , <code>expensiveC()</code> , que devuelven el <code>future</code> .  Puede llamarlos secuencialmente (una función comienza después de que se complete la anterior), o puede ejecutarlos todos al mismo tiempo y hacer algo tan pronto como regresen todos los valores.  La interfaz de Future es lo suficientemente flexible como para implementar ambos casos de uso. </p><br><p>  <strong>Una cadena de llamadas de función usando <code>then()</code></strong> <br>  Cuando las funciones que devuelven el <code>future</code> deben ejecutarse en orden, use la cadena desde <code>then()</code> : </p><br><pre> <code class="java hljs">expensiveA() .then((aValue) =&gt; expensiveB()) .then((bValue) =&gt; expensiveC()) .then((cValue) =&gt; doSomethingWith(cValue));</code> </pre> <br><p>  Adjuntar devoluciones de llamada también funciona, pero es más difícil de leer.  ( <em>nota <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://callbackhell.com/</a></em> ) </p><br><p>  <strong>Esperando que se completen múltiples <code>futures</code> usando <code>Future.wait()</code></strong> <br>  Si el orden de ejecución de las funciones no es importante, puede usar <code>Future.wait()</code> .  Cuando especifica la lista de <code>futures</code> para los parámetros de la función Future.wait (), inmediatamente devuelve el <code>future</code> .  Este <code>future</code> no terminará hasta que todos los <code>futures</code> especificados <code>futures</code> .  Este <code>future</code> terminará con una lista de los resultados de todos los <code>futures</code> indicados. </p><br><pre> <code class="java hljs">Future.wait([expensiveA(), expensiveB(), expensiveC()]) .then((List responses) =&gt; chooseBestResponse(responses, moreInfo)) .catchError(handleError);</code> </pre> <br><p>  Si falla una llamada a cualquiera de las funciones, también falla el <code>future</code> devuelto por <code>Future.wait()</code> .  Use <code>catchError()</code> para detectar este error. </p><br><hr><br><h2 id="chto-esche-pochitat">  ¿Qué más leer? </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dart 2. Programación asincrónica: flujos de datos</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442282/">https://habr.com/ru/post/442282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442270/index.html">5 errores a evitar al crear modelos 3D para impresión 3D</a></li>
<li><a href="../442272/index.html">Ir + = versión de paquete</a></li>
<li><a href="../442274/index.html">Dart 2. Programación asincrónica: flujos de datos</a></li>
<li><a href="../442278/index.html">Guía del usuario de Kibana. Visualización. Parte 6</a></li>
<li><a href="../442280/index.html">Aprendizaje automático en Dodo. Cómo lanzar una nueva dirección si eres desarrollador</a></li>
<li><a href="../442284/index.html">NoVerify: el linter para PHP del equipo VKontakte ahora está en el dominio público</a></li>
<li><a href="../442286/index.html">Los oftalmólogos rusos hablaron sobre la visión biónica. La nueva aplicación móvil demuestra el trabajo del ciber</a></li>
<li><a href="../442288/index.html">Radiación: fuentes</a></li>
<li><a href="../442290/index.html">Hacer ST-Link V2.1 a partir de ST-Link V2 chino</a></li>
<li><a href="../442292/index.html">Pasantía de Sberseasons: Python, UX / UI, datos y mucho más para estudiantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>