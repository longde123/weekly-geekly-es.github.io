<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍩 🏰 🤲🏿 Cassandra por almacenar metadatos: éxitos y fracasos 🧡 🤷🏽 🍭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Qué requisitos debe cumplir el almacenamiento de metadatos para un servicio en la nube? Sí, no el más común, pero para empresas con soporte para cent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cassandra por almacenar metadatos: éxitos y fracasos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417617/"> ¿Qué requisitos debe cumplir el almacenamiento de metadatos para un servicio en la nube?  Sí, no el más común, pero para empresas con soporte para centros de datos distribuidos geográficamente y Active-Active.  Obviamente, el sistema debería escalar bien, ser <strong>tolerante a fallas y desearía poder implementar una consistencia de operaciones personalizable.</strong> <br><br>  Solo Cassandra es adecuada para todos estos requisitos, y nada más es adecuado.  Cabe señalar que Cassandra es realmente genial, pero trabajar con ella se parece a una montaña rusa. <br><img src="https://habrastorage.org/webt/zs/tw/jb/zstwjb6bvwlg43rmuphw91_jtrm.jpeg"><br><br>  En un informe en Highload ++ 2017, <strong>Andrei Smirnov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">smira</a> ) decidió que no era interesante hablar sobre el bien, pero habló en detalle sobre cada problema que tuvo que enfrentar: sobre la pérdida de datos y la corrupción, sobre los zombis y la pérdida de rendimiento.  Estas historias son una verdadera reminiscencia de la montaña rusa, pero para todos los problemas hay una solución, para la cual eres bienvenido. <br><br>  <strong><em>Sobre el orador:</em></strong> Andrey Smirnov trabaja para Virtustream, una compañía que implementa almacenamiento en la nube para empresas.  La idea es que, condicionalmente, Amazon hace la nube para todos, y Virtustream hace las cosas específicas que necesita una gran empresa. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SAyClLjN6Sk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h1>  Algunas palabras sobre Virtustream </h1><br>  Trabajamos en un pequeño equipo completamente remoto y estamos involucrados en una de las soluciones en la nube de Virtustream.  Esta es una nube de almacenamiento de datos. <br><img src="https://habrastorage.org/webt/bo/rc/jh/borcjhczgtiycqzx8dz0bnh9zim.jpeg"><br><br>  Hablando de manera muy simple, esta es una API compatible con S3 en la que puede almacenar objetos.  Para aquellos que no saben qué es S3, es solo una API HTTP con la que puedes subir objetos a la nube en algún lugar, recuperarlos, eliminarlos, obtener una lista de objetos, etc.  Además, características más complejas basadas en estas operaciones simples. <br><br>  Tenemos algunas características distintivas que Amazon no tiene.  Una de ellas son las llamadas georegiones.  En la situación habitual, cuando crea un repositorio y dice que almacenará objetos en la nube, debe seleccionar una región.  Una región es esencialmente un centro de datos, y sus objetos nunca abandonarán este centro de datos.  Si algo le sucede, tus objetos ya no estarán disponibles. <br><br>  Ofrecemos geo-regiones en las que los datos se ubican simultáneamente en varios centros de datos (DC), al menos en dos, como en la imagen.  El cliente puede contactar con cualquier centro de datos, para él es transparente.  Los datos entre ellos se replican, es decir, trabajamos en el modo Activo-Activo, y constantemente.  Esto proporciona al cliente características adicionales, que incluyen: <br><br><ol><li>  mayor confiabilidad de almacenamiento, lectura y escritura en caso de falla de CC o pérdida de conectividad; <br></li><li>  disponibilidad de datos incluso si uno de los DC falla; <br></li><li>  operaciones de redireccionamiento al DC "más cercano". <br></li></ol><br>  Esta es una oportunidad interesante, incluso si estos DC están geográficamente separados, entonces algunos de ellos pueden estar más cerca del cliente en diferentes momentos.  Y acceder a los datos al DC más cercano es simplemente más rápido. <br><img src="https://habrastorage.org/webt/k-/ry/dl/k-rydl_mt74-eybwakpv1dpqjum.jpeg"><br><br>  Para dividir la construcción de la que hablaremos en partes, presentaré los objetos que están almacenados en la nube como dos piezas grandes: <br><br>  1. La primera pieza simple de un objeto son los <strong>datos</strong> .  No han cambiado, se descargaron una vez y eso es todo.  Lo único que puede sucederles más tarde es que podemos eliminarlos si ya no son necesarios. <br><br>  Nuestro proyecto anterior estaba relacionado con el almacenamiento de exabytes de datos, por lo que no tuvimos problemas con el almacenamiento de datos.  Esto ya era una tarea resuelta para nosotros. <br><br>  2. <strong>Metadatos</strong> .  Toda la lógica empresarial, todo lo más interesante, relacionado con la competencia: acceso, registros, reescrituras, en el área de metadatos. <br><br>  Los metadatos sobre el objeto toman en sí la mayor complejidad del proyecto, los metadatos almacenan un puntero al bloque de datos almacenados del objeto. <br><br>  Desde el punto de vista del usuario, este es un objeto único, pero podemos dividirlo en dos partes.  Hoy <strong>solo</strong> hablaré <strong>sobre metadatos</strong> . <br><br><h2>  Figuras <br></h2><br><ul><li>  <strong>Datos</strong> : 4 Pbytes. </li><li>  <strong>Grupos de metadatos</strong> : 3. </li><li>  <strong>Objetos</strong> : 40 mil millones. </li><li>  <strong>Tamaño de metadatos</strong> : 160 TB (incluida la replicación). </li><li>  <strong>Velocidad de cambio (metadatos):</strong> 3000 objetos / s. </li></ul><br>  Si observa estos indicadores con cuidado, lo primero que llama la atención es el tamaño promedio muy pequeño del objeto almacenado.  Tenemos muchos metadatos por unidad de volumen de datos maestros.  Para nosotros no fue menos sorprendente que quizás para ti ahora. <br><br>  Planeamos que tendríamos al menos un orden de datos, si no 2, más que metadatos.  Es decir, cada objeto será significativamente más grande y la cantidad de metadatos será menor.  Debido a que los datos son más baratos de almacenar, menos operaciones con ellos y los metadatos son mucho más caros tanto en el sentido del hardware como en el sentido de dar servicio y realizar varias operaciones en ellos. <br><br>  Además, estos datos cambian a una velocidad bastante alta.  He dado el valor pico aquí, el valor no pico no es mucho menor, pero, sin embargo, se puede obtener una carga bastante grande en puntos específicos en el tiempo. <br><br>  Estas cifras ya se obtuvieron de un sistema en funcionamiento, pero volvamos un poco al diseño de almacenamiento en la nube. <br><br><h1>  Elegir un repositorio para metadatos </h1><br>  Cuando nos enfrentamos al desafío de que queremos tener geo-regiones, Active-Active, y necesitamos almacenar metadatos en algún lugar, pensamos que podría ser. <br><br>  Obviamente, el repositorio (base de datos) debe tener las siguientes propiedades: <br><br><ul><li>  <strong>Soporte activo-activo</strong> ; </li><li>  <strong>Escalabilidad.</strong> </li></ul><br>  Realmente nos gustaría que nuestro producto sea extremadamente popular, y no sabemos cómo crecerá al mismo tiempo, por lo que el sistema debería escalar. <br><br><ul><li>  <strong>El equilibrio de tolerancia a fallos y fiabilidad de almacenamiento.</strong> </li></ul><br>  Los metadatos deben almacenarse de forma segura, porque si los perdemos y había un enlace a los datos en ellos, perderemos todo el objeto. <br><br><ul><li>  <strong>Consistencia de operaciones personalizable.</strong> </li></ul><br>  Debido al hecho de que trabajamos en varios DC y permitimos la posibilidad de que los DC no estén disponibles, además, los DC están lejos unos de otros, no podemos, durante la mayoría de las operaciones API, exigir que esta operación se realice simultáneamente en dos DC  Será demasiado lento e imposible si el segundo DC no está disponible.  Por lo tanto, parte de las operaciones deberían funcionar localmente en un DC. <br><br>  Pero, obviamente, algún tipo de convergencia debería ocurrir en algún momento, y después de resolver todos los conflictos, los datos deberían ser visibles en ambos centros de datos.  Por lo tanto, la consistencia de las operaciones debe ser ajustada. <br><br>  Desde mi punto de vista, Cassandra es adecuada para estos requisitos. <br><br><h1>  Cassandra </h1><br>  Estaría muy feliz si no tuviéramos que usar Cassandra, porque para nosotros fue una especie de experiencia nueva.  Pero nada más es adecuado.  Esto, me parece, es la situación más triste en el mercado para tales sistemas de almacenamiento, no hay <strong>alternativa</strong> . <br><br><img src="https://habrastorage.org/webt/ge/l-/xo/gel-xoykdx5yx1-sb36hjinlsas.jpeg"><br><br><h3>  ¿Qué es cassandra? <br></h3><br>  Esta es una base de datos distribuida de clave-valor.  Desde el punto de vista de la arquitectura y las ideas que están incrustadas en ella, me parece que todo es genial.  Si lo hiciera, haría lo mismo.  Cuando comenzamos, pensamos en escribir nuestro propio sistema de almacenamiento de metadatos.  Pero cuanto más lejos, más y más nos dimos cuenta de que tendríamos que hacer algo muy similar a Cassandra, y los esfuerzos que gastaremos en ello no valen la pena.  Para todo el desarrollo <strong>, solo tuvimos un mes y medio</strong> .  Sería extraño gastarlos escribiendo su base de datos. <br><br>  Si Cassandra estuviera en capas como un pastel de capas, seleccionaría 3 capas: <br><br>  1. <strong>Almacenamiento local de KV en cada nodo.</strong> <br>  Este es un grupo de nodos, cada uno de los cuales puede almacenar datos de valor clave localmente. <br><br>  2. <strong>Fragmentación de datos en nodos (hashing consistente).</strong> <br>  Cassandra puede distribuir datos entre los nodos del clúster, incluida la replicación, y lo hace de tal manera que el clúster puede crecer o disminuir de tamaño, y los datos se redistribuirán. <br><br>  3. Un <strong>coordinador para redirigir las solicitudes a otros nodos.</strong> <br>  Cuando accedemos a los datos para algunas consultas desde nuestra aplicación, Cassandra puede distribuir nuestra consulta en nodos para que obtengamos los datos que queremos y con el nivel de consistencia que necesitamos: queremos leerlos solo quórum, o quiere quórum con dos DC, etc. <br><img src="https://habrastorage.org/webt/zs/tw/jb/zstwjb6bvwlg43rmuphw91_jtrm.jpeg"><br><br>  Para nosotros, dos años con Cassandra, es una montaña rusa o una montaña rusa, lo que quieras.  Todo comenzó en el fondo, no teníamos experiencia con Cassandra.  Teníamos miedo  Empezamos, y todo estuvo bien.  Pero luego comienzan las caídas constantes y los despegues: el problema, todo está mal, no sabemos qué hacer, tenemos errores, luego resolvemos el problema, etc. <br><br>  Estas montañas rusas, en principio, no terminan hasta el día de hoy. <br><br><h1>  Bueno </h1><br>  El primer y último capítulo, donde digo que Cassandra es genial.  Es realmente genial, un gran sistema, pero si sigo diciendo lo bueno que es, creo que no te interesará.  Por lo tanto, prestaremos más atención a lo malo, pero más tarde. <br><br>  Cassandra es realmente buena. <br><br><ul><li>  Este es uno de los sistemas que nos permite tener <strong>un tiempo de respuesta en milisegundos</strong> , es decir, obviamente menos de 10 ms.  Esto es bueno para nosotros, porque el tiempo de respuesta en general es importante para nosotros.  La operación con metadatos para nosotros es solo una parte de cualquier operación relacionada con el almacenamiento de un objeto, ya sea que esté recibiendo o grabando. </li><li>  Desde el punto de vista de la grabación, <strong>se</strong> logra una <strong>alta escalabilidad</strong> .  Puede escribir en Cassandra a una velocidad loca, y en algunas situaciones esto es necesario, por ejemplo, cuando movemos grandes cantidades de datos entre registros. </li><li>  Cassandra es verdaderamente <strong>tolerante a fallas</strong> .  La caída de un nodo no conduce inmediatamente a problemas, aunque tarde o temprano comenzarán.  Cassandra declara que no tiene un solo punto de falla, pero, de hecho, hay puntos de falla en todas partes.  De hecho, el que trabajó con la base de datos sabe que incluso un bloqueo de nodo no es algo que generalmente sufre hasta la mañana.  Por lo general, esta situación debe repararse más rápido. </li><li>  <strong>Simplicidad</strong>  Aún así, en comparación con otras bases de datos relacionales estándar de Cassandra, es más fácil entender lo que está sucediendo.  Muy a menudo, algo sale mal y necesitamos entender lo que está sucediendo.  Cassandra tiene más posibilidades de resolverlo, llegar al tornillo más pequeño, probablemente, que con otra base de datos. </li></ul><br><h1>  Cinco malas historias </h1><br>  Repito, Cassandra es buena, funciona para nosotros, pero contaré cinco historias sobre lo malo.  Creo que esto es para lo que lo leíste.  Daré las historias en orden cronológico, aunque no están muy conectadas entre sí. <br><img src="https://habrastorage.org/webt/ao/15/oa/ao15oaiwdhwvl4w4u5pvcgwolrq.jpeg"><br><br>  Esta historia fue la más triste para nosotros.  Como almacenamos datos de usuarios, lo peor posible es perderlos y <strong>perderlos para siempre</strong> , como sucedió en esta situación.  Hemos proporcionado formas de recuperar datos si los perdemos en Cassandra, pero los perdimos para que realmente no pudiéramos recuperarlos. <br><br>  Para explicar cómo sucede esto, tendré que hablar un poco sobre cómo se organiza todo dentro de nosotros. <br><img src="https://habrastorage.org/webt/6i/vf/gk/6ivfgkdspndo3kzyy153iveq4xq.jpeg"><br><br>  Desde una perspectiva S3, hay algunas cosas básicas: <br><br><ul><li>  Bucket: se puede imaginar como un gran catálogo en el que el usuario carga un objeto (en adelante, el bucket). </li><li>  Cada objeto tiene un nombre (clave) y metadatos asociados: tamaño, tipo de contenido y un puntero a los datos del objeto.  Al mismo tiempo, el tamaño del cubo no está limitado por nada.  Es decir, pueden ser 10 claves, tal vez 100 mil millones de claves, no hay diferencia. </li><li>  Cualquier operación competitiva es posible, es decir, puede haber varios rellenos competitivos en la misma clave, puede haber eliminación competitiva, etc. </li></ul><br>  En nuestra situación, pueden ocurrir operaciones activo-activo, incluso competitivamente en diferentes DC, no solo en una.  Por lo tanto, necesitamos algún tipo de esquema de conservación que nos permita implementar tal lógica.  Al final, elegimos una política simple: gana la última versión registrada.  A veces se realizan varias operaciones competitivas, pero no es necesario que nuestros clientes lo hagan a propósito.  Puede ser solo una solicitud que comenzó, pero el cliente no esperó una respuesta, sucedió algo más, lo intentó de nuevo, etc. <br><br>  Por lo tanto, tenemos dos tablas base: <br><br><ol><li>  <strong>Tabla de objetos</strong> .  En él, un par, el nombre del depósito y el nombre de la clave, está asociado con su versión actual.  Si se elimina el objeto, entonces no hay nada en esta versión.  Si el objeto existe, existe su versión actual.  De hecho, en esta tabla solo cambiamos el campo de la versión actual. <br></li><li>  <strong>Tabla de versiones de objetos</strong> .  Solo insertamos nuevas versiones en esta tabla.  Cada vez que se descarga un nuevo objeto, insertamos una nueva versión en la tabla de versiones, le damos un número único, guardamos toda la información al respecto y, al final, le actualizamos el enlace en la tabla de objetos. <br></li></ol><br>  La figura muestra un ejemplo de cómo se relacionan las tablas de objetos y las versiones de objetos. <br><img src="https://habrastorage.org/webt/rv/jm/3y/rvjm3y1ohf-9yiehp1ajlm4zjik.jpeg"><br><br>  Aquí hay un objeto que tiene dos versiones: una actual y otra antigua, hay un objeto que ya se ha eliminado y su versión sigue ahí.  Necesitamos limpiar versiones innecesarias de vez en cuando, es decir, eliminar algo a lo que nadie más se refiere.  Además, no necesitamos eliminarlo de inmediato, podemos hacerlo en modo diferido.  Esta es nuestra limpieza interna, simplemente eliminamos lo que ya no es necesario. <br><br>  Hubo un problema <br><img src="https://habrastorage.org/webt/md/rc/xy/mdrcxyc9ojwdjuwchg7gsgkspio.jpeg"><br><br>  El problema era este: tenemos activo-activo, dos DC.  En cada DC, los metadatos se almacenan en tres copias, es decir, tenemos 3 + 3, solo 6 réplicas.  Cuando los clientes nos contactan, realizamos operaciones con coherencia (desde el punto de vista de Cassandra se llama LOCAL_QUORUM).  Es decir, se garantiza que el registro (o lectura) se produjo en 2 réplicas en el DC local.  Esto es una garantía; de lo contrario, la operación fallará. <br><br>  Cassandra siempre intentará escribir en las 6 líneas: el 99% de las veces todo estará bien.  De hecho, las 6 réplicas serán las mismas, pero nos garantizamos que 2. <br><br>  Tuvimos una situación difícil, aunque ni siquiera era una geo-región.  Incluso para regiones ordinarias que están en un DC, todavía almacenamos la segunda copia de metadatos en otro DC.  Esta es una larga historia, no daré todos los detalles.  Pero al final, tuvimos un proceso de limpieza que eliminó las versiones innecesarias. <br><br>  Y entonces surgió el mismo problema.  El proceso de limpieza también funcionó con la consistencia del quórum local en un centro de datos, porque no tiene sentido ejecutarlo en dos: lucharán entre sí. <br><br>  Todo estuvo bien hasta que resultó que nuestros usuarios todavía a veces escriben en otro centro de datos, lo cual no sospechamos.  Todo estaba configurado por si acaso para el feylover, pero resultó que ya lo estaban usando. <br><img src="https://habrastorage.org/webt/sa/cs/6q/sacs6qjj7og_ay7jbmkhfkjh9ei.jpeg"><br><br>  La mayoría de las veces, todo estuvo bien hasta que un día surgió una situación en la que una entrada en la tabla de versiones se replicaba en ambos DC, pero el registro en la tabla de objetos resultó estar en un solo DC y no terminó en el segundo.  En consecuencia, el procedimiento de limpieza, iniciado en la primera DC (superior), vio que había una versión a la que nadie se refería y la eliminó.  Y eliminé no solo la versión, sino también, por supuesto, los datos: todo es completamente, porque es solo un objeto innecesario.  Y esta eliminación es irrevocable. <br><br>  Por supuesto, hay un "boom" aún más, porque todavía tenemos un registro en la tabla de objetos que se refiere a una versión que ya no existe. <br><br>  Entonces, la primera vez que perdimos datos, y los perdimos de manera irrevocable, bueno, un poco. <br><br><h3>  Solución </h3><br>  Que hacer  En nuestra situación, todo es simple. <br><br>  Como tenemos datos almacenados en dos centros de datos, el proceso de limpieza es un proceso de convergencia y sincronización.  Debemos leer los datos de ambos DC.  Este proceso funcionará solo cuando ambos DC estén disponibles.  Como dije que este es un proceso retrasado que no ocurre durante el procesamiento de la API, esto no da miedo. <br><br>  <strong>Consistencia ALL</strong> es una característica de Cassandra 2. En Cassandra 3, todo es un poco mejor: hay un nivel de consistencia, que se llama quórum en cada DC.  Pero en cualquier caso, existe el problema de que es <strong>lento</strong> , porque, en primer lugar, tenemos que recurrir a la DC remota.  En segundo lugar, en el caso de la consistencia de los 6 nodos, esto significa que funciona a la velocidad del peor de estos 6 nodos. <br><br>  Pero al mismo tiempo, se produce el llamado proceso de <strong>reparación de lectura</strong> , cuando no todas las réplicas son sincrónicas.  Es decir, cuando la grabación falló en alguna parte, este proceso los repara simultáneamente.  Así es como funciona Cassandra. <br><br>  Cuando esto sucedió, recibimos una queja del cliente de que el objeto no estaba disponible.  Lo descubrimos, entendimos por qué, y lo primero que queríamos hacer era descubrir cuántos objetos más teníamos.  Ejecutamos un script que intentaba encontrar una construcción similar a esta cuando había una entrada en una tabla, pero ninguna entrada en otra. <br><br>  De repente, encontramos que tenemos el <strong>10% de esos registros</strong> .  Probablemente, nada peor podría no haber sucedido si no hubiéramos adivinado que este no era el caso.  El problema fue diferente. <br><br><img src="https://habrastorage.org/webt/kc/jt/_d/kcjt_dh03wmb-6szvtrgxqz-hme.jpeg"><br><br>  Los zombis se han infiltrado en nuestra base de datos.  Este es el nombre semioficial de este problema.  Para comprender qué es, debe hablar sobre cómo funciona la eliminación en Cassandra. <br><img src="https://habrastorage.org/webt/k2/sd/2j/k2sd2jvngn9ouhiv6b3yre0s8vs.jpeg"><br><br>  Por ejemplo, tenemos algún dato <strong><em>x</em></strong> que se registra y se replica perfectamente en las 6 réplicas.  Si queremos eliminarlo, la eliminación, como cualquier operación en Cassandra, puede no realizarse en todos los nodos. <br><br>  Por ejemplo, queríamos garantizar la consistencia de 2 de 3 en una DC.  Deje que la operación de eliminación se realice en cinco nodos, pero permanezca en un registro, por ejemplo, porque el nodo no estaba disponible en ese momento. <br><img src="https://habrastorage.org/webt/lu/d5/ot/lud5otv1dguftzwinkrb2wpeaaq.jpeg"><br><br>  Si eliminamos esto y luego tratamos de leer "Quiero 2 de 3" con la misma consistencia, entonces Cassandra, al ver el valor y su ausencia, interpreta esto como la presencia de datos.  Es decir, al volver a leer, ella dirá: "¡Oh, hay datos!", Aunque los eliminamos.  Por lo tanto, no puede eliminar de esta manera. <br><img src="https://habrastorage.org/webt/m6/li/ol/m6liolpvsglhmd_9wjg1gvkascw.jpeg"><br><br>  Cassandra elimina de manera diferente.  <strong>La eliminación es en realidad un registro</strong> .  Cuando eliminamos datos, Cassandra escribe un pequeño marcador llamado <strong>Tombstone</strong> (lápida).  Marca que los datos se eliminan.  Por lo tanto, si leemos el token de eliminación y los datos al mismo tiempo, Cassandra siempre prefiere el token de eliminación en esta situación y dice que en realidad no hay datos.  Esto es lo que necesitas. <br><br>  <strong>Tombstone —   </strong> , , ,      , -     ,     .   Tombstone     .   <strong>Tombstone   gc_grace_period </strong> .   ,   ,   . <br><br>   ? <br><br><h2> Repair <br></h2><br>  Cassandra  ,   Repair ().   —  ,     .       ,  ,      ,     , / ,  , -  - ,    ..     . Repair  ,    . <br><img src="https://habrastorage.org/webt/hj/td/x0/hjtdx0thzgak5uhzjd_ejn09s1m.jpeg"><br><br>   , -   , -   .  Repair    ,    ,    .  - ,     —     .     ,    . <br><img src="https://habrastorage.org/webt/qe/ee/kj/qeeekjf-dzxokqp6c4zi1aylljm.jpeg"><br><br>     Repair,       ,  ,      ,    — ,   .   6     .     — ,   ,     . <br><img src="https://habrastorage.org/webt/c7/qo/o2/c7qoo2bykcraic_gbj8fxbxrmoo.jpeg"><br><br>     ,      — ,  -  .      ,    .        ,  - ,    ,       ,    . <br><br><h3>  Solución <br></h3><br>   ,   : <br><br><ul><li> <strong>Repair       </strong> . </li></ul><br>    ,      repair.    ,          ,       . <br><br><ul><li> <strong>    ,    Tombstones,   ,   repair.</strong> </li></ul><br>  repair —   ,     repair. ,  ,          10-20 , , 3 .    Tombstone     ,     .      ,  ,      -. <br><img src="https://habrastorage.org/webt/18/yp/cc/18ypccovl1xcoxairec6nf3ssx0.jpeg"><br><br>      Cassandra,     .       . <br><br>  S3  .   ,      — 10 , 100  .   API,     —      .     , ,  , ,   ,         .  ,    ,  ,    —     ,    .      . <br><br>    API? <br><img src="https://habrastorage.org/webt/1l/tl/hd/1ltlhdhdtgnwgxezzz8jsnavvky.jpeg"><br><br>   ,     — , ,   —    ,    ,    .    .              — .   ,     ,   .   ,   ,      Cassandra.    ,         —  ,  ,    ,      . <br><br>        ,          ,      ,  ,  .          ,      . ,   ,             . ,   - ,           . <br><br> Cassandra ,       .           ,       ,  ,   ,       ,     . <br><img src="https://habrastorage.org/webt/fk/os/a3/fkosa3zozy2gk_dzpgjvxdwm4k8.jpeg"><br><br>    ,   Cassandra  <strong>composite key</strong> .       ,    —    ,   - ,      —  .    ,   .   ? ,   ,    ! <br><br>      ,    ,  , ,      —  ,          . <br><br>     .  Cassandra   ,   <strong>  Cassandra      </strong> .  ,     ,    Cassandra,        :  ,  ,   SQL  ..    ! <br><img src="https://habrastorage.org/webt/8o/_s/ka/8o_ska-swgmzixxiztlblopuze0.jpeg"><br><br>      .     Cassandra  ?    ,     ,   API.  ,   ,     ,   ,     (     )   . <strong>   ,   </strong>   . <br><br>    ,           .        ,   , ,    .   ,     —   —       . , ,  ,          . <br><br>   Cassandra   ,       .    : «  100 »,    ,    ,  ,      ,        ,   100,    . <br><br> ,         (   ),    —          ,    ,         .         ,   ,   ,   ,     ,   - .     100 ,   - ,     ,  .      ,         SQL    . <br><br> Cassandra       ,     ,     Java,    .  ,  <strong>Large Partition</strong> ,  .    — , , ,  ,     —  .         ,   , garbage collection    ..     . <br><br>   ,   ,  <strong>    ,   </strong> ,        . <br><br> ,        ,   -  . <br><img src="https://habrastorage.org/webt/qg/o9/oo/qgo9ooa3pgv_zqkv8iyby4ppq9g.jpeg"><br><br>   ,     ,           .      .     ,      Large Partition. <br><br>     : <br><br><ol><li>        ( ,  - ); <br></li><li>   ,    ,       .     ,     . <br></li></ol><br>   ,     ,   ,     key_hash   0.   , <strong>    ,         </strong> .       ,    .       ,      ,      . <br><br>  ,     . <br><img src="https://habrastorage.org/webt/zr/aw/xn/zrawxn-n6hr1huoqkenbqcgpeoo.jpeg"><br><br>    — ,    ,    ,      - -      . <br><br>   —      ,   N ?    ,  Large Partition,   —     .  ,        .   :   .  ,    ,  ,    ,       -  .    ,           .    , ,     . <br><img src="https://habrastorage.org/webt/og/um/4y/ogum4yxqpvbvrdadna7r8adomwm.jpeg"><br><br>     —   ,    ,   -  .    -  ,       ,       .    ,    ,    .   ,    ,        .. <br><br>         —  ,    ?    ,   .    ? -     md5- —      ,   -  30  —     ,  - .    .     ,     ,   . <br><img src="https://habrastorage.org/webt/yp/ik/vy/ypikvyolprsxdju5hawmlm6_epq.jpeg"><br><br>      ,    , , ,   .       —   ,    .    ,       .   ,    -  -   - ,  -  - —  .     ,     .      . <br><br><h2>   </h2><br>    ,    ,     ,    . <br><br><ul><li>   . </li><li>         . </li><li>     Cassandra. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Redistribución en línea (sin detener operaciones y pérdida de consistencia). </font></font></li></ul><br>  Tenemos algún estado del cubo ahora, de alguna manera está dividido en particiones.  Entonces entendemos que algunas particiones son demasiado grandes o demasiado pequeñas.  Necesitamos encontrar una nueva partición, que, por un lado, será óptima, es decir, el tamaño de cada partición será menor que algunos de nuestros límites, y serán más o menos uniformes.  En este caso, la transición del estado actual a uno nuevo debería requerir un número mínimo de acciones.  Está claro que cualquier transición requiere mover teclas entre particiones, pero cuanto menos las muevamos, mejor. <br><br>  Lo hicimos  Probablemente, la parte que se ocupa de la selección de distribución es la pieza más difícil de todo el servicio, si hablamos de trabajar con metadatos en general.  Lo reescribimos, volvimos a trabajar y aún lo hacemos, porque siempre se encuentran algunos clientes o ciertos patrones de creación de claves que golpean un punto débil de este esquema. <br><br>  Por ejemplo, supusimos que el cubo crecería de manera más o menos uniforme.  Es decir, recogimos algún tipo de distribución, y esperamos que todas las particiones crezcan de acuerdo con esta distribución.  Pero encontramos un cliente que siempre escribe al final, en el sentido de que sus claves siempre están ordenadas.  Todo el tiempo late en la última partición, que está creciendo a una velocidad tal que en un minuto pueden ser 100 mil llaves.  Y 100 mil es aproximadamente el valor que cabe en una partición. <br><br>  Simplemente no tendríamos tiempo para procesar dicha adición de claves con nuestro algoritmo, y tuvimos que introducir una distribución preliminar especial para este cliente.  Como sabemos cómo son sus teclas, si vemos que es él, simplemente comenzamos a crear particiones vacías por adelantado al final, para que pueda escribir con calma allí, y por ahora tendremos un pequeño descanso hasta la próxima iteración, cuando nuevamente tengamos que redistribuir todo. <br><br>  Todo esto sucede en línea en el sentido de que no detenemos la operación.  Puede haber operaciones de lectura, escritura, en cualquier momento puede solicitar una lista de claves.  Siempre será consistente, incluso si estamos en el proceso de reparticionamiento. <br><br>  Es bastante interesante, y resulta que con Cassandra.  Aquí puedes jugar con trucos relacionados con el hecho de que Cassandra puede resolver conflictos.  Si escribimos dos valores diferentes en la misma línea, entonces el valor que tiene una marca de tiempo más grande gana. <br><br>  Por lo general, la marca de tiempo es la marca de tiempo actual, pero se puede pasar manualmente.  Por ejemplo, queremos escribir un valor en una cadena, que en cualquier caso se debe frotar si el cliente escribe algo él mismo.  Es decir, estamos copiando algunos datos, pero queremos que el cliente, si de repente escribe con nosotros al mismo tiempo, pueda sobrescribirlos.  Entonces podemos copiar nuestros datos con una marca de tiempo un poco del pasado.  Entonces, cualquier grabación actual se deshilachará deliberadamente, independientemente del orden en que se realizó la grabación. <br><br>  Tales trucos te permiten hacer esto en línea. <br><br><h2>  Solución </h2><br><ul><li>  Nunca, nunca <strong>permita la aparición de una gran partición</strong> . </li><li>  <strong>Rompa los datos por clave principal</strong> según la tarea. </li></ul><br>  Si se planea algo similar a una partición grande en el esquema de datos, debe intentar hacer algo al respecto de inmediato: descubrir cómo romperlo y cómo alejarse de él.  Tarde o temprano, esto surge, porque cualquier índice invertido, tarde o temprano, surge en casi cualquier tarea.  Ya te conté sobre tal historia: tenemos una clave de depósito en el objeto y necesitamos obtener una lista de claves del depósito; de hecho, este es un índice. <br><br>  Además, la partición puede ser grande no solo a partir de los datos, sino también de Tombstones (marcadores de eliminación).  Desde el punto de vista de los componentes internos de Cassandra (nunca los vemos desde el exterior), los marcadores de eliminación también son datos, y una partición puede ser grande si se eliminan muchas cosas, porque la eliminación es un registro.  Tampoco deberías olvidarte de esto. <br><img src="https://habrastorage.org/webt/-s/tw/la/-stwlarb11mcy5nlqaqrpxfc-ky.jpeg"><br><br>  Otra historia que en realidad es constante es que algo sale mal de principio a fin.  Por ejemplo, ve que el tiempo de respuesta de Cassandra ha aumentado, responde lentamente.  ¿Cómo entender y entender cuál es el problema?  Nunca hay una señal externa de que el problema está ahí. <br><img src="https://habrastorage.org/webt/c0/lr/5r/c0lr5rwf9w5zi-nx1ddd5k5blgk.jpeg"><br><br>  Por ejemplo, daré un gráfico: este es el tiempo de respuesta promedio del clúster en su conjunto.  Muestra que tenemos un problema: el tiempo de respuesta máximo es de 12 segundos; este es el tiempo de espera interno de Cassandra.  Esto significa que ella se desconectará ella misma.  Si el tiempo de espera supera los 12 s, lo más probable es que el recolector de basura esté funcionando y Cassandra ni siquiera tiene tiempo para responder en el momento adecuado.  Ella responde a sí misma por tiempo de espera, pero el tiempo de respuesta a la mayoría de las solicitudes, como dije, debería ser en promedio dentro de 10 ms. <br><br>  En el gráfico, el promedio ya ha excedido cientos de milisegundos, algo salió mal.  Pero mirando esta imagen, es imposible entender cuál es la razón. <br><br><img src="https://habrastorage.org/webt/e6/t6/qk/e6t6qkz3yw6k80sjw7smsycclrc.jpeg"><br><br>  Pero si expande las mismas estadísticas en los nodos de Cassandra, puede ver que, en principio, todos los nodos son más o menos nada, pero el tiempo de respuesta para un nodo difiere en orden de magnitud.  Lo más probable es que haya algún tipo de problema con él. <br><br>  Las estadísticas sobre los nodos cambian la imagen por completo.  Estas estadísticas son del lado de la aplicación.  Pero aquí, en realidad, a menudo es difícil entender cuál es el problema.  Cuando una aplicación accede a Cassandra, accede a algún nodo, usándolo como coordinador.  Es decir, la aplicación realiza una solicitud y el coordinador la redirige a las réplicas con los datos.  Los que ya responden, y el coordinador devuelve la respuesta final. <br><br>  Pero, ¿por qué el coordinador responde lentamente?  Tal vez el problema es con él, como tal, es decir, ¿disminuye la velocidad y responde lentamente?  ¿O tal vez se ralentiza porque las réplicas le responden lentamente?  Si las réplicas responden lentamente, desde el punto de vista de la aplicación, se verá como una respuesta lenta del coordinador, aunque no tiene nada que ver con eso. <br><br>  Aquí hay una situación feliz: está claro que solo un nodo responde lentamente y lo más probable es que el problema esté en él. <br><br><h3>  Complejidad de interpretación </h3><br><br><ul><li>  Tiempo de respuesta del coordinador (nodo vs. réplica en sí). </li><li>  ¿Una tabla específica o el nodo completo? </li><li>  GC Pause?  ¿Grupo de subprocesos inadecuado? </li><li>  ¿Demasiadas SSTables no compactadas? </li></ul><br>  Siempre es difícil entender lo que está mal.  Solo <strong>necesita muchas estadísticas y monitoreo</strong> , tanto del lado de la aplicación como del propio Cassandra, porque si es realmente malo, Cassandra no puede ver nada.  Puede ver el nivel de consultas individuales, el nivel de cada tabla específica, en cada nodo específico. <br><br>  Puede haber, por ejemplo, una situación en la que una tabla de lo que se llama en Cassandra SSTables (archivos separados) tiene demasiado.  Para leer, Cassandra tiene que, más o menos, clasificar todas las SSTables.  Si hay demasiados, simplemente el proceso de esta clasificación lleva demasiado tiempo y la lectura comienza a ceder. <br><br>  La solución es la compactación, que reduce el número de estas SSTables, pero debe tenerse en cuenta que solo puede estar en un nodo para una tabla específica.  Dado que Cassandra, desafortunadamente, está escrito en Java y se ejecuta en la JVM, tal vez el recolector de basura ha entrado en una pausa tal que simplemente no tiene tiempo para responder.  Cuando el recolector de basura entra en pausa, no solo sus solicitudes se ralentizan, sino que la <strong>interacción dentro del clúster Cassandra entre nodos comienza a disminuir</strong> .  Los nodos de cada uno comienzan a considerarse como caídos, es decir, caídos, muertos. <br><br>  Comienza una situación aún más divertida, porque cuando un nodo considera que otro nodo está inactivo, en primer lugar, no le envía solicitudes y, en segundo lugar, comienza a intentar guardar los datos que necesitaría replicar en otro nodo en a nivel local, por lo que comienza a suicidarse lentamente, etc. <br><br>  Hay situaciones en las que este problema se puede resolver simplemente usando la configuración correcta.  Por ejemplo, puede haber suficientes recursos, todo está bien y es maravilloso, pero solo se necesita aumentar un conjunto de subprocesos, cuyo número es un tamaño fijo. <br><br>  Finalmente, tal vez necesitemos limitar la competitividad del lado del conductor.  A veces sucede que se envían demasiadas solicitudes competitivas y, como cualquier base de datos, Cassandra no puede manejarlas y acude al cierre cuando el tiempo de respuesta aumenta exponencialmente, y estamos tratando de dar más y más trabajo. <br><br><h3>  Comprensión del contexto. </h3><br>  Siempre hay algo de contexto para el problema: qué está sucediendo en el clúster, si Reparar está funcionando ahora, en qué nodo, en qué espacios clave, en qué tabla. <br><br>  Por ejemplo, tuvimos problemas bastante ridículos con el hierro.  Vimos que parte de los nodos es lenta.  Más tarde se descubrió que la razón era que en el BIOS sus procesadores estaban en modo de ahorro de energía.  Por alguna razón, durante la instalación inicial de hierro, esto sucedió, y aproximadamente el 50% de los recursos del procesador se usaron en comparación con otros nodos. <br><br>  Entender tal problema puede ser difícil, de hecho.  El síntoma es este: parece que el nodo hace compactación, pero lo hace lentamente.  A veces está conectado con hierro, a veces no, pero este es solo otro error de Cassandra. <br><br>  Por lo tanto, el monitoreo es obligatorio y necesita mucho.  Cuanto más compleja es la función en Cassandra, cuanto más se aleja de la simple escritura y lectura, más problemas hay con ella y más rápido puede eliminar una base de datos con un número suficiente de consultas.  Por lo tanto, si es posible, no mire algunos chips “sabrosos” e intente usarlos, es mejor evitarlos tanto como sea posible.  No siempre es posible, por supuesto, tarde o temprano es necesario. <br><img src="https://habrastorage.org/webt/mx/m8/lx/mxm8lxirhudrxrdlcq26jpstvle.jpeg"><br><br>  La última historia es sobre cómo Cassandra desordenó los datos.  En esta situación, sucedió dentro de Cassandra.  Eso fue interesante. <br><br>  Vimos que aproximadamente una vez por semana en nuestra base de datos aparecen varias docenas de líneas dañadas, que están literalmente obstruidas con basura.  Además, Cassandra valida los datos que van a su entrada.  Por ejemplo, si es una cadena, debería estar en utf8.  Pero en estas líneas había basura, no utf8, y Cassandra ni siquiera dio nada que ver con eso.  Cuando intento eliminar (o hacer otra cosa), no puedo eliminar un valor que no es utf8, porque, en particular, no puedo ingresarlo en DONDE, porque la clave debe ser utf8. <br><br>  Aparecen líneas estropeadas, como un destello, en algún momento, y luego desaparecen durante varios días o semanas. <br><br>  Empezamos a buscar un problema.  Pensamos que tal vez había un problema en un nodo particular con el que estábamos jugando, haciendo algo con datos, copiando SSTables.  Quizás, de todos modos, ¿puedes ver réplicas de estos datos?  ¿Quizás estas réplicas tienen un nodo común, el factor común más pequeño?  Tal vez algún nodo se bloquea?  No, nada de eso. <br><br>  Tal vez algo con un disco?  ¿Los datos están dañados en el disco?  No otra vez <br><br>  Tal vez un recuerdo?  No!  Esparcidos por un grupo. <br><br>  Tal vez este es algún tipo de problema de replicación?  ¿Un nodo estropeó todo y replicó aún más un mal valor?  - No <br><br>  Finalmente, ¿tal vez este es un problema de aplicación? <br><br>  Además, en algún momento, las líneas dañadas comenzaron a aparecer en dos grupos de Cassandra.  Uno trabajó en la versión 2.1, el segundo en el tercero.  Parece que Cassandra es diferente, pero el problema es el mismo.  ¿Quizás nuestro servicio envía datos incorrectos?  Pero era difícil de creer.  Cassandra valida los datos de entrada; no puede escribir basura.  Pero de repente? <br><br>  Nada cabe. <br><br><h3>  ¡Se encontró una aguja! </h3><br>  Luchamos mucho hasta que descubrimos un pequeño problema: ¿por qué tenemos algún tipo de volcado de memoria de la JVM en los nodos a los que no prestamos mucha atención?  Y de alguna manera se ve sospechosamente en el recolector de basura de seguimiento de pila ... Y por alguna razón, algunos rastros de pila también están obstruidos con basura. <br><br>  Al final, nos dimos cuenta, oh, <strong>por alguna razón, estamos usando la JVM de la versión anterior de 2015</strong> .  Esta fue la única cosa común que unió a los grupos de Cassandra en diferentes versiones de Cassandra. <br><br>  Todavía no sé cuál fue el problema, porque no se escribió nada sobre esto en las notas de lanzamiento oficiales de la JVM.  Pero después de la actualización, todo desapareció, el problema ya no surgió.  Además, no se produjo en el clúster desde el primer día, sino desde algún punto, aunque funcionó en la misma JVM durante mucho tiempo. <br><br><h3>  Recuperación de datos </h3><br>  ¿Qué lección hemos aprendido de esto? <br><br>  ● La copia de seguridad es inútil. <br>  Los datos, como descubrimos, se corrompieron en el mismo instante en que se registraron.  En el momento en que los datos ingresaron al coordinador, ya estaban dañados. <br><br>  ● Es posible la restauración parcial de columnas no dañadas. <br>  Algunas columnas no estaban dañadas, pudimos leer estos datos, restaurarlos parcialmente. <br><br>  ● Al final, tuvimos que hacer la recuperación de varias fuentes. <br>  Teníamos metadatos de respaldo en el objeto, pero en los datos en sí.  Para volver a conectar con el objeto, utilizamos registros, etc. <br><br>  ● ¡Los registros no tienen precio! <br>  Pudimos recuperar todos los datos que estaban dañados, pero al final es muy difícil confiar en la base de datos si pierde sus datos, incluso sin ninguna acción de su parte. <br><br><h3>  Solución </h3><br><ul><li>  Actualice la JVM después de extensas pruebas. </li><li>  Monitoreo de fallas JVM. </li><li>  Tener una copia de los datos independiente de Cassandra. </li></ul><br><blockquote>  <strong>Como consejo:</strong> intente obtener algún tipo de copia de los datos independiente de Cassandra de la que pueda recuperar si es necesario.  Esta puede ser la solución de último nivel.  Deje que tome mucho tiempo, recursos, pero debería haber alguna opción que le permita devolver datos. </blockquote><br><h1>  Bichos </h1><br>  ● <strong>Mala calidad de las pruebas de lanzamiento</strong> <br>  Cuando comienzas a trabajar con Cassandra, hay una sensación constante (especialmente si te estás moviendo, relativamente hablando, de bases de datos "buenas", por ejemplo, PostgreSQL) de que si solucionaste un error en el lanzamiento de la anterior, definitivamente agregarás uno nuevo.  Y el error no es una tontería, generalmente son datos corruptos u otro comportamiento incorrecto. <br><br>  ● <strong>Problemas persistentes con características complejas</strong> <br>  Cuanto más compleja es la característica, más problemas, errores, etc. <br><br>  ● <strong>No utilice reparaciones incrementales en 2.1</strong> <br>  La famosa reparación, de la que hablé, que corrige la consistencia de los datos, en modo estándar, cuando sondea todos los nodos, funciona bien.  Pero no en el llamado modo incremental (cuando la reparación omite datos que no han cambiado desde la reparación anterior, lo cual es bastante lógico).  Se anunció hace mucho tiempo, formalmente, ya que existe una característica, pero todos dicen: “No, en la versión 2.1, ¡nunca la use!  Definitivamente echará de menos algo.  En 3 lo arreglamos ". <br><br>  ● <strong>Pero no use la reparación incremental en 3.x</strong> <br>  Cuando salió la tercera versión, unos días después dijeron: “No, no puedes usarla en la tercera.  Hay una lista de 15 errores, por lo que en ningún caso no utilice la reparación incremental.  ¡En cuarto lo haremos mejor! <br><br>  No les creo.  Y este es un gran problema, especialmente con el aumento del tamaño del clúster.  Por lo tanto, debe monitorear constantemente su rastreador de errores y ver qué sucede.  Desafortunadamente, es imposible vivir con ellos sin él. <br><br>  ● <strong>Necesito hacer un seguimiento de JIRA</strong> <br><img src="https://habrastorage.org/webt/g0/1k/el/g01kela-ibcrrsorr1pjxo-pmdc.jpeg"><br><br><blockquote>  Si dispersas todas las bases de datos en el espectro de previsibilidad, para mí, Cassandra está a la izquierda en el área roja.  Esto no significa que sea malo, solo tienes que estar preparado para el hecho de que Cassandra es impredecible en cualquier sentido de la palabra: tanto en la forma en que funciona como en el hecho de que algo puede suceder. </blockquote><br><img src="https://habrastorage.org/webt/je/_1/w0/je_1w0808rlhzxo1bakk0zjj9ee.jpeg"><br><br>  Deseo que encuentres otros rastrillos y los pises, porque, desde mi punto de vista, pase lo que pase, Cassandra es buena y, desde luego, no aburrida.  ¡Solo recuerda los golpes en el camino! <br><br><blockquote>  <strong>Reunión abierta de activistas de HighLoad ++</strong> <br><br>  El 31 de julio en Moscú, a las 19:00, se llevará a cabo una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reunión de</a> oradores, el Comité del Programa y activistas de la conferencia de desarrolladores de sistemas de alta carga HighLoad ++ 2018. Organizaremos una pequeña lluvia de ideas sobre el programa de este año para no perder nada nuevo e importante.  La reunión está abierta, pero debe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">registrarse</a> . <br><br>  <strong>Llamada para papeles</strong> <br><br>  Aceptación activa de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitudes</a> de informes en Highload ++ 2018. El Comité del Programa está esperando su resumen hasta el final del verano. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417617/">https://habr.com/ru/post/es417617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417605/index.html">Conceptos básicos de modelado 3D para impresión 3D</a></li>
<li><a href="../es417607/index.html">Las pruebas A / B no funcionan. Comprueba lo que estás haciendo mal</a></li>
<li><a href="../es417609/index.html">Especialización en programación deportiva en el cursor</a></li>
<li><a href="../es417613/index.html">Ceph como almacenamiento conectable: 5 ideas prácticas de un gran proyecto</a></li>
<li><a href="../es417615/index.html">Confesiones de Disk Cracker para Apple II: 4am Secrets</a></li>
<li><a href="../es417619/index.html">Win32 / Glupteba ya no está asociado con la operación Windigo</a></li>
<li><a href="../es417621/index.html">¿Qué pasó cuando desciframos la exhibición?</a></li>
<li><a href="../es417627/index.html">Hyper CRM o Mini ERP? Negocio en mal estado</a></li>
<li><a href="../es417629/index.html">Edición comunitaria de Delphi y C ++ Builder</a></li>
<li><a href="../es417631/index.html">Tutorial de video CSS Grid</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>