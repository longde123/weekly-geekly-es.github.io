<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëãüèº üë®üèæ‚ÄçüöÄ üç¢ Gerenciando segredos com o HashiCorp Vault üë©üèº‚Äçüè´ üßùüèø üê∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como guardar segredos? No reposit√≥rio, no sistema de implanta√ß√£o ou no sistema de gerenciamento de configura√ß√£o? Em um computador pessoal, em servidor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gerenciando segredos com o HashiCorp Vault</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/438740/">  Como guardar segredos?  No reposit√≥rio, no sistema de implanta√ß√£o ou no sistema de gerenciamento de configura√ß√£o?  Em um computador pessoal, em servidores ou talvez em uma caixa debaixo da cama?  E como gerenciar segredos para evitar vazamentos? <br><br>  <strong>Sergey Noskov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Albibek</a> ) - o chefe do grupo de seguran√ßa da informa√ß√£o da plataforma da Avito</strong> , sabe a resposta para essas perguntas e compartilhar√° conosco.  No Avito, o HashiCorp Vault tem usado ativamente o HashiCorp Vault por dois anos, durante os quais obtiveram solavancos e aumentaram a experi√™ncia para o n√≠vel "Master". <br><br>  No artigo, falaremos de maneira abrangente sobre o Vault: o que √©, onde e como √© usado na empresa, como o Avito gerencia segredos usando o HashiCorp Vault, como o Puppet e o Kubernetes s√£o usados, casos de uso com o Puppet e outros SCM, que problemas surgem, o que prejudica a seguran√ßa desenvolvedores e, √© claro, compartilham id√©ias sobre como corrigi-lo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oDdDPU6moTs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><h2>  O que √© um segredo? </h2><br>  Qualquer informa√ß√£o confidencial: <br><br><ul><li>  login e senha, por exemplo, para o banco de dados; </li><li>  Chaves de API </li><li>  Chave de certificado do servidor (* .google.com) </li><li>  chave de certificado de cliente (parceiros, dinheiro Yandex, QIWI); </li><li>  chave para assinar aplicativos m√≥veis. </li></ul><br>  Todas as informa√ß√µes que queremos manter em segredo, chamamos de segredo.  Isso cria um problema de armazenamento: √© ruim armazenar no reposit√≥rio, na forma criptografada - voc√™ precisa manter as chaves de criptografia em algum lugar. <br><br>  <strong>O HashiCorp Vault</strong> √© uma das boas solu√ß√µes para o problema. <br><br><ul><li>  Armazena e gerencia chaves com seguran√ßa. </li><li>  Afiado no mundo dos microsservi√ßos, desde o pr√≥prio microsservi√ßo. </li><li>  <strong>O HashiCorp Vault</strong> fez muito para autenticar e autorizar o acesso a segredos, como ACLs e o princ√≠pio de privil√©gios m√≠nimos. </li><li>  Interface REST com JSON. </li><li>  A seguran√ßa n√£o √© perfeita, mas em um n√≠vel bastante alto. </li></ul><br>  Na minha opini√£o, esta √© uma ferramenta bastante conveniente. <br><br><h2>  Novidades no HashiCorp Vault <br></h2><br>  A ferramenta est√° em desenvolvimento e, nos √∫ltimos anos, muitos recursos interessantes apareceram nela: cabe√ßalhos CORS para GUI sem intermedi√°rios;  GUI embutida;  integra√ß√£o nativa com o Kubernetes;  plug-ins para backends e estrutura l√≥gicos e de autentica√ß√£o. <br><br>  A maioria das mudan√ßas que eu pessoalmente gostei √© a <strong>capacidade de n√£o escrever extens√µes e adi√ß√µes</strong> que ficar√£o fora da ferramenta. <br><br>  Por exemplo, existe o Vault, voc√™ deseja expandi-lo - escreva uma l√≥gica adicional ou sua pr√≥pria interface do usu√°rio para automa√ß√£o, o que automatizar√° algo.  Antes das altera√ß√µes, eu tive que criar um servi√ßo adicional que o Vault enfrenta e proxies todas as solicita√ß√µes: primeiro as solicita√ß√µes v√£o para o servi√ßo e depois para o Vault.  Isso √© ruim porque no servi√ßo intermedi√°rio pode haver um n√≠vel reduzido de seguran√ßa e todos os segredos passam por ele.  <strong>Os riscos de seguran√ßa s√£o muito maiores quando o segredo passa por v√°rios pontos ao mesmo tempo!</strong> <br><br><h2>  Problema de galinha e ovo <br></h2><br>  Quando voc√™ levanta a quest√£o do armazenamento de informa√ß√µes confidenciais e decide criptografar, assim que voc√™ criptografa algo, seu segredo muda do local de criptografia para o local onde a chave est√° armazenada.  Isso acontece o tempo todo: assim que voc√™ salva um segredo em algum lugar ou muda um existente, voc√™ tem outro e um c√≠rculo encantado come√ßa - <strong>onde guardar o segredo para ter acesso ao segredo</strong> . <br><br>  O segredo para acessar o segredo √© a parte da seguran√ßa chamada <strong>autentica√ß√£o</strong> .  A seguran√ßa tem outra parte - <strong>autoriza√ß√£o.</strong>  No processo de autoriza√ß√£o, √© verificado se o usu√°rio pode acessar exatamente onde est√° solicitando.  No caso do Vault, existe um terceiro confi√°vel que decide se deve revelar o segredo ou n√£o.  A autoriza√ß√£o resolve apenas parcialmente o problema. <br><br><h2>  HashiCorp Vault em Avito <br></h2><br>  No Avito, o HashiCorp √© instalado na √∫nica instala√ß√£o grande em toda a rede.  O HashiCorp Vault possui muitos recursos diferentes.  Usamos o back-end baseado no <strong>Consul</strong> tamb√©m da HashiCorp, porque o Vault pode suportar apenas sua pr√≥pria toler√¢ncia a falhas atrav√©s do Consul. <br><br>  <strong>A remo√ß√£o do lacre</strong> √© uma maneira de n√£o manter a chave mestra em um s√≥ lugar.  Quando o Vault √© iniciado, ele criptografa tudo em uma chave e, novamente, o problema do ovo e da galinha aparece: onde guardar um segredo, que criptografar√° todos os outros segredos.  Para evitar esse problema, o Vault fornece uma chave composta, que requer v√°rias partes da chave, que distribu√≠mos para v√°rios funcion√°rios.  No Avito, configuramos o Unseal nas op√ß√µes para 3 pessoas em 7. Se iniciarmos o Vault, pelo menos 3 pessoas dever√£o entrar e inserir sua parte da chave para que ele comece a funcionar.  A chave √© dividida em 7 partes e voc√™ pode trazer qualquer uma delas. <br><br>  Reunimos um pequeno Vault de teste, uma caixa de areia para desenvolvedores onde eles podem jogar.  √â na forma de um cont√™iner do Docker e cria segredos simples para que as pessoas possam tocar na ferramenta com as m√£os e se sentirem confort√°veis.  N√£o h√° Consul e clustering na sandbox, √© apenas um sistema de arquivos no qual o Vault cont√©m segredos criptografados e um pequeno script para inicializar. <br><br>  Aqui est√° o que agora armazenamos no Vault: <br><br><ul><li>  Quase todos os segredos dos microsservi√ßos do Kubernetes: senhas de bancos de dados, chaves de API, todas as op√ß√µes acima. </li><li>  Segredos para colocar nos servidores "de ferro" e no LXC. </li><li>  Tamb√©m colocamos segredos para compila√ß√µes de CI / CD no TeamCity no Vault.  A cobertura n√£o √© 100%, mas √© aceit√°vel. </li><li>  As chaves de todos os certificados: PKI interna, CAs externas, por exemplo, GeoTrust e similares. </li><li>  Segredos comuns para as equipes. </li></ul><br>  Por dentro, o Vault armazena tudo apenas em JSON, nem sempre √© conveniente e requer a√ß√µes adicionais do desenvolvedor, portanto, basicamente, publicamos segredos na forma de um arquivo. <br><br><blockquote>  Tentamos entregar segredos na forma de arquivos. <br></blockquote><br>  N√£o dizemos ao desenvolvedor: "V√° para o Vault, pegue um segredo!", Mas coloque o arquivo no disco e diga: "Desenvolvedor, um arquivo aparecer√° no seu disco, tire o segredo dele e j√° descobriremos como obt√™-lo do Vault e traz√™-lo para voc√™. " <br><img src="https://habrastorage.org/webt/rg/9o/mj/rg9omjizdszcnw0lzrr_iogfosc.png"><br><br>  Adotamos um contrato simples para os campos JSON, nos quais indicamos com quais direitos o upload do arquivo.  Esses s√£o metadados para o sistema de arquivos, e o campo de dados √© uma sequ√™ncia codificada com o pr√≥prio segredo, que se tornar√° o conte√∫do do arquivo. <br><br><h2>  Fantoche + Hiera + Cofre <br></h2><br>  Quase toda a infraestrutura Avito usa Puppet, lan√ßa todos os servidores. <br><br>  O Puppet tem uma ferramenta conveniente para organizar hierarquias - <strong>Hiera</strong> .  O Vault se integra muito bem ao Hiera por meio de um m√≥dulo complementar, porque uma solicita√ß√£o de valor-chave √© enviada para esta biblioteca e o pr√≥prio Vault √© um banco de dados de valores-chave, mas com todos os recursos de seguran√ßa - com criptografia transparente e a capacidade de escolher o acesso √†s chaves. <br><br>  Portanto, a primeira coisa que implementamos √© o Vault in Puppet, mas com uma adi√ß√£o - temos uma camada intermedi√°ria chamada de <strong>roteador back-end</strong> .  Back-end do roteador - um m√≥dulo Hiera separado, apenas arquivos no disco que indicam onde Hiera deve buscar a chave - no Vault ou em outro local. <br><br>  Ele √© necess√°rio para que Hiera n√£o v√° ao Vault constantemente, porque ela sempre percorre toda a hierarquia.  Este n√£o √© um problema do Vault ou carrega nele, mas um recurso do pr√≥prio Hiera.  Portanto, se voc√™ deixar apenas o m√≥dulo para o Vault sem o back-end do roteador, o mestre do Puppet levar√° muito tempo para coletar a configura√ß√£o do agente Puppet, pois verificar√° cada chave no Vault. <br><img src="https://habrastorage.org/webt/dv/di/f6/dvdif6z09jpflg98zykbwf7l7cq.png"><br><br>  Para o Puppet, o problema da galinha e dos ovos √© resolvido devido ao fato de a parte autorizadora ser o mestre do Puppet.  √â ele quem d√° o segredo para acessar o segredo.  O mestre de marionetes tem acesso a todos os segredos de uma s√≥ vez, mas cada host pode receber apenas o que se destina a ele.  O host no mestre do Puppet j√° est√° autorizado por seu certificado, que √© gerado localmente e n√£o deixa os limites do host.  Em princ√≠pio, o segredo para acessar o segredo permanece, mas isso n√£o √© t√£o cr√≠tico. <br><br>  Nosso processo de revelar um novo segredo no Puppet consiste nas seguintes etapas. <br><br><ul><li>  N√≥s levamos um segredo para algum lugar - algu√©m nos d√° ou o divulga. </li><li>  Colocando um segredo no Vault, com uma hierarquia como em Hiera: <strong>/puppet/role/www/site.ssl.key</strong> . </li><li>  Registramos um prefixo no manifesto Puppet, indicando que o arquivo est√° no Vault e onde obt√™-lo. </li><li>  Escrevemos o caminho no Vault no YAML para o roteador Hiera e o back-end para que Hiera possa encontr√°-lo. </li><li>  Puxe a solicita√ß√£o via GIT para o reposit√≥rio de manifesto. </li><li>  Execute ou aguarde a execu√ß√£o do agente Puppet. </li></ul><br>  Agentes de marionetes fogem conosco a cada 30 minutos, ent√£o voc√™ deve esperar um pouco at√© que o segredo seja revelado.  Isso n√£o causa problemas - <strong>n√£o compartilhamos segredos todos os dias</strong> .  Desde que a Kubernetes n√£o esteja envolvida nos neg√≥cios, n√£o h√° muita sobrecarga e estamos prontos para colocar segredos no Vault com nossas m√£os com automa√ß√£o m√≠nima. <br><br>  Al√©m disso, obtemos o "chip" Hiera - o <strong>segredo pode ser divulgado imediatamente para um grupo de hosts</strong> ou dependendo do papel do host, definido na fun√ß√£o vari√°vel. <br><br>  O √∫nico <strong>perigo</strong> : se voc√™ tem o Puppet e usa o Hiera, n√£o substitua nada por modelos de vari√°veis, porque muitos fatos e vari√°veis ‚Äã‚Äãs√£o coletados no lado do cliente.  Se um atacante substituir um fato no cliente, o mestre dos Marionetes lhe dar√° os segredos de outras pessoas.  <strong>Certifique-se de verificar as vari√°veis</strong> : use apenas aquelas que o Puppet-master n√£o permite determinar no lado do cliente. <br><br><h2>  O que fazer com o SCM sem um assistente? <br></h2><br>  Se de repente voc√™ n√£o tem Marionete, provavelmente Ansible.  Para Chef e outros SCMs centralizados, suas solu√ß√µes s√£o um plug-in que pode acessar o Vault.  Eu ofere√ßo v√°rias op√ß√µes que podem ser implementadas com o Ansible. <br><br><h3>  Agente local <br></h3><br>  Localmente para o servidor, gere um token, que √© realmente a senha para acessar o Vault.  O token √© v√°lido o tempo todo.  Voc√™ pode atualiz√°-lo ou automatiz√°-lo.  Com esse token, voc√™ vai ao Vault e tira seus segredos. <br><br>  A ideia √© que, no servidor em que voc√™ precisa entregar segredos, o agente que vem ao Vault esteja girando, analise todos os segredos e os coloque na forma de arquivos.  Usamos o agente em v√°rios servidores separados onde n√£o h√° Puppet. <br><br>  <strong>Contras:</strong> <br><br><ul><li>  √â f√°cil inserir o token em um segmento pequeno, mas se voc√™ tiver v√°rias dezenas de servidores implantados por dia, precisar√° gerar um token para cada servidor e prescrever uma pol√≠tica.  Isso √© inconveniente. </li><li>  O token precisa ser atualizado. </li><li>  O agrupamento de servidores por fun√ß√£o, objetivo ou fato √© dif√≠cil, ele deve ser sincronizado com o Vault. </li></ul><br><h3>  Criptografia de tr√¢nsito <br></h3><br>  O Vault possui uma fun√ß√£o de criptografia de tr√¢nsito, cuja ess√™ncia √© que o Vault atua como um <strong>servidor de criptografia</strong> .  Voc√™ apenas traz a ele texto simples, e ele, em sua chave privada, que somente ele possui, criptografa e emite o texto fechado.  Ent√£o voc√™ escolhe quem pode descriptografar este texto fechado. <br><br>  Ansible tem uma entidade, tamb√©m chamada Vault.  Este n√£o √© um cofre HashiCorp, mas <strong>um cofre Ansible</strong> .  N√£o h√° necessidade de confundir, e os segredos podem ser armazenados no primeiro e no segundo.  O Ansible possui um plugin pronto para fornecer segredos do Hashicorp Vault.  Se voc√™ der acesso pessoal ao Vault, poder√° descriptografar segredos.  Quando voc√™ lan√ßa o Ansible, ele acessa o Vault em seu nome, descriptografa os segredos que s√£o criptografados no reposit√≥rio e os lan√ßa em produ√ß√£o. <br><br>  H√° tamb√©m uma desvantagem - <strong>cada administrador obt√©m acesso a segredos</strong> .  Mas h√° uma auditoria: o Vault sabe como manter um log de atividades sobre qual usu√°rio entrou, qual segredo leu, qual teve acesso.  Voc√™ sempre sabe quem, quando e o que fez com um segredo.  Esta op√ß√£o parece boa para mim. <br><br><h3>  Grande falha # 1 <br></h3><br>  A maior desvantagem que causa a maior dor em n√≥s √© que no Vault voc√™ n√£o pode delegar o controle total de nenhuma <strong>parte dos</strong> <strong>dados a</strong> ningu√©m.  No Vault, o acesso ao segredo √© realizado de maneira semelhante √† do UNIX - os nomes geralmente s√£o separados por barras, e o resultado √© um "diret√≥rio".  Quando voc√™ tem esse caminho, √†s vezes deseja participar do caminho e entreg√°-lo a outra pessoa para controle. <br><img src="https://habrastorage.org/webt/w-/hq/gf/w-hqgfwmxgok3_dimlgnn8baxag.png"><br><br>  Por exemplo, voc√™ possui certificados chamados <strong>/ certs</strong> e deseja entreg√°-los a agentes de seguran√ßa individuais que lidam com a PKI.  O Vault n√£o pode fazer isso.  Voc√™ n√£o pode dar o direito de emitir direitos dentro desse prefixo - para que os pr√≥prios seguran√ßas possam distribuir os direitos dos certificados para outra pessoa. <br><br>  <strong>O Vault n√£o tem a capacidade de conceder seletivamente direitos para conceder direitos</strong> .  Assim que voc√™ concedeu o direito de conceder direitos, tamb√©m teve a oportunidade de obter acesso total a todos os segredos.  Em outras palavras, voc√™ n√£o pode dar acesso √† parte do Vault. <br><br>  Este √© um dos maiores problemas.  Eu tenho uma id√©ia de como resolv√™-lo, falarei sobre isso mais tarde. <br><br><h2>  Kubernetes <br></h2><br>  No RIT ++, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">falei</a> sobre um sistema separado que implementamos para o <strong>Kubernetes</strong> : ele serve como terceiro, acessa a API, verifica o acesso e solicita um segredo no Vault. <br><br>  Agora, nosso sistema perdeu relev√¢ncia, porque no Vault 0.9, o suporte nativo ao Kubernetes apareceu.  Agora, o pr√≥prio Vault sabe como acessar o Kubernetes e garantir que o acesso ao segredo seja permitido.  Ele faz isso com um <strong>token de conta de servi√ßo</strong> .  Por exemplo, quando voc√™ tem um pod implementado, h√° um <strong>JWT</strong> especial, assinado e autorizado para ele, projetado para solicita√ß√µes √† API do Kubernetes.  Com um token, voc√™ tamb√©m pode fazer login no Vault e obter segredos especificamente para o seu espa√ßo para nome. <br><br>  Tudo √© feito no n√≠vel do Vault.  √â verdade que ser√° necess√°rio iniciar uma fun√ß√£o para cada espa√ßo para nome, ou seja, informar ao Vault que existe um espa√ßo para nome, haver√° autoriza√ß√£o nele e registrar para onde ir no Kubernetes.  Isso √© feito uma vez e, em seguida, o Vault acessa a API, confirma a validade do JWT e emite seu pr√≥prio token de acesso. <br><br><h3>  Regras do Kubernetes <br></h3><br>  Em termos de nome do servi√ßo e metadados adicionais, confiamos nos desenvolvedores.  H√° uma pequena chance de que os desenvolvedores acidentalmente ou intencionalmente obtenham os segredos de outros servi√ßos que giram em um espa√ßo para nome, por isso introduzimos uma regra: <strong>um servi√ßo</strong> - <strong>um espa√ßo para nome.</strong> <br><br>  Novo microsservi√ßo?  Obtenha um novo espa√ßo para nome com seus segredos.  Voc√™ n√£o pode atravessar a fronteira para a vizinha - eles t√™m seu pr√≥prio token de conta de servi√ßo.  <strong>A fronteira de seguran√ßa no Kubernetes no momento √© o espa√ßo para nome.</strong>  Se em dois namespace diferentes, voc√™ precisar de um segredo - copie-o. <br><br>  Kubernetes tem <strong>segredos kubernetes</strong> .  Eles s√£o armazenados no etcd no Kubernetes de forma n√£o criptografada e podem "acender" no painel ou quando o kubectl get pods √© iniciado.  Se a autentica√ß√£o no etcd estiver desabilitada no seu cluster ou se voc√™ tiver concedido acesso completo somente leitura a algu√©m, todos os segredos estar√£o vis√≠veis para ele.  Por isso, introduzimos duas regras: √© <strong>proibido usar segredos do kubernetes</strong> e √© <strong>proibido especificar segredos em vari√°veis ‚Äã‚Äãde ambiente em manifestos</strong> .  Se voc√™ escreve um segredo no ambiente em deployment.yaml, isso √© ruim, porque o manifesto em si pode ser visto por qualquer pessoa que n√£o seja pregui√ßosa. <br><br><h3>  Kubernetes Delivery <br></h3><br>  Como eu disse, devemos de alguma forma colocar o arquivo no Kubernetes.  Temos algum tipo de segredo: a ess√™ncia, a senha, escrita em JSON no Vault.  Como transform√°-lo em um arquivo dentro do cont√™iner no Kubernetes agora? <br><img src="https://habrastorage.org/webt/gm/ki/wb/gmkiwblvlm7ca4hiwmvhhx14wxu.png"><br><br>  A primeira op√ß√£o de entrega. <br><br><ul><li>  Iniciamos um init-container especial. </li><li>  Come√ßa a partir da nossa imagem. </li><li>  A imagem cont√©m um pequeno utilit√°rio que vai para o Vault com o Token de conta de servi√ßo, pega o segredo e o coloca no volume compartilhado. </li><li>  Para o utilit√°rio, um volume compartilhado especial √© montado apenas na mem√≥ria TMPFS, para que os segredos n√£o passem pelo disco. </li><li>  O cont√™iner Init vai para o Vault, coloca neste volume na forma de arquivos todos os segredos que encontra no caminho especificado. </li><li>  Em seguida, o volume compartilhado √© montado no cont√™iner principal no qual √© necess√°rio. </li><li>  Quando o cont√™iner principal √© iniciado, ele obt√©m imediatamente o que o desenvolvedor precisa - segredos na forma de um arquivo em disco. </li></ul><br>  O desenvolvedor s√≥ precisa se lembrar do caminho em que reside seu segredo. <br><br>  Usamos algo como este prefixo: <br><br><pre><code class="plaintext hljs">/k8s/&lt;cluster&gt;/&lt;namespace&gt;/&lt;service&gt;/some_secret</code> </pre> <br>  O nome do prefixo cont√©m o nome do cluster, o espa√ßo para nome e o nome do servi√ßo.  Cada servi√ßo tem seu pr√≥prio segredo, cada espa√ßo para nome tem seu pr√≥prio segredo. <br><br>  A segunda op√ß√£o √© o seu <strong>pr√≥prio ponto de entrada</strong> .  Agora estamos migrando para ele no Avito, porque os desenvolvedores t√™m problemas com o init-container.  No diagrama, esta op√ß√£o est√° √† direita. <br><br>  Nem todo mundo pode pagar seu pr√≥prio ponto de entrada.  Podemos, portanto, em cada cont√™iner, for√ßamos nosso ponto de entrada especial. <br><br>  Nosso ponto de entrada faz o mesmo que o init-container: ele acessa o Vault com um token de conta de servi√ßo, pega segredos e os exp√µe.  Al√©m dos arquivos, ele os coloca de volta no ambiente.  Voc√™ tem a oportunidade de executar o aplicativo conforme recomendado pelo conceito de <strong>aplicativo de doze fatores</strong> : o aplicativo obt√©m todas as configura√ß√µes, incluindo segredos, das vari√°veis ‚Äã‚Äãde ambiente. <br><br>  As vari√°veis ‚Äã‚Äãde ambiente n√£o s√£o vis√≠veis no manifesto e no painel, pois s√£o definidas pelo PID 1 (o processo principal do cont√™iner) na inicializa√ß√£o.  Essas n√£o s√£o vari√°veis ‚Äã‚Äãde ambiente de deployment.yaml, mas vari√°veis ‚Äã‚Äãde ambiente definidas pelo ponto de entrada no processo.  Eles n√£o s√£o vis√≠veis no painel, eles n√£o s√£o vis√≠veis, mesmo se voc√™ fizer o kubectl exec em um cont√™iner, porque nesse caso outro processo √© iniciado, paralelo ao PID1. <br><br><h3>  Workflow <br></h3><br>  Do ponto de vista organizacional, o processo √© o seguinte.  O desenvolvedor aprende com o campe√£o de seguran√ßa ou com a documenta√ß√£o que ele n√£o deve guardar segredos no reposit√≥rio, mas apenas no Vault.  Ent√£o ele vem at√© n√≥s e pergunta onde colocar segredos - ele envia um aplicativo √† seguran√ßa para estabelecer um prefixo.  No futuro, voc√™ pode criar um prefixo sem uma solicita√ß√£o, imediatamente ao criar um servi√ßo. <br><br>  O desenvolvedor est√° esperando, e isso √© ruim, porque  o principal para ele √© o tempo de coloca√ß√£o no mercado.  Ent√£o ele l√™ as instru√ß√µes, lida com arquivos longos - ‚Äúinsira essa linha ali, insira esta linha aqui‚Äù.  Um desenvolvedor nunca iniciou um cont√™iner init antes, mas √© for√ßado a descobrir e registr√°-lo em deployment.yaml (helm chart). <br><br> <code>Commit -&gt; deploy -&gt; feel pain -&gt; fix -&gt; repeat</code> <br> <br>  Ele confirma, aguarda o lan√ßamento do TeamCity, v√™ erros no TeamCity, come√ßa a sentir dor, tenta consertar algo, sente dor novamente.  Al√©m disso, √© sobreposto que cada lan√ßamento no TeamCity ainda pode ser colocado na fila.  √Äs vezes, um desenvolvedor n√£o consegue descobrir por si mesmo, chega at√© n√≥s e resolvemos isso juntos. <br><br>  Basicamente, o desenvolvedor sofre devido a seus pr√≥prios erros: <strong>init-container especificado incorretamente ou n√£o leu a documenta√ß√£o</strong> . <br><br>  A seguran√ßa tamb√©m tem problemas.  O guarda de seguran√ßa recebe um aplicativo no qual h√° sempre pouca informa√ß√£o e ainda descobrimos as perguntas que faltam: descubra os nomes dos clusters, o espa√ßo para nome do servi√ßo, pois o desenvolvedor n√£o os indica no aplicativo e nem sempre sabe o que √©.  Quando descobrimos tudo, criamos pol√≠ticas e fun√ß√µes no Vault, prescrevemos pol√≠ticas para grupos e, juntamente com o desenvolvedor, come√ßamos a descobrir onde e por que ele cometeu um erro, e juntos lemos os logs. <br><br>  A unidade "Arquitetura" ajuda a resolver o problema ocultando o desenvolvedor deployment.yaml.  Eles est√£o desenvolvendo uma pe√ßa que gera tudo para o desenvolvedor, incluindo o ponto de entrada.  Devido ao fato de substituirmos nosso ponto de entrada, podemos us√°-lo n√£o apenas para fornecer segredos, mas tamb√©m para outras coisas que voc√™ pode precisar fazer na inicializa√ß√£o. <br><br><h3>  Problemas √≥bvios com os segredos do Kubernetes. <br></h3><br><ul><li>  <strong>Fluxo</strong> de <strong>trabalho muito complicado</strong> para o desenvolvedor e o guarda de seguran√ßa. </li><li>  <strong>Voc√™ n√£o pode delegar nada a ningu√©m.</strong>  O guarda de seguran√ßa tem acesso total ao Vault, e o acesso parcial n√£o √© poss√≠vel (consulte Grande falha 1). </li><li>  Dificuldades surgem ao mover desenvolvedores de cluster para cluster, de namespace para namespace, quando segredos compartilhados s√£o necess√°rios, porque √© assumido inicialmente que segredos diferentes s√£o diferentes em diferentes clusters. </li></ul><br>  Dizemos: ‚ÄúPor que voc√™ precisa de segredos de produ√ß√£o no cluster de desenvolvimento?  Consiga um segredo de teste, v√° em frente!  Como resultado, existem <strong>minas</strong> <strong>e segredos</strong> que s√£o dif√≠ceis de gerenciar.  Se o segredo mudou, voc√™ n√£o deve esquec√™-lo, alter√°-lo em todos os lugares e, embora n√£o haja maneira de determinar se √© o mesmo segredo, exceto pelo nome do servi√ßo. <br><br><h3>  Id√©ia: Kubernetes KMS <br></h3><br>  Nas novas vers√µes do Kubernetes, o subsistema KMS, Servi√ßo de Gerenciamento de Chaves, √© um novo recurso de criptografia secreta do Kubernetes.  Na v1.11, ele estava no estado alfa, na v1.12, foi transferido para o beta. <br><img src="https://habrastorage.org/webt/yq/nw/i9/yqnwi9a_t6atxpxdu_qrtu0qz80.png"><br>  <em>A imagem √© do site do projeto do provedor KMS do Vault e h√° um erro.</em>  <em>Se voc√™ encontrar - escreva nos coment√°rios.</em> <br><br>  O significado do KMS √© eliminar uma √∫nica desvantagem - armazenamento de dados n√£o criptografados no etcd. <br><br>  O KMS, como o Ansible, pode fazer isso. <br><br><ul><li>  V√° a algum lugar, criptografe o segredo nativo do Kubernetes e coloque-o na forma criptografada. </li><li>  Se necess√°rio, entregue no pod, descriptografar e colocar na forma descriptografada. </li></ul><br>  Os desenvolvedores criaram um servi√ßo especial que faz isso usando criptografia de tr√¢nsito.  A ideia parece estar funcionando, mas √© importante lembrar que os segredos deixam de estar apenas sob o controle do Vault e v√£o para outro lugar, na √°rea de responsabilidade dos administradores do Kubernetes. <br><br>  Contras KMS. <br><br><ul><li>  <strong>Descentraliza√ß√£o de armazenamento</strong> - <strong>Transfer√™ncia do Vault para o Kubernetes (etcd)</strong> .  Segredos tornam-se incontrol√°veis ‚Äã‚Äãpelo Vault, e √© bom como um reposit√≥rio centralizado de segredos.  Acontece que metade dos segredos no Vault e metade em outro lugar. </li><li>  <strong>Solu√ß√£o apenas para Kubernetes</strong> .  Se voc√™ possui uma infraestrutura exclusiva do Kubernetes, escolhe o Vault e quase n√£o pensa no que est√° armazenado l√°, porque  cont√©m apenas as chaves de criptografia que voc√™ gerencia corretamente - gire regularmente, etc. ... Os segredos est√£o no Kubernetes, e isso √© conveniente. </li><li>  <strong>√â dif√≠cil compartilhar segredos entre clusters</strong> .  Para cada novo cluster, √© necess√°rio iniciar tudo de novo, a c√≥pia de segredos, como no caso de um √∫nico Vault, pode n√£o funcionar. </li></ul><br>  Profissionais do KMS. <br><br><ul><li>  <strong>Suporte nativo</strong> no Kubernetes, incluindo ocultar ao mostrar o ambiente. </li><li>  <strong>Autoriza√ß√£o na √°rea de responsabilidade de Kubernetes</strong> . </li><li>  <strong>Praticamente n√£o √© necess√°rio suporte ao Vault</strong> . </li><li>  <strong>Rota√ß√£o da chave fora da caixa</strong> . </li></ul><br><h2>  CI / CD: TeamCity <br></h2><br>  Tudo √© simples no TeamCity, porque o JetBrains escreveu um plug-in que pode prescrever segredos para acessar o segredo, criptograf√°-los com o TeamCity e substitu√≠-lo em porcentagem no modelo em algum lugar do modelo.  Nesse momento, o pr√≥prio agente do TeamCity vai para o Vault, pega o segredo e o traz para a compila√ß√£o como par√¢metro. <br><br>  Alguns segredos s√£o necess√°rios durante a implanta√ß√£o, por exemplo, migra√ß√£o de banco de dados ou alertas no Slack.  O AppRole √© iniciado para cada projeto - as configura√ß√µes tamb√©m cont√™m um segredo (dados para AppRole), mas s√£o inseridos no modo somente grava√ß√£o - o TeamCity n√£o permite a leitura mais tarde. <br><br>  O pr√≥prio TeamCity cuida para que, quando um segredo entre nos logs de constru√ß√£o, ele se disfarce automaticamente.  Como resultado, o segredo n√£o ‚Äúpassa‚Äù pelo disco ou √© limpo do disco usando as ferramentas do TeamCity.  Como resultado, toda a seguran√ßa do segredo √© bem assegurada pelo pr√≥prio TeamCity e pelo plug-in, e dan√ßas adicionais com um pandeiro n√£o s√£o necess√°rias <br><br><h3>  CI / CD n√£o √© TeamCity? <br></h3><br>  Esses s√£o os principais problemas a serem considerados se voc√™ estiver usando um sistema diferente (n√£o o TeamCity) como o IC. <br><br><ul><li>  Isolamento: limite o escopo de um segredo a um projeto, equipe etc. </li><li>  Quem autoriza o acesso ao segredo. </li><li>  Exclua a capacidade de visualizar o segredo da parte autorizadora. </li><li>  Um est√°gio separado da compila√ß√£o √© importar o segredo para os arquivos. </li><li>  Limpe depois de si mesmo. </li></ul><br>  Como resultado, provavelmente voc√™ escrever√° algo muito semelhante ao plug-in TeamCity para o seu CI / CD.  A parte autorizadora aqui provavelmente ser√° o CI / CD, e ser√° ela quem decidir√° se essa compila√ß√£o pode ter acesso a esse segredo e se deve ou n√£o fornecer o pr√≥prio segredo com base nos resultados. <br><br>  √â importante n√£o esquecer de <strong>limpar os resultados da compila√ß√£o no final da montagem</strong> , se eles foram dispostos em um disco, ou garantir que eles estejam apenas na mem√≥ria. <br><br><h2>  Certifica√ß√µes <br></h2><br>  N√£o h√° nada de especial nos certificados - usamos o Vault principalmente para armazenamento. <br><img src="https://habrastorage.org/webt/ix/ye/4j/ixye4jru2blznsbq2jxmljomqi8.png"><br><br>  O Vault possui um back-end PKI especial para emiss√£o de certificados, no qual voc√™ pode criar uma Autoridade de Certifica√ß√£o e assinar novos certificados.  Temos uma √∫nica PKI interna ... A CA raiz e a CA de segundo n√≠vel existem separadamente e j√° gerenciamos a CA de terceiro n√≠vel atrav√©s do Vault.  Para armazenar certificados emitidos de qualquer n√≠vel, incluindo certificados assinados por CAs externas, usamos um prefixo separado e colocamos quase todos os certificados v√°lidos para fins de contabilidade e monitoramento.  O formato para armazenar certificados √© propriet√°rio, adequado para armazenar uma chave privada separada e o pr√≥prio certificado. <br><br><h2>  Sum√°rio <br></h2><br>  <strong>Muito trabalho manual</strong> para o guarda de seguran√ßa, <strong>muito limiar de entrada para o desenvolvedor</strong> e nenhuma ferramenta de delega√ß√£o integrada, embora eu realmente queira ... <br><br>  Como ser  Ent√£o os sonhos come√ßam. <br><br><h2>  Ideias: como fazer melhor <br></h2><br>  Como posso me livrar de v√°rias c√≥pias de um segredo? <br><br><h3>  Mestre-escravo de entrega <br></h3><br>  Temos um segredo mestre e um daemon especial que anda por a√≠, olha o segredo e seus metadados, coloca-o onde necess√°rio, acaba sendo um segredo escravo.  No caminho em que o daemon postou o escravo, nada pode ser alterado manualmente, porque o daemon vir√° e recolocar√° o segredo mestre em cima do escravo. <br><br>  Inicialmente, quer√≠amos criar um mecanismo de link simb√≥lico para simplesmente indicar: ‚ÄúProcure esse segredo l√°!‚Äù, Como no Linux.  Verificou-se que existem problemas com os direitos de acesso: n√£o se sabe como verificar os direitos de acesso - como no Linux ou n√£o, com caminhos pai, com transi√ß√µes entre pontos de montagem.  Existem muitos momentos amb√≠guos e chances de cometer um erro, ent√£o recusamos os links simb√≥licos. <br><br><h3>  Autoriza√ß√£o de Propriedade <br></h3><br>  A segunda coisa que queremos fazer √© <strong>determinar o propriet√°rio de cada segredo</strong> .  Por padr√£o, o segredo pertence √† pessoa que o criou.  Se necess√°rio, voc√™ pode expandir a √°rea de responsabilidade para a unidade emitindo um grupo de propriet√°rios. <br><br>  Quando aprendermos a delegar, daremos ao propriet√°rio o direito a um segredo, e ele poder√° fazer com o segredo o que ele deseja. <br><br><ul><li>  Espalhe no k8s - uma pol√≠tica √© gerada, uma c√≥pia escrava √© criada. </li><li>  Espalhe no servidor - uma pol√≠tica √© gerada, uma c√≥pia escrava √© criada. </li><li>  Espalhe em CI / CD - ... </li><li>  Transferir para outro propriet√°rio. </li><li>  D√™ novo acesso, gere novas ACLs. </li></ul><br>  Agora somos respons√°veis ‚Äã‚Äãpor todos os segredos e seguran√ßa, mas queremos passar a responsabilidade para o criador.  <strong>A seguran√ßa n√£o ser√° afetada</strong> , porque a pessoa que veio at√© n√≥s com uma solicita√ß√£o para manter um segredo entende que precisa manter um segredo com seguran√ßa e est√° ciente de sua responsabilidade. <br><br>  Como ele √© o propriet√°rio do segredo, para a op√ß√£o de entrega mestre-escravo, ele pode escolher onde e em que formato o segredo deve ser entregue a ele.  Acontece que o propriet√°rio gerencia tudo sozinho, n√£o h√° necessidade de enviar solicita√ß√µes, voc√™ pode usar o prefixo necess√°rio, tamb√©m pode criar e excluir segredos. <br><br><h3>  Delega√ß√£o por meio de modelos da ACL <br></h3><br>  A pol√≠tica de acesso √† Lista de controle de acesso no Vault √© dividida em duas partes: <br><br><ul><li>  Lista de controle de acesso na exibi√ß√£o cl√°ssica, que descreve o acesso ao prefixo, qual o caminho para ler e escrever, qual apenas para ler etc. </li><li>  Ao criar uma ACL interna, voc√™ pode escrever um asterisco no final, o que significa "esse prefixo e tudo abaixo dele".  O prefixo pode ser designado como uma opera√ß√£o separada, fornecida ao usu√°rio ou grupo, ou seja, anexada a v√°rias entidades diferentes. </li></ul><br>  No momento, apenas o administrador do Vault pode alterar a ACL.  Tendo obtido acesso a essa ACL, voc√™ pode prescrever tudo o que deseja dentro, por exemplo, o <code>path ‚Äú*‚Äù { capabilities = [sudo, ...] }</code> e obter acesso total.  Essa √© a ess√™ncia da <strong>maior falha</strong> n¬∫ 1 - <strong>√© imposs√≠vel proibir a altera√ß√£o do</strong> <strong>conte√∫do da ACL.</strong> <br><br>  Queremos definir as ACLs com um modelo pronto que cont√©m o caminho e os espa√ßos reservados nos quais √© permitido gerar novas ACLs para esse modelo. <br><br><h4>  Exemplo <br></h4><br>  Abaixo est√° a fonte amarela, o caminho da ACL padr√£o finalizada do Vault e ainda mais as a√ß√µes permitidas nesse caminho.  Consideramos como uma ACL a permiss√£o para alterar outra ACL abaixo, que √© fornecida na forma de um modelo. <br><img src="https://habrastorage.org/webt/ew/xe/jc/ewxejc20z7xa7dqg-o8yxwaesxk.png"><br><br>  Queremos delegar acesso a / k8s, permitimos que apenas esses modelos sejam gerados.  Por exemplo, conceda acesso somente leitura a um cluster, espa√ßo para nome, servi√ßo espec√≠fico, mas n√£o altere o campo de recursos. <br><img src="https://habrastorage.org/webt/ew/xe/jc/ewxejc20z7xa7dqg-o8yxwaesxk.png"><br><br>  Al√©m disso, queremos dar permiss√£o para vincular essas ACLs e emitir direitos diferentes. <br><br>  Aplicamos o modelo para conceder direitos ao desenvolvedor.  Ao modelar, ele executou o <code>$ vault write policy-mgr/create/k8s-microservice ...</code>  E, como resultado, obtivemos uma ACL que indica cluster = prod, namespace = ..., service = ... etc.  Os direitos foram definidos automaticamente, uma pol√≠tica foi criada com o nome <code>/k8s/some-srv</code> - este √© apenas o nome da ACL que pode ser gerado a partir do modelo. <br><img src="https://habrastorage.org/webt/ro/ih/ur/roihurfk7gxhvrv-hjpik6lctxc.png"><br><br>  Como resultado, o desenvolvedor, a nosso crit√©rio, atribui essa ACL a quem quiser, e se torna o pr√≥prio propriet√°rio, pode gerenci√°-la como um segredo: excluir, dar e receber usu√°rios e grupos.  Agora, a pr√≥pria pessoa √© respons√°vel por seu prefixo: ele gerencia todos os segredos, gera ACLs de acordo com o modelo, pode atribuir ACLs √†queles que deseja.  Naturalmente, tamb√©m podemos limitar. <br><br>  Toda m√°gica funciona com a nova entidade do Vault - <strong>plugins</strong> .  Eles s√£o um servi√ßo separado, muito parecido com o que mencionei no in√≠cio, e funcionam quase exatamente da mesma forma.  A √∫nica diferen√ßa importante √© que eles n√£o s√£o proxies.  Os plug-ins s√£o lan√ßados "ao lado" do Vault e iniciam o processo principal do Vault.  Por esse motivo, todas as solicita√ß√µes n√£o passam pelo servi√ßo, mas pelo Vault, que j√° interage com o plug-in, enviando uma solicita√ß√£o verificada e limpa. <br><br>  Sobre plugins, como eles s√£o organizados e como escrev√™-los, voc√™ pode ler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no site do Vault</a> .  √â melhor escrev√™-los no Go, o que √© bastante simples, porque  Existe uma estrutura para o Go.  O Vault se comunica com o plug-in via grpc, lan√ßa-o como um servi√ßo, mas n√£o se assuste, voc√™ n√£o o toca - tudo j√° est√° no quadro.  Voc√™ acabou de escrever um aplicativo REST mais ou menos padr√£o no qual especifica pontos de extremidade, fornece fun√ß√µes prontas, manipuladores que ter√£o l√≥gica neles. <br><br>  N√£o tenha medo de quebrar algo no Vault principal.  Um plug-in √© um servi√ßo separado.  Mesmo que seu plug-in entre em p√¢nico e falhe, ele n√£o interromper√° o trabalho do Vault.  O Vault simplesmente reiniciar√° o plug-in e continuar√° a funcionar. <br><br>  Al√©m disso, existem configura√ß√µes adicionais para o pr√≥prio plugin: ele sempre verifica as somas de hash para que ningu√©m mude o bin√°rio.  <strong>A seguran√ßa dos plugins em execu√ß√£o √© fornecida</strong> . <br><br><h2>  Links √∫teis: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.vaultproject.io</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/jovandeginste/hiera-router</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/jsok/hiera-vault</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.owasp.org/index.php/Security_Champions</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blog.jetbrains.com/teamcity/2017/09/vault</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/oracle/kubernetes-vault-kms-plugin</a> </li></ul><br><blockquote>  Falaremos sobre DevOps e seguran√ßa, CI / CD, k8s, Puppet e tudo isso no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HighLoad ++</a> (o mais pr√≥ximo de S√£o Petersburgo em abril) e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DevOpsConf</a> .  Venha compartilhar sua experi√™ncia ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">olhar</a> para os outros.  Para n√£o esquecer, assine o blog e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">boletim informativo</a> , no qual iremos lembr√°-lo dos prazos e coletar materiais √∫teis. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438740/">https://habr.com/ru/post/pt438740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438726/index.html">Y Combinator: Como fechar uma empresa</a></li>
<li><a href="../pt438730/index.html">HomoLudens: parab√©ns, Sid Meyer (+ todos os artigos em russo)</a></li>
<li><a href="../pt438732/index.html">Medi√ß√µes de r√°dio amador: An√°lise de sinal de barramento I2C</a></li>
<li><a href="../pt438734/index.html">Emaranhado de pessoas afins</a></li>
<li><a href="../pt438736/index.html">DevDay for Managers: gerenciar TI</a></li>
<li><a href="../pt438746/index.html">No caminho para os princ√≠pios f√≠sicos da evolu√ß√£o biol√≥gica. Continua√ß√£o</a></li>
<li><a href="../pt438748/index.html">Infraestrutura como c√≥digo, ganhamos em escala (Kirill Vetchinkin, TYME)</a></li>
<li><a href="../pt438752/index.html">Contabilidade diretamente no banco: como fazer felizes os empreendedores individuais</a></li>
<li><a href="../pt438754/index.html">Como fizemos o monitoramento de rede para 14.000 objetos</a></li>
<li><a href="../pt438756/index.html">Sexta verifica√ß√£o de cromo, posf√°cio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>