<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèòÔ∏è üé≥ üôãüèø Usando promesas en JavaScript üë®üèΩ‚Äçüíª ü§∞üèº ü§≤üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De vez en cuando publicamos materiales que de una forma u otra se relacionan con el uso de promesas en JavaScript. 

 Estas son algunas de ellas.  Pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usando promesas en JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/418085/">  De vez en cuando publicamos materiales que de una forma u otra se relacionan con el uso de promesas en JavaScript. <br><br><div class="spoiler">  <b class="spoiler_title">Estas son algunas de ellas.</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Promesas en ES6: patrones y antipatrones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JavaScript: m√©todos de programaci√≥n asincr√≥nicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JavaScript ES8 y transici√≥n a as√≠ncrono / espera</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">As√≠ncrono / espera: 6 razones para olvidarse de las promesas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Escapar del infierno as√≠ncrono / esperar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JavaScript ES6: escribe menos, haz m√°s</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a de promesas para aquellos que quieren entender</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dise√±o asincr√≥nico / en espera de JavaScript: fortalezas, dificultades y patrones de uso</a> </div></div><br>  ¬øPor qu√© se presta tanta atenci√≥n a las promesas?  Creemos que el punto es que esta tecnolog√≠a tiene mucha demanda y que es bastante dif√≠cil de entender. <br><br>  Por lo tanto, si desea comprender mejor las promesas, le ofrecemos una traducci√≥n del pr√≥ximo art√≠culo sobre este tema.  Su autor dice que ha estado desarrollando Java y PHP durante los √∫ltimos 10 a√±os, pero todo este tiempo ha estado buscando con inter√©s en JavaScript.  Recientemente, decidi√≥ participar seriamente en JS, y las promesas se convirtieron en el primer tema que le interes√≥. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/s3/wz/42/s3wz42iyj1wjzrvjzsx6spduxeu.jpeg"></a> <br><br>  Creemos que este material ser√° interesante para los desarrolladores novatos que sienten que, aunque usan promesas, no los entienden lo suficientemente bien.  Es posible que la historia de alguien que mira JavaScript con una mirada fresca y quiera explicar a otros lo que √©l mismo entendi√≥, sin creer que algunas cosas son entendibles para todos sin una explicaci√≥n, ayudar√° a los principiantes a dominar los mecanismos de JavaScript. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">JavaScript a trav√©s de los ojos de un principiante</font> </h2><br>  Cualquiera que comience a escribir en JavaScript, puede sentir lo que se llama "fuera de lugar".  Algunos dicen que JS es un lenguaje de programaci√≥n s√≠ncrono, otros dicen que es as√≠ncrono.  Un principiante escucha sobre el c√≥digo que bloquea el hilo principal, y sobre el c√≥digo que no lo bloquea, sobre los patrones de dise√±o basados ‚Äã‚Äãen eventos, sobre el ciclo de vida de los eventos, sobre la pila de llamadas a funciones, sobre la cola de eventos y su ascenso, sobre polyfills.  Aprende que existen cosas como Babel, Angular, React, Vue y una mir√≠ada de otras bibliotecas.  Si acaba de reconocerse como un "novato", no se preocupe por eso.  No eres ni el primero ni el √∫ltimo.  Incluso hay un t√©rmino para esto: la llamada "fatiga de JavaScript".  Lucas F Costa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://twitter.com/housecor/status/888468139389861888%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E888468139389861888%26ref_url%3D">habl√≥</a> acertadamente sobre este tema: "La <i>fatiga de JavaScript es algo que se puede observar cuando las personas usan herramientas que no necesitan para resolver problemas que no tienen</i> ". <br><br>  Pero no hablemos de cosas tristes.  Entonces, JavaScript es un lenguaje de programaci√≥n s√≠ncrono que, gracias al mecanismo de devoluci√≥n de llamada, le permite llamar a funciones de la misma manera que en lenguajes as√≠ncronos. <br><br><h2>  <font color="#3AC1EF">Una historia simple sobre promesas</font> </h2><br>  La palabra promesa se traduce como promesa.  Los objetos de promesa en la programaci√≥n, que llamamos "promesas", son muy similares a las promesas habituales que las personas se hacen en la vida real.  Entonces hablemos de estas promesas primero. <br><br>  En Wikipedia, puede encontrar la siguiente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">definici√≥n de la</a> palabra "promesa": "obligaci√≥n, el consentimiento de alguien para cumplir algo o, por el contrario, no hacer".  En el diccionario de Ozhegov, "promesa" es "un compromiso voluntario de hacer algo". <br><br>  Entonces, ¬øqu√© sabemos sobre las promesas? <br><br><ol><li>  Una promesa le garantiza que se har√° algo.  No importa qui√©n hace exactamente esto: el que hizo la promesa, o alguien m√°s, a petici√≥n del que hizo la promesa.  Una promesa da confianza en algo, bas√°ndose en esta confianza, el que recibi√≥ la promesa puede, por ejemplo, hacer algunos planes. </li><li>  Una promesa puede cumplirse o no. </li><li>  Si se cumple la promesa, entonces, como resultado, espera algo que pueda usar en el futuro para llevar a cabo cualquier acci√≥n o implementar cualquier plan. </li><li>  Si la promesa no se cumple, entonces querr√° saber por qu√© el que la dio no pudo cumplirla.  Despu√©s de descubrir el motivo de lo sucedido y de estar seguro de que la promesa no se ha cumplido, puede pensar qu√© hacer a continuaci√≥n o c√≥mo hacer frente a la situaci√≥n. </li><li>  Despu√©s de que le hayan prometido algo, todo lo que tiene es alg√∫n tipo de garant√≠a.  No puede aprovechar lo que le prometieron de inmediato.  Puede determinar por s√≠ mismo: qu√© debe hacer si se cumple la promesa (por lo tanto, recibir√° la promesa) y qu√© debe hacer si se rompe (en este caso, sabe el motivo de lo que sucedi√≥ y, por lo tanto, puede considerar un plan de acci√≥n de respaldo ) </li><li>  Es probable que la persona que hizo la promesa simplemente desaparezca.  En tales casos, es √∫til que la promesa est√© vinculada a alg√∫n tipo de marco de tiempo.  Por ejemplo, si el que le hizo la promesa no aparece en 10 d√≠as, puede suponer que tuvo algunos problemas y que rompi√≥ la promesa.  Como resultado, incluso si el que hizo la promesa la cumple en 15 d√≠as, no importar√°, por lo que ya est√° actuando en el plan alternativo, no confiando en la promesa. </li></ol><br>  Ahora pase a JavaScript. <br><br><h2>  <font color="#3AC1EF">Promesas de JavaScript</font> </h2><br>  Tengo una regla: cuando hago JavaScript, siempre leo la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> que se puede encontrar en MDN.  Me parece que este recurso se compara favorablemente con los otros en especificidad y claridad de presentaci√≥n.  Por lo tanto, mientras estudiaba las promesas, me familiaric√© con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">material</a> relevante y experiment√© con el c√≥digo para acostumbrarme a las nuevas construcciones de sintaxis. <br><br>  Para entender las promesas, debe lidiar con dos cosas principales.  El primero es la creaci√≥n de promesas.  El segundo es procesar los resultados devueltos por las promesas.  Aunque la mayor parte del c√≥digo que escribimos est√° dirigido a trabajar con promesas creadas, por ejemplo, por ciertas bibliotecas, una comprensi√≥n completa de los mecanismos de trabajo de las promesas ser√° indudablemente √∫til.  Adem√°s, para un programador que ya tiene algo de experiencia, saber c√≥mo crear promesas es tan importante como saber c√≥mo trabajar con ellas. <br><br><h2>  <font color="#3AC1EF">Crea promesas</font> </h2><br>  As√≠ es como se crean las promesas: <br><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* executor */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ ... } );</code> </pre> <br>  El constructor acepta una funci√≥n que realiza ciertas acciones, aqu√≠ la llamamos <code>executor</code> .  Esta funci√≥n toma dos par√°metros: <code>resolve</code> y <code>reject</code> , que, a su vez, tambi√©n son funciones.  Las promesas se usan generalmente para realizar operaciones as√≠ncronas o c√≥digos que pueden bloquear el hilo principal, por ejemplo, uno que trabaja con archivos, realiza llamadas a ciertas API, realiza consultas a la base de datos, trata de E / S, etc.  El inicio de tales operaciones asincr√≥nicas se realiza en la funci√≥n <code>executor</code> .  Si la operaci√≥n asincr√≥nica se completa con √©xito, el resultado esperado de la promesa se devolver√° llamando a la funci√≥n de <code>resolve</code> .  La situaci√≥n en la que se llama esta funci√≥n est√° determinada por el creador de la promesa.  De manera similar, cuando ocurre un error, la informaci√≥n sobre lo que sucedi√≥ se devuelve llamando a la funci√≥n de <code>reject</code> . <br><br>  Ahora que sabemos, en t√©rminos generales, c√≥mo crear promesas, crearemos una promesa simple para comprender mejor todo. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keepsHisWord; keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesnt want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise1);</code> </pre> <br>  Esto es lo que generar√° este c√≥digo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e2/f52/7a1/8e2f527a185616e8dbb6fa3433303d54.png"></div><br>  <i><font color="#999999">Promise tiene un estado (PromiseStatus) y un valor (PromiseValue)</font></i> <br><br>  Dado que nuestra promesa se resuelve instant√°neamente, no podemos investigar su estado inicial.  Por lo tanto, creemos una nueva promesa que, para su resoluci√≥n, necesita algo de tiempo.  La forma m√°s f√°cil de hacerlo es mediante la funci√≥n <code>setTimeout</code> . <br><br><pre> <code class="hljs javascript">promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   resolve({     <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-string"><span class="hljs-string">"aManKeepsHisWord"</span></span>   }); }, <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise2);</code> </pre> <br>  En este c√≥digo, se crea una promesa que ciertamente se resolver√° en 10 segundos.  Esto nos da la oportunidad de ver el estado de una promesa no autorizada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/828/13d/bd482813d5a8d53df3eb39b716b8c0b7.png"></div><br>  <i><font color="#999999">Promesa no resuelta</font></i> <br><br>  Despu√©s de que hayan pasado 10 segundos, la promesa se resolver√°.  Como resultado, tanto <code>PromiseStatus</code> como <code>PromiseValue</code> se actualizar√°n en consecuencia.  Como puede ver, en este ejemplo cambiamos la funci√≥n llamada cuando la promesa se resolvi√≥ con √©xito, ahora no devuelve una cadena ordinaria, sino un objeto.  Esto se hace para demostrar la capacidad de devolver estructuras de datos complejas utilizando la funci√≥n <code>resolve</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/ff7/74a/707ff774ad727f4e41a247714182d7fd.png"></div><br>  <i><font color="#999999">Promesa resuelta despu√©s de 10 segundos y devolviendo un objeto</font></i> <br><br>  Veamos ahora la promesa, que decidimos no permitir, sino rechazar.  Para hacer esto, modificamos el c√≥digo que ya se us√≥ en el primer ejemplo. <br><br><pre> <code class="hljs javascript">keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesn't want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise3);</code> </pre> <br>  Como no manejamos la situaci√≥n de rechazo de la promesa, se mostrar√° un mensaje de error en la consola del navegador (aqu√≠ se usa Google Chrome).  Hablaremos m√°s sobre esto a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/cd1/aa6/bd1cd1aa66cdd5969cb7e8726236938d.png"></div><br>  <i><font color="#999999">Promesa rechazada</font></i> <br><br>  Ahora, despu√©s de analizar los tres ejemplos, podemos ver que tres valores diferentes pueden aparecer en <code>PromiseStatus</code> : <code>pending</code> (pendiente), <code>resolved</code> (resoluci√≥n exitosa) y <code>rejected</code> (rechazada).  Cuando se crea una promesa, en <code>PromiseStatus</code> estar√° <code>pending</code> y en <code>PromiseValue</code> estar√° <code>undefined</code> .  Estos valores permanecer√°n hasta que se resuelva o rechace la promesa.  Cuando una promesa se encuentra en un estado <code>resolved</code> o <code>rejected</code> , se llama promesa <code>settled</code> .  Tal promesa ha pasado de un estado de espera a un estado en el que tiene un estado <code>resolved</code> o un estado <code>rejected</code> . <br><br>  Ahora que hemos aprendido c√≥mo se crean las promesas, podemos hablar sobre c√≥mo procesar lo que devuelven.  Para resolver esto, necesitamos entender la estructura del objeto <code>Promise</code> . <br><br><h2>  <font color="#3AC1EF">Objeto de promesa</font> </h2><br>  Seg√∫n la documentaci√≥n de MDN, un objeto <code>Promise</code> es el resultado de una finalizaci√≥n exitosa o incorrecta de una operaci√≥n asincr√≥nica. <br><br>  El objeto <code>Promise</code> tiene m√©todos est√°ticos y m√©todos prototipo del objeto.  Se pueden invocar m√©todos est√°ticos sin crear una instancia del objeto, y para llamar a los m√©todos prototipo, se necesita una instancia del objeto <code>Promise</code> .  Tenga en cuenta que los m√©todos est√°ticos y regulares devuelven objetos <code>Promise</code> .  Esto facilita el trabajo. <br><br><h3>  <font color="#3AC1EF">‚ñç Promete m√©todos de prototipos de objetos</font> </h3><br>  Hablemos primero sobre los m√©todos prototipo del objeto <code>Promise</code> .  Hay tres de estos m√©todos.  No olvide que estos m√©todos se pueden invocar en la instancia del objeto <code>Promise</code> y que ellos mismos devuelven las promesas.  Gracias a todos estos m√©todos, puede asignar controladores que respondan a los cambios en el estado de las promesas.  Como ya hemos visto, cuando se crea una promesa, est√° en estado <code>pending</code> .  Cuando una promesa pasa a un estado <code>resolved</code> o <code>rejected</code> , se llamar√° al menos uno de los siguientes m√©todos: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.catch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.then</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFulfilled</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.finally</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFinally</span></span>)</code> </pre> <br>  A continuaci√≥n se muestra un diagrama del funcionamiento de la promesa y los eventos que condujeron a la llamada de los <code>.catch</code> <code>.then</code> y <code>.catch</code> .  Como estos m√©todos devuelven objetos <code>Promise</code> , sus llamadas se pueden encadenar, esto tambi√©n se refleja en el diagrama.  Si la promesa usa el m√©todo <code>.finally</code> , se llamar√° cuando la promesa pase al estado <code>settled</code> , independientemente de si la promesa se resolvi√≥ o rechaz√≥ con √©xito. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c01/d3a/9bc/c01d3a9bce02c7b7a0a7373bba117a02.png"><br>  <i><font color="#999999">Esquema de trabajo de Promis (imagen tomada <a href="">de aqu√≠</a> )</font></i> <br><br>  Aqu√≠ hay una historia corta.  Eres estudiante y le pides a tu madre que te compre un tel√©fono celular.  Ella dice: "Si nuestros ahorros son m√°s que el costo del tel√©fono, se lo comprar√©".  Ahora vuelve a contar esta historia en JavaScript. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> momsPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ momsSavings = <span class="hljs-number"><span class="hljs-number">20000</span></span>; priceOfPhone = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (momsSavings &gt; priceOfPhone) {   resolve({     <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">"iphone"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">"6s"</span></span>   }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"We donot have enough savings. Let us save some more money."</span></span>); } }); momsPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(value)); }); momsPromise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); }); momsPromise.finally(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(   <span class="hljs-string"><span class="hljs-string">"Irrespecitve of whether my mom can buy me a phone or not, I still love her"</span></span> ); });</code> </pre> <br>  Esto es lo que generar√° este c√≥digo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/cc9/be3/cf0cc9be3eff013549852e5a27b47823.png"></div><br>  <i><font color="#999999">Mam√° no cumpli√≥ una promesa</font></i> <br><br>  Si cambiamos el valor de los <code>momsSavings</code> variables de las <code>momsSavings</code> a 200,000, entonces mam√° podr√° comprar un regalo para su hijo.  En este caso, el c√≥digo anterior generar√° lo siguiente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf5/393/72a/cf539372a0dce219b10136e4b6280de8.png"></div><br>  <i><font color="#999999">Mam√° cumpli√≥ una promesa</font></i> <br><br>  Ahora imaginemos que el c√≥digo en cuesti√≥n est√° dise√±ado como una biblioteca, y usamos esta biblioteca.  Hablemos sobre el uso efectivo de los <code>.catch</code> <code>.then</code> y <code>.catch</code> . <br><br>  Dado que el m√©todo <code>.then</code> se puede asignar tanto al controlador <code>onFulfilled</code> que se llama cuando la promesa se resuelve con √©xito como al controlador <code>onRejected</code> que se llama cuando se rechaza la promesa, en lugar de utilizar el m√©todo <code>.catch</code> y el m√©todo <code>.catch</code> , podemos lograr el mismo efecto con solo uno <code>.then</code> m√©todo.  As√≠ es como podr√≠a verse: <br><br><pre> <code class="hljs lua">momsPromise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, JSON.stringify(value)); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); } );</code> </pre> <br>  Este es un ejemplo de trabajo, pero para evitar la legibilidad del c√≥digo, es mejor usar m√©todos <code>.then</code> y <code>.catch</code> lugar de un <code>.then</code> universal. <br><br>  Para que estos ejemplos se ejecuten en un navegador, y espec√≠ficamente en Google Chrome, intent√© evitar dependencias externas.  Para comprender mejor lo que consideraremos m√°s adelante, creemos una funci√≥n que devuelva una promesa, cuya resoluci√≥n o rechazo se produce al azar.  Esto nos permitir√° experimentar varios escenarios de trabajo con promesas.  Para comprender las caracter√≠sticas de las funciones asincr√≥nicas, estableceremos retrasos aleatorios en nuestras promesas.  Como necesitamos n√∫meros aleatorios, creamos una funci√≥n que devuelve un n√∫mero aleatorio entre <code>x</code> e <code>y</code> .  Aqu√≠ est√° la funci√≥n. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getRandomNumber(start = <span class="hljs-number"><span class="hljs-number">1</span></span>, end = <span class="hljs-number"><span class="hljs-number">10</span></span>) { //,      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseInt(Math.random() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>; }</code> </pre> <br>  Ahora cree una funci√≥n que devuelva promesas.  <code>promiseTRRARNOSG</code> .  El nombre de esta funci√≥n significa <code>promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator</code> , es decir, es un generador de promesas que se resuelven o rechazan aleatoriamente despu√©s de un n√∫mero aleatorio de segundos.  Esta funci√≥n crear√° una promesa que se permitir√° o rechazar√° despu√©s de un per√≠odo de tiempo aleatorio entre 2 y 10 segundos.  Para permitir o rechazar una promesa al azar, obtenemos un n√∫mero aleatorio entre 1 y 10. Si este n√∫mero es mayor que 5, se permitir√° la promesa, de lo contrario, ser√° rechazada. <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start = 1, end = 10)</span></span></span></span> { //,      start  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; start <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (parseInt(Math.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> - start + <span class="hljs-number"><span class="hljs-number">1</span></span>)) + start; } var promiseTRRARNOSG = (promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span></span> {   let randomNumberOfSeconds = getRandomNumber(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {     let randomiseResolving = getRandomNumber(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomiseResolving &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) {       resolve({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       reject({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     }   }, randomNumberOfSeconds * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); var testProimse = promiseTRRARNOSG(); testProimse.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); testProimse.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); //             ,    .     ,  - . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;=<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { let promise = promiseTRRARNOSG(); promise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); promise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); }</code> </pre> <br>  Ejecute este c√≥digo en la consola del navegador para ver c√≥mo se comportan las promesas permitidas y rechazadas.  A continuaci√≥n, hablaremos sobre c√≥mo puede crear muchas promesas y verificar los resultados de su implementaci√≥n, utilizando otros mecanismos. <br><br><h3>  <font color="#3AC1EF">‚ñç M√©todos est√°ticos de un objeto Promise</font> </h3><br>  Hay cuatro m√©todos est√°ticos de un objeto <code>Promise</code> . <br><br>  Aqu√≠ hay dos m√©todos: <code>Promise.reject(reason)</code> y <code>Promise.resolve(value)</code> , que le permiten crear, respectivamente, promesas rechazadas y permitidas. <br><br>  Aqu√≠ se explica c√≥mo trabajar con el m√©todo <code>Promise.reject</code> , que crea promesas rechazadas. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise3 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Not interested"</span></span>); promise3.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a rejected promise. The resolved value is "</span></span>, value); }); promise3.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This run as it is a rejected promise. The reason is "</span></span>, reason); });</code> </pre> <br>  Aqu√≠ hay un ejemplo usando el m√©todo <code>Promise.resolve</code> que crea promesas resueltas exitosamente. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will run as it is a resovled promise. The resolved value is "</span></span>, value); }); promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a resolved promise"</span></span>, reason); });</code> </pre> <br>  Cabe se√±alar que una promesa puede tener varios controladores.  Por ejemplo, seg√∫n el ejemplo anterior, puede obtener el c√≥digo que se muestra a continuaci√≥n. <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = Promise.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will run as it is a resovled promise. The resolved value is ", value); }</span></span></span><span class="hljs-function">);</span></span> promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will also run as multiple handlers can be added. Printing twice the resolved value which is ", value * 2); }</span></span></span><span class="hljs-function">);</span></span> promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will not run as it is a resolved promise", reason); }</span></span></span><span class="hljs-function">);</span></span></code> </pre> <br>  Esto es lo que muestra en la consola del navegador: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/10b/6d3/64410b6d31e57ab7197e6af1453d9b93.png"></div><br>  <i><font color="#999999">Usar m√∫ltiples .then al trabajar con Promise</font></i> <br><br>  Los siguientes dos m√©todos, <code>Promise.all</code> y <code>Promise.race</code> , est√°n dise√±ados para funcionar con conjuntos de promesas.  Si, para resolver un problema determinado, es necesario procesar varias promesas, lo m√°s conveniente es colocar estas promesas en una matriz y luego realizar las acciones necesarias con ellas.  Para comprender la esencia de los m√©todos considerados aqu√≠, no podremos utilizar nuestra funci√≥n conveniente <code>promiseTRRARNOSG</code> , ya que el resultado de su trabajo depende demasiado de la voluntad del caso.  Ser√° m√°s conveniente para nosotros usar algo que produzca promesas m√°s predecibles, lo que nos permitir√° comprender su comportamiento.  Por lo tanto, crearemos dos nuevas funciones.  Uno de ellos ( <code>promiseTRSANSG</code> ) crear√° promesas que se resuelven despu√©s de <code>n</code> segundos, el segundo ( <code>promiseTRJANSG</code> ): promesas que se rechazan despu√©s de <code>n</code> segundos. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRSANSG = (promiseThatResolvesAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     resolve({       <span class="hljs-attr"><span class="hljs-attr">resolvedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRJANSG = (promiseThatRejectsAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     reject({       <span class="hljs-attr"><span class="hljs-attr">rejectedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); });</code> </pre> <br>  Ahora usaremos estas funciones para comprender las caracter√≠sticas del m√©todo <code>Promise.all</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç M√©todo Promise.all</font> </h3><br>  A partir de la documentaci√≥n de MDN, puede descubrir que el <code>Promise.all(iterable)</code> devuelve una promesa que se resolver√° cuando se resuelvan todas las promesas aprobadas como un argumento <code>iterable</code> , o cuando este argumento no contenga promesas.  Esta promesa ser√° rechazada si alguna de las promesas transferidas es rechazada. <br>  Veamos algunos ejemplos. <br><br><h4>  Ejemplo no 1 </h4><br>  Todas las promesas ser√°n permitidas aqu√≠.  Este escenario es el m√°s com√∫n. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  Esto es lo que este c√≥digo enviar√° a la consola: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfb/36f/112/cfb36f11242338d72c4541e53a8313f2.png"></div><br>  <i><font color="#999999">Todas las promesas permitidas</font></i> <br><br>  Despu√©s de analizar los resultados de este ejemplo, se pueden hacer dos observaciones importantes. <br><br>  En primer lugar, la tercera promesa, cuya resoluci√≥n lleva 2 segundos, se completa antes de la segunda, pero, como se puede ver en la salida generada por el c√≥digo, se preserva el orden de las promesas en la matriz. <br><br>  En segundo lugar, el c√≥digo contiene un temporizador que se utiliza para averiguar cu√°nto tiempo lleva ejecutar la instrucci√≥n <code>Promise.all</code> . <br><br>  Si las promesas se ejecutaran secuencialmente, el tiempo de ejecuci√≥n de esta instrucci√≥n ser√≠a de 7 segundos (1 + 4 + 2).  Sin embargo, el temporizador nos informa que toda la operaci√≥n tom√≥ 4 segundos si redondeamos el resultado.  Esta es una prueba de que todas las promesas se ejecutan en paralelo. <br><br><h4>  Ejemplo no 2 </h4><br>  Ahora considere la situaci√≥n cuando no hay promesas en la matriz pasada a Promise.all.  Creo que este es el caso de uso menos com√∫n para esta caracter√≠stica. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(<span class="hljs-number"><span class="hljs-number">1</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">4</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  Aqu√≠ est√° el resultado que generar√° este c√≥digo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24d/20c/e98/24d20ce98e2939d54fb40d7efe40a98d.png"></div><br>  <i><font color="#999999">Invoque Promise.all y pase una matriz que no contenga promesas a este m√©todo</font></i> <br><br>  Como no hay promesas en la matriz, <code>Promise.all</code> casi al instante. <br><br><h4>  Ejemplo no 3 </h4><br>  Ahora veamos qu√© sucede cuando una de las promesas pasa a <code>Promise.all</code> es rechazada. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason "</span></span>, reason); });</code> </pre> <br>  Como puede ver en los resultados de ejecuci√≥n de c√≥digo que se muestran a continuaci√≥n, <code>Promise.all</code> ejecuci√≥n se detiene despu√©s de la primera promesa rechazada con la salida del mensaje que entrega esta promesa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/b92/a32/87ab92a321b372cd6fe3abeba21f16a2.png"></div><br>  <i><font color="#999999">La ejecuci√≥n se detiene despu√©s de la primera promesa rechazada</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç M√©todo Promise.race</font> </h3><br>  MDN informa que el <code>Promise.race(iterable)</code> devuelve una promesa permitida o rechazada con un valor o motivo de rechazo despu√©s de que una de las promesas transmitidas se permita o rechace respectivamente. <br><br>  Veamos ejemplos de trabajo con <code>Promise.race</code> . <br><br><h4>  Ejemplo no 1 </h4><br>  Muestra lo que sucede cuando una de las promesas pasadas a <code>Promise.race</code> se resuelve antes que nadie. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  Esto es lo que llega a la consola despu√©s de ejecutar este ejemplo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/010/151/044/0101510448b397d862e2e3a21edb4822.png"></div><br>  <i><font color="#999999">Promis, que se resolvi√≥ m√°s r√°pido que todos los dem√°s</font></i> <br><br>  Todas las promesas aqu√≠ se realizan en paralelo.  La tercera promesa se resuelve despu√©s de 2 segundos.  Tan pronto como esto sucede, la promesa devuelta por <code>Promise.race</code> se resuelve. <br><br><h4>  Ejemplo no 2 </h4><br>  Ahora considere la situaci√≥n cuando una de las promesas pasadas a <code>Promise.race</code> es rechazada. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">6</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  Despu√©s de ejecutar este ejemplo, lo siguiente llegar√° a la consola: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/063/6fe/351/0636fe351042cfb51428c33db5595b44.png"></div><br>  <i><font color="#999999">Promesa rechazada antes que los dem√°s</font></i> <br><br>  Las promesas aqu√≠, como en los ejemplos anteriores, se realizan en paralelo.  La cuarta promesa se rechaza despu√©s de 3 segundos.  Tan pronto como esto sucede, la promesa devuelta por <code>Promise.race</code> es rechazada. <br><br><h2>  <font color="#3AC1EF">Ejemplo general y experimentos</font> </h2><br>  Recopil√© todos los ejemplos que consideramos en este material en un solo lugar, lo que har√° que sea m√°s f√°cil experimentar con ellos, explorar varios escenarios de trabajo con promesas.  Este c√≥digo est√° dise√±ado para ejecutarse en un navegador, por lo que aqu√≠ no usamos ninguna llamada API, no accedemos a las operaciones de archivo y no trabajamos con bases de datos.  Aunque todo esto tiene aplicaci√≥n en el desarrollo de proyectos reales, creo que trabajar con estos mecanismos puede distraernos de nuestro objetivo principal: las promesas.  Y el uso de funciones simples que simulan retrasos en el tiempo da resultados similares y no nos carga con detalles adicionales. <br><br>  Al explorar estos ejemplos usted mismo, puede experimentar con el c√≥digo, con los valores de las variables y estudiar diferentes escenarios para usar promesas.  En particular, puede utilizar una combinaci√≥n de los <code>promiseTRJANSG</code> , <code>promiseTRSANSG</code> y <code>promiseTRRARNOSG</code> para simular muchos escenarios para usar promesas, lo que le permitir√° comprenderlos mejor.  Adem√°s, tenga en cuenta que el uso del comando <code>console.time</code> permite averiguar el tiempo requerido para ejecutar un determinado fragmento de c√≥digo y, por ejemplo, averiguar si las promesas se ejecutan en paralelo o secuencialmente.  Aqu√≠ hay un <a href="">enlace</a> a la p√°gina principal con el c√≥digo.  Y, por cierto, si lo desea, eche un vistazo a la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bluebird</a> , que contiene algunos m√©todos interesantes para trabajar con promesas. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Le ofrezco una lista de reglas a las que me adhiero cuando trabajo con promesas para usarlas correctamente. <br><br><ol><li>  Use promesas en situaciones en las que trabaje con c√≥digo as√≠ncrono o de bloqueo. </li><li>  Para manejar la situaci√≥n de resolver con √©xito una promesa, use el m√©todo <code>.then</code> ; para los casos en que la promesa sea rechazada, use <code>.catch</code> . </li><li>  Utilice los <code>.catch</code> <code>.then</code> y <code>.catch</code> en todas las promesas. </li><li>  -     ,    ,   <code>.finally</code> . </li><li>  ,  ,      ,   . </li><li>       ,     . </li><li>    <code>Promise</code> ,     ,    ,  . </li><li>  <code>Promise.all</code>         ,        . </li></ol><br> ,      ,      ,     . <br><br>  <b>Estimados lectores!</b> ,       ,     ? <br><br><div class="spoiler"> <b class="spoiler_title">-   ,     </b> <div class="spoiler_text"> -    10%    : <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/qk/au/oy/qkauoyb4porqes9wmm3jofcs3bg.png"></a> <br><br>    :) </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418085/">https://habr.com/ru/post/es418085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418075/index.html">TOP 5 cosas que se pueden imprimir en una impresora 3D [video]</a></li>
<li><a href="../es418077/index.html">Accidentes de "no mirar": una justificaci√≥n estad√≠stica para el modo operativo de soporte t√©cnico 24/7</a></li>
<li><a href="../es418079/index.html">Los lenguajes de programaci√≥n m√°s populares - 2018</a></li>
<li><a href="../es418081/index.html">Organizaci√≥n de pruebas seguras en producci√≥n. Parte 1</a></li>
<li><a href="../es418083/index.html">Servidor simple con GraphQL en lugar de REST, implementaci√≥n en java</a></li>
<li><a href="../es418087/index.html">El 80% de los pagos de autoservicio est√°n en riesgo</a></li>
<li><a href="../es418089/index.html">Descripci√≥n general de la fresadora CNC SolidCraft</a></li>
<li><a href="../es418091/index.html">Lista de art√≠culos y literatura sobre NAS</a></li>
<li><a href="../es418093/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 3: Desbordamientos del b√∫fer: exploits y protecci√≥n, parte 2</a></li>
<li><a href="../es418095/index.html">Acerca del dispositivo de funcionalidad de prueba incorporada en Rust (traducci√≥n)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>