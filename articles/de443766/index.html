<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèø üöú üë©üèª Probieren Sie jetzt C ++ 20 Contract Programming aus üïã üì© üà¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C ++ 20 wurde die Vertragsprogrammierung angezeigt. Bisher hat noch kein Compiler die Unterst√ºtzung f√ºr diese Funktion implementiert. 


 Es gibt j...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Probieren Sie jetzt C ++ 20 Contract Programming aus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443766/"><p><img src="https://habrastorage.org/webt/ow/o1/yv/owo1yvuvpymi1w4uoa1olkjoo0g.png"></p><br><p>  In C ++ 20 wurde die Vertragsprogrammierung angezeigt.  Bisher hat noch kein Compiler die Unterst√ºtzung f√ºr diese Funktion implementiert. </p><br><p>  Es gibt jetzt jedoch eine M√∂glichkeit, Vertr√§ge aus C ++ 20 zu verwenden, wie im Standard beschrieben. </p><a name="habracut"></a><br><h3 id="tldr">  TL; DR </h3><br><p>  <em>Es gibt ein Gabelger√§usch, das Vertr√§ge unterst√ºtzt.</em>  <em>Anhand seines Beispiels erkl√§re ich Ihnen, wie Sie Vertr√§ge verwenden, damit Sie sofort mit der Verwendung einer Funktion in Ihrem bevorzugten Compiler beginnen k√∂nnen.</em> </p><br><p>  Es wurde bereits viel √ºber Vertragsprogrammierung geschrieben, aber kurz gesagt, ich werde Ihnen sagen, was es ist und wof√ºr es ist. </p><br><h2 id="logika-hoara">  Logik von Hoar </h2><br><p>  Das Paradigma der Vertr√§ge basiert auf der Hoar-Logik ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> ). </p><br><p> Hoar-Logik ist ein Weg, um die Richtigkeit eines Algorithmus formal zu beweisen. <br>  Es arbeitet mit Konzepten wie Vorbedingung, Nachbedingung und Invariante. <br>  Aus praktischer Sicht ist die Verwendung der Hoar-Logik zum einen eine M√∂glichkeit, die Richtigkeit eines Programms in F√§llen, in denen Fehler zu Katastrophen oder zum Tod f√ºhren k√∂nnen, formal zu beweisen.  Zweitens eine M√∂glichkeit, die Zuverl√§ssigkeit des Programms zusammen mit statischen Analysen und Tests zu erh√∂hen. </p><br><h2 id="kontraktnoe-programmirovanie">  Vertragsprogrammierung </h2><br><p>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> ) </p><br><p>  Die Hauptidee von Vertr√§gen besteht darin, dass in Analogie zu Gesch√§ftsvertr√§gen Vereinbarungen f√ºr jede Funktion oder Methode beschrieben werden.  Diese Vorkehrungen m√ºssen sowohl vom Anrufer als auch vom Anrufer beachtet werden. <br>  Ein wesentlicher Bestandteil von Vertr√§gen sind mindestens zwei Montagemodi - Debugging und Lebensmittelgesch√§ft.  Vertr√§ge sollten sich je nach Erstellungsmodus unterschiedlich verhalten.  Am h√§ufigsten werden Vertr√§ge in der Debug-Assembly √ºberpr√ºft und im Lebensmittelgesch√§ft ignoriert. </p><br><p>  Manchmal werden Vertr√§ge auch in der Produktmontage gepr√ºft und ihre Nichterf√ºllung kann beispielsweise zur Entstehung einer Ausnahme f√ºhren. </p><br><p>  Der Hauptunterschied zwischen der Verwendung von Vertr√§gen aus dem ‚Äûklassischen‚Äú Ansatz besteht darin, dass der Anrufer die im Vertrag beschriebenen Voraussetzungen des Angerufenen erf√ºllen muss und der Anrufer seine Nachbedingungen und Invarianten einhalten muss. <br>  Dementsprechend ist der angerufene Teilnehmer nicht verpflichtet, die Richtigkeit seiner Parameter zu √ºberpr√ºfen.  Diese Verpflichtung wird dem Anrufer vertraglich √ºbertragen. </p><br><p>  Die Nichteinhaltung von Vertr√§gen sollte in der Testphase festgestellt werden und erg√§nzt alle Arten von Tests: modulare Integration usw. </p><br><p>  Auf den ersten Blick erschwert die Verwendung von Vertr√§gen die Entwicklung und beeintr√§chtigt die Lesbarkeit des Codes.  In der Tat ist das genaue Gegenteil der Fall.  Anh√§nger der statischen Typisierung k√∂nnen die Vorteile von Vertr√§gen am einfachsten bewerten, da ihre einfachste Option darin besteht, Typen in der Signatur von Methoden und Funktionen zu beschreiben. </p><br><p>  Was sind die Vorteile von Vertr√§gen: </p><br><ul><li>  Verbessern Sie die Lesbarkeit des Codes durch explizite Dokumentation. </li><li>  Verbessern Sie die Codezuverl√§ssigkeit durch erg√§nzende Tests. </li><li>  Erm√∂glichen Sie Compilern, Optimierungen auf niedriger Ebene zu verwenden und schnelleren Code basierend auf der Einhaltung von Vertr√§gen zu generieren.  Im letzteren Fall kann die Nichteinhaltung des Vertrags in der Freigabemontage zu UB f√ºhren. </li></ul><br><h2 id="kontraktnoe-programmirovanie-v-c">  Vertragsprogrammierung in C ++ </h2><br><p>  Die Vertragsprogrammierung ist in vielen Sprachen implementiert.  Die auff√§lligsten Beispiele sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eiffel</a> , wo das Paradigma zuerst implementiert wurde, und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">D</a> in D-Vertr√§gen sind Teil der Sprache. </p><br><p>  In C ++ konnten Vertr√§ge vor dem C ++ 20-Standard als separate Bibliotheken verwendet werden. </p><br><p>  Dieser Ansatz hat mehrere Nachteile: </p><br><ul><li>  Sehr ungeschickte Syntax mit Makros. </li><li>  Das Fehlen eines einzigen Stils. </li><li>  Unf√§higkeit, Vertr√§ge des Compilers zur Optimierung des Codes zu verwenden. </li></ul><br><p>  Bibliotheksimplementierungen basieren normalerweise auf der Verwendung der guten alten Assert- und Pr√§prozessor-Direktiven, die nach dem Kompilierungsflag suchen. </p><br><p>  Die Verwendung von Vertr√§gen in dieser Form macht den Code wirklich h√§sslich und unlesbar.  Dies ist einer der Gr√ºnde, warum die Verwendung von Vertr√§gen in C ++ wenig praktiziert wird. </p><br><p>  Mit Blick auf die Zukunft werde ich zeigen, wie die Verwendung von Vertr√§gen in C ++ 20 aussehen wird. <br>  Und dann werden wir das alles genauer analysieren: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> [[ expects: x &gt; 0 ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// precondition [[ expects: y &gt; 0 ]] // precondition [[ ensures r: r &lt; x + y ]] // postcondition { int z = (x - x%y) / y; [[ assert: z &gt;= 0 ]]; // assertion return z + y; }</span></span></span></span></code> </pre> <br><h2 id="probuem">  Versuchen Sie es </h2><br><p>  Leider hat derzeit noch keiner der weit verbreiteten Compiler eine Vertragsunterst√ºtzung implementiert. <br>  Aber es gibt einen Ausweg. </p><br><p>  <em>Die ARCOS-Forschungsgruppe</em> der <em>Universidad Carlos III de Madrid</em> implementierte experimentelle Unterst√ºtzung f√ºr Vertr√§ge in der Clang ++ - Gabel. </p><br><p>  Um nicht ‚ÄûCode auf ein Blatt Papier zu schreiben‚Äú, sondern sofort neue Gesch√§ftsm√∂glichkeiten ausprobieren zu k√∂nnen, k√∂nnen wir diese Gabel sammeln und damit die folgenden Beispiele ausprobieren. </p><br><p>  Montageanleitungen sind in der Readme-Datei des Github-Repositorys beschrieben <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/arcosuc3m/clang-contracts</a> </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/arcosuc3m/clang-contracts/ mkdir -p clang-contracts/build/ &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> clang-contracts/build/ cmake -G <span class="hljs-string"><span class="hljs-string">"Unix Makefiles"</span></span> -DLLVM_USE_LINKER=gold -DBUILD_SHARED_LIBS=ON -DLLVM_USE_SPLIT_DWARF=ON -DLLVM_OPTIMIZED_TABLEGEN=ON ../ make -j8</code> </pre> <br><p>  Ich hatte w√§hrend der Montage keine Probleme, aber das Kompilieren der Quellen dauert sehr lange. </p><br><p>  Um die Beispiele zu kompilieren, m√ºssen Sie den Pfad zur Clang ++ - Bin√§rdatei explizit angeben. <br>  Zum Beispiel sieht es f√ºr mich so aus </p><br><pre> <code class="bash hljs">/home/valmat/work/git/clang-contracts/build/bin/clang++ -std=c++2a -build-level=audit -g test.cpp -o test.bin</code> </pre> <br><p>  Ich habe Beispiele vorbereitet, damit Sie Vertr√§ge anhand von Beispielen mit echtem Code pr√ºfen k√∂nnen.  Ich schlage vor, bevor Sie mit dem Lesen des n√§chsten Abschnitts beginnen, Beispiele zu klonen und zu kompilieren. </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/valmat/cpp20-contracts-examples/ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> cpp20-contracts-examples make CPP=/path/to/clang++</code> </pre> <br><p>  Hier ist <code>/path/to/clang++</code> Pfad zur <code>clang++</code> Bin√§rdatei Ihrer experimentellen Compiler-Assembly. </p><br><p>  Zus√§tzlich zum Compiler selbst hat die ARCOS-Forschungsgruppe ihre Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compiler-Explorers</a> f√ºr ihre Abzweigung vorbereitet. </p><br><h2 id="kontraktnoe-programmirovanie-v-c20">  Vertragsprogrammierung in C ++ 20 </h2><br><p>  Jetzt hindert uns nichts mehr daran, die M√∂glichkeiten der Vertragsprogrammierung zu erforschen und diese M√∂glichkeiten sofort in der Praxis auszuprobieren. </p><br><p>  Wie oben erw√§hnt, werden Vertr√§ge aus Vorbedingungen, Nachbedingungen und Invarianten (Aussagen) aufgebaut. </p><br><p>  In C ++ 20 werden hierf√ºr Attribute mit folgender Syntax verwendet </p><br><pre> <code class="cpp hljs">[[contract-attribute modifier identifier: conditional-expression]]</code> </pre> <br><p>  Wobei das <code>contract-attribute</code> einen der folgenden Werte annehmen kann: <br>  <strong>erwartet</strong> , <strong>sichert</strong> oder <strong>behauptet</strong> . </p><br><p>  <code>expects</code> f√ºr Vorbedingungen verwendet, <code>ensures</code> f√ºr Nachbedingungen <code>ensures</code> und <code>assert</code> f√ºr Aussagen. </p><br><p>  <code>conditional-expression</code> ist ein boolescher Ausdruck, der in einem Vertragspr√§dikat validiert wird. <br>  <code>modifier</code> und <code>identifier</code> k√∂nnen weggelassen werden. </p><br><p>  Warum brauche ich einen <code>modifier</code> Ich werde etwas tiefer schreiben. </p><br><p>  <code>identifier</code> nur mit <code>ensures</code> und dient zur Darstellung des R√ºckgabewerts. </p><br><p>  Voraussetzungen haben Zugriff auf Argumente. </p><br><p>  Nachbedingungen haben Zugriff auf den von der Funktion zur√ºckgegebenen Wert.  Hierf√ºr wird die Syntax verwendet. </p><br><pre> <code class="cpp hljs">[[ensures return_variable: expr(return_variable)]]</code> </pre> <br><p>  Wobei <code>return_variable</code> ein g√ºltiger Ausdruck f√ºr die Variable ist. </p><br><p>  Mit anderen Worten, Vorbedingungen sollen Einschr√§nkungen deklarieren, die Argumenten auferlegt werden, die von der Funktion akzeptiert werden, und Nachbedingungen, um Einschr√§nkungen zu deklarieren, die dem von der Funktion zur√ºckgegebenen Wert auferlegt werden. </p><br><p>  Es wird angenommen, dass <em>Vor-</em> und <em>Nachbedingungen</em> Teil der Funktionsschnittstelle sind, w√§hrend <em>Anweisungen</em> Teil ihrer Implementierung sind. </p><br><p>  Voraussetzungspr√§dikate werden immer unmittelbar vor der Ausf√ºhrung der Funktion ausgewertet.  Die Nachbedingungen sind unmittelbar nach √úbergabe der Steuerfunktion an den aufrufenden Code erf√ºllt. </p><br><p>  Wenn in einer Funktion eine Ausnahme ausgel√∂st wird, wird die Nachbedingung nicht √ºberpr√ºft. <br>  Nachbedingungen werden nur gepr√ºft, wenn die Funktion normal abgeschlossen ist. </p><br><p>  Wenn beim √úberpr√ºfen des Ausdrucks im Vertrag eine Ausnahme aufgetreten ist, wird <code>std::terminate()</code> aufgerufen. </p><br><p>  Vor- und Nachbedingungen werden immer au√üerhalb des Funktionsk√∂rpers beschrieben und k√∂nnen nicht auf lokale Variablen zugreifen. </p><br><p>  Wenn Vor- und Nachbedingungen einen Vertrag f√ºr eine √∂ffentliche Klassenmethode beschreiben, k√∂nnen sie nicht auf private und gesch√ºtzte Klassenfelder zugreifen.  Wenn die Klassenmethode gesch√ºtzt ist, besteht Zugriff auf die gesch√ºtzten und √∂ffentlichen Daten der Klasse, jedoch nicht auf private. <br>  Die letzte Einschr√§nkung ist v√∂llig logisch, da der Vertrag Teil der Methodenschnittstelle ist. </p><br><p>  Anweisungen (Invarianten) werden immer im Hauptteil einer Funktion oder Methode beschrieben.  Sie sind von Natur aus Teil der Implementierung.  Dementsprechend k√∂nnen sie auf alle verf√ºgbaren Daten zugreifen.  Einschlie√ülich lokaler Funktionsvariablen sowie privater und gesch√ºtzter Klassenfelder. </p><br><p>  <a href="">Beispiel 1</a> </p><br><p>  Wir definieren zwei Voraussetzungen, eine Nachbedingung und eine Invariante: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> [[ expects: x &gt; y ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// precondition #1 [[ expects: y &gt; 0 ]] // precondition #2 [[ ensures r: r &lt; x ]] // postcondition #3 { int z = (x - x%y) / y; [[ assert: z &gt;= 0 ]]; // assertion return z; } int main() { std::cout &lt;&lt; foo(117, 20) &lt;&lt; std::endl; std::cout &lt;&lt; foo(10, 20) &lt;&lt; std::endl; // &lt;-- contract violation #1 std::cout &lt;&lt; foo(100, -5) &lt;&lt; std::endl; // &lt;-- contract violation #2 return 0; }</span></span></span></span></code> </pre> <br><p>  <a href="">Beispiel 2</a> </p><br><p>  Eine Voraussetzung einer √∂ffentlichen Methode kann sich nicht auf ein gesch√ºtztes oder privates Feld beziehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//protected: int m = 5; public: int foo(int n) [[expects: n &lt; m]] { return n*n; } };</span></span></code> </pre> <br><p>  √Ñnderungen von Variablen innerhalb der durch die Vertragsattribute beschriebenen Ausdr√ºcke sind nicht zul√§ssig.  Wenn es kaputt ist, wird es UB geben. </p><br><p>  Die in den Vertr√§gen beschriebenen Ausdr√ºcke sollten keine Nebenwirkungen haben.  Obwohl Compiler dies √ºberpr√ºfen k√∂nnen, m√ºssen sie dies nicht tun.  Verst√∂√üe gegen diese Anforderung gelten als undefiniertes Verhalten. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: n &lt; m++ ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// UB: Modifies variable m { int k = n*n; [[ assert: ++k &lt; 100 ]] // UB: Modifies variable k return n*n; } };</span></span></span></span></code> </pre> <br><p>  Die Anforderung, den Status des Programms in Vertragsausdr√ºcken nicht zu √§ndern, wird etwas geringer, wenn ich √ºber die Ebenen der Vertragsmodifikatoren und Erstellungsmodi spreche. </p><br><p>  Jetzt stelle ich nur fest, dass das richtige Programm so funktionieren sollte, als g√§be es √ºberhaupt keine Vertr√§ge. </p><br><p>  Wie oben erw√§hnt, k√∂nnen Sie im Vertrag so viele Vor- und Nachbedingungen angeben, wie Sie m√∂chten. <br>  Alle werden der Reihe nach √ºberpr√ºft.  Die Vorbedingungen werden jedoch immer vor der Ausf√ºhrung der Funktion und unmittelbar nach dem Beenden der Funktion √ºberpr√ºft. </p><br><p>  Dies bedeutet, dass die Voraussetzungen immer zuerst √ºberpr√ºft werden, wie im folgenden Beispiel dargestellt: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function"> ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// # 1 [[ ensures r: expr(r) ]] // # 4 [[ expects: expr(n) ]] // # 2 [[ expects: expr(n) ]] // # 3 [[ ensures r: expr(r) ]] // # 5 {...}</span></span></span></span></code> </pre> <br><p>  Ausdr√ºcke in Nachbedingungen k√∂nnen sich nicht nur auf den von der Funktion zur√ºckgegebenen Wert beziehen, sondern auch auf die Argumente der Funktion. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;n)</span></span></span><span class="hljs-function"> [[ ensures: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function"> ]]</span></span>;</code> </pre> <br><p>  In diesem Fall k√∂nnen Sie die R√ºckgabewert-ID weglassen. </p><br><p>  Wenn sich die Nachbedingung auf das Argument der Funktion bezieht, wird dieses Argument <em>am Austrittspunkt der Funktion</em> und nicht am Einstiegspunkt ber√ºcksichtigt, wie dies bei Vorbedingungen der Fall ist. </p><br><p>  Es gibt keine M√∂glichkeit, in der Nachbedingung auf den urspr√ºnglichen Wert (am Funktionseintrittspunkt) zu verweisen. </p><br><p>  <a href="">Beispiel</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;n)</span></span></span><span class="hljs-function"> [[ expects: 3 </span></span>== n ]] [[ ensures: <span class="hljs-number"><span class="hljs-number">4</span></span> == n ]] {++n;}</code> </pre> <br><p>  Pr√§dikate in Vertr√§gen k√∂nnen nur dann auf lokale Variablen verweisen, wenn die Lebensdauer dieser Variablen der Pr√§dikatenberechnungszeit entspricht. </p><br><p>  Beispielsweise k√∂nnen f√ºr <code>constexpr</code> Funktionen nur dann auf lokale Variablen verwiesen werden, wenn sie zur Kompilierungszeit bekannt sind. </p><br><p>  <a href="">Beispiel</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: a &lt;</span></span>= n ]] <span class="hljs-comment"><span class="hljs-comment">// error: `a` is not constexpr [[ expects: n &lt; b ]] // OK { [[assert: n &gt; 2*a]]; // error: `a` is not constexpr [[assert: n &lt; 2*b]]; // OK return 2*n; }</span></span></code> </pre> <br><h3 id="kontrakty-dlya-ukazateley-na-funkciyu">  Vertr√§ge f√ºr Funktionszeiger </h3><br><p>  Sie k√∂nnen keine Vertr√§ge f√ºr einen Funktionszeiger definieren, aber Sie k√∂nnen einem Funktionszeiger die Adresse einer Funktion zuweisen, f√ºr die ein Vertrag definiert ist. </p><br><p>  <a href="">Beispiel</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[expects: n &lt; 10]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*pfoo)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) = &amp;foo;</code> </pre> <br><p>  Das Aufrufen von <code>pfoo(100)</code> verst√∂√üt gegen den Vertrag. </p><br><h3 id="kontrakty-pri-nasledovanii">  Erbvertr√§ge </h3><br><p>  Die klassische Umsetzung des Vertragskonzepts legt nahe, dass Vorbedingungen in Unterklassen geschw√§cht, Nachbedingungen und Invarianten in Unterklassen gest√§rkt werden k√∂nnen. </p><br><p>  In einer C ++ 20-Implementierung ist dies nicht der Fall. </p><br><p>  Erstens sind Invarianten in C ++ 20 Teil einer Implementierung und keine Schnittstelle.  Aus diesem Grund k√∂nnen sie sowohl gest√§rkt als auch geschw√§cht werden.  Wenn die Implementierung der virtuellen Funktion keine <code>assert</code> , wird sie nicht vererbt. </p><br><p>  Zweitens ist es erforderlich, dass beim Erben der Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ODR</a> identisch sind. <br>  Und da Vor- und Nachbedingungen Teil der Schnittstelle sind, m√ºssen sie im Erben genau √ºbereinstimmen. </p><br><p>  Dar√ºber hinaus kann auf die Beschreibung von Vor- und Nachbedingungen w√§hrend der Vererbung verzichtet werden.  Wenn sie jedoch deklariert sind, m√ºssen sie genau mit der Definition in der Basisklasse √ºbereinstimmen. </p><br><p>  <a href="">Beispiel</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: n &lt; 10 ]] [[ ensures r: r &gt; 100 ]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived1</span></span></span><span class="hljs-class"> :</span></span> Base { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> override [[ expects: n &lt; 10 ]] [[ ensures r: r &gt; 100 ]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n*<span class="hljs-number"><span class="hljs-number">2</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived2</span></span></span><span class="hljs-class"> :</span></span> Base { <span class="hljs-comment"><span class="hljs-comment">// Inherits contracts from Base virtual int foo(int n) override { return n*3; } };</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bemerkung</b> <div class="spoiler_text"><p>  Leider <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktioniert</a> das obige Beispiel im experimentellen Compiler nicht wie erwartet. </p><br><p>  Wenn <code>foo</code> von <code>Derived2</code> Vertrag <code>Derived2</code> , wird er nicht von der Basisklasse geerbt.  Dar√ºber hinaus k√∂nnen Sie mit dem Compiler f√ºr eine Unterklasse einen Vertrag ermitteln, der nicht mit dem Basisvertrag √ºbereinstimmt. </p><br><p>  Ein weiterer experimenteller Compilerfehler: </p><br><p>  Der Datensatz sollte syntaktisch korrekt sein </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> override [[expects: n &lt; 10]] </span></span>{...}</code> </pre> <br><p>  In dieser Form habe ich jedoch einen Kompilierungsfehler erhalten </p><br><pre> <code class="bash hljs">inheritance1.cpp:20:36: error: expected <span class="hljs-string"><span class="hljs-string">';'</span></span> at end of declaration list virtual int foo(int n) override ^ ;</code> </pre> <br><p>  und musste ersetzt werden durch </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[expects: n &lt; 10]] override </span></span>{...}</code> </pre> <br><p>  Ich denke, dies liegt an der Besonderheit des experimentellen Compilers, und syntaxkorrekter Code funktioniert in den Release-Versionen von Compilern. </p></div></div><br><h3 id="modifikatory-kontraktov">  Vertragsmodifikatoren </h3><br><p>  Vertragspr√§dikatpr√ºfungen k√∂nnen zus√§tzliche Verarbeitungskosten verursachen. <br>  Daher ist es √ºblich, Vertr√§ge in Entwicklungs- und Test-Builds zu √ºberpr√ºfen und sie im Release-Build zu ignorieren. </p><br><p>  F√ºr diese Zwecke bietet der Standard drei Ebenen von Vertragsmodifikatoren.  Mit Modifikatoren und Compilertasten kann der Programmierer steuern, welche Kontakte in der Baugruppe gepr√ºft und welche ignoriert werden. </p><br><ul><li>  <code>default</code> - Dieser Modifikator wird standardm√§√üig verwendet.  Es wird angenommen, dass die Berechnungskosten f√ºr die √úberpr√ºfung der Ausf√ºhrung eines Ausdrucks mit diesem Modifikator im Vergleich zu den Kosten f√ºr die Berechnung der Funktion selbst <em>gering sind</em> . </li><li>  <code>audit</code> - Dieser Modifikator geht davon aus, dass der Rechenaufwand f√ºr die √úberpr√ºfung der Ausf√ºhrung eines Ausdrucks im Vergleich zu den Kosten f√ºr die Berechnung der Funktion selbst <em>erheblich</em> ist. </li><li>  <code>axiom</code> - Dieser Modifikator wird verwendet, wenn der Ausdruck deklarativ ist.  Zur Laufzeit nicht √ºberpr√ºft.  Dient zur Dokumentation der Schnittstelle einer Funktion zur Verwendung durch statische Analysatoren und einen Compiler-Optimierer.  Ausdr√ºcke mit dem <code>axiom</code> Modifikator <code>axiom</code> zur Laufzeit niemals ausgewertet. </li></ul><br><p>  Beispiel </p><br><pre> <code class="cpp hljs">[[expects: expr]] <span class="hljs-comment"><span class="hljs-comment">//  default [[expects default: expr]] //  default [[expects axiom : expr]] // Run-time    [[expects audit : expr]] //   </span></span></code> </pre> <br><p>  Mithilfe von Modifikatoren k√∂nnen Sie bestimmen, welche √úberpr√ºfungen in welchen Versionen Ihrer Assemblys verwendet und welche deaktiviert werden. </p><br><p>  Es ist anzumerken, dass der Compiler das Recht hat, den Vertrag auch dann f√ºr Optimierungen auf niedriger Ebene zu verwenden, wenn die Pr√ºfung nicht durchgef√ºhrt wird.  Obwohl die Vertrags√ºberpr√ºfung durch das Kompilierungsflag deaktiviert werden kann, f√ºhrt eine Vertragsverletzung zu einem undefinierten Programmverhalten. </p><br><p>  Nach Ermessen des Compilers k√∂nnen Einrichtungen bereitgestellt werden, die die <code>axiom</code> als <code>axiom</code> gekennzeichneten Ausdr√ºcken erm√∂glichen. </p><br><p>  In unserem Fall ist dies eine Compileroption </p><br><pre> <code class="plaintext hljs">-axiom-mode=&lt;mode&gt;</code> </pre> <br><p>  <code>-axiom-mode=on</code> <em>schaltet den</em> Axiom-Modus ein und <code>-axiom-mode=on</code> dementsprechend <em>die</em> √úberpr√ºfung von Anspr√ºchen mit dem Bezeichner- <code>axiom</code> . </p><br><p>  <code>-axiom-mode=off</code> <em>schaltet den</em> Axiom-Modus <em>aus</em> und <em>erm√∂glicht</em> dementsprechend <em>die</em> √úberpr√ºfung von Anweisungen mit dem Bezeichner- <code>axiom</code> . </p><br><p>  <a href="">Beispiel</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[expects axiom: n &lt; 10]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; }</code> </pre><br><p>  Ein Programm kann mit drei verschiedenen √úberpr√ºfungsebenen zusammengestellt werden: </p><br><ul><li>  <code>off</code> schaltet alle Ausdruckspr√ºfungen in Vertr√§gen aus </li><li>  <code>default</code> nur Ausdr√ºcke mit dem <code>default</code> </li><li>  Erweiterten √úberwachungsmodus, wenn alle √úberpr√ºfungen mit dem <code>default</code> und dem √úberwachungsmodifikator durchgef√ºhrt werden </li></ul><br><p>  Wie genau die Installation der Verifizierungsstufe implementiert wird, liegt im Ermessen der Compiler-Entwickler. </p><br><p>  In unserem Fall wird hierf√ºr die Compileroption verwendet </p><br><pre> <code class="bash hljs">-build-level=&lt;off|default|audit&gt;</code> </pre> <br><p>  Der Standardwert ist <code>-build-level=default</code> </p><br><p>  Wie bereits erw√§hnt, kann der Compiler Vertr√§ge f√ºr Optimierungen auf niedriger Ebene verwenden.  Aus diesem Grund f√ºhrt ihre Nichterf√ºllung zu undefiniertem Verhalten, obwohl zum Zeitpunkt der Ausf√ºhrung einige Pr√§dikate in den Vertr√§gen (abh√§ngig vom √úberpr√ºfungsgrad) m√∂glicherweise nicht berechnet werden. </p><br><p>  Ich werde Beispiele f√ºr die Anwendung von Baugruppenebenen auf den n√§chsten Abschnitt verschieben, wo sie visuell dargestellt werden k√∂nnen. </p><br><h3 id="perehvat-narusheniya-kontrakta">  Abfangen von Vertragsverletzungen </h3><br><p>  Je nachdem, welche Optionen das Programm bietet, kann es bei Vertragsbruch zu unterschiedlichen Verhaltensszenarien kommen. </p><br><p>  Standardm√§√üig f√ºhrt eine Vertragsverletzung zum Absturz des Programms und zum Aufruf von <code>std::terminate()</code> .  Der Programmierer kann dieses Verhalten jedoch au√üer Kraft setzen, indem er seinen eigenen Handler bereitstellt und dem Compiler anzeigt, dass das Programm nach Vertragsbruch fortgesetzt werden muss. </p><br><p>  Bei der Kompilierung k√∂nnen Sie den <em>Versto√übehandler</em> installieren, der aufgerufen wird, wenn der Vertrag verletzt wird. </p><br><p>  Die Implementierung der Installation des Handlers liegt im Ermessen der Ersteller des Compilers. </p><br><p>  In unserem Fall dies </p><br><pre> <code class="bash hljs">-contract-violation-handler=&lt;violation_handler&gt;</code> </pre> <br><p>  Die Prozessorsignatur sollte sein </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::contract_violation&amp; info)</code> </pre> <br><p>  oder </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::contract_violation&amp; info) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span></code> </pre> <br><p>  <code>std::contract_violation</code> entspricht der folgenden Definition: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">contract_violation</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint_least32_t</span></span> line_number() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertion_level</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; };</code> </pre> <br><p>  Auf diese Weise erhalten Sie mit dem Handler umfassende Informationen dar√ºber, wo und unter welchen Bedingungen eine Vertragsverletzung aufgetreten ist. </p><br><p>  Wenn der <em>Handler f√ºr</em> die <em>Verletzung von Handlern</em> angegeben ist, wird im Falle einer Vertragsverletzung standardm√§√üig <code>std::abort()</code> sofort nach seiner Ausf√ºhrung aufgerufen (ohne Angabe des Handlers wird <code>std::terminate()</code> aufgerufen). </p><br><p>  Der Standard geht davon aus, dass Compiler Tools bereitstellen, mit denen Programmierer ein Programm nach Vertragsbruch weiter ausf√ºhren k√∂nnen. </p><br><p>  Die Implementierung dieser Tools liegt im Ermessen der Compiler-Entwickler. <br>  In unserem Fall ist dies eine Compileroption </p><br><pre> <code class="bash hljs">-fcontinue-after-violation</code> </pre> <br><p>  Die <code>-fcontinue-after-violation</code> und <code>-contract-violation-handler</code> k√∂nnen unabh√§ngig voneinander festgelegt werden.  Beispielsweise k√∂nnen Sie <code>-fcontinue-after-violation</code> <code>-contract-violation-handler</code> , aber nicht <code>-contract-violation-handler</code> .  Im letzteren Fall funktioniert das Programm nach einer Vertragsverletzung einfach weiter. </p><br><p>  Die M√∂glichkeit, das Programm nach einer Vertragsverletzung fortzusetzen, ist im Standard festgelegt. Diese Funktion muss jedoch mit Vorsicht angewendet werden. </p><br><p>  Technisch gesehen ist das Verhalten eines Programms nach Vertragsbruch nicht definiert, auch wenn der Programmierer ausdr√ºcklich angegeben hat, dass das Programm weiter funktionieren soll. </p><br><p>  Dies liegt daran, dass der Compiler Optimierungen auf niedriger Ebene basierend auf der Vertragsausf√ºhrung durchf√ºhren kann. </p><br><p>  Im Idealfall m√ºssen Sie bei Vertragsbruch Diagnoseinformationen so schnell wie m√∂glich aufzeichnen und das Programm beenden.  Sie m√ºssen genau verstehen, was Sie tun, indem Sie zulassen, dass das Programm nach einem Versto√ü funktioniert. </p><br><p>  Definieren Sie <a href="">Ihren Handler</a> und verwenden Sie ihn, um eine Vertragsverletzung abzufangen </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">violation_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::contract_violation&amp; info)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"line_number : "</span></span> &lt;&lt; info.line_number() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"file_name : "</span></span> &lt;&lt; info.file_name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"function_name : "</span></span> &lt;&lt; info.function_name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"comment : "</span></span> &lt;&lt; info.comment() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"assertion_level : "</span></span> &lt;&lt; info.assertion_level() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Betrachten Sie <a href="">ein Beispiel</a> f√ºr eine Vertragsverletzung: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"violation_handler.h"</span></span></span><span class="hljs-meta"> int foo(int n) [[expects: n &lt; 10]] { return n*n; } int main() { foo(100); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;-- contract violation return 0; }</span></span></span></span></code> </pre> <br><p>  Wir kompilieren das Programm mit den Optionen <code>-contract-violation-handler=violation_handler</code> <code>-fcontinue-after-violation</code> und <code>-fcontinue-after-violation</code> und f√ºhren es aus </p><br><pre> <code class="bash hljs">$ bin/example8-handling.bin line_number : 4 file_name : example8-handling.cpp function_name : foo comment : n &lt; 10 assertion_level : default</code> </pre> <br><p>  Jetzt k√∂nnen wir Beispiele geben, die das Verhalten des Programms bei Vertragsbruch auf verschiedenen Montageebenen und Vertragsmodi demonstrieren. </p><br><p>  Betrachten Sie das folgende <a href="">Beispiel</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"violation_handler.h"</span></span></span><span class="hljs-meta"> int foo(int n) [[ expects axiom : n &lt; 100 ]] [[ expects default : n &lt; 200 ]] [[ expects audit : n &lt; 300 ]] { return 2 * n; } int main() { foo(350); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// audit foo(250); // default return 0; }</span></span></span></span></code> </pre> <br><p>  Wenn Sie es mit der Option <code>-build-level=off</code> , werden die Vertr√§ge erwartungsgem√§√ü nicht √ºberpr√ºft. </p><br><p>  <code>-build-level=default</code> wir die <code>default</code> (mit der Option <code>-build-level=default</code> ) <code>-build-level=default</code> , erhalten wir die folgende Ausgabe: </p><br><pre> <code class="bash hljs">$ bin/example9-default.bin line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default</code> </pre> <br><p>  Und die Versammlung mit der <code>audit</code> Ebene wird geben: </p><br><pre> <code class="bash hljs"> $ bin/example9-audit.bin line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default line_number : 6 file_name : example9.cpp function_name : foo comment : n &lt; 300 assertion_level : audit line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default</code> </pre> <br><h4 id="zamechaniya">  Bemerkungen </h4><br><p>  <code>violation_handler</code> kann Ausnahmen ausl√∂sen.  In diesem Fall k√∂nnen Sie das Programm so konfigurieren, dass eine Vertragsverletzung zum Ausl√∂sen einer Ausnahme f√ºhrt. </p><br><p>  Wenn die Funktion, deren Vertr√§ge beschrieben sind, als <code>noexcept</code> markiert <code>noexcept</code> und bei der √úberpr√ºfung der Vertragsverletzung_handler aufgerufen wird, was eine Ausnahme <code>noexcept</code> , wird <code>std::terminate()</code> aufgerufen. </p><br><p>  <a href="">Beispiel</a> </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">violation_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::contract_violation&amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> [[ expects: n &gt; 0 ]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;-- std::terminate() when violation handler throws an exception return 0; }</span></span></code> </pre> <br><p>  Wenn das Flag an den Compiler √ºbergeben wird: F√ºhren Sie das Programm nach Vertragsbruch nicht weiter aus ( <code>continuation mode=off</code> ), aber der Versto√übehandler l√∂st eine Ausnahme aus, dann wird <code>std::terminate()</code> erzwungen. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Vertr√§ge beziehen sich auf nicht aufdringliche Laufzeitpr√ºfungen.  Sie spielen eine sehr wichtige Rolle bei der Sicherstellung der Qualit√§t der ver√∂ffentlichten Software. </p><br><p>  C ++ wird sehr h√§ufig verwendet.  Und mit Sicherheit wird es eine ausreichende Anzahl von Anspr√ºchen auf die Spezifikation von Vertr√§gen geben.  Meiner subjektiven Meinung nach erwies sich die Implementierung als sehr praktisch und visuell. </p><br><p>  C ++ 20-Vertr√§ge machen unsere Programme noch zuverl√§ssiger, schneller und verst√§ndlicher.  Ich freue mich auf ihre Implementierung in Compilern. </p><br><hr><br><p>  PS <br>  In PM sagen sie mir, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wahrscheinlich</a> in der endg√ºltigen Version des Standards <code>expects</code> und <code>ensures</code> wird <code>ensures</code> durch <code>pre</code> bzw. <code>post</code> ersetzt zu werden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443766/">https://habr.com/ru/post/de443766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443752/index.html">Kotlin als Zukunft der Android App-Entwicklung</a></li>
<li><a href="../de443754/index.html">Informationen zur Angemessenheit von Selenium WebDriverWait</a></li>
<li><a href="../de443756/index.html">Klassendesign: Was ist gut?</a></li>
<li><a href="../de443758/index.html">Quick Draw Doodle Recognition: So machen Sie Freunde R, C ++ und Neuronale Gitter</a></li>
<li><a href="../de443764/index.html">Was der Designer geraucht hat: eine ungew√∂hnliche Waffe</a></li>
<li><a href="../de443768/index.html">Monolith f√ºr Hunderte von Client-Versionen: Wie wir Tests schreiben und unterst√ºtzen</a></li>
<li><a href="../de443772/index.html">Antiquit√§ten: IBM ThinkPad T40, das erste drahtlose Ger√§t</a></li>
<li><a href="../de443774/index.html">Wie sich die Neurobiologie in US-Pr√§sidentschaftswahlen einmischt</a></li>
<li><a href="../de443776/index.html">China f√ºhrt ein experimentelles Gesichtserkennungssystem ein, wenn es f√ºr die U-Bahn bezahlt</a></li>
<li><a href="../de443780/index.html">MCDM-Projekt. Teil 1. Konzept</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>