<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏿 🚜 👩🏻 Probieren Sie jetzt C ++ 20 Contract Programming aus 🕋 📩 🈴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C ++ 20 wurde die Vertragsprogrammierung angezeigt. Bisher hat noch kein Compiler die Unterstützung für diese Funktion implementiert. 


 Es gibt j...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Probieren Sie jetzt C ++ 20 Contract Programming aus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443766/"><p><img src="https://habrastorage.org/webt/ow/o1/yv/owo1yvuvpymi1w4uoa1olkjoo0g.png"></p><br><p>  In C ++ 20 wurde die Vertragsprogrammierung angezeigt.  Bisher hat noch kein Compiler die Unterstützung für diese Funktion implementiert. </p><br><p>  Es gibt jetzt jedoch eine Möglichkeit, Verträge aus C ++ 20 zu verwenden, wie im Standard beschrieben. </p><a name="habracut"></a><br><h3 id="tldr">  TL; DR </h3><br><p>  <em>Es gibt ein Gabelgeräusch, das Verträge unterstützt.</em>  <em>Anhand seines Beispiels erkläre ich Ihnen, wie Sie Verträge verwenden, damit Sie sofort mit der Verwendung einer Funktion in Ihrem bevorzugten Compiler beginnen können.</em> </p><br><p>  Es wurde bereits viel über Vertragsprogrammierung geschrieben, aber kurz gesagt, ich werde Ihnen sagen, was es ist und wofür es ist. </p><br><h2 id="logika-hoara">  Logik von Hoar </h2><br><p>  Das Paradigma der Verträge basiert auf der Hoar-Logik ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> ). </p><br><p> Hoar-Logik ist ein Weg, um die Richtigkeit eines Algorithmus formal zu beweisen. <br>  Es arbeitet mit Konzepten wie Vorbedingung, Nachbedingung und Invariante. <br>  Aus praktischer Sicht ist die Verwendung der Hoar-Logik zum einen eine Möglichkeit, die Richtigkeit eines Programms in Fällen, in denen Fehler zu Katastrophen oder zum Tod führen können, formal zu beweisen.  Zweitens eine Möglichkeit, die Zuverlässigkeit des Programms zusammen mit statischen Analysen und Tests zu erhöhen. </p><br><h2 id="kontraktnoe-programmirovanie">  Vertragsprogrammierung </h2><br><p>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> ) </p><br><p>  Die Hauptidee von Verträgen besteht darin, dass in Analogie zu Geschäftsverträgen Vereinbarungen für jede Funktion oder Methode beschrieben werden.  Diese Vorkehrungen müssen sowohl vom Anrufer als auch vom Anrufer beachtet werden. <br>  Ein wesentlicher Bestandteil von Verträgen sind mindestens zwei Montagemodi - Debugging und Lebensmittelgeschäft.  Verträge sollten sich je nach Erstellungsmodus unterschiedlich verhalten.  Am häufigsten werden Verträge in der Debug-Assembly überprüft und im Lebensmittelgeschäft ignoriert. </p><br><p>  Manchmal werden Verträge auch in der Produktmontage geprüft und ihre Nichterfüllung kann beispielsweise zur Entstehung einer Ausnahme führen. </p><br><p>  Der Hauptunterschied zwischen der Verwendung von Verträgen aus dem „klassischen“ Ansatz besteht darin, dass der Anrufer die im Vertrag beschriebenen Voraussetzungen des Angerufenen erfüllen muss und der Anrufer seine Nachbedingungen und Invarianten einhalten muss. <br>  Dementsprechend ist der angerufene Teilnehmer nicht verpflichtet, die Richtigkeit seiner Parameter zu überprüfen.  Diese Verpflichtung wird dem Anrufer vertraglich übertragen. </p><br><p>  Die Nichteinhaltung von Verträgen sollte in der Testphase festgestellt werden und ergänzt alle Arten von Tests: modulare Integration usw. </p><br><p>  Auf den ersten Blick erschwert die Verwendung von Verträgen die Entwicklung und beeinträchtigt die Lesbarkeit des Codes.  In der Tat ist das genaue Gegenteil der Fall.  Anhänger der statischen Typisierung können die Vorteile von Verträgen am einfachsten bewerten, da ihre einfachste Option darin besteht, Typen in der Signatur von Methoden und Funktionen zu beschreiben. </p><br><p>  Was sind die Vorteile von Verträgen: </p><br><ul><li>  Verbessern Sie die Lesbarkeit des Codes durch explizite Dokumentation. </li><li>  Verbessern Sie die Codezuverlässigkeit durch ergänzende Tests. </li><li>  Ermöglichen Sie Compilern, Optimierungen auf niedriger Ebene zu verwenden und schnelleren Code basierend auf der Einhaltung von Verträgen zu generieren.  Im letzteren Fall kann die Nichteinhaltung des Vertrags in der Freigabemontage zu UB führen. </li></ul><br><h2 id="kontraktnoe-programmirovanie-v-c">  Vertragsprogrammierung in C ++ </h2><br><p>  Die Vertragsprogrammierung ist in vielen Sprachen implementiert.  Die auffälligsten Beispiele sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eiffel</a> , wo das Paradigma zuerst implementiert wurde, und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">D</a> in D-Verträgen sind Teil der Sprache. </p><br><p>  In C ++ konnten Verträge vor dem C ++ 20-Standard als separate Bibliotheken verwendet werden. </p><br><p>  Dieser Ansatz hat mehrere Nachteile: </p><br><ul><li>  Sehr ungeschickte Syntax mit Makros. </li><li>  Das Fehlen eines einzigen Stils. </li><li>  Unfähigkeit, Verträge des Compilers zur Optimierung des Codes zu verwenden. </li></ul><br><p>  Bibliotheksimplementierungen basieren normalerweise auf der Verwendung der guten alten Assert- und Präprozessor-Direktiven, die nach dem Kompilierungsflag suchen. </p><br><p>  Die Verwendung von Verträgen in dieser Form macht den Code wirklich hässlich und unlesbar.  Dies ist einer der Gründe, warum die Verwendung von Verträgen in C ++ wenig praktiziert wird. </p><br><p>  Mit Blick auf die Zukunft werde ich zeigen, wie die Verwendung von Verträgen in C ++ 20 aussehen wird. <br>  Und dann werden wir das alles genauer analysieren: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> [[ expects: x &gt; 0 ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// precondition [[ expects: y &gt; 0 ]] // precondition [[ ensures r: r &lt; x + y ]] // postcondition { int z = (x - x%y) / y; [[ assert: z &gt;= 0 ]]; // assertion return z + y; }</span></span></span></span></code> </pre> <br><h2 id="probuem">  Versuchen Sie es </h2><br><p>  Leider hat derzeit noch keiner der weit verbreiteten Compiler eine Vertragsunterstützung implementiert. <br>  Aber es gibt einen Ausweg. </p><br><p>  <em>Die ARCOS-Forschungsgruppe</em> der <em>Universidad Carlos III de Madrid</em> implementierte experimentelle Unterstützung für Verträge in der Clang ++ - Gabel. </p><br><p>  Um nicht „Code auf ein Blatt Papier zu schreiben“, sondern sofort neue Geschäftsmöglichkeiten ausprobieren zu können, können wir diese Gabel sammeln und damit die folgenden Beispiele ausprobieren. </p><br><p>  Montageanleitungen sind in der Readme-Datei des Github-Repositorys beschrieben <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/arcosuc3m/clang-contracts</a> </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/arcosuc3m/clang-contracts/ mkdir -p clang-contracts/build/ &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> clang-contracts/build/ cmake -G <span class="hljs-string"><span class="hljs-string">"Unix Makefiles"</span></span> -DLLVM_USE_LINKER=gold -DBUILD_SHARED_LIBS=ON -DLLVM_USE_SPLIT_DWARF=ON -DLLVM_OPTIMIZED_TABLEGEN=ON ../ make -j8</code> </pre> <br><p>  Ich hatte während der Montage keine Probleme, aber das Kompilieren der Quellen dauert sehr lange. </p><br><p>  Um die Beispiele zu kompilieren, müssen Sie den Pfad zur Clang ++ - Binärdatei explizit angeben. <br>  Zum Beispiel sieht es für mich so aus </p><br><pre> <code class="bash hljs">/home/valmat/work/git/clang-contracts/build/bin/clang++ -std=c++2a -build-level=audit -g test.cpp -o test.bin</code> </pre> <br><p>  Ich habe Beispiele vorbereitet, damit Sie Verträge anhand von Beispielen mit echtem Code prüfen können.  Ich schlage vor, bevor Sie mit dem Lesen des nächsten Abschnitts beginnen, Beispiele zu klonen und zu kompilieren. </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/valmat/cpp20-contracts-examples/ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> cpp20-contracts-examples make CPP=/path/to/clang++</code> </pre> <br><p>  Hier ist <code>/path/to/clang++</code> Pfad zur <code>clang++</code> Binärdatei Ihrer experimentellen Compiler-Assembly. </p><br><p>  Zusätzlich zum Compiler selbst hat die ARCOS-Forschungsgruppe ihre Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compiler-Explorers</a> für ihre Abzweigung vorbereitet. </p><br><h2 id="kontraktnoe-programmirovanie-v-c20">  Vertragsprogrammierung in C ++ 20 </h2><br><p>  Jetzt hindert uns nichts mehr daran, die Möglichkeiten der Vertragsprogrammierung zu erforschen und diese Möglichkeiten sofort in der Praxis auszuprobieren. </p><br><p>  Wie oben erwähnt, werden Verträge aus Vorbedingungen, Nachbedingungen und Invarianten (Aussagen) aufgebaut. </p><br><p>  In C ++ 20 werden hierfür Attribute mit folgender Syntax verwendet </p><br><pre> <code class="cpp hljs">[[contract-attribute modifier identifier: conditional-expression]]</code> </pre> <br><p>  Wobei das <code>contract-attribute</code> einen der folgenden Werte annehmen kann: <br>  <strong>erwartet</strong> , <strong>sichert</strong> oder <strong>behauptet</strong> . </p><br><p>  <code>expects</code> für Vorbedingungen verwendet, <code>ensures</code> für Nachbedingungen <code>ensures</code> und <code>assert</code> für Aussagen. </p><br><p>  <code>conditional-expression</code> ist ein boolescher Ausdruck, der in einem Vertragsprädikat validiert wird. <br>  <code>modifier</code> und <code>identifier</code> können weggelassen werden. </p><br><p>  Warum brauche ich einen <code>modifier</code> Ich werde etwas tiefer schreiben. </p><br><p>  <code>identifier</code> nur mit <code>ensures</code> und dient zur Darstellung des Rückgabewerts. </p><br><p>  Voraussetzungen haben Zugriff auf Argumente. </p><br><p>  Nachbedingungen haben Zugriff auf den von der Funktion zurückgegebenen Wert.  Hierfür wird die Syntax verwendet. </p><br><pre> <code class="cpp hljs">[[ensures return_variable: expr(return_variable)]]</code> </pre> <br><p>  Wobei <code>return_variable</code> ein gültiger Ausdruck für die Variable ist. </p><br><p>  Mit anderen Worten, Vorbedingungen sollen Einschränkungen deklarieren, die Argumenten auferlegt werden, die von der Funktion akzeptiert werden, und Nachbedingungen, um Einschränkungen zu deklarieren, die dem von der Funktion zurückgegebenen Wert auferlegt werden. </p><br><p>  Es wird angenommen, dass <em>Vor-</em> und <em>Nachbedingungen</em> Teil der Funktionsschnittstelle sind, während <em>Anweisungen</em> Teil ihrer Implementierung sind. </p><br><p>  Voraussetzungsprädikate werden immer unmittelbar vor der Ausführung der Funktion ausgewertet.  Die Nachbedingungen sind unmittelbar nach Übergabe der Steuerfunktion an den aufrufenden Code erfüllt. </p><br><p>  Wenn in einer Funktion eine Ausnahme ausgelöst wird, wird die Nachbedingung nicht überprüft. <br>  Nachbedingungen werden nur geprüft, wenn die Funktion normal abgeschlossen ist. </p><br><p>  Wenn beim Überprüfen des Ausdrucks im Vertrag eine Ausnahme aufgetreten ist, wird <code>std::terminate()</code> aufgerufen. </p><br><p>  Vor- und Nachbedingungen werden immer außerhalb des Funktionskörpers beschrieben und können nicht auf lokale Variablen zugreifen. </p><br><p>  Wenn Vor- und Nachbedingungen einen Vertrag für eine öffentliche Klassenmethode beschreiben, können sie nicht auf private und geschützte Klassenfelder zugreifen.  Wenn die Klassenmethode geschützt ist, besteht Zugriff auf die geschützten und öffentlichen Daten der Klasse, jedoch nicht auf private. <br>  Die letzte Einschränkung ist völlig logisch, da der Vertrag Teil der Methodenschnittstelle ist. </p><br><p>  Anweisungen (Invarianten) werden immer im Hauptteil einer Funktion oder Methode beschrieben.  Sie sind von Natur aus Teil der Implementierung.  Dementsprechend können sie auf alle verfügbaren Daten zugreifen.  Einschließlich lokaler Funktionsvariablen sowie privater und geschützter Klassenfelder. </p><br><p>  <a href="">Beispiel 1</a> </p><br><p>  Wir definieren zwei Voraussetzungen, eine Nachbedingung und eine Invariante: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> [[ expects: x &gt; y ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// precondition #1 [[ expects: y &gt; 0 ]] // precondition #2 [[ ensures r: r &lt; x ]] // postcondition #3 { int z = (x - x%y) / y; [[ assert: z &gt;= 0 ]]; // assertion return z; } int main() { std::cout &lt;&lt; foo(117, 20) &lt;&lt; std::endl; std::cout &lt;&lt; foo(10, 20) &lt;&lt; std::endl; // &lt;-- contract violation #1 std::cout &lt;&lt; foo(100, -5) &lt;&lt; std::endl; // &lt;-- contract violation #2 return 0; }</span></span></span></span></code> </pre> <br><p>  <a href="">Beispiel 2</a> </p><br><p>  Eine Voraussetzung einer öffentlichen Methode kann sich nicht auf ein geschütztes oder privates Feld beziehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//protected: int m = 5; public: int foo(int n) [[expects: n &lt; m]] { return n*n; } };</span></span></code> </pre> <br><p>  Änderungen von Variablen innerhalb der durch die Vertragsattribute beschriebenen Ausdrücke sind nicht zulässig.  Wenn es kaputt ist, wird es UB geben. </p><br><p>  Die in den Verträgen beschriebenen Ausdrücke sollten keine Nebenwirkungen haben.  Obwohl Compiler dies überprüfen können, müssen sie dies nicht tun.  Verstöße gegen diese Anforderung gelten als undefiniertes Verhalten. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: n &lt; m++ ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// UB: Modifies variable m { int k = n*n; [[ assert: ++k &lt; 100 ]] // UB: Modifies variable k return n*n; } };</span></span></span></span></code> </pre> <br><p>  Die Anforderung, den Status des Programms in Vertragsausdrücken nicht zu ändern, wird etwas geringer, wenn ich über die Ebenen der Vertragsmodifikatoren und Erstellungsmodi spreche. </p><br><p>  Jetzt stelle ich nur fest, dass das richtige Programm so funktionieren sollte, als gäbe es überhaupt keine Verträge. </p><br><p>  Wie oben erwähnt, können Sie im Vertrag so viele Vor- und Nachbedingungen angeben, wie Sie möchten. <br>  Alle werden der Reihe nach überprüft.  Die Vorbedingungen werden jedoch immer vor der Ausführung der Funktion und unmittelbar nach dem Beenden der Funktion überprüft. </p><br><p>  Dies bedeutet, dass die Voraussetzungen immer zuerst überprüft werden, wie im folgenden Beispiel dargestellt: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function"> ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// # 1 [[ ensures r: expr(r) ]] // # 4 [[ expects: expr(n) ]] // # 2 [[ expects: expr(n) ]] // # 3 [[ ensures r: expr(r) ]] // # 5 {...}</span></span></span></span></code> </pre> <br><p>  Ausdrücke in Nachbedingungen können sich nicht nur auf den von der Funktion zurückgegebenen Wert beziehen, sondern auch auf die Argumente der Funktion. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;n)</span></span></span><span class="hljs-function"> [[ ensures: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function"> ]]</span></span>;</code> </pre> <br><p>  In diesem Fall können Sie die Rückgabewert-ID weglassen. </p><br><p>  Wenn sich die Nachbedingung auf das Argument der Funktion bezieht, wird dieses Argument <em>am Austrittspunkt der Funktion</em> und nicht am Einstiegspunkt berücksichtigt, wie dies bei Vorbedingungen der Fall ist. </p><br><p>  Es gibt keine Möglichkeit, in der Nachbedingung auf den ursprünglichen Wert (am Funktionseintrittspunkt) zu verweisen. </p><br><p>  <a href="">Beispiel</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;n)</span></span></span><span class="hljs-function"> [[ expects: 3 </span></span>== n ]] [[ ensures: <span class="hljs-number"><span class="hljs-number">4</span></span> == n ]] {++n;}</code> </pre> <br><p>  Prädikate in Verträgen können nur dann auf lokale Variablen verweisen, wenn die Lebensdauer dieser Variablen der Prädikatenberechnungszeit entspricht. </p><br><p>  Beispielsweise können für <code>constexpr</code> Funktionen nur dann auf lokale Variablen verwiesen werden, wenn sie zur Kompilierungszeit bekannt sind. </p><br><p>  <a href="">Beispiel</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: a &lt;</span></span>= n ]] <span class="hljs-comment"><span class="hljs-comment">// error: `a` is not constexpr [[ expects: n &lt; b ]] // OK { [[assert: n &gt; 2*a]]; // error: `a` is not constexpr [[assert: n &lt; 2*b]]; // OK return 2*n; }</span></span></code> </pre> <br><h3 id="kontrakty-dlya-ukazateley-na-funkciyu">  Verträge für Funktionszeiger </h3><br><p>  Sie können keine Verträge für einen Funktionszeiger definieren, aber Sie können einem Funktionszeiger die Adresse einer Funktion zuweisen, für die ein Vertrag definiert ist. </p><br><p>  <a href="">Beispiel</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[expects: n &lt; 10]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*pfoo)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) = &amp;foo;</code> </pre> <br><p>  Das Aufrufen von <code>pfoo(100)</code> verstößt gegen den Vertrag. </p><br><h3 id="kontrakty-pri-nasledovanii">  Erbverträge </h3><br><p>  Die klassische Umsetzung des Vertragskonzepts legt nahe, dass Vorbedingungen in Unterklassen geschwächt, Nachbedingungen und Invarianten in Unterklassen gestärkt werden können. </p><br><p>  In einer C ++ 20-Implementierung ist dies nicht der Fall. </p><br><p>  Erstens sind Invarianten in C ++ 20 Teil einer Implementierung und keine Schnittstelle.  Aus diesem Grund können sie sowohl gestärkt als auch geschwächt werden.  Wenn die Implementierung der virtuellen Funktion keine <code>assert</code> , wird sie nicht vererbt. </p><br><p>  Zweitens ist es erforderlich, dass beim Erben der Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ODR</a> identisch sind. <br>  Und da Vor- und Nachbedingungen Teil der Schnittstelle sind, müssen sie im Erben genau übereinstimmen. </p><br><p>  Darüber hinaus kann auf die Beschreibung von Vor- und Nachbedingungen während der Vererbung verzichtet werden.  Wenn sie jedoch deklariert sind, müssen sie genau mit der Definition in der Basisklasse übereinstimmen. </p><br><p>  <a href="">Beispiel</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: n &lt; 10 ]] [[ ensures r: r &gt; 100 ]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived1</span></span></span><span class="hljs-class"> :</span></span> Base { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> override [[ expects: n &lt; 10 ]] [[ ensures r: r &gt; 100 ]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n*<span class="hljs-number"><span class="hljs-number">2</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived2</span></span></span><span class="hljs-class"> :</span></span> Base { <span class="hljs-comment"><span class="hljs-comment">// Inherits contracts from Base virtual int foo(int n) override { return n*3; } };</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bemerkung</b> <div class="spoiler_text"><p>  Leider <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktioniert</a> das obige Beispiel im experimentellen Compiler nicht wie erwartet. </p><br><p>  Wenn <code>foo</code> von <code>Derived2</code> Vertrag <code>Derived2</code> , wird er nicht von der Basisklasse geerbt.  Darüber hinaus können Sie mit dem Compiler für eine Unterklasse einen Vertrag ermitteln, der nicht mit dem Basisvertrag übereinstimmt. </p><br><p>  Ein weiterer experimenteller Compilerfehler: </p><br><p>  Der Datensatz sollte syntaktisch korrekt sein </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> override [[expects: n &lt; 10]] </span></span>{...}</code> </pre> <br><p>  In dieser Form habe ich jedoch einen Kompilierungsfehler erhalten </p><br><pre> <code class="bash hljs">inheritance1.cpp:20:36: error: expected <span class="hljs-string"><span class="hljs-string">';'</span></span> at end of declaration list virtual int foo(int n) override ^ ;</code> </pre> <br><p>  und musste ersetzt werden durch </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[expects: n &lt; 10]] override </span></span>{...}</code> </pre> <br><p>  Ich denke, dies liegt an der Besonderheit des experimentellen Compilers, und syntaxkorrekter Code funktioniert in den Release-Versionen von Compilern. </p></div></div><br><h3 id="modifikatory-kontraktov">  Vertragsmodifikatoren </h3><br><p>  Vertragsprädikatprüfungen können zusätzliche Verarbeitungskosten verursachen. <br>  Daher ist es üblich, Verträge in Entwicklungs- und Test-Builds zu überprüfen und sie im Release-Build zu ignorieren. </p><br><p>  Für diese Zwecke bietet der Standard drei Ebenen von Vertragsmodifikatoren.  Mit Modifikatoren und Compilertasten kann der Programmierer steuern, welche Kontakte in der Baugruppe geprüft und welche ignoriert werden. </p><br><ul><li>  <code>default</code> - Dieser Modifikator wird standardmäßig verwendet.  Es wird angenommen, dass die Berechnungskosten für die Überprüfung der Ausführung eines Ausdrucks mit diesem Modifikator im Vergleich zu den Kosten für die Berechnung der Funktion selbst <em>gering sind</em> . </li><li>  <code>audit</code> - Dieser Modifikator geht davon aus, dass der Rechenaufwand für die Überprüfung der Ausführung eines Ausdrucks im Vergleich zu den Kosten für die Berechnung der Funktion selbst <em>erheblich</em> ist. </li><li>  <code>axiom</code> - Dieser Modifikator wird verwendet, wenn der Ausdruck deklarativ ist.  Zur Laufzeit nicht überprüft.  Dient zur Dokumentation der Schnittstelle einer Funktion zur Verwendung durch statische Analysatoren und einen Compiler-Optimierer.  Ausdrücke mit dem <code>axiom</code> Modifikator <code>axiom</code> zur Laufzeit niemals ausgewertet. </li></ul><br><p>  Beispiel </p><br><pre> <code class="cpp hljs">[[expects: expr]] <span class="hljs-comment"><span class="hljs-comment">//  default [[expects default: expr]] //  default [[expects axiom : expr]] // Run-time    [[expects audit : expr]] //   </span></span></code> </pre> <br><p>  Mithilfe von Modifikatoren können Sie bestimmen, welche Überprüfungen in welchen Versionen Ihrer Assemblys verwendet und welche deaktiviert werden. </p><br><p>  Es ist anzumerken, dass der Compiler das Recht hat, den Vertrag auch dann für Optimierungen auf niedriger Ebene zu verwenden, wenn die Prüfung nicht durchgeführt wird.  Obwohl die Vertragsüberprüfung durch das Kompilierungsflag deaktiviert werden kann, führt eine Vertragsverletzung zu einem undefinierten Programmverhalten. </p><br><p>  Nach Ermessen des Compilers können Einrichtungen bereitgestellt werden, die die <code>axiom</code> als <code>axiom</code> gekennzeichneten Ausdrücken ermöglichen. </p><br><p>  In unserem Fall ist dies eine Compileroption </p><br><pre> <code class="plaintext hljs">-axiom-mode=&lt;mode&gt;</code> </pre> <br><p>  <code>-axiom-mode=on</code> <em>schaltet den</em> Axiom-Modus ein und <code>-axiom-mode=on</code> dementsprechend <em>die</em> Überprüfung von Ansprüchen mit dem Bezeichner- <code>axiom</code> . </p><br><p>  <code>-axiom-mode=off</code> <em>schaltet den</em> Axiom-Modus <em>aus</em> und <em>ermöglicht</em> dementsprechend <em>die</em> Überprüfung von Anweisungen mit dem Bezeichner- <code>axiom</code> . </p><br><p>  <a href="">Beispiel</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[expects axiom: n &lt; 10]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; }</code> </pre><br><p>  Ein Programm kann mit drei verschiedenen Überprüfungsebenen zusammengestellt werden: </p><br><ul><li>  <code>off</code> schaltet alle Ausdrucksprüfungen in Verträgen aus </li><li>  <code>default</code> nur Ausdrücke mit dem <code>default</code> </li><li>  Erweiterten Überwachungsmodus, wenn alle Überprüfungen mit dem <code>default</code> und dem Überwachungsmodifikator durchgeführt werden </li></ul><br><p>  Wie genau die Installation der Verifizierungsstufe implementiert wird, liegt im Ermessen der Compiler-Entwickler. </p><br><p>  In unserem Fall wird hierfür die Compileroption verwendet </p><br><pre> <code class="bash hljs">-build-level=&lt;off|default|audit&gt;</code> </pre> <br><p>  Der Standardwert ist <code>-build-level=default</code> </p><br><p>  Wie bereits erwähnt, kann der Compiler Verträge für Optimierungen auf niedriger Ebene verwenden.  Aus diesem Grund führt ihre Nichterfüllung zu undefiniertem Verhalten, obwohl zum Zeitpunkt der Ausführung einige Prädikate in den Verträgen (abhängig vom Überprüfungsgrad) möglicherweise nicht berechnet werden. </p><br><p>  Ich werde Beispiele für die Anwendung von Baugruppenebenen auf den nächsten Abschnitt verschieben, wo sie visuell dargestellt werden können. </p><br><h3 id="perehvat-narusheniya-kontrakta">  Abfangen von Vertragsverletzungen </h3><br><p>  Je nachdem, welche Optionen das Programm bietet, kann es bei Vertragsbruch zu unterschiedlichen Verhaltensszenarien kommen. </p><br><p>  Standardmäßig führt eine Vertragsverletzung zum Absturz des Programms und zum Aufruf von <code>std::terminate()</code> .  Der Programmierer kann dieses Verhalten jedoch außer Kraft setzen, indem er seinen eigenen Handler bereitstellt und dem Compiler anzeigt, dass das Programm nach Vertragsbruch fortgesetzt werden muss. </p><br><p>  Bei der Kompilierung können Sie den <em>Verstoßbehandler</em> installieren, der aufgerufen wird, wenn der Vertrag verletzt wird. </p><br><p>  Die Implementierung der Installation des Handlers liegt im Ermessen der Ersteller des Compilers. </p><br><p>  In unserem Fall dies </p><br><pre> <code class="bash hljs">-contract-violation-handler=&lt;violation_handler&gt;</code> </pre> <br><p>  Die Prozessorsignatur sollte sein </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::contract_violation&amp; info)</code> </pre> <br><p>  oder </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::contract_violation&amp; info) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span></code> </pre> <br><p>  <code>std::contract_violation</code> entspricht der folgenden Definition: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">contract_violation</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint_least32_t</span></span> line_number() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertion_level</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; };</code> </pre> <br><p>  Auf diese Weise erhalten Sie mit dem Handler umfassende Informationen darüber, wo und unter welchen Bedingungen eine Vertragsverletzung aufgetreten ist. </p><br><p>  Wenn der <em>Handler für</em> die <em>Verletzung von Handlern</em> angegeben ist, wird im Falle einer Vertragsverletzung standardmäßig <code>std::abort()</code> sofort nach seiner Ausführung aufgerufen (ohne Angabe des Handlers wird <code>std::terminate()</code> aufgerufen). </p><br><p>  Der Standard geht davon aus, dass Compiler Tools bereitstellen, mit denen Programmierer ein Programm nach Vertragsbruch weiter ausführen können. </p><br><p>  Die Implementierung dieser Tools liegt im Ermessen der Compiler-Entwickler. <br>  In unserem Fall ist dies eine Compileroption </p><br><pre> <code class="bash hljs">-fcontinue-after-violation</code> </pre> <br><p>  Die <code>-fcontinue-after-violation</code> und <code>-contract-violation-handler</code> können unabhängig voneinander festgelegt werden.  Beispielsweise können Sie <code>-fcontinue-after-violation</code> <code>-contract-violation-handler</code> , aber nicht <code>-contract-violation-handler</code> .  Im letzteren Fall funktioniert das Programm nach einer Vertragsverletzung einfach weiter. </p><br><p>  Die Möglichkeit, das Programm nach einer Vertragsverletzung fortzusetzen, ist im Standard festgelegt. Diese Funktion muss jedoch mit Vorsicht angewendet werden. </p><br><p>  Technisch gesehen ist das Verhalten eines Programms nach Vertragsbruch nicht definiert, auch wenn der Programmierer ausdrücklich angegeben hat, dass das Programm weiter funktionieren soll. </p><br><p>  Dies liegt daran, dass der Compiler Optimierungen auf niedriger Ebene basierend auf der Vertragsausführung durchführen kann. </p><br><p>  Im Idealfall müssen Sie bei Vertragsbruch Diagnoseinformationen so schnell wie möglich aufzeichnen und das Programm beenden.  Sie müssen genau verstehen, was Sie tun, indem Sie zulassen, dass das Programm nach einem Verstoß funktioniert. </p><br><p>  Definieren Sie <a href="">Ihren Handler</a> und verwenden Sie ihn, um eine Vertragsverletzung abzufangen </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">violation_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::contract_violation&amp; info)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"line_number : "</span></span> &lt;&lt; info.line_number() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"file_name : "</span></span> &lt;&lt; info.file_name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"function_name : "</span></span> &lt;&lt; info.function_name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"comment : "</span></span> &lt;&lt; info.comment() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"assertion_level : "</span></span> &lt;&lt; info.assertion_level() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Betrachten Sie <a href="">ein Beispiel</a> für eine Vertragsverletzung: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"violation_handler.h"</span></span></span><span class="hljs-meta"> int foo(int n) [[expects: n &lt; 10]] { return n*n; } int main() { foo(100); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;-- contract violation return 0; }</span></span></span></span></code> </pre> <br><p>  Wir kompilieren das Programm mit den Optionen <code>-contract-violation-handler=violation_handler</code> <code>-fcontinue-after-violation</code> und <code>-fcontinue-after-violation</code> und führen es aus </p><br><pre> <code class="bash hljs">$ bin/example8-handling.bin line_number : 4 file_name : example8-handling.cpp function_name : foo comment : n &lt; 10 assertion_level : default</code> </pre> <br><p>  Jetzt können wir Beispiele geben, die das Verhalten des Programms bei Vertragsbruch auf verschiedenen Montageebenen und Vertragsmodi demonstrieren. </p><br><p>  Betrachten Sie das folgende <a href="">Beispiel</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"violation_handler.h"</span></span></span><span class="hljs-meta"> int foo(int n) [[ expects axiom : n &lt; 100 ]] [[ expects default : n &lt; 200 ]] [[ expects audit : n &lt; 300 ]] { return 2 * n; } int main() { foo(350); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// audit foo(250); // default return 0; }</span></span></span></span></code> </pre> <br><p>  Wenn Sie es mit der Option <code>-build-level=off</code> , werden die Verträge erwartungsgemäß nicht überprüft. </p><br><p>  <code>-build-level=default</code> wir die <code>default</code> (mit der Option <code>-build-level=default</code> ) <code>-build-level=default</code> , erhalten wir die folgende Ausgabe: </p><br><pre> <code class="bash hljs">$ bin/example9-default.bin line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default</code> </pre> <br><p>  Und die Versammlung mit der <code>audit</code> Ebene wird geben: </p><br><pre> <code class="bash hljs"> $ bin/example9-audit.bin line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default line_number : 6 file_name : example9.cpp function_name : foo comment : n &lt; 300 assertion_level : audit line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default</code> </pre> <br><h4 id="zamechaniya">  Bemerkungen </h4><br><p>  <code>violation_handler</code> kann Ausnahmen auslösen.  In diesem Fall können Sie das Programm so konfigurieren, dass eine Vertragsverletzung zum Auslösen einer Ausnahme führt. </p><br><p>  Wenn die Funktion, deren Verträge beschrieben sind, als <code>noexcept</code> markiert <code>noexcept</code> und bei der Überprüfung der Vertragsverletzung_handler aufgerufen wird, was eine Ausnahme <code>noexcept</code> , wird <code>std::terminate()</code> aufgerufen. </p><br><p>  <a href="">Beispiel</a> </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">violation_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::contract_violation&amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> [[ expects: n &gt; 0 ]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;-- std::terminate() when violation handler throws an exception return 0; }</span></span></code> </pre> <br><p>  Wenn das Flag an den Compiler übergeben wird: Führen Sie das Programm nach Vertragsbruch nicht weiter aus ( <code>continuation mode=off</code> ), aber der Verstoßbehandler löst eine Ausnahme aus, dann wird <code>std::terminate()</code> erzwungen. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Verträge beziehen sich auf nicht aufdringliche Laufzeitprüfungen.  Sie spielen eine sehr wichtige Rolle bei der Sicherstellung der Qualität der veröffentlichten Software. </p><br><p>  C ++ wird sehr häufig verwendet.  Und mit Sicherheit wird es eine ausreichende Anzahl von Ansprüchen auf die Spezifikation von Verträgen geben.  Meiner subjektiven Meinung nach erwies sich die Implementierung als sehr praktisch und visuell. </p><br><p>  C ++ 20-Verträge machen unsere Programme noch zuverlässiger, schneller und verständlicher.  Ich freue mich auf ihre Implementierung in Compilern. </p><br><hr><br><p>  PS <br>  In PM sagen sie mir, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wahrscheinlich</a> in der endgültigen Version des Standards <code>expects</code> und <code>ensures</code> wird <code>ensures</code> durch <code>pre</code> bzw. <code>post</code> ersetzt zu werden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443766/">https://habr.com/ru/post/de443766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443752/index.html">Kotlin als Zukunft der Android App-Entwicklung</a></li>
<li><a href="../de443754/index.html">Informationen zur Angemessenheit von Selenium WebDriverWait</a></li>
<li><a href="../de443756/index.html">Klassendesign: Was ist gut?</a></li>
<li><a href="../de443758/index.html">Quick Draw Doodle Recognition: So machen Sie Freunde R, C ++ und Neuronale Gitter</a></li>
<li><a href="../de443764/index.html">Was der Designer geraucht hat: eine ungewöhnliche Waffe</a></li>
<li><a href="../de443768/index.html">Monolith für Hunderte von Client-Versionen: Wie wir Tests schreiben und unterstützen</a></li>
<li><a href="../de443772/index.html">Antiquitäten: IBM ThinkPad T40, das erste drahtlose Gerät</a></li>
<li><a href="../de443774/index.html">Wie sich die Neurobiologie in US-Präsidentschaftswahlen einmischt</a></li>
<li><a href="../de443776/index.html">China führt ein experimentelles Gesichtserkennungssystem ein, wenn es für die U-Bahn bezahlt</a></li>
<li><a href="../de443780/index.html">MCDM-Projekt. Teil 1. Konzept</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>