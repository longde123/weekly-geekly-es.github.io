<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíâ üõåüèø üèì S√©lection, mise en cache et affichage de photos sur la carte üòú üë©üèø‚Äçüåæ üìë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, j'ai d√©cid√© de d√©crire comment la fonctionnalit√© de s√©lection et d'affichage de photos sur un endroit sp√©cifique sur la carte a √©t√© ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>S√©lection, mise en cache et affichage de photos sur la carte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440410/"><p>  Dans cet article, j'ai d√©cid√© de d√©crire comment la fonctionnalit√© de s√©lection et d'affichage de photos sur un endroit sp√©cifique sur la carte a √©t√© impl√©ment√©e dans notre service photo <em>gfranq.com</em> .  Le service photo ne fonctionne pas maintenant. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/storage2/709/48a/e52/70948ae52bacb687d1b882fa7405bed5.jpg"></div><p></p><br><p>  √âtant donn√© que nous avions beaucoup de photos dans notre service et que nous envoyions des demandes √† la base de donn√©es chaque fois que les modifications de la fen√™tre √©taient trop gourmandes en ressources, il √©tait logique de diviser la carte en plusieurs zones contenant des informations sur les donn√©es r√©cup√©r√©es.  Pour des raisons √©videntes, ces zones ont une forme rectangulaire (bien que la grille hexagonale ait √©galement √©t√© consid√©r√©e).  Comme les zones deviennent plus sph√©riques √† grande √©chelle, des √©l√©ments de g√©om√©trie sph√©rique et des outils pour celle-ci ont √©galement √©t√© pris en compte. </p><br><p>  Dans cet article, les probl√®mes suivants ont √©t√© soulev√©s: </p><br><ul><li>  Stocker et r√©cup√©rer des photos de la base de donn√©es et les mettre en cache sur le serveur (SQL, C #, ASP.NET). </li><li>  T√©l√©charger les photos n√©cessaires du c√¥t√© client et les enregistrer dans le cache client (JavaScript). </li><li>  Recalcul des photos qui doivent √™tre masqu√©es ou affich√©es lorsque la fen√™tre change. </li><li>  √âl√©ments de g√©om√©trie sph√©rique. </li></ul><a name="habracut"></a><br><h2 id="contents">  Table des mati√®res </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie serveur</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">G√©otypes int√©gr√©s</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">S√©lection normale</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation d'une table de hachage suppl√©mentaire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mise en cache des photos pour un acc√®s multi-thread</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C√¥t√© client</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Initialisation de la carte</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©terminer la g√©olocalisation √† l'aide de HTML5</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©terminer la g√©olocalisation √† l'aide des informations du serveur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Calcul de zones rectangulaires partiellement visibles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Calcul de la taille des zones de mise en cache</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation du d√©lai lors du redessin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Calcul des coordonn√©es et des hachages des zones partiellement visibles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Redessiner les photos affich√©es</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Distance sur la carte</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusion</a> </li></ul><br><h2 id="server-part">  Partie serveur </h2><br><p>  Les m√©thodes suivantes de s√©lection et de stockage de la g√©oinformation dans la base de donn√©es ont √©t√© con√ßues: </p><br><ul><li>  Type de donn√©es g√©ographiques int√©gr√©es √† SQL Server. </li><li>  S√©lection normale avec restrictions. </li><li>  Utilisation de tableaux suppl√©mentaires. </li></ul><br><p>  De plus, ces m√©thodes seront d√©crites en d√©tail. </p><br><h3 id="built-in-geotypes">  G√©otypes int√©gr√©s </h3><br><p> Comme on le sait, SQL Server 2008 prend en charge les types de donn√©es g√©ographiques et g√©om√©triques, qui permettent de sp√©cifier des informations g√©ographiques (sur la sph√®re) et g√©om√©triques (sur le plan), telles que des points, des lignes, des polygones, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">etc.</a>  .  Afin de r√©cup√©rer toutes les photos entour√©es d'un rectangle avec les coordonn√©es ( <code>lngMin</code> <code>latMin</code> ) et ( <code>latMax</code> <code>lngMax</code> ), vous pouvez utiliser la requ√™te suivante: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @h geography; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @p geography; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @rect = geography::STGeomFromText(<span class="hljs-string"><span class="hljs-string">'POLYGON((lngMin latMin, lngMax latMin, lngMax latMax, lngMin latMax, lngMin latMin))'</span></span>, <span class="hljs-number"><span class="hljs-number">4326</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP @cound <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, image75Path, geoTag.Lat <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Lat, geoTag.Long <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Lng, popularity, width, height <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Photo <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span>(IX_Photo_geoTag)) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> @rect.STContains(geoTag) = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> popularity <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> </pre> <br><p>  Notez que le polygone est orient√© dans le sens antihoraire et que l'index spatial <code>IX_Photo_geoTag</code> d√©fini par les coordonn√©es est utilis√© (en outre, les index spatiaux sont construits √† l'aide d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arbres B</a> ). </p><br><p>  Cependant, il s'est av√©r√© que dans Microsoft SQL Server 2008, les index spatiaux ne fonctionnent pas si la colonne avec des g√©otypes peut accepter des valeurs <code>NULL</code> et qu'un index composite ne peut pas contenir une colonne avec un type de donn√©es g√©ographiques, et cette question a √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discut√©e sur Stackoverflow</a> .  C'est pourquoi les performances de ces requ√™tes (sans index) deviennent tr√®s faibles. </p><br><p>  Les approches suivantes peuvent r√©soudre ce probl√®me: </p><br><ul><li>  √âtant donn√© que les valeurs <code>NULL</code> ne peuvent pas √™tre utilis√©es, les valeurs par d√©faut pour cette colonne sont des coordonn√©es (0, 0) qui pointent vers un emplacement dans l'oc√©an Atlantique pr√®s de l'Afrique (le point de d√©part pour mesurer la latitude et la longitude).  Cependant, √† cet endroit ainsi qu'√† proximit√©, les vrais points peuvent √™tre localis√©s, et les photos ne provenant pas de la carte doivent √™tre ignor√©es.  Si vous changez le point z√©ro (0, 0) en point extr√™me nord (0, 90), alors tout ira beaucoup mieux, car la latitude 90 pointe vers le bord de la carte, et vous devez ignorer cette valeur lors de la construction de la grille (c.-√†-d. construire jusqu'√† la latitude 89). </li><li>  Utilisation de SQL Server 2012 ou sup√©rieur et modification du niveau de compatibilit√© de la base de donn√©es √† 110 ou sup√©rieur en ex√©cutant <code>ALTER DATABASE database_name SET COMPATIBILITY_LEVEL = 110</code> .  Dans cette version de SQL Server, le bogue avec les valeurs <code>NULL</code> des g√©otypes a √©t√© corrig√© et la prise en charge de polygones d'orientations diff√©rentes (sens antihoraire et horaire) a √©t√© ajout√©e. </li></ul><br><p>  Malgr√© les vastes possibilit√©s des g√©otypes (ils vous permettent de faire non seulement une simple s√©lection comme illustr√© ci-dessus, mais aussi d'utiliser des distances et diff√©rents polygones), nous ne les avons pas utilis√©s dans notre projet. </p><br><h3 id="normal-selection">  S√©lection normale </h3><br><p>  Pour s√©lectionner des photos dans la zone d√©limit√©e par les coordonn√©es ( <code>lngMin</code> <code>latMin</code> ) et ( <code>latMax</code> <code>lngMax</code> ), utilisez la requ√™te suivante: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP @<span class="hljs-keyword"><span class="hljs-keyword">Count</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>, ... <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Photo <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> latitude &gt; @latMin <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> longitude &gt; @lngMin <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> latitude &lt; @latMax <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> longitude &lt; @lngMax <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> popularity <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> </pre> <br><p>  Notez que dans ce cas, vous pouvez cr√©er des index pour les champs de <code>latitude</code> et de <code>longitude</code> (contrairement √† la premi√®re m√©thode), car un type de donn√©es float ordinaire est utilis√©.  Cependant, il y a 4 op√©rations de comparaison dans cette s√©lection. </p><br><h3 id="using-additional-hash-table">  Utilisation d'une table de hachage suppl√©mentaire </h3><br><p>  La solution la plus optimale au probl√®me de s√©lection de photos dans certaines zones consiste √† cr√©er des <code>Zooms</code> table <code>Zooms</code> qui stockent des cha√Ænes contenant des hachages de zones pour chaque zoom, comme indiqu√© ci-dessous. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/dd2/696/223/dd269622322fa5b688101ba38ef68f10.png"></div><br><p>  La requ√™te SQL suivante peut √™tre utilis√©e ( <code>zn</code> - niveau de zoom actuel): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">hash</span></span> <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">hash</span></span> = (@latMin + <span class="hljs-number"><span class="hljs-number">90</span></span>) + (@lngMin + <span class="hljs-number"><span class="hljs-number">180</span></span>) * <span class="hljs-number"><span class="hljs-number">180</span></span> + (@latMax + <span class="hljs-number"><span class="hljs-number">90</span></span>) * <span class="hljs-number"><span class="hljs-number">64800</span></span> + (@lngMax + <span class="hljs-number"><span class="hljs-number">180</span></span>) * <span class="hljs-number"><span class="hljs-number">11664000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP @<span class="hljs-keyword"><span class="hljs-keyword">Count</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>, ... <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Photo <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Zooms <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> zn = @<span class="hljs-keyword"><span class="hljs-keyword">hash</span></span>)</code> </pre> <br><p>  L'inconv√©nient de cette approche est que la table suppl√©mentaire occupe un espace m√©moire suppl√©mentaire. </p><br><p>  Malgr√© les avantages de cette derni√®re m√©thode, nous avons utilis√© la deuxi√®me m√©thode ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©lection normale</a> ) sur le serveur, car elle montrait de bonnes performances. </p><br><h3 id="caching-photos-for-multi-threaded-access">  Mise en cache des photos pour un acc√®s multi-thread </h3><br><p>  Apr√®s avoir extrait les informations de la base de donn√©es d'une mani√®re ou d'une autre, les photos sont plac√©es dans le cache du serveur √† l'aide de l'objet de synchronisation pour prendre en charge le multithreading comme suit: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SyncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); ... List&lt;Photo&gt; photos = (List&lt;Photo&gt;)CachedAreas[hash]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (photos == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Use lock to avoid extracting from and adding to the cache more than once. lock (SyncObject) { photos = (List&lt;Photo&gt;)CachedAreas[hash]; if (photos == null) { photos = PhotoList.GetAllFromRect(latMin, lngMin, latMax, lngMax, count); // Adding information about photos to the cache with a storage time of 2 minutes with a high storage priority. CachedAreas.Add(hash, photos, null, DateTime.Now.AddSeconds(120), Cache.NoSlidingExpiration, CacheItemPriority.High, null); } } } // Further usage of CachedAreas[hash]</span></span></code> </pre> <br><p>  Cette section d√©crit la fonctionnalit√© du serveur pour r√©cup√©rer des photos de la base de donn√©es et les enregistrer dans le cache.  La section suivante d√©crira ce qui se passe du c√¥t√© client dans le navigateur. </p><br><h2 id="client-side">  C√¥t√© client </h2><br><p>  Pour visualiser la carte et les photos qu'elle contient, l'API Google Maps a √©t√© utilis√©e.  Tout d'abord, la carte utilisateur doit √™tre d√©plac√©e √† un certain endroit, correspondant √† la g√©olocalisation des photos. </p><br><h3 id="initializing-the-map">  Initialisation de la carte </h3><br><p>  Il existe deux fa√ßons de d√©terminer la g√©olocalisation lors de l'initialisation de la carte: utiliser les capacit√©s de HTML5 ou utiliser des coordonn√©es pr√©-calcul√©es pour les r√©gions. </p><br><h4 id="determining-the-geolocation-using-html5">  D√©terminer la g√©olocalisation √† l'aide de HTML5 </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detectRegion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navigator.geolocation) { navigator.geolocation.getCurrentPosition(success); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { map.setZoom(defaultZoom); map.setCenter(defaultPoint); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">success</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">position</span></span></span><span class="hljs-function">) </span></span>{ ... map.setZoom(defaultZoom); map.setCenter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> google.maps.LatLng(position.coords.latitude, position.coords.longitude)); }</code> </pre> <br><p>  L'inconv√©nient de cette approche est que tous les navigateurs ne prennent pas en charge cette fonctionnalit√© de HTML5 et l'utilisateur peut ne pas autoriser l'acc√®s √† la g√©oinformation sur son appareil. </p><br><h4 id="determining-the-geolocation-using-information-from-the-server">  D√©terminer la g√©olocalisation √† l'aide des informations du serveur </h4><br><p>  La carte est initialis√©e dans la section du code source ci-dessous, o√π les <code>bounds</code> sont les coordonn√©es de la r√©gion (zone peupl√©e, r√©gion ou pays) renvoy√©es par le serveur.  Le niveau de zoom approximatif est calcul√© dans la fonction <code>getZoomFromBounds</code> (prise √† partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stackoverflow</a> ). </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> northEast = bounds.getNorthEast(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> southWest = bounds.getSouthWest(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myOptions = { <span class="hljs-attr"><span class="hljs-attr">zoom</span></span>: getZoomFromBounds(northEast, southWest), <span class="hljs-attr"><span class="hljs-attr">center</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> google.maps.LatLng((northEast.lat() + southWest.lat()) / <span class="hljs-number"><span class="hljs-number">2</span></span>, (northEast.lng() + southWest.lng()) / <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-attr"><span class="hljs-attr">mapTypeId</span></span>: google.maps.MapTypeId.ROADMAP, <span class="hljs-attr"><span class="hljs-attr">minZoom</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxZoom</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span> } map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> google.maps.Map(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"map_canvas"</span></span>), myOptions);</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getZoomFromBounds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ne, sw</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GLOBE_WIDTH = <span class="hljs-number"><span class="hljs-number">256</span></span>; <span class="hljs-comment"><span class="hljs-comment">// a constant in Google's map projection var west = sw.lng(); var east = ne.lng(); var angle = east - west; if (angle &lt; 0) { angle += 360; } return Math.round(Math.log($('#map_canvas').width() * 360 / angle / GLOBE_WIDTH) / Math.LN2); }</span></span></code> </pre> <br><p>  Sur le serveur, les r√©gions sont calcul√©es en fonction de l'adresse IP de l'utilisateur.  Pour agr√©ger toutes les coordonn√©es des limites de chaque r√©gion, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API de g√©ocodage Google a</a> √©t√© utilis√©e, bien qu'il ne soit pas l√©gitime d'utiliser ces informations hors ligne;  en outre, il y a une limite de 2500 demandes par jour.  Pour chaque ville, r√©gion et pays de notre base de donn√©es, une requ√™te a √©t√© g√©n√©r√©e qui a renvoy√© les limites requises de la <code>viewport</code> et des <code>bounds</code> .  Ils ne diff√®rent que pour les grandes zones qui ne peuvent pas entrer compl√®tement dans la fen√™tre  Si le serveur a renvoy√© une erreur, d'autres requ√™tes ont √©t√© utilis√©es dans lesquelles la langue maternelle de cette r√©gion ou l'anglais a √©t√© utilis√©e, la partie {Zone peupl√©e} a √©t√© supprim√©e, etc. <code>http://maps.googleapis.com/maps/api/geocode/xml?address={Country},{Region},{Populated area}&amp;sensor=false</code> </p><br><p>  Par exemple, pour la requ√™te suivante: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://maps.googleapis.com/maps/api/geocode/xml?address=Russia, zone Ivanovo% 20, Ivanovo &amp; sensor = false</a> </p><br><div class="spoiler">  <b class="spoiler_title">Les coordonn√©es suivantes seront retourn√©es (fragment)</b> <div class="spoiler_text"><pre> <code class="html hljs xml">... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>56.9951313<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>40.9796047<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location_type</span></span></span><span class="hljs-tag">&gt;</span></span>APPROXIMATE<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location_type</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">viewport</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>56.9420231<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>40.8765941<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>57.0703221<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>41.0876169<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">viewport</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bounds</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>56.9420231<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>40.8765941<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>57.0703221<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>41.0876169<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bounds</span></span></span><span class="hljs-tag">&gt;</span></span> ...</code> </pre> </div></div><br><h3 id="calculating-partially-visible-rectangular-areas">  Calcul de zones rectangulaires partiellement visibles </h3><br><h4 id="calculating-the-size-of-caching-areas">  Calcul de la taille des zones de mise en cache </h4><br><p>  Ainsi, comme mentionn√© pr√©c√©demment, toutes les photos c√¥t√© client et c√¥t√© serveur sont mises en cache par des zones rectangulaires, dont le point de d√©part est un point arbitraire (dans notre cas, le point avec les coordonn√©es (0, 0)), et la taille est calcul√©e en fonction sur le niveau de zoom actuel comme suit: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// The initial window at which initMapSizeLat and initMapSizeLng were calculated var initDefaultDimX = 1000, var initDefaultDimY = 800; // The current default viewport which depends on the size of the areas. var currentDefaultDimX = 1080, var currentDefaultDimY = 500; var initMapSizeLat = 0.0003019; var initMapSizeLng = 0.00067055; // The coefficient of size reduction (increase). var initRatio = 0.75; // To calculate the size of the smallest caching area, the map was zoomed in to the maximum zoom level // Ie initMapSizeLat and initMapSizeLng were calculated empirically. var initZoomSize = new google.maps.Size( initMapSizeLat / initDefaultDimX * currentDefaultDimX * initRatio, initMapSizeLng / initDefaultDimY * currentDefaultDimY * initRatio); // All subsequent sizes of areas can be calculated based only on the smallest area (by multiplying each size by 2, because with increasing the zoom level by 1, the linear dimensions increase by 2 times, and the quadratic dimensions increase by 4 times). function initZoomSizes() { zoomSizes = []; var coef = 1; for (var i = 21; i &gt;= 0; i--) { zoomSizes[i] = new google.maps.Size(initZoomSize.width * coef, initZoomSize.height * coef); coef *= 2; } }</span></span></code> </pre> <br><p>  Ainsi, √† chaque niveau de zoom, la taille de la zone rectangulaire est de <code>0.75^2=0.5625</code> rapport √† la taille de la fen√™tre courante, si elle a une largeur de 1080px et une hauteur de 500px. </p><br><h4 id="using-delay-when-redrawing">  Utilisation du d√©lai lors du redessin </h4><br><p>  √âtant donn√© que le redessin de toutes les photos sur la carte n'est pas une op√©ration rapide (comme cela sera montr√© plus loin), nous avons d√©cid√© de le faire avec un certain retard apr√®s l'entr√©e de l'utilisateur: </p><br><pre> <code class="javascript hljs">google.maps.event.addListener(map, <span class="hljs-string"><span class="hljs-string">'bounds_changed'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boundsChangedInverval != <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) clearInterval(boundsChangedInverval); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zoom = map.getZoom(); boundsChangedInverval = setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ boundsChanged(); }, prevZoom === zoom ? moveUpdateDelay : zoomUpdateDelay); prevZoom = zoom; });</code> </pre> <br><h4 id="calculating-coordinates-and-hashes-of-partially-visible-areas">  Calcul des coordonn√©es et des hachages des zones partiellement visibles </h4><br><p>  Le calcul des coordonn√©es et des hachages de tous les rectangles qui chevauchent la fen√™tre visible avec des coordonn√©es ( <code>latMin</code> , <code>lngMin</code> ) et des dimensions calcul√©es en utilisant l'algorithme d√©crit pr√©c√©demment se fait comme suit: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/d8f/63a/bd7/d8f63abd76978f82b66bd0cc5a06311e.png"></div><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = zoomSizes[zoom]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLat = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((latMin - initPoint.x) / s.width) * s.width + initPoint.x; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLng = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((lngMin - initPoint.y) / s.height) * s.height + initPoint.y; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lat = beginLat; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lng = beginLng; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lngMax &lt;= beginLng) beginLng = beginLng - <span class="hljs-number"><span class="hljs-number">360</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (lat &lt;= maxlat) { lng = beginLng; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (lng &lt;= maxLng) { <span class="hljs-comment"><span class="hljs-comment">// lat and normalizeLng(lng) coordinates are the coordinates of the overlapping rectangles. // Longitude normalization is used because the right boundary can be greater than 180 or the left boundary can be less than -180. loadIfNeeded(lat, normalizeLng(lng)); lng += s.height; } lat += s.width; } function normalizeLng(lng) { var rtn = lng % 360; if (rtn &lt;= 0) rtn += 360; if (rtn &gt; 180) rtn -= 360; return rtn; }</span></span></code> </pre> <br><p>  Apr√®s cela, pour chaque zone, la fonction suivante est appel√©e, qui envoie la demande au serveur, si n√©cessaire.  La formule de calcul du hachage renvoie une valeur unique pour chaque zone, car le point de d√©part et les dimensions sont fixes. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadIfNeeded</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lat, lng</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = calculateHash(lat, lng, zoom); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(hash <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items)) { <span class="hljs-comment"><span class="hljs-comment">// Send a query to the database and put this cell in the client cache. } else { // Do nothing. } } function calculateHash(lat, lng, zoom) { // lat: [-90..90] // lng: [-180..180] return (lat + 90) + ((lng + 180) * 180) + (zoom * 64800); }</span></span></code> </pre> <br><h3 id="redrawing-the-displayed-photos">  Redessiner les photos affich√©es </h3><br><p>  Une fois toutes les photos t√©l√©charg√©es ou extraites du cache, certaines doivent √™tre redessin√©es.  Avec un grand nombre de photos ou de marqueurs au m√™me endroit, certaines doivent √™tre masqu√©es, mais il devient alors difficile de savoir combien de photos se trouvent √† cet endroit.  Pour r√©soudre ce probl√®me, nous avons d√©cid√© de prendre en charge deux types de marqueurs: les marqueurs affichant des photos et les marqueurs indiquant qu'il y a des photos √† cet endroit.  En outre, si tous les marqueurs sont masqu√©s lorsque les limites sont modifi√©es, puis sont r√©affich√©s, l'utilisateur peut remarquer un scintillement.  Pour r√©soudre ces probl√®mes, l'algorithme suivant a √©t√© d√©velopp√©: </p><br><ol><li>  Extraction de toutes les photos visibles du cache client vers le tableau <code>visMarks</code> .  Le calcul de ces zones avec des photos a √©t√© d√©crit ci-dessus. </li><li>  Tri des marqueurs re√ßus par popularit√©. </li><li>  Recherche de marqueurs superpos√©s √† l'aide de <code>markerSize</code> , <code>SmallMarkerSize</code> , <code>minPhotoDistRatio</code> et <code>pixelDistance</code> . </li><li>  Cr√©ation de tableaux de grands marqueurs avec <code>maxBigVisPhotosCount</code> et de petits marqueurs avec <code>maxSmlVisPhotosCount</code> . </li><li>  D√©finir les anciens marqueurs qui doivent √™tre masqu√©s et les ajouter √† <code>smlMarksToHide</code> et <code>bigMarksToHide</code> aide de <code>refreshMarkerArrays</code> . </li><li>  Mise √† jour de l'index de visibilit√© et de zoom <code>zIndex</code> pour les nouveaux marqueurs qui devraient √™tre affich√©s √† l'aide de <code>updateMarkersVis</code> . </li><li>  Ajout de photos, qui sont devenues visibles √† l'heure actuelle, au flux √† l'aide d' <code>addPhotoToRibbon</code> . </li></ol><br><div class="spoiler">  <b class="spoiler_title">Algorithme de recalcul des marqueurs visibles</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redraw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ isRedrawing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visMarker; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visMarks = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visBigMarks2; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visSmlMarks2; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bigMarksToHide = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> smlMarksToHide = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> photo; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bounds = map.getBounds(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> northEast = bounds.getNorthEast(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> southWest = bounds.getSouthWest(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> latMin = southWest.lat(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lngMin = southWest.lng(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> latMax = northEast.lat(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lngMax = northEast.lng(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ratio = (latMax - latMin) / $(<span class="hljs-string"><span class="hljs-string">"#map_canvas"</span></span>).height(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zoom = map.getZoom(); visMarks = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = zoomSizes[zoom]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLat = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((latMin - initPoint.x) / s.width) * s.width + initPoint.x; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLng = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((lngMin - initPoint.y) / s.height) * s.height + initPoint.y; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lat = beginLat; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lng = beginLng; i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lngMax &lt;= beginLng) beginLng = beginLng - <span class="hljs-number"><span class="hljs-number">360</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Extracting all visible markers. while (lat &lt;= latMax) { lng = beginLng; while (lng &lt;= lngMax) { var hash = calcHash(lat, normLng(lng), zoom); if (!(hash in curItems)) { } else { var item = curItems[hash]; for (photo in item.photos) { if (bounds.contains(item.photos[photo].latLng)) { visMarks[i] = item.photos[photo]; visMarks[i].overlapCount = 0; i++; } } } k++; lng += s.height; } lat += s.width; } // Sorting markers by popularity. visMarks.sort(function (a, b) { if (b.priority !== a.priority) { return b.priority - a.priority; } else if (b.popularity !== a.popularity) { return b.popularity - a.popularity; } else { return b.id - a.id; } }); // Finding overlapping markers and markers that exceed a certain specified number. var curInd; var contains; var contains2; var dist; visBigMarks2 = []; visSmlMarks2 = []; for (i = 0; i &lt; visMarks.length; i++) { contains = false; contains2 = false; visMarker = visMarks[i]; for (j = 0; j &lt; visBigMarks2.length; j++) { dist = pixelDistance(visMarker.latLng, visBigMarks2[j].latLng, zoom); if (dist &lt;= markerSize * minPhotoDistRatio) { contains = true; if (contains &amp;&amp; contains2) break; } if (dist &lt;= (markerSize + smallMarkerSize) / 2) { contains2 = true; if (contains &amp;&amp; contains2) break; } } if (!contains) { if (visBigMarks2.length &lt; maxBigVisPhotosCount) { smlMarksToHide[smlMarksToHide.length] = visMarker; visBigMarks2[visBigMarks2.length] = visMarker; } } else { bigMarksToHide[bigMarksToHide.length] = visMarker; if (!contains2 &amp;&amp; visSmlMarks2.length &lt; maxSmlVisPhotosCount) { visSmlMarks2[visSmlMarks2.length] = visMarker; } else { visBigMarks2[j].overlapCount++; } } } // Adding markers that should be hidden to smlMarksToHide and bigMarksToHide. refreshMarkerArrays(visibleSmallMarkers, visSmlMarks2, smlMarksToHide); refreshMarkerArrays(visibleBigMarkers, visBigMarks2, bigMarksToHide); // Hiding invisible markers and displaying visible markers when zIndex changes. var curZInd = maxBigVisPhotosCount + 1; curZInd = updateMarkersVis(visBigMarks2, bigMarksToHide, true, curZInd); curZInd = 0; curZInd = updateMarkersVis(visSmlMarks2, smlMarksToHide, false, curZInd); visibleBigMarkers = visBigMarks2; visibleSmallMarkers = visSmlMarks2; // Adding visible photos to the feed. trPhotosOnMap.innerHTML = ''; for (var marker in visBigMarks2) { addPhotoToRibbon(visBigMarks2[marker]); } isRedrawing = false; } function refreshMarkerArrays(oldArr, newArr, toHide) { for (var j = 0; j &lt; oldArr.length; j++) { contains = false; var visMarker = oldArr[j]; for (i = 0; i &lt; newArr.length; i++) { if (newArr[i].id === visMarker.id) { contains = true; break; } } if (!contains) { toHide[toHide.length] = visMarker; } } } function updateMarkersVis(showArr, hideArr, big, curZInd) { var marker; var bounds = map.getBounds(); for (var i = 0; i &lt; showArr.length; i++) { var photo = showArr[i]; if (big) { marker = photo.bigMarker; $('#divOvlpCount' + photo.id).html(photo.overlapCount); } else { marker = photo.smlMarker; } marker.setZIndex(++curZInd); if (marker.getMap() === null) { marker.setMap(map); } } for (i = 0; i &lt; hideArr.length; i++) { marker = big ? hideArr[i].bigMarker : hideArr[i].smlMarker; if (marker.getMap() !== null) { marker.setMap(null); marker.setZIndex(0); if (!bounds.contains(hideArr[i].latLng)) hideArr[i].priority = 0; } } return curZInd; } function addPhotoToRibbon(marker) { var td = createColumn(marker); if (isLatLngValid(marker.latLng)) { trPhotosOnMap.appendChild(td); } else { trPhotosNotOnMap.appendChild(td); if (photoViewMode == 'user') { var img = $("#photo" + marker.id).children()[0]; $('#photo' + marker.id).draggable({ helper: 'clone', appendTo: $('#map_canvas'), stop: function (e) { var mapBoundingRect = document.getElementById("map_canvas").getBoundingClientRect(); var point = new google.maps.Point(e.pageX - mapBoundingRect.left, e.pageY - mapBoundingRect.top); var latLng = overlay.getProjection().fromContainerPixelToLatLng(point); marker.latLng = latLng; marker.priority = ++curPriority; placeMarker(marker); }, containment: 'parent', distance: 5 }); } } }</span></span></code> </pre> </div></div><br><h4 id="distance-on-the-map">  Distance sur la carte </h4><br><p>  Pour calculer la distance entre deux points de la carte en <em>pixels,</em> la fonction suivante est utilis√©e: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Offset = <span class="hljs-number"><span class="hljs-number">268435456</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Radius = <span class="hljs-number"><span class="hljs-number">85445659.4471</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pixelDistance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">latLng1, latLng2, zoom</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1 = lonToX(latLng1.lng()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y1 = latToY(latLng1.lat()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x2 = lonToX(latLng2.lng()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y2 = latToY(latLng2.lat()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) &gt;&gt; (<span class="hljs-number"><span class="hljs-number">21</span></span> - zoom); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lonToX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lng</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(Offset + Radius * lng * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">latToY</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lat</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(Offset - Radius * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.log((<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(lat * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>)) / (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(lat * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>))) / <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br><p>  Cette fonction a √©galement √©t√© trouv√©e sur stackoverflow. </p><br><p>  Pour que les marqueurs ressemblent √† des cercles avec des photos (comme vkontakte), le plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RichMarker a</a> √©t√© utilis√© avec l'ajout d'un style arbitraire √† l'√©l√©ment div. </p><br><h2 id="conclusion">  Conclusion </h2><br><p>  Il s'est av√©r√© que pour afficher les photos sur la carte rapidement et correctement, nous devions r√©soudre des probl√®mes assez int√©ressants et non triviaux li√©s √† la mise en cache et √† la g√©om√©trie sph√©rique.  Malgr√© le fait que toutes les m√©thodes d√©crites n'ont pas √©t√© r√©ellement utilis√©es dans notre projet, le temps n'a pas √©t√© perdu, car l'exp√©rience que nous acqu√©rons pourrait √™tre utile dans d'autres projets, et elle pourrait √©galement √™tre utile pour ceux qui ont lu et compris cet article. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440410/">https://habr.com/ru/post/fr440410/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440394/index.html">PostgreSQL el√©vation de privil√®ges - CVE-2018-10915 parsing</a></li>
<li><a href="../fr440398/index.html">Historique de la participation (et de la victoire) √† la Russian AI Cup 2018 - CodeBall</a></li>
<li><a href="../fr440400/index.html">Apache Kafka + Spring Boot: Bonjour, microservices</a></li>
<li><a href="../fr440402/index.html">D√©veloppeur SearchFace sur les fonctionnalit√©s de l'algorithme</a></li>
<li><a href="../fr440404/index.html">"Architecture de l'information": mitap dans OZON</a></li>
<li><a href="../fr440412/index.html">Zimbra Collaboration Suite et MS Exchange sur le m√™me domaine</a></li>
<li><a href="../fr440414/index.html">√Ä propos de linter, de la qualit√© du code, de la qualit√© en g√©n√©ral et de la gestion de la qualit√©</a></li>
<li><a href="../fr440416/index.html">Colonie. Chapitre 25: Soir√©e</a></li>
<li><a href="../fr440420/index.html">Bienvenue au Devleads Meetup 21 f√©vrier</a></li>
<li><a href="../fr440422/index.html">Lorsque vous √™tes responsable de la qualit√© du cadeau. L'histoire d'une exp√©rience blockchain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>