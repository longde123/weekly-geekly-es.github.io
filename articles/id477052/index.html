<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèº üë®üèΩ‚Äçüè≠ üö∂üèæ Reaktor, WebFlux, Kotlin Coroutines, atau Asynchrony dengan Contoh Sederhana ‚≠êÔ∏è üïï üïµüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak layanan di dunia modern, sebagian besar, "tidak melakukan apa-apa". Tugas mereka dikurangi menjadi permintaan untuk database / layanan / cache ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reaktor, WebFlux, Kotlin Coroutines, atau Asynchrony dengan Contoh Sederhana</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/477052/"><img src="https://habrastorage.org/webt/oc/vm/jy/ocvmjybd42pjwnaqjaxeyz_dxlo.png"><br><br><p>  Banyak layanan di dunia modern, sebagian besar, "tidak melakukan apa-apa".  Tugas mereka dikurangi menjadi permintaan untuk database / layanan / cache lain dan agregasi semua data ini sesuai dengan berbagai aturan dan berbagai logika bisnis.  Oleh karena itu, tidak mengherankan bahwa bahasa seperti Golang muncul, dengan sistem kompetitif bawaan yang nyaman yang membuatnya mudah untuk mengatur kode non-pemblokiran. </p><br><p>  Di dunia JVM, segalanya sedikit lebih rumit.  Ada sejumlah besar kerangka kerja dan pustaka yang memblokir utas saat digunakan.  Jadi stdlib sendiri dapat melakukan hal yang sama di waktu-waktu tertentu.  Dan di Jawa tidak ada mekanisme serupa dengan goroutin di Golang. </p><br><p>  Namun demikian, JVM secara aktif berkembang dan peluang baru yang menarik muncul.  Ada Kotlin dengan coroutine, yang dalam penggunaannya sangat mirip dengan goroutine Gorang (meskipun mereka diterapkan dengan cara yang sama sekali berbeda).  Ada JEP Loom, yang akan membawa serat ke JVM di masa depan.  Salah satu kerangka kerja web paling populer - Spring - baru-baru ini menambahkan kemampuan untuk membuat layanan yang sepenuhnya non-blocking di Webflux.  Dan dengan rilis terbaru dari boot Spring 2.2, integrasi dengan Kotlin bahkan lebih baik. </p><br><p>  Saya mengusulkan, menggunakan contoh layanan kecil untuk mentransfer uang dari satu kartu ke kartu lain, untuk menulis aplikasi pada boot Spring 2.2 dan Kotlin untuk integrasi dengan beberapa layanan eksternal. </p><a name="habracut"></a><br><p>  Baik jika Anda sudah terbiasa dengan Java, Kotlin, Gradle, Spring, Spring boot 2, Reactor, <s>fluks</s> Web <s>, Tomcat, Netty, Kotlin outoutines, Gradle Kotlin DSL atau bahkan memiliki gelar Ph.D.</s>  Tetapi jika tidak, itu tidak masalah.  Kode ini akan disederhanakan secara maksimal, dan bahkan jika Anda bukan dari dunia JVM, saya harap semuanya akan jelas bagi Anda. </p><br><p>  Jika Anda berencana untuk menulis layanan sendiri, pastikan semua yang Anda butuhkan sudah diinstal: </p><br><ul><li>  Java 8+ </li><li>  Docker dan Docker Compose; </li><li>  CURL dan lebih disukai <a href="https://stedolan.github.io/jq/download/">jq</a> ; </li><li>  Git </li><li>  lebih disukai IDE untuk Kotlin (Intellij Idea, Eclipse, VS, <s>vim</s> , dll.).  Tapi itu mungkin di notebook. </li></ul><br><p>  Contoh akan berisi kosong untuk implementasi dalam layanan, dan implementasi yang sudah tertulis.  Pertama, jalankan instalasi dan perakitan dan perhatikan lebih dekat layanan dan API mereka. </p><br><blockquote> Contoh layanan dan API itu sendiri dibuat hanya untuk tujuan ilustrasi, jangan transfer semua <code>AS IS</code> ke prod Anda! </blockquote><p>  Pertama, kita mengkloning repositori dengan layanan ke diri kita sendiri, integrasi yang dengannya kita akan melakukannya, dan pergi ke direktori: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/evgzakharov/spring-demo-services &amp;&amp; cd spring-demo-services</code> </pre> <br><p>  Di terminal terpisah, kami mengumpulkan semua aplikasi menggunakan <code>gradle</code> , di mana setelah pembangunan yang berhasil semua layanan akan diluncurkan menggunakan <code>docker-compose</code> . </p><br><pre> <code class="plaintext hljs">./gradlew build &amp;&amp; docker-compose up</code> </pre> <br><p>  Sementara semuanya diunduh dan diinstal, pertimbangkan proyek dengan layanan. </p><br><img src="https://habrastorage.org/webt/go/mp/mb/gompmbrgtjwsuz9pnpbaxbuksg8.png"><br><p>  Permintaan dengan token, nomor kartu untuk transfer, dan jumlah yang akan ditransfer antar kartu akan diterima di pintu masuk layanan (layanan Demo): </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"authToken"</span></span>: <span class="hljs-string"><span class="hljs-string">"auth-token1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardFrom"</span></span>: <span class="hljs-string"><span class="hljs-string">"55593478"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardTo"</span></span>: <span class="hljs-string"><span class="hljs-string">"55592020"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"amount"</span></span>: <span class="hljs-string"><span class="hljs-string">"10.1"</span></span> }</code> </pre> <br><p>  <code>authToken</code> token <code>authToken</code> , <code>authToken</code> harus pergi ke layanan <code>AUTH</code> dan mendapatkan <code>userId</code> , yang dengannya Anda kemudian dapat membuat permintaan ke <code>USER</code> dan mengeluarkan semua informasi tambahan tentang pengguna.  <code>AUTH</code> juga akan mengembalikan informasi tentang mana dari tiga layanan yang dapat kita akses.  Contoh tanggapan dari <code>AUTH</code> : </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"userId"</span></span>: <span class="hljs-number"><span class="hljs-number">158</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"paymentAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"userAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  Untuk mentransfer antar kartu, pertama pergi dengan setiap nomor kartu dalam <code>CARD</code> .  Menanggapi permintaan, kami akan menerima <code>cardId</code> , kemudian dengan itu kami mengirim permintaan ke <code>PAYMENT</code> dan melakukan transfer.  Dan yang terakhir - sekali lagi kami mengirim permintaan ke <code>PAYMENT</code> dengan dari <code>fromCardId</code> dan mencari tahu saldo saat ini. </p><br><p>  Untuk meniru sedikit keterlambatan dalam layanan, nilai variabel lingkungan TIMEOUT dilemparkan ke semua wadah, di mana penundaan respons diatur dalam milidetik.  Dan untuk mendiversifikasi respons dari <code>AUTH</code> , dimungkinkan untuk memvariasikan nilai <code>SUCCESS_RATE</code> , yang mengontrol kemungkinan respons <code>true</code> untuk layanan. </p><br><p>  File docker-compose.yaml: </p><br><pre> <code class="plaintext hljs">version: '3' services: service-auth: build: service-auth image: service-auth:1.0.0 environment: - SUCCESS_RATE=1.0 - TIMEOUT=100 ports: - "8081:8080" service-card: build: service-card image: service-card:1.0.0 environment: - TIMEOUT=100 ports: - "8082:8080" service-payment: build: service-payment image: service-payment:1.0.0 environment: - TIMEOUT=100 ports: - "8083:8080" service-user: build: service-user image: service-user:1.0.0 environment: - TIMEOUT=100 ports: - "8084:8080"</code> </pre> <br><p>  Untuk semua layanan, port forwarding dari 8081 ke 8084 dilakukan untuk dengan mudah menjangkau mereka secara langsung. </p><br><p>  Mari beralih ke penulisan <code>Demo service</code> .  Pertama, mari kita coba untuk menulis implementasi yang seringkuh mungkin, tanpa asinkron dan konkurensi.  Untuk melakukan ini, ambil boot Spring 2.2.1, Kotlin dan kosong untuk layanan.  Kami mengkloning repositori dan pergi ke cabang <code>spring-mvc-start</code> : </p><br><pre> <code class="plaintext hljs">git clone https://github.com/evgzakharov/demo-service &amp;&amp; cd demo-service &amp;&amp; git checkout spring-mvc-start</code> </pre> <br><p>  Buka file <code>demo.Controller</code> .  Ini memiliki satu-satunya metode <code>processRequest</code> kosong yang implementasi harus ditulis. </p><br><pre> <code class="kotlin hljs"> <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { .. }</code> </pre> <br><p>  Permintaan untuk transfer antar kartu akan diterima di pintu masuk metode. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceRequest</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authToken: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFrom: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardTo: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount: BigDecimal )</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bagi mereka yang tidak terbiasa dengan Spring</b> <div class="spoiler_text"><p>  Spring memiliki DI bawaan yang berfungsi berdasarkan anotasi.  DemoController ditandai dengan anotasi <code>RestController</code> khusus: selain mendaftarkan kacang di DI, ia juga menambahkan pemrosesan sebagai pengontrol.  PostProcessor menemukan semua metode yang ditandai dengan anotasi <code>PostMapping</code> dan menambahkannya sebagai titik akhir untuk layanan dengan metode <code>POST</code> . </p><br><p>  Pawang juga membuat kelas proxy untuk DemoController, di mana semua argumen yang diperlukan diteruskan ke metode <code>processRequest</code> .  Dalam kasus kami, ini hanya satu argumen, ditandai dengan anotasi <code>@RequestBody</code> .  Oleh karena itu, dalam proxy, metode ini akan dipanggil dengan konten JSON yang di-deserialisasi ke dalam kelas <code>ServiceRequest</code> . </p></div></div><br><p>  Untuk membuatnya lebih mudah, semua metode untuk integrasi dengan layanan lain telah dibuat, Anda hanya perlu menghubungkannya dengan benar.  Hanya ada lima metode, satu untuk setiap tindakan.  Panggilan ke layanan lain sendiri diterapkan pada panggilan <strong>pemblokiran</strong> Spring <code>RestTemplate</code> . </p><br><p>  Metode contoh untuk memanggil <code>AUTH</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAuthInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: AuthInfo { log.info(<span class="hljs-string"><span class="hljs-string">"getAuthInfo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restTemplate.getForEntity(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${demoConfig.auth}</span></span></span><span class="hljs-string">/{token}"</span></span>, AuthInfo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">token) .body ?: throw RuntimeException</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"couldn't find user by token='</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$token</span></span></span><span class="hljs-string">'"</span></span>) }</code> </pre> <br><p>  Mari kita beralih ke implementasi metode.  Komentar menunjukkan prosedur dan respons apa yang diharapkan pada output: </p><br><pre> <code class="kotlin hljs"> <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-comment"><span class="hljs-comment">//1) get auth info from service by token -&gt; userId //2) find user info by userId from 1. //3) 4) find cards info for each card in serviceRequest // 5) make transaction for known cards by calling sendMoney(id1, id2, amount) // 6) after payment get payment info by fromCardId TODO("return SuccessResponse") // SuccessResponse( // amount = , // userName = , // userSurname = , // userAge = // ) }</span></span></code> </pre> <br><p>  Pertama, kami menerapkan metode sesederhana mungkin, tanpa memperhitungkan bahwa <code>AUTH</code> dapat menolak akses kami ke layanan lain.  Coba lakukan sendiri.  Ketika ternyata (atau setelah beralih ke cabang <code>spring-mvc</code> ), Anda dapat memeriksa pengoperasian layanan sebagai berikut: </p><br><div class="spoiler">  <b class="spoiler_title">implementasi dari cabang spring-mvc</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfo = getAuthInfo(serviceRequest.authToken) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = findUser(authInfo.userId) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = findCardInfo(serviceRequest.cardFrom) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfo = findCardInfo(serviceRequest.cardTo) sendMoney(cardFromInfo.cardId, cardToInfo.cardId, serviceRequest.amount) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = getPaymentInfo(cardFromInfo.cardId) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Mulai layanan (dari folder layanan demo): </p><br><pre> <code class="plaintext hljs">./gradlew bootRun</code> </pre> <br><p>  Kami mengirim permintaan ke titik akhir: </p><br><pre> <code class="plaintext hljs">./demo-request.sh</code> </pre> <br><p>  Sebagai tanggapan, kami mendapatkan sesuatu seperti ini: </p><br><pre> <code class="plaintext hljs">‚ûú demo-service git:(spring-mvc) ‚úó ./demo-request.sh + curl -XPOST http://localhost:8080/ -d @demo-payment-request.json -H 'Content-Type: application/json; charset=UTF-8' + jq . % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 182 0 85 100 97 20 23 0:00:04 0:00:04 --:--:-- 23 { "amount": 989.9, "userName": "Vasia", "userSurname": "Pupkin", "userAge": 18, "status": true }</code> </pre> <br><p>  Secara total, Anda perlu membuat 6 permintaan untuk mengimplementasikan layanan.  Dan mengingat bahwa masing-masing dari mereka merespons dengan penundaan 100 ms, total waktu tidak boleh kurang dari 600 ms.  Pada kenyataannya, ternyata sekitar 700 ms, dengan mempertimbangkan semua overhead.  Sejauh ini kodenya cukup sederhana, dan jika kita sekarang ingin menambahkan cek respons <code>AUTH</code> untuk mengakses layanan lain, ini tidak akan sulit dilakukan (seperti halnya refactoring lainnya). </p><br><p>  Tapi mari kita pikirkan bagaimana Anda dapat mempercepat eksekusi permintaan.  Jika Anda tidak memperhitungkan verifikasi jawaban dari <code>AUTH</code> , maka kami memiliki 2 tugas independen: </p><br><ul><li>  mendapatkan <code>userId</code> dan meminta data dari <code>USER</code> ; </li><li>  menerima <code>cardId</code> untuk setiap kartu, melakukan pembayaran dan menerima jumlah total. </li></ul><br><p>  Tugas-tugas ini dapat dilakukan secara independen satu sama lain.  Maka total waktu eksekusi akan tergantung pada rantai panggilan terpanjang (dalam hal ini, yang kedua) dan akan dieksekusi secara total untuk 300 ms + X ms overhead. </p><br><p>  Mengingat bahwa panggilan itu sendiri memblokir, satu-satunya cara untuk menjalankan permintaan paralel adalah dengan menjalankannya di utas terpisah.  Anda dapat membuat Utas terpisah untuk setiap panggilan, tetapi akan sangat mahal.  Cara lain adalah menjalankan tugas di ThreadPool.  Sepintas, solusi semacam itu terlihat tepat, dan waktu akan benar-benar berkurang.  Misalnya, kita dapat menjalankan kueri di CompletableFuture.  Ini memungkinkan Anda untuk menjalankan tugas latar belakang dengan memanggil metode dengan postfix <code>async</code> .  Dan jika Anda tidak menentukan ThreadPool tertentu saat memanggil metode, tugas akan diluncurkan di <code>ForkJoinPool.commonPool()</code> .  Cobalah untuk menulis implementasi sendiri atau buka cabang <code>spring-mvc-async</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Implementasi dari cabang spring-mvc-async</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfoFuture = CompletableFuture.supplyAsync { getAuthInfo(serviceRequest.authToken) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoFuture = authInfoFuture.thenApplyAsync { findUser(it.userId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = CompletableFuture.supplyAsync { findCardInfo(serviceRequest.cardFrom) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfo = CompletableFuture.supplyAsync { findCardInfo(serviceRequest.cardTo) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> waitAll = CompletableFuture.allOf(cardFromInfo, cardToInfo) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoFuture = waitAll .thenApplyAsync { sendMoney(cardFromInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId, cardToInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId, serviceRequest.amount) } .thenApplyAsync { getPaymentInfo(cardFromInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = paymentInfoFuture.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = userInfoFuture.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Jika sekarang kita mengukur waktu permintaan, itu akan berada di wilayah 360 ms.  Dibandingkan dengan versi aslinya, total waktu berkurang hampir 2 kali lipat.  Kode itu sendiri menjadi sedikit lebih rumit, tetapi sejauh ini masih tidak sulit untuk memodifikasinya.  Dan jika di sini kita ingin menambahkan cek respons dari <code>AUTH</code> , maka ini tidak sulit. </p><br><p>  Tetapi bagaimana jika kita memiliki sejumlah besar permintaan masuk untuk layanan itu sendiri?  Katakan sekitar 1000 permintaan simultan?  Dengan pendekatan ini, ternyata cukup cepat bahwa semua utas ThreadPool sibuk membuat panggilan pemblokiran.  Dan kita sampai pada kesimpulan bahwa versi saat ini juga tidak sesuai. </p><br><p>  Tetap hanya melakukan sesuatu dengan panggilan layanan sendiri.  Anda dapat memodifikasi kueri dan membuatnya non-pemblokiran.  Kemudian metode untuk memanggil layanan akan mengembalikan CompletableFuture, Flux, Observable, Deferred, Promise atau objek serupa yang digunakan untuk membangun rantai harapan.  Dengan pendekatan ini, kita tidak perlu melakukan panggilan pada aliran yang terpisah - itu akan cukup untuk memilikinya (atau setidaknya kumpulan aliran yang terpisah kecil) yang telah kita pinjam untuk memproses permintaan. </p><br><p>  Bisakah kita menahan beban berat pada layanan ini?  Untuk menjawab pertanyaan ini, perhatikan Tomcat, yang digunakan pada Spring boot 2.2.1 di starter <code>org.springframework.boot:spring-boot-starter-web</code> .  Itu dibangun sehingga utas dari ThreadPool dialokasikan untuk setiap permintaan masuk untuk pemrosesan.  Dan dengan tidak adanya arus bebas, permintaan baru akan menjadi "antrian" menunggu.  Tetapi layanan kami sendiri hanya mengirimkan permintaan ke layanan lain.  Mengalokasikan seluruh aliran di bawahnya dan memblokirnya sampai jawaban dari semua orang datang, terlihat, untuk membuatnya lebih halus, berlebihan. </p><br><p>  Untungnya, Spring baru-baru ini memungkinkan untuk menggunakan server web non-pemblokiran berdasarkan Netty atau Undertow.  Untuk melakukan ini, Anda hanya perlu mengubah <code>spring-boot-starter-web</code> menjadi <code>spring-boot-starter-webflux</code> dan sedikit mengubah metode untuk memproses permintaan di mana permintaan dan respons akan "dibungkus" dalam Mono.  Ini disebabkan oleh fakta bahwa Webflux dibangun atas dasar Reaktor, dan karena itu sekarang dalam metode yang Anda perlukan untuk membangun rantai transformasi Mono. <br></p><p>  Cobalah menulis implementasi metode Anda yang tidak menghalangi.  Untuk melakukannya, buka cabang <code>spring-webflux-start</code> .  Harap perhatikan bahwa starter untuk Spring Boot telah berubah, di mana versi dengan Webflux sekarang digunakan, dan implementasi permintaan ke layanan lain yang telah ditulis ulang untuk menggunakan <code>WebClient</code> non-blocking juga telah berubah. </p><br><p>  Metode contoh untuk memanggil AUTH: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAuthInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Mono&lt;AuthInfo&gt; { log.info(<span class="hljs-string"><span class="hljs-string">"getAuthInfo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WebClient.create().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() .uri(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${demoConfig.auth}</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$token</span></span></span><span class="hljs-string">"</span></span>) .retrieve() .bodyToMono(AuthInfo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) }</span></span></code> </pre> <br><p>  Implementasi dari contoh pertama dimasukkan ke dalam isi metode <code>processRequest</code> dalam komentar.  Cobalah untuk menulis ulang sendiri di Reactor.  Seperti terakhir kali, pertama-tama buat versi tanpa memperhitungkan cek dari <code>AUTH</code> , dan kemudian lihat betapa sulitnya menambahkannya: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Mono</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Mono&lt;Response&gt; { <span class="hljs-comment"><span class="hljs-comment">// val authInfo = getAuthInfo(serviceRequest.authToken) // // val userInfo = findUser(authInfo.userId) // // val cardFromInfo = findCardInfo(serviceRequest.cardFrom) // val cardToInfo = findCardInfo(serviceRequest.cardTo) // // sendMoney(cardFromInfo.cardId, cardToInfo.cardId, serviceRequest.amount) // // val paymentInfo = getPaymentInfo(cardFromInfo.cardId) // // log.info("result") // // return SuccessResponse( // amount = paymentInfo.currentAmount, // userName = userInfo.name, // userSurname = userInfo.surname, // userAge = userInfo.age // ) TODO() }</span></span></code> </pre> <br><p>  Setelah berurusan dengan ini, Anda dapat membandingkan dengan implementasi saya dari cabang <code>spring-webflux</code> : </p><br><div class="spoiler">  <b class="spoiler_title">Implementasi dari cabang spring-webflux</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Mono</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Mono&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cacheRequest = serviceRequest.cache() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoMono = cacheRequest.flatMap { getAuthInfo(it.authToken) }.flatMap { findUser(it.userId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfoMono = cacheRequest.flatMap { findCardInfo(it.cardFrom) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfoMono = cacheRequest.flatMap { findCardInfo(it.cardTo) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoMono = cardFromInfoMono.zipWith(cardToInfoMono) .flatMap { (cardFromInfo, cardToInfo) -&gt; cacheRequest.flatMap { request -&gt; sendMoney(cardFromInfo.cardId, cardToInfo.cardId, request.amount).map { cardFromInfo } } }.flatMap { getPaymentInfo(it.cardId) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userInfoMono.zipWith(paymentInfoMono) .map { (userInfo, paymentInfo) -&gt; log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) } }</code> </pre> </div></div><br><p>  Setuju bahwa sekarang menulis implementasi (dibandingkan dengan pendekatan pemblokiran sebelumnya) menjadi lebih sulit.  Dan jika kita ingin menambahkan "lupa" cek dari <code>AUTH</code> , maka ini tidak akan mudah dilakukan. </p><br><p>  Ini adalah inti dari pendekatan reaktif.  Ini bagus untuk membangun rantai pemrosesan yang tidak bercabang.  Tetapi jika percabangan muncul, maka kodenya tidak lagi begitu sederhana. </p><br><p>  Kotlin coroutine, yang sangat ramah dengan kode asinkron / reaktif, dapat membantu di sini.  Selain itu, ada sejumlah besar pembungkus tertulis untuk <a href="">Reactor</a> , <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-jdk8">CompletableFuture</a> , dll.  Tetapi bahkan jika Anda tidak menemukan yang tepat, Anda selalu dapat menulis sendiri, menggunakan <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html">pembangun</a> khusus. </p><br><p>  Mari kita menulis ulang implementasi pada coroutine sendiri.  Untuk melakukannya, buka cabang <code>spring-webflux-coroutines-start</code> .  Ketergantungan yang diperlukan ditambahkan padanya di build.gradle.kts: </p><br><pre> <code class="kotlin hljs">implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-core:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>) implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-reactive:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>) implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-reactor:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Dan metode <code>processRequest</code> berubah <code>processRequest</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response = coroutineScope { <span class="hljs-comment"><span class="hljs-comment">//TODO() }</span></span></code> </pre> <br><p>  Ini tidak lagi membutuhkan Mono dan diterjemahkan hanya menjadi fungsi menangguhkan (berkat integrasi Spring dan Kotlin).  Menimbang bahwa kita akan membuat coroutine tambahan dalam metode ini, kita perlu membuat scout <code>coroutineScope</code> anak (untuk pemahaman tentang alasan-alasan untuk menciptakan ruang lingkup tambahan, lihat posting Roman Elizarov tentang <a href="https://medium.com/%40elizarov/structured-concurrency-722d765aa952">Structured concurrency</a> ).  Harap perhatikan bahwa panggilan layanan lain tidak berubah sama sekali.  Mereka mengembalikan Mono yang sama di mana metode <code>suspend</code> awaitFirst dapat dipanggil untuk "menunggu" untuk hasil query. </p><br><p>  Jika coroutine masih merupakan konsep baru untuk Anda, maka ada <a href="">panduan</a> luar biasa dengan deskripsi terperinci.  Coba tulis implementasi Anda sendiri dari metode <code>processRequest</code> atau buka cabang <code>spring-webflux-coroutines</code> : </p><br><div class="spoiler">  <b class="spoiler_title">implementasi dari cabang spring-webflux-coroutines</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response = coroutineScope { log.info(<span class="hljs-string"><span class="hljs-string">"start"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoDeferred = async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfo = getAuthInfo(serviceRequest.authToken).awaitFirst() findUser(authInfo.userId).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoDeferred = async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfoDeferred = async { findCardInfo(serviceRequest.cardFrom).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfoDeferred = async { findCardInfo(serviceRequest.cardTo).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = cardFromInfoDeferred.await() sendMoney(cardFromInfo.cardId, cardToInfoDeferred.await().cardId, serviceRequest.amount).awaitFirst() getPaymentInfo(cardFromInfo.cardId).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = userInfoDeferred.await() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = paymentInfoDeferred.await() log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Anda dapat membandingkan kode dengan pendekatan reaktif.  Dengan coroutine, Anda tidak perlu memikirkan semua poin cabang terlebih dahulu.  Kami hanya dapat memanggil metode <code>await</code> dan bercabang tugas asinkron di <code>async</code> di tempat yang tepat.  Kode tetap sama mungkin dengan versi langsung yang asli, yang sama sekali tidak sulit untuk diubah.  Dan faktor penting adalah bahwa coroutine hanya tertanam dalam kode reaktif. </p><br><p>  Anda bahkan mungkin lebih menyukai pendekatan reaktif untuk tugas ini, tetapi banyak orang yang disurvei merasa lebih sulit.  Secara umum, kedua pendekatan menyelesaikan masalah mereka dan Anda dapat menggunakan salah satu yang Anda sukai.  Ngomong-ngomong, baru-baru ini di Kotlin ada juga kesempatan untuk membuat coroutine ‚Äúdingin‚Äù dengan Flow, yang sangat mirip dengan Reactor.  Benar, mereka masih dalam tahap percobaan, tetapi sekarang Anda dapat melihat implementasi saat ini dan mencobanya dalam kode Anda. </p><br><p>  Saya ingin mengakhiri di sini dan akhirnya meninggalkan tautan yang bermanfaat: </p><br><ul><li>  <a href="">Panduan Coroutine</a> </li><li>  <a href="">Reaktor Coroutines</a> </li><li>  <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-jdk8">Coroutines CompletableFuture</a> </li><li>  <a href="https://www.youtube.com/results%3Fsearch_query%3D%25D0%25B5%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2580%25D0%25BE%25D0%25B2%2B%25D1%2580%25D0%25BE%25D0%25BC%25D0%25B0%25D0%25BD%2B%25D0%25BA%25D0%25BE%25D1%2580%25D1%2583%25D1%2582%25D0%25B8%25D0%25BD%25D1%258B">Roman Elizarov tentang coroutine</a> </li><li>  <a href="https://medium.com/%40elizarov/kotlin-flows-and-coroutines-256260fb3bdb">Kotlin Mengalir dan Coroutine</a> </li><li>  <a href="https://medium.com/%40elizarov/structured-concurrency-722d765aa952">Konkurensi terstruktur</a> </li><li>  <a href="https://blog.karumi.com/spring-boot-loves-kotlin/">Boot musim semi mencintai Kotlin</a> </li></ul><br><p>  Saya harap Anda tertarik dan Anda berhasil menulis implementasi metode untuk semua metode sendiri.  Dan, tentu saja, saya ingin percaya bahwa Anda menyukai opsi dengan coroutine lebih =) </p><br><p>  Terima kasih kepada semua orang yang membaca sampai akhir! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477052/">https://habr.com/ru/post/id477052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477042/index.html">Optimalisasi Strategi Monte Carlo Blackjack</a></li>
<li><a href="../id477044/index.html">Otomatisasi Pengujian Akhir-2-End dari sistem informasi terintegrasi. Bagian 2. Teknis</a></li>
<li><a href="../id477046/index.html">.Net Meetup di Raiffeisenbank 28/11 + Broadcast</a></li>
<li><a href="../id477048/index.html">Mengapa perusahaan dengan kapitalisasi $ 55 miliar berpikir untuk meninggalkan bursa</a></li>
<li><a href="../id477050/index.html">Black Friday 2019 untuk pengawasan video dan cloud.</a></li>
<li><a href="../id477054/index.html">Webasto Mengumumkan Sistem Baterai Otomotif Modular</a></li>
<li><a href="../id477058/index.html">Enterprise Agile Russia di Raiffeisenbank 26/11 + Broadcast</a></li>
<li><a href="../id477060/index.html">DataArt akan menyelenggarakan kuliah terbuka oleh Andrei Terekhov, Kepala Departemen Pemrograman Sistem, Matmekh, Universitas Negeri St. Petersburg</a></li>
<li><a href="../id477062/index.html">Cara kerja kompiler yang mengoptimalkan</a></li>
<li><a href="../id477072/index.html">Pengembangan Pelanggan atau bagaimana meluncurkan produk tanpa kegagalan?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>