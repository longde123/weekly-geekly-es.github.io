<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏾 🙇 ✔️ 在C ++中使用多线程时的前20个错误及其避免方法 👨‍👩‍👦 🍼 📏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我提请您注意Deb Haldar撰写的文章“ Top 20 C ++多线程错误以及如何避免这些错误” 。 


 电影《时间的循环》（2012）中的场景 

 多线程是编程中最困难的领域之一，尤其是在C ++中。 经过多年的发展，我犯了很多错误。 幸运的是，它们中的大多数是通过审查代码和测...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在C ++中使用多线程时的前20个错误及其避免方法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443406/"> 哈Ha！ 我提请您注意Deb Haldar撰写的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Top 20 C ++多线程错误以及如何避免这些错误”</a> 。 <br><br><img src="https://habrastorage.org/webt/wi/a8/4v/wia84vtxrf1vqym4rwoynnvtfw0.jpeg" title="KDPV。电影“时间循环（2012年）”中的场景"><br>  <i>电影《时间的循环》（2012）中的场景</i> <br><br> 多线程是编程中最困难的领域之一，尤其是在C ++中。 经过多年的发展，我犯了很多错误。 幸运的是，它们中的大多数是通过审查代码和测试确定的。 但是，由于某种原因，生产效率下降了，我们不得不编辑操作系统，这总是很昂贵的。 <br><br> 在本文中，我尝试使用可能的解决方案对我知道的所有错误进行分类。 如果您知道其他任何陷阱，或者对解决所描述的错误有建议，请在本文下方保留您的评论。 <br><a name="habracut"></a><br><h3> 错误＃1：在退出应用程序之前，请勿使用join（）等待后台线程 </h3><br> 如果您忘记在程序终止之前加入流（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">join（）</a> ）或取消固定它（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">detach（）</a> ）（使其不可连接），则将导致崩溃。  （虽然这并不完全正确，但是翻译将包含在<i>join（）</i>上下文中的<i>join</i>和在<i>detach（）</i>上下文中的<i>detach</i> 。实际上， <i>join（）</i>是一个执行线程等待另一个线程完成的地方，并且不会发生线程的合并或合并[评论翻译]）。 <br><br> 在下面的示例中，我们忘记了在主线程中执行线程t1的<i>join（）</i> ： <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//t1.join(); //     join-     </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br> 为什么程序崩溃？ 因为在<i>main（）</i>函数的末尾，变量t1超出范围，所以调用了线程析构函数。 析构函数检查线程t1是否<i>可连接</i> 。 如果线程尚未分离，则该线程是<i>可连接的</i> 。 在这种情况下，将在其析构函数中调用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: terminate</a> 。 例如，这就是MSVC ++编译器所做的。 <br><br> <code>~thread <font color="#008000">(</font> <font color="#008000">)</font> _NOEXCEPT <br> <font color="#008000">{</font> <font color="#666666">// clean up</font> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> joinable <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> XSTD terminate <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br> 有两种方法可以解决此问题，具体取决于任务： <br><br>  1.在主线程中调用线程t1的<i>join（）</i> ： <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//  join  t1,        </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  2.从主流分离流t1，使其继续作为“妖魔化”流工作： <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   t1   </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br><h3> 错误2：尝试附加先前分离的线程 </h3><br> 如果程序在某个时候有<i>分离</i>流，则无法将其附加回主流。 这是一个非常明显的错误。 问题是您可以取消固定流，然后编写几百行代码并尝试重新附加它。 毕竟，谁记得他写了300行，对吗？ <br><br> 问题在于这不会导致编译错误，相反，程序将在启动时崩溃。 例如： <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//..... 100  - </font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">// CRASH !!!</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br> 解决方案是在尝试将线程附加到调用线程之前，始终检查该线程是否存在<i>joinable（）</i> 。 <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//..... 100  - </font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> t1. <font color="#007788">joinable</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3> 错误3：误解std :: thread :: join（）阻止了执行的调用线程 </h3><br> 在实际应用中，您经常需要分离出处理网络I / O的“长时间播放”操作或等待用户单击按钮等。 对于此类工作流（例如，UI渲染线程）的<i>join（）</i>调用可能会导致用户界面挂起。 有更多合适的实现方法。 <br><br> 例如，在GUI应用程序中，工作线程可以在完成后将消息发送到UI线程。  UI流具有其自己的事件处理循环，例如：移动鼠标，按下键等。 此循环还可以接收来自工作线程的消息并对其进行响应，而不必调用阻塞的<i>join（）</i>方法。 <br><br> 因此，Microsoft的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WinRT</a>平台中几乎所有用户交互都是异步的，并且没有同步替代方法。 做出这些决定是为了确保开发人员将使用可提供最佳最终用户体验的API。 您可以参考“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Modern C ++和Windows Store Apps</a> ”手册，以获取有关此主题的更多信息。 <br><br><h3> 错误4：假设默认情况下通过引用传递流函数参数 </h3><br> 默认情况下，流函数的参数按值传递。 如果需要更改所传递的参数，则必须使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: ref（）</a>函数通过引用将其传递。 <br><br> 在剧透之下，来自另<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇C ++ 11文章“通过Q＆A进行多线程教程-线程管理基础知识（Deb Haldar）</a> ”的示例，说明了传递参数的过程。 译者]。 <br><br><div class="spoiler">  <b class="spoiler_title">更多详细信息：</b> <div class="spoiler_text"> 执行代码时： <br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;functional&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> ChangeCurrentMissileTarget <font color="#008000">(</font> string <font color="#000040">&amp;</font> targetCity <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> targetCity <font color="#000080">=</font> <font color="#FF0000">"Metropolis"</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" Changing The Target City To "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> string targetCity <font color="#000080">=</font> <font color="#FF0000">"Star City"</font> <font color="#008080">;</font> <br> thread t1 <font color="#008000">(</font> ChangeCurrentMissileTarget, targetCity <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Current Target City is "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br> 它将显示在终端中： <br> <code>Changing The Target City To Metropolis <br> Current Target City is Star City</code> <br> <br> 如您所见，流中通过引用调用的函数接收到的<i>targetCity</i>变量的值未更改。 <br><br> 使用<i>std :: ref（）</i>重写代码以传递参数： <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;functional&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> ChangeCurrentMissileTarget <font color="#008000">(</font> string <font color="#000040">&amp;</font> targetCity <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> targetCity <font color="#000080">=</font> <font color="#FF0000">"Metropolis"</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" Changing The Target City To "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> string targetCity <font color="#000080">=</font> <font color="#FF0000">"Star City"</font> <font color="#008080">;</font> <br> thread t1 <font color="#008000">(</font> ChangeCurrentMissileTarget, std <font color="#008080">::</font> <font color="#007788">ref</font> <font color="#008000">(</font> targetCity <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Current Target City is "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br> 它将输出： <br> <code>Changing The Target City To Metropolis <br> Current Target City is Metropolis</code> <br> <br> 在新线程中所做的更改将影响在<i>主</i>函数中声明和初始化的<i>targetCity</i>变量的值。 <br></div></div><br><h3> 错误5：请勿使用关键部分（例如互斥锁）保护共享数据和资源 </h3><br> 在多线程环境中，通常会有多个线程竞争资源和共享数据。 通常，这会导致资源和数据的状态不确定，除非通过某种机制保护对它们的访问，该机制仅允许一个执行线程在任何时间对其执行操作。 <br><br> 在下面的示例中， <i>std :: cout</i>是一个共享资源，可以使用6个线程（t1-t5 + main）。 <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> mu <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Jupiter"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t2 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Pluto"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t3 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Moon"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> CallHome <font color="#008000">(</font> <font color="#FF0000">"Hello from Main/Earth"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> thread t4 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Uranus"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t5 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Neptune"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t2. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t3. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t4. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t5. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br> 如果执行此程序，我们将得出结论： <br><br> <code>Thread 0x1000fb5c0 says Hello from Main/Earth <br> Thread Thread Thread 0x700005bd20000x700005b4f000 says says Thread Thread Hello from Pluto0x700005c55000Hello from Jupiter says 0x700005d5b000Hello from Moon <br> 0x700005cd8000 says says Hello from Uranus <br> <br> Hello from Neptune <br></code> <br><br> 这是因为五个线程正在以随机顺序同时访问输出流。 为了使结论更具体，必须使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: mutex</a>保护对共享资源的访问。 只需更改<i>CallHome（）</i>函数，以便它在使用<i>std :: cout</i>之前捕获互斥量，并在之后释放它。 <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> mu. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br><h3> 错误＃6：退出关键部分后忘记释放锁 </h3><br> 在上一段中，您了解了如何使用互斥锁保护关键部分。 但是，不建议直接在互斥<i>锁上</i>调用<i>lock（）</i>和<i>unlock（）</i>方法，因为您可能会忘记赋予保留的锁。 接下来会发生什么？ 等待资源释放的所有其他线程将被无限阻止，程序可能会挂起。 <br><br> 在我们的综合示例中，如果您忘记了在<i>CallHome（）</i>函数调用中解锁互斥锁，则来自流t1的第一条消息将输出到标准流，并且程序将崩溃。 这是由于以下事实：线程t1接收了互斥锁，而其余线程等待此锁被释放。 <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#666666">//mu.unlock();     </font> <br> <font color="#008000">}</font></code> <br> <br> 以下是此代码的输出-程序崩溃，在终端中显示唯一的消息，但没有结束： <br><br> <code>Thread 0x700005986000 says Hello from Pluto <br> <br></code> <br><br> 经常会发生此类错误，这就是不希望直接从互斥锁使用<i>lock（）/ unlock（）</i>方法的原因。 而是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: lock_guard</a>模板类，该模板类使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RAII</a>惯用语来控制锁的生存期。 创建<i>lock_guard</i>对象时，它将尝试接管互斥锁。 当程序离开<i>lock_guard</i>对象的范围时，将调用析构函数，从而释放互斥量。 <br><br> 我们使用<i>std :: lock_guard</i>对象重写<i>CallHome（）</i>函数： <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   </font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#666666">//  lock_guard    </font></code> <br> <br><h3> 错误7：使关键部分的尺寸大于必要的尺寸 </h3><br> 当一个线程在关键部分内执行时，所有其他试图进入该线程的线程都会被阻塞。 在关键部分中，我们应该保留尽可能少的说明。 为了说明这一点，给出了一个带有较大临界区的错误代码示例： <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   ,    std::cout</font> <br> <br> ReadFifyThousandRecords <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#008000">}</font> <font color="#666666">//    lock_guard    mu </font></code> <br> <br>  <i>ReadFifyThousandRecords（）</i>方法不会修改数据。 没有理由在锁定状态下执行它。 如果执行此方法10秒钟，从数据库中读取5万行，则在此整个周期内，所有其他线程都将被不必要地阻塞。 这会严重影响程序性能。 <br><br> 正确的解决方案是仅在关键部分中使用<i>std :: cout</i> 。 <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> ReadFifyThousandRecords <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//         ..    </font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   ,    std::cout</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#008000">}</font> <font color="#666666">//     lock_guard    mu </font></code> <br> <br><h3> 错误8：以不同的顺序获取多个锁 </h3><br><br> 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">死锁</a>的最常见原因之一，在这种情况下，由于等待访问其他线程阻塞的资源而导致线程被无限阻塞。 考虑一个例子： <br><br><table><tbody><tr><th> 流1 </th><th> 流2 </th></tr><tr><td> 锁A </td><td> 锁B </td></tr><tr><td>  // ...一些操作 </td><td>  // ...一些操作 </td></tr><tr><td> 锁B </td><td> 锁A </td></tr><tr><td>  // ...其他一些操作 </td><td>  // ...其他一些操作 </td></tr><tr><td> 解锁B </td><td> 解锁A </td></tr><tr><td> 解锁A </td><td> 解锁B </td></tr></tbody></table><br> 由于线程2已经捕获了锁B，因此线程1将尝试捕获锁B并被阻塞的情况可能会出现。 同时，第二个线程正在尝试捕获锁A，但不能执行此操作，因为它是第一个线程捕获的。 线程1直到锁住B等后才能释放锁A。 换句话说，程序冻结。 <br><br> 此代码示例将帮助您重现<i>死锁</i> ： <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> muA <font color="#008080">;</font> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> muB <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> CallHome_Th1 <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> muA. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//  - </font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muB. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> muB. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muA. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">void</font> CallHome_Th2 <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> muB. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">// -  </font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muA. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> muA. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muB. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> CallHome_Th1, <font color="#FF0000">"Hello from Jupiter"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t2 <font color="#008000">(</font> CallHome_Th2, <font color="#FF0000">"Hello from Pluto"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t2. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br> 如果运行此代码，它将崩溃。 如果您在线程窗口中深入调试器，则会看到第一个线程（从<i>CallHome_Th1（）</i>调用）试图获取互斥锁B，而线程2（从<i>CallHome_Th2（）</i>调用）试图阻止互斥锁A。无法成功，这将导致僵局！ <br><br> <a href=""><img src="https://habrastorage.org/webt/ud/kf/a5/udkfa53cvuh8xsrn8lljglb09fa.png"></a> <br>  （图片可点击） <br><br> 你能做什么呢？ 最好的解决方案是重组代码，以便每次锁定锁的顺序相同。 <br><br> 根据情况，您可以使用其他策略： <br><br>  1.使用包装器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类std :: scoped_lock</a>共同捕获多个锁： <br><br> <code>std <font color="#008080">::</font> <font color="#007788">scoped_lock</font> lock <font color="#008000">{</font> muA, muB <font color="#008000">}</font> <font color="#008080">;</font></code> <br> <br>  2.使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: timed_mutex类</a> ，您可以在其中指定一个超时，如果资源不可用，将在该超时后释放锁。 <br><br> <code>std <font color="#008080">::</font> <font color="#007788">timed_mutex</font> m <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> DoSome <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> timeout <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> m. <font color="#007788">try_lock_for</font> <font color="#008000">(</font> timeout <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">": acquire mutex successfully"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> m. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#0000ff">else</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">": can't  acquire mutex, do something else"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font></code> <br> <br><h3> 错误9：尝试两次捕获std ::互斥锁 </h3><br> 尝试两次锁定该锁将导致未定义的行为。 在大多数调试实现中，这将崩溃。 例如，在下面的代码中， <i>LaunchRocket（）将</i>锁定互斥锁，然后调用<i>StartThruster（）</i> 。 令人好奇的是，在上面的代码中，您在程序正常运行期间不会遇到此问题，仅当引发异常（伴随着未定义的行为或程序异常终止）时才会出现此问题。 <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> mu <font color="#008080">;</font> <br> <br> <font color="#0000ff">static</font> <font color="#0000ff">int</font> counter <font color="#000080">=</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> StartThruster <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> <font color="#666666">// - </font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching rocket"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <br> counter <font color="#000040">++</font> <font color="#008080">;</font> <br> StartThruster <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br> 若要解决此问题，您必须以防止重新检索以前收到的锁的方式更正代码。 您可以将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: recursive_mutex</a>用作拐杖解决方案，但是这样的解决方案几乎总是表明程序的体系结构不佳。 <br><br><h3> 错误10：在std ::原子类型足够时使用互斥 </h3><br><br> 当您需要更改简单数据类型（例如布尔值或整数计数器）时，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std：atomic</a>通常会比使用互斥锁提供更好的性能。 <br><br> 例如，代替使用以下构造： <br><br> <code><font color="#0000ff">int</font> counter <font color="#008080">;</font> <br> ... <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> counter <font color="#000040">++</font> <font color="#008080">;</font> <br> mu. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br></code> <br><br> 最好将变量声明为<i>std :: atomic</i> ： <br><br> <code>std <font color="#008080">::</font> <font color="#007788">atomic</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> counter <font color="#008080">;</font> <br> ... <br> <font color="#007788">counter</font> <font color="#000040">++</font> <font color="#008080">;</font></code> <br> <br> 有关互斥锁和原子锁的详细比较，请参阅《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">比较：C ++ 11与C ++中的</a>原子无<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">锁编程》。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">互斥锁和读写锁»</a> <br><br><h3> 错误11：直接创建和销毁大量线程，而不是使用空闲线程池 </h3><br> 就处理器时间而言，创建和销毁线程是一项昂贵的操作。 想象一下在系统执行计算密集型操作（例如渲染图形或计算游戏物理）时创建流的尝试。 通常用于此类任务的方法是创建一个预分配线程池，该池可以处理例行任务，例如在整个过程的整个生命周期中写入磁盘或通过网络发送数据。 <br><br> 与您自己生成和销毁线程相比，线程池的另一个优点是您不必担心<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">线程超额订购</a> （这种情况下，线程数超过了可用核心数，并且处理器的大部分时间都花在切换上下文上[大约。翻译]]。 这可能会影响系统性能。 <br><br> 另外，池的使用使我们免于管理线程生命周期的烦恼，最终使它转化为具有更少错误的更紧凑代码。 <br><br> 实现线程池的两个最受欢迎的库是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Intel线程构建块（TBB）</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Microsoft并行模式库（PPL）</a> 。 <br><br><h3> 错误编号12：不处理后台线程中发生的异常 </h3><br> 在一个线程中引发的异常无法在另一个线程中处理。 假设我们有一个引发异常的函数。 如果我们在与执行主线程分开的单独线程中执行此函数，并且期望我们将捕获从附加线程抛出的任何异常，那么它将无法正常工作。 考虑一个例子： <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include&lt;iostream&gt;</font> <br> <font color="#339900">#include&lt;thread&gt;</font> <br> <font color="#339900">#include&lt;exception&gt;</font> <br> <font color="#339900">#include&lt;stdexcept&gt;</font> <br> <br> <font color="#0000ff">static</font> std <font color="#008080">::</font> <font color="#007788">exception_ptr</font> teptr <font color="#000080">=</font> <font color="#0000ff">nullptr</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">exception</font> <font color="#000040">&amp;</font> ex <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread exited with exception: "</font> <font color="#000080">&lt;&lt;</font> ex. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" <font color="#000099">\n</font> "</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br> 当执行此程序时，它将崩溃，但是，main（）函数中的catch块将不执行，并且将无法处理线程t1中引发的异常。 <br><br> 解决此问题的方法是使用C ++ 11中的功能： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: exception_ptr</a>用于处理在后台线程中引发的异常。 这是您需要采取的步骤： <br><br><ul><li> 创建<i>std :: exception_ptr</i>类的全局实例，并将其初始化为<i>nullptr</i> </li><li> 在运行于单独线程中的函数中，处理所有异常并设置上一步中声明<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>全局变量<i>std :: exception_ptr</i>的值<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: current_exception（）</a> </li><li> 检查主线程中的全局变量的值 </li><li> 如果设置了该值，请使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: rethrow_exception（exception_ptr p）</a>函数重复调用先前捕获的异常，并将其作为参数传递给引用 </li></ul><br> 通过引用调用异常不会在创建它的线程中发生，因此此功能非常适合处理不同线程中的异常。 <br><br> 在下面的代码中，您可以安全地处理在后台线程中引发的异常。 <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include&lt;iostream&gt;</font> <br> <font color="#339900">#include&lt;thread&gt;</font> <br> <font color="#339900">#include&lt;exception&gt;</font> <br> <font color="#339900">#include&lt;stdexcept&gt;</font> <br> <br> <font color="#0000ff">static</font> std <font color="#008080">::</font> <font color="#007788">exception_ptr</font> globalExceptionPtr <font color="#000080">=</font> <font color="#0000ff">nullptr</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> globalExceptionPtr <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">current_exception</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> globalExceptionPtr <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">rethrow_exception</font> <font color="#008000">(</font> globalExceptionPtr <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">exception</font> <font color="#000040">&amp;</font> ex <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread exited with exception: "</font> <font color="#000080">&lt;&lt;</font> ex. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" <font color="#000099">\n</font> "</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3> 错误13：使用线程模拟异步操作，而不是使用std :: async </h3><br> 如果您需要代码以异步方式执行，即 在不阻塞执行主线程的情况下，最好的选择是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: async（）</a> 。 这等效于创建流并通过指向lambda函数形式的函数或参数的指针传递在该流中执行的必要代码。 但是，在后一种情况下，您需要监视此线程的创建，连接/分离以及对该线程中可能发生的所有异常的处理。 如果使用<i>std :: async（）</i> ，则可以减轻这些问题的负担，并大大减少<i>陷入僵局的</i>机会。 <br><br> 使用<i>std :: async的</i>另一个重要优点是能够使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: future</a>对象将异步操作的结果返回给调用线程。 假设我们有一个<i>ConjureMagic（）</i>函数，它返回一个int值。 我们可以启动一个异步操作，该异步操作将在任务完成时将将来的值设置为<i>将来的</i>对象，并且可以在调用该操作的执行流中从该对象中提取执行结果。 <br><br> <code><font color="#666666">//        future</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> asyncResult2 <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> <font color="#000040">&amp;</font> ConjureMagic <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//...  -   future   </font> <br> <br> <font color="#666666">//     future</font> <br> <font color="#0000ff">int</font> v <font color="#000080">=</font> asyncResult2. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br> 将结果从正在运行的线程返回给调用者比较麻烦。 两种方法是可能的： <br><br><ol><li> 将对输出变量的引用传递到将保存结果的流中。 </li><li> 将结果存储在工作流对象的字段变量中，线程完成执行后即可读取。 </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kurt Guntheroth</a>发现，就性能而言，创建流的开销是使用<i>async</i>的开销的14倍。 <br><br> 底线：默认情况下使用<i>std :: async（）</i> ，直到找到有利于直接使用<i>std :: thread的</i>强大参数为止。 <br><br><h3> 错误编号14：如果需要异步，请不要使用std :: launch :: async </h3><br>  <i>std :: async（）</i>函数的名称不太正确，因为默认情况下它可能不会异步运行！ <br><br> 有两种<i>std :: async</i>运行时策略： <br><br><ol><li>  <i>std :: launch :: async</i> ：传递的函数开始在单独的线程中立即执行 </li><li>  <i>std :: launch :: deferred</i> ：传递的函数不会立即启动，在对<i>std :: future</i>对象进行<i>get（）</i>或<i>wait（）</i>调用之前，它的启动会延迟，这将从<i>std :: async</i>调用返回。 代替调用这些方法，该函数将同步执行。 </li></ol><br> 当我们使用默认参数调用<i>std :: async（）</i>时，它以这两个参数的组合开头，实际上会导致不可预测的行为。 使用<i>std</i>还存在许多其他困难<i>：</i>默认启动策略使用<i>async（）</i> ： <br><br><ul><li> 无法预测对局部流量变量的正确访问 </li><li> 由于在程序执行期间可能不会调用<i>get（）</i>和<i>wait（）</i>方法，因此异步任务可能根本不会启动 </li><li> 当在退出条件期望std :: future对象准备就绪的循环中使用时，这些循环可能永远不会结束，因为调用std :: async返回的std :: future可能开始于延迟状态。 </li></ul><br> 为避免所有这些困难，请<b>始终</b>使用<i>std :: launch :: async启动</i>策略调用<i>std :: async</i> 。 <br><br> 不要这样做： <br><br> <code><font color="#666666">//  myFunction  std::async     </font> <br> <font color="#0000ff">auto</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> myFunction <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br> 相反，请执行以下操作： <br><br> <code><font color="#666666">//  myFunction </font> <br> <font color="#0000ff">auto</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , myFunction <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Scott Meyers在书中“ Effective and Modern C ++”对这一点进行了更详细的考虑。 <br><br><h3> 错误15：在执行时间很关键的代码块中调用std :: future对象的get（）方法 </h3><br> 下面的代码处理从异步操作的<i>std :: future</i>对象获得的结果。 但是， <i>while循环</i>将被锁定，直到异步操作完成（在这种情况下为10秒）。 如果要使用此循环在屏幕上显示信息，则可能导致渲染用户界面时出现令人不快的延迟。 <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">seconds</font> <font color="#008000">(</font> <font color="#0000dd">10</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//     </font> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Rendering Data"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#0000ff">int</font> val <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//    10 </font> <br> <font color="#666666">//  -   Val</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  <b>注意</b> ：上面代码的另一个问题是，它尝试第二次访问<i>std :: future</i>对象，尽管<i>std :: future</i>对象的状态是在循环的第一次迭代中获取的，但无法获取。 <br><br> 正确的解决方案是在调用<i>get（）</i>方法之前检查<i>std :: future</i>对象的有效性。 因此，我们不会阻止异步任务的完成，也不会尝试询问已经提取的<i>std :: future</i>对象。 <br><br> 此代码段可实现以下目的： <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">seconds</font> <font color="#008000">(</font> <font color="#0000dd">10</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//     </font> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Rendering Data"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> val <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//    10 </font> <br> <br> <font color="#666666">//   -   Val</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  №16:  ,  ,    ,        std::future::get() </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设我们有以下代码片段，您认为调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: future :: get（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的结果是</font><font style="vertical-align: inherit;">什么？</font><font style="vertical-align: inherit;">如果您认为程序将崩溃-绝对正确！</font><font style="vertical-align: inherit;">仅当</font><font style="vertical-align: inherit;">在</font><i><font style="vertical-align: inherit;">std :: future对象</font></i><font style="vertical-align: inherit;">上</font><font style="vertical-align: inherit;">调用</font><i><font style="vertical-align: inherit;">get（）</font></i><font style="vertical-align: inherit;">方法时，才会引发异步操作中引发的异常</font><font style="vertical-align: inherit;">。如果</font><font style="vertical-align: inherit;">未调用</font><i><font style="vertical-align: inherit;">get（）</font></i><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">，则当</font><i><font style="vertical-align: inherit;">std :: future</font></i><font style="vertical-align: inherit;">对象超出范围</font><font style="vertical-align: inherit;">时，将忽略并引发异常</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您的异步操作可能引发异常，则应始终将对</font><i><font style="vertical-align: inherit;">std :: future :: get（）</font></i><font style="vertical-align: inherit;">的调用包装</font><font style="vertical-align: inherit;">在</font><i><font style="vertical-align: inherit;">try / catch</font></i><font style="vertical-align: inherit;">块中。有关此示例的示例：</font></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> result <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> result <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#000040">&amp;</font> e <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Async task threw exception: "</font> <font color="#000080">&lt;&lt;</font> e. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  №17:  std::async,        </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管</font><font style="vertical-align: inherit;">在大多数情况下</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: async（）就</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">足够了，但在某些情况下，您可能需要仔细控制流中代码的执行。例如，如果您要将特定线程绑定到多处理器系统（例如Xbox）中的特定处理器核心。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给定的代码片段建立了线程与系统中第5个处理器内核的绑定。</font><font style="vertical-align: inherit;">这要归功于</font><i><font style="vertical-align: inherit;">std :: thread</font></i><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">native_handle（）</font></a><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">，并将其传递给</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Win32 API</font></a><font style="vertical-align: inherit;">流函数</font><font style="vertical-align: inherit;">。通过流Win32 API提供的许多其他功能在</font><i><font style="vertical-align: inherit;">std :: thread</font></i><font style="vertical-align: inherit;">或</font><i><font style="vertical-align: inherit;">std :: async（）</font></i><font style="vertical-align: inherit;">中不可用</font><font style="vertical-align: inherit;">。通过工作时</font></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;windows.h&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> DWORD result <font color="#000080">=</font> <font color="#008080">::</font> <font color="#007788">SetThreadIdealProcessor</font> <font color="#008000">(</font> t1. <font color="#007788">native_handle</font> <font color="#008000">(</font> <font color="#008000">)</font> , <font color="#0000dd">5</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: async（），</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些基本平台功能不可用，这使此方法不适用于更复杂的任务。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一种方法是创建</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: packaged_task</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后在设置线程的属性后将其移动到所需的执行线程。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 错误＃18：创建的“正在运行”的线程比可用的内核多得多 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从体系结构的角度来看，流可以分为两类：“正在运行”和“正在等待”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正在运行的线程占用了正在运行的内核的处理器时间的100％。当一个内核分配多个运行线程时，CPU利用率降低。如果在一个处理器内核上执行多个运行线程，则不会获得性能提升-实际上，由于附加的上下文切换，性能会下降。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待线程仅使用几个时钟周期，在等待系统事件或网络I / O等时执行。在这种情况下，内核的大部分可用处理器时间仍未使用。一个等待线程可以处理数据，而另一个等待线程正在等待事件触发，这就是为什么将多个等待线程分配到一个内核是有利的。每个内核调度多个未决线程可以提供更高的程序性能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那么，如何理解系统支持多少个正在运行的线程呢？使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: thread :: hardware_concurrency（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">。此函数通常返回处理器核心的数量，但是由于以下原因，它会考虑充当两个或多个逻辑核心的核心：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超踩踏</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您必须使用获得的目标平台值来计划程序同时运行的最大线程数。您还可以为所有挂起的线程分配一个核心，并使用剩余的核心数来运行线程。例如，在四核系统中，对所有挂起的线程使用一个核，对于其余三个核，使用三个运行线程。根据线程调度程序的效率，某些可执行线程可能会切换上下文（由于页面访问失败等），从而使内核处于非活动状态一段时间。如果在分析过程中观察到这种情况，则应创建比内核数量稍多的已执行线程，并为系统配置该值。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 错误19：使用volatile关键字进行同步 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在指定变量类型之前</font><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volatile</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关键字</font><font style="vertical-align: inherit;">不会使对该变量进行原子或线程安全的操作。</font><font style="vertical-align: inherit;">您可能想要的是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: atomic</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">更多详细信息，</font><font style="vertical-align: inherit;">请参见关于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stackoverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的讨论</font><font style="vertical-align: inherit;">。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 错误20：除非绝对必要，否则请使用无锁架构 </font></font></h3><br>    -,    .  ,    (lock free),         ,   ,  ,   . . ,    C ++,    ,  ,             ,         (     ,       !). <br><br>     C ++    ,       ,         ,            10 . <br><br>          ,     : <br><br><ul><li>         ,       ?  ,  –  . </li><li>    ,         ?  ,      ? </li><li>          ? </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总之，对于正常的应用程序开发，请仅在用尽所有其他替代方法后才考虑非锁定编程。</font><font style="vertical-align: inherit;">另一种看待这种情况的方式是，如果您仍在犯上述19个错误中的某些错误，则可能应避免编程而不会阻塞。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[从。</font><font style="vertical-align: inherit;">译者：非常感谢</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vovo4K</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">帮助</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;">我</font></a><font style="vertical-align: inherit;">准备了本文。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN443406/">https://habr.com/ru/post/zh-CN443406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN443396/index.html">3D打印和气枪：我如何打印“驱动器”</a></li>
<li><a href="../zh-CN443398/index.html">在工业企业中实施ERP：Alevtina Svetozarovna和Excel反对苛刻的建筑师和英语工厂</a></li>
<li><a href="../zh-CN443400/index.html">计算Windows计算器中的错误</a></li>
<li><a href="../zh-CN443402/index.html">如何使代码审查更快，更有效</a></li>
<li><a href="../zh-CN443404/index.html">NASA寻找地球外文明的新目标：技术标志</a></li>
<li><a href="../zh-CN443408/index.html">光子，量子和Fock状态：利用射频谐振器进行量子级操纵</a></li>
<li><a href="../zh-CN443412/index.html">为什么尽管精简的Python程序员仍继续使用冗长的Java</a></li>
<li><a href="../zh-CN443414/index.html">路标：断点不足时</a></li>
<li><a href="../zh-CN443416/index.html">Winnti：对供应链的攻击-亚洲游戏开发商处在最前沿</a></li>
<li><a href="../zh-CN443418/index.html">软件测试方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>