<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ã üéüÔ∏è ‚úçüèº Manajemen Karakter dengan SharedEvents üë®üèª‚Äçüîß üçπ üîã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tautan ke proyek 

 Dalam artikel ini, saya ingin menunjukkan bagaimana Anda dapat menggunakan SharedEvents untuk mengontrol karakter orang ketiga yan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manajemen Karakter dengan SharedEvents</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439194/"><iframe width="560" height="315" src="https://www.youtube.com/embed/v3lTKkwBDyE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan ke proyek</a> <br><br>  Dalam artikel ini, saya ingin menunjukkan bagaimana Anda dapat menggunakan <b>SharedEvents</b> untuk mengontrol karakter orang ketiga yang menawarkan serangkaian aset standar.  Saya menulis tentang <b>SharedEvents</b> di artikel sebelumnya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> ). <br><br>  Selamat datang di kucing! <br><a name="habracut"></a><br>  Hal pertama yang Anda butuhkan adalah mengambil proyek dengan SharedState / SharedEvents yang diimplementasikan dan menambahkan seperangkat aset standar <br><br><img src="https://habrastorage.org/webt/3e/6p/if/3e6pifqmbgtgupypezxrm6lqr08.jpeg"><br><br>  Saya membuat adegan kecil dan sangat sederhana dari membuat prototipe cetakan <br><br><img src="https://habrastorage.org/webt/i2/gt/zu/i2gtzu4zyhrlbjdg5qahs3wti18.jpeg"><br><br>  Dan memanggang navigasi permukaan dengan pengaturan standar <br><br><img src="https://habrastorage.org/webt/tl/ci/if/tlciif79oujqrvkaln_tsajxjgo.jpeg"><br><br>  Setelah itu, Anda perlu menambahkan prefab <b>ThirdPersonCharacter</b> ke adegan ini <br><br><img src="https://habrastorage.org/webt/ut/vj/uo/utvjuofiddf4gcrwnf4rr-cfpvs.jpeg"><br><br>  Kemudian Anda dapat memulai dan memastikan bahwa semuanya berjalan di luar kotak.  Kemudian Anda dapat melanjutkan untuk mengonfigurasi penggunaan <b>infrastruktur SharedState / SharedEvents yang</b> dibuat sebelumnya.  Untuk melakukan ini, hapus komponen <b>ThirdPersonUserController</b> dari objek karakter. <br><br><img src="https://habrastorage.org/webt/8f/gy/hu/8fgyhuqj2hafnuwss-mqebno_jw.jpeg"><br><br>  karena kontrol manual menggunakan keyboard tidak diperlukan.  Karakter akan dikontrol oleh agen, menunjukkan posisi di mana ia akan bergerak. <br><br>  Dan untuk memungkinkan ini, Anda perlu menambahkan dan mengkonfigurasi komponen <b>NavMeshAgent</b> ke objek karakter <br><br><img src="https://habrastorage.org/webt/sf/yq/qs/sfyqqsgrktyfnqwobzc_nkqtuxw.jpeg"><br><br>  Sekarang Anda perlu membuat pengontrol sederhana yang akan mengontrol karakter <br>  dengan mouse <b>AgentMouseController</b> <br><br><img src="https://habrastorage.org/webt/p0/xf/nd/p0xfndfiw52su5yd7pu5mnkhlae.jpeg"><br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityStandardAssets.Characters.ThirdPerson; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AgentMouseController</span></span></span><span class="hljs-class"> :</span></span> MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NavMeshAgent agent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ThirdPersonCharacter character; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Camera cam; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      agent.updateRotation = false; } void Update() { //     if (Input.GetMouseButtonDown(0)) { Ray ray = cam.ScreenPointToRay(Input.mousePosition); RaycastHit hit; if (Physics.Raycast(ray, out hit)) { agent.SetDestination(hit.point); } } //    ,     if(agent.remainingDistance &gt; agent.stoppingDistance) { character.Move(agent.desiredVelocity, false, false); } else // ,    { character.Move(Vector3.zero, false, false); } } }</span></span></code> </pre> <br>  Dan tambahkan ke objek karakter, berikan tautan ke kamera, pengontrol dan agen karakter.  Semua tersedia dari panggung. <br><br><img src="https://habrastorage.org/webt/6i/_a/p3/6i_ap3pgbgxkvkl9h4pl0c4mbzi.jpeg"><br><br>  Dan itu saja.  Ini cukup untuk mengontrol karakter dengan memberi tahu agen tempat bergerak, menggunakan mouse (klik kiri). <br><br>  Anda dapat memulai dan memastikan semuanya bekerja <br><br><img src="https://habrastorage.org/webt/3n/n_/g-/3nn_g-peo8ivng5gop0l5-75dta.jpeg"><br><br><h2>  Integrasi SharedEvents </h2><br>  Sekarang setelah adegan dasar siap, Anda dapat melanjutkan untuk mengintegrasikan kontrol karakter melalui <b>SharedEvents</b> .  Untuk melakukan ini, Anda perlu membuat beberapa komponen.  Yang pertama adalah komponen yang akan bertanggung jawab untuk menerima sinyal dari mouse dan memberitahukan semua komponen yang melacak posisi klik mouse di tempat kejadian, mereka hanya akan tertarik pada koordinat klik. <br><br>  Komponen akan dipanggil, misalnya, <b>MouseHandlerComponent</b> <br><br><img src="https://habrastorage.org/webt/ib/yk/v4/ibykv4n3mal6i1lfatsrjyto-ha.jpeg"><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MouseHandlerComponent</span></span></span><span class="hljs-class"> :</span></span> SharedStateComponent { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Camera cam; <span class="hljs-meta"><span class="hljs-meta">#region MonoBehaviour protected override void OnSharedStateChanged(SharedStateChangedEventData newState) { } protected override void OnStart() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (cam == null) throw new MissingReferenceException(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"   "</span></span></span><span class="hljs-meta">); } protected override void OnUpdate() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     if (Input.GetMouseButtonDown(0)) { //           var hit = GetMouseHit(); Events.PublishAsync("poittogound", new PointOnGroundEventData { Sender = this, Point = hit.point }); } } #endregion private RaycastHit GetMouseHit() { Ray ray = cam.ScreenPointToRay(Input.mousePosition); RaycastHit hit; Physics.Raycast(ray, out hit); return hit; } }</span></span></span></span></code> </pre><br>  Komponen ini membutuhkan kelas untuk mengirim data dalam pemberitahuan.  Untuk kelas yang hanya akan berisi data untuk pemberitahuan, Anda dapat membuat satu file dan <b>beri</b> nama <b>DefinedEventsData</b> <br><br><img src="https://habrastorage.org/webt/5y/bp/ar/5ybparw0g4vguy5tkbyttntdodm.jpeg"><br><br>  Dan tambahkan satu kelas untuk itu, untuk mengirim posisi klik dengan mouse <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PointOnGroundEventData</span></span></span><span class="hljs-class"> :</span></span> EventData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Point { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } }</code> </pre><br>  Hal selanjutnya yang harus dilakukan adalah menambahkan komponen yang akan menjadi pembungkus atau dekorator, sesuka Anda, untuk komponen <b>NavMeshAgent</b> .  Karena saya tidak akan mengubah komponen (pihak ketiga) yang ada, saya akan menggunakan dekorator untuk berintegrasi dengan <b>SharedState / SharedEvents</b> . <br><br><img src="https://habrastorage.org/webt/yi/1k/v5/yi1kv5s0ytqgy7folh3tygjmtky.jpeg"><br><br>  Komponen ini akan menerima pemberitahuan tentang klik mouse pada titik-titik tertentu di tempat kejadian dan memberi tahu agen tempat untuk pindah.  Dan juga memantau posisi posisi agen di setiap frame dan membuat pemberitahuan tentang perubahannya. <br><br>  Komponen ini akan tergantung pada komponen <b>NavMeshAgent.</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; [RequireComponent(typeof(NavMeshAgent))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AgentWrapperComponent</span></span></span><span class="hljs-class"> :</span></span> SharedStateComponent { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NavMeshAgent agent; <span class="hljs-meta"><span class="hljs-meta">#region Monobehaviour protected override void OnSharedStateChanged(SharedStateChangedEventData newState) { } protected override void OnStart() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  agent = GetComponent&lt;NavMeshAgent&gt;(); //      agent.updateRotation = false; Events.Subscribe&lt;PointOnGroundEventData&gt;("pointtoground", OnPointToGroundGot); } protected override void OnUpdate() { //     if (agent.remainingDistance &gt; agent.stoppingDistance) { Events.Publish("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = agent.desiredVelocity }); } else { Events.Publish("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = Vector3.zero }); } } #endregion private void OnPointToGroundGot(PointOnGroundEventData eventData) { //    agent.SetDestination(eventData.Point); } }</span></span></span></span></code> </pre> <br><br>  Untuk mengirim data, komponen ini membutuhkan kelas yang perlu ditambahkan ke file <b>DefinedEventsData.</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AgentMoveEventData</span></span></span><span class="hljs-class"> :</span></span> EventData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 DesiredVelocity { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } }</code> </pre> <br>  Ini sudah cukup bagi karakter untuk bergerak.  Tapi dia akan melakukannya tanpa animasi, karena kita belum menggunakan <b>ThirdPersonCharater</b> .  Dan untuk itu, seperti untuk <b>NavMeshAgent,</b> Anda perlu membuat dekorator CharacterWrapperComponent <br><br><img src="https://habrastorage.org/webt/j1/zz/h_/j1zzh_hp8qcyklhx3zeldtjrsn4.jpeg"><br><br>  Komponen akan mendengarkan pemberitahuan tentang perubahan posisi agen, dan memindahkan karakter ke arah yang diterima dari pemberitahuan (acara). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityStandardAssets.Characters.ThirdPerson; [RequireComponent(typeof(ThirdPersonCharacter))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharacterWrapperComponent</span></span></span><span class="hljs-class"> :</span></span> SharedStateComponent { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ThirdPersonCharacter character; <span class="hljs-meta"><span class="hljs-meta">#region Monobehaviour protected override void OnSharedStateChanged(SharedStateChangedEventData newState) { } protected override void OnStart() { character = GetComponent</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ThirdPersonCharacter&gt;(); Events.Subscribe&lt;AgentMoveEventData&gt;("agentmoved", OnAgentMove); } protected override void OnUpdate() { } #endregion private void OnAgentMove(AgentMoveEventData eventData) { //       character.Move(eventData.DesiredVelocity, false, false); } }</span></span></span></span></code> </pre> <br>  Dan itu saja.  Tetap menambahkan komponen-komponen ini ke objek permainan karakter.  Anda perlu membuat salinan dari yang sudah ada, menghapus komponen <b>AgentMouseControl yang</b> lama <br><br><img src="https://habrastorage.org/webt/az/_c/yk/az_cyk_etfyxuabjqhrbjiqxsoy.jpeg"><br><br>  Dan tambahkan <b>MouseHandlerComponent</b> , <b>AgentWrapperComponent</b> dan <b>CharacterWrapperComponent baru</b> . <br><br>  Di <b>MouseHandlerComponent</b> Anda perlu mentransfer kamera dari tempat dari mana posisi klik akan dihitung. <br><br><img src="https://habrastorage.org/webt/wv/fa/lm/wvfalm5obqvcach5uvnazlsuggu.jpeg"><br><br><img src="https://habrastorage.org/webt/vi/lq/b4/vilqb40pamgox4vbcmvogziuucw.jpeg"><br><br>  Anda dapat memulai dan memastikan semuanya bekerja. <br><br>  Itu terjadi dengan bantuan <b>SharedEvents</b> untuk mengontrol karakter tanpa memiliki koneksi langsung antara komponen, seperti pada contoh pertama.  Ini akan memungkinkan konfigurasi komponen komposisi berbeda yang lebih fleksibel dan menyesuaikan interaksi di antara mereka. <br><br><h2>  Perilaku Asynchronous untuk SharedEvents </h2><br>  Cara mekanisme pemberitahuan sekarang diterapkan didasarkan pada transmisi sinkron sinyal dan prosesnya.  Artinya, semakin banyak pendengar, semakin lama prosesnya.  Untuk menghindari hal ini, Anda perlu menerapkan pemrosesan notifikasi sinkron.  Hal pertama yang harus dilakukan adalah menambahkan versi asinkron dari metode <b>Publikasikan</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  data    eventName  public async Task PublishAsync&lt;T&gt;(string eventName, T data) where T : EventData { if (_subscribers.ContainsKey(eventName)) { var listOfDelegates = _subscribers[eventName]; var tasks = new List&lt;Task&gt;(); foreach (Action&lt;T&gt; callback in listOfDelegates) { tasks.Add(Task.Run(() =&gt; { callback(data); })); } await Task.WhenAll(tasks); } }</span></span></code> </pre> <br>  Sekarang kita perlu mengubah metode <b>OnUpdate</b> abstrak di kelas dasar <b>SharedStateComponent</b> menjadi asinkron sehingga mengembalikan tugas yang dimulai di dalam implementasi metode ini dan <b>menamainya</b> menjadi <b>OnUpdateAsync</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> abstract Task[] OnUpdateAsync();</code> </pre> <br>  Anda juga akan membutuhkan mekanisme yang akan mengontrol penyelesaian tugas dari frame sebelumnya, sebelum saat ini <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Task[] _previosFrameTasks = null; <span class="hljs-comment"><span class="hljs-comment">//   private async Task CompletePreviousTasks() { if (_previosFrameTasks != null &amp;&amp; _previosFrameTasks.Length &gt; 0) await Task.WhenAll(_previosFrameTasks); }</span></span></code> </pre> <br>  Metode <b>Pembaruan</b> di kelas dasar perlu ditandai sebagai <b>async</b> dan pra-periksa pelaksanaan tugas sebelumnya <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">async </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompletePreviousTasks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//     _previosFrameTasks = OnUpdateAsync(); }</span></span></code> </pre> <br>  Setelah perubahan ini di kelas dasar, Anda dapat melanjutkan untuk mengubah implementasi metode <b>OnUpdate</b> lama ke <b>OnUpdateAsync</b> baru.  Komponen pertama di mana ini akan dilakukan adalah <b>AgentWrapperComponent</b> .  Sekarang metode ini mengharapkan kembalinya hasil.  Hasil ini akan menjadi array tugas.  Array karena dalam metode ini beberapa dapat diluncurkan secara paralel dan kami akan memprosesnya secara berkelompok. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-comment"><span class="hljs-comment">//     if (agent.remainingDistance &gt; agent.stoppingDistance) { return new Task[] { Events.PublishAsync("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = agent.desiredVelocity }) }; } else { return new Task[] { Events.PublishAsync("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = Vector3.zero }) }; } }</span></span></code> </pre> <br>  Kandidat berikutnya untuk perubahan metode <b>OnUpdate</b> adalah <b>MouseHandlerController</b> .  Di sini prinsipnya sama <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-comment"><span class="hljs-comment">//     if (Input.GetMouseButtonDown(0)) { //           var hit = GetMouseHit(); return new Task[] { Events.PublishAsync("pointtoground", new PointOnGroundEventData { Sender = this, Point = hit.point }) }; } return null; }</span></span></code> </pre><br>  Di semua implementasi lain di mana metode ini kosong, cukup untuk menggantinya <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  Itu saja.  Sekarang Anda dapat memulai, dan jika komponen yang memproses notifikasi secara serempak tidak mengakses komponen-komponen yang seharusnya diproses di utas utama, seperti Transform, misalnya, semuanya akan berfungsi.  Jika tidak, kami akan mendapatkan kesalahan di konsol yang memberitahukan bahwa kami mengakses komponen-komponen ini bukan dari utas utama <br><br><img src="https://habrastorage.org/webt/sp/hq/it/sphqitlfyw2zspaznnsu0tec3sy.jpeg"><br><br>  Untuk mengatasi masalah ini, Anda perlu membuat komponen yang akan memproses kode di utas utama.  Buat folder terpisah untuk skrip dan sebut Sistem, dan juga tambahkan skrip <b>Dispatcher</b> ke skrip tersebut. <br><br><img src="https://habrastorage.org/webt/m2/gp/m2/m2gpm2tf3u8z6fn1ioov9brmhvu.jpeg"><br><br>  Komponen ini akan menjadi singleton dan memiliki satu metode abstrak publik yang akan mengeksekusi kode di utas utama.  Prinsip operator sangat sederhana.  Kami akan menyampaikan kepadanya delegasi yang akan dieksekusi di utas utama, ia akan menempatkan mereka dalam antrian.  Dan di setiap frame, jika ada sesuatu dalam antrian, jalankan di utas utama.  Komponen ini akan menambahkan dirinya ke adegan dalam satu salinan, saya suka pendekatan yang sederhana dan efektif. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Concurrent; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dispatcher</span></span></span><span class="hljs-class"> :</span></span> MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dispatcher _instance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _queued = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ConcurrentQueue&lt;Action&gt; _queue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;Action&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly object _sync_ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> object(); <span class="hljs-comment"><span class="hljs-comment">//     public static void RunOnMainThread(Action action) { _instance._queue.Enqueue(action); lock (_sync_) { _instance._queued = true; } } //       () [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)] private static void Initialize() { if (_instance == null) { _instance = new GameObject("Dispatcher").AddComponent&lt;Dispatcher&gt;(); DontDestroyOnLoad(_instance.gameObject); } } void Update() { if (_queued) //   { while (!_queue.IsEmpty) { if (_queue.TryDequeue(out Action a)) { StartCoroutine(ActionWrapper(a)); } } lock (_sync_) { _queued = false; } } } //    IEnumerator ActionWrapper(Action a) { a(); yield return null; } }</span></span></code> </pre> <br>  Hal selanjutnya yang harus dilakukan adalah menerapkan dispatcher.  Ada 2 tempat untuk melakukan ini.  Pertama adalah dekorator karakter, di sana kami menanyakan arahnya.  Dalam komponen <b>CharacterWrapperComponent</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAgentMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AgentMoveEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ Dispatcher.RunOnMainThread(() =&gt; character.Move(eventData.DesiredVelocity, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)); }</code> </pre> <br>  2 adalah dekorator agen, di sana kami menunjukkan posisi untuk agen.  Dalam komponen <b>AgentWrapperComponent</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPointToGroundGot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PointOnGroundEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    Dispatcher.RunOnMainThread(() =&gt; agent.SetDestination(eventData.Point)); }</span></span></code> </pre> <br>  Sekarang tidak akan ada kesalahan, kode akan berfungsi dengan benar.  Anda dapat memulai dan melihat ini. <br><br><h2>  Sedikit refactoring </h2><br>  Setelah semuanya siap dan semuanya berfungsi, Anda dapat menyisir kode sedikit dan membuatnya sedikit lebih nyaman dan sederhana.  Ini akan membutuhkan beberapa perubahan. <br><br>  Agar tidak membuat array tugas dan memasukkan satu-satunya tugas secara manual, Anda dapat membuat metode ekstensi.  Untuk semua metode ekstensi, Anda dapat menggunakan file yang sama untuk transmisi ke notifikasi serta untuk semua kelas.  Ini akan terletak di folder <b>System</b> dan disebut <b>Extensions</b> <br><br><img src="https://habrastorage.org/webt/8z/nv/wx/8znvwxom9bvxipj5ctvuuasveky.jpeg"><br><br>  Di dalam, kami akan membuat metode ekstensi generik sederhana yang akan membungkus instance apa pun dalam array <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extensions</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//    public static T[] WrapToArray&lt;T&gt;(this T source) { return new T[] { source }; } }</span></span></code> </pre> <br>  Perubahan selanjutnya adalah menyembunyikan penggunaan langsung dari operator dalam komponen.  Sebagai gantinya, buat metode di kelas dasar <b>SharedStateComponent</b> dan gunakan dispatcher dari sana. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PerformInMainThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Action action)</span></span></span><span class="hljs-function"> </span></span>{ Dispatcher.RunOnMainThread(action); }</code> </pre><br>  Dan sekarang Anda perlu menerapkan perubahan ini di beberapa tempat.  Pertama, ubah metode di mana kami secara manual membuat array tugas dan memasukkannya ke dalam satu instance <br>  Dalam komponen <b>AgentWrapperComponent</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-comment"><span class="hljs-comment">//     if (agent.remainingDistance &gt; agent.stoppingDistance) { return Events.PublishAsync("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = agent.desiredVelocity }) .WrapToArray(); } else { return Events.PublishAsync("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = Vector3.zero }) .WrapToArray(); } }</span></span></code> </pre> <br>  Dan di komponen <b>MouseHandlerComponent</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-comment"><span class="hljs-comment">//     if (Input.GetMouseButtonDown(0)) { //           var hit = GetMouseHit(); return Events.PublishAsync("pointtoground", new PointOnGroundEventData { Sender = this, Point = hit.point }) .WrapToArray(); } return null; }</span></span></code> </pre> <br>  Sekarang kita menyingkirkan penggunaan langsung dari dispatcher di komponen dan sebaliknya kita memanggil metode <b>PerformInMainThread</b> di kelas dasar. <br><br>  Pertama di <b>AgentWrapperComponent</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPointToGroundGot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PointOnGroundEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    PerformInMainThread(() =&gt; agent.SetDestination(eventData.Point)); }</span></span></code> </pre> <br>  dan di komponen <b>CharacterWrapperComponent</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAgentMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AgentMoveEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ PerformInMainThread(() =&gt; character.Move(eventData.DesiredVelocity, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)); }</code> </pre> <br>  Itu saja.  Tetap menjalankan permainan dan memastikan tidak ada yang rusak selama refactoring dan semuanya berfungsi dengan benar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439194/">https://habr.com/ru/post/id439194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439182/index.html">Bagaimana kami mendistribusikan pesanan antar driver di Yandex.Taxi</a></li>
<li><a href="../id439184/index.html">Ubah kata sandi Anda: menguji kebijakan kata sandi layanan web</a></li>
<li><a href="../id439186/index.html">Editor UX: kisah nyata, kehidupan nyata</a></li>
<li><a href="../id439190/index.html">Cara membuat aplikasi augmented reality menggunakan ARCore</a></li>
<li><a href="../id439192/index.html">Speaker PC Ke Sebelas</a></li>
<li><a href="../id439196/index.html">Analis JPMorgan: Apple harus membeli Blizzard, Netflix atau Sonos untuk meyakinkan investor</a></li>
<li><a href="../id439198/index.html">Generasi Pulau Barrier</a></li>
<li><a href="../id439200/index.html">Komposer untuk anak kecil</a></li>
<li><a href="../id439202/index.html">Deteksi Serangan Web Menggunakan Seq2Seq Auto Encoder</a></li>
<li><a href="../id439204/index.html">Meningkatkan efisiensi fotosintesis dengan modifikasi genetik tanaman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>