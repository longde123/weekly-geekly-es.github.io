<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçü§ù‚Äçüë®üèª üê¢ ü¶à Qt: desenho baseado em gr√°ficos vetoriais üë®‚Äçüíª üßü üë∞üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Qt fornece ao programador recursos muito ricos, mas o conjunto de widgets √© limitado. Se nenhuma das op√ß√µes dispon√≠veis for adequada, voc√™ dever√° de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt: desenho baseado em gr√°ficos vetoriais</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425547/"><p><img src="https://habrastorage.org/webt/kp/7v/oi/kp7voi6ve63y4yxzdtthd-dxs80.png" align="right">  O Qt fornece ao programador recursos muito ricos, mas o conjunto de widgets √© limitado.  Se nenhuma das op√ß√µes dispon√≠veis for adequada, voc√™ dever√° desenhar algo pr√≥prio.  A maneira mais simples - usar imagens prontas - tem s√©rias desvantagens: a necessidade de armazenar imagens em um arquivo ou recursos, problemas com escalabilidade e portabilidade dos formatos de imagem.  A seguir, descreve o uso dos princ√≠pios dos gr√°ficos vetoriais sem usar as imagens vetoriais reais. </p><a name="habracut"></a><br><h2 id="preambula">  Pre√¢mbulo </h2><br><p>  Tudo come√ßou com o fato de que uma vez que uma indica√ß√£o de sinais de um bit era necess√°ria.  Alguns aplicativos recebem alguns dados em alguma porta, o pacote deve ser desmontado e exibido na tela.  Seria bom, ao mesmo tempo, imitar o painel familiar.  Para exibir dados digitais, o Qt oferece "out of the box" a classe QLCDNumber, semelhante aos indicadores familiares de sete segmentos, mas algo n√£o √© vis√≠vel em l√¢mpadas simples. </p><br><p>  O uso de sinalizadores (caixas de sele√ß√£o) e comutadores (bot√µes de op√ß√£o) para esses fins √© ruim e aqui est√° uma lista de raz√µes: </p><br><ul><li>  Isso est√° errado semanticamente.  Bot√µes - s√£o bot√µes e destinam-se √† entrada do usu√°rio, e n√£o para mostrar nada a ele. </li><li>  Isso implica o segundo: o usu√°rio se esfor√ßa para cutucar esses bot√µes.  Se ao mesmo tempo a atualiza√ß√£o de informa√ß√µes n√£o for particularmente r√°pida, a indica√ß√£o permanecer√° e o usu√°rio relatar√° um mau funcionamento do programa, rindo muito. </li><li>  Se voc√™ travar o bot√£o para pressionar (setEnabled (false)), ele ficar√° cinza feio.  Lembro-me de que no Delphi, na regi√£o da vers√£o 6, havia uma finta de orelhas: voc√™ podia colocar uma bandeira no painel e desativar a disponibilidade do painel, n√£o a bandeira, ent√£o a bandeira n√£o estava nem cinza nem ativa.  Este truque n√£o funciona aqui. </li><li>  Os bot√µes t√™m foco de entrada.  Assim, se houver elementos de entrada na janela e o usu√°rio caminhar com eles usando a tecla Tab, ele precisar√° caminhar pelos elementos de sa√≠da, o que √© inconveniente e feio. </li><li>  No final, esses bot√µes parecem apenas esteticamente, principalmente ao lado dos sete segmentos. </li></ul><br><p>  Conclus√£o: voc√™ mesmo precisa desenhar uma l√¢mpada. </p><br><h2 id="muki-vybora">  Farinha de escolha </h2><br><p>  Primeiro, procurei solu√ß√µes prontas.  Naquele tempo distante, quando usei o Delphi, era poss√≠vel encontrar apenas uma quantidade gigantesca de componentes acabados, tanto de empresas s√©rias quanto de fabricantes amadores.  O Qt tem muitos problemas com isso.  O QWT tem alguns elementos, mas n√£o isso.  Eu n√£o via amadorismo.  Provavelmente, se voc√™ digitar corretamente no Github, poder√° encontrar algo, mas eu provavelmente o farei mais r√°pido. </p><br><p>  A primeira coisa que sugeriu a partir do caseiro foi usar dois arquivos de imagem com imagens da luz acesa e apagada.  Ruim: </p><br><ul><li>  √â necess√°rio encontrar boas fotos (ou desenhar, mas n√£o sou artista); </li><li>  A quest√£o do princ√≠pio √©: amarrar n√£o √© bom, nem imagens, nem mesmo debaixo dos seus p√©s; </li><li>  Eles devem ser armazenados em algum lugar.  Os arquivos s√£o muito ruins: apagados acidentalmente - e n√£o h√° bot√µes.  Os recursos s√£o melhores, mas tamb√©m n√£o sinto que consiga sobreviver; </li><li>  Sem escalabilidade; </li><li>  A personaliza√ß√£o (cores, por exemplo) √© alcan√ßada apenas adicionando arquivos.  Ou seja, recursos intensivos e inflex√≠veis. </li></ul><br><p>  A segunda coisa que se segue da primeira √© usar imagens vetoriais em vez de imagens.  Al√©m disso, o Qt pode renderizar SVG.  Aqui j√° √© um pouco mais f√°cil com a pesquisa da pr√≥pria imagem: h√° muitas li√ß√µes sobre os gr√°ficos vetoriais na rede, voc√™ pode encontrar algo mais ou menos adequado e adapt√°-lo √†s suas necessidades.  Mas permanece a quest√£o de armazenamento e personaliza√ß√£o, e a renderiza√ß√£o n√£o √© livre de recursos.  Moedas de um centavo, √© claro, mas ainda assim ... </p><br><p>  E o terceiro segue a partir do segundo: voc√™ pode usar os princ√≠pios de gr√°ficos vetoriais para imagens de auto desenho!  Um arquivo de imagem vetorial em forma de texto indica o que e como desenhar.  Eu posso especificar o mesmo c√≥digo usando tutoriais de vetor.  Felizmente, o objeto QPainter possui as ferramentas necess√°rias: uma caneta, um pincel, um gradiente e primitivas de desenho, at√© um preenchimento de textura.  Sim, as ferramentas est√£o longe de tudo: n√£o h√° m√°scaras, modos de mesclagem, mas absolutamente nenhum fotorrealismo √© necess√°rio. </p><br><p>  Procurei alguns exemplos na rede.  Ele aprendeu a primeira li√ß√£o que surgiu: ‚ÄúDesenhamos um bot√£o no editor de gr√°ficos do Inkscape‚Äù no site ‚Äú√â f√°cil desenhar‚Äù.  O bot√£o desta li√ß√£o √© muito mais parecido com uma l√¢mpada do que com um bot√£o, o que combina perfeitamente comigo.  Estou fazendo um rascunho: em vez do Inkscape, um projeto no Qt. </p><br><h2 id="proba-pera">  Teste de penas </h2><br><p>  Estou criando um novo projeto.  Eu escolhi o nome do projeto rgbled (porque quero fazer algo como um LED RGB) e o caminho para ele.  Eu escolho a classe base QWidget e o nome RgbLed, me recuso a criar um arquivo de formul√°rio.  O projeto por padr√£o ap√≥s o lan√ßamento cria uma janela vazia, ainda √© desinteressante. </p><br><h3 id="podgotovka-k-risovaniyu">  Prepara√ß√£o para o desenho </h3><br><p>  H√° um espa√ßo em branco.  Agora voc√™ precisa obter os membros particulares da classe, que determinar√£o a geometria da imagem.  Uma vantagem essencial dos gr√°ficos vetoriais √© sua escalabilidade, portanto deve haver um n√∫mero m√≠nimo de n√∫meros constantes e eles apenas definem as propor√ß√µes.  As dimens√µes ser√£o recalculadas no evento resizeEvent (), que precisar√° ser redefinido. </p><br><p>  No tutorial de desenho usado, as dimens√µes s√£o especificadas em pixels √† medida que voc√™ avan√ßa.  Preciso determinar com anteced√™ncia o que vou usar e como recontar. </p><br><p>  Uma imagem desenhada consiste nos seguintes elementos: </p><br><ul><li>  anel externo (inclinado para fora, parte do aro convexo) </li><li>  anel interno (inclinado para dentro) </li><li>  Carca√ßa da l√¢mpada LED, ‚Äúvidro‚Äù </li><li>  sombra na borda do copo </li><li>  destaque principal </li><li>  reflexo inferior </li></ul><br><p>  C√≠rculos conc√™ntricos, isto √©, tudo, exceto o brilho, √© determinado pela posi√ß√£o do centro e do raio.  O brilho √© determinado pelo centro, largura e altura, e a posi√ß√£o dos X centros de brilho coincide com a posi√ß√£o do centro X de toda a imagem. </p><br><p>  Para calcular os elementos da geometria, √© necess√°rio determinar qual √© maior - a largura ou a altura, porque a l√¢mpada √© redonda e deve caber em um quadrado com um lado igual √† menor das duas dimens√µes.  Ent√£o, adiciono os membros privados correspondentes ao arquivo de cabe√ßalho. </p><br><div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minDim; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> half; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerY; QRect drawingRect; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexHeight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexHeight;</code> </pre> </div></div><br><p>  Em seguida, redefino a fun√ß√£o protegida que √© chamada quando o widget √© redimensionado. </p><br><div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: void resizeEvent(QResizeEvent *event); void RgbLed::resizeEvent(QResizeEvent *event) { QWidget::resizeEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;height = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().height(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;width = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().width(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;minDim = (height &gt; width) ? width : height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;half = minDim / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerX = width / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerY = height / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">14</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderRadius = half - outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderRadius = half - (outerBorderWidth + innerBorderWidth); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexY = centerY - (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexY = centerY + (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; drawingRect.setTop((height - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setLeft((width - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setHeight(minDim); drawingRect.setWidth(minDim); }</code> </pre> </div></div><br><p>  Aqui, o lado do quadrado no qual a l√¢mpada est√° inscrita √© calculado, o centro desse quadrado, o raio do aro ocupando a √°rea m√°xima poss√≠vel, a largura do aro, cuja parte externa deve ser 1/10 do di√¢metro e o 1/14 interno.  Em seguida, √© calculada a posi√ß√£o do brilho, localizada no meio dos raios superior e inferior, e a largura e a altura s√£o selecionadas a olho nu. </p><br><p>  Al√©m disso, nos campos protegidos, adicionarei imediatamente um conjunto de cores a serem usadas. </p><br><div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ledColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> lightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> shadowColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowDarkColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowMedColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowLightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexUpColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexDownColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexCenterColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexSideColor;</code> </pre> </div></div><br><p>  Pelos nomes, √© aproximadamente claro que essas s√£o as cores da l√¢mpada, a parte clara da sombra, a parte escura da sombra, as tr√™s cores da sombra anular ao redor da l√¢mpada e as cores dos gradientes de brilho. </p><br><p>  As cores devem ser inicializadas, para complementar a pe√ßa de trabalho do designer. </p><br><div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs php">RgbLed::RgbLed(QWidget *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) : QWidget(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>), ledColor(Qt::green), lightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>)), shadowColor(QColor(<span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)), ringShadowDarkColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>)), ringShadowMedColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>)), ringShadowLightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), topReflexUpColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xA0</span></span>)), topReflexDownColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexCenterColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexSideColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)) { }</code> </pre> </div></div><br><p>  Al√©m disso, n√£o esque√ßa de inserir no arquivo de cabe√ßalho as inclus√µes de classes que ser√£o necess√°rias ao desenhar. </p><br><div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPainter&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPen&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QBrush&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QColor&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QGradient&gt;</span></span></span></span></code> </pre> </div></div><br><p>  Esse c√≥digo √© compilado com √™xito, mas nada mudou na janela do widget.  √â hora de come√ßar a desenhar. </p><br><h3 id="risovanie">  Desenhando </h3><br><p>  Entro em uma fun√ß√£o fechada </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawLed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QColor &amp;color</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  e redefinir a fun√ß√£o protegida </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paintEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QPaintEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  O evento redesenhar causar√° o desenho real, para o qual a cor do "vidro" √© passada como par√¢metro. </p><br><div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::paintEvent(QPaintEvent *event) { QWidget::paintEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;drawLed(ledColor); }</code> </pre> </div></div><br><p>  At√© agora.  E come√ßamos a preencher gradualmente a fun√ß√£o de desenho. </p><br><div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::drawLed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QColor &amp;color) { <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; QPen pen; pen.setStyle(Qt::NoPen); p.setPen(pen); }</code> </pre> </div></div><br><p>  Primeiro, √© criado um objeto de artista, que estar√° envolvido no desenho.  Em seguida, √© criado um l√°pis que √© necess√°rio para que n√£o haja l√°pis: nesta imagem, o tra√ßado do contorno n√£o √© apenas necess√°rio, mas n√£o necess√°rio. </p><br><p>  Em seguida, o primeiro c√≠rculo √© desenhado de acordo com a li√ß√£o sobre gr√°ficos vetoriais: um c√≠rculo grande, preenchido com um gradiente radial.  O gradiente tem um ponto de ancoragem leve na parte superior, mas n√£o na borda, e um escuro na parte inferior, mas tamb√©m n√£o na borda.  Um pincel √© criado com base no gradiente, com esse pintor pintando um c√≠rculo (ou seja, uma elipse inscrita em um quadrado).  Acontece que esse c√≥digo </p><br><div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient outerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY - outerBorderRadius - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; outerRingGradient.setColorAt(0, lightColor); outerRingGradient.setColorAt(1, shadowColor); QBrush outerRingBrush(outerRingGradient); p.setBrush(outerRingBrush); p.drawEllipse(this-&gt;drawingRect); qDebug() &lt;&lt; "draw";</span></span></code> </pre> </div></div><br><p>  O ambiente enfatiza o par√¢metro de cor da fun√ß√£o drawLed porque n√£o √© usada.  Deixe-o tolerar, ele ainda n√£o √© necess√°rio, mas em breve ele precisar√°.  O projeto lan√ßado produz o seguinte resultado: </p><br><div class="spoiler">  <b class="spoiler_title">desenho</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tr/d5/w4/trd5w4j8fbipcfgzjzhgydbxln8.png"></p></div></div><br><p>  Adicione outro lote de c√≥digo. </p><br><div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient innerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY + innerBorderRadius + (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; innerRingGradient.setColorAt(0, lightColor); innerRingGradient.setColorAt(1, shadowColor); QBrush innerRingBrush(innerRingGradient); p.setBrush(innerRingBrush); p.drawEllipse(QPoint(centerX, centerY), outerBorderRadius, outerBorderRadius);</span></span></code> </pre> </div></div><br><p>  Quase o mesmo c√≠rculo, apenas menor em tamanho e de cabe√ßa para baixo.  Temos a seguinte imagem: </p><br><div class="spoiler">  <b class="spoiler_title">desenho</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sl/qa/-p/slqa-p1yxoytsvbaw86hsqniexw.png"></p></div></div><br><p>  Ent√£o, finalmente, voc√™ precisa da cor do vidro: </p><br><div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QColor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.darker</span></span>(120)); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  Aqui, usando a fun√ß√£o mais escura da cor transmitida, a mesma cor √© obtida, mas mais escura, para organizar o gradiente.  Coeficiente 120 selecionado a olho.  Aqui est√° o resultado: </p><br><div class="spoiler">  <b class="spoiler_title">desenho</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hs/wq/dl/hswqdl5hkf_fxabxawraf8alsgq.png"></p></div></div><br><p>  Adicione uma sombra anular ao redor do vidro.  Isso √© feito na li√ß√£o sobre gr√°ficos vetoriais, e isso deve adicionar volume e realismo: </p><br><div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowLightColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0<span class="hljs-selector-class"><span class="hljs-selector-class">.85</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowMedColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowDarkColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  H√° um gradiente de tr√™s etapas, de modo que a sombra fica mais grossa at√© a borda e fica p√°lida em dire√ß√£o ao centro.  Acontece assim: </p><br><div class="spoiler">  <b class="spoiler_title">desenho</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ga/0n/wj/ga0nwjnp8vjh6yupym3d_yyo5lc.png"></p></div></div><br><p>  Adicione destaques, ao mesmo tempo.  O destaque superior, diferente do inferior (e de todos os outros elementos), √© transformado em um gradiente linear.  O meu artista √© mais ou menos assim, aceito minha palavra como autor da li√ß√£o.  Talvez haja alguma verdade nisso, n√£o experimentarei diferentes tipos de gradientes. </p><br><div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QLinearGradient topTeflexGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> + outerBorderWidth)), QPoint(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY))<span class="hljs-comment"><span class="hljs-comment">; topTeflexGradient.setColorAt(0, topReflexUpColor); topTeflexGradient.setColorAt(1, topReflexDownColor); QBrush topReflexbrush(topTeflexGradient); p.setBrush(topReflexbrush); p.drawEllipse(QPoint(centerX, topReflexY), topReflexWidth, topReflexHeight); QRadialGradient bottomReflexGradient(QPoint(centerX, bottomReflexY + (bottomReflexHeight / 2)), bottomReflexWidth); bottomReflexGradient.setColorAt(0, bottomReflexSideColor); bottomReflexGradient.setColorAt(1, bottomReflexCenterColor); QBrush bottomReflexBrush(bottomReflexGradient); p.setBrush(bottomReflexBrush); p.drawEllipse(QPoint(centerX, bottomReflexY), bottomReflexWidth, bottomReflexHeight);</span></span></code> </pre> </div></div><br><p>  Na verdade, isso √© tudo, uma l√¢mpada pronta, como no KDPV. </p><br><div class="spoiler">  <b class="spoiler_title">desenho</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/99/xx/bm/99xxbmwsmy1r6fo-dht2pif7wdg.png"></p></div></div><br><p>  A visibilidade do brilho e da protuber√¢ncia do vidro √© afetada pela cor, ou melhor, pela escurid√£o.  Pode fazer sentido adicionar um ajuste para o brilho do brilho e o coeficiente de escurecimento na fun√ß√£o mais escura, dependendo da escurid√£o, mas acho que √© perfeccionismo. </p><br><p>  Abaixo est√° um exemplo de uso em uma janela de programa. </p><br><div class="spoiler">  <b class="spoiler_title">desenho</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xy/tt/ix/xyttix1vqiabybl7-no-9d2dgk8.png"></p></div></div><br><h3 id="balovstvo">  Mimos </h3><br><p>  Por divers√£o, voc√™ pode brincar com flores.  Por exemplo, substituindo um evento de clique do mouse protegido </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mousePressEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QMouseEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  desta maneira: </p><br><div class="spoiler">  <b class="spoiler_title">c√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::mousePressEvent(QMouseEvent *event) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event-&gt;button() == Qt::LeftButton) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: ledColor = Qt::red; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: ledColor = Qt::green; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: ledColor = Qt::blue; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: ledColor = Qt::gray; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ledColor = QColor(<span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;repaint(); } QWidget::mousePressEvent(event); }</code> </pre> </div></div><br><p>  n√£o esquecendo de adicionar eventos do mouse ao cabe√ßalho: </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QMouseEvent&gt;</span></span></span></span></code> </pre> <br><p>  Agora, um clique do mouse no componente mudar√° a cor da l√¢mpada: vermelha, verde, azul, cinza e alguma luz aleat√≥ria da l√¢mpada. </p><br><h2 id="epilog">  Ep√≠logo </h2><br><p>  Quanto ao desenho, √© tudo.  E o widget deve adicionar funcionalidade.  No meu caso, foi adicionado um campo booleano ‚Äúuse state‚Äù, outro campo booleano que define o estado ‚ÄúOn‚Äù ou ‚ÄúOff‚Äù e as cores padr√£o desses estados, al√©m de getters e setters abertos para tudo isso. a fun√ß√£o paintEvent () para selecionar a cor passada para drawLed () como par√¢metro. Como resultado, voc√™ pode desativar o uso de estados e definir a l√¢mpada para qualquer cor ou ativar os estados e ativar ou desativar a l√¢mpada de acordo com os eventos. √â especialmente conveniente tornar o configurador de estados um slot aberto e unido  seja com o sinal que deve ser monitorado. </p><br><p>  O uso do mousePressEvent demonstra que um widget pode ser feito n√£o apenas como indicador, mas tamb√©m como um bot√£o, pressionando-o, soltando-o, dobrando-o, torcendo-o, colorido e o que voc√™ quiser para os eventos de apontar, clicar e liberar. </p><br><p>  Mas isso n√£o √© mais fundamental.  O objetivo era mostrar onde √© poss√≠vel obter exemplos de modelos ao desenhar seus pr√≥prios widgets e como esse desenho √© f√°cil de implementar sem o uso de imagens raster ou vetoriais, em recursos ou arquivos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425547/">https://habr.com/ru/post/pt425547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425531/index.html">Arrefecimento por l√≠quido de trav√µes. Op√ß√µes de desenvolvimento do sistema</a></li>
<li><a href="../pt425533/index.html">Como trabalhar na nuvem: da verifica√ß√£o da confiabilidade de um data center ao gerenciamento de uma infraestrutura virtual</a></li>
<li><a href="../pt425537/index.html">Como combinar Java, Js e gr√°ficos com arte, ou a hist√≥ria de como um teatro interativo foi criado</a></li>
<li><a href="../pt425541/index.html">Como rapidamente e sem chips desnecess√°rios contornar a imutabilidade do endere√ßo do sensor HTU21</a></li>
<li><a href="../pt425545/index.html">Voc√™ deve pensar em horas de pr√°tica.</a></li>
<li><a href="../pt425549/index.html">Estoques da Supermicro quebram em meio a investiga√ß√£o sobre implanta√ß√£o de chip espi√£o chin√™s</a></li>
<li><a href="../pt425551/index.html">Quem deve receber dinheiro com a venda de uma obra de arte criada pela AI?</a></li>
<li><a href="../pt425553/index.html">O que o conde de Monte Cristo pode nos dizer sobre seguran√ßa cibern√©tica</a></li>
<li><a href="../pt425555/index.html">Charles Nutter sobre idiomas din√¢micos na JVM em jug.msk.ru</a></li>
<li><a href="../pt425557/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 10: Execu√ß√£o Simb√≥lica, Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>