<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äç‚öñÔ∏è üïë üåá Penser avec des portails: cr√©er des portails dans Unreal Engine 4 ü§üüèº ‚òÇÔ∏è üôéüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je vais vous expliquer comment cr√©er des portails dans Unreal Engine 4. Je n'ai trouv√© aucune source d√©crivant un tel syst√®me en d√©t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penser avec des portails: cr√©er des portails dans Unreal Engine 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448802/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif" alt="image"></div><br>  Dans cet article, je vais vous expliquer comment cr√©er des portails dans Unreal Engine 4. Je n'ai trouv√© aucune source d√©crivant un tel syst√®me en d√©tail (surveillance via des portails et passage √† travers eux), j'ai donc d√©cid√© d'√©crire le mien. <br><br><h2>  Qu'est-ce qu'un portail? </h2><br>  Commen√ßons par des exemples et des explications sur ce qu'est un portail.  La fa√ßon la plus simple de d√©crire les portails comme un moyen de passage d'un espace √† un autre.  Dans certains jeux populaires, ce concept est utilis√© pour les effets visuels et m√™me pour les m√©caniques de jeu: <br><br><div class="spoiler">  <b class="spoiler_title">Exemples de portail de jeu (GIF)</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/020/f86/611020f86b634e1946a79f86ee8c4024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/7b9/813/77d7b9813811fc5b1748d8d29c7599ad.gif"></div><br>  <i>Antichamber (2013) et Portal (2007)</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/671/ad1/527671ad1b23838f56c324d350bf2e1e.gif"></div><br>  <i>Proie, 2006</i> </div></div><br>  Des trois jeux, le plus c√©l√®bre est probablement Portal, mais personnellement j'ai toujours admir√© Prey et c'est elle que je voulais copier.  Une fois, j'ai essay√© d'impl√©menter ma propre version dans Unreal Engine 4, mais je n'ai pas vraiment r√©ussi, car le moteur manquait de fonctionnalit√©s.  N√©anmoins, j'ai r√©ussi √† mener ces exp√©riences: <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Votre navigateur ne prend pas en charge la vid√©o HTML5. <source src="http://froyok.fr/vine_archive/videos/1318354931002269696.mp4" type="video/mp4"></video></div></div></div><br>  Cependant, ce n'est que dans les nouvelles versions d'Unreal Engine que j'ai finalement r√©ussi √† obtenir l'effet souhait√©: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5lga4ppJiuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Portails - comment fonctionnent-ils? </h2><br>  Avant de poursuivre avec les d√©tails, regardons l'image g√©n√©rale du fonctionnement des portails. <br><br>  En fait, un portail est une fen√™tre qui ne va pas √† l'ext√©rieur, mais vers un autre endroit, c'est-√†-dire que nous d√©finissons localement un point de vue sp√©cifique par rapport √† l'objet et reproduisons ce point de vue ailleurs.  En utilisant ce principe, nous pouvons relier deux espaces, m√™me s'ils sont tr√®s √©loign√©s l'un de l'autre.  La fen√™tre ressemble √† un masque qui nous permet de savoir o√π et quand afficher un autre espace au lieu de l'original.  Puisque le point de d√©part de la vue est reproduit ailleurs, cela nous donne l'illusion de la continuit√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/d56/84b/6b3d5684bf30d66c8b60d551049f7a9b.png"></div><br>  Dans cette image, le p√©riph√©rique de capture (SceneCapture dans UE4) est situ√© devant l'espace qui correspond √† l'espace vu du point de vue du joueur.  Tout ce qui est visible apr√®s la ligne est remplac√© par ce que la capture peut voir.  √âtant donn√© que le dispositif de capture peut √™tre situ√© entre la porte et d'autres objets, il est important d'utiliser le soi-disant ¬´plan de d√©tourage¬ª.  Dans le cas du portail, nous voulons que le plan de d√©tourage proche masque les objets visibles devant le portail. <br><br>  Pour r√©sumer.  Nous avons besoin de: <br><br><ul><li>  Emplacement du joueur </li><li>  Point d'entr√©e du portail </li><li>  Point de sortie du portail </li><li>  Dispositif de d√©tourage avec plan de d√©tourage </li></ul><br>  Comment impl√©menter cela dans Unreal Engine? <br><br>  J'ai construit mon syst√®me sur la base de deux classes principales g√©r√©es par <b>PlayerController</b> et <b>Character</b> .  La classe <b>Portal</b> est un v√©ritable point d'entr√©e de portail, dont le point de vue / sortie est l'acteur cible.  Il existe √©galement un <b>gestionnaire de portail</b> , qui est g√©n√©r√© par le PlayerController et mis √† jour par le personnage pour g√©rer chaque portail au niveau et les mettre √† jour, ainsi que pour manipuler l'objet SceneCapture (qui est commun √† tous les portails). <br><br><blockquote>  Gardez √† l'esprit que le didacticiel s'attend √† ce que vous ayez acc√®s aux classes Character et PlayerController √† partir du code.  Dans mon cas, ils s'appellent ExedreCharacter et ExedrePlayerController. </blockquote><br><h2>  Cr√©ation d'une classe d'acteur de portail </h2><br>  Commen√ßons par l'acteur du portail, qui sera utilis√© pour d√©finir les ¬´fen√™tres¬ª √† travers lesquelles nous regarderons le niveau.  La t√¢che de l'acteur est de fournir des informations sur le joueur pour calculer diff√©rentes positions et virages.  Il sera √©galement engag√© √† reconna√Ætre si le joueur traverse le portail et sa t√©l√©portation. <br><br>  Avant de commencer une discussion d√©taill√©e sur l'acteur, permettez-moi d'expliquer quelques concepts que j'ai cr√©√©s pour g√©rer le syst√®me de portail: <br><br><ul><li>  Pour un refus commode des calculs, le portail a un statut actif-inactif.  Cet √©tat est mis √† jour par Portal Manager. </li><li>  Le portail a des c√¥t√©s avant et arri√®re d√©termin√©s par sa position et sa direction (vecteur avant). </li><li>  Pour savoir si le joueur traverse le portail, il enregistre la position pr√©c√©dente du joueur et la compare avec la position actuelle.  Si dans la mesure pr√©c√©dente le joueur √©tait devant le portail, et dans le courant - derri√®re lui, alors nous pensons que le joueur l'a travers√©.  Le comportement inverse est ignor√©. </li><li>  Le portail a un volume limit√©, afin de ne pas effectuer de calculs et de v√©rifications tant que le joueur n'est pas dans ce volume.  Exemple: Ignorez l'intersection si le joueur ne touche pas r√©ellement le portail. </li><li>  La position du joueur est calcul√©e √† partir de la position de la cam√©ra pour garantir un comportement correct lorsque le point de vue traverse le portail mais pas le corps du joueur. </li><li>  Le portail re√ßoit une cible de rendu, qui affiche un point de vue diff√©rent dans chaque mesure au cas o√π la texture la prochaine fois est incorrecte et doit √™tre remplac√©e. </li><li>  Le portail stocke un lien vers un autre acteur appel√© Target, afin de savoir o√π l'autre espace doit √™tre contact√©. </li></ul><br>  En utilisant ces r√®gles, j'ai cr√©√© une nouvelle classe ExedrePortal h√©rit√©e d'AActor comme point de d√©part.  Voici son titre: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortal.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API AExedrePortal : public AActor { GENERATED_UCLASS_BODY() protected: virtual void BeginPlay() override; public: virtual void Tick(float DeltaTime) override; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Status of the Portal (being visualized by the player or not) UFUNCTION(BlueprintPure, Category="Exedre|Portal") bool IsActive(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetActive( bool NewActive ); //Render target to use to display the portal UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void ClearRTT(); UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void SetRTT( UTexture* RenderTexture ); UFUNCTION(BlueprintNativeEvent, Category="Exedre|Portal") void ForceTick(); //Target of where the portal is looking UFUNCTION(BlueprintPure, Category="Exedre|Portal") AActor* GetTarget(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetTarget( AActor* NewTarget ); //Helpers UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void TeleportActor( AActor* ActorToTeleport ); protected: UPROPERTY(BlueprintReadOnly) USceneComponent* PortalRootComponent; private: bool bIsActive; AActor* Target; //Used for Tracking movement of a point FVector LastPosition; bool LastInFront; };</span></span></span></span></code> </pre> <br>  Comme vous pouvez le voir, il existe la plupart des comportements d√©crits ici.  Voyons maintenant comment ils sont trait√©s dans le corps (.cpp). <br><br><hr><br>  Le concepteur pr√©pare ici les composants racine.  J'ai d√©cid√© de cr√©er deux composants racine, car l'acteur du portail combinera √† la fois les effets graphiques et les collisions / reconnaissance.  J'avais donc besoin d'un moyen simple pour d√©terminer o√π se trouve le plan de la fen√™tre / du portail, sans avoir besoin de fonctionnalit√©s Bluetooth ou d'autres astuces.  PortalRootComponent sera la base de tous les calculs li√©s au portail. <br><br>  La racine du portail est d√©finie sur dynamique, au cas o√π la classe Blueprint l'animerait (par exemple, utiliser une animation d'ouverture / fermeture). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Sets default values AExedrePortal::AExedrePortal(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = true; bIsActive = false; RootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("RootComponent")); RootComponent-&gt;Mobility = EComponentMobility::Static; PortalRootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("PortalRootComponent")); PortalRootComponent-&gt;SetupAttachment( GetRootComponent() ); PortalRootComponent-&gt;SetRelativeLocation( FVector(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;SetRelativeRotation( FRotator(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;Mobility = EComponentMobility::Movable; }</span></span></code> </pre> <br><hr><br>  Il n'y a que les fonctions Get et Set, et rien de plus.  Nous g√©rerons l'√©tat d'activit√© √† partir d'un autre endroit. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsActive() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bIsActive; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetActive( <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> NewActive ) { bIsActive = NewActive; }</code> </pre> <br><hr><br>  √âv√©nements Blueprint, je ne fais rien dans la classe C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ClearRTT_Implementation() { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetRTT_Implementation( UTexture* RenderTexture ) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ForceTick_Implementation() { }</code> </pre> <br><hr><br>  Les fonctions Get et Set pour l'acteur cible.  Il n'y a rien de plus compliqu√© dans cette partie non plus. <br><br><pre> <code class="cpp hljs">AActor* AExedrePortal::GetTarget() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Target; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetTarget( AActor* NewTarget ) { Target = NewTarget; }</code> </pre> <br><hr><br>  Avec cette fonction, nous pouvons facilement v√©rifier si un point est devant un avion, et dans notre cas c'est un portail.  La fonction utilise la structure FPlane du moteur UE4 pour effectuer des calculs. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-comment"><span class="hljs-comment">//If &lt; 0 means we are behind the Plane //See : http://api.unrealengine.com/INT/API/Runtime/Core/Math/FPlane/PlaneDot/index.html return ( PortalDot &gt;= 0 ); }</span></span></code> </pre> <br><hr><br>  Cette fonction v√©rifie si le point a travers√© le plan portail.  C'est ici que nous utilisons l'ancienne position pour d√©couvrir comment se comporte le point.  Cette fonction est courante pour pouvoir fonctionner avec n'importe quel acteur, mais dans mon cas, elle n'est utilis√©e qu'avec le lecteur. <br><br>  La fonction cr√©e une direction / segment entre l'emplacement pr√©c√©dent et l'emplacement actuel, puis v√©rifie s'ils coupent le plan.  Si c'est le cas, nous v√©rifions s'il croise dans la bonne direction (d'avant en arri√®re?). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FVector IntersectionPoint; FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCrossing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsInFront = PortalDot &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsIntersect = FMath::SegmentPlaneIntersection( LastPosition, Point, PortalPlane, IntersectionPoint ); <span class="hljs-comment"><span class="hljs-comment">//Did we intersect the portal since last Location ? //If yes, check the direction : crossing forward means we were in front and now at the back //If we crossed backward, ignore it (similar to Prey 2006) if( IsIntersect &amp;&amp; !IsInFront &amp;&amp; LastInFront ) { IsCrossing = true; } //Store values for Next check LastInFront = IsInFront; LastPosition = Point; return IsCrossing; }</span></span></code> </pre> <br><h2>  Acteur de t√©l√©portation </h2><br>  La derni√®re partie de l'acteur du portail que nous examinerons est la fonction <b>TeleportActor ()</b> . <br><br>  Lorsque vous t√©l√©portez un acteur du point A au point B, vous devez reproduire son mouvement et sa position.  Par exemple, si un joueur passe dans le portail, alors en combinaison avec des effets visuels appropri√©s, il lui semblera qu'il est pass√© par une porte ordinaire. <br><br>  L'intersection du portail donne l'impression de se d√©placer en ligne droite, mais en r√©alit√©, quelque chose de compl√®tement diff√©rent se produit.  En quittant le portail, le joueur peut se trouver dans un contexte tr√®s diff√©rent.  Prenons un exemple de Portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/185/809/d4f/185809d4fd81675cdd6f1cc871eaf193.gif"></div><br>  Comme vous pouvez le voir, lors de la travers√©e du portail, la cam√©ra pivote par rapport √† son vecteur avant (tourne).  En effet, les points de d√©part et d'arriv√©e sont parall√®les √† diff√©rents plans: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/072/97f/b30/07297fb30171a80c1cc0d831701feb74.jpg"></div><br>  Par cons√©quent, pour que cela fonctionne, nous devons transformer le mouvement du joueur dans l'espace relatif du portail afin de le convertir en espace cible.  En impl√©mentant cela, nous pouvons √™tre s√ªrs qu'apr√®s √™tre entr√© dans le portail et sortir de l'autre c√¥t√©, le joueur sera correctement align√© par rapport √† l'espace.  Cela vaut non seulement pour la position et la rotation de l'acteur, mais aussi pour sa <b>vitesse</b> . <br><br><blockquote>  Si nous t√©l√©portons un acteur sans changement, le convertissant en une rotation locale, alors en cons√©quence, l'acteur peut se retrouver √† l'envers.  Cela peut convenir aux objets, mais ne s'applique pas aux personnages ou au joueur lui-m√™me.  Vous devez modifier la position de l'acteur, comme indiqu√© ci-dessus dans l'exemple de Portal. </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::TeleportActor( AActor* ActorToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ActorToTeleport == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//------------------------------- //Retrieve and save Player Velocity //(from the Movement Component) //------------------------------- FVector SavedVelocity = FVector::ZeroVector; AExedreCharacter* EC = nullptr; if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { EC = Cast&lt;AExedreCharacter&gt;( ActorToTeleport ); SavedVelocity = EC-&gt;GetCharMovementComponent()-&gt;GetCurrentVelocity(); } //------------------------------- //Compute and apply new location //------------------------------- FHitResult HitResult; FVector NewLocation = UTool::ConvertLocationToActorSpace( ActorToTeleport-&gt;GetActorLocation(), this, Target ); ActorToTeleport-&gt;SetActorLocation( NewLocation, false, &amp;HitResult, ETeleportType::TeleportPhysics ); //------------------------------- //Compute and apply new rotation //------------------------------- FRotator NewRotation = UTool::ConvertRotationToActorSpace( ActorToTeleport-&gt;GetActorRotation(), this, Target ); //Apply new rotation ActorToTeleport-&gt;SetActorRotation( NewRotation ); //------------------------------- //If we are teleporting a character we need to //update its controller as well and reapply its velocity //------------------------------- if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { //Update Controller AExedrePlayerController* EPC = EC-&gt;GetPlayerController(); if( EPC != nullptr ) { NewRotation = UTool::ConvertRotationToActorSpace( EPC-&gt;GetControlRotation(), this, Target ); EPC-&gt;SetControlRotation( NewRotation ); } //Reapply Velocity (Need to reorient direction into local space of Portal) { FVector Dots; Dots.X = FVector::DotProduct( SavedVelocity, GetActorForwardVector() ); Dots.Y = FVector::DotProduct( SavedVelocity, GetActorRightVector() ); Dots.Z = FVector::DotProduct( SavedVelocity, GetActorUpVector() ); FVector NewVelocity = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); EC-&gt;GetCharMovementComponent()-&gt;Velocity = NewVelocity; } } //Cleanup Teleport LastPosition = NewLocation; }</span></span></code> </pre> <br><hr><br>  Comme vous l'avez probablement remarqu√©, pour appeler rotation / position, j'appelle des fonctions externes.  Ils sont appel√©s √† partir de la classe d'utilisateurs UTool, qui d√©finit les fonctions statiques qui peuvent √™tre appel√©es de n'importe o√π (y compris les plans).  Leur code est illustr√© ci-dessous, vous pouvez les impl√©menter de la mani√®re qui vous semble la meilleure (il est probablement plus facile de simplement les mettre dans la classe d'acteur Portal). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertLocationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Location, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FVector::ZeroVector; } FVector Direction = Location - Reference-&gt;GetActorLocation(); FVector TargetLocation = Target-&gt;GetActorLocation(); FVector Dots; Dots.X = FVector::DotProduct( Direction, Reference-&gt;GetActorForwardVector() ); Dots.Y = FVector::DotProduct( Direction, Reference-&gt;GetActorRightVector() ); Dots.Z = FVector::DotProduct( Direction, Reference-&gt;GetActorUpVector() ); FVector NewDirection = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TargetLocation + NewDirection; }</code> </pre> <br>  La transformation est ici effectu√©e en calculant le produit scalaire des vecteurs pour d√©terminer diff√©rents angles.  Le vecteur Direction n'est pas normalis√©, c'est-√†-dire que nous pouvons √† nouveau multiplier le r√©sultat Dots par des vecteurs cible pour obtenir la position exactement √† la m√™me distance dans l'espace local de l'acteur cible. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FRotator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertRotationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FRotator Rotation, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FRotator::ZeroRotator; } FTransform SourceTransform = Reference-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat QuatRotation = FQuat( Rotation ); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * QuatRotation; FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewWorldQuat.Rotator(); }</code> </pre> <br>  Transformer la transformation √©tait un peu plus difficile √† mettre en ≈ìuvre.  En fin de compte, la meilleure solution s'est av√©r√©e √™tre l'utilisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">quaternions</a> , car cela est beaucoup plus pr√©cis que de travailler avec des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">angles d'Euler</a> normaux et ne n√©cessite que quelques lignes de code.  Les rotations par quaternions sont effectu√©es en utilisant la multiplication, donc dans notre cas, en appliquant Inverse () √† la rotation que nous voulons convertir, nous la d√©placerons vers l'espace local.  Ensuite, il suffit de le multiplier √† nouveau par le tour cible pour obtenir le tour final. <br><br><h2>  Cr√©ation d'un maillage de portail </h2><br>  Pour √™tre belle du point de vue d'un joueur, mon syst√®me de portail utilise un maillage sp√©cifique.  Le maillage est divis√© en deux plans diff√©rents: <br><br><ul><li>  <b>Plan 1</b> : Le plan principal sur lequel la cible de rendu du portail est affich√©e.  Cet avion a un comportement assez inhabituel, car sa t√¢che est de repousser un peu le joueur alors qu'il s'approche pour √©viter l'√©cr√™tage par la cam√©ra.  Comme les fronti√®res de l'avion ne bougent pas, mais seulement ses pics centraux se d√©placent, cela permet au joueur de se superposer au rendu du portail sans artefacts visuels.  Les bords sur les bords ont leur propre UV dans la moiti√© sup√©rieure, tandis que les bords int√©rieurs ont leur propre UV dans la moiti√© inf√©rieure, ce qui facilite leur masquage dans le shader. </li><li>  <b>Plan 2</b> : ce plan est uniquement utilis√© pour √©tendre le cadre de d√©limitation standard du maillage.  Les normales des sommets sont dirig√©es vers le bas, donc m√™me sur un sol non plan, le maillage ne sera pas visible par d√©faut (car le mat√©riau de rendu ne sera pas √† deux faces). </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72e/125/f6f/72e125f6fd315caa2777f65dc0eaf39a.gif"></div><br>  Pourquoi utiliser un maillage comme celui-ci? <br><br>  J'ai d√©cid√© que ¬´l'avion 1¬ª s'√©tirerait √† l'approche du joueur.  Cela permet au joueur de chevaucher le portail et de le traverser sans couper (couper).  Cela peut se produire, par exemple, si la cam√©ra n'a pas encore travers√© le plan du portail, mais que les pieds du joueur l'ont d√©j√† touch√©.  Cela vous permet de ne pas couper le lecteur et de dupliquer le maillage d'autre part. <br><br>  La t√¢che ¬´plan 2¬ª consiste √† √©tendre le cadre de d√©limitation standard du maillage.  √âtant donn√© que le ¬´plan 1¬ª est plat, le cadre de s√©lection sur un axe a une √©paisseur de 0, et si la cam√©ra est derri√®re, le moteur le coupera (c'est-√†-dire qu'il ne le rendra pas).  Le plan 1 a une taille de 128 √ó 128, il peut donc √™tre facilement mis √† l'√©chelle √† l'aide du moteur.  Le plan 2 est l√©g√®rement plus grand et en dessous du sol (en dessous de 0). <br><br>  Apr√®s avoir cr√©√© le maillage, nous l'exportons simplement √† partir d'un √©diteur 3D tiers et l'importons dans Unreal.  Il sera utilis√© √† l'√©tape suivante. <br><br><h2>  Cr√©ation de mat√©riel de portail </h2><br>  Pour afficher l'autre c√¥t√© du portail, nous devons cr√©er notre propre mat√©riel.  Cr√©ez du nouveau mat√©riel dans le navigateur de contenu (je l'ai appel√© <b>MAT_PortalBase</b> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b0/402/a9c/7b0402a9cd6c6d62438e06fa3a7cd1f4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/96c/a1b/dea96ca1b613a92acc7ca35e0bbe44b1.png"></div><br>  Ouvrez-le maintenant et cr√©ez le graphique suivant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfe/4fa/c17/cfe4fac175e5e399c9e615a6afd0b800.jpg"></div><br>  Voici comment fonctionne le mat√©riau: <br><br><ul><li>  <b>FadeColor</b> est la couleur qui sera visible √† travers le portail lorsqu'il est tr√®s √©loign√©.  Il est n√©cessaire car nous ne rendons pas toujours tous les portails, nous masquons donc le rendu lorsque le lecteur / la cam√©ra est loin. </li><li>  Pour savoir √† quelle distance le joueur est du portail, je d√©termine la <b>distance</b> entre la position de la cam√©ra et la position de l'acteur.  Ensuite, je divise la distance par la valeur maximale avec laquelle je veux effectuer une comparaison.  Par exemple, si le maximum que je fixe est de 2000 et que la distance au joueur est de 1000, alors nous obtenons 0,5.  Si le joueur est plus loin, alors j'obtiendrai une valeur sup√©rieure √† 1, donc j'utilise des n≈ìuds satur√©s pour le limiter.  Vient ensuite le n≈ìud Smoothstep, utilis√© pour mettre √† l'√©chelle la distance en tant que gradient et contr√¥ler plus pr√©cis√©ment l'ombrage du portail.  Par exemple, je veux que lorsque le joueur est proche, l'ombre dispara√Æt compl√®tement. </li><li>  J'utilise le calcul de la distance comme valeur de canal alpha pour le n≈ìud <b>Lerp</b> pour m√©langer la couleur d'ombrage et la <b>texture</b> qui rendra la cible du portail. </li><li>  Enfin, j'isole la composante Y des coordonn√©es UV pour cr√©er un masque qui vous permet de savoir quels sommets du maillage seront pouss√©s.  Je multiplie ce masque par la quantit√© de r√©pulsion dont j'ai besoin.  J'utilise une valeur n√©gative pour que lorsque les normales des sommets sont multipli√©es par les sommets, elles se d√©placent dans la direction oppos√©e. </li></ul><br>  Apr√®s avoir fait tout cela, nous avons cr√©√© du mat√©riel pr√™t √† l'emploi. <br><br><h2>  Cr√©ation d'un acteur de portail dans Blueprint </h2><br>  Configurons une nouvelle classe de plan h√©rit√©e de l'acteur Portal.  Cliquez avec le bouton droit sur le navigateur de contenu et s√©lectionnez la classe Blueprint: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/28b/5a2/ead28b5a23369c2c86a076ec8bb1dda0.png"></div><br>  Entrez maintenant ¬´portail¬ª dans le champ de recherche pour s√©lectionner la classe de portail: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/da4/555/bd7da4555cff2dc953ab3b0b0f4d1057.png"></div><br>  Ouvrez Bluetooth s'il n'est pas d√©j√† ouvert.  Dans la liste des composants, vous verrez la hi√©rarchie suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/34c/308/73c34c308a70f644759dc9057b0facd2.png"></div><br>  Comme nous nous y attendions, il existe un composant racine et une racine de portail.  Ajoutons un composant de maillage statique √† PortalRootComponent et chargeons-y le maillage cr√©√© √† l'√©tape pr√©c√©dente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/ef3/11d/fa4ef311d11c803afc565060a9902c24.jpg"></div><br><hr><br>  Nous ajoutons √©galement la Collision Box, qui sera utilis√©e pour d√©terminer si le joueur est √† l'int√©rieur du volume du portail: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b0/28f/df6/0b028fdf696598f6b3eca9af3049caa1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2a/85d/747/c2a85d747c8b76900cae32e9f9cc1a59.png"></div><br>  La zone Collision est situ√©e sous le composant de sc√®ne associ√© √† la racine principale et non sous la racine du portail.  J'ai √©galement ajout√© une ic√¥ne (panneau d'affichage) et un composant fl√®che pour rendre le portail plus visible aux niveaux.  Bien s√ªr, ce n'est pas n√©cessaire. <br><br>  Maintenant, configurons le mat√©riau dans le plan. <br><br>  Pour commencer, nous avons besoin de deux variables - l'une sera de type <b>Actor</b> et le nom est <b>PortalTarget</b> , la seconde est de type <b>Dynamic Material Instance</b> et s'appelle <b>MaterialInstance</b> .  PortalTarget sera une r√©f√©rence √† la position que la fen√™tre du portail regarde (par cons√©quent, la variable est commune, avec une ic√¥ne en forme d'≈ìil ouvert) afin que nous puissions la changer lorsque l'acteur est plac√© au niveau.  MaterialInstance stockera un lien vers du mat√©riel dynamique afin qu'√† l'avenir nous puissions assigner la cible de rendu du portail √† la vol√©e. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/0b9/772/4740b9772dfc7ce30cda63300f1682a5.png"></div><br>  Nous devons √©galement ajouter nos propres n≈ìuds d'√©v√©nements.  Il est pr√©f√©rable d'ouvrir le menu contextuel dans le <b>graphique des √©v√©nements</b> et de trouver les noms des √©v√©nements: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/719/d22/bc2719d224381581c9bdb8ea5ce7c365.png"></div><br>  Et ici pour cr√©er le diagramme suivant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f4/400/24f/0f440024f5c322c6640609bb8d20bcad.jpg"></div><br><ul><li>  <b>Commencer la lecture</b> : ici, nous appelons la fonction parent SetTarget () du portail pour lui attribuer un lien vers l'acteur, qui sera ensuite utilis√© pour SceneCapture.  Nous cr√©ons ensuite un nouveau mat√©riau dynamique et lui attribuons la valeur de la variable MaterialInstance.  Avec ce nouveau mat√©riau, nous pouvons l'assigner au composant de maillage statique.  J'ai √©galement donn√© au mat√©riau une texture factice, mais cela est facultatif. </li><li>  <b>Clear RTT</b> : Le but de cette fonction est d'effacer la texture Render Target affect√©e au mat√©riau du portail.  Il est lanc√© par le gestionnaire de portail. </li><li>  <b>D√©finir RTT</b> : le but de cette fonction est de d√©finir le mat√©riau cible de rendu du portail.  Il est lanc√© par le gestionnaire de portail. </li></ul><br>  Jusqu'√† pr√©sent, nous avons termin√© avec le bluetooth, mais nous y reviendrons plus tard pour impl√©menter les fonctions Tick. <br><br><h2>  Gestionnaire de portail </h2><br>  Donc, nous avons maintenant tous les √©l√©ments de base n√©cessaires pour cr√©er une nouvelle classe h√©rit√©e d'AActor, qui sera Portal Manager.  Vous n'avez peut-√™tre pas besoin de la classe Portal Manager dans votre projet, mais dans mon cas, cela simplifie consid√©rablement le travail avec certains aspects.  Voici une liste des t√¢ches effectu√©es par le gestionnaire de portail: <br><br><ul><li>  Le gestionnaire de portail est un acteur <b>cr√©√© par le contr√¥leur de joueur</b> et attach√© √† lui pour suivre l'√©tat et l'√©volution du joueur dans le niveau de jeu. </li><li>  Cr√©ez et d√©truisez <b>le portail cible de rendu</b> .  L'id√©e est de cr√©er dynamiquement une texture cible de rendu qui correspond √† la r√©solution d'√©cran du lecteur.  De plus, lors du changement de r√©solution pendant le jeu, le manager la convertira automatiquement √† la taille souhait√©e. </li><li>  Le gestionnaire de portail <b>recherche et met √† jour</b> le niveau d'acteur de portail pour leur donner une cible de rendu.  Cette t√¢che est effectu√©e de mani√®re √† assurer la compatibilit√© avec le streaming de niveau.  Lorsqu'un nouvel acteur appara√Æt, il devrait obtenir une texture.  De plus, si la cible de rendu change, le gestionnaire peut √©galement en attribuer une nouvelle automatiquement.  Cela facilite la gestion du syst√®me, au lieu que chaque acteur du portail contacte manuellement le gestionnaire. </li><li>  Le composant <b>SceneCapture est</b> attach√© au gestionnaire de portail, afin de ne pas cr√©er une copie pour chaque portail.  De plus, il vous permet de le r√©utiliser chaque fois que nous passons √† un acteur de portail sp√©cifique au niveau. </li><li>  Lorsque le portail d√©cide de <b>t√©l√©porter le</b> joueur, il envoie une demande au gestionnaire de portail.  Cela est n√©cessaire pour mettre √† jour les portails source et de destination (le cas √©ch√©ant), afin que la transition se fasse sans joints. </li><li>  <b>Le</b> gestionnaire de portail est <b>mis</b> √† <b>jour</b> √† la fin de la fonction <b>tick ()</b> du <b>personnage</b> afin que tout soit correctement mis √† jour, y compris la cam√©ra du joueur.  Cela garantit que tout sur l'√©cran est synchronis√© et √©vite un retard d'une image lors du rendu par le moteur. </li></ul><br>  Jetons un coup d'≈ìil √† l'en-t√™te de Portal Manager: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortalManager.generated.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Forward declaration class AExedrePlayerController; class AExedrePortal; class UExedreScriptedTexture; UCLASS() class EXEDRE_API AExedrePortalManager : public AActor { GENERATED_UCLASS_BODY() public: AExedrePortalManager(); //Called by a Portal actor when wanting to teleport something UFUNCTION(BlueprintCallable, Category="Portal") void RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ); //Save a reference to the PlayerControler void SetControllerOwner( AExedrePlayerController* NewOwner ); //Various setup that happens during spawn void Init(); //Manual Tick void Update( float DeltaTime ); //Find all the portals in world and update them //returns the most valid/usable one for the Player AExedrePortal* UpdatePortalsInWorld(); //Update SceneCapture void UpdateCapture( AExedrePortal* Portal ); //Accessor for Debug purpose UTexture* GetPortalTexture(); //Accessor for Debug purpose FTransform GetCameraTransform(); private: //Function to create the Portal render target void GeneratePortalTexture(); UPROPERTY() USceneCaptureComponent2D* SceneCapture; //Custom class, can be replaced by a "UCanvasRenderTarget2D" instead //See : https://api.unrealengine.com/INT/API/Runtime/Engine/Engine/UCanvasRenderTarget2D/index.html UPROPERTY() UExedreScriptedTexture* PortalTexture; UPROPERTY() AExedrePlayerController* ControllerOwner; int32 PreviousScreenSizeX; int32 PreviousScreenSizeY; float UpdateDelay; };</span></span></span></span></code> </pre> <br><hr><br>  Avant d'entrer dans les d√©tails, je vais montrer comment un acteur est cr√©√© √† partir de la classe Player Controller, appel√©e √† partir de la fonction BeginPlay (): <br><br><pre> <code class="cpp hljs"> FActorSpawnParameters SpawnParams; PortalManager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PortalManager = GetWorld()-&gt;SpawnActor&lt;AExedrePortalManager&gt;( AExedrePortalManager::StaticClass(), FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams); PortalManager-&gt;AttachToActor( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, FAttachmentTransformRules::SnapToTargetIncludingScale); PortalManager-&gt;SetControllerOwner( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); PortalManager-&gt;Init();</code> </pre> <br>  Ainsi, nous cr√©ons un acteur, l'attachons au contr√¥leur du joueur (ceci), puis enregistrons le lien et appelons la fonction Init (). <br><br>  Il est √©galement important de noter que nous mettons √† jour l'acteur manuellement √† partir de la classe Character: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedreCharacter::TickActor( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime, <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELevelTick TickType, FActorTickFunction&amp; ThisTickFunction ) { Super::TickActor( DeltaTime, TickType, ThisTickFunction ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) ); EPC-&gt;PortalManager-&gt;Update( DeltaTime ); } }</code> </pre> <br>  Et voici le constructeur de Portal Manager.  Notez que Tick est d√©sactiv√©, car nous mettrons √† jour manuellement Portal Manager via le lecteur. <br><br><pre> <code class="cpp hljs">AExedrePortalManager::AExedrePortalManager(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; PortalTexture = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; UpdateDelay = <span class="hljs-number"><span class="hljs-number">1.1f</span></span>; PreviousScreenSizeX = <span class="hljs-number"><span class="hljs-number">0</span></span>; PreviousScreenSizeY = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><hr><br>  Voici les fonctions de get / set Portal Manager (apr√®s quoi nous passerons √† des choses plus int√©ressantes): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::SetControllerOwner( AExedrePlayerController* NewOwner ) { ControllerOwner = NewOwner; } FTransform AExedrePortalManager::GetCameraTransform() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( SceneCapture != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SceneCapture-&gt;GetComponentTransform(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FTransform(); } } UTexture* AExedrePortalManager::GetPortalTexture() { <span class="hljs-comment"><span class="hljs-comment">//Portal Texture is a custom component class that embed a UCanvasRenderTraget2D //The GetTexture() simply returns the RenderTarget contained in that class. //IsValidLowLevel() is used here as a way to ensure the Texture has not been destroyed or garbage collected. if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { return PortalTexture-&gt;GetTexture(); } else { return nullptr; } }</span></span></code> </pre> <br><hr><br>  De toute √©vidence, la premi√®re chose √† commencer est la fonction <b>Init ()</b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'objectif principal de cette fonction est de cr√©er le composant SceneCapture (c'est-√†-dire le p√©riph√©rique de capture mentionn√© ci-dessus) et de le configurer correctement. </font><font style="vertical-align: inherit;">Cela commence par la cr√©ation d'un nouvel objet et son enregistrement en tant que composante de cet acteur. </font><font style="vertical-align: inherit;">Ensuite, nous passons √† la d√©finition des propri√©t√©s li√©es √† cette capture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propri√©t√©s √† mentionner:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bCaptureEveryFrame = false</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nous ne voulons pas que la capture soit </font><b><font style="vertical-align: inherit;">activ√©e</font></b><font style="vertical-align: inherit;"> lorsque nous n'en avons pas besoin. </font><font style="vertical-align: inherit;">Nous le g√©rerons manuellement.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bEnableClipPlane = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : propri√©t√© assez importante pour rendre correctement la capture du portail.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bUseCustomProjectionMatrix = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cela nous permet de remplacer la projection Capture par la n√¥tre, en fonction du point de vue du joueur.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CaptureSource = ESceneCaptureSource :: SCS_SceneColorSceneDepth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ce mode est un peu cher, mais il est n√©cessaire de restituer une quantit√© d'informations suffisante.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les propri√©t√©s restantes sont principalement li√©es aux param√®tres de post-traitement. </font><font style="vertical-align: inherit;">Ils sont un moyen pratique de contr√¥ler la qualit√© et donc de capturer les performances. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La derni√®re partie appelle la fonction qui cr√©e la cible de rendu, que nous verrons ci-dessous.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Init() { <span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------ //Create Camera //------------------------------------------------ SceneCapture = NewObject&lt;USceneCaptureComponent2D&gt;(this, USceneCaptureComponent2D::StaticClass(), *FString("PortalSceneCapture")); SceneCapture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); SceneCapture-&gt;RegisterComponent(); SceneCapture-&gt;bCaptureEveryFrame = false; SceneCapture-&gt;bCaptureOnMovement = false; SceneCapture-&gt;LODDistanceFactor = 3; //Force bigger LODs for faster computations SceneCapture-&gt;TextureTarget = nullptr; SceneCapture-&gt;bEnableClipPlane = true; SceneCapture-&gt;bUseCustomProjectionMatrix = true; SceneCapture-&gt;CaptureSource = ESceneCaptureSource::SCS_SceneColorSceneDepth; //Setup Post-Process of SceneCapture (optimization : disable Motion Blur, etc) FPostProcessSettings CaptureSettings; CaptureSettings.bOverride_AmbientOcclusionQuality = true; CaptureSettings.bOverride_MotionBlurAmount = true; CaptureSettings.bOverride_SceneFringeIntensity = true; CaptureSettings.bOverride_GrainIntensity = true; CaptureSettings.bOverride_ScreenSpaceReflectionQuality = true; CaptureSettings.AmbientOcclusionQuality = 0.0f; //0=lowest quality..100=maximum quality CaptureSettings.MotionBlurAmount = 0.0f; //0 = disabled CaptureSettings.SceneFringeIntensity = 0.0f; //0 = disabled CaptureSettings.GrainIntensity = 0.0f; //0 = disabled CaptureSettings.ScreenSpaceReflectionQuality = 0.0f; //0 = disabled CaptureSettings.bOverride_ScreenPercentage = true; CaptureSettings.ScreenPercentage = 100.0f; SceneCapture-&gt;PostProcessSettings = CaptureSettings; //------------------------------------------------ //Create RTT Buffer //------------------------------------------------ GeneratePortalTexture(); }</span></span></code> </pre> <br><hr><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeneratePortalTexture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une fonction qui est appel√©e lorsque cela est n√©cessaire lorsque vous devez cr√©er une nouvelle texture cible de rendu pour les portails. </font><font style="vertical-align: inherit;">Cela se produit dans la fonction d'initialisation, mais il peut √©galement √™tre appel√© lors de la mise √† niveau de Portal Manager. </font><font style="vertical-align: inherit;">C'est pourquoi cette fonction dispose d'un contr√¥le interne pour modifier la r√©solution de la fen√™tre. </font><font style="vertical-align: inherit;">Si cela ne s'est pas produit, la mise √† jour n'est pas effectu√©e.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans mon cas, j'ai cr√©√© une classe wrapper pour UCanvasRenderTarget2D. Je l'ai appel√© ExedreScriptedTexture, c'est un composant qui peut √™tre attach√© √† un acteur. J'ai cr√©√© cette classe pour g√©rer facilement les cibles de rendu avec des acteurs qui ont des t√¢ches de rendu. Il effectue l'initialisation appropri√©e de la cible de rendu et est compatible avec mon propre syst√®me d'interface utilisateur. Cependant, dans le contexte des portails, une texture RenderTarget2D r√©guli√®re est plus que suffisante. Par cons√©quent, vous pouvez simplement l'utiliser.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::GeneratePortalTexture() { int32 CurrentSizeX = <span class="hljs-number"><span class="hljs-number">1920</span></span>; int32 CurrentSizeY = <span class="hljs-number"><span class="hljs-number">1080</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;GetViewportSize(CurrentSizeX, CurrentSizeY); } CurrentSizeX = FMath::Clamp( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(CurrentSizeX / <span class="hljs-number"><span class="hljs-number">1.7</span></span>), <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1920</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1920 / 1.5 = 1280 CurrentSizeY = FMath::Clamp( int(CurrentSizeY / 1.7), 128, 1080); if( CurrentSizeX == PreviousScreenSizeX &amp;&amp; CurrentSizeY == PreviousScreenSizeY ) { return; } PreviousScreenSizeX = CurrentSizeX; PreviousScreenSizeY = CurrentSizeY; //Cleanup existing RTT if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { PortalTexture-&gt;DestroyComponent(); GEngine-&gt;ForceGarbageCollection(); } //Create new RTT PortalTexture = nullptr; PortalTexture = NewObject&lt;UExedreScriptedTexture&gt;(this, UExedreScriptedTexture::StaticClass(), *FString("PortalRenderTarget")); PortalTexture-&gt;SizeX = CurrentSizeX; PortalTexture-&gt;SizeY = CurrentSizeY; //Custom properties of the UExedreScriptedTexture class PortalTexture-&gt;Gamma = 1.0f; PortalTexture-&gt;WrapModeX = 1; //Clamp PortalTexture-&gt;WrapModeY = 1; //Clamp PortalTexture-&gt;bDrawWidgets = false; PortalTexture-&gt;bGenerateMipMaps = false; PortalTexture-&gt;SetClearOnUpdate( false ); //Will be cleared by SceneCapture instead PortalTexture-&gt;Format = ERenderTargetFormat::RGBA16; //Needs 16b to get &gt;1 for Emissive PortalTexture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); PortalTexture-&gt;RegisterComponent(); PortalTexture-&gt;SetOwner( this ); PortalTexture-&gt;Init(); PortalTexture-&gt;SetFilterMode( TextureFilter::TF_Bilinear ); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme mentionn√© ci-dessus, j'ai cr√©√© ma propre classe, donc les propri√©t√©s d√©finies ici doivent √™tre adapt√©es √† la cible de rendu habituelle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est important de comprendre o√π la capture sera affich√©e. </font><font style="vertical-align: inherit;">√âtant donn√© que la cible de rendu sera affich√©e dans le jeu, cela signifie que cela se produira avant tout le post-traitement, et nous devons donc rendre la sc√®ne avec suffisamment d'informations (pour stocker des valeurs sup√©rieures √† 1 pour cr√©er Bloom). </font><font style="vertical-align: inherit;">C'est pourquoi j'ai choisi le format RGBA16 (notez qu'il a son propre Enum, vous devrez utiliser ETextureRenderTargetFormat √† la place). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour plus d'informations, consultez les sources suivantes:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UTextureRenderTarget2D</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETextureRenderTargetFormat</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USceneCaptureComponent2D</font></font></a> </li></ul><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, nous consid√©rerons les fonctions de mise √† jour. </font><font style="vertical-align: inherit;">La fonction de base est assez simple et rend plus complexe. </font><font style="vertical-align: inherit;">Il existe un d√©lai avant les appels √† la fonction GeneratePortalTexture () pour √©viter de recr√©er la cible de rendu lors du redimensionnement de la fen√™tre (par exemple, dans l'√©diteur). </font><font style="vertical-align: inherit;">Lors de la publication du jeu, ce d√©lai peut √™tre supprim√©.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Update( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime ) { <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Generate Portal texture ? //----------------------------------- UpdateDelay += DeltaTime; if( UpdateDelay &gt; 1.0f ) { UpdateDelay = 0.0f; GeneratePortalTexture(); } //----------------------------------- //Find portals in the level and update them //----------------------------------- AExedrePortal* Portal = UpdatePortalsInWorld(); if( Portal != nullptr ) { UpdateCapture( Portal ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous appelons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour trouver tous les portails pr√©sents dans le monde actuel (y compris tous les niveaux charg√©s) et les mettre √† jour. </font><font style="vertical-align: inherit;">La fonction d√©termine √©galement lequel est ¬´actif¬ª, c'est-√†-dire </font><font style="vertical-align: inherit;">visible pour le joueur. </font><font style="vertical-align: inherit;">Si nous trouvons un portail actif, nous appelons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui contr√¥le le composant SceneCapture.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici comment fonctionne la mise √† jour mondiale dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ol><li>   <b></b>   (    ) </li><li>   <b>iterator</b> ,         </li><li>     ,   ,    <b>ClearRTT()</b> ,    .    <b> </b> (,   ). </li><li>  ,     <b></b>  ,    ,     ,     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le contr√¥le qui d√©termine l'exactitude du portail est simple: nous donnons la priorit√© au portail le plus proche du joueur, car il sera tr√®s probablement le plus visible de son point de vue. </font><font style="vertical-align: inherit;">Pour supprimer des proches, mais, par exemple, des portails situ√©s derri√®re le joueur, des v√©rifications plus complexes seront n√©cessaires, mais je ne voulais pas me concentrer sur cela dans mon tutoriel, car cela peut devenir assez difficile.</font></font><br><br><pre> <code class="cpp hljs">AExedrePortal* AExedrePortalManager::UpdatePortalsInWorld() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update Portal actors in the world (and active one if nearby) //----------------------------------- AExedrePortal* ActivePortal = nullptr; FVector PlayerLocation = Character-&gt;GetActorLocation(); FVector CameraLocation = Character-&gt;GetCameraComponent()-&gt;GetComponentLocation(); float Distance = 4096.0f; for( TActorIterator&lt;AExedrePortal&gt;ActorItr( GetWorld() ); ActorItr; ++ActorItr ) { AExedrePortal* Portal = *ActorItr; FVector PortalLocation = Portal-&gt;GetActorLocation(); FVector PortalNormal = -1 * Portal-&gt;GetActorForwardVector(); //Reset Portal Portal-&gt;ClearRTT(); Portal-&gt;SetActive( false ); //Find the closest Portal when the player is Standing in front of float NewDistance = FMath::Abs( FVector::Dist( PlayerLocation, PortalLocation ) ); if( NewDistance &lt; Distance ) { Distance = NewDistance; ActivePortal = Portal; } } return ActivePortal; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est temps de consid√©rer la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit d'une fonctionnalit√© de mise √† niveau qui capture l'autre c√¥t√© du portail. </font><font style="vertical-align: inherit;">D'apr√®s les commentaires, tout doit √™tre clair, mais voici une br√®ve description:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous obtenons des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liens</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vers le contr√¥leur de personnage et de joueur.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous v√©rifions </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si tout est correct</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Portal, composant SceneCapture, Player).</font></font></li><li>   <b>Camera</b>    <b>Target</b>  . </li><li> <b></b>    ,     SceneCapture. </li><li>      SceneCapture     Target. </li><li> ,  SceneCapure  ,  ,   <b></b> . </li><li> <b> Render Target</b>  SceneCapture,  . </li><li>  <b> </b>  PlayerController. </li><li> ,    <b>Capture</b>  SceneCapture     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme nous pouvons le voir, lors de la t√©l√©portation d'un joueur, un √©l√©ment cl√© du comportement naturel et sans d√©faut de SceneCapture est la transformation correcte de la position et de la rotation du portail dans l'espace cible local. </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour la d√©finition de ConvertLocationToActorSpace (), voir ¬´T√©l√©portation d'un acteur¬ª. </font></font></blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::UpdateCapture( AExedrePortal* Portal ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update SceneCapture (discard if there is no active portal) //----------------------------------- if(SceneCapture != nullptr &amp;&amp; PortalTexture != nullptr &amp;&amp; Portal != nullptr &amp;&amp; Character != nullptr ) { UCameraComponent* PlayerCamera = Character-&gt;GetCameraComponent(); AActor* Target = Portal-&gt;GetTarget(); //Place the SceneCapture to the Target if( Target != nullptr ) { //------------------------------- //Compute new location in the space of the target actor //(which may not be aligned to world) //------------------------------- FVector NewLocation = UTool::ConvertLocationToActorSpace( PlayerCamera-&gt;GetComponentLocation(), Portal, Target ); SceneCapture-&gt;SetWorldLocation( NewLocation ); //------------------------------- //Compute new Rotation in the space of the //Target location //------------------------------- FTransform CameraTransform = PlayerCamera-&gt;GetComponentTransform(); FTransform SourceTransform = Portal-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * CameraTransform.GetRotation(); FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; //Update SceneCapture rotation SceneCapture-&gt;SetWorldRotation( NewWorldQuat ); //------------------------------- //Clip Plane : to ignore objects between the //SceneCapture and the Target of the portal //------------------------------- SceneCapture-&gt;ClipPlaneNormal = Target-&gt;GetActorForwardVector(); SceneCapture-&gt;ClipPlaneBase = Target-&gt;GetActorLocation() + (SceneCapture-&gt;ClipPlaneNormal * -1.5f); //Offset to avoid visible pixel border } //Switch on the valid Portal Portal-&gt;SetActive( true ); //Assign the Render Target Portal-&gt;SetRTT( PortalTexture-&gt;GetTexture() ); SceneCapture-&gt;TextureTarget = PortalTexture-&gt;GetTexture(); //Get the Projection Matrix SceneCapture-&gt;CustomProjectionMatrix = ControllerOwner-&gt;GetCameraProjectionMatrix(); //Say Cheeeeese ! SceneCapture-&gt;CaptureScene(); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCameraProjectionMatrix ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'existe pas par d√©faut dans la classe PlayerController, je l'ai ajout√©e moi-m√™me. </font><font style="vertical-align: inherit;">Il est illustr√© ci-dessous:</font></font><br><br><pre> <code class="cpp hljs">FMatrix AExedrePlayerController::GetCameraProjectionMatrix() { FMatrix ProjectionMatrix; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( GetLocalPlayer() != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { FSceneViewProjectionData PlayerProjectionData; GetLocalPlayer()-&gt;GetProjectionData( GetLocalPlayer()-&gt;ViewportClient-&gt;Viewport, EStereoscopicPass::eSSP_FULL, PlayerProjectionData ); ProjectionMatrix = PlayerProjectionData.ProjectionMatrix; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProjectionMatrix; }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, nous devons impl√©menter l'appel √† la fonction Teleport. </font><font style="vertical-align: inherit;">La raison du traitement partiel de la t√©l√©portation via le gestionnaire de portail est qu'il est n√©cessaire de garantir la mise √† jour des portails n√©cessaires, car seul le gestionnaire dispose d'informations sur tous les portails de la sc√®ne. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous avons deux portails connect√©s, lors du passage de l'un √† l'autre, nous devons mettre √† jour les deux en une seule fois. </font><font style="vertical-align: inherit;">Sinon, le joueur se t√©l√©portera et sera de l'autre c√¥t√© du portail, mais le portail cible ne sera pas actif avant la prochaine image / mesure. </font><font style="vertical-align: inherit;">Cela cr√©era des espaces visuels avec le mat√©riau d√©cal√© du maillage plan que nous avons vu ci-dessus.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { Portal-&gt;TeleportActor( TargetToTeleport ); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Force update //----------------------------------- AExedrePortal* FuturePortal = UpdatePortalsInWorld(); if( FuturePortal != nullptr ) { FuturePortal-&gt;ForceTick(); //Force update before the player render its view since he just teleported UpdateCapture( FuturePortal ); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eh bien, c'est tout, nous avons finalement termin√© avec Portal Manager! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terminer le plan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fois le gestionnaire de portail termin√©, il nous suffit de terminer l'acteur du portail lui-m√™me, apr√®s quoi le syst√®me fonctionnera. </font><font style="vertical-align: inherit;">La seule chose qui manque ici est les fonctionnalit√©s de Tick:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/455/bd3/f0f/455bd3f0f3b7c9f4f3fb36d5d1ae85d0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voici comment cela fonctionne: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous mettons √† jour le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mat√©riel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin qu'il ne reste pas dans un √©tat actif.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le portail </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actuellement </font><b><font style="vertical-align: inherit;">inactif</font></b><font style="vertical-align: inherit;"> , le reste de la mesure est rejet√©.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous obtenons la classe Personnage pour acc√©der √† l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emplacement de la cam√©ra</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re partie v√©rifie si la cam√©ra se trouve dans la zone de collision du portail. </font><font style="vertical-align: inherit;">Si c'est le cas, nous compensons le maillage du portail avec son </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mat√©riau</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deuxi√®me partie consiste √† rev√©rifier l'emplacement √† l'int√©rieur de la zone de collision. </font><font style="vertical-align: inherit;">S'il est ex√©cut√©, nous appelons une fonction qui v√©rifie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si nous traversons le portail</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li>        ,   Portal manager,    <b> Teleport</b> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la capture d'√©cran de mon graphique, vous pouvez remarquer deux points int√©ressants: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Point Inside Box</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get Portal Manager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Je n'ai pas encore expliqu√© ces deux fonctions. Ce sont des fonctions statiques que j'ai d√©finies dans ma propre classe afin que vous puissiez les appeler de n'importe o√π. Il s'agit d'une sorte de classe d'aide. Le code de ces fonctions est indiqu√© ci-dessous, vous pouvez vous-m√™me d√©cider o√π les ins√©rer. Si vous n'en avez pas besoin en dehors du syst√®me de portail, vous pouvez les ins√©rer directement dans la classe d'acteur de portail. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au d√©but, je voulais utiliser le syst√®me de collision pour d√©terminer si l'acteur de portail √† l'int√©rieur de la zone de collision se trouve dans le portail, mais il ne m'a pas sembl√© suffisamment fiable. De plus, il me semble que cette m√©thode est plus rapide √† utiliser et pr√©sente un avantage: elle prend en compte la rotation de l'acteur.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPointInsideBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Point, UBoxComponent* Box )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Box != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//From : //https://stackoverflow.com/questions/52673935/check-if-3d-point-inside-a-box/52674010 FVector Center = Box-&gt;GetComponentLocation(); FVector Half = Box-&gt;GetScaledBoxExtent(); FVector DirectionX = Box-&gt;GetForwardVector(); FVector DirectionY = Box-&gt;GetRightVector(); FVector DirectionZ = Box-&gt;GetUpVector(); FVector Direction = Point - Center; bool IsInside = FMath::Abs( FVector::DotProduct( Direction, DirectionX ) ) &lt;= Half.X &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionY ) ) &lt;= Half.Y &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionZ ) ) &lt;= Half.Z; return IsInside; } else { return false; } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AExedrePortalManager* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPortalManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AActor* Context )</span></span></span><span class="hljs-function"> </span></span>{ AExedrePortalManager* Manager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Retrieve the World from the Context actor if( Context != nullptr &amp;&amp; Context-&gt;GetWorld() != nullptr ) { //Find PlayerController AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( Context-&gt;GetWorld()-&gt;GetFirstPlayerController() ); //Retrieve the Portal Manager if( EPC != nullptr &amp;&amp; EPC-&gt;GetPortalManager() != nullptr ) { Manager = EPC-&gt;GetPortalManager(); } } return Manager; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La derni√®re partie de l'acteur Blueprint est </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ForceTick</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">N'oubliez pas que Force Tick est appel√© lorsqu'un joueur traverse un portail et se trouve √† c√¥t√© d'un autre portail pour lequel Portal Manager force une mise √† jour. </font><font style="vertical-align: inherit;">Comme nous venons de nous t√©l√©porter, il n'est pas n√©cessaire d'utiliser le m√™me code, et vous pouvez utiliser sa version simplifi√©e:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/562/22e/cf356222e9d9c81dc38c57d021e51a90.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le processus d√©marre approximativement en m√™me temps que la fonction Tick, mais nous n'ex√©cutons que la premi√®re partie de la s√©quence, qui met √† jour le mat√©riel. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avons-nous fini? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presque. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous impl√©mentons le syst√®me de portail sous cette forme, nous rencontrerons tr√®s probablement le probl√®me suivant:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/f2f/9f7/4c1f2f9f71e8ce213764d42dad1d20c3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que se passe-t-il ici? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce gif, la fr√©quence d'images du jeu est limit√©e √† 6 FPS pour montrer plus clairement le probl√®me. Dans une image, le cube dispara√Æt car le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syst√®me d'√©cr√™tage d'</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unreal Engine le consid√®re comme invisible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En effet, la d√©couverte est effectu√©e dans la trame actuelle, puis utilis√©e dans la suivante. Cela cr√©e un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retard d'une trame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela peut g√©n√©ralement √™tre r√©solu en d√©veloppant le cadre de s√©lection de l'objet afin qu'il soit enregistr√© avant qu'il ne devienne visible. Cependant, cela ne fonctionnera pas ici, car lorsque nous traversons le portail, nous nous t√©l√©portons d'un endroit √† un autre.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La d√©sactivation du syst√®me d'√©cr√™tage est √©galement impossible, en particulier parce qu'aux niveaux avec de nombreux objets, cela r√©duira les performances. De plus, j'ai essay√© de nombreuses √©quipes du moteur Unreal, mais je n'ai pas obtenu de r√©sultats positifs: dans tous les cas, un retard d'une trame est rest√©. Heureusement, apr√®s une √©tude d√©taill√©e du code source d'Unreal Engine, j'ai r√©ussi √† trouver une solution (le chemin √©tait long - il a fallu plus d'une semaine)! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme avec le composant SceneCapture, vous pouvez dire √† la cam√©ra du lecteur que nous avons effectu√© une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coupure de saut</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- la position de la cam√©ra a saut√© entre deux images, ce qui signifie que nous ne pouvons pas nous fier aux informations de l'image pr√©c√©dente. </font><font style="vertical-align: inherit;">Ce comportement peut √™tre observ√© lors de l'utilisation de Matinee ou Sequencer, par exemple, lors du changement de cam√©ra: le flou de mouvement ou le lissage ne peut pas s'appuyer sur les informations de l'image pr√©c√©dente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ce faire, nous devons consid√©rer deux aspects:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LocalPlayer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cette classe g√®re diverses informations (par exemple, la fen√™tre du joueur) et est associ√©e au PlayerController. </font><font style="vertical-align: inherit;">C‚Äôest l√† que nous pouvons influencer le processus de rendu de la cam√©ra du lecteur.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerController</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : lorsqu'un joueur se t√©l√©porte, cette classe commence √† √©pisser gr√¢ce √† l'acc√®s √† LocalPlayer.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le gros avantage de cette solution est que l'intervention dans le processus de rendu du moteur est minimale et facile √† entretenir dans les futures mises √† jour d'Unreal Engine. </font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par cr√©er une nouvelle classe h√©rit√©e de LocalPlayer. </font><font style="vertical-align: inherit;">Vous trouverez ci-dessous un en-t√™te qui identifie deux composants principaux: la red√©finition des calculs de la fen√™tre de sc√®ne et une nouvelle fonction pour invoquer le collage de la cam√©ra.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Engine/LocalPlayer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API UExedreLocalPlayer : public ULocalPlayer { GENERATED_BODY() UExedreLocalPlayer(); public: FSceneView* CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) override; void PerformCameraCut(); private: bool bCameraCut; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voici comment tout est mis en ≈ìuvre: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Exedre.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.h"</span></span></span><span class="hljs-meta"> UExedreLocalPlayer::UExedreLocalPlayer() { bCameraCut = false; } FSceneView* UExedreLocalPlayer::CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ULocalPlayer::CalcSceneView() use a ViewInitOptions to create // a FSceneView which contains a "bCameraCut" variable // See : H:\GitHub\UnrealEngine\Engine\Source\Runtime\Renderer\Private\SceneCaptureRendering.cpp // as well for bCameraCutThisFrame in USceneCaptureComponent2D FSceneView* View = Super::CalcSceneView(ViewFamily, OutViewLocation, OutViewRotation, Viewport, ViewDrawer, StereoPass ); if( bCameraCut ) { View-&gt;bCameraCut = true; bCameraCut = false; } return View; } void UExedreLocalPlayer::PerformCameraCut() { bCameraCut = true; }</span></span></span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PerformCameraCut ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©marre simplement Camera Cut avec une valeur bool√©enne. </font><font style="vertical-align: inherit;">Lorsque le moteur appelle la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous </font><b><font style="vertical-align: inherit;">ex√©cutons d'</font></b><font style="vertical-align: inherit;"> abord la fonction d'origine. </font><font style="vertical-align: inherit;">Ensuite, nous v√©rifions, nous devons effectuer un collage. </font><font style="vertical-align: inherit;">Si c'est le cas, nous red√©finissons la variable bool√©enne Camera Cut √† l'int√©rieur de la structure </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSceneView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui sera utilis√©e par le processus de rendu du moteur, puis r√©initialisons la variable bool√©enne (utilisez-la).</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√¥t√© Player Controller, les changements sont minimes. </font><font style="vertical-align: inherit;">Vous devez ajouter une variable √† l'en-t√™te pour stocker un lien vers la classe native LocalPlayer:</font></font><br><br><pre> <code class="cpp hljs"> UPROPERTY() UExedreLocalPlayer* LocalPlayer;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puis dans la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BeginPlay ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"> LocalPlayer = Cast&lt;UExedreLocalPlayer&gt;( GetLocalPlayer() );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> J'ai √©galement ajout√© une fonction pour lancer rapidement Cut: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePlayerController::PerformCameraCut() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( LocalPlayer != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { LocalPlayer-&gt;PerformCameraCut(); } }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, dans la fonction Portal Manager </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RequestTeleportByPortal (),</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous pouvons ex√©cuter pendant la t√©l√©portation Camera Cut:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;PerformCameraCut(); } [...]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et c'est tout! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camera Cut doit √™tre appel√© avant la mise √† jour de SceneCapture, c'est pourquoi il se trouve au d√©but de la fonction.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©sultat final </font></font></h2><br> <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons appris √† penser dans les portails. </font></font></a></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le syst√®me fonctionne bien, nous devrions pouvoir cr√©er ces choses:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si vous rencontrez des probl√®mes, v√©rifiez les points suivants: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V√©rifiez que Portal Manager est correctement cr√©√© et initialis√©. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La cible de rendu est cr√©√©e correctement (vous pouvez utiliser celle cr√©√©e dans le navigateur de contenu pour commencer). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les portails sont correctement activ√©s et d√©sactiv√©s. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les portails ont l'acteur cible correctement d√©fini dans l'√©diteur. </font></font></li></ul><br><h2>  Q &amp; A </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les questions les plus fr√©quemment pos√©es √† propos de ce tutoriel: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est-il possible de l'impl√©menter sur des contours, et non via C ++? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La majeure partie du code peut √™tre impl√©ment√©e en blunts, √† l'exception de deux aspects:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetProjectionData ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilis√©e pour obtenir la matrice de projection n'est pas disponible dans les plans.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est essentielle pour r√©soudre le probl√®me du syst√®me d'√©cr√™tage, n'est pas disponible dans les plans.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, vous devez soit utiliser une impl√©mentation C ++ pour acc√©der √† ces deux fonctions, soit modifier le code source du moteur pour les rendre accessibles via des plans directeurs. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puis-je utiliser ce syst√®me en VR? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oui, pour la plupart. </font><font style="vertical-align: inherit;">Cependant, certaines parties devront √™tre adapt√©es, par exemple:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez utiliser deux cibles de rendu (une pour chaque ≈ìil) et les masquer dans le mat√©riau du portail pour les afficher c√¥te √† c√¥te dans l'espace d'√©cran. </font><font style="vertical-align: inherit;">Chaque cible de rendu doit avoir la moiti√© de la largeur de la r√©solution de l'appareil VR.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous devez utiliser deux SceneCapture pour rendre la cible avec la bonne distance (la distance entre les yeux) pour cr√©er des effets st√©r√©oscopiques. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le probl√®me principal sera la performance, car l'autre c√¥t√© du portail devra √™tre rendu deux fois. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre objet peut-il traverser le portail?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il n'y en a pas dans mon code. Cependant, le rendre plus g√©n√©ral n'est pas si difficile. Pour ce faire, le portail doit suivre plus d'informations sur tous les objets √† proximit√© afin de v√©rifier s'ils le traversent. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le syst√®me prend-il en charge la r√©cursivit√© (portail √† l'int√©rieur du portail)?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ce tutoriel ne l'est pas. Pour la r√©cursivit√©, vous avez besoin d'une cible de rendu suppl√©mentaire et de SceneCapture. Il sera √©galement n√©cessaire de d√©terminer quel RenderTarget rendre en premier, et ainsi de suite. C'est assez difficile et je ne voulais pas le faire, car pour mon projet ce n'est pas n√©cessaire. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puis-je traverser le portail pr√®s du mur?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement non. </font><font style="vertical-align: inherit;">Cependant, je vois deux fa√ßons de mettre en ≈ìuvre cela (th√©oriquement):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sactivez les collisions du joueur afin qu'il puisse passer √† travers les murs. </font><font style="vertical-align: inherit;">Il est facile √† mettre en ≈ìuvre, mais il entra√Ænera de nombreux effets secondaires.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Piratez un syst√®me de collision pour cr√©er un trou dynamiquement, ce qui permettra au joueur de passer. </font><font style="vertical-align: inherit;">Pour ce faire, vous devez modifier le syst√®me physique du moteur. </font><font style="vertical-align: inherit;">Cependant, d'apr√®s ce que je sais, apr√®s avoir charg√© le niveau, la physique statique ne peut pas √™tre mise √† jour. </font><font style="vertical-align: inherit;">Par cons√©quent, pour prendre en charge cette fonctionnalit√©, il faudra beaucoup de travail. </font><font style="vertical-align: inherit;">Si vos portails sont statiques, vous pouvez probablement contourner ce probl√®me en utilisant le streaming de niveau pour basculer entre les diff√©rentes collisions.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448802/">https://habr.com/ru/post/fr448802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448792/index.html">Test Python avec pytest. Luminaires int√©gr√©s, Chapitre 4</a></li>
<li><a href="../fr448794/index.html">Test Python avec pytest. Plugins CHAPITRE 5</a></li>
<li><a href="../fr448796/index.html">Test Python avec pytest. Configuration, CHAPITRE 6</a></li>
<li><a href="../fr448798/index.html">Test Python avec pytest. Utilisation de pytest avec d'autres outils, CHAPITRE 7</a></li>
<li><a href="../fr448800/index.html">Configurer Visual Studio dans votre organisation avec .vsconfig</a></li>
<li><a href="../fr448804/index.html">Se pr√©parer pour le runtime et le notaire renforc√©s de macOS</a></li>
<li><a href="../fr448806/index.html">Cr√©ation d'un syst√®me d'extension sur la biblioth√®que Qt</a></li>
<li><a href="../fr448808/index.html">√Ä propos de choses simples, compliqu√©es. "Acier dormant." Comment graisser les boulons rouill√©s ou non WD-40 avec un seul ...</a></li>
<li><a href="../fr448810/index.html">Comment ai-je attrap√© un pirate</a></li>
<li><a href="../fr448812/index.html">Mission lunaire "Bereshit" - recherche de la premi√®re biblioth√®que lunaire apr√®s le d√©but de l'accident de son porteur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>