<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍⚖️ 🕑 🌇 Penser avec des portails: créer des portails dans Unreal Engine 4 🤟🏼 ☂️ 🙎🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je vais vous expliquer comment créer des portails dans Unreal Engine 4. Je n'ai trouvé aucune source décrivant un tel système en dét...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penser avec des portails: créer des portails dans Unreal Engine 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448802/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif" alt="image"></div><br>  Dans cet article, je vais vous expliquer comment créer des portails dans Unreal Engine 4. Je n'ai trouvé aucune source décrivant un tel système en détail (surveillance via des portails et passage à travers eux), j'ai donc décidé d'écrire le mien. <br><br><h2>  Qu'est-ce qu'un portail? </h2><br>  Commençons par des exemples et des explications sur ce qu'est un portail.  La façon la plus simple de décrire les portails comme un moyen de passage d'un espace à un autre.  Dans certains jeux populaires, ce concept est utilisé pour les effets visuels et même pour les mécaniques de jeu: <br><br><div class="spoiler">  <b class="spoiler_title">Exemples de portail de jeu (GIF)</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/020/f86/611020f86b634e1946a79f86ee8c4024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/7b9/813/77d7b9813811fc5b1748d8d29c7599ad.gif"></div><br>  <i>Antichamber (2013) et Portal (2007)</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/671/ad1/527671ad1b23838f56c324d350bf2e1e.gif"></div><br>  <i>Proie, 2006</i> </div></div><br>  Des trois jeux, le plus célèbre est probablement Portal, mais personnellement j'ai toujours admiré Prey et c'est elle que je voulais copier.  Une fois, j'ai essayé d'implémenter ma propre version dans Unreal Engine 4, mais je n'ai pas vraiment réussi, car le moteur manquait de fonctionnalités.  Néanmoins, j'ai réussi à mener ces expériences: <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Votre navigateur ne prend pas en charge la vidéo HTML5. <source src="http://froyok.fr/vine_archive/videos/1318354931002269696.mp4" type="video/mp4"></video></div></div></div><br>  Cependant, ce n'est que dans les nouvelles versions d'Unreal Engine que j'ai finalement réussi à obtenir l'effet souhaité: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5lga4ppJiuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Portails - comment fonctionnent-ils? </h2><br>  Avant de poursuivre avec les détails, regardons l'image générale du fonctionnement des portails. <br><br>  En fait, un portail est une fenêtre qui ne va pas à l'extérieur, mais vers un autre endroit, c'est-à-dire que nous définissons localement un point de vue spécifique par rapport à l'objet et reproduisons ce point de vue ailleurs.  En utilisant ce principe, nous pouvons relier deux espaces, même s'ils sont très éloignés l'un de l'autre.  La fenêtre ressemble à un masque qui nous permet de savoir où et quand afficher un autre espace au lieu de l'original.  Puisque le point de départ de la vue est reproduit ailleurs, cela nous donne l'illusion de la continuité. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/d56/84b/6b3d5684bf30d66c8b60d551049f7a9b.png"></div><br>  Dans cette image, le périphérique de capture (SceneCapture dans UE4) est situé devant l'espace qui correspond à l'espace vu du point de vue du joueur.  Tout ce qui est visible après la ligne est remplacé par ce que la capture peut voir.  Étant donné que le dispositif de capture peut être situé entre la porte et d'autres objets, il est important d'utiliser le soi-disant «plan de détourage».  Dans le cas du portail, nous voulons que le plan de détourage proche masque les objets visibles devant le portail. <br><br>  Pour résumer.  Nous avons besoin de: <br><br><ul><li>  Emplacement du joueur </li><li>  Point d'entrée du portail </li><li>  Point de sortie du portail </li><li>  Dispositif de détourage avec plan de détourage </li></ul><br>  Comment implémenter cela dans Unreal Engine? <br><br>  J'ai construit mon système sur la base de deux classes principales gérées par <b>PlayerController</b> et <b>Character</b> .  La classe <b>Portal</b> est un véritable point d'entrée de portail, dont le point de vue / sortie est l'acteur cible.  Il existe également un <b>gestionnaire de portail</b> , qui est généré par le PlayerController et mis à jour par le personnage pour gérer chaque portail au niveau et les mettre à jour, ainsi que pour manipuler l'objet SceneCapture (qui est commun à tous les portails). <br><br><blockquote>  Gardez à l'esprit que le didacticiel s'attend à ce que vous ayez accès aux classes Character et PlayerController à partir du code.  Dans mon cas, ils s'appellent ExedreCharacter et ExedrePlayerController. </blockquote><br><h2>  Création d'une classe d'acteur de portail </h2><br>  Commençons par l'acteur du portail, qui sera utilisé pour définir les «fenêtres» à travers lesquelles nous regarderons le niveau.  La tâche de l'acteur est de fournir des informations sur le joueur pour calculer différentes positions et virages.  Il sera également engagé à reconnaître si le joueur traverse le portail et sa téléportation. <br><br>  Avant de commencer une discussion détaillée sur l'acteur, permettez-moi d'expliquer quelques concepts que j'ai créés pour gérer le système de portail: <br><br><ul><li>  Pour un refus commode des calculs, le portail a un statut actif-inactif.  Cet état est mis à jour par Portal Manager. </li><li>  Le portail a des côtés avant et arrière déterminés par sa position et sa direction (vecteur avant). </li><li>  Pour savoir si le joueur traverse le portail, il enregistre la position précédente du joueur et la compare avec la position actuelle.  Si dans la mesure précédente le joueur était devant le portail, et dans le courant - derrière lui, alors nous pensons que le joueur l'a traversé.  Le comportement inverse est ignoré. </li><li>  Le portail a un volume limité, afin de ne pas effectuer de calculs et de vérifications tant que le joueur n'est pas dans ce volume.  Exemple: Ignorez l'intersection si le joueur ne touche pas réellement le portail. </li><li>  La position du joueur est calculée à partir de la position de la caméra pour garantir un comportement correct lorsque le point de vue traverse le portail mais pas le corps du joueur. </li><li>  Le portail reçoit une cible de rendu, qui affiche un point de vue différent dans chaque mesure au cas où la texture la prochaine fois est incorrecte et doit être remplacée. </li><li>  Le portail stocke un lien vers un autre acteur appelé Target, afin de savoir où l'autre espace doit être contacté. </li></ul><br>  En utilisant ces règles, j'ai créé une nouvelle classe ExedrePortal héritée d'AActor comme point de départ.  Voici son titre: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortal.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API AExedrePortal : public AActor { GENERATED_UCLASS_BODY() protected: virtual void BeginPlay() override; public: virtual void Tick(float DeltaTime) override; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Status of the Portal (being visualized by the player or not) UFUNCTION(BlueprintPure, Category="Exedre|Portal") bool IsActive(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetActive( bool NewActive ); //Render target to use to display the portal UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void ClearRTT(); UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void SetRTT( UTexture* RenderTexture ); UFUNCTION(BlueprintNativeEvent, Category="Exedre|Portal") void ForceTick(); //Target of where the portal is looking UFUNCTION(BlueprintPure, Category="Exedre|Portal") AActor* GetTarget(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetTarget( AActor* NewTarget ); //Helpers UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void TeleportActor( AActor* ActorToTeleport ); protected: UPROPERTY(BlueprintReadOnly) USceneComponent* PortalRootComponent; private: bool bIsActive; AActor* Target; //Used for Tracking movement of a point FVector LastPosition; bool LastInFront; };</span></span></span></span></code> </pre> <br>  Comme vous pouvez le voir, il existe la plupart des comportements décrits ici.  Voyons maintenant comment ils sont traités dans le corps (.cpp). <br><br><hr><br>  Le concepteur prépare ici les composants racine.  J'ai décidé de créer deux composants racine, car l'acteur du portail combinera à la fois les effets graphiques et les collisions / reconnaissance.  J'avais donc besoin d'un moyen simple pour déterminer où se trouve le plan de la fenêtre / du portail, sans avoir besoin de fonctionnalités Bluetooth ou d'autres astuces.  PortalRootComponent sera la base de tous les calculs liés au portail. <br><br>  La racine du portail est définie sur dynamique, au cas où la classe Blueprint l'animerait (par exemple, utiliser une animation d'ouverture / fermeture). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Sets default values AExedrePortal::AExedrePortal(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = true; bIsActive = false; RootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("RootComponent")); RootComponent-&gt;Mobility = EComponentMobility::Static; PortalRootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("PortalRootComponent")); PortalRootComponent-&gt;SetupAttachment( GetRootComponent() ); PortalRootComponent-&gt;SetRelativeLocation( FVector(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;SetRelativeRotation( FRotator(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;Mobility = EComponentMobility::Movable; }</span></span></code> </pre> <br><hr><br>  Il n'y a que les fonctions Get et Set, et rien de plus.  Nous gérerons l'état d'activité à partir d'un autre endroit. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsActive() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bIsActive; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetActive( <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> NewActive ) { bIsActive = NewActive; }</code> </pre> <br><hr><br>  Événements Blueprint, je ne fais rien dans la classe C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ClearRTT_Implementation() { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetRTT_Implementation( UTexture* RenderTexture ) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ForceTick_Implementation() { }</code> </pre> <br><hr><br>  Les fonctions Get et Set pour l'acteur cible.  Il n'y a rien de plus compliqué dans cette partie non plus. <br><br><pre> <code class="cpp hljs">AActor* AExedrePortal::GetTarget() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Target; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetTarget( AActor* NewTarget ) { Target = NewTarget; }</code> </pre> <br><hr><br>  Avec cette fonction, nous pouvons facilement vérifier si un point est devant un avion, et dans notre cas c'est un portail.  La fonction utilise la structure FPlane du moteur UE4 pour effectuer des calculs. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-comment"><span class="hljs-comment">//If &lt; 0 means we are behind the Plane //See : http://api.unrealengine.com/INT/API/Runtime/Core/Math/FPlane/PlaneDot/index.html return ( PortalDot &gt;= 0 ); }</span></span></code> </pre> <br><hr><br>  Cette fonction vérifie si le point a traversé le plan portail.  C'est ici que nous utilisons l'ancienne position pour découvrir comment se comporte le point.  Cette fonction est courante pour pouvoir fonctionner avec n'importe quel acteur, mais dans mon cas, elle n'est utilisée qu'avec le lecteur. <br><br>  La fonction crée une direction / segment entre l'emplacement précédent et l'emplacement actuel, puis vérifie s'ils coupent le plan.  Si c'est le cas, nous vérifions s'il croise dans la bonne direction (d'avant en arrière?). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FVector IntersectionPoint; FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCrossing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsInFront = PortalDot &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsIntersect = FMath::SegmentPlaneIntersection( LastPosition, Point, PortalPlane, IntersectionPoint ); <span class="hljs-comment"><span class="hljs-comment">//Did we intersect the portal since last Location ? //If yes, check the direction : crossing forward means we were in front and now at the back //If we crossed backward, ignore it (similar to Prey 2006) if( IsIntersect &amp;&amp; !IsInFront &amp;&amp; LastInFront ) { IsCrossing = true; } //Store values for Next check LastInFront = IsInFront; LastPosition = Point; return IsCrossing; }</span></span></code> </pre> <br><h2>  Acteur de téléportation </h2><br>  La dernière partie de l'acteur du portail que nous examinerons est la fonction <b>TeleportActor ()</b> . <br><br>  Lorsque vous téléportez un acteur du point A au point B, vous devez reproduire son mouvement et sa position.  Par exemple, si un joueur passe dans le portail, alors en combinaison avec des effets visuels appropriés, il lui semblera qu'il est passé par une porte ordinaire. <br><br>  L'intersection du portail donne l'impression de se déplacer en ligne droite, mais en réalité, quelque chose de complètement différent se produit.  En quittant le portail, le joueur peut se trouver dans un contexte très différent.  Prenons un exemple de Portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/185/809/d4f/185809d4fd81675cdd6f1cc871eaf193.gif"></div><br>  Comme vous pouvez le voir, lors de la traversée du portail, la caméra pivote par rapport à son vecteur avant (tourne).  En effet, les points de départ et d'arrivée sont parallèles à différents plans: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/072/97f/b30/07297fb30171a80c1cc0d831701feb74.jpg"></div><br>  Par conséquent, pour que cela fonctionne, nous devons transformer le mouvement du joueur dans l'espace relatif du portail afin de le convertir en espace cible.  En implémentant cela, nous pouvons être sûrs qu'après être entré dans le portail et sortir de l'autre côté, le joueur sera correctement aligné par rapport à l'espace.  Cela vaut non seulement pour la position et la rotation de l'acteur, mais aussi pour sa <b>vitesse</b> . <br><br><blockquote>  Si nous téléportons un acteur sans changement, le convertissant en une rotation locale, alors en conséquence, l'acteur peut se retrouver à l'envers.  Cela peut convenir aux objets, mais ne s'applique pas aux personnages ou au joueur lui-même.  Vous devez modifier la position de l'acteur, comme indiqué ci-dessus dans l'exemple de Portal. </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::TeleportActor( AActor* ActorToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ActorToTeleport == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//------------------------------- //Retrieve and save Player Velocity //(from the Movement Component) //------------------------------- FVector SavedVelocity = FVector::ZeroVector; AExedreCharacter* EC = nullptr; if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { EC = Cast&lt;AExedreCharacter&gt;( ActorToTeleport ); SavedVelocity = EC-&gt;GetCharMovementComponent()-&gt;GetCurrentVelocity(); } //------------------------------- //Compute and apply new location //------------------------------- FHitResult HitResult; FVector NewLocation = UTool::ConvertLocationToActorSpace( ActorToTeleport-&gt;GetActorLocation(), this, Target ); ActorToTeleport-&gt;SetActorLocation( NewLocation, false, &amp;HitResult, ETeleportType::TeleportPhysics ); //------------------------------- //Compute and apply new rotation //------------------------------- FRotator NewRotation = UTool::ConvertRotationToActorSpace( ActorToTeleport-&gt;GetActorRotation(), this, Target ); //Apply new rotation ActorToTeleport-&gt;SetActorRotation( NewRotation ); //------------------------------- //If we are teleporting a character we need to //update its controller as well and reapply its velocity //------------------------------- if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { //Update Controller AExedrePlayerController* EPC = EC-&gt;GetPlayerController(); if( EPC != nullptr ) { NewRotation = UTool::ConvertRotationToActorSpace( EPC-&gt;GetControlRotation(), this, Target ); EPC-&gt;SetControlRotation( NewRotation ); } //Reapply Velocity (Need to reorient direction into local space of Portal) { FVector Dots; Dots.X = FVector::DotProduct( SavedVelocity, GetActorForwardVector() ); Dots.Y = FVector::DotProduct( SavedVelocity, GetActorRightVector() ); Dots.Z = FVector::DotProduct( SavedVelocity, GetActorUpVector() ); FVector NewVelocity = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); EC-&gt;GetCharMovementComponent()-&gt;Velocity = NewVelocity; } } //Cleanup Teleport LastPosition = NewLocation; }</span></span></code> </pre> <br><hr><br>  Comme vous l'avez probablement remarqué, pour appeler rotation / position, j'appelle des fonctions externes.  Ils sont appelés à partir de la classe d'utilisateurs UTool, qui définit les fonctions statiques qui peuvent être appelées de n'importe où (y compris les plans).  Leur code est illustré ci-dessous, vous pouvez les implémenter de la manière qui vous semble la meilleure (il est probablement plus facile de simplement les mettre dans la classe d'acteur Portal). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertLocationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Location, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FVector::ZeroVector; } FVector Direction = Location - Reference-&gt;GetActorLocation(); FVector TargetLocation = Target-&gt;GetActorLocation(); FVector Dots; Dots.X = FVector::DotProduct( Direction, Reference-&gt;GetActorForwardVector() ); Dots.Y = FVector::DotProduct( Direction, Reference-&gt;GetActorRightVector() ); Dots.Z = FVector::DotProduct( Direction, Reference-&gt;GetActorUpVector() ); FVector NewDirection = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TargetLocation + NewDirection; }</code> </pre> <br>  La transformation est ici effectuée en calculant le produit scalaire des vecteurs pour déterminer différents angles.  Le vecteur Direction n'est pas normalisé, c'est-à-dire que nous pouvons à nouveau multiplier le résultat Dots par des vecteurs cible pour obtenir la position exactement à la même distance dans l'espace local de l'acteur cible. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FRotator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertRotationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FRotator Rotation, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FRotator::ZeroRotator; } FTransform SourceTransform = Reference-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat QuatRotation = FQuat( Rotation ); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * QuatRotation; FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewWorldQuat.Rotator(); }</code> </pre> <br>  Transformer la transformation était un peu plus difficile à mettre en œuvre.  En fin de compte, la meilleure solution s'est avérée être l'utilisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">quaternions</a> , car cela est beaucoup plus précis que de travailler avec des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">angles d'Euler</a> normaux et ne nécessite que quelques lignes de code.  Les rotations par quaternions sont effectuées en utilisant la multiplication, donc dans notre cas, en appliquant Inverse () à la rotation que nous voulons convertir, nous la déplacerons vers l'espace local.  Ensuite, il suffit de le multiplier à nouveau par le tour cible pour obtenir le tour final. <br><br><h2>  Création d'un maillage de portail </h2><br>  Pour être belle du point de vue d'un joueur, mon système de portail utilise un maillage spécifique.  Le maillage est divisé en deux plans différents: <br><br><ul><li>  <b>Plan 1</b> : Le plan principal sur lequel la cible de rendu du portail est affichée.  Cet avion a un comportement assez inhabituel, car sa tâche est de repousser un peu le joueur alors qu'il s'approche pour éviter l'écrêtage par la caméra.  Comme les frontières de l'avion ne bougent pas, mais seulement ses pics centraux se déplacent, cela permet au joueur de se superposer au rendu du portail sans artefacts visuels.  Les bords sur les bords ont leur propre UV dans la moitié supérieure, tandis que les bords intérieurs ont leur propre UV dans la moitié inférieure, ce qui facilite leur masquage dans le shader. </li><li>  <b>Plan 2</b> : ce plan est uniquement utilisé pour étendre le cadre de délimitation standard du maillage.  Les normales des sommets sont dirigées vers le bas, donc même sur un sol non plan, le maillage ne sera pas visible par défaut (car le matériau de rendu ne sera pas à deux faces). </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72e/125/f6f/72e125f6fd315caa2777f65dc0eaf39a.gif"></div><br>  Pourquoi utiliser un maillage comme celui-ci? <br><br>  J'ai décidé que «l'avion 1» s'étirerait à l'approche du joueur.  Cela permet au joueur de chevaucher le portail et de le traverser sans couper (couper).  Cela peut se produire, par exemple, si la caméra n'a pas encore traversé le plan du portail, mais que les pieds du joueur l'ont déjà touché.  Cela vous permet de ne pas couper le lecteur et de dupliquer le maillage d'autre part. <br><br>  La tâche «plan 2» consiste à étendre le cadre de délimitation standard du maillage.  Étant donné que le «plan 1» est plat, le cadre de sélection sur un axe a une épaisseur de 0, et si la caméra est derrière, le moteur le coupera (c'est-à-dire qu'il ne le rendra pas).  Le plan 1 a une taille de 128 × 128, il peut donc être facilement mis à l'échelle à l'aide du moteur.  Le plan 2 est légèrement plus grand et en dessous du sol (en dessous de 0). <br><br>  Après avoir créé le maillage, nous l'exportons simplement à partir d'un éditeur 3D tiers et l'importons dans Unreal.  Il sera utilisé à l'étape suivante. <br><br><h2>  Création de matériel de portail </h2><br>  Pour afficher l'autre côté du portail, nous devons créer notre propre matériel.  Créez du nouveau matériel dans le navigateur de contenu (je l'ai appelé <b>MAT_PortalBase</b> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b0/402/a9c/7b0402a9cd6c6d62438e06fa3a7cd1f4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/96c/a1b/dea96ca1b613a92acc7ca35e0bbe44b1.png"></div><br>  Ouvrez-le maintenant et créez le graphique suivant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfe/4fa/c17/cfe4fac175e5e399c9e615a6afd0b800.jpg"></div><br>  Voici comment fonctionne le matériau: <br><br><ul><li>  <b>FadeColor</b> est la couleur qui sera visible à travers le portail lorsqu'il est très éloigné.  Il est nécessaire car nous ne rendons pas toujours tous les portails, nous masquons donc le rendu lorsque le lecteur / la caméra est loin. </li><li>  Pour savoir à quelle distance le joueur est du portail, je détermine la <b>distance</b> entre la position de la caméra et la position de l'acteur.  Ensuite, je divise la distance par la valeur maximale avec laquelle je veux effectuer une comparaison.  Par exemple, si le maximum que je fixe est de 2000 et que la distance au joueur est de 1000, alors nous obtenons 0,5.  Si le joueur est plus loin, alors j'obtiendrai une valeur supérieure à 1, donc j'utilise des nœuds saturés pour le limiter.  Vient ensuite le nœud Smoothstep, utilisé pour mettre à l'échelle la distance en tant que gradient et contrôler plus précisément l'ombrage du portail.  Par exemple, je veux que lorsque le joueur est proche, l'ombre disparaît complètement. </li><li>  J'utilise le calcul de la distance comme valeur de canal alpha pour le nœud <b>Lerp</b> pour mélanger la couleur d'ombrage et la <b>texture</b> qui rendra la cible du portail. </li><li>  Enfin, j'isole la composante Y des coordonnées UV pour créer un masque qui vous permet de savoir quels sommets du maillage seront poussés.  Je multiplie ce masque par la quantité de répulsion dont j'ai besoin.  J'utilise une valeur négative pour que lorsque les normales des sommets sont multipliées par les sommets, elles se déplacent dans la direction opposée. </li></ul><br>  Après avoir fait tout cela, nous avons créé du matériel prêt à l'emploi. <br><br><h2>  Création d'un acteur de portail dans Blueprint </h2><br>  Configurons une nouvelle classe de plan héritée de l'acteur Portal.  Cliquez avec le bouton droit sur le navigateur de contenu et sélectionnez la classe Blueprint: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/28b/5a2/ead28b5a23369c2c86a076ec8bb1dda0.png"></div><br>  Entrez maintenant «portail» dans le champ de recherche pour sélectionner la classe de portail: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/da4/555/bd7da4555cff2dc953ab3b0b0f4d1057.png"></div><br>  Ouvrez Bluetooth s'il n'est pas déjà ouvert.  Dans la liste des composants, vous verrez la hiérarchie suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/34c/308/73c34c308a70f644759dc9057b0facd2.png"></div><br>  Comme nous nous y attendions, il existe un composant racine et une racine de portail.  Ajoutons un composant de maillage statique à PortalRootComponent et chargeons-y le maillage créé à l'étape précédente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/ef3/11d/fa4ef311d11c803afc565060a9902c24.jpg"></div><br><hr><br>  Nous ajoutons également la Collision Box, qui sera utilisée pour déterminer si le joueur est à l'intérieur du volume du portail: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b0/28f/df6/0b028fdf696598f6b3eca9af3049caa1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2a/85d/747/c2a85d747c8b76900cae32e9f9cc1a59.png"></div><br>  La zone Collision est située sous le composant de scène associé à la racine principale et non sous la racine du portail.  J'ai également ajouté une icône (panneau d'affichage) et un composant flèche pour rendre le portail plus visible aux niveaux.  Bien sûr, ce n'est pas nécessaire. <br><br>  Maintenant, configurons le matériau dans le plan. <br><br>  Pour commencer, nous avons besoin de deux variables - l'une sera de type <b>Actor</b> et le nom est <b>PortalTarget</b> , la seconde est de type <b>Dynamic Material Instance</b> et s'appelle <b>MaterialInstance</b> .  PortalTarget sera une référence à la position que la fenêtre du portail regarde (par conséquent, la variable est commune, avec une icône en forme d'œil ouvert) afin que nous puissions la changer lorsque l'acteur est placé au niveau.  MaterialInstance stockera un lien vers du matériel dynamique afin qu'à l'avenir nous puissions assigner la cible de rendu du portail à la volée. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/0b9/772/4740b9772dfc7ce30cda63300f1682a5.png"></div><br>  Nous devons également ajouter nos propres nœuds d'événements.  Il est préférable d'ouvrir le menu contextuel dans le <b>graphique des événements</b> et de trouver les noms des événements: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/719/d22/bc2719d224381581c9bdb8ea5ce7c365.png"></div><br>  Et ici pour créer le diagramme suivant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f4/400/24f/0f440024f5c322c6640609bb8d20bcad.jpg"></div><br><ul><li>  <b>Commencer la lecture</b> : ici, nous appelons la fonction parent SetTarget () du portail pour lui attribuer un lien vers l'acteur, qui sera ensuite utilisé pour SceneCapture.  Nous créons ensuite un nouveau matériau dynamique et lui attribuons la valeur de la variable MaterialInstance.  Avec ce nouveau matériau, nous pouvons l'assigner au composant de maillage statique.  J'ai également donné au matériau une texture factice, mais cela est facultatif. </li><li>  <b>Clear RTT</b> : Le but de cette fonction est d'effacer la texture Render Target affectée au matériau du portail.  Il est lancé par le gestionnaire de portail. </li><li>  <b>Définir RTT</b> : le but de cette fonction est de définir le matériau cible de rendu du portail.  Il est lancé par le gestionnaire de portail. </li></ul><br>  Jusqu'à présent, nous avons terminé avec le bluetooth, mais nous y reviendrons plus tard pour implémenter les fonctions Tick. <br><br><h2>  Gestionnaire de portail </h2><br>  Donc, nous avons maintenant tous les éléments de base nécessaires pour créer une nouvelle classe héritée d'AActor, qui sera Portal Manager.  Vous n'avez peut-être pas besoin de la classe Portal Manager dans votre projet, mais dans mon cas, cela simplifie considérablement le travail avec certains aspects.  Voici une liste des tâches effectuées par le gestionnaire de portail: <br><br><ul><li>  Le gestionnaire de portail est un acteur <b>créé par le contrôleur de joueur</b> et attaché à lui pour suivre l'état et l'évolution du joueur dans le niveau de jeu. </li><li>  Créez et détruisez <b>le portail cible de rendu</b> .  L'idée est de créer dynamiquement une texture cible de rendu qui correspond à la résolution d'écran du lecteur.  De plus, lors du changement de résolution pendant le jeu, le manager la convertira automatiquement à la taille souhaitée. </li><li>  Le gestionnaire de portail <b>recherche et met à jour</b> le niveau d'acteur de portail pour leur donner une cible de rendu.  Cette tâche est effectuée de manière à assurer la compatibilité avec le streaming de niveau.  Lorsqu'un nouvel acteur apparaît, il devrait obtenir une texture.  De plus, si la cible de rendu change, le gestionnaire peut également en attribuer une nouvelle automatiquement.  Cela facilite la gestion du système, au lieu que chaque acteur du portail contacte manuellement le gestionnaire. </li><li>  Le composant <b>SceneCapture est</b> attaché au gestionnaire de portail, afin de ne pas créer une copie pour chaque portail.  De plus, il vous permet de le réutiliser chaque fois que nous passons à un acteur de portail spécifique au niveau. </li><li>  Lorsque le portail décide de <b>téléporter le</b> joueur, il envoie une demande au gestionnaire de portail.  Cela est nécessaire pour mettre à jour les portails source et de destination (le cas échéant), afin que la transition se fasse sans joints. </li><li>  <b>Le</b> gestionnaire de portail est <b>mis</b> à <b>jour</b> à la fin de la fonction <b>tick ()</b> du <b>personnage</b> afin que tout soit correctement mis à jour, y compris la caméra du joueur.  Cela garantit que tout sur l'écran est synchronisé et évite un retard d'une image lors du rendu par le moteur. </li></ul><br>  Jetons un coup d'œil à l'en-tête de Portal Manager: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortalManager.generated.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Forward declaration class AExedrePlayerController; class AExedrePortal; class UExedreScriptedTexture; UCLASS() class EXEDRE_API AExedrePortalManager : public AActor { GENERATED_UCLASS_BODY() public: AExedrePortalManager(); //Called by a Portal actor when wanting to teleport something UFUNCTION(BlueprintCallable, Category="Portal") void RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ); //Save a reference to the PlayerControler void SetControllerOwner( AExedrePlayerController* NewOwner ); //Various setup that happens during spawn void Init(); //Manual Tick void Update( float DeltaTime ); //Find all the portals in world and update them //returns the most valid/usable one for the Player AExedrePortal* UpdatePortalsInWorld(); //Update SceneCapture void UpdateCapture( AExedrePortal* Portal ); //Accessor for Debug purpose UTexture* GetPortalTexture(); //Accessor for Debug purpose FTransform GetCameraTransform(); private: //Function to create the Portal render target void GeneratePortalTexture(); UPROPERTY() USceneCaptureComponent2D* SceneCapture; //Custom class, can be replaced by a "UCanvasRenderTarget2D" instead //See : https://api.unrealengine.com/INT/API/Runtime/Engine/Engine/UCanvasRenderTarget2D/index.html UPROPERTY() UExedreScriptedTexture* PortalTexture; UPROPERTY() AExedrePlayerController* ControllerOwner; int32 PreviousScreenSizeX; int32 PreviousScreenSizeY; float UpdateDelay; };</span></span></span></span></code> </pre> <br><hr><br>  Avant d'entrer dans les détails, je vais montrer comment un acteur est créé à partir de la classe Player Controller, appelée à partir de la fonction BeginPlay (): <br><br><pre> <code class="cpp hljs"> FActorSpawnParameters SpawnParams; PortalManager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PortalManager = GetWorld()-&gt;SpawnActor&lt;AExedrePortalManager&gt;( AExedrePortalManager::StaticClass(), FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams); PortalManager-&gt;AttachToActor( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, FAttachmentTransformRules::SnapToTargetIncludingScale); PortalManager-&gt;SetControllerOwner( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); PortalManager-&gt;Init();</code> </pre> <br>  Ainsi, nous créons un acteur, l'attachons au contrôleur du joueur (ceci), puis enregistrons le lien et appelons la fonction Init (). <br><br>  Il est également important de noter que nous mettons à jour l'acteur manuellement à partir de la classe Character: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedreCharacter::TickActor( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime, <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELevelTick TickType, FActorTickFunction&amp; ThisTickFunction ) { Super::TickActor( DeltaTime, TickType, ThisTickFunction ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) ); EPC-&gt;PortalManager-&gt;Update( DeltaTime ); } }</code> </pre> <br>  Et voici le constructeur de Portal Manager.  Notez que Tick est désactivé, car nous mettrons à jour manuellement Portal Manager via le lecteur. <br><br><pre> <code class="cpp hljs">AExedrePortalManager::AExedrePortalManager(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; PortalTexture = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; UpdateDelay = <span class="hljs-number"><span class="hljs-number">1.1f</span></span>; PreviousScreenSizeX = <span class="hljs-number"><span class="hljs-number">0</span></span>; PreviousScreenSizeY = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><hr><br>  Voici les fonctions de get / set Portal Manager (après quoi nous passerons à des choses plus intéressantes): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::SetControllerOwner( AExedrePlayerController* NewOwner ) { ControllerOwner = NewOwner; } FTransform AExedrePortalManager::GetCameraTransform() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( SceneCapture != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SceneCapture-&gt;GetComponentTransform(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FTransform(); } } UTexture* AExedrePortalManager::GetPortalTexture() { <span class="hljs-comment"><span class="hljs-comment">//Portal Texture is a custom component class that embed a UCanvasRenderTraget2D //The GetTexture() simply returns the RenderTarget contained in that class. //IsValidLowLevel() is used here as a way to ensure the Texture has not been destroyed or garbage collected. if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { return PortalTexture-&gt;GetTexture(); } else { return nullptr; } }</span></span></code> </pre> <br><hr><br>  De toute évidence, la première chose à commencer est la fonction <b>Init ()</b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'objectif principal de cette fonction est de créer le composant SceneCapture (c'est-à-dire le périphérique de capture mentionné ci-dessus) et de le configurer correctement. </font><font style="vertical-align: inherit;">Cela commence par la création d'un nouvel objet et son enregistrement en tant que composante de cet acteur. </font><font style="vertical-align: inherit;">Ensuite, nous passons à la définition des propriétés liées à cette capture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propriétés à mentionner:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bCaptureEveryFrame = false</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nous ne voulons pas que la capture soit </font><b><font style="vertical-align: inherit;">activée</font></b><font style="vertical-align: inherit;"> lorsque nous n'en avons pas besoin. </font><font style="vertical-align: inherit;">Nous le gérerons manuellement.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bEnableClipPlane = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : propriété assez importante pour rendre correctement la capture du portail.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bUseCustomProjectionMatrix = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cela nous permet de remplacer la projection Capture par la nôtre, en fonction du point de vue du joueur.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CaptureSource = ESceneCaptureSource :: SCS_SceneColorSceneDepth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ce mode est un peu cher, mais il est nécessaire de restituer une quantité d'informations suffisante.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les propriétés restantes sont principalement liées aux paramètres de post-traitement. </font><font style="vertical-align: inherit;">Ils sont un moyen pratique de contrôler la qualité et donc de capturer les performances. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La dernière partie appelle la fonction qui crée la cible de rendu, que nous verrons ci-dessous.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Init() { <span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------ //Create Camera //------------------------------------------------ SceneCapture = NewObject&lt;USceneCaptureComponent2D&gt;(this, USceneCaptureComponent2D::StaticClass(), *FString("PortalSceneCapture")); SceneCapture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); SceneCapture-&gt;RegisterComponent(); SceneCapture-&gt;bCaptureEveryFrame = false; SceneCapture-&gt;bCaptureOnMovement = false; SceneCapture-&gt;LODDistanceFactor = 3; //Force bigger LODs for faster computations SceneCapture-&gt;TextureTarget = nullptr; SceneCapture-&gt;bEnableClipPlane = true; SceneCapture-&gt;bUseCustomProjectionMatrix = true; SceneCapture-&gt;CaptureSource = ESceneCaptureSource::SCS_SceneColorSceneDepth; //Setup Post-Process of SceneCapture (optimization : disable Motion Blur, etc) FPostProcessSettings CaptureSettings; CaptureSettings.bOverride_AmbientOcclusionQuality = true; CaptureSettings.bOverride_MotionBlurAmount = true; CaptureSettings.bOverride_SceneFringeIntensity = true; CaptureSettings.bOverride_GrainIntensity = true; CaptureSettings.bOverride_ScreenSpaceReflectionQuality = true; CaptureSettings.AmbientOcclusionQuality = 0.0f; //0=lowest quality..100=maximum quality CaptureSettings.MotionBlurAmount = 0.0f; //0 = disabled CaptureSettings.SceneFringeIntensity = 0.0f; //0 = disabled CaptureSettings.GrainIntensity = 0.0f; //0 = disabled CaptureSettings.ScreenSpaceReflectionQuality = 0.0f; //0 = disabled CaptureSettings.bOverride_ScreenPercentage = true; CaptureSettings.ScreenPercentage = 100.0f; SceneCapture-&gt;PostProcessSettings = CaptureSettings; //------------------------------------------------ //Create RTT Buffer //------------------------------------------------ GeneratePortalTexture(); }</span></span></code> </pre> <br><hr><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeneratePortalTexture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une fonction qui est appelée lorsque cela est nécessaire lorsque vous devez créer une nouvelle texture cible de rendu pour les portails. </font><font style="vertical-align: inherit;">Cela se produit dans la fonction d'initialisation, mais il peut également être appelé lors de la mise à niveau de Portal Manager. </font><font style="vertical-align: inherit;">C'est pourquoi cette fonction dispose d'un contrôle interne pour modifier la résolution de la fenêtre. </font><font style="vertical-align: inherit;">Si cela ne s'est pas produit, la mise à jour n'est pas effectuée.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans mon cas, j'ai créé une classe wrapper pour UCanvasRenderTarget2D. Je l'ai appelé ExedreScriptedTexture, c'est un composant qui peut être attaché à un acteur. J'ai créé cette classe pour gérer facilement les cibles de rendu avec des acteurs qui ont des tâches de rendu. Il effectue l'initialisation appropriée de la cible de rendu et est compatible avec mon propre système d'interface utilisateur. Cependant, dans le contexte des portails, une texture RenderTarget2D régulière est plus que suffisante. Par conséquent, vous pouvez simplement l'utiliser.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::GeneratePortalTexture() { int32 CurrentSizeX = <span class="hljs-number"><span class="hljs-number">1920</span></span>; int32 CurrentSizeY = <span class="hljs-number"><span class="hljs-number">1080</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;GetViewportSize(CurrentSizeX, CurrentSizeY); } CurrentSizeX = FMath::Clamp( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(CurrentSizeX / <span class="hljs-number"><span class="hljs-number">1.7</span></span>), <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1920</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1920 / 1.5 = 1280 CurrentSizeY = FMath::Clamp( int(CurrentSizeY / 1.7), 128, 1080); if( CurrentSizeX == PreviousScreenSizeX &amp;&amp; CurrentSizeY == PreviousScreenSizeY ) { return; } PreviousScreenSizeX = CurrentSizeX; PreviousScreenSizeY = CurrentSizeY; //Cleanup existing RTT if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { PortalTexture-&gt;DestroyComponent(); GEngine-&gt;ForceGarbageCollection(); } //Create new RTT PortalTexture = nullptr; PortalTexture = NewObject&lt;UExedreScriptedTexture&gt;(this, UExedreScriptedTexture::StaticClass(), *FString("PortalRenderTarget")); PortalTexture-&gt;SizeX = CurrentSizeX; PortalTexture-&gt;SizeY = CurrentSizeY; //Custom properties of the UExedreScriptedTexture class PortalTexture-&gt;Gamma = 1.0f; PortalTexture-&gt;WrapModeX = 1; //Clamp PortalTexture-&gt;WrapModeY = 1; //Clamp PortalTexture-&gt;bDrawWidgets = false; PortalTexture-&gt;bGenerateMipMaps = false; PortalTexture-&gt;SetClearOnUpdate( false ); //Will be cleared by SceneCapture instead PortalTexture-&gt;Format = ERenderTargetFormat::RGBA16; //Needs 16b to get &gt;1 for Emissive PortalTexture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); PortalTexture-&gt;RegisterComponent(); PortalTexture-&gt;SetOwner( this ); PortalTexture-&gt;Init(); PortalTexture-&gt;SetFilterMode( TextureFilter::TF_Bilinear ); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme mentionné ci-dessus, j'ai créé ma propre classe, donc les propriétés définies ici doivent être adaptées à la cible de rendu habituelle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est important de comprendre où la capture sera affichée. </font><font style="vertical-align: inherit;">Étant donné que la cible de rendu sera affichée dans le jeu, cela signifie que cela se produira avant tout le post-traitement, et nous devons donc rendre la scène avec suffisamment d'informations (pour stocker des valeurs supérieures à 1 pour créer Bloom). </font><font style="vertical-align: inherit;">C'est pourquoi j'ai choisi le format RGBA16 (notez qu'il a son propre Enum, vous devrez utiliser ETextureRenderTargetFormat à la place). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour plus d'informations, consultez les sources suivantes:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UTextureRenderTarget2D</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETextureRenderTargetFormat</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USceneCaptureComponent2D</font></font></a> </li></ul><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, nous considérerons les fonctions de mise à jour. </font><font style="vertical-align: inherit;">La fonction de base est assez simple et rend plus complexe. </font><font style="vertical-align: inherit;">Il existe un délai avant les appels à la fonction GeneratePortalTexture () pour éviter de recréer la cible de rendu lors du redimensionnement de la fenêtre (par exemple, dans l'éditeur). </font><font style="vertical-align: inherit;">Lors de la publication du jeu, ce délai peut être supprimé.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Update( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime ) { <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Generate Portal texture ? //----------------------------------- UpdateDelay += DeltaTime; if( UpdateDelay &gt; 1.0f ) { UpdateDelay = 0.0f; GeneratePortalTexture(); } //----------------------------------- //Find portals in the level and update them //----------------------------------- AExedrePortal* Portal = UpdatePortalsInWorld(); if( Portal != nullptr ) { UpdateCapture( Portal ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous appelons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour trouver tous les portails présents dans le monde actuel (y compris tous les niveaux chargés) et les mettre à jour. </font><font style="vertical-align: inherit;">La fonction détermine également lequel est «actif», c'est-à-dire </font><font style="vertical-align: inherit;">visible pour le joueur. </font><font style="vertical-align: inherit;">Si nous trouvons un portail actif, nous appelons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui contrôle le composant SceneCapture.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici comment fonctionne la mise à jour mondiale dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ol><li>   <b></b>   (    ) </li><li>   <b>iterator</b> ,         </li><li>     ,   ,    <b>ClearRTT()</b> ,    .    <b> </b> (,   ). </li><li>  ,     <b></b>  ,    ,     ,     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le contrôle qui détermine l'exactitude du portail est simple: nous donnons la priorité au portail le plus proche du joueur, car il sera très probablement le plus visible de son point de vue. </font><font style="vertical-align: inherit;">Pour supprimer des proches, mais, par exemple, des portails situés derrière le joueur, des vérifications plus complexes seront nécessaires, mais je ne voulais pas me concentrer sur cela dans mon tutoriel, car cela peut devenir assez difficile.</font></font><br><br><pre> <code class="cpp hljs">AExedrePortal* AExedrePortalManager::UpdatePortalsInWorld() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update Portal actors in the world (and active one if nearby) //----------------------------------- AExedrePortal* ActivePortal = nullptr; FVector PlayerLocation = Character-&gt;GetActorLocation(); FVector CameraLocation = Character-&gt;GetCameraComponent()-&gt;GetComponentLocation(); float Distance = 4096.0f; for( TActorIterator&lt;AExedrePortal&gt;ActorItr( GetWorld() ); ActorItr; ++ActorItr ) { AExedrePortal* Portal = *ActorItr; FVector PortalLocation = Portal-&gt;GetActorLocation(); FVector PortalNormal = -1 * Portal-&gt;GetActorForwardVector(); //Reset Portal Portal-&gt;ClearRTT(); Portal-&gt;SetActive( false ); //Find the closest Portal when the player is Standing in front of float NewDistance = FMath::Abs( FVector::Dist( PlayerLocation, PortalLocation ) ); if( NewDistance &lt; Distance ) { Distance = NewDistance; ActivePortal = Portal; } } return ActivePortal; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est temps de considérer la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit d'une fonctionnalité de mise à niveau qui capture l'autre côté du portail. </font><font style="vertical-align: inherit;">D'après les commentaires, tout doit être clair, mais voici une brève description:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous obtenons des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liens</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vers le contrôleur de personnage et de joueur.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous vérifions </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si tout est correct</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Portal, composant SceneCapture, Player).</font></font></li><li>   <b>Camera</b>    <b>Target</b>  . </li><li> <b></b>    ,     SceneCapture. </li><li>      SceneCapture     Target. </li><li> ,  SceneCapure  ,  ,   <b></b> . </li><li> <b> Render Target</b>  SceneCapture,  . </li><li>  <b> </b>  PlayerController. </li><li> ,    <b>Capture</b>  SceneCapture     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme nous pouvons le voir, lors de la téléportation d'un joueur, un élément clé du comportement naturel et sans défaut de SceneCapture est la transformation correcte de la position et de la rotation du portail dans l'espace cible local. </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour la définition de ConvertLocationToActorSpace (), voir «Téléportation d'un acteur». </font></font></blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::UpdateCapture( AExedrePortal* Portal ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update SceneCapture (discard if there is no active portal) //----------------------------------- if(SceneCapture != nullptr &amp;&amp; PortalTexture != nullptr &amp;&amp; Portal != nullptr &amp;&amp; Character != nullptr ) { UCameraComponent* PlayerCamera = Character-&gt;GetCameraComponent(); AActor* Target = Portal-&gt;GetTarget(); //Place the SceneCapture to the Target if( Target != nullptr ) { //------------------------------- //Compute new location in the space of the target actor //(which may not be aligned to world) //------------------------------- FVector NewLocation = UTool::ConvertLocationToActorSpace( PlayerCamera-&gt;GetComponentLocation(), Portal, Target ); SceneCapture-&gt;SetWorldLocation( NewLocation ); //------------------------------- //Compute new Rotation in the space of the //Target location //------------------------------- FTransform CameraTransform = PlayerCamera-&gt;GetComponentTransform(); FTransform SourceTransform = Portal-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * CameraTransform.GetRotation(); FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; //Update SceneCapture rotation SceneCapture-&gt;SetWorldRotation( NewWorldQuat ); //------------------------------- //Clip Plane : to ignore objects between the //SceneCapture and the Target of the portal //------------------------------- SceneCapture-&gt;ClipPlaneNormal = Target-&gt;GetActorForwardVector(); SceneCapture-&gt;ClipPlaneBase = Target-&gt;GetActorLocation() + (SceneCapture-&gt;ClipPlaneNormal * -1.5f); //Offset to avoid visible pixel border } //Switch on the valid Portal Portal-&gt;SetActive( true ); //Assign the Render Target Portal-&gt;SetRTT( PortalTexture-&gt;GetTexture() ); SceneCapture-&gt;TextureTarget = PortalTexture-&gt;GetTexture(); //Get the Projection Matrix SceneCapture-&gt;CustomProjectionMatrix = ControllerOwner-&gt;GetCameraProjectionMatrix(); //Say Cheeeeese ! SceneCapture-&gt;CaptureScene(); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCameraProjectionMatrix ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'existe pas par défaut dans la classe PlayerController, je l'ai ajoutée moi-même. </font><font style="vertical-align: inherit;">Il est illustré ci-dessous:</font></font><br><br><pre> <code class="cpp hljs">FMatrix AExedrePlayerController::GetCameraProjectionMatrix() { FMatrix ProjectionMatrix; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( GetLocalPlayer() != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { FSceneViewProjectionData PlayerProjectionData; GetLocalPlayer()-&gt;GetProjectionData( GetLocalPlayer()-&gt;ViewportClient-&gt;Viewport, EStereoscopicPass::eSSP_FULL, PlayerProjectionData ); ProjectionMatrix = PlayerProjectionData.ProjectionMatrix; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProjectionMatrix; }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, nous devons implémenter l'appel à la fonction Teleport. </font><font style="vertical-align: inherit;">La raison du traitement partiel de la téléportation via le gestionnaire de portail est qu'il est nécessaire de garantir la mise à jour des portails nécessaires, car seul le gestionnaire dispose d'informations sur tous les portails de la scène. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous avons deux portails connectés, lors du passage de l'un à l'autre, nous devons mettre à jour les deux en une seule fois. </font><font style="vertical-align: inherit;">Sinon, le joueur se téléportera et sera de l'autre côté du portail, mais le portail cible ne sera pas actif avant la prochaine image / mesure. </font><font style="vertical-align: inherit;">Cela créera des espaces visuels avec le matériau décalé du maillage plan que nous avons vu ci-dessus.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { Portal-&gt;TeleportActor( TargetToTeleport ); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Force update //----------------------------------- AExedrePortal* FuturePortal = UpdatePortalsInWorld(); if( FuturePortal != nullptr ) { FuturePortal-&gt;ForceTick(); //Force update before the player render its view since he just teleported UpdateCapture( FuturePortal ); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eh bien, c'est tout, nous avons finalement terminé avec Portal Manager! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terminer le plan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fois le gestionnaire de portail terminé, il nous suffit de terminer l'acteur du portail lui-même, après quoi le système fonctionnera. </font><font style="vertical-align: inherit;">La seule chose qui manque ici est les fonctionnalités de Tick:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/455/bd3/f0f/455bd3f0f3b7c9f4f3fb36d5d1ae85d0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voici comment cela fonctionne: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous mettons à jour le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matériel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin qu'il ne reste pas dans un état actif.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le portail </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actuellement </font><b><font style="vertical-align: inherit;">inactif</font></b><font style="vertical-align: inherit;"> , le reste de la mesure est rejeté.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous obtenons la classe Personnage pour accéder à l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emplacement de la caméra</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La première partie vérifie si la caméra se trouve dans la zone de collision du portail. </font><font style="vertical-align: inherit;">Si c'est le cas, nous compensons le maillage du portail avec son </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matériau</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deuxième partie consiste à revérifier l'emplacement à l'intérieur de la zone de collision. </font><font style="vertical-align: inherit;">S'il est exécuté, nous appelons une fonction qui vérifie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si nous traversons le portail</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li>        ,   Portal manager,    <b> Teleport</b> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la capture d'écran de mon graphique, vous pouvez remarquer deux points intéressants: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Point Inside Box</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get Portal Manager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Je n'ai pas encore expliqué ces deux fonctions. Ce sont des fonctions statiques que j'ai définies dans ma propre classe afin que vous puissiez les appeler de n'importe où. Il s'agit d'une sorte de classe d'aide. Le code de ces fonctions est indiqué ci-dessous, vous pouvez vous-même décider où les insérer. Si vous n'en avez pas besoin en dehors du système de portail, vous pouvez les insérer directement dans la classe d'acteur de portail. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au début, je voulais utiliser le système de collision pour déterminer si l'acteur de portail à l'intérieur de la zone de collision se trouve dans le portail, mais il ne m'a pas semblé suffisamment fiable. De plus, il me semble que cette méthode est plus rapide à utiliser et présente un avantage: elle prend en compte la rotation de l'acteur.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPointInsideBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Point, UBoxComponent* Box )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Box != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//From : //https://stackoverflow.com/questions/52673935/check-if-3d-point-inside-a-box/52674010 FVector Center = Box-&gt;GetComponentLocation(); FVector Half = Box-&gt;GetScaledBoxExtent(); FVector DirectionX = Box-&gt;GetForwardVector(); FVector DirectionY = Box-&gt;GetRightVector(); FVector DirectionZ = Box-&gt;GetUpVector(); FVector Direction = Point - Center; bool IsInside = FMath::Abs( FVector::DotProduct( Direction, DirectionX ) ) &lt;= Half.X &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionY ) ) &lt;= Half.Y &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionZ ) ) &lt;= Half.Z; return IsInside; } else { return false; } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AExedrePortalManager* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPortalManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AActor* Context )</span></span></span><span class="hljs-function"> </span></span>{ AExedrePortalManager* Manager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Retrieve the World from the Context actor if( Context != nullptr &amp;&amp; Context-&gt;GetWorld() != nullptr ) { //Find PlayerController AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( Context-&gt;GetWorld()-&gt;GetFirstPlayerController() ); //Retrieve the Portal Manager if( EPC != nullptr &amp;&amp; EPC-&gt;GetPortalManager() != nullptr ) { Manager = EPC-&gt;GetPortalManager(); } } return Manager; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La dernière partie de l'acteur Blueprint est </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ForceTick</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">N'oubliez pas que Force Tick est appelé lorsqu'un joueur traverse un portail et se trouve à côté d'un autre portail pour lequel Portal Manager force une mise à jour. </font><font style="vertical-align: inherit;">Comme nous venons de nous téléporter, il n'est pas nécessaire d'utiliser le même code, et vous pouvez utiliser sa version simplifiée:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/562/22e/cf356222e9d9c81dc38c57d021e51a90.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le processus démarre approximativement en même temps que la fonction Tick, mais nous n'exécutons que la première partie de la séquence, qui met à jour le matériel. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avons-nous fini? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presque. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous implémentons le système de portail sous cette forme, nous rencontrerons très probablement le problème suivant:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/f2f/9f7/4c1f2f9f71e8ce213764d42dad1d20c3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que se passe-t-il ici? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce gif, la fréquence d'images du jeu est limitée à 6 FPS pour montrer plus clairement le problème. Dans une image, le cube disparaît car le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">système d'écrêtage d'</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unreal Engine le considère comme invisible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En effet, la découverte est effectuée dans la trame actuelle, puis utilisée dans la suivante. Cela crée un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retard d'une trame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela peut généralement être résolu en développant le cadre de sélection de l'objet afin qu'il soit enregistré avant qu'il ne devienne visible. Cependant, cela ne fonctionnera pas ici, car lorsque nous traversons le portail, nous nous téléportons d'un endroit à un autre.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La désactivation du système d'écrêtage est également impossible, en particulier parce qu'aux niveaux avec de nombreux objets, cela réduira les performances. De plus, j'ai essayé de nombreuses équipes du moteur Unreal, mais je n'ai pas obtenu de résultats positifs: dans tous les cas, un retard d'une trame est resté. Heureusement, après une étude détaillée du code source d'Unreal Engine, j'ai réussi à trouver une solution (le chemin était long - il a fallu plus d'une semaine)! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme avec le composant SceneCapture, vous pouvez dire à la caméra du lecteur que nous avons effectué une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coupure de saut</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- la position de la caméra a sauté entre deux images, ce qui signifie que nous ne pouvons pas nous fier aux informations de l'image précédente. </font><font style="vertical-align: inherit;">Ce comportement peut être observé lors de l'utilisation de Matinee ou Sequencer, par exemple, lors du changement de caméra: le flou de mouvement ou le lissage ne peut pas s'appuyer sur les informations de l'image précédente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ce faire, nous devons considérer deux aspects:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LocalPlayer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cette classe gère diverses informations (par exemple, la fenêtre du joueur) et est associée au PlayerController. </font><font style="vertical-align: inherit;">C’est là que nous pouvons influencer le processus de rendu de la caméra du lecteur.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerController</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : lorsqu'un joueur se téléporte, cette classe commence à épisser grâce à l'accès à LocalPlayer.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le gros avantage de cette solution est que l'intervention dans le processus de rendu du moteur est minimale et facile à entretenir dans les futures mises à jour d'Unreal Engine. </font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commençons par créer une nouvelle classe héritée de LocalPlayer. </font><font style="vertical-align: inherit;">Vous trouverez ci-dessous un en-tête qui identifie deux composants principaux: la redéfinition des calculs de la fenêtre de scène et une nouvelle fonction pour invoquer le collage de la caméra.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Engine/LocalPlayer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API UExedreLocalPlayer : public ULocalPlayer { GENERATED_BODY() UExedreLocalPlayer(); public: FSceneView* CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) override; void PerformCameraCut(); private: bool bCameraCut; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voici comment tout est mis en œuvre: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Exedre.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.h"</span></span></span><span class="hljs-meta"> UExedreLocalPlayer::UExedreLocalPlayer() { bCameraCut = false; } FSceneView* UExedreLocalPlayer::CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ULocalPlayer::CalcSceneView() use a ViewInitOptions to create // a FSceneView which contains a "bCameraCut" variable // See : H:\GitHub\UnrealEngine\Engine\Source\Runtime\Renderer\Private\SceneCaptureRendering.cpp // as well for bCameraCutThisFrame in USceneCaptureComponent2D FSceneView* View = Super::CalcSceneView(ViewFamily, OutViewLocation, OutViewRotation, Viewport, ViewDrawer, StereoPass ); if( bCameraCut ) { View-&gt;bCameraCut = true; bCameraCut = false; } return View; } void UExedreLocalPlayer::PerformCameraCut() { bCameraCut = true; }</span></span></span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PerformCameraCut ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> démarre simplement Camera Cut avec une valeur booléenne. </font><font style="vertical-align: inherit;">Lorsque le moteur appelle la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous </font><b><font style="vertical-align: inherit;">exécutons d'</font></b><font style="vertical-align: inherit;"> abord la fonction d'origine. </font><font style="vertical-align: inherit;">Ensuite, nous vérifions, nous devons effectuer un collage. </font><font style="vertical-align: inherit;">Si c'est le cas, nous redéfinissons la variable booléenne Camera Cut à l'intérieur de la structure </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSceneView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui sera utilisée par le processus de rendu du moteur, puis réinitialisons la variable booléenne (utilisez-la).</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Côté Player Controller, les changements sont minimes. </font><font style="vertical-align: inherit;">Vous devez ajouter une variable à l'en-tête pour stocker un lien vers la classe native LocalPlayer:</font></font><br><br><pre> <code class="cpp hljs"> UPROPERTY() UExedreLocalPlayer* LocalPlayer;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puis dans la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BeginPlay ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"> LocalPlayer = Cast&lt;UExedreLocalPlayer&gt;( GetLocalPlayer() );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> J'ai également ajouté une fonction pour lancer rapidement Cut: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePlayerController::PerformCameraCut() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( LocalPlayer != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { LocalPlayer-&gt;PerformCameraCut(); } }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, dans la fonction Portal Manager </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RequestTeleportByPortal (),</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous pouvons exécuter pendant la téléportation Camera Cut:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;PerformCameraCut(); } [...]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et c'est tout! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camera Cut doit être appelé avant la mise à jour de SceneCapture, c'est pourquoi il se trouve au début de la fonction.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Résultat final </font></font></h2><br> <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons appris à penser dans les portails. </font></font></a></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le système fonctionne bien, nous devrions pouvoir créer ces choses:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si vous rencontrez des problèmes, vérifiez les points suivants: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vérifiez que Portal Manager est correctement créé et initialisé. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La cible de rendu est créée correctement (vous pouvez utiliser celle créée dans le navigateur de contenu pour commencer). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les portails sont correctement activés et désactivés. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les portails ont l'acteur cible correctement défini dans l'éditeur. </font></font></li></ul><br><h2>  Q &amp; A </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les questions les plus fréquemment posées à propos de ce tutoriel: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est-il possible de l'implémenter sur des contours, et non via C ++? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La majeure partie du code peut être implémentée en blunts, à l'exception de deux aspects:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetProjectionData ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilisée pour obtenir la matrice de projection n'est pas disponible dans les plans.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est essentielle pour résoudre le problème du système d'écrêtage, n'est pas disponible dans les plans.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par conséquent, vous devez soit utiliser une implémentation C ++ pour accéder à ces deux fonctions, soit modifier le code source du moteur pour les rendre accessibles via des plans directeurs. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puis-je utiliser ce système en VR? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oui, pour la plupart. </font><font style="vertical-align: inherit;">Cependant, certaines parties devront être adaptées, par exemple:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez utiliser deux cibles de rendu (une pour chaque œil) et les masquer dans le matériau du portail pour les afficher côte à côte dans l'espace d'écran. </font><font style="vertical-align: inherit;">Chaque cible de rendu doit avoir la moitié de la largeur de la résolution de l'appareil VR.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous devez utiliser deux SceneCapture pour rendre la cible avec la bonne distance (la distance entre les yeux) pour créer des effets stéréoscopiques. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le problème principal sera la performance, car l'autre côté du portail devra être rendu deux fois. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre objet peut-il traverser le portail?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il n'y en a pas dans mon code. Cependant, le rendre plus général n'est pas si difficile. Pour ce faire, le portail doit suivre plus d'informations sur tous les objets à proximité afin de vérifier s'ils le traversent. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le système prend-il en charge la récursivité (portail à l'intérieur du portail)?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ce tutoriel ne l'est pas. Pour la récursivité, vous avez besoin d'une cible de rendu supplémentaire et de SceneCapture. Il sera également nécessaire de déterminer quel RenderTarget rendre en premier, et ainsi de suite. C'est assez difficile et je ne voulais pas le faire, car pour mon projet ce n'est pas nécessaire. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puis-je traverser le portail près du mur?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement non. </font><font style="vertical-align: inherit;">Cependant, je vois deux façons de mettre en œuvre cela (théoriquement):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Désactivez les collisions du joueur afin qu'il puisse passer à travers les murs. </font><font style="vertical-align: inherit;">Il est facile à mettre en œuvre, mais il entraînera de nombreux effets secondaires.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Piratez un système de collision pour créer un trou dynamiquement, ce qui permettra au joueur de passer. </font><font style="vertical-align: inherit;">Pour ce faire, vous devez modifier le système physique du moteur. </font><font style="vertical-align: inherit;">Cependant, d'après ce que je sais, après avoir chargé le niveau, la physique statique ne peut pas être mise à jour. </font><font style="vertical-align: inherit;">Par conséquent, pour prendre en charge cette fonctionnalité, il faudra beaucoup de travail. </font><font style="vertical-align: inherit;">Si vos portails sont statiques, vous pouvez probablement contourner ce problème en utilisant le streaming de niveau pour basculer entre les différentes collisions.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448802/">https://habr.com/ru/post/fr448802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448792/index.html">Test Python avec pytest. Luminaires intégrés, Chapitre 4</a></li>
<li><a href="../fr448794/index.html">Test Python avec pytest. Plugins CHAPITRE 5</a></li>
<li><a href="../fr448796/index.html">Test Python avec pytest. Configuration, CHAPITRE 6</a></li>
<li><a href="../fr448798/index.html">Test Python avec pytest. Utilisation de pytest avec d'autres outils, CHAPITRE 7</a></li>
<li><a href="../fr448800/index.html">Configurer Visual Studio dans votre organisation avec .vsconfig</a></li>
<li><a href="../fr448804/index.html">Se préparer pour le runtime et le notaire renforcés de macOS</a></li>
<li><a href="../fr448806/index.html">Création d'un système d'extension sur la bibliothèque Qt</a></li>
<li><a href="../fr448808/index.html">À propos de choses simples, compliquées. "Acier dormant." Comment graisser les boulons rouillés ou non WD-40 avec un seul ...</a></li>
<li><a href="../fr448810/index.html">Comment ai-je attrapé un pirate</a></li>
<li><a href="../fr448812/index.html">Mission lunaire "Bereshit" - recherche de la première bibliothèque lunaire après le début de l'accident de son porteur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>