<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèª üåü üëèüèª Wir schreiben unseren eigenen Voxelmotor üêØ üë©üèº‚Äçüç≥ ü§∂üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis: Der vollst√§ndige Quellcode f√ºr dieses Projekt ist hier verf√ºgbar: [ Quelle ]. 

 Wenn dem Projekt, an dem ich arbeite, die Puste ausgeht, f√ºg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben unseren eigenen Voxelmotor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474414/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a53/e5f/dea/a53e5fdeab8992f2b647feb66ccf126b.png" alt="Bild"></div><br>  <em><strong>Hinweis: Der</strong> vollst√§ndige Quellcode f√ºr dieses Projekt ist hier verf√ºgbar: [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> ].</em> <br><br>  Wenn dem Projekt, an dem ich arbeite, die Puste ausgeht, f√ºge ich neue Visualisierungen hinzu, die mich motivieren, weiterzumachen. <br><br>  Nach der Ver√∂ffentlichung des urspr√ºnglichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Task-Bot-</a> Konzepts [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> in Habr√©] f√ºhlte ich mich durch den zweidimensionalen Raum, in dem ich arbeitete, eingeschr√§nkt.  Es schien, dass es die M√∂glichkeiten f√ºr das aufkommende Verhalten von Bots zur√ºckhielt. <br><br>  Fr√ºhere erfolglose Versuche, modernes OpenGL zu lernen, haben mir eine mentale Barriere auferlegt, aber Ende Juli habe ich es irgendwie endlich durchbrochen.  Heute, Ende Oktober, habe ich bereits ein ziemlich sicheres Verst√§ndnis f√ºr Konzepte, daher habe ich meine eigene einfache Voxel-Engine ver√∂ffentlicht, die die Umgebung f√ºr das Leben und den Wohlstand meiner Task-Bots sein wird. <br><br>  Ich habe beschlossen, meine eigene Engine zu erstellen, da ich die volle Kontrolle √ºber die Grafiken brauchte.  au√üerdem wollte ich mich testen.  In gewisser Weise habe ich ein Fahrrad erfunden, aber dieser Prozess hat mir sehr gut gefallen! <br><br>  Das ultimative Ziel des gesamten Projekts war eine vollst√§ndige Simulation des √ñkosystems, bei der Bots in der Rolle von Agenten die Umgebung manipulieren und mit ihr interagieren. <br><br>  Da sich die Engine bereits einiges weiterentwickelt hat und ich wieder mit dem Programmieren von Bots fortfahren werde, habe ich beschlossen, einen Beitrag √ºber die Engine, ihre Funktionen und ihre Implementierung zu schreiben, um mich in Zukunft auf √ºbergeordnete Aufgaben zu konzentrieren. <br><a name="habracut"></a><br><h2>  Motorkonzept </h2><br>  Die Engine ist in C ++ vollst√§ndig von Grund auf neu geschrieben (mit einigen Ausnahmen, z. B. dem Finden eines Pfads).  Ich verwende SDL2 zum Rendern von Kontext- und Verarbeitungseingaben, OpenGL zum Rendern einer 3D-Szene und DearImgui zum Steuern der Simulation. <br><br>  Ich habe mich haupts√§chlich deshalb f√ºr Voxel entschieden, weil ich mit einem Raster arbeiten wollte, das viele Vorteile hat: <br><br><ul><li>  Das Erstellen von Maschen zum Rendern ist mir gut bekannt. </li><li>  Die weltweiten Datenspeicherfunktionen sind vielf√§ltiger und verst√§ndlicher. </li><li>  Ich habe bereits Systeme zur Erzeugung von Gel√§nde- und Klimasimulationen basierend auf Maschen erstellt. </li><li>  Die Aufgaben von Bots im Raster sind einfacher zu parametrisieren. </li></ul><br>  Die Engine besteht aus einem Weltdatensystem, einem Rendering-System und mehreren Hilfsklassen (z. B. f√ºr die Ton- und Eingabeverarbeitung). <br><br>  In dem Artikel werde ich auf die aktuelle Liste der Funktionen eingehen und die komplexeren Subsysteme genauer betrachten. <br><br><h3>  Weltklasse </h3><br>  Die Weltklasse dient als Basisklasse zum Speichern aller Informationen der Welt.  Es √ºbernimmt das Generieren, Laden und Speichern von Blockdaten. <br><br>  Die Blockdaten werden in Bl√∂cken konstanter Gr√∂√üe (16 ^ 3) gespeichert, und die Welt speichert den in den virtuellen Speicher geladenen Fragmentvektor.  In gro√üen Welten ist es praktisch notwendig, sich nur an einen bestimmten Teil der Welt zu erinnern, weshalb ich diesen Ansatz gew√§hlt habe. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">World</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: World(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> _saveFile){ saveFile = _saveFile; loadWorld(); } <span class="hljs-comment"><span class="hljs-comment">//Data Storage std::vector&lt;Chunk&gt; chunks; //Loaded Chunks std::stack&lt;int&gt; updateModels; //Models to be re-meshed void bufferChunks(View view); //Generation void generate(); Blueprint blueprint; bool evaluateBlueprint(Blueprint &amp;_blueprint); //File IO Management std::string saveFile; bool loadWorld(); bool saveWorld(); //other... int SEED = 100; int chunkSize = 16; int tickLength = 1; glm::vec3 dim = glm::vec3(20, 5, 20); //...</span></span></code> </pre> <br>  Fragmente speichern Blockdaten sowie einige andere Metadaten in einem flachen Array.  Anfangs habe ich meinen eigenen sp√§rlichen Octree-Baum zum Speichern von Fragmenten implementiert, aber es stellte sich heraus, dass die zuf√§llige Zugriffszeit zu hoch ist, um Netze zu erstellen.  Und obwohl ein flaches Array aus Sicht des Speichers nicht optimal ist, bietet es die M√∂glichkeit, sehr schnell Netze und Manipulationen mit Bl√∂cken zu erstellen sowie auf den Suchpfad zuzugreifen. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Chunk</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Position information and size information glm::vec3 pos; int size; BiomeType biome; //Data Storage Member int data[16*16*16] = {0}; bool refreshModel = false; //Get the Flat-Array Index int getIndex(glm::vec3 _p); void setPosition(glm::vec3 _p, BlockType _type); BlockType getPosition(glm::vec3 _p); glm::vec4 getColorByID(BlockType _type); };</span></span></code> </pre> <br>  Wenn ich jemals das Speichern und Laden von Fragmenten mit mehreren Threads implementiere, kann das Konvertieren eines flachen Arrays in einen sp√§rlichen Octree-Baum und umgekehrt eine vollst√§ndig m√∂gliche Option zum Speichern von Speicher sein.  Es gibt noch Raum f√ºr Optimierungen! <br><br>  Meine Implementierung des sp√§rlichen Octree-Baums ist im Code gespeichert, sodass Sie ihn sicher verwenden k√∂nnen. <br><br><h4>  Fragmentspeicherung und Speicherbehandlung </h4><br>  Fragmente sind nur sichtbar, wenn sie sich innerhalb des Renderabstands zur aktuellen Kameraposition befinden.  Dies bedeutet, dass Sie beim Bewegen der Kamera Fragmente in den Netzen dynamisch laden und zusammensetzen m√ºssen. <br><br>  Fragmente werden mithilfe der Boost-Bibliothek serialisiert, und Weltdaten werden als einfache Textdatei gespeichert, in der jedes Fragment eine Zeile der Datei ist.  Sie werden in einer bestimmten Reihenfolge generiert, damit sie in einer Weltdatei "bestellt" werden k√∂nnen.  Dies ist wichtig f√ºr weitere Optimierungen. <br><br>  Im Falle einer gro√üen Welt besteht der Hauptengpass darin, die Weltdatei zu lesen und Fragmente zu laden / schreiben.  Im Idealfall m√ºssen wir nur die Weltdatei herunterladen und √ºbertragen. <br><br>  Zu diesem <code>World::bufferChunks()</code> entfernt die <code>World::bufferChunks()</code> -Methode Fragmente, die sich im virtuellen Speicher befinden, aber unsichtbar sind, und l√§dt intelligent neue Fragmente aus der World-Datei. <br><br>  Mit Intelligenz ist gemeint, dass er einfach entscheidet, welche neuen Fragmente geladen werden sollen, sie nach ihrer Position in der Sicherungsdatei sortiert und dann einen Durchgang ausf√ºhrt.  Alles ist sehr einfach. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::bufferChunks(View view){ <span class="hljs-comment"><span class="hljs-comment">//Load / Reload all Visible Chunks evaluateBlueprint(blueprint); //Chunks that should be loaded glm::vec3 a = glm::floor(view.viewPos/glm::vec3(chunkSize))-view.renderDistance; glm::vec3 b = glm::floor(view.viewPos/glm::vec3(chunkSize))+view.renderDistance; //Can't exceed a certain size a = glm::clamp(a, glm::vec3(0), dim-glm::vec3(1)); b = glm::clamp(b, glm::vec3(0), dim-glm::vec3(1)); //Chunks that need to be removed / loaded std::stack&lt;int&gt; remove; std::vector&lt;glm::vec3&gt; load; //Construct the Vector of chunks we should load for(int i = ax; i &lt;= bx; i ++){ for(int j = ay; j &lt;= by; j ++){ for(int k = az; k &lt;= bz; k ++){ //Add the vector that we should be loading load.push_back(glm::vec3(i, j, k)); } } } //Loop over all existing chunks for(unsigned int i = 0; i &lt; chunks.size(); i++){ //Check if any of these chunks are outside of the limits if(glm::any(glm::lessThan(chunks[i].pos, a)) || glm::any(glm::greaterThan(chunks[i].pos, b))){ //Add the chunk to the erase pile remove.push(i); } //Don't reload chunks that remain for(unsigned int j = 0; j &lt; load.size(); j++){ if(glm::all(glm::equal(load[j], chunks[i].pos))){ //Remove the element from load load.erase(load.begin()+j); } } //Flags for the Viewclass to use later updateModels = remove; //Loop over the erase pile, delete the relevant chunks. while(!remove.empty()){ chunks.erase(chunks.begin()+remove.top()); remove.pop(); } //Check if we want to load any guys if(!load.empty()){ //Sort the loading vector, for single file-pass std::sort(load.begin(), load.end(), [](const glm::vec3&amp; a, const glm::vec3&amp; b) { if(ax &gt; bx) return true; if(ax &lt; bx) return false; if(ay &gt; by) return true; if(ay &lt; by) return false; if(az &gt; bz) return true; if(az &lt; bz) return false; return false; }); boost::filesystem::path data_dir( boost::filesystem::current_path() ); data_dir /= "save"; data_dir /= saveFile; std::ifstream in((data_dir/"world.region").string()); Chunk _chunk; int n = 0; while(!load.empty()){ //Skip Lines (this is dumb) while(n &lt; load.back().x*dim.z*dim.y+load.back().y*dim.z+load.back().z){ in.ignore(1000000,'\n'); n++; } //Load the Chunk { boost::archive::text_iarchive ia(in); ia &gt;&gt; _chunk; chunks.push_back(_chunk); load.pop_back(); } } in.close(); } }</span></span></code> </pre> <br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterst√ºtzt kein HTML5-Video. <source src="http://weigert.vsos.ethz.ch/wp-content/uploads/2019/10/chunkload.mp4" type="video/mp4"></video></div></div></div><br>  <i>Ein Beispiel f√ºr das Laden von Fragmenten mit geringem Renderabstand.</i>  <i>Bildschirmverzerrungsartefakte werden durch Videoaufzeichnungssoftware verursacht.</i>  <i>Manchmal treten bei Downloads merkliche Spitzen auf, die haupts√§chlich durch Vernetzung verursacht werden</i> <br><br>  Au√üerdem habe ich ein Flag gesetzt, das angibt, dass der Renderer das Netz des geladenen Fragments neu erstellen soll. <br><br><h4>  Blueprint Class und editBuffer </h4><br>  editBuffer ist ein sortierbarer bufferObjects-Container, der Informationen zum Bearbeiten im Weltraum und im Fragmentraum enth√§lt. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//EditBuffer Object Struct struct bufferObject { glm::vec3 pos; glm::vec3 cpos; BlockType type; }; //Edit Buffer! std::vector&lt;bufferObject&gt; editBuffer;</span></span></code> </pre> <br>  Wenn Sie √Ñnderungen an der Welt vornehmen und diese unmittelbar nach der √Ñnderung in eine Datei schreiben, m√ºssen Sie die gesamte Textdatei √ºbertragen und JEDE √Ñnderung schreiben.  Das ist schrecklich in Bezug auf die Leistung. <br><br>  Also schreibe ich zuerst alle √Ñnderungen, die an editBuffer vorgenommen werden m√ºssen, mit der addEditBuffer-Methode (die auch die Position der √Ñnderungen im Fragmentraum berechnet).  Bevor ich sie in eine Datei schreibe, sortiere ich die √Ñnderungen in der Reihenfolge der Fragmente, zu denen sie geh√∂ren, nach ihrem Speicherort in der Datei. <br><br>  Das Schreiben von √Ñnderungen in eine Datei besteht aus einer Datei√ºbertragung, dem Laden jeder Zeile (d. H. Eines Fragments), f√ºr die √Ñnderungen an editBuffer vorgenommen wurden, dem Vornehmen aller √Ñnderungen und dem Schreiben in eine tempor√§re Datei, bis editBuffer leer wird.  Dies geschieht in der Funktion <code>evaluateBlueprint()</code> , die schnell genug ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> World::evaluateBlueprint(Blueprint &amp;_blueprint){ <span class="hljs-comment"><span class="hljs-comment">//Check if the editBuffer isn't empty! if(_blueprint.editBuffer.empty()){ return false; } //Sort the editBuffer std::sort(_blueprint.editBuffer.begin(), _blueprint.editBuffer.end(), std::greater&lt;bufferObject&gt;()); //Open the File boost::filesystem::path data_dir(boost::filesystem::current_path()); data_dir /= "save"; data_dir /= saveFile; //Load File and Write File std::ifstream in((data_dir/"world.region").string()); std::ofstream out((data_dir/"world.region.temp").string(), std::ofstream::app); //Chunk for Saving Data Chunk _chunk; int n_chunks = 0; //Loop over the Guy while(n_chunks &lt; dim.x*dim.y*dim.z){ if(in.eof()){ return false; } //Archive Serializers boost::archive::text_oarchive oa(out); boost::archive::text_iarchive ia(in); //Load the Chunk ia &gt;&gt; _chunk; //Overwrite relevant portions while(!_blueprint.editBuffer.empty() &amp;&amp; glm::all(glm::equal(_chunk.pos, _blueprint.editBuffer.back().cpos))){ //Change the Guy _chunk.setPosition(glm::mod(_blueprint.editBuffer.back().pos, glm::vec3(chunkSize)), _blueprint.editBuffer.back().type); _blueprint.editBuffer.pop_back(); } //Write the chunk back oa &lt;&lt; _chunk; n_chunks++; } //Close the fstream and ifstream in.close(); out.close(); //Delete the first file, rename the temp file boost::filesystem::remove_all((data_dir/"world.region").string()); boost::filesystem::rename((data_dir/"world.region.temp").string(),(data_dir/"world.region").string()); //Success! return true; }</span></span></code> </pre> <br>  Die Blueprint-Klasse enth√§lt editBuffer sowie verschiedene Methoden, mit denen Sie editBuffer f√ºr bestimmte Objekte (B√§ume, Kakteen, H√ºtten usw.) erstellen k√∂nnen.  Dann kann die Blaupause in die Position konvertiert werden, an der Sie das Objekt platzieren m√∂chten, und es dann einfach in die Erinnerung der Welt schreiben. <br><br>  Eine der gr√∂√üten Schwierigkeiten bei der Arbeit mit Fragmenten besteht darin, dass sich √Ñnderungen in mehreren Bl√∂cken zwischen den Grenzen von Fragmenten als monotoner Prozess mit viel arithmetischem Modulo herausstellen und die √Ñnderungen in mehrere Teile aufteilen k√∂nnen.  Dies ist das Hauptproblem, mit dem die Blueprint-Klasse hervorragend umgeht. <br><br>  Ich benutze es aktiv in der Phase der Weltgeneration, um den ‚ÄûEngpass‚Äú beim Schreiben von √Ñnderungen in eine Datei zu erweitern. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::generate(){ <span class="hljs-comment"><span class="hljs-comment">//Create an editBuffer that contains a flat surface! blueprint.flatSurface(dim.x*chunkSize, dim.z*chunkSize); //Write the current blueprint to the world file. evaluateBlueprint(blueprint); //Add a tree Blueprint _tree; evaluateBlueprint(_tree.translate(glm::vec3(x, y, z))); }</span></span></code> </pre> <br>  Die Weltklasse speichert ihren eigenen Entwurf von √Ñnderungen, die an der Welt vorgenommen wurden, sodass beim Aufruf von bufferChunks () alle √Ñnderungen in einem Durchgang auf die Festplatte geschrieben und dann aus dem virtuellen Speicher gel√∂scht werden. <br><br><h3>  Rendern </h3><br>  Der Renderer in seiner Struktur ist nicht sehr kompliziert, erfordert jedoch Kenntnisse in OpenGL, um verstanden zu werden.  Nicht alle Teile sind interessant, haupts√§chlich OpenGL-Wrapper.  Ich habe einige Zeit mit Visualisierung experimentiert, um das zu bekommen, was mir gef√§llt. <br><br>  Da die Simulation nicht von der ersten Person stammt, habe ich die orthografische Projektion gew√§hlt.  Es k√∂nnte im Pseudo-3D-Format implementiert werden (d. H. Um Kacheln vorab zu projizieren und sie in einem Software-Renderer zu √ºberlagern), aber es kam mir albern vor.  Ich bin froh, dass ich auf OpenGL umgestiegen bin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61e/923/40e/61e92340e2801dc8f6dd63b54badc438.png"></div><br>  Die Basisklasse f√ºr das Rendern hei√üt Ansicht und enth√§lt die meisten wichtigen Variablen, die die Simulationsvisualisierung steuern: <br><br><ul><li>  Bildschirmgr√∂√üe und Schattentextur </li><li>  Shader-Objekte, Kamera, Matrix usw. Zoomfaktoren </li><li>  Boolesche Werte f√ºr fast alle Rendererfunktionen <ul><li>  Men√º, Nebel, Sch√§rfentiefe, Kornstruktur usw. </li></ul></li><li>  Farben f√ºr Beleuchtung, Nebel, Himmel, Fensterauswahl usw. </li></ul><br>  Dar√ºber hinaus gibt es mehrere Hilfsklassen, die das Rendern und Umbrechen von OpenGL selbst durchf√ºhren! <br><br><ul><li>  Klassen-Shader <ul><li>  L√§dt, kompiliert, kompiliert und verwendet GLSL-Shader </li></ul></li><li>  Modellklasse <ul><li>  Enth√§lt VAO-Datenfragmente (Vertex Arrays Object) zum Rendern, die Funktion zum Erstellen von Netzen und die Rendermethode. </li></ul></li><li>  Klassenwerbetafel <ul><li>  Enth√§lt das FBO (FrameBuffer Object), in das gerendert werden soll - n√ºtzlich zum Erstellen von Nachbearbeitungs- und Shadowing-Effekten. </li></ul></li><li>  Sprite-Klasse <ul><li>  Zeichnet ein Viereck, das relativ zur Kamera ausgerichtet ist und aus einer Texturdatei (f√ºr Bots und Objekte) geladen wird.  Kann auch mit Animationen umgehen! </li></ul></li><li>  Schnittstellenklasse <ul><li>  Mit ImGUI arbeiten </li></ul></li><li>  Audioklasse <ul><li>  Sehr rudiment√§re Soundunterst√ºtzung (wenn Sie den Motor kompilieren, dr√ºcken Sie "M") </li></ul></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/0f3/ef6/6e50f3ef66d7d71dd5ae76b94b3c168a.png"></div><br>  <i>Hohe Sch√§rfentiefe (DOF).</i>  <i>Bei gro√üen Rendering-Entfernungen kann es langsam sein, aber ich habe das alles auf meinem Laptop gemacht.</i>  <i>Vielleicht sind auf einem guten Computer die Bremsen unsichtbar.</i>  <i>Ich verstehe, dass es meine Augen belastet und dies nur zum Spa√ü getan hat.</i> <br><br>  Das Bild oben zeigt einige Parameter, die w√§hrend der Manipulation ge√§ndert werden k√∂nnen.  Ich habe auch das Umschalten in den Vollbildmodus implementiert.  Das Bild zeigt ein Beispiel eines Bot-Sprites, das als strukturiertes Viereck in Richtung der Kamera gerendert wurde.  Die H√§user und Kakteen auf dem Bild sind mit Blaupausen gebaut. <br><br><h4>  Erstellen von Fragmentnetzen </h4><br>  Anfangs habe ich die naive Version des Erstellens von Netzen verwendet: Ich habe einfach einen W√ºrfel erstellt und Scheitelpunkte verworfen, die den leeren Raum nicht ber√ºhrten.  Diese L√∂sung war jedoch langsam, und beim Laden neuer Fragmente stellte sich heraus, dass die Erstellung von Netzen noch engere ‚ÄûEngp√§sse‚Äú aufwies als der Zugriff auf die Datei. <br><br>  Das Hauptproblem war die effiziente Erstellung von Fragmenten gerenderter VBOs, aber ich konnte in C ++ meine eigene Version von "Greedy Meshing" (Greedy Meshing) implementieren, die mit OpenGL kompatibel ist (ohne seltsame Strukturen mit Schleifen).  Sie k√∂nnen meinen Code mit gutem Gewissen verwenden. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Model::fromChunkGreedy(Chunk chunk){ <span class="hljs-comment"><span class="hljs-comment">//... (this is part of the model class - find on github!) }</span></span></code> </pre> <br>  Im Allgemeinen reduzierte der √úbergang zu gierigem Ineinandergreifen die Anzahl der gezeichneten Vierecke um durchschnittlich 60%.  Nach weiteren geringf√ºgigen Optimierungen (VBO-Indizierung) wurde die Anzahl um weitere 1/3 reduziert (von 6 Eckpunkten bis zur Kante auf 4 Eckpunkte). <br><br>  Beim Rendern einer Szene mit 5x1x5-Fragmenten in einem nicht maximierten Fenster erhalte ich durchschnittlich 140 FPS (bei deaktiviertem VSYNC). <br><br>  Obwohl ich mit diesem Ergebnis sehr zufrieden bin, m√∂chte ich dennoch ein System zum Rendern nicht-kubischer Modelle aus Weltdaten entwickeln.  Es ist nicht so einfach, sich in gieriges Meshing zu integrieren, daher lohnt es sich, dar√ºber nachzudenken. <br><br><h4>  Shader- und Voxel-Hervorhebung </h4><br>  Die Implementierung von GLSL-Shadern ist aufgrund der Komplexit√§t des Debuggens auf der GPU einer der interessantesten und gleichzeitig nervigsten Teile beim Schreiben der Engine.  Ich bin kein GLSL-Spezialist, daher musste ich unterwegs viel lernen. <br><br>  Die Effekte, die ich implementiert habe, verwenden aktiv FBO und Texturabtastung (z. B. Unsch√§rfe, Abschattung und Verwendung von Tiefeninformationen). <br><br>  Ich mag das aktuelle Beleuchtungsmodell immer noch nicht, weil es die ‚ÄûDunkelheit‚Äú nicht sehr gut handhabt.  Ich hoffe, dass dies in Zukunft behoben wird, wenn ich an dem Zyklus der Ver√§nderung von Tag und Nacht arbeite. <br><br>  Ich habe auch eine einfache Voxelauswahlfunktion unter Verwendung des modifizierten Bresenham-Algorithmus implementiert (dies ist ein weiterer Vorteil der Verwendung von Voxeln).  Es ist n√ºtzlich, um r√§umliche Informationen w√§hrend der Simulation zu erhalten.  Meine Implementierung funktioniert nur f√ºr orthografische Projektionen, aber Sie k√∂nnen sie verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/020/f2c/c60020f2cd1b4507152fdee4ef16e0ea.png"></div><br>  <i>"Hervorgehobener" K√ºrbis.</i> <br><br><h3>  Spielklassen </h3><br>  Es wurden mehrere Hilfsklassen f√ºr die Verarbeitung von Eingaben, das Debuggen von Nachrichten sowie eine separate Item-Klasse mit grundlegenden Funktionen (die weiter ausgebaut werden) erstellt. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eventHandler</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-comment"><span class="hljs-comment">/* This class handles user input, creates an appropriate stack of activated events and handles them so that user inputs have continuous effect. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Queued Inputs std::deque&lt;SDL_Event*&gt; inputs; //General Key Inputs std::deque&lt;SDL_Event*&gt; scroll; //General Key Inputs std::deque&lt;SDL_Event*&gt; rotate; //Rotate Key Inputs SDL_Event* mouse; //Whatever the mouse is doing at a moment SDL_Event* windowevent; //Whatever the mouse is doing at a moment bool _window; bool move = false; bool click = false; bool fullscreen = false; //Take inputs and add them to stack void input(SDL_Event *e, bool &amp;quit, bool &amp;paused); //Handle the existing stack every tick void update(World &amp;world, Player &amp;player, Population &amp;population, View &amp;view, Audio &amp;audio); //Handle Individual Types of Events void handlePlayerMove(World &amp;world, Player &amp;player, View &amp;view, int a); void handleCameraMove(World &amp;world, View &amp;view); };</span></span></code> </pre> <br>  Mein Event-Handler ist h√§sslich, aber funktional.  Ich nehme gerne Empfehlungen zur Verbesserung an, insbesondere zur Verwendung von SDL Poll Event. <br><br><h2>  Neueste Notizen </h2><br>  Die Engine selbst ist nur ein System, in das ich meine Task-Bots einsetze (ich werde im n√§chsten Beitrag ausf√ºhrlich darauf eingehen).  Aber wenn Sie meine Methoden interessant fanden und mehr wissen m√∂chten, schreiben Sie mir. <br><br>  Dann habe ich das Task-Bot-System (das eigentliche Herz dieses Projekts) in die 3D-Welt portiert und seine Funktionen erheblich erweitert, aber dazu sp√§ter mehr (der Code wurde jedoch bereits online gestellt)! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474414/">https://habr.com/ru/post/de474414/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474400/index.html">Mythen √ºber die Verf√ºgbarkeit von Farbkontrasten</a></li>
<li><a href="../de474402/index.html">API-Handbuch f√ºr Vavr-Sammlungen</a></li>
<li><a href="../de474404/index.html">Analyse der gel√∂sten Probleme aus der Programmiermeisterschaft von Yandex (Frontend-Entwicklung) 2019</a></li>
<li><a href="../de474406/index.html">BlueKeeps erster Auftritt in freier Wildbahn wurde aufgezeichnet</a></li>
<li><a href="../de474408/index.html">Revolution oder Evolution des Seitenobjektmodells?</a></li>
<li><a href="../de474418/index.html">DEFCON-Konferenz 27. Profitieren Sie von Hacker-Produkten f√ºr macOS. Teil 1</a></li>
<li><a href="../de474420/index.html">Thermostatbildung: wie es passiert ist</a></li>
<li><a href="../de474422/index.html">Spannende Open Source-Plattformen f√ºr die Entwicklung mobiler Anwendungen</a></li>
<li><a href="../de474424/index.html">Blended Training - was ist das und wie funktioniert es?</a></li>
<li><a href="../de474426/index.html">Die Zeichentrickserie "Mathematical Circle"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>