<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏻 🌟 👏🏻 Wir schreiben unseren eigenen Voxelmotor 🐯 👩🏼‍🍳 🤶🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis: Der vollständige Quellcode für dieses Projekt ist hier verfügbar: [ Quelle ]. 

 Wenn dem Projekt, an dem ich arbeite, die Puste ausgeht, füg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben unseren eigenen Voxelmotor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474414/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a53/e5f/dea/a53e5fdeab8992f2b647feb66ccf126b.png" alt="Bild"></div><br>  <em><strong>Hinweis: Der</strong> vollständige Quellcode für dieses Projekt ist hier verfügbar: [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> ].</em> <br><br>  Wenn dem Projekt, an dem ich arbeite, die Puste ausgeht, füge ich neue Visualisierungen hinzu, die mich motivieren, weiterzumachen. <br><br>  Nach der Veröffentlichung des ursprünglichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Task-Bot-</a> Konzepts [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> in Habré] fühlte ich mich durch den zweidimensionalen Raum, in dem ich arbeitete, eingeschränkt.  Es schien, dass es die Möglichkeiten für das aufkommende Verhalten von Bots zurückhielt. <br><br>  Frühere erfolglose Versuche, modernes OpenGL zu lernen, haben mir eine mentale Barriere auferlegt, aber Ende Juli habe ich es irgendwie endlich durchbrochen.  Heute, Ende Oktober, habe ich bereits ein ziemlich sicheres Verständnis für Konzepte, daher habe ich meine eigene einfache Voxel-Engine veröffentlicht, die die Umgebung für das Leben und den Wohlstand meiner Task-Bots sein wird. <br><br>  Ich habe beschlossen, meine eigene Engine zu erstellen, da ich die volle Kontrolle über die Grafiken brauchte.  außerdem wollte ich mich testen.  In gewisser Weise habe ich ein Fahrrad erfunden, aber dieser Prozess hat mir sehr gut gefallen! <br><br>  Das ultimative Ziel des gesamten Projekts war eine vollständige Simulation des Ökosystems, bei der Bots in der Rolle von Agenten die Umgebung manipulieren und mit ihr interagieren. <br><br>  Da sich die Engine bereits einiges weiterentwickelt hat und ich wieder mit dem Programmieren von Bots fortfahren werde, habe ich beschlossen, einen Beitrag über die Engine, ihre Funktionen und ihre Implementierung zu schreiben, um mich in Zukunft auf übergeordnete Aufgaben zu konzentrieren. <br><a name="habracut"></a><br><h2>  Motorkonzept </h2><br>  Die Engine ist in C ++ vollständig von Grund auf neu geschrieben (mit einigen Ausnahmen, z. B. dem Finden eines Pfads).  Ich verwende SDL2 zum Rendern von Kontext- und Verarbeitungseingaben, OpenGL zum Rendern einer 3D-Szene und DearImgui zum Steuern der Simulation. <br><br>  Ich habe mich hauptsächlich deshalb für Voxel entschieden, weil ich mit einem Raster arbeiten wollte, das viele Vorteile hat: <br><br><ul><li>  Das Erstellen von Maschen zum Rendern ist mir gut bekannt. </li><li>  Die weltweiten Datenspeicherfunktionen sind vielfältiger und verständlicher. </li><li>  Ich habe bereits Systeme zur Erzeugung von Gelände- und Klimasimulationen basierend auf Maschen erstellt. </li><li>  Die Aufgaben von Bots im Raster sind einfacher zu parametrisieren. </li></ul><br>  Die Engine besteht aus einem Weltdatensystem, einem Rendering-System und mehreren Hilfsklassen (z. B. für die Ton- und Eingabeverarbeitung). <br><br>  In dem Artikel werde ich auf die aktuelle Liste der Funktionen eingehen und die komplexeren Subsysteme genauer betrachten. <br><br><h3>  Weltklasse </h3><br>  Die Weltklasse dient als Basisklasse zum Speichern aller Informationen der Welt.  Es übernimmt das Generieren, Laden und Speichern von Blockdaten. <br><br>  Die Blockdaten werden in Blöcken konstanter Größe (16 ^ 3) gespeichert, und die Welt speichert den in den virtuellen Speicher geladenen Fragmentvektor.  In großen Welten ist es praktisch notwendig, sich nur an einen bestimmten Teil der Welt zu erinnern, weshalb ich diesen Ansatz gewählt habe. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">World</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: World(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> _saveFile){ saveFile = _saveFile; loadWorld(); } <span class="hljs-comment"><span class="hljs-comment">//Data Storage std::vector&lt;Chunk&gt; chunks; //Loaded Chunks std::stack&lt;int&gt; updateModels; //Models to be re-meshed void bufferChunks(View view); //Generation void generate(); Blueprint blueprint; bool evaluateBlueprint(Blueprint &amp;_blueprint); //File IO Management std::string saveFile; bool loadWorld(); bool saveWorld(); //other... int SEED = 100; int chunkSize = 16; int tickLength = 1; glm::vec3 dim = glm::vec3(20, 5, 20); //...</span></span></code> </pre> <br>  Fragmente speichern Blockdaten sowie einige andere Metadaten in einem flachen Array.  Anfangs habe ich meinen eigenen spärlichen Octree-Baum zum Speichern von Fragmenten implementiert, aber es stellte sich heraus, dass die zufällige Zugriffszeit zu hoch ist, um Netze zu erstellen.  Und obwohl ein flaches Array aus Sicht des Speichers nicht optimal ist, bietet es die Möglichkeit, sehr schnell Netze und Manipulationen mit Blöcken zu erstellen sowie auf den Suchpfad zuzugreifen. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Chunk</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Position information and size information glm::vec3 pos; int size; BiomeType biome; //Data Storage Member int data[16*16*16] = {0}; bool refreshModel = false; //Get the Flat-Array Index int getIndex(glm::vec3 _p); void setPosition(glm::vec3 _p, BlockType _type); BlockType getPosition(glm::vec3 _p); glm::vec4 getColorByID(BlockType _type); };</span></span></code> </pre> <br>  Wenn ich jemals das Speichern und Laden von Fragmenten mit mehreren Threads implementiere, kann das Konvertieren eines flachen Arrays in einen spärlichen Octree-Baum und umgekehrt eine vollständig mögliche Option zum Speichern von Speicher sein.  Es gibt noch Raum für Optimierungen! <br><br>  Meine Implementierung des spärlichen Octree-Baums ist im Code gespeichert, sodass Sie ihn sicher verwenden können. <br><br><h4>  Fragmentspeicherung und Speicherbehandlung </h4><br>  Fragmente sind nur sichtbar, wenn sie sich innerhalb des Renderabstands zur aktuellen Kameraposition befinden.  Dies bedeutet, dass Sie beim Bewegen der Kamera Fragmente in den Netzen dynamisch laden und zusammensetzen müssen. <br><br>  Fragmente werden mithilfe der Boost-Bibliothek serialisiert, und Weltdaten werden als einfache Textdatei gespeichert, in der jedes Fragment eine Zeile der Datei ist.  Sie werden in einer bestimmten Reihenfolge generiert, damit sie in einer Weltdatei "bestellt" werden können.  Dies ist wichtig für weitere Optimierungen. <br><br>  Im Falle einer großen Welt besteht der Hauptengpass darin, die Weltdatei zu lesen und Fragmente zu laden / schreiben.  Im Idealfall müssen wir nur die Weltdatei herunterladen und übertragen. <br><br>  Zu diesem <code>World::bufferChunks()</code> entfernt die <code>World::bufferChunks()</code> -Methode Fragmente, die sich im virtuellen Speicher befinden, aber unsichtbar sind, und lädt intelligent neue Fragmente aus der World-Datei. <br><br>  Mit Intelligenz ist gemeint, dass er einfach entscheidet, welche neuen Fragmente geladen werden sollen, sie nach ihrer Position in der Sicherungsdatei sortiert und dann einen Durchgang ausführt.  Alles ist sehr einfach. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::bufferChunks(View view){ <span class="hljs-comment"><span class="hljs-comment">//Load / Reload all Visible Chunks evaluateBlueprint(blueprint); //Chunks that should be loaded glm::vec3 a = glm::floor(view.viewPos/glm::vec3(chunkSize))-view.renderDistance; glm::vec3 b = glm::floor(view.viewPos/glm::vec3(chunkSize))+view.renderDistance; //Can't exceed a certain size a = glm::clamp(a, glm::vec3(0), dim-glm::vec3(1)); b = glm::clamp(b, glm::vec3(0), dim-glm::vec3(1)); //Chunks that need to be removed / loaded std::stack&lt;int&gt; remove; std::vector&lt;glm::vec3&gt; load; //Construct the Vector of chunks we should load for(int i = ax; i &lt;= bx; i ++){ for(int j = ay; j &lt;= by; j ++){ for(int k = az; k &lt;= bz; k ++){ //Add the vector that we should be loading load.push_back(glm::vec3(i, j, k)); } } } //Loop over all existing chunks for(unsigned int i = 0; i &lt; chunks.size(); i++){ //Check if any of these chunks are outside of the limits if(glm::any(glm::lessThan(chunks[i].pos, a)) || glm::any(glm::greaterThan(chunks[i].pos, b))){ //Add the chunk to the erase pile remove.push(i); } //Don't reload chunks that remain for(unsigned int j = 0; j &lt; load.size(); j++){ if(glm::all(glm::equal(load[j], chunks[i].pos))){ //Remove the element from load load.erase(load.begin()+j); } } //Flags for the Viewclass to use later updateModels = remove; //Loop over the erase pile, delete the relevant chunks. while(!remove.empty()){ chunks.erase(chunks.begin()+remove.top()); remove.pop(); } //Check if we want to load any guys if(!load.empty()){ //Sort the loading vector, for single file-pass std::sort(load.begin(), load.end(), [](const glm::vec3&amp; a, const glm::vec3&amp; b) { if(ax &gt; bx) return true; if(ax &lt; bx) return false; if(ay &gt; by) return true; if(ay &lt; by) return false; if(az &gt; bz) return true; if(az &lt; bz) return false; return false; }); boost::filesystem::path data_dir( boost::filesystem::current_path() ); data_dir /= "save"; data_dir /= saveFile; std::ifstream in((data_dir/"world.region").string()); Chunk _chunk; int n = 0; while(!load.empty()){ //Skip Lines (this is dumb) while(n &lt; load.back().x*dim.z*dim.y+load.back().y*dim.z+load.back().z){ in.ignore(1000000,'\n'); n++; } //Load the Chunk { boost::archive::text_iarchive ia(in); ia &gt;&gt; _chunk; chunks.push_back(_chunk); load.pop_back(); } } in.close(); } }</span></span></code> </pre> <br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterstützt kein HTML5-Video. <source src="http://weigert.vsos.ethz.ch/wp-content/uploads/2019/10/chunkload.mp4" type="video/mp4"></video></div></div></div><br>  <i>Ein Beispiel für das Laden von Fragmenten mit geringem Renderabstand.</i>  <i>Bildschirmverzerrungsartefakte werden durch Videoaufzeichnungssoftware verursacht.</i>  <i>Manchmal treten bei Downloads merkliche Spitzen auf, die hauptsächlich durch Vernetzung verursacht werden</i> <br><br>  Außerdem habe ich ein Flag gesetzt, das angibt, dass der Renderer das Netz des geladenen Fragments neu erstellen soll. <br><br><h4>  Blueprint Class und editBuffer </h4><br>  editBuffer ist ein sortierbarer bufferObjects-Container, der Informationen zum Bearbeiten im Weltraum und im Fragmentraum enthält. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//EditBuffer Object Struct struct bufferObject { glm::vec3 pos; glm::vec3 cpos; BlockType type; }; //Edit Buffer! std::vector&lt;bufferObject&gt; editBuffer;</span></span></code> </pre> <br>  Wenn Sie Änderungen an der Welt vornehmen und diese unmittelbar nach der Änderung in eine Datei schreiben, müssen Sie die gesamte Textdatei übertragen und JEDE Änderung schreiben.  Das ist schrecklich in Bezug auf die Leistung. <br><br>  Also schreibe ich zuerst alle Änderungen, die an editBuffer vorgenommen werden müssen, mit der addEditBuffer-Methode (die auch die Position der Änderungen im Fragmentraum berechnet).  Bevor ich sie in eine Datei schreibe, sortiere ich die Änderungen in der Reihenfolge der Fragmente, zu denen sie gehören, nach ihrem Speicherort in der Datei. <br><br>  Das Schreiben von Änderungen in eine Datei besteht aus einer Dateiübertragung, dem Laden jeder Zeile (d. H. Eines Fragments), für die Änderungen an editBuffer vorgenommen wurden, dem Vornehmen aller Änderungen und dem Schreiben in eine temporäre Datei, bis editBuffer leer wird.  Dies geschieht in der Funktion <code>evaluateBlueprint()</code> , die schnell genug ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> World::evaluateBlueprint(Blueprint &amp;_blueprint){ <span class="hljs-comment"><span class="hljs-comment">//Check if the editBuffer isn't empty! if(_blueprint.editBuffer.empty()){ return false; } //Sort the editBuffer std::sort(_blueprint.editBuffer.begin(), _blueprint.editBuffer.end(), std::greater&lt;bufferObject&gt;()); //Open the File boost::filesystem::path data_dir(boost::filesystem::current_path()); data_dir /= "save"; data_dir /= saveFile; //Load File and Write File std::ifstream in((data_dir/"world.region").string()); std::ofstream out((data_dir/"world.region.temp").string(), std::ofstream::app); //Chunk for Saving Data Chunk _chunk; int n_chunks = 0; //Loop over the Guy while(n_chunks &lt; dim.x*dim.y*dim.z){ if(in.eof()){ return false; } //Archive Serializers boost::archive::text_oarchive oa(out); boost::archive::text_iarchive ia(in); //Load the Chunk ia &gt;&gt; _chunk; //Overwrite relevant portions while(!_blueprint.editBuffer.empty() &amp;&amp; glm::all(glm::equal(_chunk.pos, _blueprint.editBuffer.back().cpos))){ //Change the Guy _chunk.setPosition(glm::mod(_blueprint.editBuffer.back().pos, glm::vec3(chunkSize)), _blueprint.editBuffer.back().type); _blueprint.editBuffer.pop_back(); } //Write the chunk back oa &lt;&lt; _chunk; n_chunks++; } //Close the fstream and ifstream in.close(); out.close(); //Delete the first file, rename the temp file boost::filesystem::remove_all((data_dir/"world.region").string()); boost::filesystem::rename((data_dir/"world.region.temp").string(),(data_dir/"world.region").string()); //Success! return true; }</span></span></code> </pre> <br>  Die Blueprint-Klasse enthält editBuffer sowie verschiedene Methoden, mit denen Sie editBuffer für bestimmte Objekte (Bäume, Kakteen, Hütten usw.) erstellen können.  Dann kann die Blaupause in die Position konvertiert werden, an der Sie das Objekt platzieren möchten, und es dann einfach in die Erinnerung der Welt schreiben. <br><br>  Eine der größten Schwierigkeiten bei der Arbeit mit Fragmenten besteht darin, dass sich Änderungen in mehreren Blöcken zwischen den Grenzen von Fragmenten als monotoner Prozess mit viel arithmetischem Modulo herausstellen und die Änderungen in mehrere Teile aufteilen können.  Dies ist das Hauptproblem, mit dem die Blueprint-Klasse hervorragend umgeht. <br><br>  Ich benutze es aktiv in der Phase der Weltgeneration, um den „Engpass“ beim Schreiben von Änderungen in eine Datei zu erweitern. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::generate(){ <span class="hljs-comment"><span class="hljs-comment">//Create an editBuffer that contains a flat surface! blueprint.flatSurface(dim.x*chunkSize, dim.z*chunkSize); //Write the current blueprint to the world file. evaluateBlueprint(blueprint); //Add a tree Blueprint _tree; evaluateBlueprint(_tree.translate(glm::vec3(x, y, z))); }</span></span></code> </pre> <br>  Die Weltklasse speichert ihren eigenen Entwurf von Änderungen, die an der Welt vorgenommen wurden, sodass beim Aufruf von bufferChunks () alle Änderungen in einem Durchgang auf die Festplatte geschrieben und dann aus dem virtuellen Speicher gelöscht werden. <br><br><h3>  Rendern </h3><br>  Der Renderer in seiner Struktur ist nicht sehr kompliziert, erfordert jedoch Kenntnisse in OpenGL, um verstanden zu werden.  Nicht alle Teile sind interessant, hauptsächlich OpenGL-Wrapper.  Ich habe einige Zeit mit Visualisierung experimentiert, um das zu bekommen, was mir gefällt. <br><br>  Da die Simulation nicht von der ersten Person stammt, habe ich die orthografische Projektion gewählt.  Es könnte im Pseudo-3D-Format implementiert werden (d. H. Um Kacheln vorab zu projizieren und sie in einem Software-Renderer zu überlagern), aber es kam mir albern vor.  Ich bin froh, dass ich auf OpenGL umgestiegen bin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61e/923/40e/61e92340e2801dc8f6dd63b54badc438.png"></div><br>  Die Basisklasse für das Rendern heißt Ansicht und enthält die meisten wichtigen Variablen, die die Simulationsvisualisierung steuern: <br><br><ul><li>  Bildschirmgröße und Schattentextur </li><li>  Shader-Objekte, Kamera, Matrix usw. Zoomfaktoren </li><li>  Boolesche Werte für fast alle Rendererfunktionen <ul><li>  Menü, Nebel, Schärfentiefe, Kornstruktur usw. </li></ul></li><li>  Farben für Beleuchtung, Nebel, Himmel, Fensterauswahl usw. </li></ul><br>  Darüber hinaus gibt es mehrere Hilfsklassen, die das Rendern und Umbrechen von OpenGL selbst durchführen! <br><br><ul><li>  Klassen-Shader <ul><li>  Lädt, kompiliert, kompiliert und verwendet GLSL-Shader </li></ul></li><li>  Modellklasse <ul><li>  Enthält VAO-Datenfragmente (Vertex Arrays Object) zum Rendern, die Funktion zum Erstellen von Netzen und die Rendermethode. </li></ul></li><li>  Klassenwerbetafel <ul><li>  Enthält das FBO (FrameBuffer Object), in das gerendert werden soll - nützlich zum Erstellen von Nachbearbeitungs- und Shadowing-Effekten. </li></ul></li><li>  Sprite-Klasse <ul><li>  Zeichnet ein Viereck, das relativ zur Kamera ausgerichtet ist und aus einer Texturdatei (für Bots und Objekte) geladen wird.  Kann auch mit Animationen umgehen! </li></ul></li><li>  Schnittstellenklasse <ul><li>  Mit ImGUI arbeiten </li></ul></li><li>  Audioklasse <ul><li>  Sehr rudimentäre Soundunterstützung (wenn Sie den Motor kompilieren, drücken Sie "M") </li></ul></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/0f3/ef6/6e50f3ef66d7d71dd5ae76b94b3c168a.png"></div><br>  <i>Hohe Schärfentiefe (DOF).</i>  <i>Bei großen Rendering-Entfernungen kann es langsam sein, aber ich habe das alles auf meinem Laptop gemacht.</i>  <i>Vielleicht sind auf einem guten Computer die Bremsen unsichtbar.</i>  <i>Ich verstehe, dass es meine Augen belastet und dies nur zum Spaß getan hat.</i> <br><br>  Das Bild oben zeigt einige Parameter, die während der Manipulation geändert werden können.  Ich habe auch das Umschalten in den Vollbildmodus implementiert.  Das Bild zeigt ein Beispiel eines Bot-Sprites, das als strukturiertes Viereck in Richtung der Kamera gerendert wurde.  Die Häuser und Kakteen auf dem Bild sind mit Blaupausen gebaut. <br><br><h4>  Erstellen von Fragmentnetzen </h4><br>  Anfangs habe ich die naive Version des Erstellens von Netzen verwendet: Ich habe einfach einen Würfel erstellt und Scheitelpunkte verworfen, die den leeren Raum nicht berührten.  Diese Lösung war jedoch langsam, und beim Laden neuer Fragmente stellte sich heraus, dass die Erstellung von Netzen noch engere „Engpässe“ aufwies als der Zugriff auf die Datei. <br><br>  Das Hauptproblem war die effiziente Erstellung von Fragmenten gerenderter VBOs, aber ich konnte in C ++ meine eigene Version von "Greedy Meshing" (Greedy Meshing) implementieren, die mit OpenGL kompatibel ist (ohne seltsame Strukturen mit Schleifen).  Sie können meinen Code mit gutem Gewissen verwenden. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Model::fromChunkGreedy(Chunk chunk){ <span class="hljs-comment"><span class="hljs-comment">//... (this is part of the model class - find on github!) }</span></span></code> </pre> <br>  Im Allgemeinen reduzierte der Übergang zu gierigem Ineinandergreifen die Anzahl der gezeichneten Vierecke um durchschnittlich 60%.  Nach weiteren geringfügigen Optimierungen (VBO-Indizierung) wurde die Anzahl um weitere 1/3 reduziert (von 6 Eckpunkten bis zur Kante auf 4 Eckpunkte). <br><br>  Beim Rendern einer Szene mit 5x1x5-Fragmenten in einem nicht maximierten Fenster erhalte ich durchschnittlich 140 FPS (bei deaktiviertem VSYNC). <br><br>  Obwohl ich mit diesem Ergebnis sehr zufrieden bin, möchte ich dennoch ein System zum Rendern nicht-kubischer Modelle aus Weltdaten entwickeln.  Es ist nicht so einfach, sich in gieriges Meshing zu integrieren, daher lohnt es sich, darüber nachzudenken. <br><br><h4>  Shader- und Voxel-Hervorhebung </h4><br>  Die Implementierung von GLSL-Shadern ist aufgrund der Komplexität des Debuggens auf der GPU einer der interessantesten und gleichzeitig nervigsten Teile beim Schreiben der Engine.  Ich bin kein GLSL-Spezialist, daher musste ich unterwegs viel lernen. <br><br>  Die Effekte, die ich implementiert habe, verwenden aktiv FBO und Texturabtastung (z. B. Unschärfe, Abschattung und Verwendung von Tiefeninformationen). <br><br>  Ich mag das aktuelle Beleuchtungsmodell immer noch nicht, weil es die „Dunkelheit“ nicht sehr gut handhabt.  Ich hoffe, dass dies in Zukunft behoben wird, wenn ich an dem Zyklus der Veränderung von Tag und Nacht arbeite. <br><br>  Ich habe auch eine einfache Voxelauswahlfunktion unter Verwendung des modifizierten Bresenham-Algorithmus implementiert (dies ist ein weiterer Vorteil der Verwendung von Voxeln).  Es ist nützlich, um räumliche Informationen während der Simulation zu erhalten.  Meine Implementierung funktioniert nur für orthografische Projektionen, aber Sie können sie verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/020/f2c/c60020f2cd1b4507152fdee4ef16e0ea.png"></div><br>  <i>"Hervorgehobener" Kürbis.</i> <br><br><h3>  Spielklassen </h3><br>  Es wurden mehrere Hilfsklassen für die Verarbeitung von Eingaben, das Debuggen von Nachrichten sowie eine separate Item-Klasse mit grundlegenden Funktionen (die weiter ausgebaut werden) erstellt. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eventHandler</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-comment"><span class="hljs-comment">/* This class handles user input, creates an appropriate stack of activated events and handles them so that user inputs have continuous effect. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Queued Inputs std::deque&lt;SDL_Event*&gt; inputs; //General Key Inputs std::deque&lt;SDL_Event*&gt; scroll; //General Key Inputs std::deque&lt;SDL_Event*&gt; rotate; //Rotate Key Inputs SDL_Event* mouse; //Whatever the mouse is doing at a moment SDL_Event* windowevent; //Whatever the mouse is doing at a moment bool _window; bool move = false; bool click = false; bool fullscreen = false; //Take inputs and add them to stack void input(SDL_Event *e, bool &amp;quit, bool &amp;paused); //Handle the existing stack every tick void update(World &amp;world, Player &amp;player, Population &amp;population, View &amp;view, Audio &amp;audio); //Handle Individual Types of Events void handlePlayerMove(World &amp;world, Player &amp;player, View &amp;view, int a); void handleCameraMove(World &amp;world, View &amp;view); };</span></span></code> </pre> <br>  Mein Event-Handler ist hässlich, aber funktional.  Ich nehme gerne Empfehlungen zur Verbesserung an, insbesondere zur Verwendung von SDL Poll Event. <br><br><h2>  Neueste Notizen </h2><br>  Die Engine selbst ist nur ein System, in das ich meine Task-Bots einsetze (ich werde im nächsten Beitrag ausführlich darauf eingehen).  Aber wenn Sie meine Methoden interessant fanden und mehr wissen möchten, schreiben Sie mir. <br><br>  Dann habe ich das Task-Bot-System (das eigentliche Herz dieses Projekts) in die 3D-Welt portiert und seine Funktionen erheblich erweitert, aber dazu später mehr (der Code wurde jedoch bereits online gestellt)! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474414/">https://habr.com/ru/post/de474414/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474400/index.html">Mythen über die Verfügbarkeit von Farbkontrasten</a></li>
<li><a href="../de474402/index.html">API-Handbuch für Vavr-Sammlungen</a></li>
<li><a href="../de474404/index.html">Analyse der gelösten Probleme aus der Programmiermeisterschaft von Yandex (Frontend-Entwicklung) 2019</a></li>
<li><a href="../de474406/index.html">BlueKeeps erster Auftritt in freier Wildbahn wurde aufgezeichnet</a></li>
<li><a href="../de474408/index.html">Revolution oder Evolution des Seitenobjektmodells?</a></li>
<li><a href="../de474418/index.html">DEFCON-Konferenz 27. Profitieren Sie von Hacker-Produkten für macOS. Teil 1</a></li>
<li><a href="../de474420/index.html">Thermostatbildung: wie es passiert ist</a></li>
<li><a href="../de474422/index.html">Spannende Open Source-Plattformen für die Entwicklung mobiler Anwendungen</a></li>
<li><a href="../de474424/index.html">Blended Training - was ist das und wie funktioniert es?</a></li>
<li><a href="../de474426/index.html">Die Zeichentrickserie "Mathematical Circle"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>