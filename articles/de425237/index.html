<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📖 👩🏽‍🤝‍👩🏼 🥜 Zeitmessung mit Nanosekundengenauigkeit ♥️ ❣️ 🎢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor ein paar Monaten kam ein historischer Moment für mich. Standard-Betriebssystem-Tools zum Messen der Zeit reichen für mich nicht mehr aus. Es dauer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zeitmessung mit Nanosekundengenauigkeit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425237/"><img src="https://habrastorage.org/webt/zx/xf/se/zxxfse_sd5ma4wwfy0u6rilcai8.jpeg" alt="Bild"><br><br>  Vor ein paar Monaten kam ein historischer Moment für mich.  Standard-Betriebssystem-Tools zum Messen der Zeit reichen für mich nicht mehr aus.  Es dauerte einige Zeit, um mit Nanosekundengenauigkeit und mit Nanosekunden-Overhead zu messen. <br><br>  Ich beschloss, eine Bibliothek zu schreiben, die dieses Problem lösen würde.  Auf den ersten Blick schien es nichts Besonderes zu geben.  Bei näherer Betrachtung stellte sich jedoch wie immer heraus, dass es viele interessante Probleme gab, die gelöst werden mussten.  In diesem Artikel werde ich über die Probleme sprechen und wie sie gelöst wurden. <br><br>  Da Sie viele verschiedene Arten von Zeit auf einem Computer messen können, werde ich sofort klarstellen, dass wir hier über "Zeit mit Stoppuhr" sprechen werden.  Oder Wanduhrzeit.  Es ist Echtzeit, verstrichene Zeit usw.  Das heißt, eine einfache "menschliche" Zeit, die wir zu Beginn der Aufgabe erkennen und am Ende anhalten. <br><a name="habracut"></a><br><h3>  Mikrosekunde - fast für immer </h3><br>  Entwickler von Hochleistungssystemen haben sich in den letzten Jahren an die Mikrosekunden-Zeitskala gewöhnt.  In Mikrosekunden können Sie Daten von einem NVMe-Laufwerk lesen.  In Mikrosekunden können Daten über das Netzwerk gesendet werden.  Natürlich nicht für jedermann, aber für InifiniBand-Netzwerk - ganz einfach. <br><br>  Gleichzeitig hatte die Mikrosekunde auch eine Struktur.  Ein vollständiger E / A-Stapel besteht aus mehreren Software- und Hardwarekomponenten.  Die von einigen von ihnen eingeführten Verzögerungen liegen im Submikrosekundenbereich. <br><br>  Um Verzögerungen dieser Größenordnung zu messen, reicht die Mikrosekundengenauigkeit nicht mehr aus.  Es ist jedoch nicht nur die Genauigkeit wichtig, sondern auch der Aufwand für die Messzeit.  Der Linux-Systemaufruf clock_gettime () gibt die Zeit mit einer Genauigkeit von Nanosekunden zurück.  Auf einem Computer, der mir direkt zur Verfügung steht (Intel® Xeon® CPU E5-2630 v2 bei 2,60 GHz), wird dieser Anruf in ca. 120 ns abgeschlossen.  Sehr gute Figur.  Außerdem funktioniert clock_gettime () ziemlich vorhersehbar.  Auf diese Weise können Sie den Overhead seines Anrufs berücksichtigen und tatsächlich Messungen mit einer Genauigkeit in der Größenordnung von zehn Nanosekunden durchführen.  Lassen Sie uns jetzt jedoch darauf achten.  Um das Zeitintervall zu messen, müssen Sie zwei solche Anrufe tätigen: am Anfang und am Ende.  Das heißt,  240 ns ausgeben.  Wenn dicht beabstandete Zeitintervalle in der Größenordnung von 1-10 μs gemessen werden, verzerrt in einigen solchen Fällen der Messprozess selbst den beobachteten Prozess erheblich. <br><br>  Ich habe diesen Abschnitt damit begonnen, wie sich der E / A-Stapel in den letzten Jahren beschleunigt hat.  Dies ist neu, aber bei weitem nicht der einzige Grund, die Zeit schnell und genau messen zu wollen.  Ein solches Bedürfnis war schon immer.  Zum Beispiel gab es immer einen Code, den ich um mindestens 1 Taktzyklus des Mikroprozessors beschleunigen wollte.  Oder ein anderes Beispiel aus dem Originalartikel über die sensationelle Spectre-Sicherheitslücke: <br><br><img src="https://habrastorage.org/webt/db/5a/7o/db5a7oldvzrcqfi_ymamg4qzscu.jpeg" alt="Bild"><br><br>  Hier messen die Zeilen 72 bis 74 die Ausführungszeit einer einzelnen Speicherzugriffsoperation.  Specter interessiert sich zwar nicht für Nanosekunden.  Die Zeit kann in "Papageien" gemessen werden.  Wir werden zu den Papageien und Sekunden zurückkehren. <br><br><h3>  Zeitstempelzähler </h3><br>  Der Schlüssel zur schnellen und genauen Zeitmessung ist ein spezieller Mikroprozessorzähler.  Der Wert dieses Zählers wird normalerweise in einem separaten Register gespeichert und ist normalerweise - aber nicht immer - vom Benutzerbereich aus zugänglich.  Auf verschiedenen Architekturen wird der Zähler unterschiedlich genannt: <br><br><ol><li>  x86 Zeitstempelzähler </li><li>  Zeitbasisregister auf PowerPC </li><li>  Intervallzeitzähler auf Itanium </li><li>  usw. </li></ol><br>  Im Folgenden werde ich immer den Namen "Zeitstempelzähler" oder TSC verwenden, obwohl ich in Wirklichkeit jeden solchen Zähler unabhängig von der Architektur im Auge behalten werde. <br><br>  Das Lesen des TSC-Werts ist normalerweise - aber auch nicht immer - mit einer einzigen Anweisung möglich.  Hier ist ein Beispiel für x86.  Genau genommen ist dies keine reine Assembler-Anweisung, sondern der GNU-Inline-Assembler: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eax, edx; __asm__ __volatile__( <span class="hljs-string"><span class="hljs-string">"rdtsc"</span></span> : <span class="hljs-string"><span class="hljs-string">"=a"</span></span> (eax), <span class="hljs-string"><span class="hljs-string">"=d"</span></span> (edx));</code> </pre> <br>  Der Befehl rdtsc platziert zwei 32-Bit-Hälften des TSC-Registers in den Registern eax und edx.  Von diesen können Sie einen einzelnen 64-Bit-Wert "kleben". <br><br>  Ich stelle noch einmal fest: Diese (und ähnliche) Anweisungen können in den meisten Fällen direkt aus dem Benutzerbereich aufgerufen werden.  Keine Systemaufrufe.  Minimaler Overhead. <br><br>  Was muss jetzt getan werden, um die Zeit zu messen? <br><br><ol><li>  Führen Sie eine solche Anweisung zu Beginn des für uns interessanten Zeitintervalls aus.  Zählerwert merken </li><li>  Führen Sie am Ende eine solche Anweisung aus.  Wir glauben, dass der Wert des Zählers von der ersten Anweisung zur zweiten steigen wird.  Warum wird es sonst benötigt?  Denken Sie an den zweiten Wert </li><li>  Wir betrachten den Unterschied zwischen den beiden gespeicherten Werten.  Dies ist unsere Zeit </li></ol><br>  Es sieht einfach aus, aber ... <br><br>  Die nach dem beschriebenen Verfahren gemessene Zeit wird in „Papageien“ ausgedrückt.  Es ist nicht in Sekunden.  Aber manchmal sind Papageien genau das, was Sie brauchen.  Es gibt Situationen, in denen nicht die absoluten Werte der Zeitintervalle wichtig sind, sondern die Beziehung zwischen den verschiedenen Intervallen.  Das obige Spectre-Beispiel zeigt genau diese Situation.  Die Dauer jedes einzelnen Speicherzugriffs spielt keine Rolle.  Es ist nur wichtig, dass Aufrufe an einige Adressen viel schneller ausgeführt werden als an andere (abhängig davon, ob die Daten im Cache oder im Hauptspeicher gespeichert sind). <br><br>  Aber was ist, wenn keine Papageien benötigt werden, sondern Sekunden / Mikrosekunden / Nanosekunden usw.?  Hier lassen sich zwei grundsätzlich unterschiedliche Fälle unterscheiden: <br><br><ol><li>  Aber dann werden Nanosekunden benötigt.  Das heißt, es ist zulässig, zuerst alle erforderlichen Messungen in Papageien durchzuführen und sie zur weiteren Verarbeitung irgendwo zu speichern (z. B. im Speicher).  Und erst nach Abschluss der Messungen werden die gesammelten Papageien langsam in Sekunden umgewandelt </li><li>  Nanosekunden werden "on the fly" benötigt.  Zum Beispiel hat Ihr Messprozess eine Art „Verbraucher“, den Sie nicht kontrollieren und der Zeit im „menschlichen“ Format erwartet </li></ol><br>  Der erste Fall ist einfach, der zweite - erfordert Einfallsreichtum.  Die Konvertierung sollte so effektiv wie möglich sein.  Wenn es viele Ressourcen verbraucht, kann es den Messprozess stark verzerren.  Wir werden im Folgenden über eine effektive Konvertierung sprechen.  Hier haben wir dieses Problem bisher identifiziert und gehen zu einem anderen über. <br><br>  Zeitstempelzähler sind nicht so einfach, wie wir es gerne hätten.  Auf einigen Architekturen: <br><br><ol><li>  Es kann nicht garantiert werden, dass die TSC mit hoher Frequenz aktualisiert wird.  Wenn die TSC beispielsweise einmal pro Mikrosekunde aktualisiert wird, ist es nicht möglich, Nanosekunden damit zu reparieren. </li><li>  Die Häufigkeit, mit der die TSC aktualisiert wird, kann im Laufe der Zeit variieren </li><li>  Auf verschiedenen im System vorhandenen CPUs können TSCs mit unterschiedlichen Frequenzen aktualisiert werden </li><li>  Es kann zu einer Verschiebung zwischen TSCs kommen, die auf verschiedenen CPUs ticken </li></ol><br>  Hier ist ein Beispiel, das das letzte Problem veranschaulicht.  Angenommen, wir haben ein System mit zwei CPUs: CPU1 und CPU2.  Angenommen, die TSC auf der ersten CPU liegt um die Anzahl der Ticks hinter der zweiten, was 5 Sekunden entspricht.  Angenommen, im System wird ein Stream gestartet, der die Zeit der Berechnungen misst, was er selbst tut.  Dazu liest der Stream zuerst den TSC-Wert, führt dann die Berechnung durch und liest dann den zweiten TSC-Wert.  Wenn ein Thread während seiner gesamten Lebensdauer nur auf einer CPU verbleibt - auf einer beliebigen -, gibt es keine Probleme.  Was aber, wenn der Thread auf CPU1 gestartet, dort den ersten TSC-Wert gemessen und dann in der Mitte der Berechnungen vom Betriebssystem auf CPU2 verschoben wurde, wo er den zweiten TSC-Wert las?  In diesem Fall erscheinen die Berechnungen 5 Sekunden länger als sie tatsächlich sind. <br><br>  Aufgrund der oben aufgeführten Probleme kann TSC auf einigen Systemen nicht als zuverlässige Zeitquelle dienen.  Auf anderen Systemen, die unter denselben Problemen "leiden", kann TSC jedoch weiterhin verwendet werden.  Möglich wird dies durch besondere architektonische Merkmale: <br><br><ol><li>  Das Gerät kann jedes Mal einen speziellen Interrupt erzeugen, wenn sich die Häufigkeit ändert, mit der die TSC aktualisiert wird.  Gleichzeitig bietet das Gerät die Möglichkeit, die aktuelle Frequenz herauszufinden.  Alternativ kann die TSC-Aktualisierungsrate unter die Kontrolle des Betriebssystems gestellt werden (siehe „Power ISA Version 2.06 Revision B, Buch II, Kapitel 5“). </li><li>  Zusammen mit dem TSC-Wert kann das Gerät auch die ID der CPU bereitstellen, auf der dieser Wert gelesen wird (siehe Intel RDTSCP-Anweisung, „Entwicklerhandbuch für Intel 64- und IA-32-Architekturen-Software“, Band 2). </li><li>  Auf einigen Systemen können Sie den TSC-Wert für jede CPU programmgesteuert anpassen (siehe Intel WRMSR-Anweisung und Register IA32_TIME_STAMP_COUNTER, „Entwicklerhandbuch für Intel 64- und IA-32-Architekturen-Software“, Band 3). </li></ol><br>  Im Allgemeinen ist das Thema, wie Zeitmesser auf verschiedenen Architekturen implementiert werden, faszinierend und umfangreich.  Wenn Sie Zeit und Interesse haben, empfehle ich Tauchen.  Unter anderem erfahren Sie beispielsweise, dass Sie mit einigen Systemen programmgesteuert bestimmen können, ob TSC als zuverlässige Zeitquelle dienen kann. <br><br>  Es gibt also viele architektonische Implementierungen von TSC, von denen jede ihre eigenen Eigenschaften hat.  Es ist jedoch interessant, dass sich in diesem ganzen Zoo ein allgemeiner Trend etabliert hat.  <b>Moderne Hardware und Betriebssysteme bemühen sich darum, dass</b> : <br><br><ol><li>  TSC tickt auf jeder CPU im System mit der gleichen Frequenz </li><li>  Diese Frequenz ändert sich zeitlich nicht </li><li>  Es gibt keine Verschiebung zwischen TSCs, die auf verschiedenen CPUs ticken </li></ol><br>  Beim Entwerfen meiner Bibliothek habe ich mich entschieden, von dieser Prämisse auszugehen und nicht von der Vinaigrette der Hardware-Implementierungen. <br><br><h3>  Die Bibliothek </h3><br>  Ich habe nicht angefangen, auf Hardware-Chips einer Reihe verschiedener Architekturen zu legen.  Stattdessen entschied ich mich für eine trendorientierte Bibliothek.  Sie hat einen rein empirischen Fokus: <br><br><ol><li>  Damit können Sie die Zuverlässigkeit von TSC als Zeitquelle experimentell überprüfen </li><li>  Außerdem können Sie die Parameter experimentell berechnen, die für die schnelle Umwandlung von Zecken in Nanosekunden erforderlich sind </li><li>  Natürlich bietet die Bibliothek praktische Schnittstellen zum Lesen von TSC und zum Konvertieren von Zecken in Nanosekunden "on the fly". </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Den Bibliothekscode finden Sie hier.</a>  Es wird nur unter Linux kompiliert und ausgeführt. <br><br>  Im Code sehen Sie die Details der Implementierung aller Methoden, die später erläutert werden. <br><br><h3>  TSC-Zuverlässigkeitsbewertung </h3><br>  Die Bibliothek bietet eine Schnittstelle, die zwei Bewertungen zurückgibt: <br><br><ol><li>  maximale Verschiebung zwischen Zählern, die zu verschiedenen CPUs gehören.  Es werden nur CPUs berücksichtigt, die dem Prozess zur Verfügung stehen.  Wenn für einen Prozess beispielsweise drei CPUs verfügbar sind und die TSC auf diesen CPUs gleichzeitig 50, 150, 20 beträgt, beträgt die maximale Verschiebung 150-20 = 130.  Natürlich wird die Bibliothek nicht in der Lage sein, experimentell eine echte maximale Verschiebung zu erhalten, aber sie wird eine Schätzung geben, in die diese Verschiebung passt.  Was tun als nächstes mit der Bewertung?  Wie benutzt man?  Dies löst bereits den Client-Code.  Die Bedeutung ist jedoch ungefähr die folgende.  Die maximale Verschiebung ist der maximale Wert, um den die Dimension, die der Clientcode erstellt, verzerrt werden kann.  Angenommen, in unserem Beispiel mit drei CPUs begann der Client-Code, die Zeit auf CPU3 (wo TSC 20 war) zu messen, und endete auf CPU2 (wo TSC 150 war).  Es stellt sich heraus, dass sich zusätzliche 130 Ticks in das gemessene Intervall einschleichen.  Und nie wieder.  Der Unterschied zwischen CPU1 und CPU2 würde nur 100 Ticks betragen.  Mit einer Schätzung von 130 Ticks (in der Tat wird es viel konservativer sein) kann der Kunde entscheiden, ob ein solcher Verzerrungswert zu ihm passt oder nicht </li><li>  Erhöhen sich die TSC-Werte, die nacheinander auf derselben oder verschiedenen CPUs gemessen werden?  Hier ist die Idee.  Nehmen wir an, wir haben mehrere CPUs.  Angenommen, ihre Uhr ist synchronisiert und tickt mit derselben Frequenz.  Wenn Sie dann zuerst die Zeit auf einer CPU messen und dann erneut messen - bereits auf einer der verfügbaren CPUs -, sollte die zweite Ziffer größer sein als die erste. <br><br>  Ich werde diese Schätzung unterhalb der TSC-Monotonie-Schätzung nennen <br></li></ol><br>  Nun wollen wir sehen, wie wir die erste Schätzung erhalten können: <br><br><ol><li>  Einer der für den Prozess verfügbaren Prozessoren wird als "grundlegend" deklariert. </li><li>  dann werden alle anderen CPUs sortiert und für jede von ihnen wird die Verschiebung berechnet: <code>TSC___CPU – TSC___CPU</code> .  Dies geschieht wie folgt: <br><ul><li>  a) Drei Messwerte werden nacheinander (nacheinander!) <code>TSC_base_1, TSC_current, TSC_base_2</code> : <code>TSC_base_1, TSC_current, TSC_base_2</code> .  Hier zeigt der Strom an, dass der Wert auf der aktuellen CPU und die Basis auf der Basis gemessen wurde </li><li>  b) Die Verschiebung <code>TSC___CPU – TSC___CPU</code> muss im Intervall <code>[TSC_current – TSC_base_2, TSC_current – TSC_base_1]</code> .  Dies setzt voraus, dass TSCs auf beiden CPUs mit der gleichen Frequenz ticken. </li><li>  c) Die Schritte a) -b) werden mehrmals wiederholt.  Der Schnittpunkt aller in Schritt b) erhaltenen Intervalle wird berechnet.  Das resultierende Intervall wird als Schätzung der Verschiebung <code>TSC___CPU – TSC___CPU</code> </li></ul><br></li><li>  Nachdem für jede CPU eine Verschiebungsschätzung relativ zur Basis erhalten wurde, ist es einfach, eine Schätzung der maximalen Verschiebung zwischen allen verfügbaren CPUs zu erhalten: <br><ul><li>  a) Das Mindestintervall wird berechnet, das alle in Schritt 2 erhaltenen resultierenden Intervalle enthält </li><li>  b) Die Breite dieses Intervalls wird als Schätzung der maximalen Verschiebung zwischen TSCs verwendet, die auf verschiedenen CPUs ticken </li></ul><br></li></ol><br>  Um die Monotonie in der Bibliothek zu bewerten, wird der folgende Algorithmus implementiert: <br><br><ol><li>  Angenommen, ein Prozess verfügt über N CPU </li><li>  TSC auf CPU1 messen </li><li>  TSC auf CPU2 messen </li><li>  ... </li><li>  TSC auf CPUN messen </li><li>  TSC erneut an CPU1 messen </li><li>  Wir überprüfen, ob die gemessenen Werte vom ersten bis zum letzten monoton ansteigen </li></ol><br>  Hierbei ist es wichtig, dass der erste und der letzte Wert auf derselben CPU gemessen werden.  Und hier ist warum.  Nehmen wir an, wir haben 3 CPUs.  Angenommen, die TSC auf CPU2 ist gegenüber der TSC auf CPU1 um +100 Ticks verschoben.  Angenommen, die TSC auf CPU3 ist gegenüber der TSC auf CPU2 um +100 Ticks verschoben.  Betrachten Sie die folgende Ereigniskette: <br><br><ul><li>  Lesen Sie die TSC auf CPU1.  Es sei ein Wert von 10 erhalten </li><li>  2 Zecken bestanden </li><li>  Lesen Sie TSC auf CPU2.  Muss 112 sein </li><li>  2 Zecken bestanden </li><li>  Lesen Sie TSC auf CPU3.  Muss 214 sein </li></ul><br>  Bisher sieht die Uhr synchronisiert aus.  Aber lassen Sie uns noch einmal TSC auf CPU1 messen: <br><br><ul><li>  2 Zecken bestanden </li><li>  Lesen Sie die TSC auf CPU1.  Muss 16 sein </li></ul><br>  Ups!  Monotonie ist gebrochen.  Es stellt sich heraus, dass Sie durch Messen des ersten und letzten Werts auf derselben CPU mehr oder weniger große Verschiebungen zwischen den Uhren erkennen können.  Die nächste Frage natürlich: "Wie groß sind die Schichten?"  Das Ausmaß der Verschiebung, das erkannt werden kann, hängt von der Zeit ab, die zwischen aufeinanderfolgenden TSC-Messungen vergeht.  Im angegebenen Beispiel sind dies nur 2 Ticks.  Verschiebungen zwischen Stunden, die 2 Ticks überschreiten, werden erkannt.  Im Allgemeinen werden Verschiebungen, die kürzer als die zwischen aufeinanderfolgenden Messungen verstrichene Zeit sind, nicht erkannt.  Je dichter die Messungen in der Zeit sind, desto besser.  Die Genauigkeit beider Schätzungen hängt davon ab.  Je dichter die Messungen sind: <br><br><ul><li>  Je niedriger die maximale Schichtschätzung </li><li>  desto mehr Vertrauen in die Beurteilung der Monotonie </li></ul><br>  Im nächsten Abschnitt werden wir darüber sprechen, wie man enge Messungen vornimmt.  Ich möchte hier hinzufügen, dass die Bibliothek bei der Berechnung der TSC-Zuverlässigkeitsschätzungen viel mehr einfache "Läuse" -Prüfungen durchführt, zum Beispiel: <br><br><ul><li>  eingeschränkte Überprüfung, ob TSCs auf verschiedenen CPUs mit derselben Geschwindigkeit ticken </li><li>  Überprüfen Sie, ob sich die Zähler im Laufe der Zeit wirklich ändern und nicht nur den gleichen Wert anzeigen </li></ul><br><h3>  Zwei Methoden zum Sammeln von Zählerwerten </h3><br>  In der Bibliothek habe ich zwei Methoden zum Sammeln von TSC-Werten implementiert: <br><br><ol><li>  <b>Zwischen CPU wechseln</b> .  Bei dieser Methode werden alle Daten, die zur Bewertung der Zuverlässigkeit der TSC erforderlich sind, von einem einzelnen Thread erfasst, der von einer CPU zur anderen springt.  Beide im vorherigen Abschnitt beschriebenen Algorithmen sind für diese Methode geeignet und für die andere nicht. <br>  "Umschalten zwischen der CPU" hat keinen praktischen Nutzen.  Die Methode wurde nur implementiert, um "herumzuspielen".  Das Problem bei der Methode ist, dass die Zeit, die erforderlich ist, um einen Stream von einer CPU auf eine andere zu ziehen, sehr groß ist.  Dementsprechend vergeht zwischen aufeinanderfolgenden TSC-Messungen viel Zeit, und die Genauigkeit der Schätzungen ist sehr gering.  Beispielsweise wird eine typische Schätzung für die maximale Verschiebung zwischen TSC im Bereich von 23.000 Zecken erhalten. <br><br>  Das Verfahren hat jedoch einige Vorteile: <br><ul><li>  es ist absolut deterministisch.  Wenn Sie TSC nacheinander an CPU1, CPU2, CPU3 messen müssen, nehmen wir es einfach und tun es: Wechseln Sie zu CPU1, lesen Sie TSC, wechseln Sie zu CPU2, lesen Sie TSC und wechseln Sie schließlich zu CPU3, lesen Sie TSC </li><li>  Wenn die Anzahl der CPUs im System sehr schnell zunimmt, sollte die Umschaltzeit zwischen ihnen vermutlich viel langsamer ansteigen.  Daher kann theoretisch anscheinend ein System existieren - ein sehr großes System!  - in denen die Anwendung der Methode gerechtfertigt ist.  Dies ist jedoch unwahrscheinlich </li></ul><br></li><li>  <b>Messungen mit CAS bestellt</b> .  Bei dieser Methode werden Daten parallel von mehreren Threads erfasst.  Jede verfügbare CPU startet einen Thread.  Messungen, die von verschiedenen Threads durchgeführt werden, werden in einer einzigen Sequenz unter Verwendung der Operation "Vergleichen und Tauschen" angeordnet.  Unten finden Sie einen Code, der zeigt, wie dies gemacht wird. <br>  Die Idee der Methode stammt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fio</a> , einem beliebten Tool zur Erzeugung von E / A-Lasten. <br><br>  Die Zuverlässigkeitsschätzungen, die mit der Leistung dieser Methode erhalten wurden, sehen bereits ziemlich gut aus.  Beispielsweise wird bereits eine Schätzung der maximalen Verschiebung auf der Ebene von mehreren hundert Ticks erhalten.  Eine Überprüfung der Monotonie ermöglicht es Ihnen, die Uhr innerhalb von Hunderten von Ticks nicht synchron zu erfassen. <br><br>  Die im vorherigen Abschnitt angegebenen Algorithmen sind jedoch für diese Methode nicht geeignet.  Für sie ist es wichtig, dass die TSC-Werte in einer vorgegebenen Reihenfolge gemessen werden.  Die Methode der von CAS bestellten Messungen erlaubt dies nicht.  Stattdessen wird zuerst eine lange Folge von Zufallsmessungen gesammelt, und dann versuchen (bereits unterschiedliche) Algorithmen, Werte zu finden, die auf „geeigneten“ CPUs in dieser Folge gelesen werden. <br><br>  Ich werde diese Algorithmen hier nicht angeben, um Ihre Aufmerksamkeit nicht zu missbrauchen.  Sie können sie im Code sehen.  Es gibt viele Kommentare.  Theoretisch sind diese Algorithmen gleich.  Ein grundlegend neuer Punkt ist die Überprüfung, wie zufällig typisierte TSC-Sequenzen statistisch „qualitativ“ sind.  Es ist auch möglich, ein akzeptables Mindestmaß an statistischer Signifikanz für TSC-Zuverlässigkeitsschätzungen festzulegen. <br><br>  Theoretisch kann bei SEHR großen Systemen die Methode „CAS-geordnet“ zu schlechten Ergebnissen führen.  Das Verfahren erfordert, dass Prozessoren um den Zugriff auf einen gemeinsamen Speicherort konkurrieren.  Wenn es viele Prozessoren gibt, kann sich der Wettbewerb als sehr intensiv herausstellen.  Infolgedessen wird es schwierig sein, eine Messsequenz mit guten statistischen Eigenschaften zu erstellen.  Im Moment scheint diese Situation jedoch unwahrscheinlich. <br></li></ol><br>  Ich habe Code versprochen.  So sieht es aus, wenn Sie mit CAS Messungen in einer einzigen Kette erstellen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg-&gt;probes_count; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> seq_num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> tsc_val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { __atomic_load( seq_counter, &amp;seq_num, __ATOMIC_ACQUIRE); __sync_synchronize(); tsc_val = WTMLIB_GET_TSC(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !__atomic_compare_exchange_n( seq_counter, &amp;seq_num, seq_num + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, __ATOMIC_ACQ_REL, __ATOMIC_RELAXED)); arg-&gt;tsc_probes[i].seq_num = seq_num; arg-&gt;tsc_probes[i].tsc_val = tsc_val; }</code> </pre><br>  Dieser Code wird auf jeder verfügbaren CPU ausgeführt.  Alle Threads haben Zugriff auf die gemeinsam genutzte Variable <code>seq_counter</code> .  Vor dem Lesen der TSC liest der Stream den Wert dieser Variablen und speichert ihn in der Variablen <code>seq_num</code> .  Dann liest TSC.  Dann wird versucht, seq_counter atomar um eins zu erhöhen, jedoch nur, wenn sich der Wert der Variablen seit dem Lesen nicht geändert hat.  Wenn die Operation erfolgreich ist, bedeutet dies, dass es dem Thread gelungen ist, die in <code>seq_num</code> hinter dem gemessenen TSC-Wert gespeicherte <code>seq_num</code> .  Die nächste Seriennummer, die (möglicherweise bereits in einem anderen Thread) eingesetzt werden kann, ist eine weitere.  Diese Nummer wird der Variablen <code>seq_counter</code> entnommen, und jeder erfolgreiche Aufruf von <code>__atomic_compare_exchange_n()</code> erhöht diese Variable um eins. <br><br><div class="spoiler">  <b class="spoiler_title">__atomic mit __sync ???</b> <div class="spoiler_text">  Aus Gründen der <code>__atomic</code> sollte beachtet werden, dass die Verwendung der integrierten Funktionen der <code>__atomic</code> Familie zusammen mit einer Funktion aus der veralteten <code>__sync</code> Familie hässlich aussieht.  <code>__sync_synchronize()</code> im Code verwendet, um zu vermeiden, dass die TSC-Leseoperation mit der Upstream-Operation neu angeordnet wird.  Dies erfordert eine vollständige Speicherbarriere.  Die <code>__atomic</code> Familie hat formal keine Funktion mit den entsprechenden Eigenschaften.  Obwohl es tatsächlich gibt: <code>__atomic_signal_fence()</code> .  Diese Funktion organisiert Stream-Berechnungen mit Signalhandlern, die auf demselben Stream ausgeführt werden.  In der Tat ist dies eine vollständige Barriere.  Dies wird jedoch nicht ausdrücklich angegeben.  Und ich bevorzuge Code ohne versteckte Semantik.  Daher ist <code>__sync_synchronize()</code> eine Stop-Full-Speicherbarriere. <br></div></div><br>  Ein weiterer erwähnenswerter Punkt ist die Sorgfalt, dass alle an Messungen beteiligten Flüsse mehr oder weniger gleichzeitig beginnen.  Wir sind daran interessiert, dass die auf verschiedenen CPUs gelesenen TSC-Werte so gemischt wie möglich sind.  Wir sind nicht zufrieden mit der Situation, in der beispielsweise ein Thread zuerst startet, seine Arbeit beendet und erst dann alle anderen beginnen.  Die resultierende TSC-Sequenz hat nutzlose Eigenschaften.  Daraus können keine Schätzungen gezogen werden.  Der gleichzeitige Start aller Threads ist wichtig - und dafür wurden Maßnahmen in der Bibliothek ergriffen. <br><br><h3>  Konvertieren Sie Zecken im laufenden Betrieb in Nanosekunden </h3><br>  Nach Überprüfung der Zuverlässigkeit von TSC besteht der zweite Hauptzweck der Bibliothek darin, Zecken im laufenden Betrieb in Nanosekunden umzuwandeln.  Die Idee dieser Umstellung habe ich dem bereits erwähnten Fio entlehnt.  Ich musste jedoch einige signifikante Verbesserungen vornehmen, da das Konvertierungsverfahren, wie meine Analyse gezeigt hat, in fio selbst nicht gut genug funktioniert.  Dort erhalten Sie eine geringe Genauigkeit. <br><br>  Ich beginne mit einem Beispiel. <br><br>  Idealerweise möchte ich Zecken wie folgt in Nanosekunden umwandeln: <br> <code>ns_time = tsc_ticks / tsc_per_ns</code> <br>  Wir möchten, dass der Zeitaufwand für die Konvertierung minimal ist.  Daher möchten wir ausschließlich ganzzahlige Arithmetik verwenden.  Mal sehen, wie uns das bedrohen kann. <br><br>  Wenn <code>tsc_per_ns = 3</code> , <code>tsc_per_ns = 3</code> eine einfache Ganzzahldivision unter dem Gesichtspunkt der Genauigkeit <code>ns_time = tsc_ticks / 3</code> : <code>ns_time = tsc_ticks / 3</code> . <br><br>  Aber was ist, wenn <code>tsc_per_ns = 3.333</code> ?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn diese Zahl auf 3 gerundet wird, ist die Konvertierungsgenauigkeit sehr gering. Zur Lösung dieses Problems wie folgt: </font></font><br> <code>ns_time = (tsc_ticks * factor) / (3.333 * factor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Faktor </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">groß genug ist, ist die Genauigkeit gut. Aber etwas wird schlecht bleiben. Konvertierungsaufwand. Die Ganzzahldivision ist eine sehr teure Operation. Auf x86 sind beispielsweise mehr als 10 Taktzyklen erforderlich. Außerdem werden Operationen zur Ganzzahldivision nicht immer per Pipeline ausgeführt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir schreiben unsere Formel in der entsprechenden Form </font></font><br> <code>ns_time = (tsc_ticks * factor / 3.333) / factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Division ist kein Problem. Wir können </font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Voraus </font><font style="vertical-align: inherit;">vorberechnen </font><font style="vertical-align: inherit;">. Aber die zweite Liga ist immer noch Schmerz. Um sie loszuwerden, wählen wir</font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich der Potenz von zwei. Danach kann die zweite Abteilung durch eine Bitverschiebung ersetzt werden - eine einfache und schnelle Operation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie groß kannst du wählen </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Leider kann </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es nicht beliebig groß sein. Es ist durch die Bedingung begrenzt, dass die Multiplikation im Zähler nicht zu einem Überlauf des 64-Bit-Typs führen darf. Ja, wir möchten nur "native" Typen verwenden. Auch hier, um den Conversion-Overhead auf ein Minimum zu beschränken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun wollen wir sehen, wie groß es </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in unserem speziellen Beispiel sein kann. Angenommen, wir möchten mit Zeitintervallen von bis zu einem Jahr arbeiten. Im </font><font style="vertical-align: inherit;">Laufe des Jahres tiknet TSC mal folgenden: </font></font><code>3.333 * 1000000000 * 60 * 60 * 24 * 365 = 105109488000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Unterteile </font><font style="vertical-align: inherit;">ein Maximalwert von 64-Bit - </font><font style="vertical-align: inherit;">Typennummer ist: </font></font><code>18446744073709551615 / 105109488000000000 ~ 175.5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Also der Ausdruck</font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte nicht größer als dieser Wert sein. Dann haben wir </font></font><code>factor &lt;= 175.5 * 3.333 ~ 584.9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die größte Zweierpotenz, die diese Zahl nicht überschreitet, ist 512. Daher hat unsere Umrechnungsformel die Form: </font></font><br><br> <code>ns_time = (tsc_ticks * 512 / 3.333) / 512</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oder: </font></font><br><br> <code>ns_time = tsc_ticks * 153 / 512</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fein. Lassen Sie uns nun mit Genauigkeit sehen, was diese Formel hat. Ein Jahr enthält </font></font><code>1000000000 * 60 * 60 * 24 * 365 = 31536000000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nanosekunden. Unsere Formel ergibt: </font></font><code>105109488000000000 * 153 / 512 = 31409671218750000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Differenz zum Barwert beträgt 126328781250000 Nanosekunden oder </font></font><code>126328781250000 / 1000000000 / 60 / 60 ~ 35</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stunden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist ein großer Fehler. Wir wollen eine bessere Genauigkeit. Was ist, wenn wir Zeitintervalle von nicht mehr als einer Stunde messen? Ich werde die Berechnungen weglassen. Sie sind völlig identisch mit denen, die gerade gemacht wurden. Die endgültige Formel lautet: </font></font><br><br> <code>ns_time = tsc_ticks * 1258417 / 4194304</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Konvertierungsfehler beträgt nur 119.305 Nanosekunden pro 1 Stunde (was weniger als 0,2 Millisekunden entspricht). Sehr sehr gut. Wenn der maximale konvertierbare Wert noch weniger als eine Stunde beträgt, ist die Genauigkeit sogar noch besser. Aber wie nutzen wir das? Zeitmessungen nicht auf eine Stunde beschränken? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Achten Sie </font><font style="vertical-align: inherit;">auf den folgenden Punkt: </font></font><br><br> <code>tsc_ticks = (tsc_ticks_per_1_hour * number_of_hours) + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir Vorkalkulation </font></font><code>tsc_ticks_per_1_hour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, können wir extrahieren </font></font><code>number_of_hours</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Als nächstes wissen wir, wie viele Nanosekunden in einer Stunde enthalten sind. Daher wird es für uns nicht schwierig sein, den Teil </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der einer ganzen Anzahl von Stunden entspricht, </font><font style="vertical-align: inherit;">in Nanosekunden zu übersetzen </font><font style="vertical-align: inherit;">. Um die Konvertierung abzuschließen, müssen wir in Nanosekunden übersetzen</font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir wissen jedoch, dass diese Anzahl von Zecken in weniger als einer Stunde auftrat. Um es in Nanosekunden umzuwandeln, können wir die Formel (1) verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertig. Ein solcher Umwandlungsmechanismus passt zu uns. Lassen Sie es uns jetzt zusammenfassen und optimieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst möchten wir eine flexible Kontrolle über Konvertierungsfehler haben. Wir möchten die Konvertierungsparameter nicht an ein Zeitintervall von 1 Stunde binden. Es sei ein beliebiges Zeitintervall: Denken Sie noch </font></font><br><br> <code>tsc_ticks = modulus * number_of_moduli_periods + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einmal daran, wie der Rest in Nanosekunden konvertiert wird: </font></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * factor / tsc_per_nsec) / factor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir berechnen die Konvertierungsparameter (das wissen wir </font></font><code>tsc_ticks_remainder &lt; modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br><br> <code>modulus * (factor / tsc_per_nsec) &lt;= UINT64_MAX <br> factor &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br> 2 ^ shift &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus Gründen der Langeweile ist anzumerken, dass die letzte Ungleichung im Rahmen der Ganzzahlarithmetik nicht der ersten entspricht. Aber ich werde nicht lange darauf eingehen. Ich kann nur sagen, dass die letzte Ungleichung schwerwiegender ist als die erste und daher sicher zu verwenden ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir aus der letzten Ungleichung erhalten haben </font></font><code>shift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, berechnen wir: </font><font style="vertical-align: inherit;">Und dann werden diese Parameter verwendet, um den Rest in Nanosekunden umzuwandeln: </font><font style="vertical-align: inherit;">Also haben wir die Restumrechnung herausgefunden. Das nächste zu lösende Problem - ist die Entfernung </font><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">aus </font><font style="vertical-align: inherit;">. Wie immer wollen wir es schnell machen. Wie immer wollen wir keine Division verwenden. Deshalb wählen wir einfach </font><font style="vertical-align: inherit;">gleich der Zweierpotenz: </font><font style="vertical-align: inherit;">Dann:</font></font><br><br> <code>factor = 2 ^ shift <br> mult = factor / tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * mult) &gt;&gt; shift <br></code> <br><br><font style="vertical-align: inherit;"></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"></font><code>number_of_moduli_periods</code><font style="vertical-align: inherit;"></font><code>tsc_ticks</code><font style="vertical-align: inherit;"></font><code>modulus</code><font style="vertical-align: inherit;"></font><br><br> <code>modulus = 2 ^ remainder_bit_length</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length <br> tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> <br> <br>  Großartig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir wissen jetzt, wie man aus </font></font><code>tsc_ticks</code> <code>number_of_moduli_periods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">extrahiert </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und wir wissen, wie man </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Nanosekunden </font><font style="vertical-align: inherit;">umwandelt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es bleibt zu verstehen, wie dieser Teil der Zecken, der ein Vielfaches ist, in Nanosekunden umgewandelt wird </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber alles ist einfach: </font></font><br><br> <code>ns_per_moduli = ns_per_modulus * number_of_moduli_periods</code> <br> <br> <code>ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können im Voraus rechnen. </font><font style="vertical-align: inherit;">Darüber hinaus nach der gleichen Formel, nach der wir den Rest umrechnen. </font><font style="vertical-align: inherit;">Diese Formel kann für Zeiträume verwendet werden, die nicht länger als sind </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Er selbst </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">natürlich nicht länger als </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <code>ns_per_modulus = (modulus * mult) &gt;&gt; shift</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist alles! </font><font style="vertical-align: inherit;">Wir konnten alle Parameter berechnen, die erforderlich sind, um Zecken im laufenden Betrieb in Nanosekunden umzuwandeln. </font><font style="vertical-align: inherit;">Fassen Sie nun das Konvertierungsverfahren kurz zusammen:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir haben </font></font><code>tsc_ticks</code> </li><li> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length</code> </li> <li> <code>tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> </li> <li> <code>ns = ns_per_modulus * number_of_moduli_periods + (tsc_ticks_remainder * mult) &gt;&gt; shift</code> </li> </ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei diesem Verfahren werden Parameter </font></font><code>remainder_bit_length</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>modulus, ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>shift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorkalkulation voraus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diesen Beitrag noch lesen, sind Sie großartig oder großartig. </font><font style="vertical-align: inherit;">Es ist sogar möglich, dass Sie ein Performance-Analyst oder Entwickler von Hochleistungssoftware sind.</font></font><br><br>  Also.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellt sich heraus, dass wir noch nicht fertig sind :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erinnerst du dich, wie wir den Parameter berechnet haben </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Es war so: </font></font><br><br> <code>mult = factor / tsc_per_nsec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frage: Woher kommt es </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der Zecken in einer Nanosekunde ist ein sehr kleiner Wert. </font><font style="vertical-align: inherit;">Tatsächlich </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird </font><font style="vertical-align: inherit;">stattdessen meine Bibliothek </font><font style="vertical-align: inherit;">verwendet </font></font><code>(tsc_per_sec / 1000000000)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font> Das heißt: <br><br> <code>mult = factor * 1000000000 / tsc_per_sec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und es gibt zwei interessante Fragen: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nicht </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Beispiel?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Woher bekommen diese </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit dem ersten. Fio verwendet jetzt tatsächlich die Anzahl der Ticks pro Millisekunde. Und damit gibt es Probleme. Auf der Maschine, die Parameter , </font><font style="vertical-align: inherit;">von denen ich oben genannt </font></font><code>tsc_per_msec = 2599998</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Während </font></font><code>tsc_per_sec = 2599998971</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn wir diese Zahlen auf eine Skala bringen, liegt ihr Verhältnis sehr nahe bei Eins: 0,999999626. Wenn wir jedoch die erste und nicht die zweite verwenden, haben wir für jede Sekunde einen Fehler von 374 Nanosekunden. Deshalb - </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiter ... Wie zählt man </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies erfolgt auf der Grundlage einer direkten Messung: </font><font style="vertical-align: inherit;">„einige Zeit“ ist ein konfigurierbarer Parameter. Sie kann größer, kleiner oder gleich einer Sekunde sein. Nehmen wir an, es ist eine halbe Sekunde. Nehmen wir weiter an, dass der tatsächliche Unterschied zwischen </font><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">0,6 Sekunden betrug. Dann </font><font style="vertical-align: inherit;">.</font></font><br><br> <code>start_sytem_time = clock_gettime() <br> start_tsc = WTMLIB_GET_TSC() <br>  -  <br> end_system_time = clock_gettime() <br> end_tsc = WTMLIB_GET_TSC() <br></code> <br><br><font style="vertical-align: inherit;"></font><code>end_system_time</code><font style="vertical-align: inherit;"></font><code>start_system_time</code><font style="vertical-align: inherit;"></font><code>tsc_per_sec = (end_tsc – start_tsc) / 0,6</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bibliothek berücksichtigt auf diese Weise mehrere Werte </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mit Standardmethoden werden sie dann von statistischem Rauschen „gereinigt“ und erhalten einen einzigen </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vertrauenswürdigen </font><font style="vertical-align: inherit;">Wert </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im obigen Zeitmessdiagramm ist die Reihenfolge der Anrufe </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">wichtig </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es ist wichtig, </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dass zwischen zwei Anrufen dieselbe Zeit vergeht wie zwischen zwei Anrufen </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dann ist es möglich, die Systemzeit leicht mit TSC-Ticks zu korrelieren. Und dann kann die Streuung der Werte </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wirklich als zufällig angesehen werden. Bei diesem Messschema </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weichen </font><font style="vertical-align: inherit;">die Werte </font><font style="vertical-align: inherit;">mit der gleichen Wahrscheinlichkeit in beide Richtungen vom Durchschnittswert ab. Und es wird möglich sein, Standardfiltermethoden auf sie anzuwenden.</font></font><br><br><h3>  Fazit </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht ist das alles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Thema der effektiven Zeitmessung ist jedoch nicht darauf beschränkt. </font><font style="vertical-align: inherit;">Es gibt viele Nuancen. </font><font style="vertical-align: inherit;">Für Interessierte schlage ich vor, unabhängig an folgenden Themen zu arbeiten:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichern von Konvertierungsparametern im Cache oder - noch besser - in Registern </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis zu welchen Grenzen kann reduziert werden </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wodurch die Genauigkeit der Konvertierung erhöht wird)?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wir gesehen haben, wird die Konvertierungsgenauigkeit nicht nur beeinflusst </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sondern auch durch die Größe des Zeitintervalls, das mit Ticks ( </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">korreliert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie kann der Einfluss beider Faktoren ausgeglichen werden?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TSC in der virtuellen Maschine. </font><font style="vertical-align: inherit;">Kann ich es benutzen?</font></font></li><li>        . , fio        timespec.    : <br><br> <code>tp-&gt;tv_sec = nsecs / 1000000000ULL;</code> <br> <br> ,   TSC          .         ,  ,      <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit den in diesem Artikel beschriebenen Methoden können wir die Zeitskala einer Sekunde mit einer Genauigkeit in der Größenordnung von mehreren zehn Nanosekunden messen. </font><font style="vertical-align: inherit;">Dies ist die Genauigkeit, die ich bei der Verwendung meiner Bibliothek tatsächlich beobachte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interessanterweise verliert das Fio, von dem ich einige Methoden ausgeliehen habe, auf einer zweiten Skala genau 700-900 Nanosekunden (und dafür gibt es drei Gründe). </font><font style="vertical-align: inherit;">Außerdem verliert die Konvertierungsgeschwindigkeit aufgrund der Speicherung von Zeit in einem Standard-Linux-Format. </font><font style="vertical-align: inherit;">Ich beeile mich jedoch, Fio-Fans zu beruhigen. </font><font style="vertical-align: inherit;">Ich habe Entwicklern eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschreibung aller Konvertierungsprobleme</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gesendet </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">, die ich entdeckt habe</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die Leute arbeiten bereits, sie werden es bald beheben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wünsche Ihnen viele angenehme Nanosekunden!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425237/">https://habr.com/ru/post/de425237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425227/index.html">Forscher haben einen Weg gefunden, Honeytoken-Schlüssel in einer Reihe von Amazon-Diensten zu erkennen und zu umgehen.</a></li>
<li><a href="../de425229/index.html">Wie wir CDN MegaFon.TV geholfen haben, die Weltmeisterschaft 2018 nicht zu erreichen</a></li>
<li><a href="../de425231/index.html">FAQ über die Arbeit einer Stewardess</a></li>
<li><a href="../de425233/index.html">Python 3 auf Facebook</a></li>
<li><a href="../de425235/index.html">Ein wenig mehr über Diagramme oder das Erkennen von Abhängigkeiten zwischen Ihren Anwendungen</a></li>
<li><a href="../de425241/index.html">Entwickler 20 Jahre später: Vasily Lebedev über ICRE, Bildung, sein Buch und Programmierung</a></li>
<li><a href="../de425243/index.html">Das John Willis Handbuch</a></li>
<li><a href="../de425245/index.html">Ankündigung von RamblerFront & # 6</a></li>
<li><a href="../de425247/index.html">Crowdsourcing beim Testen</a></li>
<li><a href="../de425249/index.html">Wie ist die Bekanntschaft mit LLP an der ITMO University: der Kurs "Low-Level Programming"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>