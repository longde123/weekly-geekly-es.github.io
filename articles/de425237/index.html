<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìñ üë©üèΩ‚Äçü§ù‚Äçüë©üèº ü•ú Zeitmessung mit Nanosekundengenauigkeit ‚ô•Ô∏è ‚ù£Ô∏è üé¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor ein paar Monaten kam ein historischer Moment f√ºr mich. Standard-Betriebssystem-Tools zum Messen der Zeit reichen f√ºr mich nicht mehr aus. Es dauer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zeitmessung mit Nanosekundengenauigkeit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425237/"><img src="https://habrastorage.org/webt/zx/xf/se/zxxfse_sd5ma4wwfy0u6rilcai8.jpeg" alt="Bild"><br><br>  Vor ein paar Monaten kam ein historischer Moment f√ºr mich.  Standard-Betriebssystem-Tools zum Messen der Zeit reichen f√ºr mich nicht mehr aus.  Es dauerte einige Zeit, um mit Nanosekundengenauigkeit und mit Nanosekunden-Overhead zu messen. <br><br>  Ich beschloss, eine Bibliothek zu schreiben, die dieses Problem l√∂sen w√ºrde.  Auf den ersten Blick schien es nichts Besonderes zu geben.  Bei n√§herer Betrachtung stellte sich jedoch wie immer heraus, dass es viele interessante Probleme gab, die gel√∂st werden mussten.  In diesem Artikel werde ich √ºber die Probleme sprechen und wie sie gel√∂st wurden. <br><br>  Da Sie viele verschiedene Arten von Zeit auf einem Computer messen k√∂nnen, werde ich sofort klarstellen, dass wir hier √ºber "Zeit mit Stoppuhr" sprechen werden.  Oder Wanduhrzeit.  Es ist Echtzeit, verstrichene Zeit usw.  Das hei√üt, eine einfache "menschliche" Zeit, die wir zu Beginn der Aufgabe erkennen und am Ende anhalten. <br><a name="habracut"></a><br><h3>  Mikrosekunde - fast f√ºr immer </h3><br>  Entwickler von Hochleistungssystemen haben sich in den letzten Jahren an die Mikrosekunden-Zeitskala gew√∂hnt.  In Mikrosekunden k√∂nnen Sie Daten von einem NVMe-Laufwerk lesen.  In Mikrosekunden k√∂nnen Daten √ºber das Netzwerk gesendet werden.  Nat√ºrlich nicht f√ºr jedermann, aber f√ºr InifiniBand-Netzwerk - ganz einfach. <br><br>  Gleichzeitig hatte die Mikrosekunde auch eine Struktur.  Ein vollst√§ndiger E / A-Stapel besteht aus mehreren Software- und Hardwarekomponenten.  Die von einigen von ihnen eingef√ºhrten Verz√∂gerungen liegen im Submikrosekundenbereich. <br><br>  Um Verz√∂gerungen dieser Gr√∂√üenordnung zu messen, reicht die Mikrosekundengenauigkeit nicht mehr aus.  Es ist jedoch nicht nur die Genauigkeit wichtig, sondern auch der Aufwand f√ºr die Messzeit.  Der Linux-Systemaufruf clock_gettime () gibt die Zeit mit einer Genauigkeit von Nanosekunden zur√ºck.  Auf einem Computer, der mir direkt zur Verf√ºgung steht (Intel¬Æ Xeon¬Æ CPU E5-2630 v2 bei 2,60 GHz), wird dieser Anruf in ca. 120 ns abgeschlossen.  Sehr gute Figur.  Au√üerdem funktioniert clock_gettime () ziemlich vorhersehbar.  Auf diese Weise k√∂nnen Sie den Overhead seines Anrufs ber√ºcksichtigen und tats√§chlich Messungen mit einer Genauigkeit in der Gr√∂√üenordnung von zehn Nanosekunden durchf√ºhren.  Lassen Sie uns jetzt jedoch darauf achten.  Um das Zeitintervall zu messen, m√ºssen Sie zwei solche Anrufe t√§tigen: am Anfang und am Ende.  Das hei√üt,  240 ns ausgeben.  Wenn dicht beabstandete Zeitintervalle in der Gr√∂√üenordnung von 1-10 Œºs gemessen werden, verzerrt in einigen solchen F√§llen der Messprozess selbst den beobachteten Prozess erheblich. <br><br>  Ich habe diesen Abschnitt damit begonnen, wie sich der E / A-Stapel in den letzten Jahren beschleunigt hat.  Dies ist neu, aber bei weitem nicht der einzige Grund, die Zeit schnell und genau messen zu wollen.  Ein solches Bed√ºrfnis war schon immer.  Zum Beispiel gab es immer einen Code, den ich um mindestens 1 Taktzyklus des Mikroprozessors beschleunigen wollte.  Oder ein anderes Beispiel aus dem Originalartikel √ºber die sensationelle Spectre-Sicherheitsl√ºcke: <br><br><img src="https://habrastorage.org/webt/db/5a/7o/db5a7oldvzrcqfi_ymamg4qzscu.jpeg" alt="Bild"><br><br>  Hier messen die Zeilen 72 bis 74 die Ausf√ºhrungszeit einer einzelnen Speicherzugriffsoperation.  Specter interessiert sich zwar nicht f√ºr Nanosekunden.  Die Zeit kann in "Papageien" gemessen werden.  Wir werden zu den Papageien und Sekunden zur√ºckkehren. <br><br><h3>  Zeitstempelz√§hler </h3><br>  Der Schl√ºssel zur schnellen und genauen Zeitmessung ist ein spezieller Mikroprozessorz√§hler.  Der Wert dieses Z√§hlers wird normalerweise in einem separaten Register gespeichert und ist normalerweise - aber nicht immer - vom Benutzerbereich aus zug√§nglich.  Auf verschiedenen Architekturen wird der Z√§hler unterschiedlich genannt: <br><br><ol><li>  x86 Zeitstempelz√§hler </li><li>  Zeitbasisregister auf PowerPC </li><li>  Intervallzeitz√§hler auf Itanium </li><li>  usw. </li></ol><br>  Im Folgenden werde ich immer den Namen "Zeitstempelz√§hler" oder TSC verwenden, obwohl ich in Wirklichkeit jeden solchen Z√§hler unabh√§ngig von der Architektur im Auge behalten werde. <br><br>  Das Lesen des TSC-Werts ist normalerweise - aber auch nicht immer - mit einer einzigen Anweisung m√∂glich.  Hier ist ein Beispiel f√ºr x86.  Genau genommen ist dies keine reine Assembler-Anweisung, sondern der GNU-Inline-Assembler: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eax, edx; __asm__ __volatile__( <span class="hljs-string"><span class="hljs-string">"rdtsc"</span></span> : <span class="hljs-string"><span class="hljs-string">"=a"</span></span> (eax), <span class="hljs-string"><span class="hljs-string">"=d"</span></span> (edx));</code> </pre> <br>  Der Befehl rdtsc platziert zwei 32-Bit-H√§lften des TSC-Registers in den Registern eax und edx.  Von diesen k√∂nnen Sie einen einzelnen 64-Bit-Wert "kleben". <br><br>  Ich stelle noch einmal fest: Diese (und √§hnliche) Anweisungen k√∂nnen in den meisten F√§llen direkt aus dem Benutzerbereich aufgerufen werden.  Keine Systemaufrufe.  Minimaler Overhead. <br><br>  Was muss jetzt getan werden, um die Zeit zu messen? <br><br><ol><li>  F√ºhren Sie eine solche Anweisung zu Beginn des f√ºr uns interessanten Zeitintervalls aus.  Z√§hlerwert merken </li><li>  F√ºhren Sie am Ende eine solche Anweisung aus.  Wir glauben, dass der Wert des Z√§hlers von der ersten Anweisung zur zweiten steigen wird.  Warum wird es sonst ben√∂tigt?  Denken Sie an den zweiten Wert </li><li>  Wir betrachten den Unterschied zwischen den beiden gespeicherten Werten.  Dies ist unsere Zeit </li></ol><br>  Es sieht einfach aus, aber ... <br><br>  Die nach dem beschriebenen Verfahren gemessene Zeit wird in ‚ÄûPapageien‚Äú ausgedr√ºckt.  Es ist nicht in Sekunden.  Aber manchmal sind Papageien genau das, was Sie brauchen.  Es gibt Situationen, in denen nicht die absoluten Werte der Zeitintervalle wichtig sind, sondern die Beziehung zwischen den verschiedenen Intervallen.  Das obige Spectre-Beispiel zeigt genau diese Situation.  Die Dauer jedes einzelnen Speicherzugriffs spielt keine Rolle.  Es ist nur wichtig, dass Aufrufe an einige Adressen viel schneller ausgef√ºhrt werden als an andere (abh√§ngig davon, ob die Daten im Cache oder im Hauptspeicher gespeichert sind). <br><br>  Aber was ist, wenn keine Papageien ben√∂tigt werden, sondern Sekunden / Mikrosekunden / Nanosekunden usw.?  Hier lassen sich zwei grunds√§tzlich unterschiedliche F√§lle unterscheiden: <br><br><ol><li>  Aber dann werden Nanosekunden ben√∂tigt.  Das hei√üt, es ist zul√§ssig, zuerst alle erforderlichen Messungen in Papageien durchzuf√ºhren und sie zur weiteren Verarbeitung irgendwo zu speichern (z. B. im Speicher).  Und erst nach Abschluss der Messungen werden die gesammelten Papageien langsam in Sekunden umgewandelt </li><li>  Nanosekunden werden "on the fly" ben√∂tigt.  Zum Beispiel hat Ihr Messprozess eine Art ‚ÄûVerbraucher‚Äú, den Sie nicht kontrollieren und der Zeit im ‚Äûmenschlichen‚Äú Format erwartet </li></ol><br>  Der erste Fall ist einfach, der zweite - erfordert Einfallsreichtum.  Die Konvertierung sollte so effektiv wie m√∂glich sein.  Wenn es viele Ressourcen verbraucht, kann es den Messprozess stark verzerren.  Wir werden im Folgenden √ºber eine effektive Konvertierung sprechen.  Hier haben wir dieses Problem bisher identifiziert und gehen zu einem anderen √ºber. <br><br>  Zeitstempelz√§hler sind nicht so einfach, wie wir es gerne h√§tten.  Auf einigen Architekturen: <br><br><ol><li>  Es kann nicht garantiert werden, dass die TSC mit hoher Frequenz aktualisiert wird.  Wenn die TSC beispielsweise einmal pro Mikrosekunde aktualisiert wird, ist es nicht m√∂glich, Nanosekunden damit zu reparieren. </li><li>  Die H√§ufigkeit, mit der die TSC aktualisiert wird, kann im Laufe der Zeit variieren </li><li>  Auf verschiedenen im System vorhandenen CPUs k√∂nnen TSCs mit unterschiedlichen Frequenzen aktualisiert werden </li><li>  Es kann zu einer Verschiebung zwischen TSCs kommen, die auf verschiedenen CPUs ticken </li></ol><br>  Hier ist ein Beispiel, das das letzte Problem veranschaulicht.  Angenommen, wir haben ein System mit zwei CPUs: CPU1 und CPU2.  Angenommen, die TSC auf der ersten CPU liegt um die Anzahl der Ticks hinter der zweiten, was 5 Sekunden entspricht.  Angenommen, im System wird ein Stream gestartet, der die Zeit der Berechnungen misst, was er selbst tut.  Dazu liest der Stream zuerst den TSC-Wert, f√ºhrt dann die Berechnung durch und liest dann den zweiten TSC-Wert.  Wenn ein Thread w√§hrend seiner gesamten Lebensdauer nur auf einer CPU verbleibt - auf einer beliebigen -, gibt es keine Probleme.  Was aber, wenn der Thread auf CPU1 gestartet, dort den ersten TSC-Wert gemessen und dann in der Mitte der Berechnungen vom Betriebssystem auf CPU2 verschoben wurde, wo er den zweiten TSC-Wert las?  In diesem Fall erscheinen die Berechnungen 5 Sekunden l√§nger als sie tats√§chlich sind. <br><br>  Aufgrund der oben aufgef√ºhrten Probleme kann TSC auf einigen Systemen nicht als zuverl√§ssige Zeitquelle dienen.  Auf anderen Systemen, die unter denselben Problemen "leiden", kann TSC jedoch weiterhin verwendet werden.  M√∂glich wird dies durch besondere architektonische Merkmale: <br><br><ol><li>  Das Ger√§t kann jedes Mal einen speziellen Interrupt erzeugen, wenn sich die H√§ufigkeit √§ndert, mit der die TSC aktualisiert wird.  Gleichzeitig bietet das Ger√§t die M√∂glichkeit, die aktuelle Frequenz herauszufinden.  Alternativ kann die TSC-Aktualisierungsrate unter die Kontrolle des Betriebssystems gestellt werden (siehe ‚ÄûPower ISA Version 2.06 Revision B, Buch II, Kapitel 5‚Äú). </li><li>  Zusammen mit dem TSC-Wert kann das Ger√§t auch die ID der CPU bereitstellen, auf der dieser Wert gelesen wird (siehe Intel RDTSCP-Anweisung, ‚ÄûEntwicklerhandbuch f√ºr Intel 64- und IA-32-Architekturen-Software‚Äú, Band 2). </li><li>  Auf einigen Systemen k√∂nnen Sie den TSC-Wert f√ºr jede CPU programmgesteuert anpassen (siehe Intel WRMSR-Anweisung und Register IA32_TIME_STAMP_COUNTER, ‚ÄûEntwicklerhandbuch f√ºr Intel 64- und IA-32-Architekturen-Software‚Äú, Band 3). </li></ol><br>  Im Allgemeinen ist das Thema, wie Zeitmesser auf verschiedenen Architekturen implementiert werden, faszinierend und umfangreich.  Wenn Sie Zeit und Interesse haben, empfehle ich Tauchen.  Unter anderem erfahren Sie beispielsweise, dass Sie mit einigen Systemen programmgesteuert bestimmen k√∂nnen, ob TSC als zuverl√§ssige Zeitquelle dienen kann. <br><br>  Es gibt also viele architektonische Implementierungen von TSC, von denen jede ihre eigenen Eigenschaften hat.  Es ist jedoch interessant, dass sich in diesem ganzen Zoo ein allgemeiner Trend etabliert hat.  <b>Moderne Hardware und Betriebssysteme bem√ºhen sich darum, dass</b> : <br><br><ol><li>  TSC tickt auf jeder CPU im System mit der gleichen Frequenz </li><li>  Diese Frequenz √§ndert sich zeitlich nicht </li><li>  Es gibt keine Verschiebung zwischen TSCs, die auf verschiedenen CPUs ticken </li></ol><br>  Beim Entwerfen meiner Bibliothek habe ich mich entschieden, von dieser Pr√§misse auszugehen und nicht von der Vinaigrette der Hardware-Implementierungen. <br><br><h3>  Die Bibliothek </h3><br>  Ich habe nicht angefangen, auf Hardware-Chips einer Reihe verschiedener Architekturen zu legen.  Stattdessen entschied ich mich f√ºr eine trendorientierte Bibliothek.  Sie hat einen rein empirischen Fokus: <br><br><ol><li>  Damit k√∂nnen Sie die Zuverl√§ssigkeit von TSC als Zeitquelle experimentell √ºberpr√ºfen </li><li>  Au√üerdem k√∂nnen Sie die Parameter experimentell berechnen, die f√ºr die schnelle Umwandlung von Zecken in Nanosekunden erforderlich sind </li><li>  Nat√ºrlich bietet die Bibliothek praktische Schnittstellen zum Lesen von TSC und zum Konvertieren von Zecken in Nanosekunden "on the fly". </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Den Bibliothekscode finden Sie hier.</a>  Es wird nur unter Linux kompiliert und ausgef√ºhrt. <br><br>  Im Code sehen Sie die Details der Implementierung aller Methoden, die sp√§ter erl√§utert werden. <br><br><h3>  TSC-Zuverl√§ssigkeitsbewertung </h3><br>  Die Bibliothek bietet eine Schnittstelle, die zwei Bewertungen zur√ºckgibt: <br><br><ol><li>  maximale Verschiebung zwischen Z√§hlern, die zu verschiedenen CPUs geh√∂ren.  Es werden nur CPUs ber√ºcksichtigt, die dem Prozess zur Verf√ºgung stehen.  Wenn f√ºr einen Prozess beispielsweise drei CPUs verf√ºgbar sind und die TSC auf diesen CPUs gleichzeitig 50, 150, 20 betr√§gt, betr√§gt die maximale Verschiebung 150-20 = 130.  Nat√ºrlich wird die Bibliothek nicht in der Lage sein, experimentell eine echte maximale Verschiebung zu erhalten, aber sie wird eine Sch√§tzung geben, in die diese Verschiebung passt.  Was tun als n√§chstes mit der Bewertung?  Wie benutzt man?  Dies l√∂st bereits den Client-Code.  Die Bedeutung ist jedoch ungef√§hr die folgende.  Die maximale Verschiebung ist der maximale Wert, um den die Dimension, die der Clientcode erstellt, verzerrt werden kann.  Angenommen, in unserem Beispiel mit drei CPUs begann der Client-Code, die Zeit auf CPU3 (wo TSC 20 war) zu messen, und endete auf CPU2 (wo TSC 150 war).  Es stellt sich heraus, dass sich zus√§tzliche 130 Ticks in das gemessene Intervall einschleichen.  Und nie wieder.  Der Unterschied zwischen CPU1 und CPU2 w√ºrde nur 100 Ticks betragen.  Mit einer Sch√§tzung von 130 Ticks (in der Tat wird es viel konservativer sein) kann der Kunde entscheiden, ob ein solcher Verzerrungswert zu ihm passt oder nicht </li><li>  Erh√∂hen sich die TSC-Werte, die nacheinander auf derselben oder verschiedenen CPUs gemessen werden?  Hier ist die Idee.  Nehmen wir an, wir haben mehrere CPUs.  Angenommen, ihre Uhr ist synchronisiert und tickt mit derselben Frequenz.  Wenn Sie dann zuerst die Zeit auf einer CPU messen und dann erneut messen - bereits auf einer der verf√ºgbaren CPUs -, sollte die zweite Ziffer gr√∂√üer sein als die erste. <br><br>  Ich werde diese Sch√§tzung unterhalb der TSC-Monotonie-Sch√§tzung nennen <br></li></ol><br>  Nun wollen wir sehen, wie wir die erste Sch√§tzung erhalten k√∂nnen: <br><br><ol><li>  Einer der f√ºr den Prozess verf√ºgbaren Prozessoren wird als "grundlegend" deklariert. </li><li>  dann werden alle anderen CPUs sortiert und f√ºr jede von ihnen wird die Verschiebung berechnet: <code>TSC___CPU ‚Äì TSC___CPU</code> .  Dies geschieht wie folgt: <br><ul><li>  a) Drei Messwerte werden nacheinander (nacheinander!) <code>TSC_base_1, TSC_current, TSC_base_2</code> : <code>TSC_base_1, TSC_current, TSC_base_2</code> .  Hier zeigt der Strom an, dass der Wert auf der aktuellen CPU und die Basis auf der Basis gemessen wurde </li><li>  b) Die Verschiebung <code>TSC___CPU ‚Äì TSC___CPU</code> muss im Intervall <code>[TSC_current ‚Äì TSC_base_2, TSC_current ‚Äì TSC_base_1]</code> .  Dies setzt voraus, dass TSCs auf beiden CPUs mit der gleichen Frequenz ticken. </li><li>  c) Die Schritte a) -b) werden mehrmals wiederholt.  Der Schnittpunkt aller in Schritt b) erhaltenen Intervalle wird berechnet.  Das resultierende Intervall wird als Sch√§tzung der Verschiebung <code>TSC___CPU ‚Äì TSC___CPU</code> </li></ul><br></li><li>  Nachdem f√ºr jede CPU eine Verschiebungssch√§tzung relativ zur Basis erhalten wurde, ist es einfach, eine Sch√§tzung der maximalen Verschiebung zwischen allen verf√ºgbaren CPUs zu erhalten: <br><ul><li>  a) Das Mindestintervall wird berechnet, das alle in Schritt 2 erhaltenen resultierenden Intervalle enth√§lt </li><li>  b) Die Breite dieses Intervalls wird als Sch√§tzung der maximalen Verschiebung zwischen TSCs verwendet, die auf verschiedenen CPUs ticken </li></ul><br></li></ol><br>  Um die Monotonie in der Bibliothek zu bewerten, wird der folgende Algorithmus implementiert: <br><br><ol><li>  Angenommen, ein Prozess verf√ºgt √ºber N CPU </li><li>  TSC auf CPU1 messen </li><li>  TSC auf CPU2 messen </li><li>  ... </li><li>  TSC auf CPUN messen </li><li>  TSC erneut an CPU1 messen </li><li>  Wir √ºberpr√ºfen, ob die gemessenen Werte vom ersten bis zum letzten monoton ansteigen </li></ol><br>  Hierbei ist es wichtig, dass der erste und der letzte Wert auf derselben CPU gemessen werden.  Und hier ist warum.  Nehmen wir an, wir haben 3 CPUs.  Angenommen, die TSC auf CPU2 ist gegen√ºber der TSC auf CPU1 um +100 Ticks verschoben.  Angenommen, die TSC auf CPU3 ist gegen√ºber der TSC auf CPU2 um +100 Ticks verschoben.  Betrachten Sie die folgende Ereigniskette: <br><br><ul><li>  Lesen Sie die TSC auf CPU1.  Es sei ein Wert von 10 erhalten </li><li>  2 Zecken bestanden </li><li>  Lesen Sie TSC auf CPU2.  Muss 112 sein </li><li>  2 Zecken bestanden </li><li>  Lesen Sie TSC auf CPU3.  Muss 214 sein </li></ul><br>  Bisher sieht die Uhr synchronisiert aus.  Aber lassen Sie uns noch einmal TSC auf CPU1 messen: <br><br><ul><li>  2 Zecken bestanden </li><li>  Lesen Sie die TSC auf CPU1.  Muss 16 sein </li></ul><br>  Ups!  Monotonie ist gebrochen.  Es stellt sich heraus, dass Sie durch Messen des ersten und letzten Werts auf derselben CPU mehr oder weniger gro√üe Verschiebungen zwischen den Uhren erkennen k√∂nnen.  Die n√§chste Frage nat√ºrlich: "Wie gro√ü sind die Schichten?"  Das Ausma√ü der Verschiebung, das erkannt werden kann, h√§ngt von der Zeit ab, die zwischen aufeinanderfolgenden TSC-Messungen vergeht.  Im angegebenen Beispiel sind dies nur 2 Ticks.  Verschiebungen zwischen Stunden, die 2 Ticks √ºberschreiten, werden erkannt.  Im Allgemeinen werden Verschiebungen, die k√ºrzer als die zwischen aufeinanderfolgenden Messungen verstrichene Zeit sind, nicht erkannt.  Je dichter die Messungen in der Zeit sind, desto besser.  Die Genauigkeit beider Sch√§tzungen h√§ngt davon ab.  Je dichter die Messungen sind: <br><br><ul><li>  Je niedriger die maximale Schichtsch√§tzung </li><li>  desto mehr Vertrauen in die Beurteilung der Monotonie </li></ul><br>  Im n√§chsten Abschnitt werden wir dar√ºber sprechen, wie man enge Messungen vornimmt.  Ich m√∂chte hier hinzuf√ºgen, dass die Bibliothek bei der Berechnung der TSC-Zuverl√§ssigkeitssch√§tzungen viel mehr einfache "L√§use" -Pr√ºfungen durchf√ºhrt, zum Beispiel: <br><br><ul><li>  eingeschr√§nkte √úberpr√ºfung, ob TSCs auf verschiedenen CPUs mit derselben Geschwindigkeit ticken </li><li>  √úberpr√ºfen Sie, ob sich die Z√§hler im Laufe der Zeit wirklich √§ndern und nicht nur den gleichen Wert anzeigen </li></ul><br><h3>  Zwei Methoden zum Sammeln von Z√§hlerwerten </h3><br>  In der Bibliothek habe ich zwei Methoden zum Sammeln von TSC-Werten implementiert: <br><br><ol><li>  <b>Zwischen CPU wechseln</b> .  Bei dieser Methode werden alle Daten, die zur Bewertung der Zuverl√§ssigkeit der TSC erforderlich sind, von einem einzelnen Thread erfasst, der von einer CPU zur anderen springt.  Beide im vorherigen Abschnitt beschriebenen Algorithmen sind f√ºr diese Methode geeignet und f√ºr die andere nicht. <br>  "Umschalten zwischen der CPU" hat keinen praktischen Nutzen.  Die Methode wurde nur implementiert, um "herumzuspielen".  Das Problem bei der Methode ist, dass die Zeit, die erforderlich ist, um einen Stream von einer CPU auf eine andere zu ziehen, sehr gro√ü ist.  Dementsprechend vergeht zwischen aufeinanderfolgenden TSC-Messungen viel Zeit, und die Genauigkeit der Sch√§tzungen ist sehr gering.  Beispielsweise wird eine typische Sch√§tzung f√ºr die maximale Verschiebung zwischen TSC im Bereich von 23.000 Zecken erhalten. <br><br>  Das Verfahren hat jedoch einige Vorteile: <br><ul><li>  es ist absolut deterministisch.  Wenn Sie TSC nacheinander an CPU1, CPU2, CPU3 messen m√ºssen, nehmen wir es einfach und tun es: Wechseln Sie zu CPU1, lesen Sie TSC, wechseln Sie zu CPU2, lesen Sie TSC und wechseln Sie schlie√ülich zu CPU3, lesen Sie TSC </li><li>  Wenn die Anzahl der CPUs im System sehr schnell zunimmt, sollte die Umschaltzeit zwischen ihnen vermutlich viel langsamer ansteigen.  Daher kann theoretisch anscheinend ein System existieren - ein sehr gro√ües System!  - in denen die Anwendung der Methode gerechtfertigt ist.  Dies ist jedoch unwahrscheinlich </li></ul><br></li><li>  <b>Messungen mit CAS bestellt</b> .  Bei dieser Methode werden Daten parallel von mehreren Threads erfasst.  Jede verf√ºgbare CPU startet einen Thread.  Messungen, die von verschiedenen Threads durchgef√ºhrt werden, werden in einer einzigen Sequenz unter Verwendung der Operation "Vergleichen und Tauschen" angeordnet.  Unten finden Sie einen Code, der zeigt, wie dies gemacht wird. <br>  Die Idee der Methode stammt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fio</a> , einem beliebten Tool zur Erzeugung von E / A-Lasten. <br><br>  Die Zuverl√§ssigkeitssch√§tzungen, die mit der Leistung dieser Methode erhalten wurden, sehen bereits ziemlich gut aus.  Beispielsweise wird bereits eine Sch√§tzung der maximalen Verschiebung auf der Ebene von mehreren hundert Ticks erhalten.  Eine √úberpr√ºfung der Monotonie erm√∂glicht es Ihnen, die Uhr innerhalb von Hunderten von Ticks nicht synchron zu erfassen. <br><br>  Die im vorherigen Abschnitt angegebenen Algorithmen sind jedoch f√ºr diese Methode nicht geeignet.  F√ºr sie ist es wichtig, dass die TSC-Werte in einer vorgegebenen Reihenfolge gemessen werden.  Die Methode der von CAS bestellten Messungen erlaubt dies nicht.  Stattdessen wird zuerst eine lange Folge von Zufallsmessungen gesammelt, und dann versuchen (bereits unterschiedliche) Algorithmen, Werte zu finden, die auf ‚Äûgeeigneten‚Äú CPUs in dieser Folge gelesen werden. <br><br>  Ich werde diese Algorithmen hier nicht angeben, um Ihre Aufmerksamkeit nicht zu missbrauchen.  Sie k√∂nnen sie im Code sehen.  Es gibt viele Kommentare.  Theoretisch sind diese Algorithmen gleich.  Ein grundlegend neuer Punkt ist die √úberpr√ºfung, wie zuf√§llig typisierte TSC-Sequenzen statistisch ‚Äûqualitativ‚Äú sind.  Es ist auch m√∂glich, ein akzeptables Mindestma√ü an statistischer Signifikanz f√ºr TSC-Zuverl√§ssigkeitssch√§tzungen festzulegen. <br><br>  Theoretisch kann bei SEHR gro√üen Systemen die Methode ‚ÄûCAS-geordnet‚Äú zu schlechten Ergebnissen f√ºhren.  Das Verfahren erfordert, dass Prozessoren um den Zugriff auf einen gemeinsamen Speicherort konkurrieren.  Wenn es viele Prozessoren gibt, kann sich der Wettbewerb als sehr intensiv herausstellen.  Infolgedessen wird es schwierig sein, eine Messsequenz mit guten statistischen Eigenschaften zu erstellen.  Im Moment scheint diese Situation jedoch unwahrscheinlich. <br></li></ol><br>  Ich habe Code versprochen.  So sieht es aus, wenn Sie mit CAS Messungen in einer einzigen Kette erstellen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg-&gt;probes_count; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> seq_num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> tsc_val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { __atomic_load( seq_counter, &amp;seq_num, __ATOMIC_ACQUIRE); __sync_synchronize(); tsc_val = WTMLIB_GET_TSC(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !__atomic_compare_exchange_n( seq_counter, &amp;seq_num, seq_num + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, __ATOMIC_ACQ_REL, __ATOMIC_RELAXED)); arg-&gt;tsc_probes[i].seq_num = seq_num; arg-&gt;tsc_probes[i].tsc_val = tsc_val; }</code> </pre><br>  Dieser Code wird auf jeder verf√ºgbaren CPU ausgef√ºhrt.  Alle Threads haben Zugriff auf die gemeinsam genutzte Variable <code>seq_counter</code> .  Vor dem Lesen der TSC liest der Stream den Wert dieser Variablen und speichert ihn in der Variablen <code>seq_num</code> .  Dann liest TSC.  Dann wird versucht, seq_counter atomar um eins zu erh√∂hen, jedoch nur, wenn sich der Wert der Variablen seit dem Lesen nicht ge√§ndert hat.  Wenn die Operation erfolgreich ist, bedeutet dies, dass es dem Thread gelungen ist, die in <code>seq_num</code> hinter dem gemessenen TSC-Wert gespeicherte <code>seq_num</code> .  Die n√§chste Seriennummer, die (m√∂glicherweise bereits in einem anderen Thread) eingesetzt werden kann, ist eine weitere.  Diese Nummer wird der Variablen <code>seq_counter</code> entnommen, und jeder erfolgreiche Aufruf von <code>__atomic_compare_exchange_n()</code> erh√∂ht diese Variable um eins. <br><br><div class="spoiler">  <b class="spoiler_title">__atomic mit __sync ???</b> <div class="spoiler_text">  Aus Gr√ºnden der <code>__atomic</code> sollte beachtet werden, dass die Verwendung der integrierten Funktionen der <code>__atomic</code> Familie zusammen mit einer Funktion aus der veralteten <code>__sync</code> Familie h√§sslich aussieht.  <code>__sync_synchronize()</code> im Code verwendet, um zu vermeiden, dass die TSC-Leseoperation mit der Upstream-Operation neu angeordnet wird.  Dies erfordert eine vollst√§ndige Speicherbarriere.  Die <code>__atomic</code> Familie hat formal keine Funktion mit den entsprechenden Eigenschaften.  Obwohl es tats√§chlich gibt: <code>__atomic_signal_fence()</code> .  Diese Funktion organisiert Stream-Berechnungen mit Signalhandlern, die auf demselben Stream ausgef√ºhrt werden.  In der Tat ist dies eine vollst√§ndige Barriere.  Dies wird jedoch nicht ausdr√ºcklich angegeben.  Und ich bevorzuge Code ohne versteckte Semantik.  Daher ist <code>__sync_synchronize()</code> eine Stop-Full-Speicherbarriere. <br></div></div><br>  Ein weiterer erw√§hnenswerter Punkt ist die Sorgfalt, dass alle an Messungen beteiligten Fl√ºsse mehr oder weniger gleichzeitig beginnen.  Wir sind daran interessiert, dass die auf verschiedenen CPUs gelesenen TSC-Werte so gemischt wie m√∂glich sind.  Wir sind nicht zufrieden mit der Situation, in der beispielsweise ein Thread zuerst startet, seine Arbeit beendet und erst dann alle anderen beginnen.  Die resultierende TSC-Sequenz hat nutzlose Eigenschaften.  Daraus k√∂nnen keine Sch√§tzungen gezogen werden.  Der gleichzeitige Start aller Threads ist wichtig - und daf√ºr wurden Ma√ünahmen in der Bibliothek ergriffen. <br><br><h3>  Konvertieren Sie Zecken im laufenden Betrieb in Nanosekunden </h3><br>  Nach √úberpr√ºfung der Zuverl√§ssigkeit von TSC besteht der zweite Hauptzweck der Bibliothek darin, Zecken im laufenden Betrieb in Nanosekunden umzuwandeln.  Die Idee dieser Umstellung habe ich dem bereits erw√§hnten Fio entlehnt.  Ich musste jedoch einige signifikante Verbesserungen vornehmen, da das Konvertierungsverfahren, wie meine Analyse gezeigt hat, in fio selbst nicht gut genug funktioniert.  Dort erhalten Sie eine geringe Genauigkeit. <br><br>  Ich beginne mit einem Beispiel. <br><br>  Idealerweise m√∂chte ich Zecken wie folgt in Nanosekunden umwandeln: <br> <code>ns_time = tsc_ticks / tsc_per_ns</code> <br>  Wir m√∂chten, dass der Zeitaufwand f√ºr die Konvertierung minimal ist.  Daher m√∂chten wir ausschlie√ülich ganzzahlige Arithmetik verwenden.  Mal sehen, wie uns das bedrohen kann. <br><br>  Wenn <code>tsc_per_ns = 3</code> , <code>tsc_per_ns = 3</code> eine einfache Ganzzahldivision unter dem Gesichtspunkt der Genauigkeit <code>ns_time = tsc_ticks / 3</code> : <code>ns_time = tsc_ticks / 3</code> . <br><br>  Aber was ist, wenn <code>tsc_per_ns = 3.333</code> ?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn diese Zahl auf 3 gerundet wird, ist die Konvertierungsgenauigkeit sehr gering. Zur L√∂sung dieses Problems wie folgt: </font></font><br> <code>ns_time = (tsc_ticks * factor) / (3.333 * factor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Faktor </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gro√ü genug ist, ist die Genauigkeit gut. Aber etwas wird schlecht bleiben. Konvertierungsaufwand. Die Ganzzahldivision ist eine sehr teure Operation. Auf x86 sind beispielsweise mehr als 10 Taktzyklen erforderlich. Au√üerdem werden Operationen zur Ganzzahldivision nicht immer per Pipeline ausgef√ºhrt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir schreiben unsere Formel in der entsprechenden Form </font></font><br> <code>ns_time = (tsc_ticks * factor / 3.333) / factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Division ist kein Problem. Wir k√∂nnen </font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Voraus </font><font style="vertical-align: inherit;">vorberechnen </font><font style="vertical-align: inherit;">. Aber die zweite Liga ist immer noch Schmerz. Um sie loszuwerden, w√§hlen wir</font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich der Potenz von zwei. Danach kann die zweite Abteilung durch eine Bitverschiebung ersetzt werden - eine einfache und schnelle Operation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie gro√ü kannst du w√§hlen </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Leider kann </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es nicht beliebig gro√ü sein. Es ist durch die Bedingung begrenzt, dass die Multiplikation im Z√§hler nicht zu einem √úberlauf des 64-Bit-Typs f√ºhren darf. Ja, wir m√∂chten nur "native" Typen verwenden. Auch hier, um den Conversion-Overhead auf ein Minimum zu beschr√§nken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun wollen wir sehen, wie gro√ü es </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in unserem speziellen Beispiel sein kann. Angenommen, wir m√∂chten mit Zeitintervallen von bis zu einem Jahr arbeiten. Im </font><font style="vertical-align: inherit;">Laufe des Jahres tiknet TSC mal folgenden: </font></font><code>3.333 * 1000000000 * 60 * 60 * 24 * 365 = 105109488000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Unterteile </font><font style="vertical-align: inherit;">ein Maximalwert von 64-Bit - </font><font style="vertical-align: inherit;">Typennummer ist: </font></font><code>18446744073709551615 / 105109488000000000 ~ 175.5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Also der Ausdruck</font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte nicht gr√∂√üer als dieser Wert sein. Dann haben wir </font></font><code>factor &lt;= 175.5 * 3.333 ~ 584.9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die gr√∂√üte Zweierpotenz, die diese Zahl nicht √ºberschreitet, ist 512. Daher hat unsere Umrechnungsformel die Form: </font></font><br><br> <code>ns_time = (tsc_ticks * 512 / 3.333) / 512</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oder: </font></font><br><br> <code>ns_time = tsc_ticks * 153 / 512</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fein. Lassen Sie uns nun mit Genauigkeit sehen, was diese Formel hat. Ein Jahr enth√§lt </font></font><code>1000000000 * 60 * 60 * 24 * 365 = 31536000000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nanosekunden. Unsere Formel ergibt: </font></font><code>105109488000000000 * 153 / 512 = 31409671218750000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Differenz zum Barwert betr√§gt 126328781250000 Nanosekunden oder </font></font><code>126328781250000 / 1000000000 / 60 / 60 ~ 35</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stunden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist ein gro√üer Fehler. Wir wollen eine bessere Genauigkeit. Was ist, wenn wir Zeitintervalle von nicht mehr als einer Stunde messen? Ich werde die Berechnungen weglassen. Sie sind v√∂llig identisch mit denen, die gerade gemacht wurden. Die endg√ºltige Formel lautet: </font></font><br><br> <code>ns_time = tsc_ticks * 1258417 / 4194304</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Konvertierungsfehler betr√§gt nur 119.305 Nanosekunden pro 1 Stunde (was weniger als 0,2 Millisekunden entspricht). Sehr sehr gut. Wenn der maximale konvertierbare Wert noch weniger als eine Stunde betr√§gt, ist die Genauigkeit sogar noch besser. Aber wie nutzen wir das? Zeitmessungen nicht auf eine Stunde beschr√§nken? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Achten Sie </font><font style="vertical-align: inherit;">auf den folgenden Punkt: </font></font><br><br> <code>tsc_ticks = (tsc_ticks_per_1_hour * number_of_hours) + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir Vorkalkulation </font></font><code>tsc_ticks_per_1_hour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, k√∂nnen wir extrahieren </font></font><code>number_of_hours</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Als n√§chstes wissen wir, wie viele Nanosekunden in einer Stunde enthalten sind. Daher wird es f√ºr uns nicht schwierig sein, den Teil </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der einer ganzen Anzahl von Stunden entspricht, </font><font style="vertical-align: inherit;">in Nanosekunden zu √ºbersetzen </font><font style="vertical-align: inherit;">. Um die Konvertierung abzuschlie√üen, m√ºssen wir in Nanosekunden √ºbersetzen</font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir wissen jedoch, dass diese Anzahl von Zecken in weniger als einer Stunde auftrat. Um es in Nanosekunden umzuwandeln, k√∂nnen wir die Formel (1) verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertig. Ein solcher Umwandlungsmechanismus passt zu uns. Lassen Sie es uns jetzt zusammenfassen und optimieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst m√∂chten wir eine flexible Kontrolle √ºber Konvertierungsfehler haben. Wir m√∂chten die Konvertierungsparameter nicht an ein Zeitintervall von 1 Stunde binden. Es sei ein beliebiges Zeitintervall: Denken Sie noch </font></font><br><br> <code>tsc_ticks = modulus * number_of_moduli_periods + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einmal daran, wie der Rest in Nanosekunden konvertiert wird: </font></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * factor / tsc_per_nsec) / factor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir berechnen die Konvertierungsparameter (das wissen wir </font></font><code>tsc_ticks_remainder &lt; modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br><br> <code>modulus * (factor / tsc_per_nsec) &lt;= UINT64_MAX <br> factor &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br> 2 ^ shift &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus Gr√ºnden der Langeweile ist anzumerken, dass die letzte Ungleichung im Rahmen der Ganzzahlarithmetik nicht der ersten entspricht. Aber ich werde nicht lange darauf eingehen. Ich kann nur sagen, dass die letzte Ungleichung schwerwiegender ist als die erste und daher sicher zu verwenden ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir aus der letzten Ungleichung erhalten haben </font></font><code>shift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, berechnen wir: </font><font style="vertical-align: inherit;">Und dann werden diese Parameter verwendet, um den Rest in Nanosekunden umzuwandeln: </font><font style="vertical-align: inherit;">Also haben wir die Restumrechnung herausgefunden. Das n√§chste zu l√∂sende Problem - ist die Entfernung </font><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">aus </font><font style="vertical-align: inherit;">. Wie immer wollen wir es schnell machen. Wie immer wollen wir keine Division verwenden. Deshalb w√§hlen wir einfach </font><font style="vertical-align: inherit;">gleich der Zweierpotenz: </font><font style="vertical-align: inherit;">Dann:</font></font><br><br> <code>factor = 2 ^ shift <br> mult = factor / tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * mult) &gt;&gt; shift <br></code> <br><br><font style="vertical-align: inherit;"></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"></font><code>number_of_moduli_periods</code><font style="vertical-align: inherit;"></font><code>tsc_ticks</code><font style="vertical-align: inherit;"></font><code>modulus</code><font style="vertical-align: inherit;"></font><br><br> <code>modulus = 2 ^ remainder_bit_length</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length <br> tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> <br> <br>  Gro√üartig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir wissen jetzt, wie man aus </font></font><code>tsc_ticks</code> <code>number_of_moduli_periods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">extrahiert </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und wir wissen, wie man </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Nanosekunden </font><font style="vertical-align: inherit;">umwandelt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es bleibt zu verstehen, wie dieser Teil der Zecken, der ein Vielfaches ist, in Nanosekunden umgewandelt wird </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber alles ist einfach: </font></font><br><br> <code>ns_per_moduli = ns_per_modulus * number_of_moduli_periods</code> <br> <br> <code>ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen im Voraus rechnen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus nach der gleichen Formel, nach der wir den Rest umrechnen. </font><font style="vertical-align: inherit;">Diese Formel kann f√ºr Zeitr√§ume verwendet werden, die nicht l√§nger als sind </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Er selbst </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nat√ºrlich nicht l√§nger als </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <code>ns_per_modulus = (modulus * mult) &gt;&gt; shift</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist alles! </font><font style="vertical-align: inherit;">Wir konnten alle Parameter berechnen, die erforderlich sind, um Zecken im laufenden Betrieb in Nanosekunden umzuwandeln. </font><font style="vertical-align: inherit;">Fassen Sie nun das Konvertierungsverfahren kurz zusammen:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir haben </font></font><code>tsc_ticks</code> </li><li> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length</code> </li> <li> <code>tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> </li> <li> <code>ns = ns_per_modulus * number_of_moduli_periods + (tsc_ticks_remainder * mult) &gt;&gt; shift</code> </li> </ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei diesem Verfahren werden Parameter </font></font><code>remainder_bit_length</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>modulus, ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>shift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorkalkulation voraus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diesen Beitrag noch lesen, sind Sie gro√üartig oder gro√üartig. </font><font style="vertical-align: inherit;">Es ist sogar m√∂glich, dass Sie ein Performance-Analyst oder Entwickler von Hochleistungssoftware sind.</font></font><br><br>  Also.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellt sich heraus, dass wir noch nicht fertig sind :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erinnerst du dich, wie wir den Parameter berechnet haben </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Es war so: </font></font><br><br> <code>mult = factor / tsc_per_nsec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frage: Woher kommt es </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der Zecken in einer Nanosekunde ist ein sehr kleiner Wert. </font><font style="vertical-align: inherit;">Tats√§chlich </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird </font><font style="vertical-align: inherit;">stattdessen meine Bibliothek </font><font style="vertical-align: inherit;">verwendet </font></font><code>(tsc_per_sec / 1000000000)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font> Das hei√üt: <br><br> <code>mult = factor * 1000000000 / tsc_per_sec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und es gibt zwei interessante Fragen: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nicht </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Beispiel?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Woher bekommen diese </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit dem ersten. Fio verwendet jetzt tats√§chlich die Anzahl der Ticks pro Millisekunde. Und damit gibt es Probleme. Auf der Maschine, die Parameter , </font><font style="vertical-align: inherit;">von denen ich oben genannt </font></font><code>tsc_per_msec = 2599998</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. W√§hrend </font></font><code>tsc_per_sec = 2599998971</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn wir diese Zahlen auf eine Skala bringen, liegt ihr Verh√§ltnis sehr nahe bei Eins: 0,999999626. Wenn wir jedoch die erste und nicht die zweite verwenden, haben wir f√ºr jede Sekunde einen Fehler von 374 Nanosekunden. Deshalb - </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiter ... Wie z√§hlt man </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies erfolgt auf der Grundlage einer direkten Messung: </font><font style="vertical-align: inherit;">‚Äûeinige Zeit‚Äú ist ein konfigurierbarer Parameter. Sie kann gr√∂√üer, kleiner oder gleich einer Sekunde sein. Nehmen wir an, es ist eine halbe Sekunde. Nehmen wir weiter an, dass der tats√§chliche Unterschied zwischen </font><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">0,6 Sekunden betrug. Dann </font><font style="vertical-align: inherit;">.</font></font><br><br> <code>start_sytem_time = clock_gettime() <br> start_tsc = WTMLIB_GET_TSC() <br>  -  <br> end_system_time = clock_gettime() <br> end_tsc = WTMLIB_GET_TSC() <br></code> <br><br><font style="vertical-align: inherit;"></font><code>end_system_time</code><font style="vertical-align: inherit;"></font><code>start_system_time</code><font style="vertical-align: inherit;"></font><code>tsc_per_sec = (end_tsc ‚Äì start_tsc) / 0,6</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bibliothek ber√ºcksichtigt auf diese Weise mehrere Werte </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mit Standardmethoden werden sie dann von statistischem Rauschen ‚Äûgereinigt‚Äú und erhalten einen einzigen </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vertrauensw√ºrdigen </font><font style="vertical-align: inherit;">Wert </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im obigen Zeitmessdiagramm ist die Reihenfolge der Anrufe </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">wichtig </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es ist wichtig, </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dass zwischen zwei Anrufen dieselbe Zeit vergeht wie zwischen zwei Anrufen </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dann ist es m√∂glich, die Systemzeit leicht mit TSC-Ticks zu korrelieren. Und dann kann die Streuung der Werte </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wirklich als zuf√§llig angesehen werden. Bei diesem Messschema </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weichen </font><font style="vertical-align: inherit;">die Werte </font><font style="vertical-align: inherit;">mit der gleichen Wahrscheinlichkeit in beide Richtungen vom Durchschnittswert ab. Und es wird m√∂glich sein, Standardfiltermethoden auf sie anzuwenden.</font></font><br><br><h3>  Fazit </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht ist das alles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Thema der effektiven Zeitmessung ist jedoch nicht darauf beschr√§nkt. </font><font style="vertical-align: inherit;">Es gibt viele Nuancen. </font><font style="vertical-align: inherit;">F√ºr Interessierte schlage ich vor, unabh√§ngig an folgenden Themen zu arbeiten:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichern von Konvertierungsparametern im Cache oder - noch besser - in Registern </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis zu welchen Grenzen kann reduziert werden </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wodurch die Genauigkeit der Konvertierung erh√∂ht wird)?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wir gesehen haben, wird die Konvertierungsgenauigkeit nicht nur beeinflusst </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sondern auch durch die Gr√∂√üe des Zeitintervalls, das mit Ticks ( </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">korreliert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie kann der Einfluss beider Faktoren ausgeglichen werden?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TSC in der virtuellen Maschine. </font><font style="vertical-align: inherit;">Kann ich es benutzen?</font></font></li><li>        . , fio        timespec.    : <br><br> <code>tp-&gt;tv_sec = nsecs / 1000000000ULL;</code> <br> <br> ,   TSC          .         ,  ,      <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit den in diesem Artikel beschriebenen Methoden k√∂nnen wir die Zeitskala einer Sekunde mit einer Genauigkeit in der Gr√∂√üenordnung von mehreren zehn Nanosekunden messen. </font><font style="vertical-align: inherit;">Dies ist die Genauigkeit, die ich bei der Verwendung meiner Bibliothek tats√§chlich beobachte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interessanterweise verliert das Fio, von dem ich einige Methoden ausgeliehen habe, auf einer zweiten Skala genau 700-900 Nanosekunden (und daf√ºr gibt es drei Gr√ºnde). </font><font style="vertical-align: inherit;">Au√üerdem verliert die Konvertierungsgeschwindigkeit aufgrund der Speicherung von Zeit in einem Standard-Linux-Format. </font><font style="vertical-align: inherit;">Ich beeile mich jedoch, Fio-Fans zu beruhigen. </font><font style="vertical-align: inherit;">Ich habe Entwicklern eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschreibung aller Konvertierungsprobleme</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gesendet </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">, die ich entdeckt habe</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die Leute arbeiten bereits, sie werden es bald beheben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich w√ºnsche Ihnen viele angenehme Nanosekunden!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425237/">https://habr.com/ru/post/de425237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425227/index.html">Forscher haben einen Weg gefunden, Honeytoken-Schl√ºssel in einer Reihe von Amazon-Diensten zu erkennen und zu umgehen.</a></li>
<li><a href="../de425229/index.html">Wie wir CDN MegaFon.TV geholfen haben, die Weltmeisterschaft 2018 nicht zu erreichen</a></li>
<li><a href="../de425231/index.html">FAQ √ºber die Arbeit einer Stewardess</a></li>
<li><a href="../de425233/index.html">Python 3 auf Facebook</a></li>
<li><a href="../de425235/index.html">Ein wenig mehr √ºber Diagramme oder das Erkennen von Abh√§ngigkeiten zwischen Ihren Anwendungen</a></li>
<li><a href="../de425241/index.html">Entwickler 20 Jahre sp√§ter: Vasily Lebedev √ºber ICRE, Bildung, sein Buch und Programmierung</a></li>
<li><a href="../de425243/index.html">Das John Willis Handbuch</a></li>
<li><a href="../de425245/index.html">Ank√ºndigung von RamblerFront & # 6</a></li>
<li><a href="../de425247/index.html">Crowdsourcing beim Testen</a></li>
<li><a href="../de425249/index.html">Wie ist die Bekanntschaft mit LLP an der ITMO University: der Kurs "Low-Level Programming"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>