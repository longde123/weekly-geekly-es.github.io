<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèΩ üôé üîº Impl√©mentation d'un rechargement √† chaud du code C ++ sous Linux üï∫üèº üå•Ô∏è üëÜüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Lien vers la biblioth√®que √† la fin de l'article. L'article lui-m√™me d√©crit les m√©canismes mis en ≈ìuvre dans la biblioth√®que, avec des d√©tails moyens...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Impl√©mentation d'un rechargement √† chaud du code C ++ sous Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435260/"><p><img src="https://alexpolt.github.io/images/stroustrup-didnt-plan-for-this.png" alt="image"></p><br><p>  * Lien vers la biblioth√®que √† la fin de l'article.  L'article lui-m√™me d√©crit les m√©canismes mis en ≈ìuvre dans la biblioth√®que, avec des d√©tails moyens.  L'impl√©mentation pour macOS n'est pas encore termin√©e, mais elle n'est pas tr√®s diff√©rente de l'impl√©mentation pour Linux.  Il s'agit principalement d'une impl√©mentation pour Linux. </p><br><p>  En parcourant le github un samedi apr√®s-midi, je suis tomb√© sur une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">biblioth√®que</a> qui impl√©mente la mise √† jour du code c ++ √† la vol√©e pour Windows.  Je suis moi-m√™me descendu de Windows il y a quelques ann√©es, je ne l'ai pas regrett√© un peu, et maintenant toute la programmation se fait soit sur Linux (√† la maison) soit sur macOS (au travail).  Googler un peu, j'ai trouv√© que l'approche de la biblioth√®que ci-dessus est assez populaire, et msvc utilise la m√™me technique pour la fonction "Modifier et continuer" dans Visual Studio.  Le seul probl√®me est que je n'ai trouv√© aucune impl√©mentation sous non-windows (ai-je mal regard√©?).  √Ä la question √† l'auteur de la biblioth√®que ci-dessus s'il fera un portage pour d'autres plateformes, la r√©ponse √©tait non. </p><br><p>  Je <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dois dire tout de suite</a> que je n'√©tais int√©ress√© que par l'option dans laquelle je n'aurais pas √† modifier le code de projet existant (comme, par exemple, dans le cas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RCCPP</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cr</a> , o√π tout le code potentiellement recharg√© devrait √™tre dans une biblioth√®que s√©par√©e charg√©e dynamiquement). </p><br><p>  "Comment √ßa?"  - J'ai pens√©, et j'ai commenc√© √† allumer de l'encens. </p><a name="habracut"></a><br><h2 id="zachem">  Pourquoi? </h2><br><p>  Je fais principalement du gamedev.  La plupart de mon temps de travail est consacr√© √† l'√©criture de la logique du jeu et √† la disposition de tout visuel.  J'utilise √©galement imgui pour les utilitaires d'assistance.  Mon cycle de travail avec le code, comme vous l'avez probablement devin√©, est √âcrire -&gt; Compiler -&gt; Ex√©cuter -&gt; R√©p√©ter.  Tout se passe assez rapidement (build incr√©mental, toutes sortes de ccache, etc.).  Le probl√®me ici est que ce cycle doit √™tre r√©p√©t√© assez souvent.  Par exemple, j'√©cris une nouvelle m√©canique de jeu, que ce soit "Jump", un Jump valide et contr√¥l√©: </p><br><p>  1. R√©daction d'un projet de mise en ≈ìuvre bas√© sur l'√©lan, assembl√©, lanc√©.  J'ai vu que j'applique accidentellement une impulsion √† chaque image, et pas une seule fois. </p><br><p>  2. Fix√©, assembl√©, lanc√©, maintenant normal.  Mais il faudrait prendre davantage la valeur absolue de l'impulsion. </p><br><p>  3. Fix√©, assembl√©, lanc√©, fonctionnant.  Mais d'une mani√®re ou d'une autre, cela ne va pas.  Nous devons essayer de le faire sur la base de la force. </p><br><p>  4. R√©daction d'un projet de mise en ≈ìuvre bas√© sur la force, assembl√©, lanc√©, travaux.  Il suffirait seulement de changer la vitesse instantan√©e au moment du saut. <br>  ... </p><br><p> 10. Fix√©, assembl√©, lanc√©, fonctionnant.  Mais toujours pas √ßa.  Il faudra probablement essayer une impl√©mentation bas√©e sur un changement de <code>gravityScale</code> . <br>  ... </p><br><p>  20. Super, √ßa a l'air super!  Maintenant, nous retirons tous les param√®tres dans l'√©diteur pour le gamediz, testons et remplissons. <br>  ... </p><br><p>  30. Le saut est pr√™t. </p><br><p>  Et √† chaque it√©ration, vous devez collecter le code et dans l'application lanc√©e arriver √† l'endroit o√π je peux sauter.  Cela prend g√©n√©ralement au moins 10 secondes.  Et si je ne peux sauter que dans une zone ouverte, laquelle doit encore √™tre atteinte?  Et si j'ai besoin de pouvoir sauter sur des blocs d'une hauteur de N unit√©s?  Ici, j'ai d√©j√† besoin de collecter une sc√®ne de test, qui doit √©galement √™tre d√©bogu√©e et qui doit √©galement passer du temps.  C'est pour de telles it√©rations qu'un rechargement √† chaud de code serait id√©al.  Bien s√ªr, ce n'est pas une panac√©e, elle ne convient pas √† tout, et apr√®s un red√©marrage, vous devez parfois recr√©er une partie du monde du jeu, et cela doit √™tre pris en compte.  Mais √† bien des √©gards, cela peut √™tre utile et peut √©conomiser de l'attention et beaucoup de temps. </p><br><h2 id="trebovaniya-i-postanovka-zadachi">  Exigences et √©nonc√© du probl√®me </h2><br><ul><li>  Lors de la modification du code, la nouvelle version de toutes les fonctions doit remplacer les anciennes versions des m√™mes fonctions </li><li>  Cela devrait fonctionner sur Linux et macOS </li><li>  Cela ne devrait pas n√©cessiter de modifications du code d'application existant. </li><li>  Id√©alement, il devrait s'agir d'une biblioth√®que, li√©e statiquement ou dynamiquement √† l'application, sans utilitaires tiers </li><li>  Il est souhaitable que cette biblioth√®que n'affecte pas beaucoup les performances de l'application. </li><li>  Assez si cela fonctionne avec cmake + make / ninja </li><li>  Cela suffit si cela fonctionne avec les versions de Debazine (sans optimisations, sans d√©coupage des caract√®res, etc.) </li></ul><br><p>  Il s'agit de l'ensemble minimal d'exigences qu'une impl√©mentation doit satisfaire.  √Ä l'avenir, je d√©crirai bri√®vement ce qui a √©galement √©t√© mis en ≈ìuvre: </p><br><ul><li>  Transfert de valeurs de variables statiques dans un nouveau code (voir la section "Transfert de variables statiques" pour savoir pourquoi cela est important) </li><li>  Rechargement bas√© sur les d√©pendances (en-t√™te modifi√© -&gt; reconstruit <del>  un demi-projet </del>  tous les fichiers d√©pendants) </li><li>  Rechargement de code √† partir de biblioth√®ques dynamiques </li></ul><br><h2 id="realizaciya">  Impl√©mentation </h2><br><p>  Jusqu'√† ce moment, j'√©tais compl√®tement loin du sujet, donc j'ai d√ª collecter et assimiler des informations √† partir de z√©ro. </p><br><p>  √Ä un niveau √©lev√©, le m√©canisme ressemble √† ceci: </p><br><ul><li>  Nous surveillons le syst√®me de fichiers pour les changements dans la source </li><li>  Lorsque la source change, la biblioth√®que la reconstruit √† l'aide de la commande de compilation que ce fichier a d√©j√† √©t√© compil√© </li><li>  Tous les objets collect√©s sont li√©s √† une biblioth√®que charg√©e dynamiquement </li><li>  La biblioth√®que est charg√©e dans l'espace d'adressage du processus </li><li>  Toutes les fonctions de la biblioth√®que remplacent les m√™mes fonctions dans l'application. </li><li>  Les valeurs des variables statiques sont transf√©r√©es de l'application vers la biblioth√®que </li></ul><br><p>  Commen√ßons par le plus int√©ressant - le m√©canisme de rechargement des fonctions. </p><br><h4 id="perezagruzka-funkciy">  Fonctions de rechargement </h4><br><p>  Voici 3 fa√ßons plus ou moins populaires de remplacer des fonctions dans (ou presque) l'ex√©cution: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Astuce avec LD_PRELOAD</a> - vous permet de construire une biblioth√®que charg√©e dynamiquement avec, par exemple, la fonction <code>strcpy</code> , et de faire en sorte que lorsque vous d√©marrez l'application prend ma version de <code>strcpy</code> au lieu de la biblioth√®que </li><li>  Changer les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tables PLT et GOT</a> - vous permet de "surcharger" les fonctions export√©es </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Accrochage des fonctions</a> - vous permet de rediriger le thread d'ex√©cution d'une fonction √† une autre </li></ul><br><p>  Les 2 premi√®res options, √©videmment, ne conviennent pas, car elles ne fonctionnent qu'avec des fonctions export√©es, et nous ne voulons pas marquer toutes les fonctions de notre application avec des attributs.  Par cons√©quent, le crochet de fonction est notre option! </p><br><p>  En bref, le hook fonctionne comme ceci: </p><br><ul><li>  L'adresse de la fonction est trouv√©e </li><li>  Les premiers octets de la fonction sont remplac√©s par une transition inconditionnelle vers le corps d'une autre fonction </li><li>  ... </li><li>  Profit! <br>  Dans msvc, il y a 2 drapeaux pour cela - <code>/hotpatch</code> et <code>/FUNCTIONPADMIN</code> .  Le premier au d√©but de chaque fonction √©crit 2 octets, qui ne font rien, pour leur r√©√©criture ult√©rieure avec un "saut court".  La seconde vous permet de laisser un espace vide devant le corps de chaque fonction sous la forme d'instructions <code>nop</code> pour un "saut en longueur" √† l'emplacement souhait√©, donc en 2 sauts, vous pouvez passer de l'ancienne fonction √† la nouvelle.  Vous pouvez en savoir plus sur la fa√ßon dont cela est impl√©ment√© dans Windows et MSVC, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </li></ul><br><p>  Malheureusement, il n'y a rien de similaire dans clang et gcc (au moins sous Linux et macOS).  En fait, ce n'est pas un gros probl√®me, nous √©crirons directement au-dessus de l'ancienne fonction.  Dans ce cas, nous risquons de rencontrer des probl√®mes si notre application est multithread.  Si g√©n√©ralement dans un environnement multi-thread nous restreignons l'acc√®s aux donn√©es par un thread alors qu'un autre thread les modifie, alors nous devons limiter la possibilit√© d'ex√©cuter du code par un thread tandis qu'un autre thread modifie ce code.  Je n'ai pas compris comment faire cela, donc l'impl√©mentation se comportera de mani√®re impr√©visible dans un environnement multi-thread. </p><br><p>  Il y a un point subtil.  Sur un syst√®me 32 bits, 5 octets nous suffisent pour "sauter" n'importe o√π.  Sur un syst√®me 64 bits, si nous ne voulons pas g√¢cher les registres, nous avons besoin de 14 octets.  L'essentiel est que 14 octets dans l'√©chelle du code machine, c'est beaucoup, et si le code a une fonction de stub avec un corps vide, il aura probablement moins de 14 octets de longueur.  Je ne connais pas toute la v√©rit√©, mais j'ai pass√© quelque temps derri√®re le d√©sassembleur en r√©fl√©chissant, en √©crivant et en d√©boguant le code, et j'ai remarqu√© que toutes les fonctions sont align√©es sur une limite de 16 octets (d√©bogage sans optimisations, pas s√ªr du code optimis√©).  Et cela signifie qu'entre le d√©but de deux fonctions, il y aura au moins 16 octets, ce qui nous suffit de les ¬´brouiller¬ª.  La recherche Google superficielle a conduit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , cependant, je ne sais pas avec certitude, j'ai juste eu de la chance, ou aujourd'hui tous les compilateurs le font.  Dans tous les cas, en cas de doute, d√©clarez simplement quelques variables au d√©but de la fonction stub pour qu'elle devienne suffisamment grande. </p><br><p>  Nous avons donc le premier grain - un m√©canisme pour rediriger les fonctions de l'ancienne version vers la nouvelle. </p><br><h4 id="poisk-funkciy-v-skopmilirovannoy-programme">  Rechercher des fonctions dans un programme copi√© </h4><br><p>  Maintenant, nous devons en quelque sorte obtenir les adresses de toutes les fonctions (non seulement export√©es) de notre programme ou d'une biblioth√®que dynamique arbitraire.  Cela peut √™tre fait tout simplement en utilisant l'API syst√®me si les caract√®res ne sont pas supprim√©s de votre application.  Sous Linux, ce sont les api d' <code>elf.h</code> et <code>link.h</code> , sur macOS, <code>loader.h</code> et <code>nlist.h</code> . </p><br><ul><li>  En utilisant <code>dl_iterate_phdr</code> nous <code>dl_iterate_phdr</code> toutes les biblioth√®ques charg√©es et, en fait, le programme </li><li>  Trouvez l'adresse o√π la biblioth√®que est charg√©e </li><li>  De la section <code>.symtab</code> , <code>.symtab</code> obtenons toutes les informations sur les caract√®res, √† savoir le nom, le type, l'index de la section dans laquelle il se trouve, la taille, et calculons √©galement son "vraie" adresse en fonction de l'adresse virtuelle et de l'adresse de chargement de la biblioth√®que </li></ul><br><p>  Il y a une subtilit√©.  Lors du t√©l√©chargement d'un fichier elf, le syst√®me ne charge pas la section <code>.symtab</code> (correcte si elle est incorrecte) et la section <code>.dynsym</code> ne nous convient pas, car nous ne pouvons pas en extraire des caract√®res avec la visibilit√© <code>STV_INTERNAL</code> et <code>STV_HIDDEN</code> .  Autrement dit, nous ne verrons pas de telles fonctions: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp namespace { int someUsefulFunction(int value) // &lt;----- { return value * 2; } }</span></span></code> </pre> <br><p>  et ces variables: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp void someDefaultFunction() { static int someVariable = 0; // &lt;----- ... }</span></span></code> </pre> <br><p>  Ainsi, au paragraphe 3, nous ne travaillons pas avec le programme que <code>dl_iterate_phdr</code> donn√©, mais avec le fichier que nous avons t√©l√©charg√© √† partir du disque et analys√© par un analyseur elfe (ou sur l'api nu).  Donc, nous ne manquons de rien.  Sur macOS, la proc√©dure est similaire, seuls les noms des fonctions de l'api syst√®me sont diff√©rents. </p><br><p>  Apr√®s cela, nous filtrons tous les caract√®res et enregistrons uniquement: </p><br><ul><li>  Les fonctions qui peuvent √™tre recharg√©es sont des caract√®res de type <code>STT_FUNC</code> situ√©s dans la section <code>.text</code> , qui sont de taille non nulle.  Un tel filtre ignore uniquement les fonctions dont le code est r√©ellement contenu dans ce programme ou cette biblioth√®que </li><li>  Les variables statiques dont vous souhaitez transf√©rer les valeurs sont des caract√®res de type <code>STT_OBJECT</code> situ√©s dans la section <code>.bss</code> </li></ul><br><h2 id="edinicy-translyacii">  Unit√©s de diffusion </h2><br><p>  Pour recharger le code, nous devons savoir o√π obtenir les fichiers de code source et comment les compiler. </p><br><p>  Dans la premi√®re impl√©mentation, j'ai lu ces informations dans la section <code>.debug_info</code> , qui contient des informations de d√©bogage au format DWARF.  Pour que chaque unit√© de compilation (ET) dans DWARF obtienne une ligne de compilation pour cet ET, vous devez passer <code>-grecord-gcc-switches</code> pendant la compilation.  DWARF lui-m√™me, j'ai analys√© la biblioth√®que libdwarf, qui est livr√©e avec <code>libelf</code> .  En plus de la commande de compilation de DWARF, vous pouvez obtenir des informations sur les d√©pendances de nos ET sur d'autres fichiers.  Mais j'ai refus√© cette mise en ≈ìuvre pour plusieurs raisons: </p><br><ul><li>  Les biblioth√®ques sont assez lourdes </li><li>  L'analyse d'une application DWARF compil√©e √† partir de ~ 500 ET, avec analyse des d√©pendances, a pris un peu plus de 10 secondes </li></ul><br><p>  10 secondes pour d√©marrer l'application, c'est trop.  Apr√®s r√©flexion, j'ai r√©√©crit la logique de l'analyse de DWARF en analysant <code>compile_commands.json</code> .  Ce fichier peut √™tre g√©n√©r√© simplement en ajoutant <code>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</code> √† votre CMakeLists.txt.  Ainsi, nous obtenons toutes les informations dont nous avons besoin. </p><br><h2 id="obrabotka-zavisimostey">  Gestion des d√©pendances </h2><br><p>  Depuis que nous avons abandonn√© DWARF, nous devons trouver une autre option, comment g√©rer les d√©pendances entre les fichiers.  Je ne voulais vraiment pas analyser les fichiers avec mes mains et y chercher des <code>include</code> , et qui en sait plus sur les d√©pendances que le compilateur lui-m√™me? </p><br><p>  Il existe un certain nombre d'options dans clang et gcc qui g√©n√®rent ce que l'on appelle des fichiers de d√©p√¥t presque gratuitement.  Ces fichiers utilisent les syst√®mes de g√©n√©ration make et ninja pour r√©soudre les d√©pendances entre les fichiers.  Les fichiers de d√©p√¥t ont un format tr√®s simple: </p><br><pre> <code class="plaintext hljs">CMakeFiles/lib_efsw.dir/libs/efsw/src/efsw/DirectorySnapshot.cpp.o: \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/base.hpp \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/sophist.h \ /home/ddovod/_private/_projects/jet/live/libs/efsw/include/efsw/efsw.hpp \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/c++/7.3.0/string \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/c++config.h \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/os_defines.h \ ...</code> </pre> <br><p>  Le compilateur place ces fichiers √† c√¥t√© des fichiers objets pour chaque ET, il nous reste √† les analyser et √† les mettre dans une table de hachage.  L'analyse totale <code>compile_commands.json</code> + depfiles pour les m√™mes 500 ET prend un peu plus d'une seconde.  Pour que tout fonctionne, nous devons ajouter l'indicateur <code>-MD</code> globalement pour tous les fichiers de projet dans l'option de compilation. </p><br><p>  Il y a une subtilit√© associ√©e au ninja.  Ce syst√®me de g√©n√©ration g√©n√®re des fichiers de d√©p√¥t ind√©pendamment de la pr√©sence de l'indicateur <code>-MD</code> pour leurs besoins.  Mais une fois g√©n√©r√©s, il les traduit dans son format binaire et supprime les fichiers source.  Par cons√©quent, lorsque vous d√©marrez ninja, vous devez passer l' <code>-d keepdepfile</code> .  De plus, pour des raisons que je ne <code>-MD</code> pas, dans le cas de make (avec l'option <code>-MD</code> ), le fichier s'appelle <code>some_file.cpp.d</code> , tandis qu'avec ninja il s'appelle <code>some_file.cpp.od</code> .  Par cons√©quent, vous devez v√©rifier les deux versions. </p><br><h2 id="perenos-staticheskih-peremennyh">  Transfert variable statique </h2><br><p>  Supposons que nous ayons un tel code (un exemple tr√®s synth√©tique): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Singleton.hpp class Singletor { public: static Singleton&amp; instance(); }; int veryUsefulFunction(int value); // Singleton.cpp Singleton&amp; Singletor::instance() { static Singleton ins; return ins; } int veryUsefulFunction(int value) { return value * 2; }</span></span></code> </pre> <br><p>  Nous voulons changer la fonction <code>veryUsefulFunction</code> en ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veryUsefulFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value * <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br><p>  Lors du rechargement, dans la biblioth√®que dynamique avec du nouveau code, en plus de <code>veryUsefulFunction</code> , la variable <code>static Singleton ins;</code>  et la m√©thode <code>Singletor::instance</code> .  Par cons√©quent, le programme commencera √† appeler de nouvelles versions des deux fonctions.  Mais les <code>ins</code> statiques de cette biblioth√®que ne sont pas encore initialis√©es et, par cons√©quent, la premi√®re fois que vous y acc√©derez, le constructeur de la classe <code>Singleton</code> sera appel√©.  Bien s√ªr, nous ne voulons pas cela.  Par cons√©quent, l'impl√©mentation transf√®re les valeurs de toutes ces variables qu'elle trouve dans la biblioth√®que dynamique assembl√©e de l'ancien code vers cette biblioth√®que tr√®s dynamique avec le nouveau code avec leurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">variables de garde</a> . </p><br><p>  Il y a un moment subtil et g√©n√©ralement insoluble. <br>  Supposons que nous ayons une classe: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  La m√©thode <code>calledEachUpdate</code> appel√©e 60 fois par seconde.  Nous le changeons en ajoutant un nouveau champ: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; m_someVar2++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  Si une instance de cette classe se trouve dans la m√©moire dynamique ou sur la pile, apr√®s avoir recharg√© le code, l'application risque de se bloquer.  L'instance allou√©e ne contient que la variable <code>m_someVar1</code> , mais apr√®s le red√©marrage, la m√©thode <code>calledEachUpdate</code> tentera de modifier <code>m_someVar2</code> , modifiant ce qui n'appartient pas r√©ellement √† cette instance, ce qui entra√Æne des cons√©quences impr√©visibles.  Dans ce cas, la logique de transfert d'√©tat est transf√©r√©e au programmeur, qui doit d'une mani√®re ou d'une autre sauvegarder l'√©tat de l'objet et supprimer l'objet lui-m√™me avant le rechargement du code, et cr√©er un nouvel objet apr√®s le red√©marrage.  La biblioth√®que fournit des √©v√©nements sous la forme des m√©thodes d√©l√©gu√©es <code>onCodePreLoad</code> et <code>onCodePostLoad</code> que l'application peut traiter. </p><br><p>  Je ne sais pas comment (et si) il est possible de r√©soudre cette situation de mani√®re g√©n√©rale, je pense.  Maintenant ce cas "plus ou moins normal" ne fonctionnera que pour les variables statiques, il utilise la logique suivante: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* oldVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* newVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> oldVarSize = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> newVarSize = ...; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(newVarPtr, oldVarPtr, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(oldVarSize, newVarSize));</code> </pre> <br><p>  Ce n'est pas tr√®s correct, mais c'est le meilleur que j'ai trouv√©. </p><br><p>  Par cons√©quent, le code se comportera de mani√®re impr√©visible si le runtime modifie l'ensemble et la disposition des champs dans les structures de donn√©es.  Il en va de m√™me pour les types polymorphes. </p><br><h2 id="sobiraem-vse-vmeste">  Tout mettre ensemble </h2><br><p>  Comment tout cela fonctionne ensemble. </p><br><ul><li>  La biblioth√®que parcourt les en-t√™tes de toutes les biblioth√®ques charg√©es dynamiquement dans le processus et, en fait, le programme lui-m√™me, analyse et filtre les caract√®res. </li><li>  Ensuite, la biblioth√®que essaie de trouver le fichier <code>compile_commands.json</code> dans le r√©pertoire de l'application et dans les r√©pertoires parents de mani√®re r√©cursive, et en extrait toutes les informations n√©cessaires sur ET. </li><li>  Connaissant le chemin d'acc√®s aux fichiers objets, la biblioth√®que charge et analyse les fichiers de d√©p√¥t. </li><li>  Apr√®s cela, le r√©pertoire le plus courant pour tous les fichiers de code source du programme est calcul√© et la surveillance de ce r√©pertoire commence r√©cursivement. </li><li>  Lorsqu'un fichier change, la biblioth√®que cherche √† voir s'il se trouve dans la table de hachage des d√©pendances et, le cas √©ch√©ant, d√©marre plusieurs processus de compilation des fichiers modifi√©s et leurs d√©pendances en arri√®re-plan, √† l'aide des commandes de compilation de <code>compile_commands.json</code> . </li><li>  Lorsque le programme vous demande de recharger le code (dans mon application, la combinaison <code>Ctrl+r</code> est affect√©e), la biblioth√®que attend la fin des processus de compilation et relie tous les nouveaux objets √† la biblioth√®que dynamique. </li><li>  Cette biblioth√®que est ensuite charg√©e dans l'espace d'adressage du processus √† l' <code>dlopen</code> fonction <code>dlopen</code> . </li><li>  Les informations sur les symboles sont charg√©es √† partir de cette biblioth√®que, et l'intersection compl√®te de l'ensemble des symboles de cette biblioth√®que et des symboles d√©j√† pr√©sents dans le processus est soit recharg√©e (s'il s'agit d'une fonction) soit transf√©r√©e (s'il s'agit d'une variable statique). </li></ul><br><p>  Cela fonctionne tr√®s bien, surtout lorsque vous savez ce qui se cache sous le capot et √† quoi s'attendre, au moins √† un niveau √©lev√©. </p><br><p>  Personnellement, j'ai √©t√© tr√®s surpris par l'absence d'une telle solution pour Linux, cela int√©resse-t-il vraiment quelqu'un? </p><br><p>  Je serai heureux de toute critique, merci! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Lien avec la mise en ≈ìuvre</strong></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435260/">https://habr.com/ru/post/fr435260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435250/index.html">Fonctionnement de l'Universit√© ITMO: visite de notre laboratoire de cyberphysique</a></li>
<li><a href="../fr435252/index.html">Jessica Livingston: ¬´Comment nous avons cr√©√© Y Combinator. La composante √©motionnelle "</a></li>
<li><a href="../fr435254/index.html">Gestion des erreurs fonctionnelles dans Kotlin avec Arrow</a></li>
<li><a href="../fr435256/index.html">Nous √©valuons les recruteurs par lettres froides</a></li>
<li><a href="../fr435258/index.html">Nous √©crivons notre langage de programmation, partie 2: repr√©sentation interm√©diaire des programmes</a></li>
<li><a href="../fr435262/index.html">Li-Fi: l'avenir d'Internet</a></li>
<li><a href="../fr435264/index.html">Modification des prix en RMK. 1C: Gestion du commerce 11</a></li>
<li><a href="../fr435268/index.html">Ne me traitez pas, docteur</a></li>
<li><a href="../fr435270/index.html">Gardez les cl√©s SSH en s√©curit√©</a></li>
<li><a href="../fr435272/index.html">Cyclophobie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>