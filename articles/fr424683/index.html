<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃🏾 👩🏻‍⚖️ 👩🏽‍🤝‍👨🏾 90 nouvelles fonctionnalités (et API) dans JDK 11 ✍🏻 🏉 🍲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article « 90 nouvelles fonctionnalités (et API) dans JDK 11 » de Simon Ritter. 





 Pour beaucoup...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>90 nouvelles fonctionnalités (et API) dans JDK 11</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424683/"><p>  Bonjour, Habr!  Je vous présente la traduction de l'article « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">90 nouvelles fonctionnalités (et API) dans JDK 11</a> » de Simon Ritter. </p><br><p><img src="https://habrastorage.org/webt/nz/8c/f_/nz8cf_erkk_q0xqhz_kptdl772s.jpeg"></p><br><p>  Pour beaucoup, le nouveau cycle de publication JDK de six mois signifie que certains n'ont pas encore compris quelles sont les nouvelles fonctionnalités de JDK 10, et JDK 11 est sur le point. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dans l'un des premiers blogs</a> , les 109 nouvelles fonctionnalités et API a pu être trouvé dans JDK 10. Par conséquent, pour JDK 11, il a été décidé de faire de même.  Cependant, un format différent a été choisi.  Ce message sera divisé en deux sections: les nouvelles fonctionnalités disponibles pour les développeurs (API publique) et tout le reste.  Ainsi, si vous n'êtes intéressé que par ce qui affecte directement votre développement, vous pouvez ignorer la deuxième partie. </p><br><p>  Le nombre total de modifications pouvant être calculées s'est avéré être de 90 (il s'agit de JEP plus de nouvelles classes et méthodes, à l'exclusion des méthodes distinctes pour le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://openjdk.java.net/groups/net/">client HTTP</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Flight Recorder</a> ) ( <em>note du traducteur: Java Flight Recorder (JFR) était l'un des modules complémentaires intégrés d'Oracle dans le JDK, mais à partir de Java 11, grâce au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 328</a> , il a été transféré en open source)</em> .  Bien que JDK 11 ait réussi à trouver onze changements de moins que dans JDK 10, je pense qu'il est juste de dire que davantage de fonctionnalités ont été ajoutées à JDK 11, certainement au niveau de la JVM. </p><a name="habracut"></a><br><h3 id="novye-zametnye-dlya-razrabotchika-fichi">  Nouvelles fonctionnalités visibles par le développeur </h3><br><p>  JDK 11 a quelques changements qui pourraient affecter le style de développement.  Il y a un léger changement de syntaxe, de nombreuses nouvelles API et la possibilité d'exécuter des applications dans un seul fichier sans utiliser de compilateur ( <em>traducteur de notes: soi-disant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichiers shebang</a></em> ).  En outre, le changement majeur (et de rupture) est la suppression du module d'agrégation <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">java.se.ee</a></strong> , qui peut affecter la migration d'une application existante vers JDK 11. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 323: syntaxe de variable locale pour les paramètres Lambda</a></strong> </p><br><p>  Dans JDK 10, l'inférence de variable locale (ou inférence de type) a été introduite ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 286</a> ).  Cela simplifie le code car vous n'avez plus besoin de spécifier explicitement le type de la variable locale, vous pouvez utiliser <strong>var à la</strong> place.  JEP 323 étend l'utilisation de cette syntaxe, qui est désormais également applicable aux paramètres des expressions lambda.  Un exemple simple: </p><br><pre><code class="java hljs">list.stream() .map((<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  Un programmeur Java attentif indiquerait que les expressions lambda ont déjà une inférence de type, donc utiliser var serait (dans ce cas) redondant.  On pourrait tout aussi bien écrire le même code que: </p><br><pre> <code class="java hljs"> list.stream() .map(s -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  Pourquoi ajouter le support var?  La réponse est un cas particulier - lorsque vous souhaitez ajouter une annotation à un paramètre lambda.  Cela ne peut se faire sans aucune implication.  Pour éviter d'utiliser un type explicite, nous pouvons utiliser var pour simplifier les choses, de cette façon: </p><br><pre> <code class="java hljs"> list.stream() .map((<span class="hljs-meta"><span class="hljs-meta">@Notnull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  Cette modification a nécessité des modifications de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la spécification du langage Java (JLS)</a> , en particulier: </p><br><p>  Page 24: La description de l'identifiant spécial var. <br>  Page 627-630: Paramètres Lambda <br>  Page 636: évaluation à l'exécution des expressions Lambda <br>  Page 746: syntaxe Lambda </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 330: lancement de programmes de code source à fichier unique</a></strong> </p><br><p>  L'une des critiques de Java est la redondance de la syntaxe, et la «cérémonie» associée au lancement même d'une application triviale peut augmenter sérieusement le seuil d'entrée pour un débutant.  Pour écrire une application qui affiche simplement «Bonjour tout le monde!», Vous devez écrire une classe avec la méthode principale public static void et utiliser la méthode System.out.println ().  Cela fait, vous devez compiler le code à l'aide de javac.  Enfin, vous pouvez lancer une application qui accueillera le monde.  L'exécution du même script dans la plupart des langues modernes est beaucoup plus simple et plus rapide. </p><br><p>  JEP 330 élimine le besoin de compiler une application à fichier unique.  Entrez maintenant: </p><br><pre> <code class="java hljs"> java HelloWorld.java</code> </pre> <br><p>  Le lanceur Java identifie que le fichier contient le code source Java et compile le code dans un fichier * .class avant de l'exécuter. </p><br><p>  Les arguments placés après le nom du fichier source sont passés comme arguments au démarrage de l'application.  Les arguments placés avant le nom du fichier source sont passés en tant qu'arguments au lanceur java après avoir compilé le code (cela vous permet de définir des choses comme classpath sur la ligne de commande).  Les arguments liés au compilateur (par exemple classpath) seront également passés à javac pour la compilation. </p><br><p>  Un exemple: </p><br><pre> <code class="java hljs"> java -classpath /home/foo/java Hello.java Bonjour</code> </pre> <br><p>  Il sera équivalent à: </p><br><pre> <code class="java hljs"> javac -classpath /home/foo/java Hello.java java -classpath /home/foo/java Hello Bonjour</code> </pre> <br><p>  Ce JEP prend également en charge les fichiers shebang.  Pour réduire le besoin de mentionner même le lanceur Java sur la ligne de commande, vous pouvez l'inclure dans la première ligne du fichier source.  Par exemple: </p><br><pre> <code class="java hljs"> #!/usr/bin/java --source <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloWorld</span></span></span><span class="hljs-class"> </span></span>{ ...</code> </pre> <br><p>  L'indicateur -source avec la version de Java utilisée est requis. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 321: client HTTP (standard)</a></strong> </p><br><p>  JDK 9 a introduit une nouvelle API pour prendre en charge le protocole client HTTP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 110</a> ).  Étant donné que JDK 9 fournissait le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">système de module de plate-forme Java (JPMS)</a> , cette API a été incluse en tant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">que module d'incubateur</a> .  Les modules d'incubateur sont conçus pour fournir de nouvelles API, mais ne les transforment pas en standard Java SE.  Les développeurs peuvent essayer l'API en fournissant des commentaires.  Après avoir apporté les modifications nécessaires (cette API a été mise à jour dans JDK 10), l'API peut être transférée au module principal pour faire partie de la norme. </p><br><p>  L'API du client HTTP fait désormais partie de la norme Java SE 11. Cela introduit un nouveau module et package pour le JDK, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://download.java.net/java/early_access/jdk11/docs/api/java.net.">java.net.http</a> .  Classes principales: </p><br><ul><li>  Httpclient </li><li>  Httprequest </li><li>  HttpResponse </li><li>  Prise Web </li></ul><br><p>  L'API peut être utilisée de manière synchrone ou asynchrone.  En mode asynchrone, CompletionFutures et CompletionStages sont utilisés. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 320: suppression des modules Java EE et CORBA</a></strong> </p><br><p>  Avec l'introduction de JPMS dans JDK 9, il a été possible de diviser le fichier monolithique rt.jar en plusieurs modules.  Un avantage supplémentaire de JPMS est que vous pouvez désormais créer un environnement d'exécution Java qui inclut uniquement les modules nécessaires à votre application, réduisant ainsi considérablement la taille globale.  Avec des limites clairement définies, les modules obsolètes sont désormais plus faciles à supprimer de l'API Java.  C'est ce que fait ce JEP;  Le méta-module java.se.ee comprend six modules qui ne feront plus partie de la norme Java SE 11 et ne seront pas inclus dans le JDK. </p><br><p>  Modules distants: </p><br><ul><li>  corba ( <em>note du traducteur:</em> <del>  <em>repose en paix</em> </del>  <em>brûler en enfer</em> ) </li><li>  transaction </li><li>  activation </li><li>  xml.bind </li><li>  xml.ws </li><li>  xml.ws.annotation </li></ul><br><p>  Ces modules sont obsolètes (@Deprecated) depuis JDK 9 et n'étaient pas inclus par défaut dans la compilation ou le runtime.  Si vous avez essayé de compiler ou d'exécuter une application à l'aide de l'API à partir de ces modules sur JDK 9 ou JDK 10, vous auriez échoué.  Si vous utilisez l'API de ces modules dans votre code, vous devrez les fournir en tant que module ou bibliothèque distinct.  À en juger par les critiques, il semble que les modules java.xml qui font partie de la prise en charge des services Web JAX-WS et SOAP soient ceux qui causeront le plus de problèmes. </p><br><h3 id="novyy-publichnyy-api">  Nouvelle API publique </h3><br><p>  La plupart des nouvelles API de JDK 11 sont le résultat du fait que le module client HTTP fait désormais partie de la norme, ainsi que l'inclusion de Flight Recorder. </p><br><p>  Une liste schématique complète des modifications de l'API, y compris une comparaison des différentes versions du JDK, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut être trouvée ici.</a> </p><br><p>  Voici toutes les nouvelles méthodes autres que celles contenues dans les modules java.net.http et jdk.jfr.  Les nouvelles méthodes et classes des modules java.security, qui sont assez spécifiques aux modifications <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 324</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 329,</a> ne sont pas non plus répertoriées (il y a six nouvelles classes et huit nouvelles méthodes). </p><br><h4 id="javaiobytearrayoutputstream">  java.io.ByteArrayOutputStream </h4><br><ul><li>  <strong>void writeBytes (byte [])</strong> : écrit tous les octets de l'argument dans OutputStream </li></ul><br><h4 id="javaiofilereader">  java.io.FileReader </h4><br><p>  Deux nouveaux constructeurs qui vous permettent de spécifier un jeu de caractères. </p><br><h4 id="javaiofilewriter">  java.io.FileWriter </h4><br><p>  Quatre nouveaux constructeurs qui vous permettent de spécifier un jeu de caractères. </p><br><h4 id="javaioinputstream">  java.io.InputStream </h4><br><ul><li>  <strong>io.InputStream nullInputStream ()</strong> : renvoie un InputStream qui ne lit pas les octets.  En regardant cette méthode (et celle de OutputStream, Reader et Writer), la question se pose de savoir pourquoi elle pourrait être utile.  Vous pouvez les considérer comme <strong>/ dev / null</strong> - pour supprimer la sortie dont vous n'avez pas besoin, ou fournir une entrée qui retourne toujours des octets nuls. </li></ul><br><h4 id="javaiooutputstream">  java.io.OutputStream </h4><br><ul><li>  <strong>io.OutputStream nullOutputStream ()</strong> </li></ul><br><h4 id="javaioreader">  java.io.Reader </h4><br><ul><li>  <strong>io.Reader nullReader ()</strong> </li></ul><br><h4 id="javaiowriter">  java.io.Writer </h4><br><ul><li>  <strong>io.Writer nullWriter ()</strong> </li></ul><br><h4 id="javalangcharacter">  java.lang.Character </h4><br><ul><li>  <strong>String toString (int)</strong> : Il s'agit d'une forme surchargée d'une méthode existante, mais int est utilisé à la place de char.  Int est le point de code Unicode. </li></ul><br><h4 id="javalangcharsequence">  java.lang.CharSequence </h4><br><ul><li>  <strong>int compare (CharSequence, CharSequence)</strong> : compare deux instances de CharSequence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lexicographiquement</a> .  Renvoie une valeur négative, zéro ou une valeur positive si la première séquence est lexicographiquement inférieure, égale ou supérieure à la seconde, respectivement. </li></ul><br><h4 id="javalangrefreference">  java.lang.ref.Reference </h4><br><ul><li>  <strong>lang.Object clone ()</strong> : Je dois admettre que ce changement crée de la confusion.  La classe Reference n'implémente pas l'interface Cloneable et cette méthode lève une exception CloneNotSupportedException.  Il doit y avoir une raison pour son inclusion, peut-être pour quelque chose dans le futur.  ( <em>Note du traducteur: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il y a une discussion sur StackOverflow</a> , un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ticket dans OpenJDK</a></em> ) </li></ul><br><h4 id="javalangruntime">  java.lang.Runtime </h4><br><h4 id="javalangsystem">  java.lang.System </h4><br><p>  Il n'y a pas de nouvelles méthodes ici, mais il convient de mentionner que la méthode <strong>runFinalizersOnExit ()</strong> est désormais supprimée des deux classes (il peut y avoir un problème lors de la migration vers JDK 11). </p><br><h4 id="javalangstring">  java.lang.String </h4><br><p>  Je pense que c'est l'un des points forts des nouvelles API dans JDK 11. Il y a ici de nouvelles méthodes utiles. </p><br><ul><li>  <strong>boolean isBlank ()</strong> : retourne true si la chaîne est vide ou ne contient que des espaces, sinon false. </li><li>  <strong>Stream lines ()</strong> : renvoie Stream from String, extrait de cette chaîne, séparé par des séparateurs de ligne. </li><li>  <strong>String repeat (int)</strong> : renvoie une chaîne dont la valeur est la concaténation de cette chaîne, répétée plusieurs fois. </li><li>  <strong>String strip ()</strong> : renvoie une chaîne dont la valeur est cette chaîne, cela supprime tous les espaces au début et à la fin de la chaîne. </li><li>  <strong>String stripLeading ()</strong> : renvoie une chaîne dont la valeur est cette chaîne, tout en supprimant tous les espaces au début de la ligne. </li><li>  <strong>String stripTrailing ()</strong> : renvoie une chaîne dont la valeur est cette chaîne, cela supprime tous les espaces à la fin de la chaîne. </li></ul><br><p>  Très probablement, vous regardez <strong>strip ()</strong> et demandez: "En quoi est-ce différent de la méthode <strong>trim ()</strong> existante?"  La réponse réside dans la différence de définition des espaces.  ( <em>note du traducteur: en bref, <strong>strip ()</strong> comprend mieux Unicode, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une analyse détaillée sur StackOverflow</a></em> ) </p><br><h4 id="javalangstringbuffer">  java.lang.StringBuffer </h4><br><h4 id="javalangstringbuilder">  java.lang.StringBuilder </h4><br><p>  Ces deux classes ont une nouvelle méthode <strong>compareTo ()</strong> qui prend un StringBuffer / StringBuilder et retourne un int.  La méthode de comparaison lexicale est similaire à la nouvelle méthode <strong>compareTo ()</strong> de CharSequence. </p><br><h4 id="javalangthread">  java.lang.Thread </h4><br><p>  Pas de nouvelles méthodes.  Les <strong>méthodes</strong> <strong>destroy ()</strong> et <strong>stop (Throwable)</strong> ont été supprimées.  La méthode <strong>stop ()</strong> , qui ne prend aucun argument, est toujours présente.  Peut entraîner un problème de compatibilité. </p><br><h4 id="javaniobytebuffer">  java.nio.ByteBuffer </h4><br><h4 id="javaniocharbuffer">  java.nio.CharBuffer </h4><br><h4 id="javaniodoublebuffer">  java.nio.DoubleBuffer </h4><br><h4 id="javaniofloatbuffer">  java.nio.FloatBuffer </h4><br><h4 id="javaniolongbuffer">  java.nio.LongBuffer </h4><br><h4 id="javanioshortbuffer">  java.nio.ShortBuffer </h4><br><p>  Toutes ces classes ont désormais la méthode <strong>mismatch ()</strong> , qui recherche et renvoie l'index relatif de la première incompatibilité entre ce tampon et le tampon passé. </p><br><h4 id="javaniochannelsselectionkey">  java.nio.channels.SelectionKey </h4><br><ul><li>  <strong>int interestOpsAnd (int)</strong> : définit atomiquement l'intérêt de cette clé (intérêt de la clé) à l'intersection au niveau du bit ("et") de l'ensemble d'intérêts existant et de la valeur transmise. </li><li>  <strong>int interestOpsOr (int)</strong> : définit atomiquement l'intérêt de cette clé (intérêt de la clé) dans l'union au niveau du bit ("ou") de l'ensemble d'intérêts existant et de la valeur transmise. </li></ul><br><h4 id="javaniochannelsselector">  java.nio.channels.Selector </h4><br><ul><li>  <strong>int select (java.util.function.Consumer, long)</strong> : sélectionnez et effectuez des actions sur les touches dont les canaux correspondants sont prêts pour les opérations d'E / S.  long argument est un délai d'attente. </li><li>  <strong>int select (java.util.function.Consumer)</strong> : comme ci-dessus, mais sans délai. </li><li>  <strong>int selectNow (java.util.function.Consumer)</strong> : comme ci-dessus, uniquement non bloquant. </li></ul><br><h4 id="javaniofilefiles">  java.nio.file.Files </h4><br><ul><li>  <strong>String readString (Path)</strong> : lit tout le contenu d'un fichier dans une chaîne, décodant d'octets en caractères à l'aide du codage UTF-8. </li><li>  <strong>String readString (Path, Charset)</strong> : comme indiqué ci-dessus, avec la différence que le décodage d'octets en caractères se produit en utilisant le jeu de caractères spécifié. </li><li>  <strong>Path writeString (Path, CharSequence, java.nio.file.OpenOption [])</strong> : écrire CharSequence dans un fichier.  Les caractères sont codés en octets à l'aide du codage UTF-8. </li><li>  <strong>Path writeString (Path, CharSequence, java.nio.file.Charset, OpenOption [])</strong> : les mêmes que ci-dessus, les caractères sont codés en octets en utilisant le codage spécifié dans Charset. </li></ul><br><h4 id="javaniofilepath">  java.nio.file.Path </h4><br><ul><li>  <strong>Path of (String, String [])</strong> : renvoie Path à partir de l'argument chaîne du chemin ou de la séquence de chaînes qui, une fois combinées, forment la chaîne de chemin. </li><li>  <strong>Chemin de (net.URI)</strong> : retourne le chemin depuis l'URI. </li></ul><br><h4 id="javautilcollection">  java.util.Collection </h4><br><ul><li>  <strong>Object [] toArray (java.util.function.IntFunction)</strong> : renvoie un tableau contenant tous les éléments de cette collection, en utilisant la fonction de génération fournie pour allouer le tableau renvoyé. </li></ul><br><h4 id="javautilconcurrentpriorityblockingqueue">  java.util.concurrent.PriorityBlockingQueue </h4><br><h4 id="javautilpriorityqueue">  java.util.PriorityQueue </h4><br><ul><li>  <strong>void forEach (java.util.function.Consumer)</strong> : exécute l'action transmise pour chaque élément Iterable jusqu'à ce que tous les éléments soient traités ou que l'action lève une exception. </li><li>  <strong>boolean removeAll (java.util.Collection)</strong> : supprime tous les éléments de cette collection qui sont également contenus dans la collection spécifiée (opération facultative). </li><li>  <strong>boolean removeIf (java.util.function.Predicate)</strong> : supprime tous les éléments de cette collection qui satisfont le prédicat donné. </li><li>  <strong>boolean retentionAll (java.util.Collection)</strong> : <strong>enregistre</strong> uniquement les éléments de cette collection qui sont contenus dans la collection transférée (opération facultative). </li></ul><br><h4 id="javautilconcurrenttimeunit">  java.util.concurrent.TimeUnit </h4><br><ul><li>  <strong>conversion longue (java.time.Duration)</strong> : convertit la durée passée en ce type. </li></ul><br><h4 id="javautilfunctionpredicate">  java.util.function.Predicate </h4><br><ul><li>  <strong>Predicate not (Predicate)</strong> : renvoie le prédicat, qui est la négation du prédicat transmis. </li></ul><br><p>  C'est l'une de mes nouvelles API préférées dans JDK 11. À titre d'exemple, vous pouvez convertir ce code: </p><br><pre> <code class="java hljs"> lines.stream() .filter(s -&gt; !s.isBlank())</code> </pre> <br><p>  dans </p><br><pre> <code class="java hljs"> lines.stream() .filter(Predicate.not(String::isBlank))</code> </pre> <br><p>  ou si nous utilisons des importations statiques: </p><br><pre> <code class="java hljs"> lines.stream() .filter(not(String::isBlank))</code> </pre> <br><p>  Personnellement, je pense que cette version est plus compréhensible et concise. </p><br><h4 id="javautiloptional">  java.util.Optional </h4><br><h4 id="javautiloptionalint">  java.util.OptionalInt </h4><br><h4 id="javautiloptionaldouble">  java.util.OptionalDouble </h4><br><h4 id="javautiloptionallong">  java.util.OptionalLong </h4><br><ul><li>  <strong>boolean isEmpty ()</strong> : Si aucune valeur, retourne true, sinon false. </li></ul><br><h4 id="javautilregexpattern">  java.util.regex.Pattern </h4><br><ul><li>  <strong>Prédicat asMatchPredicate ()</strong> : Je pense que ce pourrait être le joyau de la nouvelle API JDK 11. Crée un prédicat qui vérifie si ce modèle correspond à la chaîne d'entrée donnée. </li></ul><br><h4 id="javautilzipdeflater">  java.util.zip.Deflater </h4><br><ul><li><p>  <strong>int deflate (ByteBuffer)</strong> : compresse l'entrée et remplit le tampon spécifié avec. </p><br></li><li><p>  <strong>int deflate (ByteBuffer, int)</strong> : compresse l'entrée et remplit le tampon spécifié avec.  Renvoie la quantité réelle de données compressées. </p><br></li><li><p>  <strong>void setDictionary (ByteBuffer)</strong> : définit le dictionnaire spécifié pour la compression en octets dans ce tampon.  Il s'agit d'une forme surchargée d'une méthode existante qu'un ByteBuffer peut désormais accepter, plutôt qu'un tableau d'octets. </p><br></li><li><p>  <strong>void setInput (ByteBuffer)</strong> : définit l'entrée à compresser.  Également une forme surchargée d'une méthode existante. </p><br></li></ul><br><h4 id="javautilzipinflater">  java.util.zip.Inflater </h4><br><ul><li>  <strong>int inflate (ByteBuffer)</strong> : décompresse les octets dans le tampon spécifié.  Renvoie le nombre réel d'octets décompressés. </li><li>  <strong>void setDictionary (ByteBuffer)</strong> : définit le dictionnaire spécifié en octets dans ce tampon.  La forme surchargée d'une méthode existante. </li><li>  <strong>void setInput (ByteBuffer)</strong> : définit l'entrée pour la décompression.  La forme surchargée d'une méthode existante. </li></ul><br><h4 id="javaxprintattributestandarddialogowner">  javax.print.attribute.standard.DialogOwner </h4><br><p>  Il s'agit d'une nouvelle classe dans JDK 11. Utilisée pour prendre en charge une demande de boîte de dialogue d'impression ou de mise en page.  Doit être affiché au-dessus de toutes les fenêtres ou d'une fenêtre spécifique. </p><br><h4 id="javaxswingdefaultcomboboxmodel">  javax.swing.DefaultComboBoxModel </h4><br><h4 id="javaxswingdefaultlistmodel">  javax.swing.DefaultListModel </h4><br><ul><li>  <strong>void addAll (Collection)</strong> : ajoute tous les éléments présents dans la collection. </li><li>  <strong>void addAll (int, Collection)</strong> : ajoute tous les éléments présents dans la collection, à partir de l'index spécifié. </li></ul><br><h4 id="javaxswinglistselectionmodel">  javax.swing.ListSelectionModel </h4><br><ul><li>  <strong>int [] getSelectedIndices ()</strong> : renvoie un tableau de tous les indices sélectionnés dans le modèle sélectionné, dans l'ordre croissant. </li><li>  <strong>int getSelectedItemsCount ()</strong> : renvoie le nombre d'éléments sélectionnés. </li></ul><br><h4 id="jdkjshellevalexception">  jdk.jshell.EvalException </h4><br><ul><li>  <strong>jshell.JShellException getCause ()</strong> : retourne un wrapper de cause jetable dans le client d'exécution représenté par une EvalException, ou null si la cause n'existe pas ou est inconnue. </li></ul><br><h3 id="novye-fichi-ne-publichnyy-api">  Nouvelles fonctionnalités (pas API publique) </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 181: Contrôle d'accès basé sur Nest</a> </p><br><p>  Java (et d'autres langages) prend en charge les classes imbriquées via les classes internes.  Pour le bon fonctionnement, le compilateur doit effectuer quelques astuces.  Par exemple: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outerInt); } } }</code> </pre> <br><p>  Le compilateur modifie ceci pour créer quelque chose comme ceci avant de faire la compilation: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> access$<span class="hljs-number"><span class="hljs-number">000</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outerInt; } }</code> </pre> <br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Outer outer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outer.access$<span class="hljs-number"><span class="hljs-number">000</span></span>()); } }</code> </pre> <br><p>  Bien que, logiquement, la classe interne fasse partie du même code que la classe externe, elle est compilée en tant que classe distincte.  Par conséquent, cela nécessite une méthode synthétique ("bridge"), qui doit être créée par le compilateur pour fournir l'accès au champ privé de la classe externe. </p><br><p>  Ce JEP représente le concept de «socket», où deux membres de la même socket (Outer et Inner de notre exemple) sont voisins.  Deux nouveaux attributs ont été ajoutés au format de fichier * .class: NestHost et NestMembers.  Ces modifications sont également utiles pour d'autres langages compilés par bytecode qui prennent en charge les classes imbriquées. </p><br><p>  Cette fonctionnalité propose trois nouvelles méthodes pour java.lang.Class: </p><br><ul><li>  <strong>Classe getNestHost ()</strong> </li><li>  <strong>Classe [] getNestMembers ()</strong> </li><li>  <strong>boolean isNestmateOf (clazz)</strong> </li></ul><br><p>  Cette fonctionnalité a également nécessité des modifications de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la spécification de machine virtuelle Java (JVMS)</a> , en particulier dans la section 5.4.4 Contrôle d'accès. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 309: Constantes dynamiques de fichier de classe</a></strong> </p><br><p>  Ce JEP décrit l'extension du format de fichier * .class pour prendre en charge le nouveau formulaire avec le pool constant CONSTANT_Dynamic (souvent appelé condy dans les présentations).  L'idée d'une constante dynamique semble être un oxymore, mais, en fait, vous pouvez le considérer comme une valeur finale en Java.  La valeur du pool de constantes n'est pas définie au stade de la compilation (contrairement aux autres constantes), mais la méthode d'amorçage est utilisée pour déterminer la valeur au moment de l'exécution.  Par conséquent, la valeur est dynamique, mais comme sa valeur n'est définie qu'une seule fois, elle est également constante. </p><br><p>  Cette fonctionnalité sera principalement utile à ceux qui développent de nouveaux langages et compilateurs.  Qui générera les fichiers de bytecode et * .class pour les exécuter sur la JVM.  Cela simplifiera certaines tâches. </p><br><p>  Cette fonctionnalité fournit une nouvelle classe java.lang.invoke.ConstantBootstraps avec neuf nouvelles méthodes.  Je ne les énumérerai pas tous ici;  ce sont des méthodes d'amorçage pour les constantes calculées dynamiquement. </p><br><p>  Cette fonctionnalité a nécessité des modifications du JVMS, en particulier, dans la façon dont le code d'octet d'invocation spécial et la section 4.4 de The Constant Pool sont utilisés. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 315: Amélioration de l'intrinsèque Aarch64</a></strong> </p><br><p>  Il s'agit du JEP fourni par Red Hat.  La machine virtuelle Java peut désormais utiliser des instructions plus spécialisées disponibles dans le jeu de commandes Arm 64. Cela améliore en particulier le fonctionnement des méthodes sin (), cos () et log () de la classe java.lang.Math. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 318: Le ramasse-miettes d'Epsilon</a></strong> </p><br><p>  Red Hat a également contribué à ce JEP.  Le ramasse-miettes Epsilon est quelque peu inhabituel car il ne ramasse pas les ordures!  Il allouera de la nouvelle mémoire si nécessaire lors de la création de nouveaux objets, mais ne libère pas l'espace occupé par les objets sans liens. </p><br><p>  Il semblerait, alors, quel est le point?  Il y a au moins deux utilisations: </p><br><ul><li>  Tout d'abord, ce collecteur est conçu pour garantir que les nouveaux algorithmes GC sont évalués en fonction de leur impact sur les performances.  L'idée est d'exécuter un exemple d'application avec Epsilon GC et de générer une métrique.  Un nouvel algorithme GC est inclus, les mêmes tests sont exécutés et les résultats sont comparés. </li><li>  Pour les tâches très courtes ou de courte durée (pensez à une fonction sans serveur dans le cloud), où vous pouvez vous assurer de ne pas dépasser la mémoire allouée à l'espace de tas.  Cela peut améliorer les performances en éliminant la surcharge (y compris la collecte des statistiques nécessaires pour décider d'exécuter ou non le collecteur) dans le code d'application. </li></ul><br><p>  Si l'espace de mémoire est épuisé, l'opération JVM suivante peut être configurée de trois manières: </p><br><ul><li>  Une OutOfMemoryError régulière est appelée. </li><li>  Réinitialiser le tas </li><li>  Arrêt dur de la JVM et éventuellement exécution d'une tâche externe (par exemple, démarrage du débogueur). </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>JEP 324: Accord clé avec Curve25519 et Curve448</strong></a> </p><br><p>  Les normes cryptographiques sont en constante évolution et amélioration.  Dans ce cas, le schéma Diffie-Hellman existant avec une courbe elliptique est remplacé par Curve25519 et Curve448.  Il s'agit d'un schéma d'accord clé défini dans la RFC-7748. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>JEP 327: Unicode 10</strong></a> </p><br><p>  La plate-forme Java prend en charge Unicode pour permettre le traitement de tous les jeux de caractères.  Depuis Unicode a été mis à jour vers la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version 10</a> , le JDK a également été mis à jour pour prendre en charge cette version de la norme. </p><br><p>  Je suis toujours intrigué de voir ce que les développeurs Unicode incluent dans les nouvelles versions.  Unicode 10 compte 8 518 nouveaux caractères.  Cela comprend le symbole Bitcoin, le jeu de caractères Nüshu (utilisé par les femmes chinoises pour écrire des poèmes) et Soyombo et la place Zanabazar (sont les caractères utilisés dans les textes bouddhistes historiques pour écrire le sanskrit, les langues tibétaine et mongole).  De nombreux autres Emoji ont également été ajoutés, y compris le très attendu (apparemment) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Colbert Emoji</a> . </p><br><p>  N'oubliez pas, à partir de JDK 9, vous pouvez utiliser UTF-8 dans les fichiers de propriétés (.properties).  Cela signifie que tout caractère Unicode peut être utilisé dans de tels fichiers.  Y compris les Emojis.  Ou Nüshu. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>JEP 328: Enregistreur de vol</strong></a> </p><br><p> Flight Recorder —       JVM.  JDK 11        Oracle JDK. ,  Oracle     Oracle JDK  OpenJDK,      OpenJDK. </p><br><p> JEP    : </p><br><ul><li>  API        </li><li>        </li><li>      </li><li>    , JVM HotSpot   JDK </li></ul><br><p>      : jdk.jfr  jdk.management.jfr. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms</strong></a> </p><br><p>  JEP 324,   ,  JDK.   ChaCha20  ChaCha20-Poly1305,    RFC 7539. ChaCha20 —     ,    ,    RC4. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>JEP 331: Low-overhead Heap Profiling</strong></a> </p><br><p>  ,   JEP,   Google.          Java  JVM. </p><br><p>  : </p><br><ul><li>    ,       </li><li>       </li><li>     </li><li>        ( ,     GC   VM) </li><li>         Java. </li></ul><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>JEP 332: Transport Layer Security (TLS) 1.3</strong></a> </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TLS 1.3 (RFC 8446)</a>  " "  TLS            . JDK   ,      Datagram Transport Layer Security (DTLS). </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>JEP 333: ZGC A Scalable, Low Latency Garbage Collector</strong></a> </p><br><p>     ,     ,     ()    .      (  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Weak Generational Hypothesis</a> )    (  )  GC   .     ""  ,            .           . </p><br><p> ZGC — region-based (  G1), NUMA aware  compacting  .      . </p><br><p>     pauseless     ,      C4   Zing JVM. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>JEP 335: Deprecate the Nashorn Scripting Engine</strong></a> </p><br><p> Nashorn    JDK 8     Rhino Javascript .    ,   Nashorn   API  jjs     Java.   ,   .     Graal VM   ,     ,  . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>JEP 336: Deprecate the Pack200 Tools and APIs</strong></a> </p><br><p> Pack200 —     JAR-,     Java SE 5.0.   JPMS  JDK 9 Pack200       JDK.  pack200  unpack200  API Pack200  java.util.jar          JDK.   ,  . </p><br><h3 id="vyvody">  Conclusions </h3><br><p> JDK 11 —   LTS JDK (       ).   ,  ,   ,   ,  JVM   ,        . </p><br><p> Zulu  JDK 11  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>   ! </p><br><p>         JDK 11? </p><br><p> ( <em>. : ,         </em> ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424683/">https://habr.com/ru/post/fr424683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424673/index.html">CLRium # 4: Réunion de la communauté .NET</a></li>
<li><a href="../fr424675/index.html">Que se passe-t-il dans le commerce de détail</a></li>
<li><a href="../fr424677/index.html">Un bref historique du pavé numérique</a></li>
<li><a href="../fr424679/index.html">Réparer les éléments essentiels des périphériques informatiques</a></li>
<li><a href="../fr424681/index.html">Résumé des événements informatiques d'octobre (première partie)</a></li>
<li><a href="../fr424685/index.html">La Securities and Exchange Commission des États-Unis a déposé une plainte contre le chef de Tesla Elon Musk, notamment en raison d'une fraude</a></li>
<li><a href="../fr424687/index.html">Ce sont les bonnes abeilles: adaptation mécanique aux effets dynamiques</a></li>
<li><a href="../fr424689/index.html">Le contrôle de la situation vous rend heureux.</a></li>
<li><a href="../fr424691/index.html">Nous vous invitons à la conférence Azov Developers Meetup 2018 - 13 octobre à Taganrog</a></li>
<li><a href="../fr424693/index.html">Ajout d'un filigrane à toutes les photos du site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>