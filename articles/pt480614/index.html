<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥐 🎢 🚶🏼 ENUM rápido 👆🏿 🌖 👁️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="tl; dr 
 github.com/QratorLabs/fastenum 


pip install fast-enum  
 Por que a enumeração é necessária 
 (se você souber tudo - vá para a seção "Enumer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ENUM rápido</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/480614/"><h4>  tl; dr </h4><br>  <a href="https://github.com/QratorLabs/fastenum">github.com/QratorLabs/fastenum</a> <br><pre><code class="bash hljs">pip install fast-enum</code> </pre> <br><h3>  Por que a enumeração é necessária </h3><br>  (se você souber tudo - vá para a seção "Enumerações na biblioteca padrão") <br><br>  Imagine que você precise descrever um conjunto de todos os estados possíveis de entidades em seu próprio modelo de banco de dados.  Provavelmente, você terá várias constantes definidas diretamente no namespace do módulo: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># /path/to/package/static.py: INITIAL = 0 PROCESSING = 1 PROCESSED = 2 DECLINED = 3 RETURNED = 4 ...</span></span></code> </pre> <br>  ... ou como atributos de classe estática: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModelStates</span></span></span><span class="hljs-class">:</span></span> INITIAL = <span class="hljs-number"><span class="hljs-number">0</span></span> PROCESSING = <span class="hljs-number"><span class="hljs-number">1</span></span> PROCESSED = <span class="hljs-number"><span class="hljs-number">2</span></span> DECLINED = <span class="hljs-number"><span class="hljs-number">3</span></span> RETURNED = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Essa abordagem ajudará a se referir a esses estados por nomes mnemônicos, enquanto no seu repositório eles serão inteiros comuns.  Assim, você se livra simultaneamente dos números mágicos espalhados em diferentes partes do código, tornando-o mais legível e informativo. <br><br>  No entanto, a constante do módulo e a classe com atributos estáticos sofrem com a natureza intrínseca dos objetos Python: todos são mutáveis ​​(mutáveis).  Você pode acidentalmente atribuir um valor à sua constante no tempo de execução, e depurar e reverter objetos quebrados é uma aventura separada.  Portanto, convém manter o pacote de constantes inalterado no sentido de que o número de constantes declaradas e seus valores para os quais estão mapeados não serão alterados durante a execução do programa. <br><a name="habracut"></a><br>  Para fazer isso, você pode tentar organizá-los em tuplas nomeadas usando <code>namedtuple()</code> , como no exemplo: <br><pre> <code class="python hljs">MyModelStates = namedtuple(<span class="hljs-string"><span class="hljs-string">'MyModelStates'</span></span>, (<span class="hljs-string"><span class="hljs-string">'INITIAL'</span></span>, <span class="hljs-string"><span class="hljs-string">'PROCESSING'</span></span>, <span class="hljs-string"><span class="hljs-string">'PROCESSED'</span></span>, <span class="hljs-string"><span class="hljs-string">'DECLINED'</span></span>, <span class="hljs-string"><span class="hljs-string">'RETURNED'</span></span>)) EntityStates = MyModelStates(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br>  Mas isso não parece muito elegante e legível, e os objetos <code>namedtuple</code> , por sua vez, não são muito extensíveis.  Suponha que você tenha uma interface do usuário que exiba todos esses estados.  Você pode usar suas constantes em módulos, uma classe com atributos ou tuplas nomeadas para renderizá-las (as duas últimas são mais fáceis de renderizar porque estamos falando sobre isso).  Mas esse código não torna possível fornecer ao usuário uma descrição adequada para cada estado que você definir.  Além disso, se você planeja implementar o multilinguismo e o suporte ao i18n em sua interface do usuário, perceberá a rapidez com que concluir todas as traduções dessas descrições se torna uma tarefa incrivelmente entediante.  Nomes de estados correspondentes não necessariamente significam correspondência à descrição, o que significa que você não pode apenas mapear todos os seus estados <code>INITIAL</code> para a mesma descrição no <code>gettext</code> .  Em vez disso, sua constante assume o seguinte formato: <br><pre> <code class="python hljs">INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'My_MODEL_INITIAL_STATE'</span></span>)</code> </pre> <br>  Ou sua turma fica assim: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModelStates</span></span></span><span class="hljs-class">:</span></span> INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>)</code> </pre> <br>  Por fim, a tupla nomeada se transforma em: <br><pre> <code class="python hljs">EntityStates = MyModelStates((<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>), ...)</code> </pre><br>  Já não é ruim - agora garante que o valor do status e o stub da tradução sejam exibidos nos idiomas suportados pela interface do usuário.  Mas você pode perceber que o código usando esses mapeamentos se tornou uma bagunça.  Sempre que tentar atribuir um valor de entidade, é necessário extrair o valor com o índice 0 da exibição que você está usando: <br><br><pre> <code class="python hljs">my_entity.state = INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre>  ou <pre> <code class="python hljs">my_entity.state = MyModelStates.INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre>  ou <pre> <code class="python hljs">my_entity.state = EntityStates.INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  E assim por diante  Lembre-se de que as duas primeiras abordagens que usam constantes e atributos de classe, respectivamente, sofrem mutabilidade. <br><br><h4>  E as transferências vêm em nosso auxílio </h4><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyEntityStates</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Enum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val, description)</span></span></span><span class="hljs-function">:</span></span> self.val = val self.description = description INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>) PROCESSING = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_BEING_PROCESSED_STATE'</span></span>) PROCESSED = (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_PROCESSED_STATE'</span></span>) DECLINED = (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_DECLINED_STATE'</span></span>) RETURNED = (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_RETURNED_STATE'</span></span>)</code> </pre> <br>  Isso é tudo.  Agora você pode facilmente percorrer a listagem em sua renderização (sintaxe Jinja2): <br><pre> <code class="python hljs">{% <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> MyEntityState %} &lt;option value=”{{ state.val }}”&gt;{{ _(state.description) }}&lt;/option&gt; {% endfor %}</code> </pre> <br>  Uma enumeração é imutável para um conjunto de elementos - você não pode definir um novo membro de uma enumeração em tempo de execução e não pode excluir um membro já definido e para os valores de elemento que ele armazena - não é possível [re] atribuir nenhum valor de atributo ou excluir um atributo. <br><br>  No seu código, você simplesmente atribui valores às suas entidades, assim: <br><pre> <code class="python hljs">my_entity.state = MyEntityStates.INITIAL.val</code> </pre> <br>  Tudo é claro o suficiente, informativo e extensível.  É para isso que usamos as enumerações. <br><br><h3>  Como poderíamos torná-lo mais rápido? </h3><br>  A enumeração da biblioteca padrão é bastante lenta, então nos perguntamos - podemos acelerá-la?  Como se viu, podemos, a saber, a implementação de nossa enumeração: <br><br><ul><li>  Três vezes mais rápido no acesso à enumeração de membros; </li><li>  ~ 8,5 mais rápido ao acessar o atributo ( <code>name</code> , <code>value</code> ) de um membro; </li><li>  3 vezes mais rápido ao acessar um membro por valor (chame o construtor da enumeração <code>MyEnum(value))</code> ; </li><li>  1,5 vezes mais rápido ao acessar um membro pelo nome (como no dicionário <code>MyEnum[name]</code> ). </li></ul><br>  Tipos e objetos em Python são dinâmicos.  Mas existem ferramentas para limitar a natureza dinâmica dos objetos.  Você pode obter um aumento significativo no desempenho com <code>__slots__</code> .  Também há potencial para ganhos de velocidade se você evitar o uso de descritores de dados sempre que possível - mas você deve considerar a possibilidade de um aumento significativo na complexidade do aplicativo. <br><br><h4>  Slots </h4><br>  Por exemplo, você pode usar uma declaração de classe usando <code>__slots__</code> - nesse caso, todas as instâncias de classes terão apenas um conjunto limitado de propriedades declaradas em <code>__slots__</code> e todos os <code>__slots__</code> classes pai. <br><br><h4>  Descritores </h4><br>  Por padrão, o intérprete Python retorna o valor do atributo do objeto diretamente (ao mesmo tempo, estipulamos que, nesse caso, o valor também é um objeto Python, e não, por exemplo, sem assinatura por muito tempo em termos da linguagem C): <br> <code>value = my_obj.attribute #        ,      .</code> <br> <br>  De acordo com o modelo de dados Python, se o valor do atributo for um objeto que implementa o protocolo do descritor, ao tentar obter o valor desse atributo, o intérprete encontrará primeiro um link para o objeto ao qual a propriedade se refere e, em seguida, chamará o método <code>__get__</code> especial, que será transmitido ao nosso objeto original como argumento: <br><pre> <code class="python hljs">obj_attribute = my_obj.attribute obj_attribute_value = obj_attribute.__get__(my_obj)</code> </pre> <br><h4>  Enumerações na biblioteca padrão </h4><br>  Pelo menos as propriedades de <code>name</code> e <code>value</code> dos membros da implementação de enumeração padrão são declaradas como <code>types.DynamicClassAttribute</code> .  Isso significa que quando você tentar obter os valores de <code>name</code> e <code>value</code> , o seguinte acontecerá: <br><br><pre> <code class="python hljs">one_value = StdEnum.ONE.value <span class="hljs-comment"><span class="hljs-comment">#        #   ,      one_value_attribute = StdEnum.ONE.value one_value = one_value_attribute.__get__(StdEnum.ONE)</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   ,  __get__     (  python3.7): def __get__(self, instance, ownerclass=None): if instance is None: if self.__isabstractmethod__: return self raise AttributeError() elif self.fget is None: raise AttributeError("unreadable attribute") return self.fget(instance)</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   DynamicClassAttribute     `name`  `value`   __get__()  : @DynamicClassAttribute def name(self): """The name of the Enum member.""" return self._name_ @DynamicClassAttribute def value(self): """The value of the Enum member.""" return self._value_</span></span></code> </pre> <br>  Assim, toda a sequência de chamadas pode ser representada pelo seguinte pseudo-código: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(enum_member, attrname)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#        __dict__,        -     return getattr(enum_member, f'_{attrnme}_') def get_name_value(enum_member): name_descriptor = get_descriptor(enum_member, 'name') if enum_member is None: if name_descriptor.__isabstractmethod__: return name_descriptor raise AttributeError() elif name_descriptor.fget is None: raise AttributeError("unreadable attribute") return get_func(enum_member, 'name')</span></span></code> </pre> <br>  Escrevemos um script simples demonstrando a saída descrita acima: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> enum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Enum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StdEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Enum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value, description)</span></span></span><span class="hljs-function">:</span></span> self.v = value self.description = description A = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'One'</span></span> B = <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'Two'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StdEnum.A.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PyCallGraph <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph.output <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GraphvizOutput graphviz = GraphvizOutput(output_file=<span class="hljs-string"><span class="hljs-string">'stdenum.png'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> PyCallGraph(output=graphviz): v = get_name()</code> </pre> <br>  E após a execução, o script nos deu a seguinte imagem: <br><img src="https://habrastorage.org/webt/op/ff/m7/opffm7k3v2rgako7xufgkgqtcek.png"><br><br>  Isso mostra que toda vez que você acessa os atributos de <code>name</code> e <code>value</code> dos membros da enumeração da biblioteca padrão, um identificador é chamado.  Este descritor, por sua vez, termina com uma chamada da classe <code>Enum</code> da biblioteca padrão do método <code>def name(self)</code> , decorada com o descritor. <br><br>  Compare com o nosso FastEnum: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fast_enum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FastEnum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyNewEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(metaclass=FastEnum)</span></span></span><span class="hljs-class">:</span></span> A = <span class="hljs-number"><span class="hljs-number">1</span></span> B = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyNewEnum.A.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PyCallGraph <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph.output <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GraphvizOutput graphviz = GraphvizOutput(output_file=<span class="hljs-string"><span class="hljs-string">'fastenum.png'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> PyCallGraph(output=graphviz): v = get_name()</code> </pre> <br>  O que pode ser visto na imagem a seguir: <br><img src="https://habrastorage.org/webt/le/ck/td/lecktd3dtx71oi3dmlyax7qyogu.png"><br><br>  Tudo isso realmente acontece dentro da implementação de enumeração padrão toda vez que você acessa as propriedades de <code>name</code> e <code>value</code> de seus membros.  Essa também é a razão pela qual nossa implementação é mais rápida. <br><br>  <b>A implementação de enumerações na biblioteca padrão do Python usa muitas chamadas para objetos que implementam o protocolo do descritor de dados.</b>  Quando tentamos usar a implementação de enumeração padrão em nossos projetos, notamos imediatamente quantos descritores de dados foram chamados para <code>name</code> e <code>value</code> . <br>  E como as enumerações foram usadas extensivamente em todo o código, o desempenho resultante foi baixo. <br><br>  Além disso, a classe Enum padrão contém vários atributos auxiliares "protegidos": <br><ul><li>  <code>_member_names_</code> - uma lista contendo todos os nomes dos membros da enumeração; </li><li>  <code>_member_map_</code> - <code>OrderedDict</code> , que mapeia o nome de um membro de enumeração para seu valor; </li><li>  <code>_value2member_map_</code> - um dicionário que contém correspondência na direção oposta: os valores dos membros da enumeração para os membros da enumeração correspondentes. </li></ul><br>  A pesquisa de dicionário é lenta, pois cada chamada leva ao cálculo da função de hash (a menos, é claro, que o resultado seja armazenado em cache separadamente, o que nem sempre é possível para código não gerenciado) e à pesquisa de tabela de hash, que torna esses dicionários uma base ideal para enumerações.  Até a pesquisa por membros de enumeração (como no <code>StdEnum.MEMBER</code> ) é uma pesquisa de dicionário. <br><br><h4>  Nossa abordagem </h4><br>  Criamos nossa implementação de enumerações de olho em enumerações elegantes em C e belas enumerações extensíveis em Java.  As principais funções que queríamos implementar em casa eram as seguintes: <br><br><ul><li>  a enumeração deve ser o mais estática possível;  "Estático" aqui significa o seguinte - se algo puder ser calculado apenas uma vez e durante o anúncio, deve ser calculado neste momento (e somente neste momento); </li><li>  é impossível herdar de uma enumeração (deve ser uma classe "final") se a classe herdada definir novos membros da enumeração - isso é verdade para implementação na biblioteca padrão, exceto que a herança é proibida lá, mesmo que a classe herdada não defina novos membros; </li><li>  a enumeração deve ter amplo escopo para expansão (atributos adicionais, métodos etc.) </li></ul><br>  Usamos a pesquisa de dicionário no único caso - este é o mapeamento inverso do valor <code>value</code> para um membro de enumeração.  Todos os outros cálculos são executados apenas uma vez durante a declaração de classe (onde as metaclasses são usadas para configurar a criação do tipo). <br>  Diferente da biblioteca padrão, processamos apenas o primeiro valor após o sinal <code>=</code> na declaração da classe como um valor de membro: <br>  <code>A = 1, 'One'</code> na biblioteca padrão, toda a tupla <code>1, "One"</code> considerada como o valor do <code>value</code> ; <br>  <code>A: 'MyEnum' = 1, 'One'</code> em nossa implementação, apenas <code>1</code> considerado como <code>value</code> . <br><br>  Aceleração adicional é alcançada através do uso de <code>__slots__</code> que possível.  Nas classes Python declaradas usando <code>__slots__</code> , o atributo <code>__dict__</code> não é criado nas <code>__dict__</code> , que contém o mapeamento dos nomes dos atributos para seus valores (portanto, você não pode declarar nenhuma propriedade da instância que não seja mencionada em <code>__slots__</code> ).  Além disso, os valores dos atributos definidos em <code>__slots__</code> são acessados ​​com um deslocamento constante no ponteiro da instância do objeto.  Esse é o acesso de alta velocidade às propriedades, pois evita cálculos de hash e varreduras de tabela de hash. <br><br><h3>  Quais são as fichas extras? </h3><br>  O FastEnum não é compatível com nenhuma versão do Python anterior à 3.6 porque universalmente usa anotações de tipo implementadas no Python 3.6.  Pode-se supor que a instalação do módulo de <code>typing</code> do PyPi ajudará.  A resposta curta é não.  A implementação usa o PEP-484 para os argumentos de algumas funções, métodos e ponteiros para o tipo de retorno, portanto, qualquer versão anterior ao Python 3.5 não é suportada devido à incompatibilidade de sintaxe.  Mas, novamente, a primeira linha de código na metaclasse <code>__new__</code> usa a sintaxe PEP-526 para indicar o tipo de variável.  Portanto, o Python 3.5 também não funcionará.  Você pode portar a implementação para versões mais antigas, embora nós do Qrator Labs tendamos a usar anotações de tipo sempre que possível, pois isso ajuda muito no desenvolvimento de projetos complexos.  Bem, no final!  Você não deseja ficar preso no Python antes da versão 3.6, pois nas versões mais recentes não há incompatibilidade com o código existente (desde que você não esteja usando o Python 2) e muito trabalho foi feito na implementação do <code>asyncio</code> comparado ao 3.5, em nossa opinião, vale uma atualização imediata. <br><br>  Isso, por sua vez, torna desnecessária a importação especial de <code>auto</code> , diferente da biblioteca padrão.  Você simplesmente indica que o membro da enumeração será uma instância dessa enumeração sem fornecer um valor - e o valor será gerado automaticamente para você.  Embora o Python 3.6 seja suficiente para trabalhar com o FastEnum, lembre-se de que a preservação da ordem das chaves nos dicionários foi introduzida apenas no Python 3.7 (e não usamos o <code>OrderedDict</code> separadamente para o caso 3.6).  Não conhecemos nenhum exemplo em que a ordem de valores gerada automaticamente seja importante, pois assumimos que, se o desenvolvedor forneceu ao ambiente a tarefa de gerar e atribuir um valor a um membro de enumeração, então o valor em si não é tão importante para ele.  No entanto, se você ainda não mudou para o Python 3.7, avisamos. <br><br>  Aqueles que precisam que suas enumerações iniciem de 0 (zero) em vez do valor padrão (1) podem fazer isso usando um atributo especial ao declarar a enumeração <code>_ZERO_VALUED</code> , que não será armazenada na classe resultante. <br><br>  No entanto, existem algumas restrições: todos os nomes dos membros da enumeração devem ser escritos em letras maiúsculas, caso contrário, eles não serão processados ​​pela metaclasse. <br><br>  Finalmente, você pode declarar uma classe base para suas enumerações (lembre-se de que a classe base pode usar a metaclasse em si, para que você não precise fornecer a metaclasse para todas as subclasses) - basta definir a lógica geral (atributos e métodos) nessa classe e não definir os membros da enumeração (para que a turma não seja "finalizada").  Depois que você puder declarar quantas classes herdadas dessa classe desejar, os próprios herdeiros terão a mesma lógica. <br><br><h3>  Aliases e como eles podem ajudar </h3><br>  Suponha que você tenha código usando: <br><pre> <code class="python hljs">package_a.some_lib_enum.MyEnum</code> </pre> <br>  E que a classe MyEnum é declarada da seguinte maneira: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(metaclass=FastEnum)</span></span></span><span class="hljs-class">:</span></span> ONE: <span class="hljs-string"><span class="hljs-string">'MyEnum'</span></span> TWO: <span class="hljs-string"><span class="hljs-string">'MyEnum'</span></span></code> </pre> <br>  Agora, você decidiu que deseja refatorar e transferir a listagem para outro pacote.  Você cria algo como isto: <br><pre> <code class="python hljs">package_b.some_lib_enum.MyMovedEnum</code> </pre> <br>  Onde MyMovedEnum é declarado assim: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyMovedEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MyEnum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br>  Agora você está pronto para o estágio em que a transferência localizada no endereço antigo é considerada obsoleta.  Você reescreve as importações e chamadas dessa enumeração para que o novo nome dessa enumeração (seu alias) seja agora usado - você pode ter certeza de que todos os membros dessa enumeração de alias são realmente declarados na classe com o nome antigo.  Na documentação do projeto, você declara que o <code>MyEnum</code> obsoleto e será removido do código no futuro.  Por exemplo, na próxima versão.  Suponha que seu código armazene seus objetos com atributos contendo membros de enumeração usando <code>pickle</code> .  Neste ponto, você usa <code>MyMovedEnum</code> no seu código, mas internamente, todos os membros da enumeração ainda são instâncias do <code>MyEnum</code> .  Seu próximo passo é trocar as declarações de <code>MyEnum</code> e <code>MyMovedEnum</code> para que <code>MyMovedEnum</code> não <code>MyMovedEnum</code> uma subclasse de <code>MyEnum</code> e <code>MyEnum</code> todos os seus membros;  <code>MyEnum</code> , por outro lado, agora não declara nenhum membro, mas se torna apenas um alias (subclasse) de <code>MyMovedEnum</code> . <br><br>  Isso é tudo.  Quando você reinicia seus aplicativos no estágio <code>unpickle</code> todos os membros da enumeração serão declarados novamente como instâncias de <code>MyMovedEnum</code> e <code>MyMovedEnum</code> associados a essa nova classe.  No momento em que você tiver certeza de que todos os seus objetos armazenados, por exemplo, no banco de dados, foram desserializados novamente (e possivelmente serializados novamente e armazenados no repositório) - é possível lançar um novo release, no qual ele foi marcado anteriormente como uma classe desatualizada <code>MyEnum</code> pode ser declarado mais desnecessário e removido da base de código. <br><br>  Experimente você mesmo: <a href="https://github.com/QratorLabs/fastenum">github.com/QratorLabs/fastenum</a> , <a href="https://pypi.org/project/fast-enum/">pypi.org/project/fast-enum</a> . <br>  Os profissionais de karma vão para o autor FastEnum - <a href="https://habr.com/en/users/santjagocorkez/" class="user_link">santjagocorkez</a> . <br><br>  UPD: Na versão 1.3.0, tornou-se possível herdar das classes existentes, por exemplo, <code>int</code> , <code>float</code> , <code>str</code> .  Os membros dessas enumerações passam com êxito no teste de igualdade para um objeto limpo com o mesmo valor ( <code>IntEnum.MEMBER == int(value_given_to_member)</code> ) e, é claro, que são instâncias dessas classes herdadas.  Isso, por sua vez, permite que o membro da enum herdado de <code>int</code> seja um argumento direto para <code>sys.exit()</code> como o código de retorno do interpretador python. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480614/">https://habr.com/ru/post/pt480614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480600/index.html">Enum mais rápido</a></li>
<li><a href="../pt480606/index.html">Mais cinco ideias sobre como atualizar suas habilidades como desenvolvedor front-end (dezembro de 2019)</a></li>
<li><a href="../pt480608/index.html">Rust supera C ++ com resultados de jogos de benchmarks</a></li>
<li><a href="../pt480610/index.html">Tabelas em C ++. Parte 2 (herança virtual + código gerado pelo compilador)</a></li>
<li><a href="../pt480612/index.html">Faça essas alterações para atender aos padrões de acessibilidade do design da web.</a></li>
<li><a href="../pt480618/index.html">Jogo eletrônico Tic Tac Toe. O que eu vim para</a></li>
<li><a href="../pt480620/index.html">SD-WAN e DNA para ajudar o administrador: recursos de arquitetura e prática</a></li>
<li><a href="../pt480622/index.html">Como usar a capacidade de armazenamento disponível corretamente</a></li>
<li><a href="../pt480626/index.html">Herança de sistemas e processos legados ou Os primeiros 90 dias no papel de CTO</a></li>
<li><a href="../pt480642/index.html">Introdução aos ELFs do Linux: Entendendo e Analisando</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>