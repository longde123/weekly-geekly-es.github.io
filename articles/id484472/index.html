<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚔️ 🥓 👨‍👩‍👧‍👦 Menggunakan asyncio untuk membuat driver perangkat asinkron di MicroPython v.1.12 🤸🏽 🚻 👐🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mempelajari kemungkinan MicroPython untuk keperluannya, saya menemukan salah satu implementasi perpustakaan asyncio dan, setelah korespondensi singkat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan asyncio untuk membuat driver perangkat asinkron di MicroPython v.1.12</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484472/"> <i>Mempelajari kemungkinan <b>MicroPython</b> untuk keperluannya, saya menemukan salah satu implementasi perpustakaan <b>asyncio</b> dan, setelah korespondensi singkat dengan <b>Piter Hinch</b> , penulis perpustakaan, saya menyadari bahwa saya perlu memahami lebih dalam prinsip, konsep dasar dan kesalahan umum menggunakan metode pemrograman asinkron.</i>  <i>Apalagi bagian untuk pemula hanya untuk saya.</i> <br><br>  Panduan ini ditujukan untuk pengguna dengan tingkat pengalaman berbeda dengan <i><b>asyncio</b></i> , termasuk bagian khusus untuk pemula. <br><a name="habracut"></a><br>  <b>Isi</b> <br>  <b>0. Pendahuluan</b> <br>  0.1 <i><b>.___</b></i> Menginstal <i><b>uasyncio</b></i> pada perangkat kosong (perangkat keras) <br>  <b>1. Merencanakan pelaksanaan program bersama</b> <br>  1.1 .___ Modul <br>  <b>2. perpustakaan <i>uasyncio</i></b> <br>  2.1 .___ Struktur Program: Siklus Pemrosesan Acara <br>  2.2 .___ Coroutines <br>  2.2.1 .______ Antrian <i>coroutine untuk berpartisipasi dalam perencanaan</i> <br>  2.2.2 .______ <i>Memulai fungsi <i>panggil balik</i> ( <i>callback</i> )</i> <br>  2.2.3 .______ <i>Catatan: coroutine sebagai metode terkait.</i>  <i>Nilai-nilai pengembalian.</i> <br>  2.3 .___ Penundaan <br>  <b>3. Sinkronisasi dan kelasnya</b> <br>  3.1 .___ Kunci <i><b>Kunci</b></i> <br>  3.1.1 .______ <i>Kunci dan batas waktu</i> <br>  3.2 .___ <i><b>Acara</b></i> <br>  3.2.1 .______ <i>Nilai</i> Acara <br>  3.3 .___ Barrier <i><b>Barrier</b></i> <br>  3.4 .___ <i><b>Semaphore</b></i> <br>  3.4.1 .______ <i>Semaphore Terbatas</i> <br>  3.5 .___ Antrian <i><b>Antrian</b></i> <br>  3.6 .___ Kelas Sinkronisasi Lainnya <br>  <b>4. Pengembangan kelas untuk <i>asyncio</i></b> <br>  4.1 .___ Kelas menggunakan <i>menunggu</i> <br>  4.1.1 .______ <i>Gunakan dalam konteks manajer</i> <br>  4.1.2 .______ <i>Menunggu di coroutine</i> <br>  4.2 .___ Iterator Asinkron <br>  4.3 .___ Manajer Konteks Asinkron <br>  <b>5. Pengecualian untuk timeout dan karena pembatalan tugas</b> <br>  5.1 .___ Pengecualian <br>  5.2 .___ Pengecualian karena batas waktu dan karena pembatalan tugas <br>  5.2.1 .______ <i>Membatalkan tugas</i> <br>  5.2.2 .______ <i>Coroutine dengan batas waktu</i> <br>  <b>6. Interaksi dengan perangkat perangkat keras</b> <br>  6.1 .___ Sinkronisasi Masalah <br>  6.2 .___ Polling perangkat dengan coroutine <br>  6.3 .___ Menggunakan mesin streaming <br>  6.3.1 .______ <i>Contoh Driver UART</i> <br>  6.4 .___ Pengembangan Driver untuk Perangkat Streaming <br>  6.5 .___ Contoh lengkap: <i>aremote.py</i> Driver untuk penerima remote control IR. <br>  6.6 .___ Driver untuk sensor suhu dan kelembaban HTU21D. <br>  <b>7. Kiat dan Trik</b> <br>  7.1 .___ Program macet <br>  7.2 <b><i>.___ uasyncio</i></b> menyimpan status <br>  7.3 .___ Pengumpulan sampah <br>  7.4 .___ Pengujian <br>  7.5 .___ Kesalahan umum.  Mungkin sulit ditemukan. <br>  7.6 .___ Pemrograman menggunakan soket ( <i>soket</i> ) <br>  7.6.1 .______ <i>Masalah WiFi</i> <br>  7.7 .___ Argumen dari konstruktor loop acara <br>  <b>8. Catatan untuk pemula</b> <br>  8.1 .___ Masalah 1: loop acara <br>  8.2 .___ Masalah 2: metode penguncian <br>  8.3 <b><i>.___</i></b> Pendekatan <b><i>uasyncio</i></b> <br>  8.4 .___ Perencanaan dalam <b><i>uasyncio</i></b> <br>  8.5 .___ Mengapa kolaboratif, bukan penjadwalan berbasis <i>utas</i> ( <i>_thread</i> )? <br>  8.6 .___ Interaksi <br>  8.7 .___ <i>Polling</i> <br><br>  <b>0. Pendahuluan</b> <br><br>  Sebagian besar dokumen ini mengasumsikan keakraban dengan pemrograman asinkron.  Untuk pemula, pengantar dapat ditemukan di bagian 7. <br><br>  Perpustakaan <i><b>uasyncio</b></i> untuk <b>MicroPython</b> termasuk subset dari perpustakaan <b>Python</b> <b><i>asyncio</i></b> dan dimaksudkan untuk digunakan pada mikrokontroler.  Karena itu, dibutuhkan sejumlah kecil RAM dan dikonfigurasi untuk dengan cepat beralih konteks dengan alokasi nol RAM. <br><br>  Dokumen ini menjelaskan penggunaan <i><b>uasyncio</b></i> dengan penekanan pada pembuatan driver untuk perangkat perangkat keras. <br><br>  Tujuannya adalah untuk mendesain driver agar aplikasi terus bekerja sementara driver sedang menunggu respons dari perangkat.  Pada saat yang sama, aplikasi tetap peka terhadap peristiwa lain dan interaksi pengguna. <br><br>  Bidang penting lain dari aplikasi <b><i>asyncio</i></b> adalah pemrograman jaringan: di Internet Anda dapat menemukan informasi yang cukup tentang topik ini. <br><br>  Perhatikan bahwa <b>MicroPython</b> didasarkan pada <b>Python 3.4</b> dengan add-ons minimum <b>Python 3.5</b> .  Kecuali seperti yang dijelaskan di bawah ini, fungsi versi <b><i>asyncio yang</i></b> lebih tua dari 3,4 tidak didukung.  Dokumen ini mendefinisikan fitur-fitur yang didukung dalam subset ini. <br><br>  Tujuan dari panduan ini adalah untuk memperkenalkan gaya pemrograman yang kompatibel dengan <b>CPython V3.5</b> dan lebih tinggi. <br><br>  <b>0,1 Instal <b><i>uasyncio</i></b> pada perangkat kosong (perangkat keras)</b> <br><br>  Disarankan untuk menggunakan firmware <b>MicroPython V1.11</b> atau yang lebih baru.  Pada banyak platform, instalasi tidak diperlukan, karena <b><i>uasyncio</i></b> sudah dikompilasi dalam perakitan.  Untuk memeriksanya, cukup ketik REPL <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio</code> </pre> <br>  Instruksi berikut mencakup kasus-kasus ketika modul tidak diinstal sebelumnya.  Modul <b><i>antrian</i></b> dan <b><i>sinkronisasi</i></b> adalah opsional, tetapi diharuskan untuk menjalankan contoh yang diberikan di sini. <br><br>  <b>Perangkat yang terhubung internet</b> <br><br>  Pada perangkat yang terhubung ke Internet dan menjalankan firmware V1.11 atau yang lebih baru, Anda dapat menginstal menggunakan versi <i>upip bawaan</i> .  Memastikan perangkat terhubung ke jaringan Anda: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> upip upip.install ( <span class="hljs-string"><span class="hljs-string">'micropython-uasyncio'</span></span> ) upip.install ( <span class="hljs-string"><span class="hljs-string">'micropython-uasyncio.synchro'</span></span> ) upip.install ( <span class="hljs-string"><span class="hljs-string">'micropython-uasyncio.queues'</span></span> )</code> </pre><br>  Pesan kesalahan dari <i>upip</i> tidak terlalu berguna.  Jika Anda mendapatkan kesalahan yang tidak dapat dipahami, periksa koneksi Internet lagi. <br><br>  <b>Perangkat keras tanpa koneksi internet ( <i>mikropip</i> )</b> <br><br>  Jika perangkat <b>Anda</b> tidak memiliki koneksi Internet (misalnya, <b>Pyboard V1.x</b> ), cara termudah adalah memulai instalasi <i>micropip.py</i> di komputer ke direktori pilihan Anda, lalu salin struktur direktori yang dihasilkan ke perangkat target.  Utilitas <i>micropip.py</i> berjalan pada <b>Python 3.2</b> atau yang lebih baru dan berjalan di Linux, Windows, dan OSX.  Informasi lebih lanjut dapat ditemukan di <a href="https://github.com/peterhinch/micropython-samples/tree/master/micropip" rel="nofollow">sini</a> . <br><br>  Panggilan biasa: <br><br><pre> <code class="python hljs">$ micropip.py install -p ~/rats micropython-uasyncio $ micropip.py install -p ~/rats micropython-uasyncio.synchro $ micropip.py install -p ~/rats micropython-uasyncio.queues</code> </pre><br>  <b>Perangkat tanpa koneksi internet (sumber penyalinan)</b> <br><br>  Jika Anda tidak menggunakan <i>micropip.py</i> , file harus disalin dari sumbernya.  Petunjuk berikut menjelaskan cara menyalin jumlah minimum file ke perangkat target, serta kasus ketika <b><i>uasyncio</i></b> perlu dikompresi ke dalam rakitan yang dikompilasi dalam bentuk bytecode untuk mengurangi ruang yang ditempati.  Untuk versi terbaru yang kompatibel dengan firmware resmi, file harus disalin dari situs <a href="http://github.com/micropython/micropython-lib" rel="nofollow">web</a> resmi <a href="http://github.com/micropython/micropython-lib" rel="nofollow">micropython-lib</a> . <br><br>  Kloning perpustakaan ke komputer dengan perintah <br><br><pre> <code class="python hljs">$ git clone https://github.com/micropython/micropython-lib.git</code> </pre><br>  Pada perangkat target, buat direktori <b><i>uasyncio</i></b> (opsional di direktori lib) dan salin file berikut ke dalamnya: <br><br>  <b>• uasyncio / uasyncio / __ init__.py</b> <b><br></b>  <b>• uasyncio.core / uasyncio / core.py</b> <b><br></b>  <b>• uasyncio.synchro / uasyncio / synchro.py</b> <b><br></b>  <b>• uasyncio.queues / uasyncio / queues.py</b> <b><br></b> <br><br>  Modul <b><i>uasyncio</i></b> ini dapat dikompresi menjadi bytecode dengan menempatkan direktori <b><i>uasyncio</i></b> dan isinya di port direktori <i>modules</i> dan mengkompilasi ulang isinya. <br><br>  <b>1. Perencanaan bersama</b> <br><br>  Teknik eksekusi bersama dari beberapa tugas banyak digunakan dalam embedded system, yang menawarkan lebih sedikit overhead daripada penjadwalan threading ( <b>_thread</b> ), menghindari banyak jebakan yang terkait dengan utas yang benar-benar tidak sinkron. <br><br>  <b>1.1 Modul</b> <br><br>  Berikut ini adalah daftar modul yang dapat berjalan di perangkat target. <br><br>  <b><u>Perpustakaan</u></b> <br><br>  1. <b><i>asyn.py</i></b> Menyediakan <i><b>Kunci, Peristiwa, Penghalang, Semaphore, BoundedSemaphore, Kondisi, kumpulkan</b></i> primitif sinkronisasi.  Memberikan dukungan untuk membatalkan tugas melalui kelas <i><b>NamedTask</b></i> dan <i><b>Cancellable</b></i> . <br><br>  2. <b><i>aswitch.py</i></b> Merupakan kelas untuk memasangkan sakelar dan tombol, serta objek program dengan kemungkinan penundaan berulang.  Tombol adalah generalisasi dari sakelar yang menyediakan keadaan logis dan bukan fisik, serta peristiwa yang dipicu oleh pers ganda dan panjang. <br><br>  <b>Program demo</b> <br><br>  Dua yang pertama paling berguna karena mereka memberikan hasil yang terlihat ketika mengakses <b>perangkat keras Pyboard</b> . <br><br><ol><li>  <b><i>aledflash.py</i></b> Flashes empat indikator <b>Pyboard secara</b> sinkron selama 10 detik.  Demonstrasi <b>uasyncio yang</b> paling sederhana.  Impor untuk dijalankan. </li><li>  <b><i>apoll.py</i></b> Driver <b><i>perangkat</i></b> untuk accelerometer <b>Pyboard</b> .  Menunjukkan penggunaan coroutine untuk permintaan perangkat.  Bekerja selama 20 detik.  Impor untuk dijalankan.  Membutuhkan <b>Pyboard V1.x.</b> </li><li>  <b><i>astests.py Program</i></b> uji / demo untuk modul <b><i>aswitch</i></b> . </li><li>  <b><i>asyn_demos.py</i></b> Demo sederhana untuk membatalkan tugas. </li><li>  <b><i>roundrobin.py</i></b> Peragaan perencanaan melingkar.  Juga menjadi tolok ukur untuk perencanaan kinerja. </li><li>  <b><i>awaitable.py</i></b> Demonstrasi kelas dengan menunggu.  Salah satu cara untuk mengimplementasikan pengandar perangkat yang polling antarmuka. </li><li>  <b><i>chain.py</i></b> Disalin dari dokumentasi <b>Python</b> .  Demonstrasi rantai coroutine. </li><li>  <b><i>aqtest.py</i></b> Demonstrasi kelas <b><i>antrian</i></b> perpustakaan <i><b>uasyncio</b></i> . </li><li>  <b><i>aremote.py</i></b> Contoh driver perangkat untuk protokol NEC IR. </li><li>  <b><i>auart.py</i></b> Peragaan streaming input-output melalui <b>Pyboard UART</b> . </li><li>  <b><i>auart_hd.py</i></b> Menggunakan <b>Pyboard UART</b> untuk berkomunikasi dengan perangkat menggunakan protokol setengah dupleks.  Cocok untuk perangkat, misalnya, menggunakan set perintah modem AT. </li><li>  <b><i>iorw.py</i></b> Demonstrasi perangkat pembaca / penulis menggunakan streaming I / O. </li></ol><br>  <b>Program uji</b> <br><br><ol><li>  <b><i>asyntest.py</i></b> Tes untuk kelas sinkronisasi di <b><i>asyn.py.</i></b> </li><li>  <b><i>cantest.py</i></b> Tes pembatalan pekerjaan. </li></ol><br>  <b>Utilitas</b> <br><br>  1. <b><i>check_async_code.py</i></b> Utilitas ini ditulis dalam <b>Python3</b> untuk mendeteksi kesalahan pengkodean tertentu yang sulit ditemukan.  Lihat bagian 7.5. <br><br>  <b>Kontrol</b> <br><br>  Direktori <a href="" rel="nofollow"><i>tolok ukur</i></a> berisi skrip untuk memeriksa dan mengkarakterisasi <i><b>penjadwal uasyncio</b></i> . <br><br><cut></cut><br>  <b>2. perpustakaan <i>uasyncio</i></b> <br><br>  Konsep <i>asyncio</i> didasarkan pada organisasi perencanaan untuk pelaksanaan bersama beberapa tugas, yang dalam dokumen ini disebut <b>coroutine</b> . <br><br>  <b>2.1 Struktur program: loop acara</b> <br><br>  Perhatikan contoh berikut: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> : count + = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ( count ) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-comment"><span class="hljs-comment">#  1 loop = asyncio.get_event_loop () loop.create_task ( bar ()) #     loop.run_forever ()</span></span></code> </pre><br>  Eksekusi program berlanjut sampai <i>loop.run_forever dipanggil</i> .  Pada titik ini, eksekusi dikendalikan oleh penjadwal.  Baris demi <i>loop.run_forever</i> tidak akan pernah dieksekusi.  Penjadwal mengeksekusi kode <i>batang</i> karena telah di-antri di <i>scheduler loop.create_task</i> .  Dalam contoh sepele ini, hanya ada satu <i>batang</i> coroutine.  Jika ada yang lain, penjadwal akan menjalankannya selama periode ketika <i>bilah</i> dijeda. <br><br>  Sebagian besar aplikasi yang disematkan memiliki loop acara yang berkelanjutan.  Perulangan peristiwa juga dapat dimulai dengan cara yang memungkinkan penyelesaian menggunakan <i>run_until_complete</i> metode peristiwa;  Ini terutama digunakan dalam pengujian.  Contohnya dapat ditemukan di modul <a href="https://github.com/peterhinch/micropython-async/blob/master/astests.py" rel="nofollow"><b><i>astests.py</i></b></a> . <br><br>  Contoh loop peristiwa adalah objek tunggal yang dibuat oleh panggilan pertama ke <i>asyncio.get_event_loop ()</i> dengan dua argumen integer opsional yang menunjukkan jumlah coroutine dalam dua antrian - mulai dan menunggu.  Biasanya, kedua argumen akan memiliki nilai yang sama, sama dengan setidaknya jumlah coroutine yang dieksekusi secara bersamaan dalam aplikasi.  Biasanya, nilai default 16 sudah cukup. Jika nilai-nilai non-standar digunakan, lihat Argumen dari konstruktor loop peristiwa (bagian 7.7.). <br><br>  Jika coroutine perlu memanggil metode event loop (biasanya <i>create_task</i> ), memanggil <i>asyncio.get_event_loop ()</i> (tanpa argumen) akan mengembalikannya secara efektif. <br><br>  <b>2.2 Coroutine</b> <br><br>  Coroutine dibuat sebagai berikut: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( delay_secs )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( delay_secs ) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> )</code> </pre><br>  Coroutine dapat memungkinkan coroutine lainnya diluncurkan menggunakan pernyataan <i>tunggu</i> .  Coroutine harus mengandung setidaknya satu pernyataan <i>menunggu</i> .  Ini menyebabkan coroutine untuk mengeksekusi sebelum selesai, sebelum eksekusi berlanjut ke pernyataan berikutnya.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( delay_secs ) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( <span class="hljs-number"><span class="hljs-number">0</span></span> )</code> </pre><br>  Baris pertama menyebabkan kode berhenti untuk waktu tunda, sementara coroutine lain menggunakan waktu ini untuk eksekusi mereka.  Penundaan 0 menyebabkan semua coroutine yang tertunda dijalankan dalam urutan siklik hingga baris berikutnya dijalankan.  Lihat contoh <i><b>roundrobin.py</b></i> . <br><br>  <b>2.2.1.</b>  <b>Antrian untuk merencanakan coroutine</b> <br><br><ul><li>  <i>EventLoop.create_task</i> Argumen: Coroutine untuk dijalankan.  Penjadwal mengantri coroutine untuk memulai sesegera mungkin.  Panggilan <i>create_task</i> segera kembali.  Coroutine dalam argumen ditentukan menggunakan sintaks pemanggilan fungsi dengan argumen yang diperlukan. </li><li>  <i>EventLoop.run_until_complete</i> Argument: Coroutine untuk dijalankan.  Penjadwal mengantri coroutine untuk memulai sesegera mungkin.  Coroutine dalam argumen ditentukan menggunakan sintaks pemanggilan fungsi dengan argumen yang diperlukan.  Panggilan <i>un_until_complete</i> kembali ketika coroutine telah selesai: metode ini menyediakan cara untuk keluar dari penjadwal. </li><li>  <i>menunggu</i> Argumen: A coroutine untuk dijalankan, ditentukan menggunakan sintaks pemanggilan fungsi.  Mulai coroutine sesegera mungkin.  Coroutine yang tertunda diblokir sampai salah satu coroutine yang diharapkan selesai. </li></ul><br>  Di atas adalah kompatibel dengan <b>CPython</b> .  Metode <b><i>uasyncio</i></b> tambahan dibahas dalam Catatan (Bagian 2.2.3.). <br><br>  <b>2.2.2 Memulai fungsi panggilan balik</b> <br><br>  Callback haruslah fungsi <b>Python yang</b> dirancang untuk dijalankan dalam waktu singkat.  Hal ini disebabkan oleh fakta bahwa coroutine tidak akan dapat bekerja selama durasi dari pelaksanaan fungsi tersebut. <br><br>  <b><i>Metode</i></b> kelas <b><i>EventLoop</i></b> berikut menggunakan panggilan balik: <br><br><ol><li>  <i>call_soon</i> - panggilan sesegera mungkin.  Args: <i>callback</i> callback untuk dijalankan, <i>* args</i> argumen posisi apa pun dapat diikuti oleh koma. </li><li>  <i>call_later</i> - panggilan setelah penundaan dalam hitungan detik.  Args: <i>delay, callback, * args</i> </li><li>  <i>call_later_ms</i> - panggilan setelah penundaan dalam ms.  Args: <i>delay, callback, * args</i> . </li></ol><br><pre> <code class="python hljs">loop = asyncio.get_event_loop () loop.call_soon ( foo , <span class="hljs-number"><span class="hljs-number">5</span></span> ) <span class="hljs-comment"><span class="hljs-comment">#    'foo'      5. loop.call_later ( 2 , foo , 5 ) #   2 . loop.call_later_ms ( 50 , foo , 5 ) #   50 . loop.run_forever ()</span></span></code> </pre><br>  <b>2.2.3 Catatan</b> <br><br>  Coroutine dapat berisi pernyataan <i>pengembalian</i> dengan nilai pengembalian yang berubah-ubah.  Untuk mendapatkan nilai ini: <br><br><pre> <code class="python hljs">result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> my_coro ()</code> </pre><br>  Coroutine dapat dibatasi dengan metode dan harus mengandung setidaknya satu pernyataan <i>menunggu</i> . <br><br>  <b>2.3 Penundaan</b> <br><br>  Ada dua opsi untuk mengatur keterlambatan dalam coroutine.  Untuk penundaan yang lebih lama dan dalam kasus di mana durasinya tidak perlu akurat, Anda dapat menggunakan: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( delay_secs , delay_ms )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( delay_secs ) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms ( delay_ms )</code> </pre><br>  Selama penundaan tersebut, penjadwal akan menjalankan coroutine lain.  Ini dapat menimbulkan ketidakpastian waktu, karena coroutine yang memanggil hanya akan diluncurkan ketika yang sedang dijalankan dijalankan.  Jumlah penundaan tergantung pada pengembang aplikasi, tetapi mungkin akan berada di urutan puluhan atau ratusan ms;  ini dibahas lebih lanjut dalam Interaksi dengan Perangkat Keras (Bagian 6). <br><br>  Penundaan yang sangat tepat dapat dilakukan menggunakan fungsi <i>utime</i> - <i>sleep_ms</i> dan <i>sleep_us</i> .  Mereka paling cocok untuk penundaan pendek, karena penjadwal tidak akan dapat mengeksekusi coroutine lain saat penundaan sedang berlangsung. <br><br>  <b>3. Sinkronisasi</b> <br><br>  Seringkali ada kebutuhan untuk memastikan sinkronisasi antar coroutine.  Contoh umum adalah untuk menghindari apa yang disebut "kondisi ras" ketika beberapa coroutine secara bersamaan membutuhkan akses ke sumber daya yang sama.  Contoh disediakan di <b><i>astests.py</i></b> dan dibahas dalam <a href="" rel="nofollow">dokumentasi</a> .  Bahaya lain adalah "pelukan maut," ketika masing-masing coroutine menunggu selesainya yang lain. <br><br>  Dalam aplikasi sederhana, sinkronisasi dapat dicapai menggunakan flag global atau variabel terkait.  Pendekatan yang lebih elegan adalah dengan menggunakan kelas sinkronisasi.  Modul <b><i>asyn.py</i></b> menawarkan implementasi "mikro" dari kelas <i><b>Event, Barrier, Semaphore,</b></i> dan <i><b>Conditios</b></i> , yang dimaksudkan untuk digunakan hanya dengan <b><i>asyncio</i></b> .  Mereka tidak berorientasi thread dan tidak boleh digunakan dengan modul <b><i>_thread</i></b> atau interrupt handler, kecuali ditentukan lain.  Kelas <i><b>Lock</b></i> juga diterapkan, yang merupakan alternatif dari implementasi resmi. <br><br>  Masalah sinkronisasi lain muncul dengan produsen coroutine dan konsumen coroutine.  Produsen coroutine menghasilkan data yang digunakan konsumen coroutine.  Untuk melakukan ini, <b><i>asyncio</i></b> menyediakan kelas <i><b>Queue</b></i> .  Produsen coroutine menempatkan data dalam antrian, sementara konsumen coroutine sedang menunggu penyelesaiannya (dengan operasi lain dijadwalkan tepat waktu).  Kelas <i><b>Antrian</b></i> memberikan jaminan untuk menghapus item dalam urutan penerimaannya.  Atau, Anda dapat menggunakan kelas <i><b>Barrier</b></i> jika produsen coroutine harus menunggu sampai konsumen coroutine siap mengakses data. <br><br>  Tinjauan singkat kelas diberikan di bawah ini.  Lebih detail dalam <a href="" rel="nofollow">dokumentasi lengkap</a> . <br><br>  <b>3.1 <a href="" rel="nofollow"><i>Kunci</i></a></b> <br><br>  <i><b>Kunci</b></i> menjamin akses unik ke sumber daya bersama.  Contoh kode berikut ini membuat turunan dari kelas <i>kunci</i> <b><i>Kunci</i></b> yang diteruskan ke semua klien yang ingin mengakses sumber daya bersama.  Setiap coroutine mencoba menangkap kunci, menjeda eksekusi sampai berhasil: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> uasyncio.synchro <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Lock <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, lock)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> lock.acquire() print(<span class="hljs-string"><span class="hljs-string">"Acquired lock in task"</span></span>, i) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) lock.release() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">killer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">10</span></span>) loop = asyncio.get_event_loop() lock = Lock() <span class="hljs-comment"><span class="hljs-comment"># The global Lock instance loop.create_task(task(1, lock)) loop.create_task(task(2, lock)) loop.create_task(task(3, lock)) loop.run_until_complete(killer()) #  10s</span></span></code> </pre><br>  <b>3.1.1.Kunci dan batas waktu</b> <br><br>  Pada saat penulisan (5 Januari 2018), pengembangan kelas <i><b>uasycio</b></i> <i>Lock</i> belum selesai secara resmi.  Jika coroutine memiliki <u>batas waktu (bagian 5.2.2.)</u> , Ketika menunggu kunci ketika dipicu, batas waktu akan tidak efektif.  Itu tidak akan menerima <i>TimeoutError</i> sampai ia menerima kunci.  Hal yang sama berlaku untuk membatalkan tugas. <br><br>  Modul <b><i>asyn.py</i></b> menawarkan kelas <a href="" rel="nofollow"><b><i>Lock</i></b></a> , yang berfungsi dalam situasi ini.  Implementasi kelas ini kurang efisien daripada kelas resmi, tetapi mendukung antarmuka tambahan sesuai dengan versi <b>CPython</b> , termasuk penggunaan manajer konteks. <br><br>  <b>3.2 Acara</b> <br><br>  <b><i>Peristiwa</i></b> menciptakan peluang bagi satu atau beberapa coroutine untuk berhenti, sementara yang lain memberi sinyal tentang kelanjutannya.  Sebuah instance dari <b>Event</b> menjadi tersedia untuk semua coroutine yang menggunakannya: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyn event = asyn.Event ()</code> </pre><br>  Coroutine menunggu acara dengan mendeklarasikan <i>acara tunggu</i> , setelah eksekusi berhenti sampai coroutine lain mendeklarasikan <i>event.set ()</i> .  <a href="" rel="nofollow">Informasi lengkap</a> <br><br>  Masalah dapat muncul jika <i>event.set ()</i> dikeluarkan dalam konstruksi perulangan;  kode harus menunggu sampai semua objek yang tertunda memiliki akses ke acara sebelum mengaturnya lagi.  Dalam kasus ketika satu <b>coro</b> mengharapkan suatu peristiwa, ini dapat dicapai dengan menerima acara <b>coro</b> membersihkan acara: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventwait</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( event )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> event event.clear()</code> </pre><br>  Coroutine yang memicu acara memeriksa apakah telah dilayani: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( event )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> : <span class="hljs-comment"><span class="hljs-comment">#   - while event.is_set (): await asyncio.sleep ( 1 ) # ,  coro   event.set ()</span></span></code> </pre><br>  Dalam kasus ketika beberapa perusahaan sedang menunggu sinkronisasi satu peristiwa, masalahnya dapat diselesaikan dengan menggunakan acara konfirmasi.  Setiap <b>coro</b> membutuhkan acara terpisah. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventwait</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(  , ack_event )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> event ack_event.set ()</code> </pre><br>  Contoh dari ini diberikan dalam fungsi <i><b>event_test</b></i> di <i><b>asyntest.py</b></i> .  Ini rumit dalam kebanyakan kasus - bahkan dengan satu menunggu <b>coro</b> - kelas <b>Barrier</b> , disajikan di bawah ini, menawarkan pendekatan yang lebih sederhana. <br>  Suatu acara juga dapat menyediakan sarana komunikasi antara interrupt handler dan <b>coro</b> .  Pawang memelihara perangkat keras dan mengatur acara, yang diperiksa oleh <b>coro</b> sudah dalam mode normal. <br><br>  <b>3.2.1 Nilai Acara</b> <br><br>  Metode <i>event.set ()</i> dapat mengambil nilai data opsional jenis apa pun.  <b>Coro</b> , menunggu acara, bisa mendapatkannya dengan <i>event.value ()</i> .  Perhatikan bahwa <i>event.clear ()</i> akan diatur ke <i>Tidak Ada</i> .  Penggunaan khas ini untuk pengaturan <i>coro</i> acara adalah untuk mengeluarkan <i>event.set (utime.ticks_ms ())</i> .  Perusahaan apa pun yang menunggu acara dapat menentukan penundaan yang telah terjadi, misalnya, untuk mengkompensasi hal ini. <br><br>  <b>3.3 <a href="" rel="nofollow"><i>Penghalang</i></a></b> <br><br>  Ada dua kegunaan untuk kelas <b><i>Barrier</i></b> . <br><br>  Pertama, ia dapat menangguhkan coroutine sampai satu atau beberapa coroutine lainnya selesai. <br><br>  Kedua, memungkinkan beberapa coroutine untuk bertemu pada titik tertentu.  Misalnya, produsen dan konsumen dapat melakukan sinkronisasi pada titik di mana produsen memiliki data, dan konsumen siap menggunakannya.  Pada saat eksekusi, <b>Penghalang</b> dapat mengeluarkan panggilan balik tambahan sebelum penghalang dihapus dan semua peristiwa yang tertunda dapat dilanjutkan. <br><br>  Callback dapat berupa fungsi atau coroutine.  Dalam sebagian besar aplikasi, fungsi kemungkinan besar akan digunakan: itu dapat dijamin akan dieksekusi sebelum selesai, sebelum penghalang dihilangkan. <br><br>  Contohnya adalah fungsi <i><b>barrier_test</b></i> di <i><b>asyntest.py</b></i> .  Dalam cuplikan kode program ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyn <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text)</span></span></span><span class="hljs-function">:</span></span> print(text) barrier = asyn.Barrier(<span class="hljs-number"><span class="hljs-number">3</span></span>, callback, (<span class="hljs-string"><span class="hljs-string">'Synch'</span></span>,)) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): print(<span class="hljs-string"><span class="hljs-string">'{} '</span></span>.format(i), end=<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> barrier</code> </pre> <br>  beberapa contoh <i>laporan</i> coroutine mencetak hasil mereka dan berhenti sampai contoh lainnya juga selesai dan menunggu <b>penghalang</b> untuk melanjutkan.  Pada titik ini, panggilan balik sedang dilakukan.  Setelah selesai, coroutine asli dilanjutkan. <br><br>  <b>3.4 Semaphore</b> <br><br>  Semaphore membatasi jumlah coroutine yang dapat mengakses sumber daya.  Dapat digunakan untuk membatasi jumlah instance dari coroutine tertentu yang dapat berjalan secara bersamaan.  Ini dilakukan dengan menggunakan penghitung akses, yang diinisialisasi oleh konstruktor dan dikurangi setiap kali coroutine menerima semaphore. <br><br>  Cara termudah untuk menggunakannya dalam manajer konteks: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyn sema = asyn.Semaphore(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sema)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> sema: <span class="hljs-comment"><span class="hljs-comment">#   </span></span></code> </pre><br>  Contohnya adalah fungsi <i>semaphore_test</i> di <i><b>asyntest.py</b></i> . <br><br>  <b>3.4.1 ( <a href="" rel="nofollow"><i>Terbatas</i></a> ) semaphore</b> <br><br>  Ia bekerja mirip dengan kelas <i><b>Semaphore</b></i> kecuali bahwa jika metode <i>rilis</i> menyebabkan penghitung akses melebihi nilai awal, <i>ValueError</i> diatur. <br><br>  <b>3,5 Antrian</b> <br><br>  Kelas <i><b>Antrian</b></i> dikelola oleh <i><b>uasycio</b></i> resmi dan program sampel <i><b>aqtest.py</b></i> menunjukkan penggunaannya.  Antrian dibuat sebagai berikut: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> uasyncio.queues <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Queue q = Queue ()</code> </pre><br>  Coroutine pabrikan yang khas dapat bekerja sebagai berikut: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> slow_process() <span class="hljs-comment"><span class="hljs-comment">#       await q.put(result) #  ,       </span></span></code> </pre><br>  dan coroutine konsumen dapat berfungsi sebagai berikut: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span>(q.get()) <span class="hljs-comment"><span class="hljs-comment"># ,  q  print('Result was {}'.format(result))</span></span></code> </pre><br>  Kelas <i><b>Antrian</b></i> menyediakan fungsionalitas tambahan yang signifikan ketika ukuran antrian dapat dibatasi dan status dapat disurvei.  Perilaku dengan antrian kosong (jika ukuran terbatas) dan perilaku dengan antrian penuh dapat dikontrol.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentasi tentang ini ada dalam kode. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.6 Kelas Sinkronisasi Lainnya</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pustaka </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyn.py</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyediakan implementasi mikro dari beberapa fitur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lainnya </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas </font></font><a href="" rel="nofollow"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kondisi</font></font></i></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memungkinkan coroutine untuk memberi tahu coroutine lain yang menunggu pada sumber yang terkunci. Setelah menerima pemberitahuan, mereka akan mendapatkan akses ke sumber daya dan membuka kunci pada gilirannya. Pemberitahuan coroutine dapat membatasi jumlah coroutine yang akan diberitahukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas </font></font><a href="" rel="nofollow"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kumpulkan</font></font></i></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memungkinkan Anda untuk menjalankan daftar coroutine. Setelah menyelesaikan yang terakhir, daftar hasil akan dikembalikan. Implementasi "mikro" ini menggunakan sintaks yang berbeda. Timeout dapat diterapkan ke salah satu coroutine.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 Mengembangkan kelas untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncio</font></font></i></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam konteks pengembangan driver perangkat, tujuannya adalah untuk memastikan bahwa mereka bekerja tanpa pemblokiran. Driver coroutine harus memastikan bahwa coroutine lain dijalankan saat driver sedang menunggu perangkat melakukan operasi perangkat keras. Misalnya, tugas menunggu data tiba di UART, atau pengguna yang menekan tombol harus memungkinkan acara lain dijadwalkan hingga acara tersebut terjadi. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 Kelas menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i></b> <font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;"> menunggu Sebuah </font></b><b><i><font style="vertical-align: inherit;">coroutine</font></i></b></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat menjeda eksekusi sambil menunggu objek yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Di bawah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kelas custom yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dibuat dengan menerapkan metode </font><i><font style="vertical-align: inherit;">__await__</font></i><font style="vertical-align: inherit;"> khusus</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dimana generator kembali. </font><font style="vertical-align: inherit;">Kelas yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> digunakan sebagai berikut:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__await__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): print(<span class="hljs-string"><span class="hljs-string">'__await__ called'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">#     return 42 __iter__ = __await__ # .   async def bar(): foo = Foo() # Foo - awaitable  print('waiting for foo') res = await foo #   print('done', res) loop = asyncio.get_event_loop() loop.run_until_complete(bar())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak mendukung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="http://github.com/micropython/micropython/issues/2678" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">issue # 2678</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dan untuk solusi yang akan digunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__iter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">String </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__iter__ = __await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyediakan portabilitas antara </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">contoh kode, lihat kelas </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event, Barrier, Cancellable, Kondisi</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyn.py</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1.1 Penggunaan dalam manajer konteks</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objek yang diharapkan dapat digunakan dalam manajer konteks sinkron atau asinkron, menyediakan metode khusus yang diperlukan. </font><font style="vertical-align: inherit;">Sintaks:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> awaitable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a: <span class="hljs-comment"><span class="hljs-comment">#  'as'   #    async with awaitable as a: #    (.) #  -</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mencapai ini, </font><font style="vertical-align: inherit;">generator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> harus kembali </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sendiri</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini diteruskan ke variabel apa pun dalam </font><font style="vertical-align: inherit;">klausa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan juga memungkinkan metode khusus untuk bekerja. Lihat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyn.Condition</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyntest.condition_test di</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mana kelas </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kondisi</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan dapat digunakan dalam manajer konteks sinkron. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1.2 coroutine Tunggulah di</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bahasa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> membutuhkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah generator fungsi. Dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generator dan coroutine identik, jadi solusinya adalah menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasil dari coro (args)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tujuan dari panduan ini adalah untuk menawarkan kode yang portabel ke </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython 3.5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau yang lebih baru. Dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generator dan coroutine berbeda artinya. Dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coroutine memiliki </font><font style="vertical-align: inherit;">metode khusus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang diambil oleh generator. Ini portabel:</font></font><br><br><pre> <code class="python hljs">up = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-comment"><span class="hljs-comment">#   MicroPython? try: import uasyncio as asyncio up = True #    sys.implementation.name except ImportError: import asyncio async def times_two(n): # Coro   await asyncio.sleep(1) return 2 * n class Foo(): def __await__(self): res = 1 for n in range(5): print('__await__ called') if up: # MicroPython res = yield from times_two(res) else: # CPython res = yield from times_two(res).__await__() return res __iter__ = __await__ async def bar(): foo = Foo() # foo is awaitable print('waiting for foo') res = await foo #   print('done', res) loop = asyncio.get_event_loop() loop.run_until_complete(bar())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__, hasil dari asyncio.sleep (1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diizinkan oleh </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Saya masih tidak mengerti bagaimana ini dicapai. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2. Asynchronous iterators.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asynchronous iterators menyediakan sarana untuk mengembalikan urutan nilai yang terbatas atau tidak terbatas dan dapat digunakan sebagai sarana untuk mengambil elemen data sekuensial ketika mereka datang dari perangkat read-only. </font><font style="vertical-align: inherit;">Iterator asinkron memanggil kode asinkron dalam metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selanjutnya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kelas harus memenuhi persyaratan berikut:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini memiliki metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aiter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang </font><font style="vertical-align: inherit;">didefinisikan dalam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan mengembalikan iterator asynchronous.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini memiliki metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__anext__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang itu sendiri adalah coroutine - yaitu, didefinisikan melalui </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async def</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan mengandung setidaknya satu pernyataan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Untuk menghentikan iterasi, itu harus meningkatkan </font><font style="vertical-align: inherit;">pengecualian </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StopAsyncIteration</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai serial diambil menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async untuk</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seperti yang ditunjukkan di bawah ini:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncIterable</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.data = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) self.index = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__aiter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__anext__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.fetch_data() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> StopAsyncIteration <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-comment"><span class="hljs-comment">#     if self.index &gt;= len(self.data): return None x = self.data[self.index] self.index += 1 return x async def run(): ai = AsyncIterable() async for x in ai: print(x)</span></span></code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3 Manajer konteks asinkron</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kelas dapat dirancang untuk mendukung manajer konteks asinkron yang memiliki prosedur masuk dan keluar yang merupakan program bersama. Contohnya adalah Kelas </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kunci yang</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dijelaskan di atas. Ini memiliki </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aenter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coroutine </font><font style="vertical-align: inherit;">, yang secara logis diperlukan untuk operasi asinkron. Untuk mendukung protokol asinkron dari manajer konteks, </font><font style="vertical-align: inherit;">metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aexit__-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nya </font><font style="vertical-align: inherit;">juga harus berupa coroutine, yang dicapai dengan memasukkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu asyncio.sleep (0)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kelas-kelas tersebut dapat diakses dari dalam coroutine dengan sintaks berikut:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( lock )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> lock: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ( « bar » )</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti halnya manajer konteks biasa, metode keluar dijamin dipanggil ketika manajer konteks menyelesaikan pekerjaannya, seperti biasa, dan melalui pengecualian. Untuk mencapai ini, metode khusus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aenter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aexit__ digunakan,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang harus didefinisikan sebagai coroutine yang menunggu coroutine lain atau </font><font style="vertical-align: inherit;">objek yang bisa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Contoh ini diambil dari kelas </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lock</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__aenter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.acquire() <span class="hljs-comment"><span class="hljs-comment"># a coro    async def return self async def __aexit__(self, *args): self.release() #   await asyncio.sleep_ms(0)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async dengan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berisi klausa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai variabel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , variabel mendapatkan nilai yang dikembalikan oleh </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aenter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memastikan perilaku yang benar, firmware harus V1.9.10 atau yang lebih baru. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Pengecualian untuk batas waktu dan karena pembatalan tugas</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Topik-topik ini terkait: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mencakup pembatalan tugas dan menerapkan batas waktu untuk suatu tugas, melemparkan pengecualian untuk tugas tersebut dengan cara khusus. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1 Pengecualian</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika pengecualian terjadi di coroutine, itu harus diproses baik di coroutine ini atau di coroutine menunggu penyelesaiannya. Ini memastikan bahwa pengecualian tidak berlaku untuk penjadwal. Jika pengecualian terjadi, penjadwal akan berhenti bekerja dengan meneruskan pengecualian ke kode yang penjadwal dimulai. Oleh karena itu, untuk menghindari penjadwalan berhenti, coroutine yang diluncurkan dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop.create_task ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> harus menangkap setiap pengecualian di dalamnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lemparan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tutup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk </font><i><font style="vertical-align: inherit;">melempar</font></i><font style="vertical-align: inherit;"> pengecualian di coroutine tidak masuk akal. Ini menghancurkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , menyebabkan coroutine untuk memulai dan mungkin </font><b><font style="vertical-align: inherit;">keluar</font></b><font style="vertical-align: inherit;"> ketika masih dalam antrian eksekusi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh di atas menggambarkan situasi ini. Jika dibiarkan bekerja sampai akhir, itu berfungsi seperti yang diharapkan.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">3</span></span>) print(<span class="hljs-string"><span class="hljs-string">'About to throw exception.'</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> foo() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ZeroDivisionError: print(<span class="hljs-string"><span class="hljs-string">'foo  -   0'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># ! raise #     . except KeyboardInterrupt: print('foo was interrupted by ctrl-c') #   ! raise async def shutdown(): print('Shutdown is running.') #     await asyncio.sleep(1) print('done') loop = asyncio.get_event_loop() try: loop.run_until_complete(bar()) except ZeroDivisionError: loop.run_until_complete(shutdown()) except KeyboardInterrupt: print('Keyboard interrupt at loop level.') loop.run_until_complete(shutdown())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, mengeluarkan interupsi keyboard menyebabkan pengecualian masuk ke loop acara. Ini karena eksekusi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio.sleep</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dilewatkan ke loop acara. Oleh karena itu, aplikasi yang memerlukan kode yang jelas sebagai respons atas gangguan keyboard harus mendapatkan pengecualian di level loop acara. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2 Membatalkan dan waktu habis</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti disebutkan di atas, fungsi-fungsi ini bekerja dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melemparkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pengecualian untuk tugas dengan cara khusus menggunakan metode </font><b><font style="vertical-align: inherit;">MicroPython</font></b><font style="vertical-align: inherit;"> khusus </font><font style="vertical-align: inherit;">coroutine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pend_throw</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cara kerjanya tergantung pada versi. Dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio v.2.0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resmi </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> pengecualian tidak diproses hingga tugas terjadwal berikutnya. Ini memaksakan penundaan jika tugas mengharapkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">input-output </font><font style="vertical-align: inherit;">Waktu habis bisa melampaui periode nominalnya. </font><font style="vertical-align: inherit;">Tugas pembatalan tugas lainnya tidak dapat menentukan kapan pembatalan selesai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini ada solusi dan dua solusi.</font></font><br><br><ul><li><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penanganan masalah</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Pustaka </font><b><font style="vertical-align: inherit;">asyn</font></b><font style="vertical-align: inherit;"> menyediakan cara menunggu tugas atau kelompok tugas untuk dibatalkan. </font><font style="vertical-align: inherit;">Lihat Membatalkan pekerjaan (bagian 5.2.1.).</font></font></li><li> <a href="http://github.com/pfalcon/pycopy-lib" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perpustakaan Paul Sokolovsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyediakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio v2.4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi ini membutuhkan firmware </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pycopy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -nya </font><font style="vertical-align: inherit;">.</font></font></li><li> <a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast_io</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perpustakaan</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memecahkan masalah ini dalam</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (cara kurang elegan) dan berjalan firmware resmi.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hirarki pengecualian yang digunakan di sini adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exception-CancelledError-TimeoutError</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2.1 Membatalkan pekerjaan </font></font></b> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyediakan fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cancel (coro)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini berfungsi dengan melempar pengecualian untuk menggunakan coroutine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pend_throw</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini juga bekerja dengan coroutine bersarang. Penggunaannya adalah sebagai berikut:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-comment"><span class="hljs-comment">#  -  10 secs await asyncio.sleep(10) async def bar(loop): foo_instance = foo() #   coro loop.create_task(foo_instance) # code omitted asyncio.cancel(foo_instance)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika contoh ini dijalankan di bawah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio v2.0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , maka ketika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bilah</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kembali </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membatalkan,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> itu tidak akan berlaku sampai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terjadwal berikutnya </font><font style="vertical-align: inherit;">dan </font><font style="vertical-align: inherit;">penundaan hingga 10 detik dapat terjadi </font><font style="vertical-align: inherit;">ketika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dibatalkan </font><font style="vertical-align: inherit;">. Sumber keterlambatan lain akan terjadi jika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menunggu I / O. Di mana pun penundaan terjadi, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bilah</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak akan dapat menentukan apakah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo telah</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dibatalkan. Itu penting dalam beberapa kasus penggunaan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat menggunakan </font><b><font style="vertical-align: inherit;">perpustakaan </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paul Sokolovsky</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cukup menggunakan sleep (0):</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-comment"><span class="hljs-comment">#  -  10 secs await asyncio.sleep(10) async def bar(loop): foo_instance = foo() #   coro loop.create_task(foo_instance) #    asyncio.cancel(foo_instance) await asyncio.sleep(0) #   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini juga akan berfungsi di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio v2.0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (dan sembarang coroutine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) tidak pernah </font><font style="vertical-align: inherit;">kembali </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan tidak menunggu I / O. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perilaku yang mungkin mengejutkan kecerobohan terjadi ketika coroutine yang dijalankan oleh </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">create_task</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan dalam mode siaga </font><font style="vertical-align: inherit;">diharapkan untuk membatalkan </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pertimbangkan cuplikan ini:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-comment"><span class="hljs-comment">#  -  10 secs await asyncio.sleep(10) async def foo_runner(foo_instance): await foo_instance print('   ') async def bar(loop): foo_instance = foo() loop.create_task(foo_runner(foo_instance)) #    asyncio.cancel(foo_instance)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dibatalkan, itu dihapus dari antrian scheduler; </font><font style="vertical-align: inherit;">karena tidak memiliki </font><font style="vertical-align: inherit;">pernyataan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kembali</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , prosedur pemanggilan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo_runner</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak pernah dilanjutkan. </font><font style="vertical-align: inherit;">Disarankan agar Anda selalu menangkap pengecualian di ruang lingkup fungsi terluar untuk dibatalkan:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> my_coro <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> asyncio.CancelledError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my_coro</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak perlu menangkap pengecualian, karena akan disebarkan ke saluran panggilan dan ditangkap di sana.</font></font><br><br>  Catatan<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dilarang menggunakan </font><font style="vertical-align: inherit;">metode coroutine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">close</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ketika coroutine digunakan di luar scheduler. Ini merusak penjadwal, memaksa coroutine untuk mengeksekusi kode, bahkan jika itu tidak dijadwalkan. Ini mungkin memiliki konsekuensi yang tidak diinginkan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2.2 Coroutines dengan timeout</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Timeout diimplementasikan menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.wait_for ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.wait_for_ms ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mereka masing-masing mengambil coroutine dan latency dalam detik atau ms, sebagai argumen. Jika batas waktu berakhir, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimeoutError</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan </font><i><font style="vertical-align: inherit;">dilemparkan</font></i><font style="vertical-align: inherit;"> ke coroutine menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pend_throw</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pengecualian ini harus ditangkap oleh pengguna atau penelepon. </font><font style="vertical-align: inherit;">Ini diperlukan karena alasan yang dijelaskan di atas: jika batas waktu berakhir, dibatalkan. </font><font style="vertical-align: inherit;">Kecuali jika kesalahan ditangkap dan dikembalikan, satu-satunya cara penelepon dapat melanjutkan adalah menangkap pengecualian itu sendiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di mana pengecualian ditangkap oleh coroutine, saya memiliki kegagalan yang tidak jelas jika pengecualian tidak tertangkap di lingkup luar, seperti yang ditunjukkan di bawah ini:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forever</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: print(<span class="hljs-string"><span class="hljs-string">'Starting'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(<span class="hljs-number"><span class="hljs-number">300</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Got here'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> asyncio.TimeoutError: print(<span class="hljs-string"><span class="hljs-string">'Got timeout'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># And return async def foo(): await asyncio.wait_for(forever(), 5) await asyncio.sleep(2) loop = asyncio.get_event_loop() loop.run_until_complete(foo())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atau, Anda dapat mencegat fungsi panggilan: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forever</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'Starting'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(<span class="hljs-number"><span class="hljs-number">300</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Got here'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait_for(forever(), <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> asyncio.TimeoutError: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> print(<span class="hljs-string"><span class="hljs-string">'Timeout elapsed.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) loop = asyncio.get_event_loop() loop.run_until_complete(foo())</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan untuk </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uasyncio v2.0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini tidak berlaku untuk </font><b><font style="vertical-align: inherit;">perpustakaan </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paul Sokolovsky</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika coroutine mulai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu asyncio.sleep (t)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dengan t penundaan yang lama, coroutine tidak akan memulai kembali sampai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berakhir </font><font style="vertical-align: inherit;">. Jika batas waktu telah berlalu sebelum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berakhir </font><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimeoutError</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan </font><i><font style="vertical-align: inherit;">terjadi</font></i><font style="vertical-align: inherit;"> ketika coroutine dimuat - yaitu ketika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berakhir </font><font style="vertical-align: inherit;">. Secara real time dan dari perspektif penelepon, respons </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimeoutError-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nya </font><font style="vertical-align: inherit;">akan tertunda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika ini penting untuk aplikasi, buat penundaan lama sambil menunggu yang pendek di loop. Coroutine</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyn.sleep</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mendukung ini. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6 Interaksi dengan peralatan</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dasar interaksi antara </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan peristiwa asinkron eksternal adalah polling. Perangkat keras yang membutuhkan respons cepat dapat menggunakan interupsi. Tetapi interaksi antara rutin interupsi (ISR) dan coroutine pengguna akan didasarkan pada jajak pendapat. Misalnya, ISR dapat memanggil </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acara</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau menetapkan bendera global, sementara coroutine menunggu hasil polling objek setiap kali permintaan dijadwalkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interogasi dapat dilakukan dengan dua cara, eksplisit atau implisit. Yang terakhir dilakukan menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aliran I / O</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebuah mekanisme, yang merupakan sistem yang dirancang untuk perangkat streaming seperti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UART</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soket</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dalam jajak pendapat eksplisit paling sederhana, kode berikut ini dapat terdiri dari:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poll_my_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> my_flag <span class="hljs-comment"><span class="hljs-comment">#   ISR while True: if my_flag: my_flag = False # service the device await asyncio.sleep(0)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih bendera global, Anda bisa menggunakan variabel instance dari kelas </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau instance dari kelas yang menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Survei eksplisit dibahas di bawah ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polling implisit terdiri dari mengembangkan driver yang akan bertindak sebagai perangkat I / O streaming, seperti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UART</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soket </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I / O stream</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang melakukan polling pada perangkat menggunakan sistem </font><b><font style="vertical-align: inherit;">Python </font></b></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">select.poll</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : karena polling dilakukan dalam C, lebih cepat dan lebih efisien daripada jajak pendapat eksplisit. Penggunaan aliran I / O dibahas di bagian 6.3.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena keefektifannya, polling implisit memberikan keuntungan bagi driver perangkat I / O tercepat: driver streaming dapat dibuat untuk banyak perangkat yang biasanya tidak dianggap sebagai perangkat streaming. Ini dibahas secara lebih rinci di bagian 6.4. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1 Masalah Sinkronisasi</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baik jajak pendapat eksplisit dan implisit saat ini didasarkan pada perencanaan siklus. Misalkan I / O bekerja secara bersamaan dengan N custom coroutine, yang masing-masing berjalan dengan zero delay Ketika I / O dilayani, maka akan disurvei segera setelah semua operasi pengguna dijadwalkan. Perkiraan keterlambatan harus dipertimbangkan ketika merancang. Saluran I / O mungkin memerlukan penyanggaan, dengan peralatan servis ISR secara real time dari buffer dan coroutine, mengisi atau membebaskan buffer pada waktu yang lebih lambat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penting juga untuk mempertimbangkan kemungkinan melampaui: inilah kasus ketika sesuatu yang diinterogasi oleh coroutine terjadi lebih dari sekali sebelum benar-benar direncanakan oleh coroutine.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah waktu lainnya adalah akurasi latensi. Jika masalah coroutine</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms ( t ) <span class="hljs-comment"><span class="hljs-comment">#  </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penjadwal menjamin bahwa eksekusi akan ditangguhkan untuk setidaknya t ms. Penundaan yang sebenarnya mungkin lebih besar dari t, yang tergantung pada beban sistem saat ini. Jika saat ini coroutine lain sedang menunggu penyelesaian penundaan yang tidak nol, baris berikutnya akan segera dijadwalkan untuk dieksekusi. Tetapi jika coroutine lain juga menunggu eksekusi (baik karena mereka mengeluarkan penundaan nol, atau karena waktu mereka juga telah berakhir), mereka mungkin dijadwalkan untuk mengeksekusi lebih awal. Ini memperkenalkan ketidakpastian sinkronisasi ke fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep_ms ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nilai kasus terburuk untuk limpahan ini dapat dihitung dengan menjumlahkan nilai runtime dari semua coroutine tersebut untuk menentukan waktu transmisi kasus terburuk ke penjadwal.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versi fast_io</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam konteks ini menyediakan cara untuk memastikan bahwa streaming I / O akan disurvei pada setiap iterasi dari penjadwal. Diharapkan bahwa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resmi </font><font style="vertical-align: inherit;">akan menerima amandemen yang relevan pada waktunya. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2 Perangkat interogasi menggunakan coroutine</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini adalah pendekatan sederhana yang paling cocok untuk perangkat yang dapat diinterogasi dengan kecepatan yang relatif rendah. Hal ini terutama disebabkan oleh fakta bahwa pemungutan suara dengan interval pemungutan suara pendek (atau nol) dapat mengarah pada fakta bahwa coroutine menghabiskan lebih banyak waktu prosesor daripada yang diinginkan untuk jatuh ke dalam interval. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apoll.py</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menunjukkan pendekatan ini dengan menanyakan accelerometer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan interval 100 ms. Ia melakukan penyaringan sederhana untuk mengabaikan kebisingan, dan mencetak pesan setiap dua detik jika tidak ada gerakan yang terjadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aswitch.py</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyediakan driver untuk sakelar dan perangkat tombol. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh driver untuk perangkat yang mampu membaca dan menulis ditunjukkan di bawah ini. Untuk kemudahan pengujian, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UART 4 ​​mengemulasi perangkat bersyarat. Driver mengimplementasikan </font><b><i><font style="vertical-align: inherit;">RecordOrientedUart</font></i></b><font style="vertical-align: inherit;"> Class</font></font><b><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, di mana data disediakan dalam catatan panjang variabel yang terdiri dari instance byte. Objek menambahkan pembatas sebelum mengirim dan buffer data yang masuk sampai pembatas ditambahkan diterima. Ini hanya demo dan cara yang tidak efisien untuk menggunakan UART dibandingkan dengan streaming input / output. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendemonstrasikan transfer asinkron, kami mengasumsikan bahwa perangkat yang ditiru memiliki cara untuk memverifikasi bahwa transfer telah selesai dan bahwa aplikasi mengharuskan kami untuk menunggu. Tidak ada asumsi yang benar dalam contoh ini, tetapi kode memalsukannya dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu asyncio.sleep (0.1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memulai, jangan lupa menghubungkan output dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> X1 dan X2 (UART Txd dan Rxd)</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyb <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UART <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecordOrientedUart</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> DELIMITER = <span class="hljs-string"><span class="hljs-string">b'\0'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.uart = UART(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9600</span></span>) self.data = <span class="hljs-string"><span class="hljs-string">b''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__iter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Not __await__ issue #2678 data = b'' while not data.endswith(self.DELIMITER): yield from asyncio.sleep(0) # ,  : while not self.uart.any(): yield from asyncio.sleep(0) # timing may mean this is never called data = b''.join((data, self.uart.read(self.uart.any()))) self.data = data async def send_record(self, data): data = b''.join((data, self.DELIMITER)) self.uart.write(data) await self._send_complete() #          #        await asyncio.sleep(0) async def _send_complete(self): await asyncio.sleep(0.1) def read_record(self): # Synchronous: await the object before calling return self.data[0:-1] # Discard delimiter async def run(): foo = RecordOrientedUart() rx_data = b'' await foo.send_record(b'A line of text.') for _ in range(20): await foo #  coros       foo rx_data = foo.read_record() print('Got: {}'.format(rx_data)) await foo.send_record(rx_data) rx_data = b'' loop = asyncio.get_event_loop() loop.run_until_complete(run())</span></span></code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3 Menggunakan Mekanisme Streaming ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contoh menunjukkan input-output simultan pada satu UART dari mikroprosesor </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memulai, sambungkan output dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> X1 dan X2 (UART Txd dan Rxd)</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyb <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UART uart = UART(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9600</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> swriter = asyncio.StreamWriter(uart, {}) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> swriter.awrite(<span class="hljs-string"><span class="hljs-string">'Hello uart\n'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receiver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> sreader = asyncio.StreamReader(uart) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: res = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sreader.readline() print(<span class="hljs-string"><span class="hljs-string">'Received'</span></span>, res) loop = asyncio.get_event_loop() loop.create_task(sender()) loop.create_task(receiver()) loop.run_forever()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode pendukung dapat ditemukan di </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__init__.py</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di </font><font style="vertical-align: inherit;">perpustakaan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mekanisme ini berfungsi karena driver perangkat (ditulis dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) mengimplementasikan metode berikut: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl, membaca, membaca</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menulis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bagian 6.4: Menulis Driver Perangkat Streaming mengungkapkan rincian tentang bagaimana driver tersebut dapat ditulis dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UART dapat menerima data kapan saja. Mekanisme streaming I / O memeriksa karakter yang masuk tertunda setiap kali penjadwal mendapatkan kontrol. Ketika coroutine sedang berjalan, interrupt rutin menyangga karakter yang masuk; mereka akan dihapus ketika coroutine memberi jalan ke penjadwal. Oleh karena itu, aplikasi UART harus dirancang sedemikian rupa sehingga coroutine meminimalkan waktu antara transfer ke penjadwal untuk menghindari buffer overflows dan kehilangan data. Ini dapat ditingkatkan dengan menggunakan buffer baca UART yang lebih besar, atau kecepatan data yang lebih rendah. Atau, kontrol aliran perangkat keras akan memberikan solusi jika sumber data mendukungnya. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.1 Contoh UART pengemudi</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Program </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auart_hd.py</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggambarkan metode komunikasi dengan perangkat setengah dupleks, seperti perangkat yang menanggapi set perintah modem AT. Half duplex berarti perangkat tidak pernah mengirim data yang tidak diminta: transfernya selalu dilakukan sebagai respons terhadap perintah yang diterima dari master. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perangkat ini ditiru dengan menjalankan tes pada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan dua koneksi kabel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perangkat yang ditiru (sangat disederhanakan) merespons perintah apa pun dengan mengirim empat baris data dengan jeda di antara masing-masing untuk mensimulasikan pemrosesan yang lambat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wisaya mengirim perintah, tetapi tidak tahu sebelumnya berapa banyak baris data yang akan dikembalikan. Ini memulai timer restart yang me-restart setiap kali garis diterima. Ketika penghitung waktu berakhir, diasumsikan bahwa perangkat telah menyelesaikan transmisi dan daftar saluran yang diterima dikembalikan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kasus kegagalan perangkat juga ditunjukkan, yang dicapai dengan melewatkan transmisi sebelum menunggu tanggapan. Setelah batas waktu habis, daftar kosong dikembalikan. Lihat komentar kode untuk detail lebih lanjut. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.4 Pengembangan streaming (driver </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streaming</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) Unit</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> input stream / mekanisme keluaran ( </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">streaming I / O</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) untuk mengendalikan operasi streaming perangkat I / O seperti UART dan soket ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">socket</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Mekanisme ini dapat digunakan oleh driver dari setiap perangkat yang disurvei secara teratur dengan mendelegasikan ke penjadwal yang menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pilih</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , polling kesiapan perangkat apa pun dalam antrian. Ini lebih efisien daripada melakukan beberapa operasi coroutine, yang masing-masing polling perangkat, sebagian karena </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pilih</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditulis dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan juga karena coroutine yang melakukan polling ditunda sampai objek yang disurvei mengembalikan keadaan siap. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Driver perangkat yang mampu memperbaiki mekanisme input / output streaming sebaiknya mendukung metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamReader, StreamWriter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Perangkat yang dapat dibaca harus menyediakan setidaknya satu dari metode berikut. Harap perhatikan bahwa ini adalah metode sinkron. Metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (lihat di bawah) memastikan bahwa mereka dipanggil hanya ketika data tersedia. Metode harus dikembalikan secepat mungkin, menggunakan sebanyak mungkin data yang tersedia. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readline ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kembalikan karakter sebanyak mungkin, hingga karakter baris baru. Diperlukan jika menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamReader.readline () </font></font></i> <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baca (n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kembalikan karakter sebanyak mungkin, tetapi tidak lebih dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diperlukan jika menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamReader.read ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamReader.readexactly ()</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Driver yang dibuat harus menyediakan metode sinkron berikut dengan pengembalian segera: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tulis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan argumen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf, off, sz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di mana: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah buffer untuk menulis. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">off</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - offset ke buffer karakter pertama yang ditulis. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - jumlah karakter yang diminta untuk ditulis. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai kembali</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah jumlah karakter yang benar-benar ditulis (mungkin 1 jika perangkat lambat). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memastikan bahwa itu hanya akan dipanggil ketika perangkat siap menerima data.</font></font><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua perangkat harus menyediakan metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang mensurvei peralatan untuk menentukan status ketersediaannya. </font><font style="vertical-align: inherit;">Contoh khas untuk driver baca / tulis:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io MP_STREAM_POLL_RD = const(<span class="hljs-number"><span class="hljs-number">1</span></span>) MP_STREAM_POLL_WR = const(<span class="hljs-number"><span class="hljs-number">4</span></span>) MP_STREAM_POLL = const(<span class="hljs-number"><span class="hljs-number">3</span></span>) MP_STREAM_ERROR = const(<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIO</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(io.IOBase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    def ioctl(self, req, arg): # see ports/stm32/uart.c ret = MP_STREAM_ERROR if req == MP_STREAM_POLL: ret = 0 if arg &amp; MP_STREAM_POLL_RD: if hardware_has_at_least_one_char_to_read: ret |= MP_STREAM_POLL_RD if arg &amp; MP_STREAM_POLL_WR: if hardware_can_accept_at_least_one_write_character: ret |= MP_STREAM_POLL_WR return ret</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini adalah deskripsi </font><font style="vertical-align: inherit;">penundaan tunggu </font><font style="vertical-align: inherit;">Kelas </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MillisecTimer</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> utime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io MP_STREAM_POLL_RD = const(<span class="hljs-number"><span class="hljs-number">1</span></span>) MP_STREAM_POLL = const(<span class="hljs-number"><span class="hljs-number">3</span></span>) MP_STREAM_ERROR = const(<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MillisecTimer</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(io.IOBase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.end = <span class="hljs-number"><span class="hljs-number">0</span></span> self.sreader = asyncio.StreamReader(self) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__iter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.sreader.readline() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, ms)</span></span></span><span class="hljs-function">:</span></span> self.end = utime.ticks_add(utime.ticks_ms(), ms) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ioctl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, req, arg)</span></span></span><span class="hljs-function">:</span></span> ret = MP_STREAM_ERROR <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> req == MP_STREAM_POLL: ret = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> arg &amp; MP_STREAM_POLL_RD: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> utime.ticks_diff(utime.ticks_ms(), self.end) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>: ret |= MP_STREAM_POLL_RD <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang bisa digunakan sebagai berikut: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer_test</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( n )</span></span></span><span class="hljs-function">:</span></span> timer = ms_timer.MillisecTimer () <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> timer ( <span class="hljs-number"><span class="hljs-number">30</span></span> ) <span class="hljs-comment"><span class="hljs-comment">#  30 </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dibandingkan dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resmi </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> implementasi seperti itu tidak menawarkan keuntungan apa pun dibandingkan dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu asyncio.sleep_ms ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Penggunaan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memberikan penundaan yang jauh lebih akurat dalam pola penggunaan normal, ketika coroutine mengharapkan zero delay. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menggunakan penjadwalan I / O untuk mengaitkan suatu peristiwa dengan panggilan balik. Ini lebih efisien daripada siklus pemungutan suara, karena pemungutan suara tidak dijadwalkan sampai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kembali siap. Selanjutnya, panggilan balik dilakukan ketika panggilan balik berubah status.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io MP_STREAM_POLL_RD = const(<span class="hljs-number"><span class="hljs-number">1</span></span>) MP_STREAM_POLL = const(<span class="hljs-number"><span class="hljs-number">3</span></span>) MP_STREAM_ERROR = const(<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PinCall</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(io.IOBase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pin, *, cb_rise=None, cbr_args=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cb_fall=None, cbf_args=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self.pin = pin self.cb_rise = cb_rise self.cbr_args = cbr_args self.cb_fall = cb_fall self.cbf_args = cbf_args self.pinval = pin.value() self.sreader = asyncio.StreamReader(self) loop = asyncio.get_event_loop() loop.create_task(self.run()) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.sreader.read(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, _)</span></span></span><span class="hljs-function">:</span></span> v = self.pinval <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.cb_rise <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: self.cb_rise(*self.cbr_args) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.cb_fall <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: self.cb_fall(*self.cbf_args) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ioctl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, req, arg)</span></span></span><span class="hljs-function">:</span></span> ret = MP_STREAM_ERROR <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> req == MP_STREAM_POLL: ret = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> arg &amp; MP_STREAM_POLL_RD: v = self.pin.value() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v != self.pinval: self.pinval = v ret = MP_STREAM_POLL_RD <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan lagi - pada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resmi </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> penundaan mungkin tinggi. Bergantung pada desain aplikasi, versi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mungkin lebih efisien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Program demonstrasi </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iorw.py</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menunjukkan contoh lengkap. Harap dicatat bahwa pada saat penulisan artikel di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resmi </font><font style="vertical-align: inherit;">ada kesalahan karena ini </font></font><a href="http://github.com/micropython/pull/3836" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak berfungsi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ada dua solusi. Solusinya adalah menulis dua driver terpisah, satu untuk hanya baca dan satu untuk hanya menulis. Yang kedua adalah menggunakan </font></font><a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang memecahkan masalah ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resmi </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> input / output sangat </font></font><a href="http://github.com/micropython/micropython/issues/2664" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jarang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> direncanakan </font><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.5 Contoh lengkap: aremote.py</font></font></b> <br><br> <a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengemudi</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dirancang untuk menerima / mendekode sinyal dari kendali jarak jauh inframerah. Driver</font></font><a href="http://github.com/peterhinch/micropython-async/blob/master/nec_ir/aremote.py" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aremote.py itu sendiri</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Catatan berikut ini penting untuk penggunaan</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> asyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interupsi pada kontak mencatat waktu perubahan status (dalam mikrodetik) dan mengatur acara, melewatkan waktu ketika perubahan status pertama kali terjadi. Coroutine menunggu suatu peristiwa, melaporkan durasi paket data, kemudian menerjemahkan data yang tersimpan sebelum memanggil panggilan balik yang ditentukan oleh pengguna.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melewati waktu ke instance</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Event</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memungkinkan coroutine untuk mengkompensasi</font><font style="vertical-align: inherit;">keterlambatan</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> asyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saat mengatur periode penundaan.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.6 sensor lingkungan HTU21D</font></font></b> <br><br> <a href="http://github.com/peterhinch/micropython-async/blob/master/nec_ir/aremote.py" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sopir</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HTU21D Chip memberikan pengukuran yang akurat dari suhu dan kelembaban.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chip membutuhkan sekitar 120 ms untuk menerima kedua elemen data. Pengemudi bekerja secara serempak, memprakarsai tanda terima dan penggunaan</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menunggu asyncio.sleep (t)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebelum membaca data, memperbarui variabel suhu dan kelembaban, yang dapat diakses kapan saja, yang memungkinkan coroutine lain diluncurkan saat driver chip berjalan.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Tip dan Trik </font></font></b> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1 Program dibekukan Pembekuan</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> biasanya terjadi karena tugas diblokir tanpa konsesi: ini akan menyebabkan pembekuan seluruh sistem. Saat berkembang, ada baiknya memiliki coroutine yang secara berkala menyalakan LED bawaan. Ini memberikan konfirmasi bahwa penjadwal masih berjalan.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2 uasyncio save state</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat memulai program menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di REPL, lakukan soft reset (ctrl-D) di antara awal. Karena fakta bahwa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mempertahankan status di antara permulaan, perilaku yang tidak terduga dapat terjadi pada permulaan berikutnya. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.3 Pengumpulan sampah</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda dapat menjalankan coroutine dengan menentukan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impor gc terlebih dahulu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="python hljs">gc.collect () gc.treshold ( gc.mem_free () // <span class="hljs-number"><span class="hljs-number">4</span></span> + gc.mem_alloc ())</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tujuan dari ini dibahas </font><font style="vertical-align: inherit;">di </font></font><a href="http://docs.micropython.org/en/latest/reference/constrained.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di bagian tumpukan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.4 Pengujian</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dianjurkan untuk memastikan bahwa driver perangkat mempertahankan kontrol bila perlu, yang dapat dilakukan dengan menjalankan satu atau lebih salinan korout fiktif yang memulai siklus pencetakan pesan dan memeriksa apakah itu berjalan selama periode ketika pengemudi dalam mode siaga:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: print(<span class="hljs-string"><span class="hljs-string">'Roundrobin '</span></span>, n) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai contoh jenis bahaya yang mungkin timbul, dalam contoh di atas, metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecordOrientedUart </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada awalnya ditulis sebagai:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__await__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-string"><span class="hljs-string">b''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> data.endswith(self.DELIMITER): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.uart.any(): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) data = <span class="hljs-string"><span class="hljs-string">b''</span></span>.join((data, self.uart.read(self.uart.any()))) self.data = data</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akibatnya, eksekusi diperluas hingga seluruh catatan diterima, serta fakta bahwa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uart.any ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selalu mengembalikan jumlah karakter yang bukan nol yang diterima. Pada saat panggilan, semua karakter mungkin telah diterima. Situasi ini dapat diatasi menggunakan loop eksternal:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__await__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-string"><span class="hljs-string">b''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> data.endswith(self.DELIMITER): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment"># ,  : while not self.uart.any(): yield from asyncio.sleep(0) #        data = b''.join((data, self.uart.read(self.uart.any()))) self.data = data</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin perlu dicatat bahwa kesalahan ini tidak akan jelas jika data telah dikirim ke UART dengan kecepatan lebih rendah, daripada menggunakan tes umpan balik. Selamat datang di kegembiraan pemrograman waktu-nyata. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.5 Common error</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika suatu fungsi atau metode didefinisikan oleh </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan selanjutnya dipanggil seolah-olah itu adalah panggilan biasa (sinkron), </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak </font><b><font style="vertical-align: inherit;">menampilkan</font></b><font style="vertical-align: inherit;"> pesan kesalahan. Ini dengan desain. Biasanya ini mengarah pada fakta bahwa program diam-diam tidak berfungsi dengan benar:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># code loop.create_task(foo) #  1 1: foo     foo() #  2: .</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya punya </font></font><a href="http://github.com/micropython-lib/pull/292" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saran</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang menyarankan untuk memperbaiki situasi di opsi 1 menggunakan </font></font><a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modul </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">check_async_code.py</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mencoba mendeteksi kasus penggunaan coroutine yang meragukan. Itu ditulis dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan dirancang untuk bekerja pada PC. Digunakan dalam skrip yang ditulis sesuai dengan pedoman yang diuraikan dalam panduan ini dengan coroutine yang dinyatakan menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Modul ini mengambil satu argumen, jalur ke file sumber </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (atau --help).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harap dicatat bahwa itu agak kasar dan dimaksudkan untuk digunakan dalam file yang benar secara sintaksis, yang tidak dimulai secara default. </font><font style="vertical-align: inherit;">Gunakan alat, seperti </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pylint,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk memeriksa sintaksis umum ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pylint</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saat ini tidak memiliki kesalahan ini). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Script menghasilkan positif palsu. </font><font style="vertical-align: inherit;">Menurut rencana, coroutine adalah objek dari tingkat pertama, mereka dapat ditransfer ke fungsi dan disimpan dalam struktur data. </font><font style="vertical-align: inherit;">Bergantung pada logika program, Anda dapat menyimpan fungsi atau hasil pelaksanaannya. </font><font style="vertical-align: inherit;">Script tidak dapat menentukan tujuannya. </font><font style="vertical-align: inherit;">Ini bertujuan untuk mengabaikan kasus yang tampaknya benar ketika mengidentifikasi kasus lain untuk dipertimbangkan. </font><font style="vertical-align: inherit;">Misalkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo di</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mana coroutine dinyatakan sebagai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><pre> <code class="python hljs">loop.run_until_complete(foo()) <span class="hljs-comment"><span class="hljs-comment">#   bar(foo) #     ,      bar(foo()) z = (foo,) z = (foo(),) foo() #  :   .</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya merasa ini berguna, tetapi perbaikan selalu diterima. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7,6 Programming dengan soket ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soket</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ada dua pendekatan dasar untuk pemrograman soket </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Secara default, soket diblokir hingga operasi baca atau tulis yang ditentukan selesai. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mendukung penguncian soket menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">select.poll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk mencegah penjadwal memblokirnya. Dalam kebanyakan kasus, mekanisme ini paling mudah digunakan. Contoh kode klien dan server dapat ditemukan di direktori </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client_server</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Userver</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menggunakan aplikasi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">select.poll dengan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> polling secara eksplisit soket server.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soket klien menggunakannya secara implisit dalam arti bahwa mesin streaming </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menggunakannya secara langsung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harap perhatikan bahwa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">socket.getaddrinfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saat ini diblokir. Waktu dalam kode sampel akan minimal, tetapi jika pencarian DNS diperlukan, periode pemblokiran bisa signifikan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendekatan kedua untuk pemrograman soket adalah dengan menggunakan soket yang tidak menghalangi. Ini menambah kompleksitas, tetapi perlu di beberapa aplikasi, terutama jika koneksi melalui WiFi (lihat di bawah). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada saat penulisan (Maret 2019), dukungan TLS untuk soket yang tidak menghalangi sedang dikembangkan. Status pastinya tidak diketahui (untuk saya).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan soket yang tidak menghalangi membutuhkan perhatian terhadap detail. Jika pembacaan non-pemblokiran terjadi karena latensi server, tidak ada jaminan bahwa semua (atau apa saja) dari data yang diminta akan dikembalikan. Demikian pula, entri mungkin tidak selesai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, metode baca dan tulis asinkron harus secara iteratif melakukan operasi non-pemblokiran hingga data yang diperlukan dibaca atau ditulis. Dalam praktiknya, batas waktu mungkin diperlukan untuk menangani pemadaman server. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komplikasi lain adalah bahwa port ESP32 memiliki masalah yang memerlukan pembobolan yang cukup jahat untuk operasi bebas kesalahan. Saya belum menguji apakah ini masih terjadi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modul </font></font><a href="" rel="nofollow"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sock_nonblock.py</font></font></b></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggambarkan metode yang diperlukan. Ini bukan demo yang berfungsi dan keputusan cenderung bergantung pada aplikasi. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.6.1 Masalah dengan WiFi</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mekanisme streaming </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bukan pilihan terbaik saat mendeteksi pemadaman WiFi. Saya merasa perlu untuk menggunakan soket non-pemblokiran untuk menyediakan operasi gagal-aman dan menghubungkan kembali klien jika terjadi kegagalan. </font><a href="" rel="nofollow"><b><font style="vertical-align: inherit;">Dokumen</font></b></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini </font><font style="vertical-align: inherit;">menjelaskan masalah yang saya temui dalam aplikasi WiFi yang membuat soket tetap terbuka untuk waktu yang lama dan menguraikan solusinya. </font><a href="http://guthub.com/peterhinch/micropython-mqtt" rel="nofollow"><b><font style="vertical-align: inherit;">Pltcm</font></b></a></font><a href="" rel="nofollow"><b><font style="vertical-align: inherit;"></font></b></a><font style="vertical-align: inherit;"></font><br><br> <a href="http://guthub.com/peterhinch/micropython-mqtt" rel="nofollow"><b><font style="vertical-align: inherit;"></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menawarkan klien MQTT asinkron yang kuat yang memberikan integritas pesan selama kegagalan WiFi. Tautan serial dupleks-penuh asinkron sederhana antara klien nirkabel dan server berkabel dengan pengiriman pesan yang terjamin dijelaskan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.7 Argumen konstruktor loop peristiwa</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sebuah kesalahan kecil dapat terjadi jika Anda perlu membuat loop acara dengan nilai yang berbeda dari nilai default. Perulangan semacam itu harus dideklarasikan sebelum menjalankan kode lain menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> karena nilai-nilai ini mungkin diperlukan dalam kode ini. Jika tidak, kode akan diinisialisasi dengan nilai default:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> some_module bar = some_module.Bar() <span class="hljs-comment"><span class="hljs-comment">#   get_event_loop() #     loop = asyncio.get_event_loop(runq_len=40, waitq_len=40)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengingat bahwa mengimpor modul dapat mengeksekusi kode, cara paling aman adalah dengan instantiate loop peristiwa segera setelah mengimpor </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio loop = asyncio.get_event_loop(runq_len=<span class="hljs-number"><span class="hljs-number">40</span></span>, waitq_len=<span class="hljs-number"><span class="hljs-number">40</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> some_module bar = some_module.Bar() <span class="hljs-comment"><span class="hljs-comment"># get_event_loop()   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat menulis modul untuk digunakan oleh program lain, saya lebih suka menghindari menjalankan kode </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setelah impor. </font><font style="vertical-align: inherit;">Tulis fungsi dan metode untuk menunggu loop peristiwa sebagai argumen. </font><font style="vertical-align: inherit;">Kemudian pastikan bahwa hanya aplikasi tingkat atas yang memanggil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_event_loop</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> my_module <span class="hljs-comment"><span class="hljs-comment">#      loop = asyncio.get_event_loop(runq_len=40, waitq_len=40) bar = my_module.Bar(loop)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah ini dibahas di </font></font><a href="http://github.com/micropython/micropython-lib/issues/295" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 catatan untuk pemula</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Catatan ini dimaksudkan untuk pemula dalam kode asinkron dan mulai dengan deskripsi masalah yang coba dipecahkan oleh perencana, serta memberikan gambaran umum </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tentang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pendekatan </font><b><font style="vertical-align: inherit;">uasyncio</font></b><font style="vertical-align: inherit;"> untuk solusi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian 8.5 membahas manfaat relatif modul </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan _ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , serta mengapa Anda lebih suka menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coroutine </font><b><font style="vertical-align: inherit;">dengan</font></b><font style="vertical-align: inherit;"> penjadwalan proaktif (_thread). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.1 Masalah 1: loop acara</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplikasi firmware tipikal bekerja terus-menerus dan pada saat yang sama harus menanggapi peristiwa eksternal, yang mungkin termasuk perubahan tegangan pada ADC, tampilan gangguan perangkat keras, atau simbol yang diterima di UART, atau data yang tersedia pada soket. Peristiwa ini terjadi secara tidak sinkron, dan kode harus dapat merespons terlepas dari urutan terjadinya. Selain itu, tugas yang tergantung waktu mungkin diperlukan, seperti menginstal LED. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara yang jelas untuk melakukan ini adalah dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> acara </font><b><font style="vertical-align: inherit;">uasycio</font></b><font style="vertical-align: inherit;"> . Contoh ini bukan kode praktis, tetapi berfungsi untuk menggambarkan bentuk umum dari loop peristiwa.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">event_loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> led_1_time = <span class="hljs-number"><span class="hljs-number">0</span></span> led_1_period = <span class="hljs-number"><span class="hljs-number">20</span></span> led_2_time = <span class="hljs-number"><span class="hljs-number">0</span></span> led_2_period = <span class="hljs-number"><span class="hljs-number">30</span></span> switch_state = switch.state() <span class="hljs-comment"><span class="hljs-comment">#    while True: time_now = utime.time() if time_now &gt;= led_1_time: #  LED #1 led1.toggle() led_1_time = time_now + led_1_period if time_now &gt;= led_2_time: #  LED #2 led2.toggle() led_2_time = time_now + led_2_period #    LEDs if switch.value() != switch_state: switch_state = switch.value() #  - if uart.any(): #    UART</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perulangan seperti itu berfungsi untuk contoh sederhana, tetapi karena jumlah kejadian bertambah, kode dengan cepat menjadi rumit. Mereka juga melanggar prinsip-prinsip pemrograman berorientasi objek dengan menggabungkan sebagian besar logika program di satu tempat, daripada menghubungkan kode ke objek yang dikendalikan. Kami ingin mengembangkan kelas untuk LED berkedip yang dapat dimasukkan ke modul dan diimpor. Pendekatan OOP untuk LED berkedip mungkin terlihat seperti ini:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pyb <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LED_flashable</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, led_no)</span></span></span><span class="hljs-function">:</span></span> self.led = pyb.LED(led_no) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, period)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: self.led.toggle() <span class="hljs-comment"><span class="hljs-comment"># -     period, #         </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penjadwal di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memungkinkan Anda membuat kelas-kelas seperti itu. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.2 Masalah 2: Metode Pemblokiran</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Misalkan Anda perlu membaca sejumlah byte dari soket. Jika Anda memanggil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">socket.read (n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan socket blocking secara default, itu akan “block” (artinya, ia tidak akan dapat berhenti) sampai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> byte </font><font style="vertical-align: inherit;">diterima </font><font style="vertical-align: inherit;">. Selama periode ini, aplikasi tidak akan menanggapi acara lainnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan soket </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio yang tidak</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menghalangi </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> Anda dapat menulis metode baca asinkron. Tugas yang membutuhkan data akan (harus) diblokir sampai diterima, tetapi tugas lain akan dilakukan selama periode ini, yang akan memungkinkan aplikasi tetap responsif.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.3. Pendekatan Uasyncio</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kelas berikutnya memiliki LED yang dapat dinyalakan dan dimatikan, dan Anda juga dapat berkedip dengan kecepatan apa pun. Contoh </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED_async</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menggunakan metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jalankan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang dapat digunakan untuk operasi berkelanjutan. Perilaku LED dapat dikontrol menggunakan metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hidup (), mati (),</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lampu kilat (detik)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pyb <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LED_async</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, led_no)</span></span></span><span class="hljs-function">:</span></span> self.led = pyb.LED(led_no) self.rate = <span class="hljs-number"><span class="hljs-number">0</span></span> loop = asyncio.get_event_loop() loop.create_task(self.run()) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.rate &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(<span class="hljs-number"><span class="hljs-number">200</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self.led.toggle() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(int(<span class="hljs-number"><span class="hljs-number">500</span></span> / self.rate)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, rate)</span></span></span><span class="hljs-function">:</span></span> self.rate = rate <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.led.on() self.rate = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">off</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.led.off() self.rate = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu dicatat bahwa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on (), off ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flash ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah metode sinkron biasa. Mereka mengubah perilaku LED, tetapi segera kembali. Berkedip terjadi "di latar belakang." Ini dijelaskan secara rinci di bagian selanjutnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas mematuhi prinsip OOP, yang terdiri dari penyimpanan logika yang terkait dengan perangkat di kelas. Pada saat yang sama, penggunaan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memastikan bahwa aplikasi dapat merespons peristiwa lain saat LED berkedip. Program di bawah ini berkedip dengan empat LED </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada frekuensi yang berbeda, dan juga merespons tombol USR, yang melengkapinya.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pyb <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> led_async <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LED_async <span class="hljs-comment"><span class="hljs-comment"># ,   async def killer(): # ,      sw = pyb.Switch() while not sw.value(): await asyncio.sleep_ms(100) leds = [LED_async(n) for n in range(1, 4)] for n, led in enumerate(leds): led.flash(0.7 + n/4) loop = asyncio.get_event_loop() loop.run_until_complete(killer())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berbeda dengan contoh pertama dari sebuah loop peristiwa, logika yang terkait dengan sakelar berada dalam fungsi yang terpisah dari fungsi LED. </font><font style="vertical-align: inherit;">Perhatikan kode yang digunakan untuk memulai penjadwal:</font></font><br><br><pre> <code class="python hljs">loop = asyncio.get_event_loop() loop.run_until_complete(killer()) <span class="hljs-comment"><span class="hljs-comment">#    #       killer (), #   .</span></span></code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.4 Perencanaan dalam uasyncio </font></font></b> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python 3.5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mendukung konsep fungsi asinkron, juga dikenal sebagai coroutine atau tugas. </font><font style="vertical-align: inherit;">Coroutine harus menyertakan setidaknya satu pernyataan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>): print(<span class="hljs-string"><span class="hljs-string">'Hello world.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi ini mencetak pesan sepuluh kali dalam interval satu detik. Sementara fungsi dijeda untuk mengantisipasi penundaan, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penjadwal asyncio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan melakukan tugas-tugas lain, menciptakan ilusi menjalankannya secara bersamaan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika masalah coroutine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu asyncio.sleep_ms ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu asyncio.sleep (),</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tugas saat ini dijeda dan ditempatkan dalam antrian yang dipesan oleh waktu dan eksekusi dilanjutkan ke tugas di bagian atas antrian. Antrian dirancang sedemikian rupa sehingga, bahkan jika mode tidur yang ditentukan adalah nol, tugas-tugas relevan lainnya akan dilakukan sampai kembali saat ini. Ini adalah perencanaan "bundar jujur". Ini adalah praktik umum untuk menjalankan </font><i><font style="vertical-align: inherit;">menunggu loop asyncio.sleep (0)</font></i><font style="vertical-align: inherit;"> .</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga tugas tidak menunda eksekusi. </font><font style="vertical-align: inherit;">Berikut ini adalah loop sibuk-tunggu menunggu tugas lain untuk mengatur variabel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flag</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> global </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sayangnya, itu memonopoli prosesor, mencegah peluncuran coroutine lain:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> flag <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> flag: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-comment"><span class="hljs-comment">#  flag = False #    </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalahnya di sini adalah bahwa sampai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flagis False</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loop </font><i><font style="vertical-align: inherit;">melewati</font></i><font style="vertical-align: inherit;"> kontrol ke penjadwal, jadi tidak ada tugas lain yang akan dimulai. </font><font style="vertical-align: inherit;">Pendekatan yang tepat:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> flag <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> flag: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  flag = False #    </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk alasan yang sama, itu adalah praktik yang buruk untuk mengatur penundaan, misalnya, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utime.sleep (1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> karena memblokir tugas-tugas lain selama 1 detik; lebih tepat menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu asyncio.sleep (1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harap perhatikan bahwa keterlambatan yang dihasilkan oleh metode </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep_ms</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mungkin benar-benar melebihi waktu yang ditentukan. Ini disebabkan oleh kenyataan bahwa tugas-tugas lain akan dilakukan selama penundaan. Setelah periode penundaan berlalu, eksekusi tidak akan dilanjutkan sampai masalah tugas yang sedang berjalan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau berakhir. Coroutine yang berperilaku baik akan selalu menyatakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secara berkala. Di mana penundaan yang tepat diperlukan, terutama jika satu kurang dari beberapa ms, mungkin diperlukan untuk menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utime.sleep_us (kami)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.5 Mengapa kolaboratif, bukan penjadwalan berbasis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><i><font style="vertical-align: inherit;">_thread</font></i><font style="vertical-align: inherit;"> )?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reaksi awal pemula terhadap gagasan co-planning coroutine seringkali mengecewakan. Tentunya perencanaan streaming lebih baik? Mengapa saya harus secara eksplisit memberikan kontrol cara jika mesin virtual Python dapat melakukan ini untuk saya? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika datang ke sistem embedded, model kolaborasi memiliki dua keunggulan.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang pertama adalah ringan. Dimungkinkan untuk memiliki sejumlah besar coroutine, karena tidak seperti utas terjadwal, coroutine yang ditangguhkan membutuhkan lebih sedikit ruang. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua, ini menghindari beberapa masalah halus terkait dengan penjadwalan streaming. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam praktiknya, multitasking kolaboratif banyak digunakan, terutama dalam aplikasi antarmuka pengguna. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mempertahankan model perencanaan streaming, saya akan menunjukkan satu keuntungan: jika seseorang menulis</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range ( <span class="hljs-number"><span class="hljs-number">1000000</span></span> ): <span class="hljs-comment"><span class="hljs-comment">#  - </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu tidak akan memblokir tugas lain. Model kolaborasi mengasumsikan bahwa loop harus secara eksplisit memberikan kontrol setiap tugas sejumlah iterasi, misalnya, menempatkan kode dalam coroutine dan mengeluarkan secara berkala </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu asyncio.sleep (0)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, keuntungan ini tidak ada artinya dibandingkan dengan kerugiannya. Beberapa di antaranya dijelaskan dalam dokumentasi untuk menulis </font></font><a href="http://docs.micropython.org/en/latest/reference/isr_rules.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penangan interrupt.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dalam model penjadwalan streaming, setiap utas dapat mengganggu utas lainnya, mengubah data yang dapat digunakan pada utas lainnya. Sebagai aturan, jauh lebih mudah untuk menemukan dan memperbaiki kunci yang terjadi karena kesalahan yang tidak memberikan hasil dibandingkan dengan pendeteksian kesalahan yang terkadang sangat halus dan jarang ditemui yang dapat terjadi dalam kode yang ditulis dalam kerangka model dengan perencanaan streaming. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sederhananya, jika Anda menulis coroutine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Anda dapat yakin bahwa variabel tidak akan tiba-tiba diubah oleh coroutine lain: coroutine Anda memiliki kontrol penuh sampai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kembali menunggu asyncio.sleep (0)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu diingat bahwa interrupt handler adalah preemptive. Ini berlaku untuk gangguan perangkat keras dan lunak yang dapat terjadi di mana saja dalam kode Anda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskusi fasih tentang masalah perencanaan streaming dapat ditemukan di </font></font><a href="http://glyph.twistedmatrix.com/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.6 Interaksi</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam aplikasi non-sepele, coroutine harus berinteraksi. Metode </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> konvensional dapat digunakan </font><font style="vertical-align: inherit;">. Ini termasuk menggunakan variabel global atau mendeklarasikan coroutine sebagai metode objek: mereka dapat berbagi variabel instan. Atau, objek yang bisa berubah dapat dilewatkan sebagai argumen ke coroutine.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model perencanaan streaming memerlukan spesialis untuk memastikan bahwa kelas menyediakan koneksi yang aman; </font><font style="vertical-align: inherit;">dalam model kolaborasi, ini jarang diperlukan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.7. </font><font style="vertical-align: inherit;">Poll ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polling</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beberapa perangkat keras seperti accelerometer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tidak mendukung interupsi, dan karena itu harus disurvei (yaitu berkala diperiksa). </font><font style="vertical-align: inherit;">Polling juga dapat digunakan bersama dengan penangan interrupt: penangan interrupt memelihara peralatan dan menetapkan bendera. </font><font style="vertical-align: inherit;">Coroutine akan meng-polling flag - jika sudah diset, data diproses dan flag di-reset. </font><font style="vertical-align: inherit;">Pendekatan terbaik adalah dengan menggunakan kelas </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484472/">https://habr.com/ru/post/id484472/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484462/index.html">Scraping Github: Mencari "Rahasia" untuk Dikembangkan</a></li>
<li><a href="../id484464/index.html">Lelang motor Jepang, bagaimana semua itu terjadi</a></li>
<li><a href="../id484466/index.html">Common JavaScript Menjanjikan Hal-Hal yang Harus Diketahui Semua Orang</a></li>
<li><a href="../id484468/index.html">Budaya perusahaan merah adalah masalah utama bisnis Rusia (Bagian 2)</a></li>
<li><a href="../id484470/index.html">Extensible Extensions dalam JavaScript</a></li>
<li><a href="../id484480/index.html">Kapitalisasi 5 perusahaan teknologi AS terbesar melebihi $ 5 triliun</a></li>
<li><a href="../id484482/index.html">Program pendidikan kecil tentang pengolahan air</a></li>
<li><a href="../id484484/index.html">Ubuntu bukan desktop Linux terbaik</a></li>
<li><a href="../id484486/index.html">Komputer yang menolak mati</a></li>
<li><a href="../id484488/index.html">Seberapa membingungkan sistem kuantum? Jawabannya mungkin tidak bisa dihitung.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>