<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüè´ üö• üë† Desde copiar y pegar hasta componentes: reutilizar c√≥digo en diferentes aplicaciones üÜì üïù üö°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badoo desarrolla varias aplicaciones, y cada una de ellas es un producto separado con sus propias caracter√≠sticas, equipos de gesti√≥n, producto e inge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desde copiar y pegar hasta componentes: reutilizar c√≥digo en diferentes aplicaciones</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/466049/"><img src="https://habrastorage.org/webt/4j/xp/to/4jxptoi9jrqf5aynpoeurc816ee.jpeg"><br><br>  Badoo desarrolla varias aplicaciones, y cada una de ellas es un producto separado con sus propias caracter√≠sticas, equipos de gesti√≥n, producto e ingenier√≠a.  Pero todos trabajamos juntos en la misma oficina y resolvemos problemas similares. <br><br>  El desarrollo de cada proyecto tuvo lugar a su manera.  La base del c√≥digo fue influenciada no solo por diferentes marcos de tiempo y soluciones de productos, sino tambi√©n por la visi√≥n de los desarrolladores.  Al final, notamos que los proyectos tienen la misma funcionalidad, que es fundamentalmente diferente en la implementaci√≥n. <br><br>  Luego decidimos llegar a una estructura que nos dar√≠a la oportunidad de reutilizar funciones entre aplicaciones.  Ahora, en lugar de desarrollar funcionalidades en proyectos individuales, creamos componentes comunes que se integran en todos los productos.  Si est√° interesado en c√≥mo llegamos a esto, bienvenido a cat. <a name="habracut"></a><br><br>  Pero primero, deteng√°monos en los problemas, cuya soluci√≥n condujo a la creaci√≥n de componentes comunes.  Hubo varios de ellos: <br><br><ul><li>  copiar y pegar entre aplicaciones; <br></li><li>  procesos que insertan palos en las ruedas; <br></li><li>  arquitectura diferente de proyectos. <br></li></ul><br><img src="https://habrastorage.org/webt/wq/ls/ov/wqlsovroayg0xhqrwibqc37pv6y.png"><br><br>  <i>Este art√≠culo es una versi√≥n de texto de mi informe con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf 2019</a> , que se puede ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .</i> <br><br><h2>  Problema: copiar y pegar </h2><br>  Hace alg√∫n tiempo, cuando los √°rboles estaban m√°s difusos, el c√©sped era m√°s verde y yo era un a√±o m√°s joven, a menudo ten√≠amos la siguiente situaci√≥n. <br><br>  Hay un desarrollador, llam√©mosle Lesha.  Crea un m√≥dulo genial para su tarea, se lo cuenta a sus colegas y lo coloca en el repositorio de su aplicaci√≥n, donde lo utiliza. <br><br>  El problema es que todas nuestras aplicaciones est√°n en repositorios diferentes. <br><br><img src="https://habrastorage.org/webt/-a/1f/zq/-a1fzqhp9m--jhxy1tcrmx7plwi.png"><br><br>  El desarrollador Andrey en este momento solo est√° trabajando en otra aplicaci√≥n en un repositorio diferente.  Quiere usar este m√≥dulo en su tarea, que es sospechosamente similar a la que Lesha estaba involucrada.  Pero hay un problema: el proceso de reutilizaci√≥n del c√≥digo est√° completamente depurado. <br><br>  En esta situaci√≥n, Andrei escribir√° su decisi√≥n (que ocurre en el 80% de los casos) o copiar√° y pegar√° la soluci√≥n de Lyosha y cambiar√° todo en ella para que se ajuste a su aplicaci√≥n, tarea o estado de √°nimo. <br><br><img src="https://habrastorage.org/webt/2e/nd/95/2end959nckg-szaxu_nwwwcqxtm.png"><br><br>  Despu√©s de eso, Lesha puede actualizar su m√≥dulo agregando cambios a su c√≥digo para su tarea.  No conoce otra versi√≥n y solo actualizar√° su repositorio. <br><br>  Esta situaci√≥n trae varios problemas. <br><br>  En primer lugar, tenemos varias aplicaciones, cada una con su propio historial de desarrollo.  Al trabajar en cada aplicaci√≥n, el equipo del producto a menudo creaba soluciones que son dif√≠ciles de llevar a una sola estructura. <br><br>  En segundo lugar, equipos independientes participan en proyectos, que se comunican mal entre s√≠ y, por lo tanto, rara vez se informan entre s√≠ sobre actualizaciones / reutilizaci√≥n de uno u otro m√≥dulo. <br><br>  En tercer lugar, la arquitectura de la aplicaci√≥n es muy diferente: de MVP a MVI, de actividad divina a actividad individual. <br><br>  Bueno, lo m√°s destacado del programa: las aplicaciones est√°n en diferentes repositorios, cada uno con sus propios procesos. <br><br>  Al comienzo de la lucha contra estos problemas, fijamos el objetivo final: reutilizar nuestras mejores pr√°cticas (tanto l√≥gicas como de interfaz de usuario) entre todas las aplicaciones. <br><br><h2>  Decisiones: establecemos procesos </h2><br>  De los problemas anteriores, dos est√°n relacionados con los procesos: <br><br><ol><li>  Dos repositorios que comparten proyectos con un muro impenetrable. <br></li><li>  Equipos separados sin comunicaci√≥n establecida y requisitos diferentes de los equipos de aplicaci√≥n de productos. <br></li></ol><br>  Comencemos con el primero: estamos tratando con dos repositorios con la misma versi√≥n del m√≥dulo.  Te√≥ricamente, podr√≠amos usar git-subtree o soluciones similares y colocar m√≥dulos de proyecto comunes en repositorios separados. <br><br><img src="https://habrastorage.org/webt/ro/q0/nr/roq0nrr9xuy2my8ajbsldfcismw.png"><br><br>  El problema ocurre durante la modificaci√≥n.  A diferencia de los proyectos de c√≥digo abierto, que tienen una API estable y se distribuyen a trav√©s de fuentes externas, los cambios a menudo ocurren en componentes internos que rompen todo.  Cuando se utiliza el sub√°rbol, cada migraci√≥n se convierte en una molestia. <br><br>  Mis colegas del equipo de iOS tienen una experiencia similar y result√≥ que no tuvo mucho √©xito, como Anton Schukin habl√≥ en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la conferencia de Mobius</a> el a√±o pasado. <br><br>  Despu√©s de estudiar y comprender su experiencia, cambiamos a un √∫nico repositorio.  Todas las aplicaciones de Android ahora se encuentran en un solo lugar, lo que nos brinda ciertos beneficios: <br><br><ul><li>  puede reutilizar el c√≥digo de forma segura utilizando los m√≥dulos Gradle; <br></li><li>  logramos conectar la cadena de herramientas en CI usando una infraestructura para compilaciones y pruebas; <br></li><li>  Estos cambios eliminaron la barrera f√≠sica y mental entre los equipos, ya que ahora somos libres de usar los desarrollos y soluciones de los dem√°s. <br></li></ul><br>  Por supuesto, esta soluci√≥n tambi√©n tiene desventajas.  Tenemos un gran proyecto, que a veces no est√° sujeto a IDE y Gradle.  El problema podr√≠a resolverse parcialmente mediante los m√≥dulos de carga / descarga en Android Studio, pero es dif√≠cil usarlos si necesita trabajar simult√°neamente en todas las aplicaciones y, a menudo, cambiar. <br><br>  El segundo problema, la interacci√≥n entre equipos, constaba de varias partes: <br><br><ul><li>  equipos separados sin comunicaci√≥n establecida; <br></li><li>  distribuci√≥n indistinta de la responsabilidad de los m√≥dulos comunes; <br></li><li>  diferentes requisitos de los equipos de productos. <br></li></ul><br>  Para resolverlo, formamos equipos que se dedican a la implementaci√≥n de ciertas funcionalidades en cada aplicaci√≥n: por ejemplo, chat o registro.  Adem√°s del desarrollo, tambi√©n son responsables de integrar estos componentes en la aplicaci√≥n. <br><br>  Los equipos de productos ya tienen componentes existentes en sus manos, mejor√°ndolos y personaliz√°ndolos a las necesidades de un proyecto particular. <br><br>  Por lo tanto, ahora la creaci√≥n de un componente reutilizable es parte del proceso para toda la empresa, desde la etapa de la idea hasta el inicio de la producci√≥n. <br><br><h2>  Soluciones: arquitectura racionalizada </h2><br>  Nuestro siguiente paso hacia la reutilizaci√≥n fue racionalizar la arquitectura.  ¬øPor qu√© hicimos esto? <br><br>  Nuestra base de c√≥digo lleva el legado hist√≥rico de varios a√±os de desarrollo.  Junto con el tiempo y las personas, los enfoques cambiaron.  Entonces nos encontramos en una situaci√≥n con todo un zool√≥gico de arquitecturas, lo que result√≥ en los siguientes problemas: <br><br><ol><li>  La integraci√≥n de m√≥dulos comunes fue casi m√°s lenta que escribir nuevos.  Adem√°s de las caracter√≠sticas de lo funcional, era necesario soportar la estructura tanto del componente como de la aplicaci√≥n. <br></li><li>  Los desarrolladores que tuvieron que cambiar de una aplicaci√≥n a otra pasaron mucho tiempo dominando nuevos enfoques. <br></li><li>  A menudo, los contenedores se escribieron de un enfoque a otro, lo que equival√≠a a la mitad del c√≥digo en la integraci√≥n del m√≥dulo. <br></li></ol><br>  Al final, nos decidimos por el enfoque MVI, que estructuramos en nuestra biblioteca MVICore ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> ).  Est√°bamos particularmente interesados ‚Äã‚Äãen una de sus caracter√≠sticas: las actualizaciones de estado at√≥mico, que siempre garantizan la validez.  Fuimos un poco m√°s all√° y combinamos los estados de las capas l√≥gicas y de presentaci√≥n, reduciendo la fragmentaci√≥n.  Por lo tanto, llegamos a una estructura donde la √∫nica entidad es responsable de la l√≥gica, y view solo muestra el modelo creado a partir del estado. <br><br><img src="https://habrastorage.org/webt/ze/4z/kr/ze4zkr0ecnm_x9il17ibon6uzkk.png"><br><br>  La separaci√≥n de responsabilidades ocurre a trav√©s de la transformaci√≥n de modelos entre niveles.  Gracias a esto, obtenemos una bonificaci√≥n en forma de reutilizaci√≥n.  Conectamos los elementos desde el exterior, es decir, cada uno de ellos no sospecha que el otro existe, simplemente regalan algunos modelos y reaccionan a lo que les llega.  Esto le permite extraer componentes y usarlos en otros lugares escribiendo adaptadores para sus modelos. <br><br>  Veamos un ejemplo de una pantalla simple como se ve en la realidad. <br><br><img src="https://habrastorage.org/webt/wm/0k/cs/wm0kcsuh1io0cr4cnil0ui11gme.png"><br><br>  Utilizamos las interfaces b√°sicas de RxJava para indicar los tipos con los que funciona el elemento.  La entrada se indica mediante la interfaz Consumer &lt;T&gt;, salida - ObservableSource &lt;T&gt;. <br><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// input = Consumer&lt;ViewModel&gt; // output = ObservableSource&lt;Event&gt; class View( val events: PublishRelay&lt;Event&gt; ): ObservableSource&lt;Event&gt; by events, Consumer&lt;ViewModel&gt; { val button: Button val textView: TextView init { button.setOnClickListener { events.accept(Event.ButtonClick) } } override fun accept(model: ViewModel) { textView.text = model.text } }</span></span></code> </pre> <br>  Usando estas interfaces, podemos expresar View como Consumer &lt;ViewModel&gt; y ObservableSource &lt;Event&gt;.  Tenga en cuenta que ViewModel solo contiene el estado de la pantalla y tiene poco que ver con MVVM.  Una vez recibido el modelo, podemos mostrar los datos del mismo, y cuando hacemos clic en el bot√≥n, enviamos el evento, que se transmite al exterior. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// input = Consumer&lt;Wish&gt; // output = ObservableSource&lt;State&gt; class Feature: ReducerFeature&lt;Wish, State&gt;( initialState = State(counter = 0), reducer = ReducerImpl() ) { class ReducerImpl: Reducer&lt;Wish, State&gt; { override fun invoke(state: State, wish: Wish) = when (wish) { is Increment -&gt; state.copy(counter = state.counter + 1) } } }</span></span></code> </pre> <br>  Feature ya implementa ObservableSource y Consumer para nosotros;  necesitamos transferir all√≠ el estado inicial (contador igual a 0) e indicar c√≥mo cambiar este estado. <br><br>  Despu√©s de la transferencia de Wish, se llama Reducer, que crea uno nuevo basado en el √∫ltimo estado.  Adem√°s de Reducer, la l√≥gica puede ser descrita por otros componentes.  Puedes aprender m√°s sobre ellos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Despu√©s de crear los dos elementos, tenemos que conectarlos. <br><br><img width="250" src="https://habrastorage.org/webt/pq/kh/jp/pqkhjphpe4pvypmm5y8icqralhy.png" align="left"><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> eventToWish: (Event) -&gt; Wish = { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ButtonClick -&gt; Increment } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stateToModel: (State) -&gt; ViewModel = { ViewModel(text = state.counter.toString()) } Binder().apply { bind(view to feature using eventToWish) bind(feature to view using stateToModel) }</code> </pre> <br>  Primero, indicamos c√≥mo transformamos un elemento de un tipo en otro.  Entonces, ButtonClick se convierte en Incremento, y el campo de contador de Estado entra en texto. <br><br>  Ahora podemos crear cada una de las cadenas con la transformaci√≥n deseada.  Para esto usamos Binder.  Le permite crear relaciones entre ObservableSource y Consumer, observando el ciclo de vida.  Y todo esto con una buena sintaxis.  Este tipo de conexi√≥n nos lleva a un sistema flexible que nos permite extraer y usar elementos individualmente. <br><br>  Los elementos MVICore funcionan bastante bien con nuestro "zool√≥gico" de arquitecturas despu√©s de escribir envoltorios de ObservableSource y Consumer.  Por ejemplo, podemos ajustar los m√©todos de casos de uso de Clean Architecture en Wish / State y usarlos en la cadena en lugar de Feature. <br><br><img src="https://habrastorage.org/webt/l3/x7/ee/l3x7eef1pxxq4qbl6epceicz_1a.png"><br><br><h2>  Componente </h2><br>  Finalmente, pasamos a los componentes.  Como son <br><br>  Considere la pantalla en la aplicaci√≥n y div√≠dala en partes l√≥gicas. <br><br><img src="https://habrastorage.org/webt/s6/xb/mg/s6xbmgomehcdqao1psynv5mnnlc.png"><br><br>  Se puede distinguir: <br><br><ul><li>  barra de herramientas con logotipo y botones en la parte superior; <br></li><li>  una tarjeta con perfil y logo; <br></li><li>  Secci√≥n de Instagram. <br></li></ul><br>  Cada una de estas partes es el componente que se puede reutilizar en un contexto completamente diferente.  Por lo tanto, la secci√≥n de Instagram puede formar parte de la edici√≥n de perfiles en otra aplicaci√≥n. <br><br><img src="https://habrastorage.org/webt/o_/yh/c7/o_yhc7jqyzwma6l4nljmf2jasuk.png"><br><br>  En el caso general, un componente es una Vista, elementos l√≥gicos y componentes anidados en su interior, unidos por una funcionalidad com√∫n.  E inmediatamente surge la pregunta: ¬øc√≥mo ensamblarlos en una estructura soportada? <br><br>  El primer problema que encontramos es que MVICore ayuda a crear y vincular elementos, pero no ofrece una estructura com√∫n.  Al reutilizar elementos de un m√≥dulo com√∫n, no est√° claro d√≥nde juntar estas piezas: ¬ødentro de la parte com√∫n o en el lado de la aplicaci√≥n? <br><br>  En el caso general, definitivamente no queremos dar a la aplicaci√≥n piezas dispersas.  Idealmente, buscamos alg√∫n tipo de estructura que nos permita obtener dependencias y ensamblar el componente como un todo con el ciclo de vida deseado. <br><br>  Inicialmente, dividimos los componentes en pantallas.  La conexi√≥n de los elementos tuvo lugar junto a la creaci√≥n de contenedores DI para actividad o fragmento.  Estos contenedores ya conocen todas las dependencias, tienen acceso a la Vista y al ciclo de vida. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SomeScopedComponent : ScopedComponent&lt;SomeComponent&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SomeComponent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DaggerSomeComponent.builder() .build() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> SomeComponent.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Array&lt;Disposable&gt; = arrayOf( Binder().apply { bind(feature().news to otherFeature()) bind(feature() to view()) } ) }</code> </pre> <br>  Los problemas comenzaron en dos lugares a la vez: <br><br><ol><li>  DI comenz√≥ a trabajar con l√≥gica, lo que condujo a la descripci√≥n de todo el componente en una clase. <br></li><li>  Dado que el contenedor est√° conectado a una Actividad o Fragmento y describe al menos toda la pantalla, hay muchos elementos en dicha pantalla / contenedor, lo que se traduce en una gran cantidad de c√≥digo para conectar todas las dependencias de esta pantalla. <br></li></ol><br>  Para resolver los problemas en orden, comenzamos colocando la l√≥gica en un componente separado.  Por lo tanto, podemos recopilar todas las funciones dentro de este componente y comunicarnos con View a trav√©s de entradas y salidas.  Desde el punto de vista de la interfaz, parece un elemento MVICore normal, pero al mismo tiempo se crea a partir de varios otros. <br><br><img src="https://habrastorage.org/webt/bx/xf/ih/bxxfihgylnpbclxg3o9pcem9xr8.png"><br><br>  Una vez resuelto este problema, compartimos la responsabilidad de conectar los elementos.  Pero a√∫n compart√≠amos los componentes en las pantallas, lo que claramente no estaba al alcance de nuestra mano, lo que result√≥ en una gran cantidad de dependencias en un solo lugar. <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Scope</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> params: ScreenParams, news: NewsRelay, <span class="hljs-meta"><span class="hljs-meta">@OnDisposeAction</span></span> onDisposeAction: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>, globalFeature: GlobalFeature, conversationControlFeature: ConversationControlFeature, messageSyncFeature: MessageSyncFeature, conversationInfoFeature: ConversationInfoFeature, conversationPromoFeature: ConversationPromoFeature, messagesFeature: MessagesFeature, messageActionFeature: MessageActionFeature, initialScreenFeature: InitialScreenFeature, initialScreenExplanationFeature: InitialScreenExplanationFeature?, errorFeature: ErrorFeature, conversationInputFeature: ConversationInputFeature, sendRegularFeature: SendRegularFeature, sendContactForCreditsFeature: SendContactForCreditsFeature, screenEventTrackingFeature: ScreenEventTrackingFeature, messageReadFeature: MessageReadFeature?, messageTimeFeature: MessageTimeFeature?, photoGalleryFeature: PhotoGalleryFeature?, onlineStatusFeature: OnlineStatusFeature?, favouritesFeature: FavouritesFeature?, isTypingFeature: IsTypingFeature?, giftStoreFeature: GiftStoreFeature?, messageSelectionFeature: MessageSelectionFeature?, reportingFeature: ReportingFeature?, takePhotoFeature: TakePhotoFeature?, giphyFeature: GiphyFeature, goodOpenersFeature: GoodOpenersFeature?, matchExpirationFeature: MatchExpirationFeature, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pushIntegration: PushIntegration ) : AbstractMviComponent&lt;UiEvent, States&gt;(</code> </pre> <br>  La soluci√≥n correcta en esta situaci√≥n es romper el componente.  Como vimos anteriormente, cada pantalla consta de muchos elementos l√≥gicos que podemos dividir en partes independientes. <br><br>  Despu√©s de una peque√±a reflexi√≥n, llegamos a una estructura de √°rbol y, ingenuamente construy√©ndola a partir de componentes existentes, obtuvimos este esquema: <br><br><img src="https://habrastorage.org/webt/el/yl/v1/elylv1elwdrgyoqdamiepx0lleo.png"><br><br>  Por supuesto, mantener la sincronizaci√≥n de dos √°rboles (desde Vista y desde l√≥gica) es casi imposible.  Sin embargo, si el componente es responsable de mostrar su Vista, podemos simplificar este esquema.  Habiendo estudiado las soluciones ya creadas, repensamos nuestro enfoque, confiando en los RIB de Uber. <br><br><img src="https://habrastorage.org/webt/sy/xt/kd/syxtkdw8uiusbnrneqna1-bqfbe.png"><br><br>  Las ideas detr√°s de este enfoque son muy similares a las bases de MVICore.  RIB es un tipo de "recuadro negro", la comunicaci√≥n con la que se produce a trav√©s de una interfaz estrictamente definida de dependencias (a saber, entrada y salida).  A pesar de la aparente complejidad de admitir dicha interfaz en un producto iterativo r√°pido, tenemos grandes oportunidades para reutilizar el c√≥digo. <br><br>  Por lo tanto, en comparaci√≥n con las iteraciones anteriores, obtenemos: <br><br><ul><li>  l√≥gica encapsulada dentro de un componente; <br></li><li>  soporte para anidamiento, que permite dividir pantallas en partes; <br></li><li>  interacci√≥n con otros componentes a trav√©s de una interfaz estricta de entrada / salida con soporte para MVICore; <br></li><li>  Conexi√≥n segura en tiempo de compilaci√≥n de dependencias de componentes (confiando en Dagger como DI). <br></li></ul><br>  Por supuesto, esto est√° lejos de todo.  El repositorio en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> contiene una descripci√≥n m√°s detallada y actualizada. <br><br>  Y aqu√≠ tenemos un mundo perfecto.  Tiene componentes a partir de los cuales podemos construir un √°rbol totalmente reutilizable. <br><br>  Pero vivimos en un mundo imperfecto. <br><br><h2>  Bienvenido a la realidad! </h2><br>  En un mundo imperfecto, hay un mont√≥n de cosas que tenemos que soportar.  Nos preocupa lo siguiente: <br><br><ul><li>  diferentes funcionalidades: a pesar de toda la unificaci√≥n, todav√≠a estamos tratando con productos individuales con diferentes requisitos; <br></li><li>  soporte: ¬øc√≥mo sin nuevas funcionalidades bajo pruebas A / B? <br></li><li>  Legado (todo lo que se escribi√≥ antes de nuestra nueva arquitectura). <br></li></ul><br>  La complejidad de las soluciones aumenta exponencialmente, ya que cada aplicaci√≥n agrega algo propio a los componentes comunes. <br><br>  Considere el proceso de registro como un ejemplo de un componente com√∫n que se integra en las aplicaciones.  En general, el registro es una cadena de pantallas con acciones que afectan todo el flujo.  Cada aplicaci√≥n tiene diferentes pantallas y su propia interfaz de usuario.  El objetivo final es crear un componente reutilizable flexible, que tambi√©n nos ayudar√° a resolver los problemas de la lista anterior. <br><br><img src="https://habrastorage.org/webt/22/v6/cd/22v6cdpd9uf8ebuxcdo0j4mgc5a.png"><br><br><h3>  Requisitos diversos </h3><br>  Cada aplicaci√≥n tiene sus propias variaciones de registro √∫nicas, tanto desde el lado l√≥gico como desde el lado de la interfaz de usuario.  Por lo tanto, comenzamos a generalizar la funcionalidad en el componente con un m√≠nimo: descargando datos y enrutando todo el flujo. <br><br><img src="https://habrastorage.org/webt/nv/lr/1b/nvlr1bpwh_s1bw0lrlfk0py2zww.png"><br><br>  Dicho contenedor transfiere datos a la aplicaci√≥n desde el servidor, que se convierte en una pantalla terminada con l√≥gica.  El √∫nico requisito es que las pantallas que se pasan a dicho contenedor deben satisfacer las dependencias para interactuar con la l√≥gica de todo el flujo. <br><br>  Despu√©s de hacer este truco con un par de aplicaciones, notamos que la l√≥gica de las pantallas es casi la misma.  En un mundo ideal, crear√≠amos una l√≥gica com√∫n al personalizar la Vista.  La pregunta es c√≥mo personalizarlos. <br><br>  Como puede recordar de la descripci√≥n de MVICore, tanto View como Feature se basan en la interfaz de ObservableSource y Consumer.  Utiliz√°ndolos como una abstracci√≥n, podemos reemplazar la implementaci√≥n sin cambiar las partes principales. <br><br><img src="https://habrastorage.org/webt/ay/ox/lo/ayoxlo24e49tsprdsdxplsdv4yo.png"><br><br>  Entonces reutilizamos la l√≥gica dividiendo la IU.  Como resultado, el soporte se vuelve mucho m√°s conveniente. <br><br><h3>  Apoyo </h3><br>  Considere la prueba A / B para la variaci√≥n de elementos visuales.  En este caso, nuestra l√≥gica no cambia, lo que nos permite sustituir otra implementaci√≥n de Vista por la interfaz existente de ObservableSource y Consumer. <br><br><img src="https://habrastorage.org/webt/ag/qg/vm/agqgvmwnzn_cztnwovas8jk9ydw.png"><br><br>  Por supuesto, a veces los nuevos requisitos contradicen la l√≥gica ya escrita.  En este caso, siempre podemos volver al esquema original, donde la aplicaci√≥n suministra toda la pantalla.  Para nosotros es una especie de "caja negra", y no le importa al contenedor lo que le pasan, siempre que se observe su interfaz. <br><br><h3>  Integraci√≥n </h3><br>  Como muestra la pr√°ctica, la mayor√≠a de las aplicaciones utilizan Activity como las unidades b√°sicas, los medios de comunicaci√≥n entre los cuales se conocen desde hace mucho tiempo.  Todo lo que ten√≠amos que hacer era aprender a ajustar componentes en Activity y pasar datos a trav√©s de la entrada y la salida.  Al final result√≥ que, este enfoque funciona bien con fragmentos. <br><br>  Para aplicaciones de una sola actividad, nada cambia mucho.  Casi todos los marcos ofrecen sus elementos b√°sicos en los que los componentes RIB se pueden envolver. <br><br><h2>  Al final </h2><br>  Una vez superadas estas etapas, hemos aumentado significativamente el porcentaje de reutilizaci√≥n de c√≥digo entre los proyectos de nuestra empresa.  Por el momento, el n√∫mero de componentes se acerca a 100, y la mayor√≠a de ellos implementa la funcionalidad para varias aplicaciones a la vez. <br><br>  Nuestra experiencia muestra que: <br><br><ul><li>  a pesar de la mayor complejidad del dise√±o de componentes comunes, dados los requisitos de diferentes aplicaciones, su soporte es mucho m√°s f√°cil a largo plazo; <br></li><li>  construyendo componentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aislados unos de otros</a> , simplificamos enormemente su integraci√≥n en aplicaciones basadas en principios diferentes; <br></li><li>  Las revisiones de procesos, junto con el √©nfasis en el desarrollo y soporte de componentes, tienen un efecto positivo en la calidad de la funcionalidad general. <br></li></ul><br>  Mi colega Zsolt Kocsi escribi√≥ anteriormente sobre MVICore y las ideas detr√°s de √©l.  Recomiendo leer sus art√≠culos, que hemos traducido en nuestro blog ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3</a> ). <br><br>  Sobre las RIB, puede leer el art√≠culo original de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Uber</a> .  Y para el conocimiento pr√°ctico, recomiendo tomar algunas lecciones <a href="">de nosotros</a> (en ingl√©s). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466049/">https://habr.com/ru/post/466049/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466033/index.html">C√≥mo involucrar a un equipo en la b√∫squeda de ideas y obtener mucho m√°s que ideas</a></li>
<li><a href="../466039/index.html">Bibliotecas PHP para comercio electr√≥nico: trabajando con ATOL y Payture, analizando c√≥digos GS1 y otras tareas</a></li>
<li><a href="../466041/index.html">El primer evento fuera de l√≠nea del C√≠rculo de desarrolladores de Facebook: comunidad de Mosc√∫ - Evento de lanzamiento</a></li>
<li><a href="../466045/index.html">C√≥mo revitalizar una marca: una narraci√≥n que funcion√≥</a></li>
<li><a href="../466047/index.html">Dise√±o de tiendas online. Parte 3. P√°gina de inicio y cat√°logo</a></li>
<li><a href="../466051/index.html">Automatizaci√≥n de perfiles de reuni√≥n de Java 10/09</a></li>
<li><a href="../466053/index.html">Representaci√≥n de las empresas rusas de TI en Singapur: ¬øpor qu√© no?</a></li>
<li><a href="../466059/index.html">Libro "Design Thinking. Del conocimiento a los nuevos productos y mercados "</a></li>
<li><a href="../466065/index.html">Resumen de noticias de PostgreSQL. Edici√≥n No.17</a></li>
<li><a href="../466067/index.html">Protector de pantalla encantador para Kodi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>