<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîà üë©‚Äçüë©‚Äçüëß üö¥üèº Crea un sombreador de agua de dibujos animados para la web. Parte 2 üî© üèîÔ∏è üë®üèΩ‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la primera parte, vimos c√≥mo configurar el entorno y la superficie del agua. En esta parte, daremos flotabilidad a los objetos, agregaremos l√≠neas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crea un sombreador de agua de dibujos animados para la web. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416983/"> En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte,</a> vimos c√≥mo configurar el entorno y la superficie del agua.  En esta parte, daremos flotabilidad a los objetos, agregaremos l√≠neas de agua en la superficie y crearemos l√≠neas de espuma con un amortiguador de profundidad alrededor de los l√≠mites de los objetos que se cruzan con la superficie. <br><br>  Para que la escena se vea un poco mejor, le hice peque√±os cambios.  Puedes personalizar tu escena como quieras, pero hice lo siguiente: <br><br><ul><li>  Se agregaron modelos de un faro y un pulpo. </li><li> Se agreg√≥ un modelo de suelo con color <code>#FFA457</code> . </li><li>  Se agreg√≥ un color de cielo de <code>#6CC8FF</code> . </li><li>  Se <code>#FFC480</code> color de retroiluminaci√≥n <code>#FFC480</code> a la escena (estos par√°metros se pueden encontrar en la configuraci√≥n de la escena). </li></ul><br>  Mi escena original ahora se ve as√≠. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/2fa/0d5/bc22fa0d57b5120e75cced6f105bebd2.png"></div><a name="habracut"></a><br><h2>  Flotabilidad </h2><br>  La forma m√°s f√°cil de crear flotabilidad es usar un script para empujar objetos hacia arriba y hacia abajo.  Cree un nuevo script <strong>Buoyancy.js</strong> y establezca lo siguiente en su inicializaci√≥n: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getPosition().clone(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialRotation = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getEulerAngles().clone(); <span class="hljs-comment"><span class="hljs-comment">//     ,  //        //     this.time = Math.random() * 2 * Math.PI; };</span></span></code> </pre> <br>  Ahora en la actualizaci√≥n ejecutamos el incremento de tiempo y giramos el objeto: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      var pos = this.entity.getPosition().clone(); pos.y = this.initialPosition.y + Math.cos(this.time) * 0.07; this.entity.setPosition(pos.x,pos.y,pos.z); //    var rot = this.entity.getEulerAngles().clone(); rot.x = this.initialRotation.x + Math.cos(this.time * 0.25) * 1; rot.z = this.initialRotation.z + Math.sin(this.time * 0.5) * 2; this.entity.setLocalEulerAngles(rot.x,rot.y,rot.z); };</span></span></code> </pre> <br>  ¬°Aplique este script al bote y vea c√≥mo salta arriba y abajo del agua!  Puede aplicar este script a varios objetos (incluida la c√°mara; pru√©belo). <br><br><h2>  Textura superficial </h2><br>  Por ahora, podemos ver las olas mirando los bordes de la superficie del agua.  Agregar textura har√° que el movimiento de la superficie sea m√°s notable.  Adem√°s, es una forma de bajo costo para simular reflexiones y c√°usticos. <br><br>  Puedes intentar encontrar algunas texturas c√°usticas o crear una t√∫ mismo.  Dibuj√© <a href="" rel="external">una textura</a> en Gimp que puedes usar libremente.  Cualquier textura es adecuada, siempre que se pueda revestir sin juntas notables. <br><br>  Despu√©s de elegir la textura que le gusta, arr√°strela a la ventana Activos de su proyecto.  Necesitamos hacer referencia a esta textura desde el script Water.js, as√≠ que creemos un atributo para ello: <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'surfaceTexture'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'texture'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Surface Texture'</span></span> });</code> </pre> <br>  Y luego asignarlo en el editor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/672/61e/32f/67261e32f145eda9dab99d1866181ced.png"></div><br>  Ahora tenemos que pasarlo al sombreador.  Vaya a <strong>Water.js</strong> y configure la funci√≥n <code>CreateWaterMaterial</code> nuevo par√°metro: <br><br><pre> <code class="javascript hljs">material.setParameter(<span class="hljs-string"><span class="hljs-string">'uSurfaceTexture'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.surfaceTexture.resource);</code> </pre> <br>  Ahora vuelve a <strong>Water.frag</strong> y declara un nuevo uniforme: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture;</code> </pre> <br>  Ya casi hemos terminado.  Para representar una textura en un plano, necesitamos saber d√≥nde est√° cada p√≠xel en la malla.  Es decir, necesitamos transferir datos desde el sombreador de v√©rtices al fragmento. <br><br><h3>  Variables variables </h3><br>  <em>Las</em> variables variables le permiten transferir datos desde el sombreador de v√©rtices al fragmento.  Este es el tercer tipo de variables especiales que se pueden usar en el sombreador (las dos primeras son <em>uniformes</em> y de <em>atributo</em> ).  Se establece una variable para cada v√©rtice y cada p√≠xel puede acceder a ella.  Dado que hay muchos m√°s p√≠xeles que v√©rtices, el valor se interpola entre los v√©rtices (de ah√≠ el nombre "variable"; se desv√≠a de los valores que se le pasan). <br><br>  Para probarlo en funcionamiento, declare una nueva variable en <strong>Water.vert</strong> como variable: <br><br><pre> <code class="javascript hljs">varying vec2 ScreenPosition;</code> </pre> <br>  Y luego as√≠gnele el valor <code>gl_Position</code> despu√©s de calcularlo: <br><br><pre> <code class="javascript hljs">ScreenPosition = gl_Position.xyz;</code> </pre> <br>  Ahora regrese a <strong>Water.frag</strong> y declare la misma variable.  No podemos obtener la salida de los datos de depuraci√≥n del sombreador, pero podemos usar el color para la depuraci√≥n visual.  Aqu√≠ se explica c√≥mo hacerlo: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec3 ScreenPosition; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    varying- color = vec4(vec3(ScreenPosition.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  El plano ahora deber√≠a verse en blanco y negro, y la l√≠nea de divisi√≥n de color ir√° a <code>ScreenPosition.x</code> = 0. Los valores de color solo cambian de 0 a 1, pero los valores en <code>ScreenPosition</code> pueden estar fuera de este rango.  Se limitan autom√°ticamente, por lo tanto, cuando ve negro, puede ser 0 o un n√∫mero negativo. <br><br>  Lo que acabamos de hacer es pasar la posici√≥n de la pantalla de cada v√©rtice a cada p√≠xel.  Puede ver que la l√≠nea que separa los lados blanco y negro siempre pasar√° por el centro de la pantalla, independientemente de d√≥nde est√© realmente la superficie del mundo. <br><br><blockquote>  <em>Tarea 1: cree una nueva variable variable para transferir la posici√≥n en el mundo en lugar de la posici√≥n de la pantalla.</em>  <em>Visual√≠zalo de la misma manera.</em>  <em>Si el color no cambia con el movimiento de la c√°mara, entonces todo se hace correctamente.</em> </blockquote><br><h3>  Usando UV </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">UV</a> son las coordenadas 2D de cada v√©rtice en la malla, normalizadas de 0 a 1. Son necesarias para el muestreo correcto de la textura en el plano, y ya las configuramos en la parte anterior. <br><br>  Declararemos un nuevo atributo en <strong>Water.vert</strong> (este nombre se toma de la definici√≥n de sombreador en Water.js): <br><br><pre> <code class="javascript hljs">attribute vec2 aUv0;</code> </pre> <br>  Y ahora solo tenemos que pasarlo al sombreador de fragmentos, as√≠ que solo cree variables y as√≠gnele el valor del atributo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Water.vert //        varying vec2 vUv0; // .. //        //  varying,        vUv0 = aUv0;</span></span></code> </pre> <br>  Ahora declararemos la misma variable variable en el fragment shader.  Para asegurarnos de que todo funciona, podemos visualizar la depuraci√≥n como antes, y luego Water.frag se ver√° as√≠: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  UV color = vec4(vec3(vUv0.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  Deber√≠a ver un gradiente que confirma que tenemos un valor de 0 de un extremo y 1 del otro.  Ahora para probar la textura de verdad, todo lo que tenemos que hacer es: <br><br><pre> <code class="javascript hljs">color = texture2D(uSurfaceTexture,vUv0);</code> </pre> <br>  Despu√©s de eso, veremos la textura en la superficie: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/9bf/ae2/f499bfae266b0aa16709bbea0280df6f.png"></div><br><h3>  Estilo de textura </h3><br>  En lugar de simplemente establecer la textura como el nuevo color, combin√©moslo con el azul existente: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec4 WaterLines = texture2D(uSurfaceTexture,vUv0); color.rgba += WaterLines.r; gl_FragColor = color; }</code> </pre> <br>  Esto funciona porque el color de la textura es negro (0) en todas partes, excepto en las l√≠neas de agua.  Agreg√°ndolo, no cambiamos el color azul inicial, con la excepci√≥n de los lugares con l√≠neas donde se vuelve m√°s claro. <br><br>  Sin embargo, esta no es la √∫nica forma de combinar colores. <br><br><blockquote>  <em>Tarea 2: ¬øPuedes combinar los colores para obtener el efecto m√°s d√©bil que se muestra a continuaci√≥n?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/e18/22a/a3de1822a348656f47e5bd6cfa6cbed5.png"></div><br><h3>  Textura en movimiento </h3><br>  Como efecto final, queremos que las l√≠neas se muevan a lo largo de la superficie y no se vea tan est√°tica.  Para hacer esto, aprovecharemos el hecho de que cualquier valor fuera del intervalo de 0 a 1, pasado a la funci√≥n <code>texture2D</code> , ser√° transferido (por ejemplo, tanto 1.5 como 2.5 son iguales a 0.5).  Por lo tanto, podemos aumentar nuestra posici√≥n mediante la variable de tiempo uniforme que ya hemos establecido para aumentar o disminuir la densidad de las l√≠neas en la superficie, lo que le dar√° al sombreador de fragmentos final esta forma: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; uniform float uTime; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0; <span class="hljs-comment"><span class="hljs-comment">//      1 //     pos *= 2.0; //   ,      pos.y += uTime * 0.02; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r; gl_FragColor = color; }</span></span></code> </pre> <br><h2>  L√≠neas de espuma y tamp√≥n de profundidad </h2><br>  Al representar l√≠neas de espuma alrededor de los objetos en el agua, es mucho m√°s f√°cil ver qu√© tan inmersos est√°n los objetos y d√≥nde cruzan la superficie.  Adem√°s, de esta manera nuestra agua se vuelve mucho m√°s cre√≠ble.  Para darnos cuenta de las l√≠neas de espuma, de alguna manera necesitamos descubrir d√≥nde est√°n los l√≠mites de cada objeto y hacerlo de manera efectiva. <br><br><h3>  Truco </h3><br>  Necesitamos aprender a determinar si un p√≠xel en la superficie del agua est√° cerca del objeto.  Si es as√≠, podemos pintarlo del color de la espuma.  No hay formas simples de resolver este problema (que yo sepa).  Por lo tanto, para resolverlo, utilizo una t√©cnica √∫til para resolver problemas: tomar√© un ejemplo para el cual conocemos la respuesta y veremos si podemos generalizarla. <br><br>  Echa un vistazo a la imagen de abajo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d0/0e7/eec/4d00e7eec8714a365c110aea67df9fab.png"></div><br>  ¬øQu√© p√≠xeles deber√≠an ser parte de la espuma?  Sabemos que deber√≠a verse as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a8/541/c4f/1a8541c4f8fdd65879966b909805c484.png"></div><br>  As√≠ que veamos dos p√≠xeles espec√≠ficos.  A continuaci√≥n los marqu√© con asteriscos.  El negro estar√° en la espuma y el rojo no.  ¬øC√≥mo los distinguimos en un sombreador? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/d35/fb2/012d35fb25d42c19a86adaa081048237.png"></div><br>  Sabemos que a pesar de que estos dos p√≠xeles en el espacio de la pantalla est√°n cerca uno del otro (ambos se representan en la parte superior del faro), de hecho, est√°n muy lejos en el espacio del mundo.  Podemos verificar esto mirando la misma escena desde un √°ngulo diferente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd3/5a0/31b/cd35a031bbd18805128ebd44ed1c1279.png"></div><br>  Tenga en cuenta que la estrella roja no se encuentra en el faro, como nos pareci√≥, pero la negra est√° realmente all√≠.  Podemos distinguir el uso de la distancia a la c√°mara, que generalmente se llama "profundidad".  La profundidad 1 significa que el punto est√° muy cerca de la c√°mara, la profundidad 0 significa que est√° muy lejos.  Pero esto no es solo una cuesti√≥n de distancias absolutas en el mundo, profundidad o c√°mara.  La profundidad <em>relativa al p√≠xel detr√°s es</em> importante. <br><br>  Mira de nuevo a la primera vista.  Digamos que el faro tiene un valor de profundidad de 0.5.  La profundidad de la estrella negra estar√° muy cerca de 0.5.  Es decir, √©l y el p√≠xel debajo tienen valores de profundidad muy cercanos.  Por otro lado, el asterisco rojo tendr√° una profundidad mucho mayor, ya que est√° m√°s cerca de la c√°mara, digamos 0.7.  Y aunque el p√≠xel detr√°s de √©l todav√≠a est√° en el faro, tiene un valor de profundidad de 0.5, es decir, hay m√°s diferencia. <br><br>  Este es el truco.  <em>Cuando la profundidad de un p√≠xel en la superficie del agua est√° lo suficientemente cerca de la profundidad del p√≠xel sobre el que se dibuja, entonces estamos bastante cerca del borde de alg√∫n objeto</em> y podemos convertir el p√≠xel como espuma. <br><br>  Es decir, necesitamos m√°s informaci√≥n de la que tenemos en cualquier p√≠xel.  De alguna manera, necesitamos descubrir la profundidad del p√≠xel sobre el que se debe dibujar.  Y aqu√≠ el buffer de profundidad es √∫til para nosotros. <br><br><h3>  Tamp√≥n de profundidad </h3><br>  Puede pensar en un b√∫fer de cuadro o un b√∫fer de cuadro como un renderizado o textura objetivo fuera de la pantalla.  Cuando necesitamos leer datos, necesitamos renderizar fuera de la pantalla.  Esta t√©cnica se usa en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">el efecto de humo</a> . <br><br>  El b√∫fer de profundidad es un renderizado objetivo especial que contiene informaci√≥n sobre los valores de profundidad de cada p√≠xel.  No olvide que el valor en <code>gl_Position</code> , calculado en el sombreador de v√©rtices, era el valor del espacio de la pantalla, pero tambi√©n tiene una tercera coordenada: el valor Z. Este valor Z se utiliza para calcular la profundidad, que se escribe en el b√∫fer de profundidad. <br><br>  El b√∫fer de profundidad est√° destinado a la representaci√≥n correcta de la escena sin la necesidad de ordenar objetos de atr√°s hacia adelante.  Cada p√≠xel a dibujar primero verifica el b√∫fer de profundidad.  Si su valor de profundidad es mayor que el valor en el b√∫fer, entonces se dibuja y su propio valor sobrescribe el valor del b√∫fer.  De lo contrario, se descarta (porque significa que hay otro objeto delante de √©l). <br><br>  De hecho, puede deshabilitar la escritura en el b√∫fer de profundidad para ver c√≥mo se ver√≠a todo sin √©l.  Intentemos hacerlo en Water.js: <br><br><pre> <code class="javascript hljs">material.depthTest = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Notar√° que ahora el agua siempre se extraer√° desde arriba, incluso si est√° detr√°s de objetos opacos. <br><br><h3>  Visualizaci√≥n del buffer de profundidad </h3><br>  Agreguemos una forma de representar el b√∫fer de profundidad con fines de depuraci√≥n.  Cree un nuevo script <strong>DepthVisualize.js</strong> .  Adjuntarlo a la c√°mara. <br><br>  Para acceder al b√∫fer de profundidad en PlayCanvas, solo escriba lo siguiente: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.camera.camera.requestDepthMap();</code> </pre> <br>  Entonces, inyectamos autom√°ticamente la variable uniforme en todos nuestros sombreadores, que podemos usar al declararla de la siguiente manera: <br><br><pre> <code class="javascript hljs">uniform sampler2D uDepthMap;</code> </pre> <br>  A continuaci√≥n se muestra un script de ejemplo que solicita un mapa de profundidad y lo representa en la parte superior de una escena.  Ha configurado un reinicio en caliente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DepthVisualize = pc.createScript(<span class="hljs-string"><span class="hljs-string">'depthVisualize'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  initialize,       DepthVisualize.prototype.initialize = function() { this.entity.camera.camera.requestDepthMap(); this.antiCacheCount = 0; //    ,         this.SetupDepthViz(); }; DepthVisualize.prototype.SetupDepthViz = function(){ var device = this.app.graphicsDevice; var chunks = pc.shaderChunks; this.fs = ''; this.fs += 'varying vec2 vUv0;'; this.fs += 'uniform sampler2D uDepthMap;'; this.fs += ''; this.fs += 'float unpackFloat(vec4 rgbaDepth) {'; this.fs += ' const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);'; this.fs += ' float depth = dot(rgbaDepth, bitShift);'; this.fs += ' return depth;'; this.fs += '}'; this.fs += ''; this.fs += 'void main(void) {'; this.fs += ' float depth = unpackFloat(texture2D(uDepthMap, vUv0)) * 30.0; '; this.fs += ' gl_FragColor = vec4(vec3(depth),1.0);'; this.fs += '}'; this.shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, this.fs, "renderDepth" + this.antiCacheCount); this.antiCacheCount ++; //     ,        this.command = new pc.Command(pc.LAYER_FX, pc.BLEND_NONE, function () { pc.drawQuadWithShader(device, null, this.shader); }.bind(this)); this.command.isDepthViz = true; //    ,      this.app.scene.drawCalls.push(this.command); }; //  update,     DepthVisualize.prototype.update = function(dt) { }; //  swap,      //      DepthVisualize.prototype.swap = function(old) { this.antiCacheCount = old.antiCacheCount; //      for(var i=0;i&lt;this.app.scene.drawCalls.length;i++){ if(this.app.scene.drawCalls[i].isDepthViz){ this.app.scene.drawCalls.splice(i,1); break; } } //    this.SetupDepthViz(); }; //      ,  : // http://developer.playcanvas.com/en/user-manual/scripting/</span></span></code> </pre> <br>  Intente copiar el c√≥digo y comente / descomente la l√≠nea <code>this.app.scene.drawCalls.push(this.command);</code>  para habilitar / deshabilitar la representaci√≥n de profundidad.  Esto deber√≠a verse como la imagen de abajo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c09/93a/c4f/c0993ac4f8ed7a4c739658bbff69e455.png"></div><br><blockquote>  <em>Tarea 3: la superficie del agua no se introduce en el b√∫fer de profundidad.</em>  <em>El motor de PlayCanvas hace esto a prop√≥sito.</em>  <em>¬øPuedes entender por qu√©?</em>  <em>¬øQu√© tiene de especial el material de agua?</em>  <em>En otras palabras, dadas nuestras reglas para verificar profundidades, ¬øqu√© pasar√≠a si se escribieran p√≠xeles de agua en el b√∫fer de profundidad?</em> </blockquote><br>  <em>Sugerencia: puede cambiar una l√≠nea en Water.js, que le permite escribir agua en el b√∫fer de profundidad.</em> <br><br>  Tambi√©n se debe tener en cuenta que en la funci√≥n de inicializaci√≥n, multiplico el valor de profundidad por 30. Esto es necesario para verlo claramente, porque de lo contrario el rango de valores ser√≠a demasiado peque√±o para mostrar tonos de color. <br><br><h3>  Implementaci√≥n de trucos </h3><br>  Hay varias funciones auxiliares en el motor PlayCanvas para trabajar con valores de profundidad, pero al momento de la escritura, no se lanzaron en producci√≥n, por lo que tendremos que configurarlos nosotros mismos. <br><br>  <strong>Definimos las</strong> siguientes variables uniformes en <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   uniform-    PlayCanvas uniform sampler2D uDepthMap; uniform vec4 uScreenSize; uniform mat4 matrix_view; //      uniform vec4 camera_params;</span></span></code> </pre> <br>  Definimos estas funciones auxiliares sobre la funci√≥n principal: <br><br><pre> <code class="javascript hljs">#ifdef GL2 float linearizeDepth(float z) { z = z * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (camera_params.z * z + camera_params.w); } #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #ifndef UNPACKFLOAT #define UNPACKFLOAT float unpackFloat(vec4 rgbaDepth) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec4 bitShift = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">256.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot(rgbaDepth, bitShift); } #endif #endif float getLinearScreenDepth(vec2 uv) { #ifdef GL2 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y; #endif } float getLinearDepth(vec3 pos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -(matrix_view * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)).z; } float getLinearScreenDepth() { vec2 uv = gl_FragCoord.xy * uScreenSize.zw; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getLinearScreenDepth(uv); }</code> </pre> <br>  Pasaremos la informaci√≥n del sombreador sobre la c√°mara en <strong>Water.js</strong> .  Pegue esto donde pase las otras variables uniformes como uTime: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">"Camera"</span></span>).camera; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = camera.nearClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = camera.farClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera_params = [ <span class="hljs-number"><span class="hljs-number">1</span></span>/f, f, (<span class="hljs-number"><span class="hljs-number">1</span></span>-f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-number"><span class="hljs-number">1</span></span> + f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span> ]; material.setParameter(<span class="hljs-string"><span class="hljs-string">'camera_params'</span></span>, camera_params);</code> </pre> <br>  Finalmente, necesitamos una posici√≥n en el mundo de cada p√≠xel para nuestro sombreador de fragmentos.  Tenemos que obtenerlo del sombreador de v√©rtices.  Por lo tanto, definiremos una variable variable en <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs">varying vec3 WorldPosition;</code> </pre> <br>  Defina la misma variable variable en <strong>Water.vert</strong> .  Luego le asignamos una posici√≥n distorsionada desde el sombreador de v√©rtices para que el c√≥digo completo se vea as√≠: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; attribute vec2 aUv0; varying vec2 vUv0; varying vec3 WorldPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; uniform float uTime; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vUv0 = aUv0; vec3 pos = aPosition; pos.y += cos(pos.z*<span class="hljs-number"><span class="hljs-number">5.0</span></span>+uTime) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> * sin(pos.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span> + uTime); gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); WorldPosition = pos; }</code> </pre> <br><h3>  Nos damos cuenta del truco de verdad </h3><br>  Ahora finalmente estamos listos para implementar la t√©cnica descrita al comienzo de esta secci√≥n.  Queremos comparar la profundidad del p√≠xel en el que estamos con la profundidad del p√≠xel debajo de √©l.  El p√≠xel en el que estamos se toma de una posici√≥n en el mundo, y el p√≠xel debajo se obtiene de la posici√≥n de la pantalla.  Por lo tanto, tomamos estas dos profundidades: <br><br><pre> <code class="javascript hljs">float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth();</code> </pre> <br><blockquote>  <em>Tarea 4: uno de estos valores nunca ser√° mayor que el otro (suponiendo depthTest = true).</em>  <em>¬øPuedes determinar cu√°l?</em> </blockquote><br>  Sabemos que la espuma ser√° donde la distancia entre los dos valores es peque√±a.  Por lo tanto, hagamos esta diferencia para cada p√≠xel.  Pegue esto al final del sombreador (y apague el script de visualizaci√≥n de profundidad de la secci√≥n anterior): <br><br><pre> <code class="javascript hljs">color = vec4(vec3(screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">1.0</span></span>); gl_FragColor = color;</code> </pre> <br>  Y deber√≠a verse m√°s o menos as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/173/883/ad2173883ebe214bbec6c97921810755.png"></div><br>  Es decir, ¬°elegimos correctamente los l√≠mites de cualquier objeto sumergido en agua en tiempo real!  Por supuesto, puede escalar la diferencia para hacer que la espuma sea m√°s gruesa o menos com√∫n. <br><br>  Ahora tenemos muchas opciones para combinar esta salida con la superficie del agua para crear hermosas l√≠neas de espuma.  Puede dejarlos con un degradado, usarlos para tomar muestras de una textura diferente o asignarles un color espec√≠fico si la diferencia es menor o igual a un cierto valor l√≠mite. <br><br>  Lo que m√°s me gust√≥ fue la asignaci√≥n de un color similar a las l√≠neas de agua est√°tica, por lo que mi funci√≥n principal terminada se ve as√≠: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0 * <span class="hljs-number"><span class="hljs-number">2.0</span></span>; pos.y += uTime * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r * <span class="hljs-number"><span class="hljs-number">0.1</span></span>; float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth(); float foamLine = clamp((screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(foamLine &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>){ color.rgba += <span class="hljs-number"><span class="hljs-number">0.2</span></span>; } gl_FragColor = color; }</code> </pre> <br><h2>  Para resumir </h2><br>  Creamos la flotabilidad de los objetos sumergidos en el agua, aplicamos una textura en movimiento a la superficie para simular c√°usticos y aprendimos c√≥mo usar el tamp√≥n de profundidad para crear franjas de espuma din√°micas. <br><br>  En la tercera y √∫ltima parte, agregaremos los efectos del postprocesamiento y aprenderemos c√≥mo usarlos para crear el efecto de distorsi√≥n bajo el agua. <br><br><h2>  C√≥digo fuente </h2><br>  El proyecto PlayCanvas terminado se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">aqu√≠</a> .  Nuestro repositorio tambi√©n tiene un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">puerto de proyecto en Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416983/">https://habr.com/ru/post/es416983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416967/index.html">Como hicimos BelAZ. Parte 3 - Puesta en servicio seccional</a></li>
<li><a href="../es416969/index.html">Justificaci√≥n matem√°tica pitag√≥rica de la escala musical</a></li>
<li><a href="../es416977/index.html">Smart Home Software # 2</a></li>
<li><a href="../es416979/index.html">Scrum a grandes equipos: LeSS Day 2018</a></li>
<li><a href="../es416981/index.html">C√≥mo ocho personas escalan un proyecto de alta carga. Experiencia Unsplash</a></li>
<li><a href="../es416985/index.html">A la cent√©sima m√°s cercana: los 10 mejores informes SmartData 2017</a></li>
<li><a href="../es416987/index.html">Gartner: lo principal en el mercado de IaaS en 2018</a></li>
<li><a href="../es416989/index.html">Festo robots bi√≥nicos: ¬øara√±as y pulpos en las f√°bricas del futuro?</a></li>
<li><a href="../es416991/index.html">Grabar video desde su pantalla no es tan secreto. King Burger Versiones y Appsee</a></li>
<li><a href="../es416993/index.html">Conoce a Sof√≠a: un robot casi indistinguible de los humanos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>