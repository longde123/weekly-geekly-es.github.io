<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😎 ⁉️ 👨‍🚀 C简介 上个世纪的讯息 ⬜️ 👍🏿 🤜🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前言 
 在我的评论中，我多次提及Andrew Tanenbaum的书《操作系统设计和实现》（ 第一版）以及C在其中的表示方式。 这些评论一直很有趣。 我认为是时候将该简介翻译成C了。 它仍然是相关的。 尽管当然有些人尚未听说过编程语言PL / 1 ，甚至尚未听说过操作系统Minix 。 

 从历...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C简介 上个世纪的讯息</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464075/"><h3> 前言 </h3><br> 在我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">评论中，我</a>多次提及Andrew Tanenbaum的书《操作系统设计和实现》（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一版）</a>以及C在其中的表示方式。 这些评论一直很有趣。 我认为是时候将该简介翻译成C了。 它仍然是相关的。 尽管当然有些人尚未听说过编程语言<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PL / 1</a> ，甚至尚未听说过操作系统<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Minix</a> 。 <br><br> 从历史的角度以及对于理解C语言自诞生以来到整个IT行业已经走了多远的角度，此描述也很有趣。 <br><a name="habracut"></a><br> 我想立即预订我的第二种语言是法语： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/467/5a3/9614675a3883bf417fa2505dada57690.png" alt="图片"><br><br> 但这被46年的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编程经验</a>所抵消。 <br> 所以，让我们开始吧，轮到安德鲁·塔南鲍姆（Andrew Tanenbaum）了。 <br><br><h3>  C语言简介（pp.350-362） </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cx/s5/il/cxs5ilctyz8rybmfwoqyjahv5ty.png"></div><br><br>  C编程语言是AT＆T贝尔实验室的Dennis Ritchie创建的，它是用于开发UNIX操作系统的高级编程语言。 当前，该语言被广泛用于各个领域。  C在系统程序员中特别流行，因为它使您可以简单，简洁地编写程序。 <br><br> 描述C语言的主要书籍是Brian Kernigan和Dennis Ritchie的书The C Programming Language（1978）。 关于C语言的书籍由Bolon（1986），Gehani（1984），Hancock和Krieger（1986），Harbison和Steele（1984）等人撰写。 <br><br> 在本附录中，我们将尝试对C进行相当完整的介绍，以便熟悉Pascal，PL / 1或Modula 2等高级语言的人能够理解本书中给出的大多数MINIX代码。 此处不讨论MINIX中未使用的C功能。 省略了许多细微之处。 重点是阅读C程序，而不是编写代码。 <br><br><h3>  A.1。  C语言基础 </h3><br>  C程序由一组过程组成（通常称为函数，即使它们不返回值）。 这些过程包含声明，运算符和其他元素，它们一起告诉计算机要做什么。 图A-1显示了一个小过程，其中声明了三个整数变量并为其分配了值。 该过程的名称为main。 该过程没有形式参数，如过程名称后面方括号之间没有任何标识符所示。 该过程的主体括在大括号（{}）中。 此示例说明C具有变量，并且必须在使用前声明这些变量。  C也有运算符，在此示例中，它们是赋值运算符。 所有语句必须以分号结尾（不同于Pascal，Pascal在语句之间使用冒号，而不是在后面）。 <br><br> 注释以字符“ / *”开头，以字符“ * /”结尾，并且可以跨越多行。 <br><br><pre><code class="cpp hljs">main () <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, k; <span class="hljs-comment"><span class="hljs-comment">/*  3   */</span></span> i = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  i  10 ( ) */</span></span> j = i + <span class="hljs-number"><span class="hljs-number">015</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  j  i + 015 ( ) */</span></span> k = j * j + <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  k  j * j + 0xFF ( ) */</span></span> } . Al.    .</code> </pre> <br> 该过程包含三个常量。 第一次分配中的常数为10 <br> 它是一个普通的十进制常数。  015常数是八进制常数 <br>  （等于十进制的13）。 八进制常数始终从零开始。 常数0xFF是十六进制常数（等于255十进制）。 十六进制常数始终以0x开头。 这三种类型都在C中使用。 <br><br><h3>  A.2。 基本数据类型 </h3><br>  C有两种主要的数据类型（变量）：整数和字符，分别声明为int和char。 没有单独的布尔变量。  int变量用作布尔变量。 如果此变量包含0，则表示false / false，其他任何值表示true / true。  C也有浮点类型，但是MINIX不使用它们。 <br><br> 您可以将短，长或无符号的“形容词”应用于定义值范围（取决于编译器）的int类型。 大多数8088处理器将16位整数用于int和short int，将32位整数用于long int。  8088处理器上的无符号整数（unsigned int）的范围是0到65535，而不是-32768到+32767，与普通整数（int）一样。 一个字符占8位。 <br><br> 寄存器说明符还可以用于int和char，并且向编译器提示已声明的变量应放在寄存器中，以使程序更快地工作。 <br><br> 一些广告如图所示。  A-2。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z1, z2; / *    */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flag_poll; <span class="hljs-comment"><span class="hljs-comment">/* 'int'    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> . <span class="hljs-number"><span class="hljs-number">-2.</span></span>  .</code> </pre> <br> 类型之间的转换是允许的。 例如，运算符 <br><br><pre> <code class="cpp hljs">flag_pole = i;</code> </pre> <br> 即使我的类型为int并且flag_pole很长也可以。 在很多情况下 <br> 强制在数据类型之间进行转换是必要的或有用的。 对于强制转换，只需将目标类型放在表达式前面的方括号中即可进行转换。 例如： <br><br><pre> <code class="cpp hljs"> ( (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) i);</code> </pre> <br> 指令将整数i转换为long，然后再将其作为参数传递给过程p，该过程需要long参数。 <br><br> 在类型之间进行转换时，请注意符号。 <br> 将字符转换为整数时，某些编译器将字符视为带符号，即从-128到+127，而其他编译器将它们视为 <br> 无符号，即从0到255。在MINIX中，诸如 <br><br><pre> <code class="cpp hljs">i = c &amp; <span class="hljs-number"><span class="hljs-number">0377</span></span>;</code> </pre> <br> 从（字符）转换为整数，然后执行逻辑与 <br>  （＆）八进制常数0377。结果是高8位 <br> 设置为零，实际上将c视为8位无符号数，范围为0到255。 <br><br><h3>  A.3。 复合类型和指针 </h3><br> 在本节中，我们将研究构建更复杂的数据类型的四种方法：数组，结构，联合和指针。 数组是相同类型的元素的集合/集合。  C中的所有数组均以元素0开头。 <br><br> 公告公告 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a [<span class="hljs-number"><span class="hljs-number">10</span></span>];</code> </pre> <br> 声明一个具有10个整数的数组a，该数组将存储在从[0]到[9]的数组元素中。 其次，数组可以是3维或3维以上，但在MINIX中不使用。 <br> 结构是变量的集合，通常是各种类型。  C中的结构类似于Pascal中的记录。 操作员 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} s;</code> </pre> <br> 将s声明为包含两个成员（整数i和字符c）的结构。 <br><br> 要将结构s的成员i分配给6，请编写以下表达式： <br><br><pre> <code class="cpp hljs">si = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br> 点运算符表示元素i属于结构s。 <br> 工会也是一组成员，类似于结构，但在任何时候只有一个成员可以加入工会。 公告公告 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} u;</code> </pre> <br> 表示您可以使用整数或字符，但不能同时使用。 编译器应分配足够的合并空间，以便可以容纳最大的合并元素（从占用内存的角度来看）。 联合仅在MINIX中的两个位置使用（将消息定义为几种不同结构的联合，并将磁盘块定义为数据块，索引节点块，目录块等的联合）。 <br><br> 指针用于将机器地址存储在C中。 它们被非常非常频繁地使用。 星号（*）用于指示广告中的指针。 公告公告 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, *pi, a [<span class="hljs-number"><span class="hljs-number">10</span></span>], *b[<span class="hljs-number"><span class="hljs-number">10</span></span>], **ppi;</code> </pre> <br> 声明一个整数i，一个指向整数pi的指针，一个包含10个元素的数组a，一个包含10个指向整数的指针的数组b，以及一个指向整数的指针ppi的指针。 <br><br> 结合数组，指针和其他类型的复杂声明的确切语法规则有些复杂。 幸运的是，MINIX仅使用简单的声明。 <br><br> 图A-3显示了结构表结构数组z的声明，每个结构表都具有 <br> 三个成员，整数i，指向字符c和字符c的指针cp。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; / *  */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, c; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } z [<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*    20  */</span></span> .  - <span class="hljs-number"><span class="hljs-number">3.</span></span>  .</code> </pre> <br> 结构数组在MINIX中很常见。 此外，可以将名称表声明为可在后续声明中使用的结构表结构。 举个例子 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br> 声明p指向结构表结构的指针并建议保存它 <br> 在寄存器中。 在程序执行期间，p可以指示例如z [4]或 <br> 到z中的任何其他元素，其中所有20个元素都是struct table类型的结构。 <br><br> 要使p指向z [4]，只需编写 <br><br><pre> <code class="cpp hljs">p = &amp;z[<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre> <br>  “＆”号作为一元（一元）运算符的意思是“采用其后的地址”。 将成员i的值复制到整数变量n <br>  p指向的结构可以如下进行： <br><br><pre> <code class="cpp hljs">n = p-&gt;i;</code> </pre> <br> 请注意，箭头用于通过指针访问结构的成员。 如果使用变量z，则必须使用点运算符： <br><br><pre> <code class="cpp hljs">n = z [<span class="hljs-number"><span class="hljs-number">4</span></span>] .i;</code> </pre> <br> 区别在于z [4]是结构，并且点运算符选择元素 <br> 直接来自复合类型（结构，数组）。 使用指针，我们不会直接选择参与者。 指针指示您首先选择一个结构，然后才选择该结构的成员。 <br><br> 有时为复合类型命名很方便。 例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unshort;</code> </pre> <br> 将unshort定义为unsigned short（无符号的短整数）。 现在unshort可以在程序中用作主要类型。 举个例子 <br><br><pre> <code class="cpp hljs">unshort ul, *u2, u3[<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br> 声明一个短无符号整数，一个指向短无符号整数的指针，以及 <br> 短无符号整数的数组。 <br><br><h3>  A.4。 经营者 </h3><br>  C中的过程包含声明和声明。 我们已经看到了声明，因此现在我们将考虑运算符。 条件和循环运算符的目的与其他语言基本相同。 图A-4显示了其中的几个示例。 唯一需要注意的是花括号用于分组运算符，而while语句具有两种形式，第二种类似于Pascal的repeat语句。 <br><br>  C也有一个for语句，但是它看起来不像任何其他语言的for语句。  for语句具有以下形式： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (&lt;&gt;; &lt;&gt;; &lt;&gt;) ;</code> </pre> <br> 通过while语句可以表达相同的意思： <br><br><pre> <code class="cpp hljs">&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(&lt;&gt;) { &lt;&gt;; &lt;&gt; }</code> </pre> <br> 例如，考虑以下语句： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;n; i = i+l) a[i]=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br> 此运算符将数组a的前n个元素设置为零。 运算符的执行从将i设置为零开始（在循环外部完成）。 然后，在执行i的赋值和增加的同时，重复操作符直到i &lt;n。 当然，代替在零数组的当前元素上赋值的运算符，可能会在大括号中包含一个复合运算符（块）。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) k = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; y) { <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j + l, } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x + <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;y) { <span class="hljs-comment"><span class="hljs-comment">/*  if-else */</span></span> j = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  while */</span></span> k = k + k; n = n - l; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { / *    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> */ k = k + k; n = n - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); . A<span class="hljs-number"><span class="hljs-number">-4.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>  C.</code> </pre> <br>  C还具有类似于Pascal中的case运算符的运算符。 这是一个switch语句。 图A-5中显示了一个示例。 根据switch中指定的表达式的值，选择一个或另一个case语句。 <br><br> 如果表达式与任何case语句都不匹配，则选择默认语句。 <br><br> 如果该表达式不与任何case语句关联，并且缺少默认语句，则从switch语句之后的下一个语句继续执行。 <br><br> 应当注意，要退出case块，请使用break语句。 如果没有break语句，将执行下一个case块。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (k) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>: i = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   case 20, ..    switch */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>: i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; / *   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>* / <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: j = <span class="hljs-number"><span class="hljs-number">5</span></span>; } . A<span class="hljs-number"><span class="hljs-number">-5.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span></code> </pre> <br>  break语句还在for和while循环内起作用。 应当记住，如果break语句位于一系列嵌套循环内，则输出仅向上一级。 <br><br> 一个相关的语句是continue语句，它不会退出循环， <br> 但是导致当前迭代的完成和下一个迭代的开始 <br> 立即。 从本质上讲，这是循环顶部的返回。 <br><br>  C具有可以带或不带参数调用的过程。 <br> 根据Kernigan和Ritchie（p。121）的说法，不允许转移数组， <br> 结构或过程作为参数，尽管将指针传递给所有这些 <br> 允许的。 是否有一本书（它将在我的记忆中弹出：-“如果火星上有生命，如果火星上没有生命”），许多C编译器都允许使用结构作为参数。 <br> 如果数组的名称不带索引，则表示数组的指针，从而简化了数组指针的传输。 因此，如果a是任何类型的数组的名称，则可以通过编写将其传递给g <br><br><pre> <code class="cpp hljs">g();</code> </pre> <br> 此规则仅适用于数组；此规则不适用于结构。 <br> 过程可以通过执行return语句来返回值。 该语句可能包含一个表达式，其结果将作为过程的值返回，但是调用者可以放心地忽略该返回值。 如果过程返回一个值，则将类型值写入过程名称之前，如图2所示。  A-6。 像参数一样，过程不能返回数组，结构或过程，但是可以返回指向它们的指针。 设计该规则是为了实现更有效的实现-所有参数和结果始终对应一个机器字（地址存储在其中）。 允许将结构用作参数的编译器通常还允许将其用作返回值。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*      */</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> i, j </span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i + j); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } . <span class="hljs-number"><span class="hljs-number">-6.</span></span>   ,   .</code> </pre> <br>  C没有内置的I / O。 输入/输出通过调用库函数来实现，最常见的函数如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> («x=% dy = %oz = %x \n», x, y, z);</code> </pre> <br> 第一个参数是引号之间的字符串（实际上，这是一个字符数组）。 <br><br> 任何不是百分比的字符都将按原样打印。 <br><br> 出现百分比时，以下参数将以该百分比后面的字母所定义的形式打印： <br><blockquote>  d-打印为十进制整数 <br>  o-打印为八进制整数 <br>  u-打印为无符号十进制整数 <br>  x-打印为十六进制整数 <br>  s-打印为字符串 <br>  c-打印为一个字符 </blockquote> 字母D，0和X也允许用于长数字的十进制，八进制和十六进制打印。 <br><br><h3>  A.5。 表达方式 </h3><br> 通过组合操作数和运算符来创建表达式。 <br><br> 算术运算符（例如+和-）和关系运算符（例如&lt; <br> 并且&gt;类似于其他语言中的对应词。  ％运算符 <br> 用模。 值得注意的是，等于运算符为==，而不等于运算符为！  =。 要检查a和b是否相等，可以这样编写： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;&gt;;</code> </pre> <br>  C还允许您将赋值运算符与其他运算符结合使用，因此 <br><br><pre> <code class="cpp hljs">a += <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br> 相当于录音 <br><br><pre> <code class="cpp hljs"> =  + <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br> 其他运算符也可以以此方式组合。 <br><br>  C具有用于操作单词位的运算符。 允许移位和按位逻辑运算。 左右移位运算符是&lt;&lt; <br> 和&gt;&gt;。 按位逻辑运算符＆，| 和^分别为逻辑AND（AND），包括OR（OR）和异或（XOP）。 如果i的值为035（八进制），则表达式i和06的值为04（八进制）。 另一个例子，如果i = 7，则 <br><br><pre> <code class="cpp hljs">j = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) | <span class="hljs-number"><span class="hljs-number">014</span></span>;</code> </pre> <br> 得到j的074 <br> 另一重要的运算符组是一元运算符，每个运算符仅接受一个操作数。 作为一元运算符，“＆”号获取变量的地址。 <br><br> 如果p是一个指向整数的指针，而i是一个整数，则该运算符 <br><br><pre> <code class="cpp hljs">p = &amp;i;</code> </pre> <br> 计算地址i并将其存储在变量p中。 <br> 与获取地址相反的是，运算符采用指针作为输入并计算该地址处的值。 如果我们只是将地址i分配给指针p，则* p的含义与i相同。 <br><br> 换句话说，作为一元运算符，星号后跟指针（或 <br> 给出指针的表达式）并返回其指向的元素的值。 如果我的值为6，则运算符 <br><br><pre> <code class="cpp hljs">j = *;</code> </pre> <br> 将为j分配数字6。 <br> 操作员！  （感叹号是取反运算符）如果其操作数非零，则返回0；如果其运算符为0，则返回1。 <br><br> 它主要用于if语句，例如 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!x) k=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br> 检查x的值。 如果x为零（假），则为k分配值0。实际上，算子！ 取消其后的条件，就像Pascal中的not运算符一样。 <br><br>  〜运算符是按位补码运算符。 其操作数中的每个0 <br> 变为1，每1变为0。 <br><br>  sizeof运算符以字节为单位报告其操作数的大小。 关于 <br> 在具有2个字节整数的计算机上，由20个整数a组成的数组，例如sizeof a将具有40的值。 <br><br> 最后一组运算符是增减运算符。 <br><br> 操作员 <br><br><pre> <code class="cpp hljs">++;</code> </pre> <br> 表示p的增加。  p将增加多少取决于其类型。 <br> 整数或字符加1，但指针增加 <br> 以这种方式指向的对象的大小，如果a是结构的数组，而p是指向这些结构之一的指针，则我们写 <br><br><pre> <code class="cpp hljs">p = &amp;a[<span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br> 使p指向数组中的结构之一，然后增加p <br> 无论结构有多大，都将指向[4]。 操作员 <br><br><pre> <code class="cpp hljs">p--;</code> </pre> <br> 类似于p ++运算符，除了它减小而不是增大操作数的值。 <br><br> 在声明中 <br><br><pre> <code class="cpp hljs">n = k++;</code> </pre> <br> 如果两个变量都是整数，则将k的原始值分配给n， <br> 只有这样，k才会增加。 在声明中 <br><br><pre> <code class="cpp hljs">n = ++ k;</code> </pre> <br>  k首先增加，然后将其新值存储在n中。 <br><br> 因此，可以在其操作数之前或之后写入++（或-）运算符，从而产生各种值。 <br><br> 最后的陈述是这个吗？  （问号），它选择了两种选择之一 <br> 用冒号隔开。 例如操作员 <br><br><pre> <code class="cpp hljs">i = (x &lt; y ? <span class="hljs-number"><span class="hljs-number">6</span></span> : k + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br> 将x与y比较。 如果x小于y，那么我得到的值是6； 否则，变量i的值为k +1。方括号是可选的。 <br><br><h3>  A.6。 程序结构 </h3><br>  C程序由一个或多个包含过程和声明的文件组成。 <br> 这些文件可以单独编译为目标文件，然后将它们彼此链接（使用链接器）以形成可执行程序。 <br> 与Pascal不同，过程声明不能嵌套，因此所有声明都写在程序文件的“顶层”。 <br><br> 允许在过程外部声明变量，例如，在第一次声明过程之前在文件的开头声明变量。 这些变量是全局变量，并且可以在整个程序的任何过程中使用，除非static关键字在声明之前。 在这种情况下，这些变量不能在另一个文件中使用。 相同的规则适用于过程。 在过程内部声明的变量是该过程的局部变量。 <br> 该过程可以访问在另一个文件中声明的整数变量v（前提是该变量不是静态的），并在外部声明它： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v;</code> </pre> <br> 每个全局变量必须在没有extern属性的情况下准确地声明一次，以便为其分配内存。 <br><br> 声明时可以初始化变量： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br> 数组和结构也可以初始化。 未显式初始化的全局变量的默认值为零。 <br><br><h3>  A.7。  C预处理器 </h3><br> 在将源文件传输到C编译器之前，将对其进行自动处理 <br> 称为预处理程序的程序。 它是预处理器的输出，而不是 <br> 原始程序被馈送到编译器的输入。 预处理器执行 <br> 在将文件传递给编译器之前，对文件进行三个基本转换： <br><br>  1.包含文件。 <br>  2.定义和替换宏。 <br>  3.有条件的编译。 <br><br> 所有预处理指令均在第一列中以数字符号（＃）开头。 <br> 当一个视图指令 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"prog.h"</span></span></span></span></code> </pre> <br> 由预处理器满足，它在一行中逐行包含prog.h文件 <br> 要传递给编译器的程序。 当#include指令写为 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;prog.h&gt;</span></span></span></span></code> </pre> <br> 然后在/ usr / include目录而不是工作目录中搜索包含的文件。 在C中，通常的做法是将多个文件使用的声明分组在头文件中（通常带有后缀.h），并在必要时包括它们。 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 预处理器还允许宏定义。 </font></font>举个例子 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BLOCK_SIZE 1024</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义BLOCK_SIZE宏并将其分配为1024。从现在开始，文件中</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每次出现的10个字符的字符串“ BLOCK_SIZE”都将由</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4个字符的字符串“ 1024”代替，然后编译器才能使用程序查看文件。</font><font style="vertical-align: inherit;">按照惯例，宏名称以大写形式编写。</font><font style="vertical-align: inherit;">宏可以具有参数，但实际上很少。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预处理器的第三个功能是条件编译。</font><font style="vertical-align: inherit;">MINIX在几个</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地方专门为8088处理器编写代码，并且在为另一个处理器编译时不应包含此代码。</font><font style="vertical-align: inherit;">这些部分如下所示：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> i8088 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;   8088&gt; #endif</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果定义了i8088字符，则预处理器输出中将包含两个预处理器指令#ifdef i8088和#endif之间的语句；</font><font style="vertical-align: inherit;">否则将被跳过。</font><font style="vertical-align: inherit;">使用命令调用编译器</font></font><br><br><pre> <code class="cpp hljs">cc -c -Di8088 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 或在程序中包含一条语句 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> i8088</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们定义了符号i8088，因此包含了8088的所有相关代码。</font><font style="vertical-align: inherit;">随着MINIX的发展，它可能会获得适用于68000和其他处理器的特殊代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为预处理器工作方式的一个示例，请考虑程序图。</font><font style="vertical-align: inherit;">A-7（a）。</font><font style="vertical-align: inherit;">它包含一个prog.h文件，其内容如下：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAXAELEMENTS 100</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 想象一下，编译器是由命令调用的 </font></font><br><br><pre> <code class="bash hljs">cc -E -Di8088 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件通过预处理器后，输出将如图10所示。</font><font style="vertical-align: inherit;">A-7（b）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为C编译器的输入而给出的是此输出而不是源文件。</font></font><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include prog.h int x; main () main (); { { int a[MAX_ELEMENTS]; int a [100];  = 4;  = 4; a[x] = 6; [] = 6; #ifdef i8088 printf("8088. a[x]:% d\n", a[x]); printf ("8088. a[x]:% d\n", a[x]); #endif } #ifdef m68000 printf ("68000. x=%d\n", x); #endif } () (b) . -7. (a)   prog.c. (b)  .</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，预处理器完成了其工作，并删除了以＃号开头的所有行。</font><font style="vertical-align: inherit;">如果编译器会像这样被调用</font></font><br><br><pre> <code class="bash hljs">cc -c -Dm68000 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后将包含另一张印刷品。</font><font style="vertical-align: inherit;">如果这样调用：</font></font><br><br><pre> <code class="bash hljs">cc -c prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那么将不包含任何打印内容。</font><font style="vertical-align: inherit;">（读者可能会想一想如果同时使用-D ﬂ ags标志调用编译器会发生什么情况。）</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A.8。</font><font style="vertical-align: inherit;">成语</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本节中，我们将研究几种典型的C结构，但在其他编程语言中并不常见。</font><font style="vertical-align: inherit;">首先，考虑循环：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n--) *p++ = *q++;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量p和q通常是字符指针，而n是计数器。</font><font style="vertical-align: inherit;">循环将n字符串从q指向的地方复制到p指向的字符串。</font><font style="vertical-align: inherit;">在循环的每次迭代中，计数器都会减少直到达到0，并且每个指针都会增加，因此它们依次指向具有更高编号的存储单元。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个常见的设计：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) a[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将a的前N个元素设置为0。编写此循环的另一种方法如下： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; p &lt; &amp;a[N]; p++) *p = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此语句中，整数指针p初始化为指向数组的零元素。</font><font style="vertical-align: inherit;">循环继续直到p到达数组第N个元素的地址。</font><font style="vertical-align: inherit;">指针构造比数组构造更有效，因此通常使用它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配运算符可能会出现在意外的地方。</font></font>举个例子 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = f (x)) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先调用函数f，然后分配调用函数a的结果，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后检查它是true（非零）还是false（零）。</font><font style="vertical-align: inherit;">如果a不等于零，则满足条件。</font></font>操作员 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = b) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样，首先，检查变量a的变量b的值，然后检查a值是否为非零。</font><font style="vertical-align: inherit;">而且这个运算符与</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 比较两个变量，如果相等则执行运算符。 </font></font><br><br><h3> 后记 </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅此而已。</font><font style="vertical-align: inherit;">您不会相信我对编写本文有多喜欢。</font><font style="vertical-align: inherit;">我记得从同一C语言中有用的东西有多少。</font><font style="vertical-align: inherit;">希望您也喜欢进入C语言的美好世界。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN464075/">https://habr.com/ru/post/zh-CN464075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN464053/index.html">注意：音轨选择和旋转算法</a></li>
<li><a href="../zh-CN464055/index.html">我们研究了小米乐队今年收集的数据</a></li>
<li><a href="../zh-CN464057/index.html">希尔伯特，勒贝格...和虚空</a></li>
<li><a href="../zh-CN464063/index.html">在2019年切断电缆</a></li>
<li><a href="../zh-CN464071/index.html">革命还是痛苦？ Yandex React Hooks报告</a></li>
<li><a href="../zh-CN464077/index.html">不，您不需要50 km / s的增量。 您需要附加技术（第1部分）</a></li>
<li><a href="../zh-CN464079/index.html">如何在没有奇迹技术的情况下制造水平起飞和降落的太空飞船</a></li>
<li><a href="../zh-CN464083/index.html">ITSM将如何提供帮助以及谁将采用这种方法</a></li>
<li><a href="../zh-CN464089/index.html">在Spring上下文中自动化HTTP请求</a></li>
<li><a href="../zh-CN464091/index.html">适用于移动311开发人员的有趣材料的摘要（8月12日至18日）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>