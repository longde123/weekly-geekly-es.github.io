<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî® ü§∂üèø üå± Wie sch√ºtzt man sich vor Stapel√ºberlauf (bei Cortex M)? üë©üèø‚Äçüè´ üî≠ ü•ò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie auf einem "gro√üen" Computer programmieren, haben Sie wahrscheinlich keine solche Frage. Es gibt eine Menge Stapel, um es zu √ºberlaufen, m√ºsse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie sch√ºtzt man sich vor Stapel√ºberlauf (bei Cortex M)?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425071/">  Wenn Sie auf einem "gro√üen" Computer programmieren, haben Sie wahrscheinlich keine solche Frage.  Es gibt eine Menge Stapel, um es zu √ºberlaufen, m√ºssen Sie versuchen.  Im schlimmsten Fall klicken Sie in einem Fenster wie diesem auf OK und finden es heraus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/c2c/358/b12c2c358fa3a040589578b71521957b.png" alt="Bild"></div><br>  Wenn Sie jedoch Mikrocontroller programmieren, sieht das Problem etwas anders aus.  Zuerst m√ºssen Sie <i>feststellen,</i> dass der Stapel voll ist. <br><br>  In diesem Artikel werde ich √ºber meine eigene Forschung zu diesem Thema sprechen.  Da ich haupts√§chlich unter STM32 und unter Milander 1986 programmiere, habe ich mich auf sie konzentriert. <br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br>  Stellen wir uns den einfachsten Fall vor: Wir schreiben einfachen Single-Threaded-Code ohne Betriebssysteme, d. H.  Wir haben nur einen Stapel.  Und wenn Sie wie ich in uVision Keil programmieren, wird der Speicher irgendwie so verteilt: <br><br><img src="https://habrastorage.org/webt/er/tb/to/ertbtohh-xf2meqxvzekrxlmwoe.png"><br><br>  Und wenn Sie, wie ich, das dynamische Ged√§chtnis auf Mikrocontrollern als b√∂se betrachten, dann so: <br><br><img src="https://habrastorage.org/webt/op/bu/el/opbuelnjpcvre-9jjpm_qnrlqcw.png"><br><br><div class="spoiler">  <b class="spoiler_title">√úbrigens</b> <div class="spoiler_text">  Wenn Sie die Verwendung von Heap verbieten m√∂chten, k√∂nnen Sie dies folgenderma√üen tun: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> import(__use_no_heap_region)</span></span></code> </pre> <br>  Details <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> <br></div></div><br>  OK, was ist das Problem?  Das Problem ist, dass Keil den Stapel <b>unmittelbar</b> hinter dem statischen Datenbereich platziert.  Und der Stapel in Cortex-M w√§chst in Richtung abnehmender Adressen.  Und wenn es √ºberl√§uft, kriecht es einfach aus dem zugewiesenen Speicher heraus.  Und √ºberschreibt alle statischen oder globalen Variablen. <br><br>  Besonders gut, wenn der Stack nur beim Eintritt in den Interrupt √ºberl√§uft.  Oder noch besser in einem verschachtelten Interrupt!  Und verdirbt leise eine Variable, die in einem v√∂llig anderen Codeabschnitt verwendet wird.  Und das Programm st√ºrzt beim Assert ab.  Wenn Sie Gl√ºck haben.  Sph√§rischer Heisenbag, man kann so eine ganze Woche mit einer Taschenlampe suchen. <br><br>  Machen Sie sofort eine Reservierung, dass, wenn Sie einen Heap verwenden, das Problem nirgendwohin f√ºhrt, nur anstelle globaler Variablen, die der Heap verdirbt.  Nicht viel besser. <br><br>  Okay, das Problem ist klar.  Was zu tun ist? <br><br><h2>  MPU </h2><br>  Am einfachsten und naheliegendsten ist die Verwendung der MPU (mit anderen Worten Memory Protection Unit).  Erm√∂glicht das Zuweisen unterschiedlicher Attribute zu verschiedenen Speicherelementen.  Insbesondere k√∂nnen Sie den Stapel mit schreibgesch√ºtzten Bereichen umgeben und MemFault abfangen, wenn Sie dort schreiben. <br><br>  Zum Beispiel ist in stm32f407 MPU.  Leider ist es in vielen anderen "Junior" -Stm nicht der Fall.  Und im Milandrovsky 1986VE1 ist es auch nicht. <br><br>  Das hei√üt,  Die L√∂sung ist gut, aber nicht immer erschwinglich. <br><br><h2>  Manuelle Steuerung </h2><br>  Beim Kompilieren kann Keil einen HTML-Bericht mit einem Aufrufdiagramm generieren (und dies standardm√§√üig tun) (Linker-Option "--info = stack").  Dieser Bericht enth√§lt auch Informationen zum verwendeten Stapel.  Gcc kann das auch (Option -fstack-usage).  Dementsprechend k√∂nnen Sie sich diesen Bericht manchmal ansehen (oder ein Skript schreiben, das dies f√ºr Sie erledigt, und es vor jedem Build aufrufen). <br><br>  Dar√ºber hinaus wird zu Beginn des Berichts ein Pfad geschrieben, der zur maximalen Nutzung des Stapels f√ºhrt: <br><br><img src="https://habrastorage.org/webt/eb/mh/ao/ebmhaouyrjjvnmziubxybt3zyg0.png"><br><br>  Das Problem ist, dass wenn Ihr Code Funktionsaufrufe durch Zeiger oder virtuelle Methoden hat (und ich habe sie), dieser Bericht die maximale Stapeltiefe stark untersch√§tzen kann.  Unterbrechungen werden nat√ºrlich nicht ber√ºcksichtigt.  Kein sehr zuverl√§ssiger Weg. <br><br><h2>  Schwierige Stapelplatzierung </h2><br>  Diese Methode habe ich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel kennengelernt</a> .  Der Artikel handelt von Rost, aber die Hauptidee ist folgende: <br><br><img src="https://habrastorage.org/webt/i3/pz/yb/i3pzyb-ewbtxaei_oaz5mrhthda.png"><br><br>  Bei Verwendung von gcc kann dies √ºber den " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Double Link</a> " erfolgen. <br><br>  Und in Keil kann die Position der Bereiche mithilfe Ihres eigenen Skripts f√ºr den Linker ge√§ndert werden (Streudatei in Keils Terminologie).  √ñffnen Sie dazu die Projektoptionen und deaktivieren Sie "Speicherlayout aus Zieldialog verwenden".  Dann wird die Standarddatei im Feld "Streudatei" angezeigt.  Es sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="cpp hljs">; ************************************************************* ; *** Scatter-Loading Description File generated by uVision *** ; ************************************************************* LR_IROM1 <span class="hljs-number"><span class="hljs-number">0x08000000</span></span> <span class="hljs-number"><span class="hljs-number">0x00020000</span></span> { ; load region size_region ER_IROM1 <span class="hljs-number"><span class="hljs-number">0x08000000</span></span> <span class="hljs-number"><span class="hljs-number">0x00020000</span></span> { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } RW_IRAM1 <span class="hljs-number"><span class="hljs-number">0x20000000</span></span> <span class="hljs-number"><span class="hljs-number">0x00005000</span></span> { ; RW data .ANY (+RW +ZI) } }</code> </pre> <br>  Was ist als n√§chstes zu tun?  M√∂gliche Optionen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In der offiziellen Dokumentation wird vorgeschlagen</a> , Abschnitte mit reservierten Namen zu definieren - ARM_LIB_HEAP und ARM_LIB_STACK.  Dies hat jedoch zumindest f√ºr mich unangenehme Konsequenzen: Die Gr√∂√üe des Stapels und des Heaps muss in der Scatter-Datei festgelegt werden. <br><br>  In allen von mir verwendeten Projekten werden die Stapel- und Heap-Gr√∂√üen in der Assembler-Startdatei festgelegt (die Keil beim Erstellen des Projekts generiert).  Ich m√∂chte es nicht wirklich √§ndern.  Ich m√∂chte nur eine neue Scatter-Datei in das Projekt aufnehmen, und alles wird gut.  Also bin ich einen etwas anderen Weg gegangen: <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#! armcc -E ; with that we can use C preprocessor <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RAM_BEGIN 0x20000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RAM_SIZE_BYTES (4*1024) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_BEGIN 0x8000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_SIZE_BYTES (32*1024) ; This scatter file places stack before .bss region, so on stack overflow ; we get HardFault exception immediately LR_IROM1 FLASH_BEGIN FLASH_SIZE_BYTES { ; load region size_region ER_IROM1 FLASH_BEGIN FLASH_SIZE_BYTES { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } ; Stack region growing down REGION_STACK RAM_BEGIN { *(STACK) } ; We have to </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> heap region, even </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> we don</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'t actually use heap REGION_HEAP ImageLimit(REGION_STACK) { *(HEAP) } ; this will place .bss region above the stack and heap and allocate RAM that is left for it RW_IRAM1 ImageLimit(REGION_HEAP) (RAM_SIZE_BYTES - ImageLength(REGION_STACK) - ImageLength(REGION_HEAP)) { *(+RW +ZI) } }</span></span></span></span></code> </pre> <br></div></div><br>  Dann sagte ich, dass sich alle Objekte mit dem Namen STACK in der Region REGION_STACK befinden sollten und dass sich alle HEAP-Objekte in der Region REGION_HEAP befinden sollten.  Und alles andere ist in der Region RW_IRAM1.  Und er ordnete die Regionen in dieser Reihenfolge an - den Beginn der Operation, den Stapel, den Haufen, alles andere.  Die Berechnung besteht darin, dass in der Assembler-Startdatei der Stapel und der Heap unter Verwendung dieses Codes festgelegt werden (d. H. Als Arrays mit den Namen STACK und HEAP): <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Stack_Size EQU 0x00000400 AREA STACK, NOINIT, READWRITE, ALIGN=3 Stack_Mem SPACE Stack_Size __initial_sp Heap_Size EQU 0x00000200 AREA HEAP, NOINIT, READWRITE, ALIGN=3 __heap_base Heap_Mem SPACE Heap_Size __heap_limit PRESERVE8 THUMB</code> </pre> <br></div></div><br>  Okay, k√∂nnten Sie fragen, aber was gibt uns das?  Und hier ist was.  Beim Verlassen des Stapels versucht der Prozessor nun, nicht vorhandenen Speicher zu schreiben (oder zu lesen).  Und auf STM32 tritt eine Unterbrechung aufgrund einer Ausnahme auf - HardFault. <br><br>  Dies ist aufgrund der MPU nicht so praktisch wie MemFault, da HardFault aus vielen Gr√ºnden auftreten kann, der Fehler jedoch zumindest laut und nicht leise ist.  Das hei√üt,  es tritt sofort auf und nicht nach einer unbekannten Zeitspanne wie zuvor. <br><br>  Das Beste ist, wir haben nichts daf√ºr bezahlt, keine Overhead-Laufzeit!  Wow.  Es gibt jedoch ein Problem. <br><br>  <i>Dies funktioniert bei Milander nicht.</i> <br><br>  Ja  Bei der Milandra (ich interessiere mich haupts√§chlich f√ºr 1986BE1 und BE91) sieht die Speicherkarte nat√ºrlich anders aus.  In STM32 gibt es vor dem Start des Operateurs nichts, und auf der Milandra liegt vor dem Operateur der Bereich des externen Busses. <br><br>  Aber selbst wenn Sie keinen externen Bus verwenden, erhalten Sie keinen HardFault.  Oder vielleicht bekommen.  Oder vielleicht bekommen, aber nicht sofort.  Ich konnte keine Informationen zu diesem Thema finden (was f√ºr Milander nicht √ºberraschend ist), und die Experimente ergaben keine verst√§ndlichen Ergebnisse.  HardFault trat <i>manchmal</i> auf, wenn die Stapelgr√∂√üe ein Vielfaches von 256 war. Manchmal trat HardFault auf, wenn der Stapel zu weit in den nicht vorhandenen Speicher ging. <br><br>  Aber es spielt keine Rolle.  Wenn HardFault nicht jedes Mal auftritt, werden wir durch einfaches Verschieben des Stapels an den Anfang des RAM nicht mehr gerettet.  Und um ganz ehrlich zu sein, ist STM auch nicht verpflichtet, gleichzeitig eine Ausnahme auszul√∂sen. Die Cortex-M-Kernspezifikation scheint nichts Konkretes dar√ºber zu sagen. <br><br>  Selbst bei STM ist es eher ein Hack, nur nicht sehr schmutzig. <br><br>  Sie m√ºssen also nach einem anderen Weg suchen. <br><br><h2>  Zugriff auf den Haltepunkt in der Aufzeichnung </h2><br>  Wenn wir den Stapel an den Anfang des RAM verschieben, ist der Grenzwert des Stapels immer der gleiche - 0x20000000.  Und wir k√∂nnen einfach einen Haltepunkt auf den Datensatz in dieser Zelle setzen.  Dies kann mit dem Befehl erfolgen und sogar mithilfe der INI-Datei im Autorun registriert werden: <br><br><pre> <code class="plaintext hljs">// breakpoint on stackoverflow BS Write 0x20000000, 1</code> </pre> <br>  Dies ist jedoch kein sehr zuverl√§ssiger Weg.  Dieser Haltepunkt wird jedes Mal ausgel√∂st, wenn der Stapel initialisiert wird.  Es ist leicht, es versehentlich zu schlagen, indem Sie auf "Alle Haltepunkte t√∂ten" klicken.  Und er wird Sie nur in Gegenwart eines Debuggers sch√ºtzen.  Nicht gut. <br><br><h2>  Dynamischer √úberlaufschutz </h2><br>  Eine schnelle Suche zu diesem Thema f√ºhrte mich zu Keils Optionen --protect_stack und --protect_stack_all.  N√ºtzliche Optionen sch√ºtzen leider nicht vor dem √úberlaufen des gesamten Stapels, sondern vor dem Einf√ºgen einer weiteren Funktion in den Stapelrahmen.  Zum Beispiel, wenn Ihr Code die Grenzen eines Arrays √ºberschreitet oder mit einer variablen Anzahl von Parametern fehlschl√§gt.  Gcc kann das nat√ºrlich auch (-fstack-protector). <br><br>  Das Wesentliche dieser Option ist folgender: "Schutzvariable" wird jedem Stapelrahmen hinzugef√ºgt, dh einer Schutznummer.  Wenn sich diese Nummer nach dem Beenden der Funktion ge√§ndert hat, wird die Fehlerbehandlungsfunktion aufgerufen.  Details <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Eine n√ºtzliche Sache, aber nicht ganz das, was ich brauche.  Ich brauche eine viel einfachere Pr√ºfung - damit bei der Eingabe jeder Funktion der Wert des SP-Registers (Stack Pointer) gegen einen zuvor bekannten Mindestwert gepr√ºft wird.  Aber schreiben Sie diesen Test nicht mit Ihren H√§nden am Eingang zu jeder Funktion? <br><br><h2>  Dynamische SP-Steuerung </h2><br>  Gl√ºcklicherweise hat gcc die wunderbare Option "-finstrument-functions", mit der Sie eine benutzerdefinierte Funktion aufrufen k√∂nnen, wenn Sie jede Funktion eingeben und wenn Sie jede Funktion verlassen.  Dies wird normalerweise zur Ausgabe von Debugging-Informationen verwendet, aber was ist der Unterschied? <br><br>  Noch gl√ºcklicher ist es, dass Keil die gcc-Funktionalit√§t absichtlich kopiert und dort dieselbe Option unter dem Namen "--gnu_instrument" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Details</a> ) verf√ºgbar ist. <br><br>  Danach m√ºssen Sie nur noch diesen Code schreiben: <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    //   ,         scatter- extern unsigned int Image$$REGION_STACK$$RW$$Base; //    ,   static const uint32_t stack_lower_address = (uint32_t) &amp;( Image$$REGION_STACK$$RW$$Base ); //         extern "C" __attribute__((no_instrument_function)) void __cyg_profile_func_enter( void * current_func, void * callsite ) { (void)current_func; (void)callsite; ASSERT( __current_sp() &gt;= stack_lower_address ); } //   -   extern "C" __attribute__((no_instrument_function)) void __cyg_profile_func_exit( void * current_func, void * callsite ) { (void)current_func; (void)callsite; }</span></span></code> </pre> <br></div></div><br>  Und voila!  Nach Eingabe jeder Funktion (einschlie√ülich Interrupt-Handler) wird nun eine √úberpr√ºfung auf Stapel√ºberlauf durchgef√ºhrt.  Und wenn der Stapel √ºberl√§uft, gibt es eine Best√§tigung. <br><br><div class="spoiler">  <b class="spoiler_title">Eine kleine Erkl√§rung:</b> <div class="spoiler_text"><ul><li>  Ja, nat√ºrlich m√ºssen Sie mit einem gewissen Spielraum auf √úberlauf pr√ºfen, da sonst die Gefahr besteht, dass Sie √ºber den Stapel "springen". </li><li>  Image $$ REGION_STACK $$ RW $$ Base ist eine besondere Magie, um mithilfe der vom Linker generierten Konstanten Informationen √ºber Speicherbereiche abzurufen.  Details (obwohl stellenweise nicht sehr verst√§ndlich) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </li></ul><br></div></div><br>  Ist die L√∂sung perfekt?  Nat√ºrlich nicht. <br><br>  Erstens ist diese Pr√ºfung alles andere als kostenlos, der Code schwillt um 10 Prozent an. Nun, der Code funktioniert langsamer (obwohl ich ihn nicht gemessen habe).  Ob es kritisch ist oder nicht, liegt bei Ihnen;  Meiner Meinung nach ist dies ein angemessener Preis f√ºr die Sicherheit. <br><br>  Zweitens funktioniert dies h√∂chstwahrscheinlich nicht, wenn vorkompilierte Bibliotheken verwendet werden (aber da ich sie √ºberhaupt nicht verwende, habe ich sie nicht √ºberpr√ºft). <br><br>  Diese L√∂sung eignet sich jedoch m√∂glicherweise f√ºr Multithread-Programme, da wir die √úberpr√ºfung selbst durchf√ºhren.  Aber ich habe diese Idee nicht wirklich durchdacht, deshalb werde ich sie vorerst behalten. <br><br><h2>  Zusammenfassend </h2><br>  Es stellte sich heraus, dass es funktionierende L√∂sungen f√ºr stm32 und Milander gab, obwohl ich f√ºr letzteres mit etwas Aufwand bezahlen musste. <br><br>  F√ºr mich war das Wichtigste ein kleiner Paradigmenwechsel des Denkens.  Vor dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oben genannten Artikel habe</a> ich √ºberhaupt nicht gedacht, dass Sie sich irgendwie vor Stapel√ºberlauf sch√ºtzen k√∂nnten.  Ich habe dies nicht als ein Problem wahrgenommen, das gel√∂st werden muss, sondern als ein bestimmtes nat√ºrliches Ph√§nomen - manchmal regnet es und manchmal l√§uft der Stapel √ºber. Nun, es gibt nichts zu tun, man muss die Kugel bei√üen und tolerieren. <br><br>  Und ich merke im Allgemeinen ziemlich oft f√ºr mich (und f√ºr andere Leute), dass ich - anstatt 5 Minuten in Google zu verbringen und eine triviale L√∂sung zu finden - seit Jahren mit meinen Problemen lebe. <br><br>  Das ist alles f√ºr mich.  Ich verstehe, dass ich nichts grundlegend Neues entdeckt habe, aber ich habe keine fertigen Artikel mit einer solchen Entscheidung gefunden (zumindest Joseph Yu selbst bietet dies nicht direkt in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> zu diesem Thema an).  Ich hoffe, dass sie mir in den Kommentaren sagen werden, ob ich Recht habe oder nicht und was die Fallstricke dieses Ansatzes sind. <br><br>  <b>UPD:</b> Wenn Keil beim Hinzuf√ºgen einer Scatter-Datei eine unverst√§ndliche Warnung ausgibt, z. B. "AppData \ Local \ Temp \ p17af8-2 (33): Warnung: # 1-D: Die letzte Zeile der Datei endet ohne Zeilenumbruch" - diese Datei selbst jedoch nicht wird ge√∂ffnet, da es nur vor√ºbergehend ist. F√ºgen Sie dann einfach den Zeilenumbruch mit dem letzten Zeichen in der Streudatei hinzu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425071/">https://habr.com/ru/post/de425071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425057/index.html">Vorzugsdarlehen f√ºr Bildung f√ºr alle GeekUniversity-Programme von GeekBrains und Alfa Bank</a></li>
<li><a href="../de425059/index.html">Hackathon Nr. 1 bei Tinkoff.ru</a></li>
<li><a href="../de425061/index.html">CodeRainbow: Interaktives Lernen und Dokumentieren von Code</a></li>
<li><a href="../de425063/index.html">Migrieren eines Datenbankschemas ohne Ausfallzeit f√ºr postgresql am Beispiel von django</a></li>
<li><a href="../de425069/index.html">Testen eines Pr√§sentators mit PromiseKit</a></li>
<li><a href="../de425073/index.html">Einfache Erstellung eines Git-Repositorys auf OneDrive</a></li>
<li><a href="../de425075/index.html">Bildverarbeitung: Installieren, Konfigurieren und Verwenden von Google Cloud Vision in PHP</a></li>
<li><a href="../de425077/index.html">Kotlin unter der Haube - siehe dekompilierten Bytecode</a></li>
<li><a href="../de425079/index.html">Schwierige IPSec unter Linux</a></li>
<li><a href="../de425081/index.html">Der Staat wei√ü nicht, wie viel er f√ºr IT ausgibt. Wir beweisen die Zahlen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>