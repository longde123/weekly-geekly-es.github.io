<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍍 🚨 🧑🏻 Cómo manejar los errores en la JVM más rápido 🏇 🖐🏼 🧛🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hay varias formas de manejar errores en lenguajes de programación: 


- excepciones estándar para muchos lenguajes (Java, Scala y otras JVM, python y ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo manejar los errores en la JVM más rápido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431586/"><p>  Hay varias formas de manejar errores en lenguajes de programación: </p><br><ul><li>  excepciones estándar para muchos lenguajes (Java, Scala y otras JVM, python y muchos otros) </li><li>  códigos de estado o banderas (Go, bash) </li><li>  Varias estructuras de datos algebraicos, cuyos valores pueden ser resultados exitosos y descripciones de errores (Scala, Haskell y otros lenguajes funcionales) </li></ul><br><p>  Las excepciones se usan ampliamente, por otro lado, a menudo se dice que son lentas.  Pero los oponentes de un enfoque funcional a menudo apelan al rendimiento. </p><br><p>  Recientemente, he estado trabajando con Scala, donde puedo usar igualmente las excepciones y varios tipos de datos para el manejo de errores, por lo que me pregunto qué enfoque será más conveniente y más rápido. </p><br><p>  Inmediatamente descartaremos el uso de códigos y marcas, ya que este enfoque no se acepta en los idiomas JVM y, en mi opinión, es demasiado propenso a errores (lo siento por el juego de palabras).  Por lo tanto, compararemos las excepciones y los diferentes tipos de ADT.  Además, el ADT puede considerarse como el uso de códigos de error en un estilo funcional. </p><br><p>  <strong>ACTUALIZACIÓN</strong> : se añaden excepciones sin trazas de pila a la comparación </p><a name="habracut"></a><br><h3 id="konkursanty">  Concursantes </h3><br><div class="spoiler">  <b class="spoiler_title">Un poco más sobre los tipos de datos algebraicos</b> <div class="spoiler_text"><p>  Para aquellos que no están demasiado familiarizados con ADT ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ADT</a> ), un tipo algebraico consta de varios valores posibles, cada uno de los cuales puede ser un valor compuesto (estructura, registro). </p><br><p> Un ejemplo es el tipo <code>Option[T] = Some(value: T) | None</code>  <code>Option[T] = Some(value: T) | None</code> , que se utiliza en lugar de nulos: un valor de este tipo puede ser <code>Some(t)</code> si hay un valor o <code>None</code> si no lo es. </p><br><p>  Otro ejemplo sería <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> , que describe el resultado de un cálculo que podría completarse con éxito o con un error. </p><br><p>  Entonces nuestros concursantes: </p></div></div><br><ul><li>  <em>Buenas</em> viejas excepciones </li><li>  Excepciones sin seguimiento de pila, ya que llenar un seguimiento de pila es una operación muy lenta </li><li> <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> : las mismas excepciones, pero en un contenedor funcional </li><li> <code>Either[String, T] = Left(error: String) | Right(value: T)</code>  <code>Either[String, T] = Left(error: String) | Right(value: T)</code> : un tipo que contiene el resultado o una descripción del error </li><li> <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code>  <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code> : un tipo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la biblioteca Cats</a> , que en caso de error puede contener varios mensajes sobre diferentes errores (no <code>List</code> usa <code>List</code> , pero no importa) </li></ul><br><p>  <strong>NOTA:</strong> en esencia, las excepciones se comparan con el seguimiento de la pila, sin y ATD, pero se seleccionan varios tipos, ya que Scala no tiene un enfoque único y es interesante comparar varios. </p><br><p>  Además de las excepciones, las cadenas se usan para describir errores, pero con el mismo éxito en una situación real, se usarían diferentes clases ( <code>Either[Failure, T]</code> ). </p><br><h3 id="problema">  El problema </h3><br><p>  Para probar el manejo de errores, tomamos el problema del análisis y la validación de datos: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, isMale: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonParser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] }</code> </pre> <br><p>  es decir  tener un <code>Map[String, String]</code> datos sin procesar <code>Map[String, String]</code> necesita obtener <code>Person</code> o un error si los datos no son válidos. </p><br><h4 id="throw">  Tirar </h4><br><p>  Una solución <em>para la frente</em> usando excepciones (en adelante daré solo la función de <code>person</code> , puedes ver el código completo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> ): <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Throwparser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Person</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = string(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age = integer(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"age"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale = boolean(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale) }</code> </pre> <br><p>  aquí <code>string</code> , <code>integer</code> y <code>boolean</code> validan la presencia y el formato de tipos simples y realizan la conversión. <br>  En general, es bastante simple y claro. </p><br><h4 id="thrownst-no-stack-trace">  ThrowNST (Sin seguimiento de pila) </h4><br><p>  El código es el mismo que en el caso anterior, pero las excepciones se usan sin un seguimiento de pila siempre que sea posible: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ThrowNSTParser.scala</a> </p><br><h4 id="try">  Prueba </h4><br><p>  La solución detecta excepciones antes y permite combinar los resultados a través de <code>for</code> (que no debe confundirse con bucles en otros idiomas): <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TryParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p>  un poco más inusual para un ojo frágil, pero debido al uso de <code>for</code> , es muy similar a la versión con excepciones, además, la validación de la presencia de un campo y el análisis del tipo deseado se producen por separado ( <code>flatMap</code> se puede leer aquí <code>and then</code> ) </p><br><h4 id="either">  Ya sea </h4><br><p>  Aquí el tipo <code>Either</code> está oculto detrás del alias <code>Result</code> ya que el tipo de error es fijo: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EitherParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p>  Dado que el estándar <code>Either</code> como <code>Try</code> forma una mónada en Scala, el código salió exactamente igual, la diferencia aquí es que la cadena aparece aquí como un error y las excepciones se usan mínimamente (solo para manejar errores al analizar un número) </p><br><h4 id="validated">  Validado </h4><br><p>  Aquí, la biblioteca Cats se usa para no obtener lo primero que sucedió, sino todo lo posible (por ejemplo, si varios campos no son válidos, el resultado contendrá errores de análisis para todos estos campos) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ValidatedParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) .ensure(one(<span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>))(_.nonEmpty) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) .andThen(integer) .ensure(one(<span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>))(_ &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Boolean</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) .andThen(boolean) (name, age, isMale).mapN(<span class="hljs-type"><span class="hljs-type">Person</span></span>) }</code> </pre> <br><p>  este código ya es menos similar a la versión original con excepciones, pero la verificación de restricciones adicionales no está divorciada de analizar los campos y todavía recibimos varios errores en lugar de uno, ¡vale la pena! </p><br><h3 id="testirovanie">  Prueba </h3><br><p>  Para las pruebas, se generó un conjunto de datos con un porcentaje diferente de errores y se analizó en cada una de las formas. </p><br><p>  Resultado en todos los porcentajes de errores: <br><img src="https://habrastorage.org/webt/hj/la/-8/hjla-8vnb-pa7jgyiwghmhwwhxk.png"></p><br><p>  Con más detalle, con un bajo porcentaje de errores (el tiempo es diferente aquí desde que se utilizó <em>una</em> muestra más grande): <br><img src="https://habrastorage.org/webt/4s/8r/ca/4s8rcaqkm4gke5o_2fim1dxx9y0.png"></p><br><p>  Si alguna parte de los errores sigue siendo una excepción con el seguimiento de la pila (en nuestro caso, el error de analizar el número será una excepción que no controlamos), entonces, por supuesto, el rendimiento de los métodos de manejo de errores "rápidos" se deteriorará significativamente.  <code>Validated</code> ve especialmente afectado, ya que recopila todos los errores y, como resultado, recibe una excepción lenta más que otros: <br><img src="https://habrastorage.org/webt/gy/x-/ve/gyx-veyf2w3kexn4oa56vrbfuvw.png"></p><br><h3 id="vyvody">  Conclusiones </h3><br><p>  Como mostró el experimento, las excepciones con los rastros de la pila son realmente muy lentas (¡el 100% de los errores son la diferencia entre <code>Throw</code> y <code>Either</code> más de 50 veces!), Y cuando prácticamente no hay excepciones, usar ADT tiene un precio.  Sin embargo, el uso de excepciones sin trazas de pila es tan rápido (y con un bajo porcentaje de errores más rápido) como ADT, sin embargo, si tales excepciones van más allá de la misma validación, no será fácil rastrear su fuente. </p><br><p>  En total, si la probabilidad de una excepción es superior al 1%, las excepciones sin trazas de pila funcionan más rápidamente, <code>Validated</code> o regulares. <code>Either</code> casi tan rápida.  Con una gran cantidad de errores, <code>Either</code> puede ser un poco más rápido que <code>Validated</code> solo debido a la semántica a prueba de fallas. </p><br><p>  El uso de ADT para el manejo de errores proporciona otra ventaja sobre las excepciones: la posibilidad de un error está conectada al tipo en sí y es más difícil pasarla por alto, como cuando se usa <code>Option</code> lugar de valores nulos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431586/">https://habr.com/ru/post/es431586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431570/index.html">Estudio de seguridad de pago de estacionamiento</a></li>
<li><a href="../es431572/index.html">Cómo escribir requisitos funcionales</a></li>
<li><a href="../es431574/index.html">Neuro interfaces hoy</a></li>
<li><a href="../es431582/index.html">Historia de la protección de datos personales: ¿cómo surgió el RGPD?</a></li>
<li><a href="../es431584/index.html">Espacio y pruebas: mezclar, pero no agitar</a></li>
<li><a href="../es431588/index.html">Ley de autoempleo. Información para consideración</a></li>
<li><a href="../es431590/index.html">La modernización de los parques eólicos obsoletos del Reino Unido aumentará la generación de energía en un 171%</a></li>
<li><a href="../es431596/index.html">Veeam Backup y prueba de carga de replicación</a></li>
<li><a href="../es431598/index.html">Traemos a Internet una máquina virtual QEMU pública sin una tarjeta de red e intentamos extraer</a></li>
<li><a href="../es431600/index.html">Elevar IDS / NMS: Mikrotik y Suricata con una interfaz web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>