<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游꼜 游뚿 游븸游낕 C칩mo manejar los errores en la JVM m치s r치pido 游끦 游둟游낖 游빁游</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hay varias formas de manejar errores en lenguajes de programaci칩n: 


- excepciones est치ndar para muchos lenguajes (Java, Scala y otras JVM, python y ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C칩mo manejar los errores en la JVM m치s r치pido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431586/"><p>  Hay varias formas de manejar errores en lenguajes de programaci칩n: </p><br><ul><li>  excepciones est치ndar para muchos lenguajes (Java, Scala y otras JVM, python y muchos otros) </li><li>  c칩digos de estado o banderas (Go, bash) </li><li>  Varias estructuras de datos algebraicos, cuyos valores pueden ser resultados exitosos y descripciones de errores (Scala, Haskell y otros lenguajes funcionales) </li></ul><br><p>  Las excepciones se usan ampliamente, por otro lado, a menudo se dice que son lentas.  Pero los oponentes de un enfoque funcional a menudo apelan al rendimiento. </p><br><p>  Recientemente, he estado trabajando con Scala, donde puedo usar igualmente las excepciones y varios tipos de datos para el manejo de errores, por lo que me pregunto qu칠 enfoque ser치 m치s conveniente y m치s r치pido. </p><br><p>  Inmediatamente descartaremos el uso de c칩digos y marcas, ya que este enfoque no se acepta en los idiomas JVM y, en mi opini칩n, es demasiado propenso a errores (lo siento por el juego de palabras).  Por lo tanto, compararemos las excepciones y los diferentes tipos de ADT.  Adem치s, el ADT puede considerarse como el uso de c칩digos de error en un estilo funcional. </p><br><p>  <strong>ACTUALIZACI칍N</strong> : se a침aden excepciones sin trazas de pila a la comparaci칩n </p><a name="habracut"></a><br><h3 id="konkursanty">  Concursantes </h3><br><div class="spoiler">  <b class="spoiler_title">Un poco m치s sobre los tipos de datos algebraicos</b> <div class="spoiler_text"><p>  Para aquellos que no est치n demasiado familiarizados con ADT ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ADT</a> ), un tipo algebraico consta de varios valores posibles, cada uno de los cuales puede ser un valor compuesto (estructura, registro). </p><br><p> Un ejemplo es el tipo <code>Option[T] = Some(value: T) | None</code>  <code>Option[T] = Some(value: T) | None</code> , que se utiliza en lugar de nulos: un valor de este tipo puede ser <code>Some(t)</code> si hay un valor o <code>None</code> si no lo es. </p><br><p>  Otro ejemplo ser칤a <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> , que describe el resultado de un c치lculo que podr칤a completarse con 칠xito o con un error. </p><br><p>  Entonces nuestros concursantes: </p></div></div><br><ul><li>  <em>Buenas</em> viejas excepciones </li><li>  Excepciones sin seguimiento de pila, ya que llenar un seguimiento de pila es una operaci칩n muy lenta </li><li> <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> : las mismas excepciones, pero en un contenedor funcional </li><li> <code>Either[String, T] = Left(error: String) | Right(value: T)</code>  <code>Either[String, T] = Left(error: String) | Right(value: T)</code> : un tipo que contiene el resultado o una descripci칩n del error </li><li> <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code>  <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code> : un tipo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la biblioteca Cats</a> , que en caso de error puede contener varios mensajes sobre diferentes errores (no <code>List</code> usa <code>List</code> , pero no importa) </li></ul><br><p>  <strong>NOTA:</strong> en esencia, las excepciones se comparan con el seguimiento de la pila, sin y ATD, pero se seleccionan varios tipos, ya que Scala no tiene un enfoque 칰nico y es interesante comparar varios. </p><br><p>  Adem치s de las excepciones, las cadenas se usan para describir errores, pero con el mismo 칠xito en una situaci칩n real, se usar칤an diferentes clases ( <code>Either[Failure, T]</code> ). </p><br><h3 id="problema">  El problema </h3><br><p>  Para probar el manejo de errores, tomamos el problema del an치lisis y la validaci칩n de datos: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, isMale: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonParser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] }</code> </pre> <br><p>  es decir  tener un <code>Map[String, String]</code> datos sin procesar <code>Map[String, String]</code> necesita obtener <code>Person</code> o un error si los datos no son v치lidos. </p><br><h4 id="throw">  Tirar </h4><br><p>  Una soluci칩n <em>para la frente</em> usando excepciones (en adelante dar칠 solo la funci칩n de <code>person</code> , puedes ver el c칩digo completo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> ): <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Throwparser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Person</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = string(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age = integer(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"age"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale = boolean(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale) }</code> </pre> <br><p>  aqu칤 <code>string</code> , <code>integer</code> y <code>boolean</code> validan la presencia y el formato de tipos simples y realizan la conversi칩n. <br>  En general, es bastante simple y claro. </p><br><h4 id="thrownst-no-stack-trace">  ThrowNST (Sin seguimiento de pila) </h4><br><p>  El c칩digo es el mismo que en el caso anterior, pero las excepciones se usan sin un seguimiento de pila siempre que sea posible: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ThrowNSTParser.scala</a> </p><br><h4 id="try">  Prueba </h4><br><p>  La soluci칩n detecta excepciones antes y permite combinar los resultados a trav칠s de <code>for</code> (que no debe confundirse con bucles en otros idiomas): <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TryParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p>  un poco m치s inusual para un ojo fr치gil, pero debido al uso de <code>for</code> , es muy similar a la versi칩n con excepciones, adem치s, la validaci칩n de la presencia de un campo y el an치lisis del tipo deseado se producen por separado ( <code>flatMap</code> se puede leer aqu칤 <code>and then</code> ) </p><br><h4 id="either">  Ya sea </h4><br><p>  Aqu칤 el tipo <code>Either</code> est치 oculto detr치s del alias <code>Result</code> ya que el tipo de error es fijo: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EitherParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p>  Dado que el est치ndar <code>Either</code> como <code>Try</code> forma una m칩nada en Scala, el c칩digo sali칩 exactamente igual, la diferencia aqu칤 es que la cadena aparece aqu칤 como un error y las excepciones se usan m칤nimamente (solo para manejar errores al analizar un n칰mero) </p><br><h4 id="validated">  Validado </h4><br><p>  Aqu칤, la biblioteca Cats se usa para no obtener lo primero que sucedi칩, sino todo lo posible (por ejemplo, si varios campos no son v치lidos, el resultado contendr치 errores de an치lisis para todos estos campos) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ValidatedParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) .ensure(one(<span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>))(_.nonEmpty) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) .andThen(integer) .ensure(one(<span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>))(_ &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Boolean</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) .andThen(boolean) (name, age, isMale).mapN(<span class="hljs-type"><span class="hljs-type">Person</span></span>) }</code> </pre> <br><p>  este c칩digo ya es menos similar a la versi칩n original con excepciones, pero la verificaci칩n de restricciones adicionales no est치 divorciada de analizar los campos y todav칤a recibimos varios errores en lugar de uno, 춰vale la pena! </p><br><h3 id="testirovanie">  Prueba </h3><br><p>  Para las pruebas, se gener칩 un conjunto de datos con un porcentaje diferente de errores y se analiz칩 en cada una de las formas. </p><br><p>  Resultado en todos los porcentajes de errores: <br><img src="https://habrastorage.org/webt/hj/la/-8/hjla-8vnb-pa7jgyiwghmhwwhxk.png"></p><br><p>  Con m치s detalle, con un bajo porcentaje de errores (el tiempo es diferente aqu칤 desde que se utiliz칩 <em>una</em> muestra m치s grande): <br><img src="https://habrastorage.org/webt/4s/8r/ca/4s8rcaqkm4gke5o_2fim1dxx9y0.png"></p><br><p>  Si alguna parte de los errores sigue siendo una excepci칩n con el seguimiento de la pila (en nuestro caso, el error de analizar el n칰mero ser치 una excepci칩n que no controlamos), entonces, por supuesto, el rendimiento de los m칠todos de manejo de errores "r치pidos" se deteriorar치 significativamente.  <code>Validated</code> ve especialmente afectado, ya que recopila todos los errores y, como resultado, recibe una excepci칩n lenta m치s que otros: <br><img src="https://habrastorage.org/webt/gy/x-/ve/gyx-veyf2w3kexn4oa56vrbfuvw.png"></p><br><h3 id="vyvody">  Conclusiones </h3><br><p>  Como mostr칩 el experimento, las excepciones con los rastros de la pila son realmente muy lentas (춰el 100% de los errores son la diferencia entre <code>Throw</code> y <code>Either</code> m치s de 50 veces!), Y cuando pr치cticamente no hay excepciones, usar ADT tiene un precio.  Sin embargo, el uso de excepciones sin trazas de pila es tan r치pido (y con un bajo porcentaje de errores m치s r치pido) como ADT, sin embargo, si tales excepciones van m치s all치 de la misma validaci칩n, no ser치 f치cil rastrear su fuente. </p><br><p>  En total, si la probabilidad de una excepci칩n es superior al 1%, las excepciones sin trazas de pila funcionan m치s r치pidamente, <code>Validated</code> o regulares. <code>Either</code> casi tan r치pida.  Con una gran cantidad de errores, <code>Either</code> puede ser un poco m치s r치pido que <code>Validated</code> solo debido a la sem치ntica a prueba de fallas. </p><br><p>  El uso de ADT para el manejo de errores proporciona otra ventaja sobre las excepciones: la posibilidad de un error est치 conectada al tipo en s칤 y es m치s dif칤cil pasarla por alto, como cuando se usa <code>Option</code> lugar de valores nulos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431586/">https://habr.com/ru/post/es431586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431570/index.html">Estudio de seguridad de pago de estacionamiento</a></li>
<li><a href="../es431572/index.html">C칩mo escribir requisitos funcionales</a></li>
<li><a href="../es431574/index.html">Neuro interfaces hoy</a></li>
<li><a href="../es431582/index.html">Historia de la protecci칩n de datos personales: 쯖칩mo surgi칩 el RGPD?</a></li>
<li><a href="../es431584/index.html">Espacio y pruebas: mezclar, pero no agitar</a></li>
<li><a href="../es431588/index.html">Ley de autoempleo. Informaci칩n para consideraci칩n</a></li>
<li><a href="../es431590/index.html">La modernizaci칩n de los parques e칩licos obsoletos del Reino Unido aumentar치 la generaci칩n de energ칤a en un 171%</a></li>
<li><a href="../es431596/index.html">Veeam Backup y prueba de carga de replicaci칩n</a></li>
<li><a href="../es431598/index.html">Traemos a Internet una m치quina virtual QEMU p칰blica sin una tarjeta de red e intentamos extraer</a></li>
<li><a href="../es431600/index.html">Elevar IDS / NMS: Mikrotik y Suricata con una interfaz web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>