<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™üèΩ ‚ôÄÔ∏è üïß Perspectiva: MultiClet S1 ü§¶üèø ü¶Ä üéã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ent√£o, √© hora de falar sobre a pr√≥xima gera√ß√£o de processadores multicelulares: MultiClet S1. Se esta √© a primeira vez que voc√™ os conhece, verifique ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perspectiva: MultiClet S1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434982/"><img src="https://habrastorage.org/webt/fx/3k/yv/fx3kyvqsb8hquivzhowomntx-xe.jpeg"><br><br>  Ent√£o, √© hora de falar sobre a pr√≥xima gera√ß√£o de processadores multicelulares: MultiClet S1.  Se esta √© a primeira vez que voc√™ os conhece, verifique a hist√≥ria e a ideologia da arquitetura nestes artigos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Um processador multicelular √© o qu√™?"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Multiclet R1 - os primeiros testes"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Compilador C / C ++ baseado em LLVM para processadores multicelulares: ser ou n√£o ser?"</a> </li></ul><br>  No momento, o novo processador est√° em desenvolvimento, mas os primeiros resultados j√° apareceram e voc√™ pode avaliar do que ele ser√° capaz. <br><a name="habracut"></a><br>  Vamos come√ßar com as maiores mudan√ßas: recursos b√°sicos. <br><br><h2>  Caracter√≠sticas </h2><br>  Est√° previsto atingir os seguintes indicadores: <br><br><ol><li>  N√∫mero de c√©lulas: 64 </li><li>  Processo t√©cnico: 28 nm </li><li>  Frequ√™ncia de clock: 1,6 GHz </li><li>  O tamanho da mem√≥ria no chip: 8 MB </li><li>  √Årea de cristal: 40mm <sup>2</sup> </li><li>  Consumo de energia: 6 W </li></ol><br>  Os n√∫meros reais ser√£o anunciados com base nos resultados dos testes de amostras fabricadas em 2019.  Al√©m das caracter√≠sticas do pr√≥prio chip, o processador suporta at√© 16 GB de RAM padr√£o DDR4 3200MHz, barramento PCI Express e PLL. <br><br>  Deve-se notar que o processo de fabrica√ß√£o de 28 nm √© a faixa familiar mais baixa que n√£o requer permiss√µes especiais de uso, por isso foi ele quem foi escolhido.  Pelo n√∫mero de c√©lulas, diferentes op√ß√µes foram consideradas: 128 e 256, mas com um aumento na √°rea do cristal, a porcentagem de rejeitos aumenta.  Estabelecemos 64 c√©lulas e, consequentemente, uma √°rea relativamente pequena, o que proporcionar√° um rendimento maior de cristais adequados na placa.  √â poss√≠vel um maior desenvolvimento na estrutura do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ICS (sistema no caso)</a> , onde ser√° poss√≠vel combinar v√°rios cristais de 64 c√©lulas em um caso. <br><br>  Deve-se dizer que o objetivo e o uso do processador est√£o mudando radicalmente.  O S1 n√£o ser√° um microprocessador projetado para incorpora√ß√£o, como P1 e R1, mas um acelerador de c√°lculos.  Assim como a GPGPU, uma placa baseada em S1 pode ser inserida na placa-m√£e PCI Express de um PC comum e usada para processamento de dados. <br><br><h2>  Arquitetura </h2><br>  No S1, o "multicel" √© agora a unidade computacional m√≠nima: um conjunto de 4 c√©lulas executando uma certa sequ√™ncia de comandos.  Inicialmente, planejava-se combinar multic√©lulas em grupos chamados cluster para execu√ß√£o conjunta de comandos: um cluster precisava conter 4 multicells, no total havia 4 clusters separados no cristal.  No entanto, cada c√©lula tem uma conex√£o completa com todas as outras c√©lulas do aglomerado e, com um aumento no grupo de liga√ß√µes, torna-se excessiva, o que complica muito o design topol√≥gico do microcircuito e reduz suas caracter√≠sticas.  Portanto, eles decidiram abandonar a divis√£o de cluster, uma vez que a complica√ß√£o n√£o justifica os resultados.  Al√©m disso, para obter o desempenho m√°ximo, √© mais ben√©fico executar o c√≥digo em paralelo em cada multicell.  Total, agora o processador cont√©m 16 multic√©lulas separadas. <br><br>  Um multicelular, embora constitu√≠do por 4 c√©lulas, difere de um R1 de 4 c√©lulas, no qual cada c√©lula possui sua pr√≥pria mem√≥ria, seu pr√≥prio bloco de comandos de amostra e sua pr√≥pria ULA.  S1 √© organizado de maneira um pouco diferente.  A ALU possui 2 partes: um bloco aritm√©tico de ponto flutuante e um bloco aritm√©tico inteiro.  Cada c√©lula possui um bloco inteiro separado, mas existem apenas dois blocos com um ponto flutuante em uma multic√©lula e, portanto, dois pares de c√©lulas os dividem entre si.  Isso foi feito principalmente para reduzir a √°rea do cristal: a aritm√©tica de ponto flutuante de 64 bits, em contraste com a aritm√©tica inteira, ocupa muito espa√ßo.  Ter uma ALU em cada c√©lula acabou sendo redundante: os comandos de busca n√£o fornecem o carregamento da ALU e eles est√£o ociosos.  Embora reduza o n√∫mero de blocos da ALU e mantenha o ritmo de busca de comandos e dados, como a pr√°tica demonstrou, o tempo total para resolver problemas praticamente n√£o muda ou muda um pouco, e os blocos da ALU est√£o totalmente carregados.  Al√©m disso, a aritm√©tica de ponto flutuante n√£o √© usada com tanta freq√º√™ncia quanto com n√∫mero inteiro. <br><br>  Uma vista esquem√°tica dos blocos dos processadores R1 e S1 √© mostrada no diagrama abaixo.  Aqui: <br><br><ul><li>  CU (Unidade de controle) - unidade de busca de instru√ß√µes </li><li>  ALU <sub>FX</sub> - unidade l√≥gica aritm√©tica da aritm√©tica inteira </li><li>  ALU <sub>FP</sub> - Unidade l√≥gica aritm√©tica da aritm√©tica de ponto flutuante </li><li>  DMS (Data Memory Scheduler) - unidade de controle de mem√≥ria de dados </li><li>  DM - mem√≥ria de dados </li><li>  PMS (Program Memory Scheduler) - programa de controle de mem√≥ria </li><li>  PM - mem√≥ria de programa </li></ul><br><img src="https://habrastorage.org/webt/6t/4n/dp/6t4ndpu7d_koh8rpn8dmx0-b7ho.png"><br><br>  Diferen√ßas arquitet√¥nicas S1: <br><br><ol><li>  As equipes agora podem acessar os resultados da equipe dos par√°grafos anteriores.  Essa √© uma altera√ß√£o muito importante que permite acelerar significativamente as transi√ß√µes ao ramificar o c√≥digo.  Os processadores P1 e R1 n√£o tiveram escolha a n√£o ser gravar os resultados desejados na mem√≥ria e l√™-los imediatamente de volta com os primeiros comandos no novo par√°grafo.  Mesmo ao usar mem√≥ria em um chip, as opera√ß√µes de grava√ß√£o e leitura levam de 2 a 5 ciclos cada, o que pode ser salvo simplesmente referindo-se ao resultado do comando do par√°grafo anterior </li><li>  A grava√ß√£o na mem√≥ria e nos registros agora ocorre imediatamente, e n√£o no final de um par√°grafo, o que permite que voc√™ comece a escrever comandos antes do final do par√°grafo.  Como resultado, o tempo de inatividade potencial entre par√°grafos √© reduzido. </li><li>  O sistema de comando foi otimizado, a saber: <br><ul><li>  Adicionado aritm√©tica de n√∫mero inteiro de 64 bits: adi√ß√£o, subtra√ß√£o, multiplica√ß√£o de n√∫meros de 32 bits, que retorna um resultado de 64 bits. </li><li>  O m√©todo de leitura da mem√≥ria foi alterado: agora para <b>qualquer</b> comando, voc√™ pode simplesmente especificar o endere√ßo do qual deseja ler os dados como argumento, enquanto a ordem de execu√ß√£o dos comandos de leitura e grava√ß√£o √© preservada. <br><br>  Tamb√©m tornou obsoleto um comando de leitura de mem√≥ria separado.  Em vez disso, o comando load value √© usado na op√ß√£o <b>load</b> (anteriormente, <b>get</b> ), especificando o endere√ßo na mem√≥ria como argumento: <br><br><pre><code class="plaintext hljs">.data foo: .long 0x1234 .text habr: load_l foo ;      foo load_l [foo] ;    0x1234 add_l [foo], 0xABCD ;       ;   complete</code> </pre> <br></li><li>  Foi adicionado um formato de comando que permite o uso de 2 argumentos constantes. <br>  Anteriormente, era poss√≠vel especificar uma constante apenas como um segundo argumento, o primeiro argumento sempre deve ser um link para o resultado no comutador.  A altera√ß√£o se aplica a todas as equipes de dois argumentos.  O campo constante √© sempre de 32 bits, portanto esse formato permite, por exemplo, gerar constantes de 64 bits com um comando. <br><br>  Foi: <br><br><pre> <code class="plaintext hljs">load_l 0x12345678 patch_q @1, 0xDEADBEEF</code> </pre><br>  Tornou-se: <br><br><pre> <code class="plaintext hljs">patch_q 0x12345678, 0xDEADBEEF</code> </pre> <br></li><li>  Tipos de dados vetoriais modificados e suplementados. <br>  O que costumava ser chamado de tipos de dados "compactados" agora pode ser chamado de vetorial com seguran√ßa.  Em P1 e R1, as opera√ß√µes em n√∫meros compactados levaram apenas uma constante como o segundo argumento, isto √©, por exemplo, ao adicionar, cada elemento do vetor foi adicionado com o mesmo n√∫mero e isso n√£o p√¥de ser aplicado de maneira inteligente.  Agora, opera√ß√µes semelhantes podem ser aplicadas a dois vetores completos.  Al√©m disso, essa maneira de trabalhar com vetores √© totalmente consistente com o mecanismo de vetores no LLVM, que agora permite ao compilador gerar c√≥digo usando tipos de vetores. <br><br><pre> <code class="plaintext hljs">patch_q 0x00010002, 0x00030004 patch_q 0x00020003, 0x00040005 mul_ps @1, @2 ;  - 00020006000C0014</code> </pre><br></li></ul><br></li><li>  Sinalizadores do processador removidos. <br><br>  Como resultado, foram removidas cerca de 40 equipes baseadas apenas nos valores das bandeiras.  Isso reduziu significativamente o n√∫mero de equipes e, consequentemente, a √°rea do cristal.  E todas as informa√ß√µes necess√°rias agora s√£o armazenadas diretamente na c√©lula do switch. <br><br><ul><li>  Ao comparar com zero, em vez do sinalizador zero, agora apenas o valor no comutador √© usado </li><li>  Em vez do sinalizador, agora √© usado um bit correspondente ao tipo de comando: 7¬∫ para byte, 15¬∫ para abrevia√ß√£o, 31¬∫ para long, 63¬∫ para long, 63¬∫ para quad.  Devido ao fato de o caractere se multiplicar at√© o 63¬∫ bit, independentemente do tipo, voc√™ pode comparar n√∫meros de tipos diferentes: <br><br><pre> <code class="plaintext hljs">.data long: .long -0x1000 byte: .byte -0x10 .text habr: a := load_b [byte] ;     0xFFFFFFFFFFFFFFF0, ;   byte 7    63. b := loadu_b [byte] ;     0x00000000000000F0, ; ..  loadu_b    c := load_l [long] ;     0xFFFFFFFFFFFFF000. ge_l @a, @c ;   "  "  1: ;   31 ,   . lt_s @a, @b ; 1, .. b     complete</code> </pre><br></li><li>  O sinalizador de transporte n√£o √© mais necess√°rio, pois h√° aritm√©tica de 64 bits </li></ul><br></li><li>  O tempo de transi√ß√£o de par√°grafo para par√°grafo foi reduzido para 1 medida (em vez de 2-3 em R1) </li></ol><br><h2>  Compilador baseado em LLVM </h2><br>  O compilador da linguagem C para S1 √© semelhante ao R1 e, como a arquitetura n√£o mudou fundamentalmente, os problemas descritos no artigo anterior, infelizmente, n√£o desapareceram. <br><br>  No entanto, no processo de implementa√ß√£o do novo sistema de comando, a quantidade de c√≥digo de sa√≠da diminuiu por si s√≥, simplesmente devido √† atualiza√ß√£o do sistema de comando.  Al√©m disso, existem muitas otimiza√ß√µes menores que reduzir√£o o n√∫mero de instru√ß√µes no c√≥digo, algumas das quais j√° foram executadas (por exemplo, gerar constantes de 64 bits com uma √∫nica instru√ß√£o).  Mas h√° otimiza√ß√µes ainda mais s√©rias que precisam ser feitas e elas podem ser constru√≠das em ordem crescente de efici√™ncia e complexidade de implementa√ß√£o: <br><br><ol><li>  A capacidade de gerar todos os comandos de dois argumentos com duas constantes. <br><br>  Gerar uma constante de 64 bits via patch_q √© apenas um caso especial, mas precisamos de um caso geral.  De fato, o objetivo dessa otimiza√ß√£o √© permitir que as equipes substituam apenas o primeiro argumento como uma constante, uma vez que o segundo argumento sempre pode ser uma constante, e isso tem sido implementado h√° muito tempo.  Esse n√£o √© um caso muito frequente, mas, por exemplo, quando voc√™ precisa chamar uma fun√ß√£o e escrever o endere√ßo de retorno na parte superior da pilha, pode <br><br><pre> <code class="plaintext hljs">load_l func wr_l @1, #SP</code> </pre><br>  otimizar para <br><br><pre> <code class="plaintext hljs">wr_l func, #SP</code> </pre><br></li><li>  A capacidade de substituir o acesso √† mem√≥ria por meio de um argumento em qualquer comando. <br>  Por exemplo, se voc√™ precisar adicionar dois n√∫meros da mem√≥ria, poder√° <br><br><pre> <code class="plaintext hljs">load_l [foo] load_l [bar] add_l @1, @2</code> </pre><br>  otimizar para <br><br><pre> <code class="plaintext hljs">add_l [foo], [bar]</code> </pre><br>  Essa otimiza√ß√£o √© uma extens√£o da anterior, no entanto, a an√°lise j√° √© necess√°ria aqui: essa substitui√ß√£o s√≥ pode ser realizada se os valores carregados forem usados ‚Äã‚Äãapenas uma vez neste comando de adi√ß√£o e em nenhum outro lugar.  Se o resultado da leitura for usado mesmo em apenas dois comandos, √© mais lucrativo ler da mem√≥ria uma vez como um comando separado e nos outros dois referenci√°-lo atrav√©s do switch. <br></li><li>  Otimiza√ß√£o da transfer√™ncia de registros virtuais entre unidades base. <br>  Para R1, a transfer√™ncia de todos os registradores virtuais foi feita atrav√©s da mem√≥ria, o que gera um n√∫mero muito grande de leituras e grava√ß√µes na mem√≥ria, mas simplesmente n√£o havia outra maneira de transferir dados entre par√°grafos.  S1 permite acessar os resultados dos comandos dos par√°grafos anteriores; portanto, teoricamente, muitas opera√ß√µes de mem√≥ria podem ser removidas, o que daria o maior efeito entre todas as otimiza√ß√µes.  No entanto, essa abordagem ainda √© limitada pela op√ß√£o: n√£o mais que 63 resultados anteriores, t√£o longe de toda transfer√™ncia do registro virtual pode ser implementada dessa maneira.  Como fazer isso n√£o √© uma tarefa trivial, e uma an√°lise das possibilidades para resolv√™-lo ainda precisa ser feita.  As fontes do compilador podem aparecer em dom√≠nio p√∫blico; portanto, se algu√©m tiver id√©ias e voc√™ desejar ingressar no desenvolvimento, voc√™ poder√° faz√™-lo. <br></li></ol><br><h2>  Benchmarks </h2><br>  Como o processador ainda n√£o foi lan√ßado no chip, √© dif√≠cil avaliar seu desempenho real.  No entanto, o c√≥digo do kernel RTL j√° est√° pronto, o que significa que voc√™ pode fazer uma avalia√ß√£o usando simula√ß√£o ou FPGA.  Para executar os seguintes benchmarks, usamos uma simula√ß√£o usando o programa ModelSim para calcular o tempo exato de execu√ß√£o (em medidas).  Como √© dif√≠cil simular todo o cristal e leva muito tempo, portanto, uma multic√©lula foi simulada e o resultado foi multiplicado por 16 (se a tarefa foi projetada para multithreading), pois cada multic√©lula pode funcionar completamente independentemente das outras. <br><br>  Ao mesmo tempo, a modelagem multicelular foi realizada no Xilinx Virtex-6 para testar o desempenho do c√≥digo do processador em hardware real. <br><br><h4>  Coremark </h4><br>  CoreMark - um conjunto de testes para uma avalia√ß√£o abrangente do desempenho de microcontroladores e processadores centrais, bem como de seus compiladores C.  Como voc√™ pode ver, o processador S1 n√£o √© um nem o outro.  No entanto, pretende-se executar um c√≥digo absolutamente arbitr√°rio, ou seja,  qualquer pessoa que possa estar executando no processador central.  Portanto, o CoreMark √© adequado para avaliar o desempenho do S1 n√£o pior. <br><br>  O CoreMark cont√©m trabalho com listas vinculadas, matrizes, uma m√°quina de estado e c√°lculo de soma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CRC</a> .  Em geral, a maior parte do c√≥digo acaba sendo estritamente sequencial (que testa a for√ßa do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">paralelismo</a> multicelular de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hardware</a> ) e com muitas ramifica√ß√µes, motivo pelo qual os recursos do compilador desempenham um papel significativo no desempenho final.  O c√≥digo compilado cont√©m alguns par√°grafos curtos e, apesar do aumento da velocidade de transi√ß√£o entre eles, a ramifica√ß√£o inclui o trabalho com mem√≥ria, o que gostar√≠amos de evitar ao m√°ximo. <br><br>  Cart√£o de pontua√ß√£o CoreMark: <br><table><tbody><tr><th></th><th>  Multiclet R1 (compilador llvm) </th><th>  <b>Multiclet S1 (compilador llvm)</b> </th><th>  Elbrus-4C (R500 / E) </th><th>  Texas Inst.  AM5728 ARM Cortex-A15 </th><th>  Baikal-t1 </th><th>  Intel Core i7 7700K </th></tr><tr><td>  Ano de fabrica√ß√£o </td><td>  2015 </td><td>  <b>2019</b> </td><td>  2014 </td><td>  2018 </td><td>  2016 </td><td>  2017 </td></tr><tr><td>  Frequ√™ncia de clock, MHz </td><td>  100 </td><td>  <b>1600</b> </td><td>  700 </td><td>  1500 </td><td>  1200 </td><td>  4500 </td></tr><tr><td>  Pontua√ß√£o geral do CoreMark </td><td>  59. </td><td>  <b>18356</b> </td><td>  1214 </td><td>  15789 </td><td>  13142 </td><td>  182128 </td></tr><tr><td>  Coremark / MHz </td><td>  0,59 </td><td>  <b>11,47</b> </td><td>  5.05 </td><td>  10,53 </td><td>  10,95 </td><td>  40,47 </td></tr></tbody></table><br>  O resultado de um multicell √© 1147, ou 0,72 / MHz, que √© maior que o de R1.  Isso fala das vantagens do desenvolvimento de arquitetura multicelular no novo processador. <br><br><h4>  Wheatstone </h4><br>  Whetstone - um conjunto de testes para medir o desempenho do processador ao trabalhar com n√∫meros de ponto flutuante.  Aqui a situa√ß√£o √© muito melhor: o c√≥digo tamb√©m √© seq√ºencial, mas sem um grande n√∫mero de ramifica√ß√µes e com boa simultaneidade interna. <br><br>  O Whetstone consiste em muitos m√≥dulos, o que permite medir n√£o apenas o resultado geral, mas tamb√©m o desempenho em cada m√≥dulo espec√≠fico: <br><br><ol><li>  Elementos de matriz </li><li>  Matriz como par√¢metro </li><li>  Saltos condicionais </li><li>  Aritm√©tica de n√∫mero inteiro </li><li>  Fun√ß√µes trigonom√©tricas (tan, sin, cos) </li><li>  Chamadas de procedimento </li><li>  Refer√™ncias de matriz </li><li>  Fun√ß√µes padr√£o (sqrt, exp, log) </li></ol><br>  Eles s√£o divididos em categorias: os m√≥dulos 1, 2 e 6 medem o desempenho das opera√ß√µes de ponto flutuante (linhas MFLOPS1-3);  m√≥dulos 5 e 8 - fun√ß√µes matem√°ticas (COS MOPS, EXP MOPS);  m√≥dulos 4 e 7 - aritm√©tica de n√∫meros inteiros (FIXPT MOPS, IGUAL MOPS);  m√≥dulo 3 - saltos condicionais (SE MOPS).  Na tabela abaixo, a segunda linha do MWIPS √© um indicador geral. <br><br>  Ao contr√°rio do CoreMark, o Whetstone ser√° comparado em um n√∫cleo ou, como no nosso caso, em uma multic√©lula.  Como o n√∫mero de n√∫cleos √© muito diferente em diferentes processadores, para a pureza do experimento, consideramos os indicadores por megahertz. <br><br>  Cart√£o de pontua√ß√£o da pedra de amolar: <br><table><tbody><tr><th>  CPU </th><th>  MultiClet R1 </th><th>  <b>MultiClet S1</b> </th><th>  Core i7 4820K </th><th>  ARM v8-A53 </th></tr><tr><td>  Frequ√™ncia, MHz </td><td>  100 </td><td>  <b>1600</b> </td><td>  3900 </td><td>  1300 </td></tr><tr><td>  MWIPS / MHz </td><td>  0,311 </td><td>  <b>0,343</b> </td><td>  0,887 </td><td>  0,642 </td></tr><tr><td>  MFLOPS1 / MHz </td><td>  0,157 </td><td>  <b>0,156</b> </td><td>  0,341 </td><td>  0,268 </td></tr><tr><td>  MFLOPS2 / MHz </td><td>  0,153 </td><td>  <b>0,111</b> </td><td>  0,308 </td><td>  0,241 </td></tr><tr><td>  MFLOPS3 / MHz </td><td>  0,029 </td><td>  <b>0,124</b> </td><td>  0,167 </td><td>  0,239 </td></tr><tr><td>  MOPS COS / MHz </td><td>  0,018 </td><td>  <b>0,008</b> </td><td>  0,023 </td><td>  0,028 </td></tr><tr><td>  MOPS EXP / MHz </td><td>  0,008 </td><td>  <b>0,005</b> </td><td>  0,014 </td><td>  0,004 </td></tr><tr><td>  FIXPT MOPS / MHz </td><td>  0,714 </td><td>  <b>0,116</b> </td><td>  0,998 </td><td>  1.197 </td></tr><tr><td>  SE MOPS / MHz </td><td>  0,081 </td><td>  <b>0,196</b> </td><td>  1,504 </td><td>  1.436 </td></tr><tr><td>  MOPS IGUAIS / MHz </td><td>  0,143 </td><td>  <b>0,149</b> </td><td>  0,251 </td><td>  0,439 </td></tr></tbody></table><br>  O Whetstone cont√©m opera√ß√µes computacionais muito mais diretamente do que o CoreMark (o que √© muito percept√≠vel quando se olha o c√≥digo abaixo), por isso √© importante lembrar aqui: o n√∫mero de ALUs de ponto flutuante √© reduzido pela metade.  No entanto, a velocidade de computa√ß√£o quase n√£o foi afetada, em compara√ß√£o com R1. <br><br>  Alguns m√≥dulos se encaixam muito bem em uma arquitetura multicelular.  Por exemplo, o m√≥dulo 2 conta muitos valores em um ciclo e, gra√ßas ao suporte total de n√∫meros de ponto flutuante de precis√£o dupla, tanto pelo processador quanto pelo compilador, ap√≥s a compila√ß√£o, obtemos par√°grafos grandes e bonitos que realmente revelam os recursos computacionais de uma arquitetura multicelular: <br><br><div class="spoiler">  <b class="spoiler_title">Par√°grafo grande e bonito para 120 equipes</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pa: SR4 := loadu_q [#SP + 16] SR5 := loadu_q [#SP + 8] SR6 := loadu_l [#SP + 4] SR7 := loadu_l [#SP] setjf_l @0, @SR7 SR8 := add_l @SR6, 0x8 SR9 := add_l @SR6, 0x10 SR10 := add_l @SR6, 0x18 SR11 := loadu_q [@SR6] SR12 := loadu_q [@SR8] SR13 := loadu_q [@SR9] SR14 := loadu_q [@SR10] SR15 := add_d @SR11, @SR12 SR11 := add_d @SR15, @SR13 SR15 := sub_d @SR11, @SR14 SR11 := mul_d @SR15, @SR5 SR15 := add_d @SR12, @SR11 SR12 := sub_d @SR15, @SR13 SR15 := add_d @SR14, @SR12 SR12 := mul_d @SR15, @SR5 SR15 := sub_d @SR11, @SR12 SR16 := sub_d @SR12, @SR11 SR17 := add_d @SR11, @SR12 SR11 := add_d @SR13, @SR15 SR13 := add_d @SR14, @SR11 SR11 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR11 SR15 := add_d @SR17, @SR11 SR16 := add_d @SR14, @SR13 SR13 := div_d @SR16, @SR4 SR14 := sub_d @SR15, @SR13 SR15 := mul_d @SR14, @SR5 SR14 := add_d @SR12, @SR15 SR12 := sub_d @SR14, @SR11 SR14 := add_d @SR13, @SR12 SR12 := mul_d @SR14, @SR5 SR14 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR11, @SR14 SR11 := add_d @SR13, @SR15 SR14 := mul_d @SR11, @SR5 SR11 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR13, @SR11 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR15 := mul_d @SR13, @SR5 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR15 SR14 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR11, @SR13 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR4 := loadu_q @SR4 SR5 := loadu_q @SR5 SR6 := loadu_q @SR6 SR7 := loadu_q @SR7 SR15 := mul_d @SR13, @SR5 SR8 := loadu_q @SR8 SR9 := loadu_q @SR9 SR10 := loadu_q @SR10 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR15 SR14 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR11, @SR13 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR15 := mul_d @SR13, @SR5 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR15 SR14 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR11, @SR13 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR15 := mul_d @SR13, @SR5 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR17 SR14 := mul_d @SR13, @SR5 SR5 := add_d @SR16, @SR14 SR13 := add_d @SR11, @SR5 SR5 := div_d @SR13, @SR4 wr_q @SR15, @SR6 wr_q @SR12, @SR8 wr_q @SR14, @SR9 wr_q @SR5, @SR10 complete</code> </pre><br></div></div><br><h4>  popcnt </h4><br>  Para refletir as caracter√≠sticas da pr√≥pria arquitetura (independentemente do compilador), mediremos algo escrito no assembler, levando em considera√ß√£o todos os recursos da arquitetura.  Por exemplo, contando os bits da unidade em um n√∫mero de 512 bits (popcnt).  Por √≥bvio, pegaremos os resultados de uma multic√©lula, para que possam ser comparados com R1. <br><br>  Tabela de compara√ß√£o, o n√∫mero de ciclos de clock por ciclo de c√°lculo de 32 bits: <br><table><tbody><tr><th>  Algoritmo </th><th>  Multiclet r1 </th><th>  Multiclet S1 (um multicell) </th></tr><tr><td>  Bithacks </td><td>  5.0 </td><td>  2.625 </td></tr></tbody></table><br>  Novas instru√ß√µes vetoriais atualizadas foram usadas aqui, o que nos permitiu reduzir pela metade o n√∫mero de instru√ß√µes em compara√ß√£o com o mesmo algoritmo implementado no assembler R1.  A velocidade do trabalho, respectivamente, aumentou quase duas vezes. <br><br><div class="spoiler">  <b class="spoiler_title">popcnt</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">bithacks: b0 := patch_q 0x1, 0x1 v0 := loadu_q [v] v1 := loadu_q [v+8] v2 := loadu_q [v+16] v3 := loadu_q [v+24] v4 := loadu_q [v+32] v5 := loadu_q [v+40] v6 := loadu_q [v+48] v7 := loadu_q [v+56] b1 := patch_q 0x55555555, 0x55555555 i00 := slr_pl @v0, @b0 i01 := slr_pl @v1, @b0 i02 := slr_pl @v2, @b0 i03 := slr_pl @v3, @b0 i04 := slr_pl @v4, @b0 i05 := slr_pl @v5, @b0 i06 := slr_pl @v6, @b0 i07 := slr_pl @v7, @b0 b2 := patch_q 0x33333333, 0x33333333 i10 := and_q @i00, @b1 i11 := and_q @i01, @b1 i12 := and_q @i02, @b1 i13 := and_q @i03, @b1 i14 := and_q @i04, @b1 i15 := and_q @i05, @b1 i16 := and_q @i06, @b1 i17 := and_q @i07, @b1 b3 := patch_q 0x2, 0x2 i20 := sub_pl @v0, @i10 i21 := sub_pl @v1, @i11 i22 := sub_pl @v2, @i12 i23 := sub_pl @v3, @i13 i24 := sub_pl @v4, @i14 i25 := sub_pl @v5, @i15 i26 := sub_pl @v6, @i16 i27 := sub_pl @v7, @i17 i30 := and_q @i20, @b2 i31 := and_q @i21, @b2 i32 := and_q @i22, @b2 i33 := and_q @i23, @b2 i34 := and_q @i24, @b2 i35 := and_q @i25, @b2 i36 := and_q @i26, @b2 i37 := and_q @i27, @b2 i40 := slr_pl @i20, @b3 i41 := slr_pl @i21, @b3 i42 := slr_pl @i22, @b3 i43 := slr_pl @i23, @b3 i44 := slr_pl @i24, @b3 i45 := slr_pl @i25, @b3 i46 := slr_pl @i26, @b3 i47 := slr_pl @i27, @b3 b4 := patch_q 0x4, 0x4 i50 := and_q @i40, @b2 i51 := and_q @i41, @b2 i52 := and_q @i42, @b2 i53 := and_q @i43, @b2 i54 := and_q @i44, @b2 i55 := and_q @i45, @b2 i56 := and_q @i46, @b2 i57 := and_q @i47, @b2 i60 := add_pl @i50, @i30 i61 := add_pl @i51, @i31 i62 := add_pl @i52, @i32 i63 := add_pl @i53, @i33 i64 := add_pl @i54, @i34 i65 := add_pl @i55, @i35 i66 := add_pl @i56, @i36 i67 := add_pl @i57, @i37 b5 := patch_q 0xf0f0f0f, 0xf0f0f0f i70 := slr_pl @i60, @b4 i71 := slr_pl @i61, @b4 i72 := slr_pl @i62, @b4 i73 := slr_pl @i63, @b4 i74 := slr_pl @i64, @b4 i75 := slr_pl @i65, @b4 i76 := slr_pl @i66, @b4 i77 := slr_pl @i67, @b4 b6 := patch_q 0x1010101, 0x1010101 i80 := add_pl @i70, @i60 i81 := add_pl @i71, @i61 i82 := add_pl @i72, @i62 i83 := add_pl @i73, @i63 i84 := add_pl @i74, @i64 i85 := add_pl @i75, @i65 i86 := add_pl @i76, @i66 i87 := add_pl @i77, @i67 b7 := patch_q 0x18, 0x18 i90 := and_q @i80, @b5 i91 := and_q @i81, @b5 i92 := and_q @i82, @b5 i93 := and_q @i83, @b5 i94 := and_q @i84, @b5 i95 := and_q @i85, @b5 i96 := and_q @i86, @b5 i97 := and_q @i87, @b5 iA0 := mul_pl @i90, @b6 iA1 := mul_pl @i91, @b6 iA2 := mul_pl @i92, @b6 iA3 := mul_pl @i93, @b6 iA4 := mul_pl @i94, @b6 iA5 := mul_pl @i95, @b6 iA6 := mul_pl @i96, @b6 iA7 := mul_pl @i97, @b6 iB0 := slr_pl @iA0, @b7 iB1 := slr_pl @iA1, @b7 iB2 := slr_pl @iA2, @b7 iB3 := slr_pl @iA3, @b7 iB4 := slr_pl @iA4, @b7 iB5 := slr_pl @iA5, @b7 iB6 := slr_pl @iA6, @b7 iB7 := slr_pl @iA7, @b7 wr_q @iB0, c wr_q @iB1, c+8 wr_q @iB2, c+16 wr_q @iB3, c+24 wr_q @iB4, c+32 wr_q @iB5, c+40 wr_q @iB6, c+48 wr_q @iB7, c+56 complete</code> </pre><br></div></div><br><h4>  Ethereum </h4><br>  Os benchmarks s√£o, √© claro, bons, mas temos uma tarefa espec√≠fica: criar um acelerador de computa√ß√£o, e seria bom saber como ele lida com tarefas reais.  As criptomoedas modernas s√£o as mais adequadas para essa verifica√ß√£o, porque os algoritmos de minera√ß√£o s√£o executados em muitos dispositivos diferentes e, portanto, podem servir como refer√™ncia para compara√ß√£o.  Come√ßamos com o Ethereum e o algoritmo Ethash, que √© executado diretamente no dispositivo de minera√ß√£o. <br><br>  A escolha do Ethereum deveu-se √†s seguintes considera√ß√µes.  Como voc√™ sabe, algoritmos como o Bitcoin s√£o implementados com muita efici√™ncia por chips ASIC especializados, de modo que o uso de processadores ou placas de v√≠deo para minerar o Bitcoin e seus clones se torna economicamente desvantajoso devido ao baixo desempenho e alto consumo de energia.  A comunidade de mineradores, na tentativa de fugir dessa situa√ß√£o, est√° desenvolvendo criptomoedas em outros princ√≠pios algor√≠tmicos, concentrando-se no desenvolvimento de algoritmos que usam processadores de uso geral ou placas de v√≠deo para minera√ß√£o.  √â prov√°vel que esta tend√™ncia continue no futuro.  Ethereum √© a criptomoeda mais famosa com base nessa abordagem.  A principal ferramenta para minera√ß√£o do Ethereum s√£o as placas de v√≠deo, que em termos de efici√™ncia (hashrate / TDP) est√£o significativamente (v√°rias vezes) √† frente dos processadores de uso geral. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ethash</a> √© um algoritmo chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">limite de mem√≥ria</a> , ou seja,  seu tempo de c√°lculo √© limitado principalmente pela quantidade e velocidade da mem√≥ria, e n√£o pela velocidade dos pr√≥prios c√°lculos.  Agora, para a minera√ß√£o Ethereum, as placas de v√≠deo s√£o as mais adequadas, mas sua capacidade de executar muitas opera√ß√µes simultaneamente n√£o ajuda muito, e ainda permanecem na velocidade da RAM, o que √© claramente demonstrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> .  A partir da√≠, voc√™ pode tirar uma foto ilustrando a opera√ß√£o do algoritmo para explicar por que isso acontece. <br><br><img src="https://habrastorage.org/webt/y-/gg/t5/y-ggt5p2hd3w2vn1hzddmhwmq3u.png"><br><br>  O artigo divide o algoritmo em 6 pontos, mas √© poss√≠vel distinguir tr√™s est√°gios para uma obviedade ainda maior: <br><br><ol><li>  In√≠cio: SHA-3 (512) para calcular o Mix 0 original de 128 bytes (ponto 1) </li><li>  Rec√°lculo de 64 vezes da matriz Mix, lendo os pr√≥ximos 128 bytes e misturando-os com os anteriores atrav√©s da fun√ß√£o de mixagem, para um total de 8 kilobytes (par√°grafos 2-4) </li><li>  Finaliza√ß√£o e verifica√ß√£o do resultado </li></ol><br>  A leitura aleat√≥ria de 128 bytes da RAM leva muito mais tempo do que parece.  Se voc√™ usar a placa de v√≠deo MSI RX 470, que possui 2048 dispositivos de computa√ß√£o e uma largura de banda de mem√≥ria m√°xima de 211,2 GB / s, para equipar cada dispositivo, voc√™ precisa de 1 / (211,2 GB / (128 b * 2048)) = 1241 ns ou cerca de 1496 ciclos em uma determinada frequ√™ncia.  Dado o tamanho da fun√ß√£o de mixagem, podemos assumir que leva v√°rias vezes mais tempo para ler a mem√≥ria de uma placa de v√≠deo do que para recalcular as informa√ß√µes recebidas.  Como resultado, o est√°gio 2 do algoritmo leva muito tempo, muito mais do que os est√°gios 1 e 3, que no final t√™m pouco efeito no desempenho, apesar de conterem mais c√°lculos (principalmente no SHA-3).  Voc√™ pode ver o hashrate desta placa de v√≠deo: 26.375 megachashes / s te√≥ricos (limitado apenas pela largura de banda da mem√≥ria) versus 24 megachehes / s reais, ou seja, os est√°gios 1 e 3 levam apenas 10% do tempo. <br><br>  No S1, todos os 16 multicells podem funcionar em paralelo e em c√≥digo diferente.  Al√©m disso, a RAM de canal duplo ser√° instalada, ao longo de um canal para 8 multicells.  No est√°gio 2 do algoritmo Ethash, nosso plano √© o seguinte: uma multic√©lula l√™ 128 bytes da mem√≥ria e come√ßa a recont√°-los, depois a pr√≥xima l√™ a mem√≥ria e reconta, e assim por diante at√© o dia 8, ou seja,  uma multic√©lula, ap√≥s ler 128 bytes de mem√≥ria, possui 7 * [tempo de leitura de 128 bytes] para recalcular a matriz.  Sup√µe-se que essa leitura levar√° 16 ciclos, ou seja,  112 medidas s√£o dadas para recontagem.  O c√°lculo da fun√ß√£o de mixagem leva aproximadamente o mesmo ciclo de clock, portanto, o S1 est√° pr√≥ximo da propor√ß√£o ideal de largura de banda da mem√≥ria e desempenho do processador.  Como o tempo n√£o √© desperdi√ßado no segundo est√°gio, as partes restantes do algoritmo devem ser otimizadas o m√°ximo poss√≠vel, pois elas realmente afetam o desempenho. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para avaliar a velocidade de computa√ß√£o SHA-3 (Keccak), um programa C foi desenvolvido e testado, com base no qual sua vers√£o ideal no assembler est√° sendo criada. </font><font style="vertical-align: inherit;">A programa√ß√£o de avalia√ß√£o mostra que uma multic√©lula executa o c√°lculo de SHA-3 (Keccak) em 1550 ciclos de clock. </font><font style="vertical-align: inherit;">Portanto, o tempo total para calcular um hash por um multicelular ser√° 1550 + 64 * (16 + 112) = 9742 ciclos. </font><font style="vertical-align: inherit;">Com uma frequ√™ncia de 1,6 GHz e 16 multic√©lulas paralelas, a taxa de hash do processador ser√° de 2,6 MHash / s.</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acelerador </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MultiClet S1 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NVIDIA GeForce GTX 980 Ti </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radeon RX 470 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radeon RX Vega 64 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NVIDIA GeForce GTX 1060 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NVIDIA GeForce GTX 1080 Ti </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pre√ßo </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ 650 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ 180 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ 500 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ 300 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ 700 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Taxa de hash </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2,6 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21,6 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25,8 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 43,5 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 55 MHash / s </font></font></td></tr><tr><td>  TDP </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 250 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 120 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 295 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 120 W </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 250 W </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hashrate / TDP </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,43 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,09 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,22 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,15 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,22 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,21 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tecnologia de processo </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 28 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 28 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16 nm </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao usar o MultiClet S1 como uma ferramenta de minera√ß√£o, 20 ou mais processadores podem realmente ser instalados nas placas. </font><font style="vertical-align: inherit;">Nesse caso, o hashrate de uma placa desse tipo ser√° igual ou superior ao hashrates das placas de v√≠deo existentes, enquanto o consumo de energia de uma placa com S1 ser√° metade, mesmo que o de placas de v√≠deo com padr√µes topogr√°ficos de 16 e 14 nm. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concluindo, devo dizer que a principal tarefa agora √© a fabrica√ß√£o de uma placa multiprocessadora para um minerador de criptomoeda multicelular e um supercomputador. </font><font style="vertical-align: inherit;">A competitividade est√° planejada para ser alcan√ßada devido ao pequeno consumo de energia e arquitetura, o que √© adequado para computa√ß√£o arbitr√°ria.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O processador ainda est√° em desenvolvimento, mas voc√™ j√° pode iniciar a programa√ß√£o em linguagem assembly, bem como avaliar a vers√£o atual do compilador. </font><font style="vertical-align: inherit;">J√° existe um SDK m√≠nimo contendo montador, vinculador, compilador e modelo funcional, no qual voc√™ pode iniciar e testar seus programas.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434982/">https://habr.com/ru/post/pt434982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../In146148/index.html">Runetology (152): Slon.ru ‡§ï‡•á ‡§™‡•ç‡§∞‡§Æ‡•Å‡§ñ ‡§Æ‡•à‡§ï‡•ç‡§∏‡§ø‡§Æ ‡§ï‡§æ‡§∂‡•Å‡§≤‡§ø‡§Ç‡§∏‡•ç‡§ï‡•Ä</a></li>
<li><a href="../In146149/index.html">‡§ì‡§°‡•á‡§∏‡§æ ‡§Æ‡•á‡§Ç ‡§ó‡•ç‡§∞‡•Ä‡§∑‡•ç‡§Æ‡§ï‡§æ‡§≤‡•Ä‡§® ‡§¨‡§æ‡§∞‡§ï‡•à‡§Æ‡•ç‡§™</a></li>
<li><a href="../In146150/index.html">‡§Æ‡•Ä‡§°‡§ø‡§Ø‡§æ ‡§™‡•ç‡§≤‡•á‡§Ø‡§∞ ‡§ï‡•ã ‡§®‡•á‡§ü‡§ü‡•â‡§™ ‡§Æ‡•á‡§Ç ‡§ï‡•à‡§∏‡•á ‡§¨‡§¶‡§≤‡•á‡§Ç?</a></li>
<li><a href="../In146151/index.html">‡§è‡§ú‡§æ‡§á‡§≤ ‡§°‡§æ‡§á‡§µ ‡§°‡•á‡§™‡•ç‡§•: ‡§è‡§ú‡§æ‡§á‡§≤ ‡§á‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç‡§è‡§∂‡§® ‡§´‡•ç‡§∞‡•á‡§Æ‡§µ‡§∞‡•ç‡§ï</a></li>
<li><a href="../In146152/index.html">‡§ü‡•à‡§≤‡•á‡§Ç‡§ü ‡§Æ‡•à‡§™ ‡§∞‡§ø‡§ú‡•ç‡§Ø‡•Ç‡§Æ‡•á ‡§µ‡§ø‡§ú‡§º‡•Å‡§Ö‡§≤‡§æ‡§á‡§ú‡§º‡§∞ - ‡§∞‡§ø‡§≤‡•Ä‡§ú‡§º ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§∞‡§æ‡§∏‡•ç‡§§‡•á ‡§™‡§∞ ‡§è‡§°‡§µ‡•á‡§Ç‡§ö‡§∞‡•ç‡§∏</a></li>
<li><a href="../pt434984/index.html">Por que eu odeio Eloquent ORM</a></li>
<li><a href="../pt434986/index.html">Conceitos b√°sicos da biblioteca C ++ padr√£o</a></li>
<li><a href="../pt434992/index.html">Atualizando o IDA Pro. Depurador para Sega Mega Drive (parte 1)</a></li>
<li><a href="../pt434994/index.html">Android: Criando sabores din√¢micos de produtos e assinando configura√ß√µes</a></li>
<li><a href="../pt434996/index.html">Como compartilhei o local por meio da API VK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>