<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👽 🍺 🏽 Tidak akan ada koleksi abadi di Jawa - baik sekarang maupun selamanya 🚣 👃🏿 👄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Hari ini, perhatian Anda diundang ke terjemahan artikel yang ditulis dengan serius tentang salah satu masalah dasar Jawa - kemampuan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tidak akan ada koleksi abadi di Jawa - baik sekarang maupun selamanya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/470149/">  Halo semuanya! <br><br>  Hari ini, perhatian Anda diundang ke terjemahan artikel yang ditulis dengan serius tentang salah satu masalah dasar Jawa - kemampuan berubah-ubah, dan bagaimana hal itu memengaruhi struktur struktur data dan cara bekerja dengannya.  Materi diambil dari blog Nicolai Parlog, yang gaya sastra briliannya kami benar-benar berusaha untuk tetap menerjemahkan.  Nicholas sendiri sangat dicirikan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kutipan dari blog</a> perusahaan JUG.ru di Habré;  mari kita mengutip keseluruhan bagian ini: <br><br><img src="https://habrastorage.org/webt/7l/mh/iy/7lmhiypudt5z093eme-wrlhzygq.jpeg"><br><blockquote>  Nikolay Parlog adalah dude media yang melakukan review pada fitur Java.  Tapi dia bukan dari Oracle pada saat yang sama, jadi ulasannya sangat jujur ​​dan mudah dimengerti.  Terkadang setelah mereka seseorang dipecat, tetapi jarang.  Nikolay akan berbicara tentang masa depan Jawa, apa yang akan ada di versi baru.  Dia pandai berbicara tentang tren dan umumnya tentang dunia besar.  Dia adalah teman yang sangat baik membaca dan terpelajar.  Bahkan laporan sederhana menyenangkan untuk didengarkan, setiap saat Anda mempelajari sesuatu yang baru.  Selain itu, Nicholas tahu melampaui apa yang dia katakan.  Artinya, Anda dapat datang ke laporan apa pun dan hanya menikmatinya, bahkan jika ini bukan topik Anda sama sekali.  Dia sedang mengajar.  Dia menulis "The Java Module System" untuk Manning Publishing House, mengelola blog tentang pengembangan perangkat lunak di codefx.org, dan telah lama terlibat dalam beberapa proyek sumber terbuka.  Dia dapat dipekerjakan tepat di konferensi, dia adalah pekerja lepas.  Benar, freelancer yang sangat mahal.  Inilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporannya</a> . </blockquote><br>  Kami membaca dan memilih.  Yang terutama menyukai posting - kami juga menyarankan Anda melihat komentar pembaca pada posting asli. <br><a name="habracut"></a><br>  Volatilitas itu buruk, bukan?  Dengan demikian, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ketetapan adalah baik</a> .  Struktur data utama di mana imutabilitas sangat bermanfaat adalah koleksi: di Jawa itu adalah daftar ( <code>List</code> ), satu set ( <code>Set</code> ) dan kamus ( <code>Map</code> ).  Namun, meskipun JDK hadir dengan Koleksi yang tidak dapat diubah (atau tidak dapat dimodifikasi?), Sistem tipe tidak tahu apa-apa tentang ini.  Tidak ada <code>ImmutableList</code> di JDK, dan jenis ini dari Guava tampaknya sama sekali tidak berguna bagi saya.  Tapi mengapa?  Mengapa tidak menambahkan <code>Immutable...</code> ke dalam campuran ini dan tidak mengatakan bahwa itu seharusnya? <br><br><h4>  Apa itu koleksi abadi? </h4><br>  Dalam terminologi JDK, makna kata " <i>tidak berubah</i> " dan " <i>tidak dapat dimodifikasi</i> " telah berubah selama beberapa tahun terakhir.  Awalnya, "tidak dapat dimodifikasi" disebut sebuah instance yang tidak memungkinkan mutabilitas (mutabilitas): sebagai tanggapan terhadap metode yang berubah, ia melemparkan <code>UnsupportedOperationException</code> .  Namun, itu bisa diubah dengan cara lain - mungkin karena itu hanya pembungkus koleksi yang bisa berubah.  Pandangan ini tercermin dalam metode <code>Collections::unmodifiableList</code> , <code>unmodifiableSet</code> dan <code>unmodifiableMap</code> , serta di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaDoc mereka</a> . <br><br>  Awalnya, istilah " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak berubah</a> " mengacu pada koleksi yang dikembalikan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode pabrik dari koleksi Java 9</a> .  Koleksi itu sendiri tidak dapat diubah dengan cara apa pun (ya, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">refleksi</a> , tetapi tidak masuk hitungan), oleh karena itu, tampaknya mereka membenarkan nama mereka.  Sayangnya, kebingungan sering muncul karena ini.  Misalkan ada metode yang menampilkan semua elemen dari koleksi abadi di layar - akankah ia selalu memberikan hasil yang sama?  Hah?  Atau tidak? <br><br>  Jika Anda tidak segera menjawab <i>tidak</i> , itu berarti bahwa Anda baru saja melihat secara persis kebingungan apa yang mungkin terjadi di sini.  " <i>Koleksi Agen Rahasia yang Tidak Berubah</i> " - tampaknya terdengar sangat mirip dengan " <i>koleksi Agen Rahasia yang tidak dapat diubah,</i> " tetapi kedua entitas ini mungkin tidak identik.  Koleksi yang tidak dapat diubah tidak dapat diedit menggunakan operasi sisipkan / hapus / bersihkan, dll., Tetapi jika agen rahasia dapat berubah (meskipun karakter karakter dalam film mata-mata sangat buruk sehingga mereka tidak benar-benar mempercayainya), maka itu tidak berarti bahwa seluruh koleksi agen rahasia tidak dapat diubah.  Oleh karena itu, sekarang ada pergeseran ke arah penamaan koleksi yang <i>tidak dapat dimodifikasi</i> , daripada <i>tidak berubah</i> , yang diabadikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">edisi baru JavaDoc</a> . <br><br>  Koleksi abadi yang dibahas dalam artikel ini mungkin mengandung elemen yang bisa berubah. <br><br>  Secara pribadi, saya tidak suka revisi terminologi seperti itu.  Menurut pendapat saya, istilah "koleksi tidak dapat diubah" seharusnya hanya berarti bahwa koleksi itu sendiri tidak dapat diubah, tetapi tidak boleh mengkarakterisasi elemen-elemen yang terkandung di dalamnya.  Dalam hal ini, ada satu hal positif lagi: istilah "ketidakberdayaan" dalam ekosistem Jawa tidak berubah menjadi omong kosong. <br><br>  Dengan satu atau lain cara, dalam artikel ini kita akan berbicara tentang <i>koleksi abadi</i> , di mana ... <br><br><ul><li>  Contoh-contoh yang terkandung dalam koleksi ditentukan pada tahap desain </li><li>  Salinan ini - jumlah yang genap, tidak mengurangi atau menambah </li><li>  Tidak ada pernyataan yang dibuat sehubungan dengan mutabilitas elemen-elemen ini. </li></ul><br>  Mari kita memikirkan fakta bahwa sekarang kita akan berlatih menambahkan koleksi abadi.  Tepatnya - daftar abadi.  Segala sesuatu yang akan dikatakan tentang daftar sama-sama berlaku untuk koleksi jenis lain. <br><br>  Mulai menambahkan koleksi abadi! <br><br>  Mari kita membuat antarmuka <code>ImmutableList</code> dan membuatnya, relatif terhadap <code>List</code> , eh ... apa?  Supertype atau subtype?  Mari kita memikirkan opsi pertama. <br><br><img src="https://habrastorage.org/webt/sc/uv/yl/scuvyloeubhj5-wq36b7nzuzdu8.png"><br><br>  Indahnya, <code>ImmutableList</code> tidak <code>ImmutableList</code> metode yang <code>ImmutableList</code> , jadi menggunakannya selalu aman, bukan?  Jadi?  Tidak, tuan. <br><br><pre> <code class="java hljs">List&lt;Agent&gt; agents = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ,  `List`  `ImmutableList` ImmutableList&lt;Agent&gt; section4 = agents; //    section4.forEach(System.out::println); //    `section4` agents.add(new Agent("Motoko"); //  "Motoko" – ,      ?! section4.forEach(System.out::println);</span></span></code> </pre> <br>  Contoh ini menunjukkan bahwa dimungkinkan untuk mentransfer daftar yang tidak sepenuhnya tidak dapat diubah tersebut ke API, yang operasinya dapat dibangun di atas ketidakmampuan dan, karenanya, membatalkan semua jaminan yang mungkin disiratkan oleh nama jenis ini.  Inilah resep untuk Anda yang bisa mengakibatkan bencana. <br><br>  OK, kemudian <code>ImmutableList</code> memperpanjang <code>List</code> .  Mungkin? <br><br><img src="https://habrastorage.org/webt/fr/sq/_r/frsq_rgj7rt0mp3u0f--zn8jlrs.png"><br><br>  Sekarang, jika API mengharapkan daftar yang tidak dapat diubah, maka ia akan menerima daftar seperti itu, tetapi ada dua kelemahan: <br><br><ul><li>  Daftar yang tidak dapat diubah harus tetap menawarkan metode modifikasi (seperti yang didefinisikan dalam supertype), dan satu-satunya implementasi yang mungkin akan menimbulkan pengecualian </li><li>  Instance <code>ImmutableList</code> juga instance Instances, dan ketika ditugaskan ke variabel seperti itu, diteruskan sebagai argumen seperti itu, atau dikembalikan dari jenis ini, logis untuk mengasumsikan bahwa mutabilitas diperbolehkan. </li></ul><br>  Dengan demikian, ternyata Anda hanya dapat menggunakan <code>ImmutableList</code> secara lokal, karena ia melewati batas API sebagai <code>List</code> , yang mengharuskan Anda untuk melakukan tindakan pencegahan tingkat manusia super, atau meledak saat runtime.  Ini tidak seburuk <code>List</code> memperpanjang <code>ImmutableList</code> , tetapi solusi seperti itu masih jauh dari ideal. <br><br>  Ini persis apa yang ada dalam pikiran saya ketika saya mengatakan bahwa tipe <code>ImmutableList</code> dari Guava praktis tidak berguna.  Ini adalah contoh kode yang hebat, sangat andal ketika bekerja dengan daftar lokal yang tidak dapat diubah (itulah sebabnya saya menggunakannya secara aktif), tetapi, dengan menggunakan itu, sangat mudah untuk melampaui benteng yang tidak dapat ditembus, kompilasi yang dijamin, dinding-dindingnya terdiri dari tipe yang tidak dapat diubah - dan hanya di dalamnya tipe abadi dapat sepenuhnya mengungkapkan potensi mereka.  Ini lebih baik daripada tidak sama sekali, tetapi tidak efisien sebagai solusi JDK. <br><br>  Jika <code>ImmutableList</code> tidak dapat memperpanjang <code>List</code> , dan solusi masih tidak berfungsi, lalu bagaimana cara membuatnya semua berfungsi? <br><br><h4>  Kekekalan adalah fitur </h4><br>  Masalah yang kami temui dalam dua upaya pertama untuk menambahkan tipe yang tidak dapat diubah adalah kesalahpahaman kami bahwa ketidakmampuan hanyalah tidak adanya sesuatu: kami mengambil <code>List</code> , menghapus kode yang berubah darinya, kami mendapatkan <code>ImmutableList</code> .  Tetapi, pada kenyataannya, semua ini tidak bekerja seperti itu. <br><br>  Jika kami hanya menghapus metode modifikasi dari <code>List</code> , kami mendapatkan daftar hanya-baca.  Atau, mengikuti terminologi yang dirumuskan di atas, itu bisa disebut <code>UnmodifiableList</code> - itu masih bisa berubah, hanya saja Anda tidak akan mengubahnya. <br><br>  Sekarang kita dapat menambahkan dua hal lagi ke gambar ini: <br><br><ul><li>  Kita dapat membuatnya bisa berubah dengan menambahkan metode yang sesuai </li><li>  Kami dapat membuatnya tidak berubah dengan menambahkan jaminan yang sesuai. </li></ul><br>  Kekekalan bukanlah tidak adanya mutabilitas, tetapi jaminan bahwa tidak akan ada perubahan <br>  Dalam hal ini, penting untuk dipahami bahwa dalam kedua kasus ini kita berbicara tentang fitur lengkap - ketidakmampuan bukanlah tidak adanya perubahan, tetapi jaminan bahwa tidak akan ada perubahan.  Fitur yang ada mungkin tidak selalu menjadi sesuatu yang digunakan untuk kebaikan, itu juga dapat menjamin bahwa sesuatu yang buruk tidak akan terjadi dalam kode - dalam hal ini, pikirkan, misalnya, tentang keamanan utas. <br><br>  Jelaslah, ketidakmampuan dan ketidakmampuan bertentangan satu sama lain, dan oleh karena itu kita tidak dapat secara bersamaan menggunakan dua hierarki warisan yang disebutkan di atas.  Jenis mewarisi kemampuan dari jenis lain, jadi tidak masalah bagaimana Anda memotongnya, jika salah satu jenis mewarisi dari yang lain, itu akan berisi kedua fitur. <br><br>  <code>ImmutableList</code> , <code>List</code> dan <code>ImmutableList</code> tidak dapat saling memperpanjang.  Tetapi kami dibawa ke sini dengan bekerja dengan <code>UnmodifiableList</code> , dan ternyata kedua jenis memiliki API yang sama, hanya-baca, yang berarti mereka harus memperluasnya. <br><br><img src="https://habrastorage.org/webt/bd/dp/7b/bddp7bjb5e9m6sddvp4slse0yfi.png"><br><br>  Meskipun, saya tidak akan menyebut nama-nama ini dengan tepat, hierarki semacam ini masuk akal.  Di Scala, misalnya, ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">praktis dilakukan</a> .  Perbedaannya adalah bahwa supertype bersama, yang kami sebut <code>UnmodifiableList</code> , mendefinisikan metode yang bisa berubah yang mengembalikan koleksi yang dimodifikasi dan membiarkan yang asli tidak tersentuh.  Dengan demikian, daftar yang tidak dapat diubah ternyata bersifat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">persisten</a> dan memberikan varian yang dapat berubah dua set metode modifikasi - diwarisi untuk menerima salinan yang dimodifikasi dan miliknya sendiri untuk perubahan yang terjadi. <br><br>  Bagaimana dengan Jawa?  Apakah mungkin memodernisasi hierarki dengan menambahkan supertipe dan saudara kandung yang baru ke dalamnya? <br><br>  Apakah mungkin untuk meningkatkan koleksi yang tidak dapat dimodifikasi dan tidak dapat diubah? <br>  Tentu saja, tidak ada masalah dalam menambahkan tipe <code>UnmodifiableList</code> dan <code>ImmutableList</code> dan membuat hierarki warisan yang dijelaskan di atas.  Masalahnya adalah bahwa dalam jangka pendek dan menengah praktis tidak akan berguna.  Biarkan saya jelaskan. <br><br>  Yang <code>ImmutableList</code> memiliki <code>UnmodifiableList</code> , <code>UnmodifiableList</code> , dan <code>List</code> sebagai tipe - dalam hal ini, API akan dapat dengan jelas menyatakan apa yang mereka butuhkan dan apa yang mereka tawarkan. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payAgents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnmodifiableList&lt;Agent&gt; agents)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      , //         } public void sendOnMission(ImmutableList&lt;Agent&gt; agents) { //   ( ), //  ,     } public void downtime(List&lt;Agent&gt; agents) { //       , //        ,      } public UnmodifiableList&lt;Agent&gt; teamRoster() { //   ,     , //      ,     -  } public ImmutableList&lt;Agent&gt; teamOnMission() { //    ,      } public List&lt;Agent&gt; team() { //    ,    , //        }</span></span></code> </pre> <br>  Namun, kecuali jika Anda memulai proyek dari awal, Anda mungkin akan memiliki fungsi seperti itu, dan itu akan terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  `Iterable&lt;Agent&gt;` //  ,   ,        public void payAgents(List&lt;Agent&gt; agents) { } public void sendOnMission(List&lt;Agent&gt; agents) { } public void downtime(List&lt;Agent&gt; agents) { } //      , //    ,  `List`     public List&lt;Agent&gt; teamRoster() { } // ,     `Stream&lt;Agent&gt;` public List&lt;Agent&gt; teamOnMission() { } public List&lt;Agent&gt; team() { }</span></span></code> </pre> <br>  Ini tidak baik, karena agar koleksi baru yang baru saja diperkenalkan oleh kami bermanfaat, kita perlu bekerja dengannya!  (Fiuh).  Di atas mengingatkan pada kode aplikasi, oleh karena itu, refactoring <code>ImmutableList</code> <code>UnmodifiableList</code> dan <code>ImmutableList</code> , dan Anda dapat mengimplementasikannya, seperti yang ditunjukkan dalam daftar di atas.  Ini bisa menjadi potongan besar pekerjaan, ditambah dengan kebingungan ketika Anda perlu mengatur interaksi kode lama dan diperbarui, tetapi setidaknya tampaknya layak. <br><br>  Bagaimana dengan kerangka kerja, perpustakaan, dan JDK itu sendiri?  Semuanya di sini tampak suram.  Upaya untuk mengubah parameter atau jenis kembali dari <code>List</code> ke <code>ImmutableList</code> akan menyebabkan <i>ketidakcocokan dengan kode sumber</i> , mis.  kode sumber yang ada tidak akan dikompilasi dengan versi baru, karena jenis ini tidak saling terkait.  Demikian pula, mengubah tipe pengembalian dari <code>List</code> ke supertype baru UnmodifiableList akan menghasilkan kesalahan kompilasi. <br><br>  Dengan diperkenalkannya tipe baru, akan perlu untuk membuat perubahan dan mengkompilasi ulang seluruh ekosistem. <br><br>  Namun, bahkan jika kita memperluas tipe parameter dari <code>List</code> ke <code>UnmodifiableList</code> , kita akan mengalami masalah, karena perubahan seperti itu menyebabkan <i>ketidakcocokan pada level bytecode</i> .  Ketika kode sumber memanggil suatu metode, kompiler mengubah panggilan ini menjadi bytecode yang mereferensikan metode target dengan: <br><br><ul><li>  Nama kelas yang instance targetnya dideklarasikan </li><li>  Nama metode </li><li>  Metode tipe parameter </li><li>  Jenis metode pengembalian </li></ul><br>  Setiap perubahan dalam parameter atau tipe pengembalian metode akan menyebabkan bytecode menunjukkan tanda tangan yang salah ketika merujuk ke metode;  sebagai hasilnya, kesalahan <code>NoSuchMethodError</code> akan terjadi selama eksekusi.  Jika perubahan yang Anda lakukan kompatibel dengan kode sumber - misalnya, jika Anda berbicara tentang mempersempit tipe pengembalian atau memperluas jenis parameter - maka kompilasi ulang harus memadai.  Namun, dengan perubahan yang jauh jangkauannya, misalnya, dengan diperkenalkannya koleksi baru, semuanya tidak begitu sederhana: untuk mengkonsolidasikan perubahan tersebut, Anda perlu mengkompilasi ulang seluruh ekosistem Jawa.  Ini bisnis yang hilang. <br><br>  Satu-satunya cara yang mungkin untuk mengambil keuntungan dari koleksi baru seperti itu tanpa merusak kompatibilitas adalah dengan menduplikasi setiap metode yang ada dengan nama baru, mengubah API, dan kemudian menandai versi lama sebagai yang tidak diinginkan.  Bisakah Anda bayangkan betapa monumental dan hampir tak terbatas tugas seperti itu?! <br><br><h4>  Refleksi </h4><br>  Tentu saja, tipe koleksi yang tidak berubah adalah hal hebat yang saya ingin miliki, tetapi kita tidak mungkin melihat sesuatu seperti ini di JDK.  Implementasi kompeten <code>List</code> dan <code>ImmutableList</code> tidak <code>ImmutableList</code> pernah <code>ImmutableList</code> saling memperluas (pada kenyataannya, keduanya memperpanjang tipe daftar yang sama dengan <code>UnmodifiableList</code> , yang hanya-baca), yang membuatnya sulit untuk mengintegrasikan tipe-tipe tersebut ke dalam API yang ada. <br><br>  Di luar konteks hubungan spesifik antara jenis, mengubah tanda tangan metode yang ada selalu penuh dengan masalah, karena perubahan tersebut tidak kompatibel dengan bytecode.  Ketika mereka diperkenalkan, setidaknya diperlukan kompilasi ulang, dan ini adalah perubahan yang menghancurkan yang akan mempengaruhi seluruh ekosistem Jawa. <br><br>  Karena itu, saya percaya bahwa hal seperti ini tidak akan terjadi - tidak pernah dan tidak akan pernah. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470149/">https://habr.com/ru/post/id470149/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470129/index.html">Manajemen memori deklaratif</a></li>
<li><a href="../id470133/index.html">Cara mengumpulkan metrik yang tidak terdistorsi berdasarkan referensi waktu dengan Prometheus</a></li>
<li><a href="../id470135/index.html">Aplikasi web interaktif tanpa pemrograman? Mudah! Mavo di tangan Anda</a></li>
<li><a href="../id470139/index.html">2 life hacks: alternatif pencarian klasik di Microsoft SQL Server</a></li>
<li><a href="../id470145/index.html">“Waspadalah, FAS!”: Apa bahaya ID militer dalam periklanan, mengapa penting untuk mengetahui matematika dan apakah kebenaran telanjang selalu dibutuhkan</a></li>
<li><a href="../id470153/index.html">Kamus Model Data</a></li>
<li><a href="../id470155/index.html">Fitur pengenalan pola nasional</a></li>
<li><a href="../id470159/index.html">Generasi Perdana</a></li>
<li><a href="../id470165/index.html">Filosofi membagi dengan ... atau pengakuan orang gila</a></li>
<li><a href="../id470167/index.html">Konferensi untuk mereka yang tertarik pada sains sebelum menjadi arus utama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>