<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🏫 ⚕️ 😕 La tupla de una persona sana. 🔅 🆗 🌫️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artículo trata sobre uno de los mejores inventos de Python: namedtuple. Consideraremos sus características agradables, desde conocidas hasta no o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La tupla de una persona sana.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438162/"><p><img src="https://habrastorage.org/webt/ou/ec/1d/ouec1dsywtxqia_uzzqonhvnrty.png" alt="Tupla nombrada"><br>  Este artículo trata sobre uno de los mejores inventos de Python: namedtuple.  Consideraremos sus características agradables, desde conocidas hasta no obvias.  El nivel de inmersión en el tema aumentará gradualmente, por lo que espero que todos encuentren algo interesante para ellos.  Vamos! </p><a name="habracut"></a><br><h2 id="vvedenie">  Introduccion </h2><br><p>  Seguramente se enfrenta a una situación en la que necesita transferir varias propiedades del objeto en una sola pieza.  Por ejemplo, información sobre una mascota: tipo, apodo y edad. </p><br><p>  A menudo es demasiado vago crear una clase separada para esto, y se usan tuplas: </p><br><pre><code class="python hljs">(<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-string"><span class="hljs-string">"fox"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) (<span class="hljs-string"><span class="hljs-string">"parrot"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Para mayor claridad, una tupla con nombre - <code>collections.namedtuple</code> es adecuada: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple Pet = namedtuple(<span class="hljs-string"><span class="hljs-string">"Pet"</span></span>, <span class="hljs-string"><span class="hljs-string">"type name age"</span></span>) frank = Pet(type=<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, name=<span class="hljs-string"><span class="hljs-string">""</span></span>, age=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; frank.age <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Todos lo saben ツ Y aquí hay algunas características menos conocidas: </p><br><h2 id="bystroe-izmenenie-poley">  Campos de cambio rápido </h2><br><p>  ¿Qué pasa si una de las propiedades necesita ser cambiada?  Frank está envejeciendo, y la caravana es inmutable.  Para no recrearlo por completo, se nos ocurrió el método <code>_replace()</code> : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>frank._replace(age=<span class="hljs-number"><span class="hljs-number">4</span></span>) Pet(type=<span class="hljs-string"><span class="hljs-string">'pigeon'</span></span>, name=<span class="hljs-string"><span class="hljs-string">''</span></span>, age=<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br><p>  Y si quieres hacer que toda la estructura sea mutable - <code>_asdict()</code> : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>frank._asdict() OrderedDict([(<span class="hljs-string"><span class="hljs-string">'type'</span></span>, <span class="hljs-string"><span class="hljs-string">'pigeon'</span></span>), (<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), (<span class="hljs-string"><span class="hljs-string">'age'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)])</code> </pre> <br><h2 id="avtomaticheskaya-zamena-nazvaniy">  Cambio automático de título </h2><br><p>  Suponga que importa datos de un CSV y convierte cada línea en una tupla.  Los nombres de campo se tomaron del encabezado del archivo CSV.  Pero algo sale mal: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># headers = ("name", "age", "with") &gt;&gt;&gt; Pet = namedtuple("Pet", headers) ValueError: Type names and field names cannot be a keyword: 'with' # headers = ("name", "age", "name") &gt;&gt;&gt; Pet = namedtuple("Pet", headers) ValueError: Encountered duplicate field name: 'name'</span></span></code> </pre> <br><p>  La solución es el argumento <code>rename=True</code> en el constructor: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># headers = ("name", "age", "with", "color", "name", "food") Pet = namedtuple("Pet", headers, rename=True) &gt;&gt;&gt; Pet._fields ('name', 'age', '_2', 'color', '_4', 'food')</span></span></code> </pre> <br><p>  Los nombres "sin éxito" se renombraron de acuerdo con los números de serie. </p><br><h2 id="znacheniya-po-umolchaniyu">  Valores por defecto </h2><br><p>  Si una tupla tiene un montón de campos opcionales, aún debe enumerarlos cada vez que crea un objeto: </p><br><pre> <code class="python hljs">Pet = namedtuple(<span class="hljs-string"><span class="hljs-string">"Pet"</span></span>, <span class="hljs-string"><span class="hljs-string">"type name alt_name"</span></span>) &gt;&gt;&gt; Pet(<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) TypeError: __new__() missing <span class="hljs-number"><span class="hljs-number">1</span></span> required positional argument: <span class="hljs-string"><span class="hljs-string">'alt_name'</span></span> &gt;&gt;&gt; Pet(<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) Pet(type=<span class="hljs-string"><span class="hljs-string">'pigeon'</span></span>, name=<span class="hljs-string"><span class="hljs-string">''</span></span>, alt_name=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br><p>  Para evitar esto, especifique los <code>defaults</code> en el constructor: </p><br><pre> <code class="python hljs">Pet = namedtuple(<span class="hljs-string"><span class="hljs-string">"Pet"</span></span>, <span class="hljs-string"><span class="hljs-string">"type name alt_name"</span></span>, defaults=(<span class="hljs-string"><span class="hljs-string">""</span></span>,)) &gt;&gt;&gt; Pet(<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) Pet(type=<span class="hljs-string"><span class="hljs-string">'pigeon'</span></span>, name=<span class="hljs-string"><span class="hljs-string">''</span></span>, alt_name=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  <code>defaults</code> predeterminados asignan valores predeterminados de la cola.  Funciona en python 3.7+ </p><br><p>  Para versiones anteriores, puede lograr de manera más torpe el mismo resultado a través del prototipo: </p><br><pre> <code class="python hljs">Pet = namedtuple(<span class="hljs-string"><span class="hljs-string">"Pet"</span></span>, <span class="hljs-string"><span class="hljs-string">"type name alt_name"</span></span>) default_pet = Pet(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) &gt;&gt;&gt; default_pet._replace(type=<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, name=<span class="hljs-string"><span class="hljs-string">""</span></span>) Pet(type=<span class="hljs-string"><span class="hljs-string">'pigeon'</span></span>, name=<span class="hljs-string"><span class="hljs-string">''</span></span>, alt_name=<span class="hljs-string"><span class="hljs-string">''</span></span>) &gt;&gt;&gt; default_pet._replace(type=<span class="hljs-string"><span class="hljs-string">"fox"</span></span>, name=<span class="hljs-string"><span class="hljs-string">""</span></span>) Pet(type=<span class="hljs-string"><span class="hljs-string">'fox'</span></span>, name=<span class="hljs-string"><span class="hljs-string">''</span></span>, alt_name=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  Pero con los <code>defaults</code> , por supuesto, mucho mejor. </p><br><h2 id="neobychaynaya-lyogkost">  Extraordinaria ligereza </h2><br><p>  Uno de los beneficios de una tupla con nombre es la ligereza.  Un ejército de cien mil palomas tomará solo 10 megabytes: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> objsize <span class="hljs-comment"><span class="hljs-comment"># 3rd party Pet = namedtuple("Pet", "type name age") frank = Pet(type="pigeon", name="", age=None) pigeons = [frank._replace(age=idx) for idx in range(100000)] &gt;&gt;&gt; round(objsize.get_deep_size(pigeons)/(1024**2), 2) 10.3</span></span></code> </pre> <br><p>  A modo de comparación, si convierte a Pet en una clase ordinaria, una lista similar ya ocupará 19 megabytes. </p><br><p>  Esto sucede porque los objetos ordinarios en Python llevan una gran <code>__dict__</code> __dict__, que contiene los nombres y valores de todos los atributos del objeto: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PetObj</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, type, name, age)</span></span></span><span class="hljs-function">:</span></span> self.type = type self.name = name self.age = age frank_obj = PetObj(type=<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, name=<span class="hljs-string"><span class="hljs-string">""</span></span>, age=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; frank_obj.__dict__ {<span class="hljs-string"><span class="hljs-string">'type'</span></span>: <span class="hljs-string"><span class="hljs-string">'pigeon'</span></span>, <span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'age'</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre> <br><p>  Los objetos namedtuple carecen de este diccionario y, por lo tanto, ocupan menos memoria: </p><br><pre> <code class="python hljs">frank = Pet(type=<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, name=<span class="hljs-string"><span class="hljs-string">""</span></span>, age=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; frank.__dict__ AttributeError: <span class="hljs-string"><span class="hljs-string">'Pet'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'__dict__'</span></span> &gt;&gt;&gt; objsize.get_deep_size(frank_obj) <span class="hljs-number"><span class="hljs-number">335</span></span> &gt;&gt;&gt; objsize.get_deep_size(frank) <span class="hljs-number"><span class="hljs-number">239</span></span></code> </pre> <br><p>  Pero, ¿cómo se libró la tupla nombrada de <code>__dict__</code> ?  Sigue leyendo ツ </p><br><h2 id="bogatyy-vnutrenniy-mir">  Rico mundo interior </h2><br><p>  Si ha estado trabajando con Python durante mucho tiempo, entonces probablemente sepa: se puede crear un objeto liviano a través de la <code>__slots__</code> __slots__: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PetSlots</span></span></span><span class="hljs-class">:</span></span> __slots__ = (<span class="hljs-string"><span class="hljs-string">"type"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, type, name, age)</span></span></span><span class="hljs-function">:</span></span> self.type = type self.name = name self.age = age frank_slots = PetSlots(type=<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, name=<span class="hljs-string"><span class="hljs-string">""</span></span>, age=<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  Los objetos "Slot" no tienen un diccionario con atributos, por lo que ocupan poca memoria.  "Frank en las máquinas tragamonedas" es tan ligero como "Frank en la caravana", ver: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>objsize.get_deep_size(frank) <span class="hljs-number"><span class="hljs-number">239</span></span> &gt;&gt;&gt; objsize.get_deep_size(frank_slots) <span class="hljs-number"><span class="hljs-number">231</span></span></code> </pre> <br><p>  Si decides que namedtuple también usa slots, esto no está lejos de la verdad.  Como recordará, las clases de tuplas específicas se declaran dinámicamente: </p><br><pre> <code class="python hljs">Pet = namedtuple(<span class="hljs-string"><span class="hljs-string">"Pet"</span></span>, <span class="hljs-string"><span class="hljs-string">"type name age"</span></span>)</code> </pre> <br><p>  El constructor namedtuple usa magia oscura diferente y genera algo como esta clase (simplificando enormemente): </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(tuple)</span></span></span><span class="hljs-class">:</span></span> __slots__ = () type = property(operator.itemgetter(<span class="hljs-number"><span class="hljs-number">0</span></span>)) name = property(operator.itemgetter(<span class="hljs-number"><span class="hljs-number">1</span></span>)) age = property(operator.itemgetter(<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__new__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, type, name, age)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tuple.__new__(cls, (type, name, age))</code> </pre> <br><p>  Es decir, nuestra mascota es una <code>tuple</code> ordinaria, a la que se han clavado tres métodos de propiedad con clavos: </p><br><ul><li>  <code>type</code> devuelve el elemento nulo de la tupla </li><li>  <code>name</code> : el primer elemento de la tupla </li><li>  <code>age</code> - el segundo elemento de la tupla </li></ul><br><p>  Y <code>__slots__</code> solo <code>__slots__</code> necesita para que los objetos sean ligeros.  Como resultado, Pet ocupa poco espacio y puede usarse como una tupla regular: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>frank.index(<span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; type, _, _ = frank &gt;&gt;&gt; type <span class="hljs-string"><span class="hljs-string">'pigeon'</span></span></code> </pre> <br><p>  Ingeniosamente inventado, ¿eh? </p><br><h2 id="neustupaet-data-klassam">  No es inferior a las clases de datos </h2><br><p>  Ya que estamos hablando de generación de código.  En Python 3.7, apareció un código uber-generador, que no tiene igual - clases de datos. </p><br><p>  Cuando vea por primera vez una clase de datos, desea cambiar a una nueva versión del idioma solo por el bien de esta: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dataclasses <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataclass @dataclass <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PetData</span></span></span><span class="hljs-class">:</span></span> type: str name: str age: int</code> </pre> <br><p>  ¡El milagro es tan bueno!  Pero hay un matiz: es gordo: </p><br><pre> <code class="python hljs">frank_data = PetData(type=<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, name=<span class="hljs-string"><span class="hljs-string">""</span></span>, age=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; objsize.get_deep_size(frank_data) <span class="hljs-number"><span class="hljs-number">335</span></span> &gt;&gt;&gt; objsize.get_deep_size(frank) <span class="hljs-number"><span class="hljs-number">239</span></span></code> </pre> <br><p>  La clase de datos genera una clase de python regular, cuyos objetos se agotan bajo el peso de <code>__dict__</code> .  Entonces, si está leyendo líneas desde la base y convirtiéndolas en objetos, las clases de datos no son la mejor opción. </p><br><p>  Pero espera, puedes congelar una clase de datos como una tupla.  Tal vez entonces será más fácil? </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass(frozen=True) class PetFrozen: type: str name: str age: int frank_frozen = PetFrozen(type="pigeon", name="", age=3) &gt;&gt;&gt; objsize.get_deep_size(frank_frozen) 335</span></span></code> </pre> <br><p>  Por desgracia  Incluso congelado, seguía siendo un objeto pesado ordinario con un diccionario de atributos.  Entonces, si necesita objetos inmutables ligeros (que también se pueden usar como tuplas regulares), namedtuple sigue siendo la mejor opción. </p><br><p>  ⌘ ⌘ ⌘ </p><br><p>  Realmente me gusta la tupla nombrada: </p><br><ul><li>  honesto iterable, </li><li>  declaración de tipo dinámico </li><li>  Acceso a atributos con nombre </li><li>  Ligero e inmutable. </li></ul><br><p>  Y al mismo tiempo se implementa en 150 líneas de código.  ¿Qué más se necesita para la felicidad? </p><br><p>  <em>Si desea saber más sobre la biblioteca estándar de Python, suscríbase al canal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@ohmypy</a></em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438162/">https://habr.com/ru/post/438162/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438146/index.html">Ponemos las líneas en los parámetros de la plantilla.</a></li>
<li><a href="../438148/index.html">Google debe dividirse</a></li>
<li><a href="../438150/index.html">Cómo hacer un lote de zapatillas únicas en China</a></li>
<li><a href="../438152/index.html">"Puedo contarte sobre el dolor que cada desarrollador de iOS tiene en el culo" - 10 preguntas para un desarrollador, episodio 2</a></li>
<li><a href="../438158/index.html">Los corredores de datos de EE. UU. Venden datos de ubicación sin el consentimiento del usuario: su trabajo estará regulado</a></li>
<li><a href="../438164/index.html">Genética y pollos: proteína CSF1-Fc humana en proteína de huevo</a></li>
<li><a href="../438166/index.html">Interacción entre un sitio en un navegador y un programa que se ejecuta localmente</a></li>
<li><a href="../438168/index.html">Cómo romper una cámara cara para que tu esposa no te mate</a></li>
<li><a href="../438170/index.html">Premio que lleva el nombre de Ilya Segalovich. Historia sobre informática y publicaciones de lanzamiento</a></li>
<li><a href="../438172/index.html">Apple no puede trasladar la producción de sus dispositivos a los EE. UU.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>