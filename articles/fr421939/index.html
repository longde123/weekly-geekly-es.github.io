<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèº üë∂üèº üôÜüèº Utilisation de SQL dans Rails ‚ö°Ô∏è üë¥ üôä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Premi√®rement, l'article n'est pas sur la fa√ßon dont j'aime les rails, et deuxi√®mement, l'article n'est pas sur la fa√ßon dont je les d√©teste. Ils peuve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation de SQL dans Rails</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421939/"><p>  Premi√®rement, l'article n'est pas sur la fa√ßon dont j'aime les rails, et deuxi√®mement, l'article n'est pas sur la fa√ßon dont je les d√©teste.  Ils peuvent √™tre trait√©s de mani√®res compl√®tement diff√©rentes et ils ne s'am√©lioreront que si vous les changez.  Et ils ne peuvent empirer que s'ils commencent √† changer.  Eh bien, en g√©n√©ral, je vous ai pr√©venu, mais vous m'avez compris. </p><br><p> L'un des principaux concepts d'ActiveRecord est que la base de donn√©es est assez utilitaire et peut √™tre modifi√©e.  Eh bien, vous √™tes assis l√†, en train d'√©crire vos mod√®les en utilisant MySQL, et soudain vous lisez quelque part que vous pouvez prendre MySQL √† la place et le remplacer par MongoDB.  Eh bien, pas si radical, mais, disons, sur PostgreSQL, vous pourriez avoir des raisons de remplacer MySQL.  Ou vice versa, je n'ai rien contre MySQL.  Ici, ActiveRecord pr√©tend vous faciliter la t√¢che, soi-disant √©tendues, les filtres avant / apr√®s et les associations sont suffisamment abstraits pour ne pas vous soucier de g√©n√©rer des requ√™tes de base de donn√©es et de prendre soin de la logique de l'application.  Au lieu de <code>WHERE is_archived = TRUE</code> vous √™tes heureux d'√©crire <code>where(is_archived: true)</code> et ActiveRecord fera tout pour vous.  Tous les exemples seront traduits pour PostgreSQL, pas pour MySQL, donc les utilisateurs de MySQL devront inventer leur propre v√©lo. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e53/ff1/cfc/e53ff1cfc747b1a79b89c8139cd1d196.gif"></p><br><p>  Mais peu importe comment!  En pratique, il s'av√®re que cette couche d'abstraction est compl√®tement remplie de trous, comme un creux de l'histoire du poisson d'or.  Et que de nombreuses fonctionnalit√©s de base ne peuvent pas √™tre utilis√©es, telles que la comparaison de dates ou l'utilisation de tableaux.  Et vous obtenez des √©tendues avec forc√© <code>where("#{quoted_table_name}.finished_at &gt;= ?", Date.current)</code> ou <code>where("#{quoted_table_name}.other_ids &lt;@ ARRAY[?]", ids)</code> .  √Ä quoi ActiveRecord donne une r√©ponse compl√®tement consciente et logique: ne l'utilisez pas.  Au lieu de tableaux, utilisez la connexion habtm, et si vous avez besoin de comparer des dates, vivez avec.  Oui, et Dieu vous interdit de manquer <code>quoted_table_name</code> dans une telle port√©e - le premier <code>includes</code> ou <code>joins</code> mettra tout √† sa place.  Il est plus facile partout et toujours d'√©crire, pour ne pas renverser la main. </p><a name="habracut"></a><br><p>  Eh bien, bien s√ªr, d√®s que vous d√©cidez d'interf√©rer avec ActiveRecord ici, il n'y aura plus de retour en arri√®re.  Non pas qu'il n'y ait aucune chance, m√™me un espoir fantomatique pour une transition sans douleur vers une autre base de donn√©es.  Il sera beaucoup plus facile d'imprimer et de graver ce code source.  Et bien s√ªr, il n'y a aucune autre raison de ne pas utiliser les fonctionnalit√©s de base de donn√©es suppl√©mentaires dans votre application.  Utilisez sur la sant√© et forcez les autres! </p><br><p>  Et lorsqu'il s'av√®re que vos √©tendues dans le dossier des mod√®les comprennent plus de la moiti√© de ces fonctionnalit√©s suppl√©mentaires, il est √©vident qu'ActiveRecord n'est qu'un shell pratique pour int√©grer un morceau de code avec des √©tiquettes avec un autre morceau de code.  Et les √©tendues, comme <code>where(is_archived: true).joins(:sprint).merge(Sprint.archived)</code> , fonctionneront bien et les combiner ne sera pas plus difficile que de faire des ≈ìufs brouill√©s, non? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/618/8a9/0b1/6188a90b173dcc6238fa5fa649ee3227.gif"></p><br><p>  La prochaine √©tape sera la d√©normalisation.  Non, la d√©normalisation, pour ainsi dire, n'a toujours pas disparu, mais le soin en incombait aux puissantes √©paules de Rails et d'ActiveRecord, et vous savez que ces deux gars ne diff√©raient pas en rapidit√© et en asc√©tisme des besoins en ressources.  Disons <code>counter_cache: true</code> est la premi√®re √©tape vers la d√©normalisation, car <code>COUNT(*) AS sprints_count</code> ne vous permettra pas de faire ActiveRecord (vous ne voulez pas changer <code>select()</code> , non?).  Et <code>counter_cache</code> pas loin d'√™tre parfait, et dans certains cas, il peut y avoir une d√©synchronisation du montant r√©el de celui mis en cache.  Non critique, bien s√ªr, mais d√©sagr√©able.  Et ce n'est que le premier candidat √† s'installer dans la base de donn√©es et √† ne pas charger la t√™te d√©j√† charg√©e de la machine √† rubis.  Juste quelques d√©clencheurs et vous avez termin√©!  Tout d'abord, lors de la suppression et de l'ajout d'un nouvel enregistrement √† la plaque A, vous devez compter le nombre d'enregistrements dans la plaque B et c'est tout, non?  Eh bien, lors de l'√©dition, bien s√ªr, si <code>foreign_key</code> chang√©, car la <code>UPDATE B SET a_id = $1 WHERE id = $2</code> cassera counter_cache pour l'ancien A et le nouveau. </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> update_#{parent_table}_#{child_table}_counter_on_insert() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">UPDATE</span></span></span><span class="pgsql"> #{parent_table} </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SET</span></span></span><span class="pgsql"> #{counter_column} = COALESCE((</span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> COUNT(id) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> #{child_table} </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">GROUP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> #{foreign_column} </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">HAVING</span></span></span><span class="pgsql"> #{foreign_column} = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.#{foreign_column}), </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql">) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> (#{parent_table}.id = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.#{foreign_column}); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">NULL</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql;</code> </pre><br><p>  Le prochain chemin d'acc√®s √† la base de donn√©es sera li√© √† la date-heure.  Et pour commencer, servons simplement les champs <code>created_at</code> et <code>updated_at</code> dans la base de donn√©es, heureusement, c'est beaucoup plus simple.  Param√®tres par d√©faut du premier ensemble: </p><br><pre> <code class="hljs ruby"> change_column_default <span class="hljs-symbol"><span class="hljs-symbol">:table_name</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:created_at</span></span>, -&gt; { <span class="hljs-string"><span class="hljs-string">'CURRENT_TIMESTAMP'</span></span> } change_column_default <span class="hljs-symbol"><span class="hljs-symbol">:table_name</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:updated_at</span></span>, -&gt; { <span class="hljs-string"><span class="hljs-string">'CURRENT_TIMESTAMP'</span></span> }</code> </pre> <br><p>  Et pour le faire imm√©diatement partout, vous pouvez organiser un cycle pour toutes les plaques o√π se trouvent ces champs.  Outre les <code>ar_internal_metadata</code> <code>schema_migrations</code> et <code>ar_internal_metadata</code> , bien s√ªr: </p><br><pre> <code class="hljs matlab"> (tables - <span class="hljs-comment"><span class="hljs-comment">%w(schema_migrations ar_internal_metadata)).each { ... }</span></span></code> </pre> <br><p>  Voil√†, maintenant la valeur par d√©faut de ces tables sera exactement ce dont nous avons besoin.  Et il est maintenant temps de s'assurer que les rails ne touchent pas ces champs.  Cela se fait avec deux boulons aux bons endroits.  Et oui, il y a une option dans la mise en place du cadre qui en est responsable: </p><br><pre> <code class="hljs lua">Rails.application.<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.active_record.record_timestamps = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><p>  Par cons√©quent, l'√©tape suivante consiste √† mettre √† jour le champ <code>updated_at</code> au moment o√π l'enregistrement est mis √† jour.  C'est simple: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> touch_for_#{<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span>}_on_update() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">CURRENT_TIMESTAMP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.updated_at; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql;</code> </pre> <br><p>  Vous devez maintenant vous d√©barrasser compl√®tement du <code>touch: true</code> dans les mod√®les.  Cette chose est tr√®s similaire √† la cible dans le tiret - √©galement compl√®tement trou√©e.  Et je n‚Äôexpliquerai m√™me pas pourquoi, car vous connaissez d√©j√† tous ces cas.  Ce n'est pas beaucoup plus compliqu√©, il vous suffit de mettre √† jour update_at non seulement pour vous-m√™me: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> touch_for_#{<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span>}_on_update() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">UPDATE</span></span></span><span class="pgsql"> foreign_table_name </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SET</span></span></span><span class="pgsql"> updated_at = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">CURRENT_TIMESTAMP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> id = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.foreign_column_name; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">CURRENT_TIMESTAMP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.updated_at; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql;</code> </pre> <br><p>  Bien s√ªr, la cha√Æne d'appels de ces d√©clencheurs fera une action inutile, mais dans les postgres du m√©canisme sain, les d√©clencheurs sont invoqu√©s sans changer l'enregistrement lui-m√™me.  Vous pouvez essayer de faire <code>SET title = title</code> , mais cela ne sort pas mieux que <code>SET updated_at = CURRENT_TIMESTAMP</code> . </p><br><p>  Exactement le m√™me d√©clencheur sera sur l'insert, seule la mise √† jour <code>updated_at</code> pas n√©cessaire: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> touch_for_#{<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span>}_on_insert() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">UPDATE</span></span></span><span class="pgsql"> foreign_table_name </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SET</span></span></span><span class="pgsql"> updated_at = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">CURRENT_TIMESTAMP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> id = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.foreign_column_name; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql;</code> </pre> <br><p>  Bien s√ªr, vous pouvez essayer d'√©crire cela avec une seule fonction, en ajoutant une v√©rification de l'√©v√©nement actuel juste √† l'int√©rieur du d√©clencheur, similaire √† <code>IF TG_OP = 'UPDATE' THEN</code> , mais il est pr√©f√©rable de rendre tous les d√©clencheurs aussi simples que possible pour r√©duire la probabilit√© d'une erreur. </p><br><p>  Vous voudrez peut-√™tre en quelque sorte automatiser la g√©n√©ration de ces d√©clencheurs, puis vous devrez probablement trouver toutes les relations √©trang√®res entre la table actuelle et les autres.  Vous pouvez facilement le faire avec cette requ√™te: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ccu.<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> foreign_table_name, kcu.<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> information_schema.table_constraints <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tc <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> information_schema.key_column_usage <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> kcu <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tc.<span class="hljs-built_in"><span class="hljs-built_in">constraint_name</span></span> = kcu.<span class="hljs-built_in"><span class="hljs-built_in">constraint_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> information_schema.constraint_column_usage <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ccu <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ccu.<span class="hljs-built_in"><span class="hljs-built_in">constraint_name</span></span> = tc.<span class="hljs-built_in"><span class="hljs-built_in">constraint_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> constraint_type = <span class="hljs-string"><span class="hljs-string">'FOREIGN KEY'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tc.<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span> = <span class="hljs-string"><span class="hljs-string">'#{table_name}'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ccu.<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span>;</code> </pre><br><p>  Un autre conseil tr√®s utile.  Appelez les d√©clencheurs de la m√™me mani√®re pour pouvoir v√©rifier la pr√©sence ou l'absence de ce qui est requis par une demande, par exemple, cette demande trouvera tous les d√©clencheurs √† insertion tactile: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> routine_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> information_schema.<span class="hljs-keyword"><span class="hljs-keyword">routines</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> routine_name <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'touch_for_%_on_insert'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> routine_type =<span class="hljs-string"><span class="hljs-string">'FUNCTION'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> specific_schema=<span class="hljs-string"><span class="hljs-string">'public'</span></span>;</code> </pre> <br><p>  Et enfin, le pire reste.  Le fait est que les rails ne sont pas con√ßus pour au moins une sorte de base de donn√©es intelligente, et ils se moquaient vraiment du fait qu'au moins quelque chose d'autre que le champ <code>id</code> pouvait changer dans la base de donn√©es, et cela uniquement lorsqu'ils √©taient ins√©r√©s.  Par cons√©quent, il n'y a pas de m√©canisme sain pour ajouter <code>RETURNING updated_at</code> pour mettre √† jour les demandes, il n'y en a pas, vous devrez plonger √† l'int√©rieur de Rails jusqu'aux oreilles. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5e2/741/5b9/5e27415b90ea63490670e7d4e2e4e758.jpg"></p><br><p>  Mankipatch s'est av√©r√© ne pas √™tre tr√®s soign√©, mais tout d'abord l'objectif √©tait d'endommager le moins possible le travail actuel du cadre. </p><br><div class="spoiler">  <b class="spoiler_title">Je vais l'amener compl√®tement</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">module ActiveRecord module Persistence # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/persistence.rb#L729-L741 def _create_record(attribute_names = self.attribute_names) attribute_names &amp;= self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.column_names attributes_values = attributes_with_values_for_create(attribute_names) an_id, *affected_rows = self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>._insert_record(attributes_values).dup self.id ||= an_id <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.primary_key Hash[ApplicationRecord.custom_returning_columns(self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.quoted_table_name, :<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>).take(affected_rows.size).zip(affected_rows)].<span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>| public_send("#{column_name}=", self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.attribute_types[<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span>.to_s].deserialize(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> @new_record = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> yield(self) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> block_given? id <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> private :_create_record # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/persistence.rb#L710-L725 def _update_record(attribute_names = self.attribute_names) attribute_names &amp;= self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.column_names attribute_names = attributes_for_update(attribute_names) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> attribute_names.empty? affected_rows = [] @_trigger_update_callback = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> affected_rows = _update_row(attribute_names) @_trigger_update_callback = affected_rows.<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> Hash[ApplicationRecord.custom_returning_columns(self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.quoted_table_name, :<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>).take(affected_rows.size).zip(affected_rows)].<span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>| public_send("#{column_name}=", self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.attribute_types[<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span>.to_s].deserialize(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> yield(self) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> block_given? affected_rows.<span class="hljs-keyword"><span class="hljs-keyword">none</span></span>? ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> private :_update_record <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> module ConnectionAdapters module PostgreSQL module DatabaseStatements # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb#L93-L96 def exec_update(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> = nil, binds = []) execute_and_clear(sql_with_returning(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>), <span class="hljs-type"><span class="hljs-type">name</span></span>, binds) { |result| <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.wrap(result.<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>.first) } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb#L147-L152 def <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(arel, <span class="hljs-type"><span class="hljs-type">name</span></span> = nil, pk = nil, _id_value = nil, sequence_name = nil, binds = []) <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>, binds = to_sql_and_binds(arel, binds) exec_insert(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>, binds, pk, sequence_name).<span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>.first <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb#L98-L111 def sql_for_insert(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>, pk, id_value, sequence_name, binds) # :nodoc: table_ref = extract_table_ref_from_insert_sql(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pk.nil? # Extract the <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>. Yuck. pk = primary_key(table_ref) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> table_ref <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> returning_columns = quote_returning_column_names(table_ref, pk, :<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> returning_columns.<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> = "#{sql} RETURNING #{returning_columns.join(', ')}" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> super <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> original repo def quote_returning_column_names(table_ref, pk, action) returning_columns = [] returning_columns &lt;&lt; pk <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> suppress_composite_primary_key(pk) returning_columns += ApplicationRecord.custom_returning_columns(table_ref, action) returning_columns.map { |<span class="hljs-keyword"><span class="hljs-keyword">column</span></span>| quote_column_name(<span class="hljs-keyword"><span class="hljs-keyword">column</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> original repo def sql_with_returning(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) table_ref = extract_table_ref_from_update_sql(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) returning_columns = quote_returning_column_names(table_ref, nil, :<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> returning_columns.blank? "#{sql} RETURNING #{returning_columns.join(', ')}" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> original repo def extract_table_ref_from_update_sql(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>[/<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>\s("[A-Za-z0-9_."\[\]\s]+"|[A-Za-z0-9_."\[\]]+)\s*<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>/im] Regexp.last_match(<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;.strip <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  La chose la plus importante est qu'ici nous nous tournons vers <code>ApplicationRecord.custom_returning_columns</code> pour d√©couvrir quelles colonnes en plus d'id sont int√©ressantes pour nous.  Et cette m√©thode ressemble √† ceci: </p><br><pre> <code class="hljs vhdl"> class &lt;&lt; self def custom_returning_columns(table_ref, action) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ['<span class="hljs-string"><span class="hljs-string">"schema_migrations"</span></span>', '<span class="hljs-string"><span class="hljs-string">"ar_internal_metadata"</span></span>'].include?(table_ref) res = [] res &lt;&lt; :created_at <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == :create res &lt;&lt; :updated_at res += <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> table_ref <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> '<span class="hljs-string"><span class="hljs-string">"user_applications"</span></span>' [:api_token] <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> '<span class="hljs-string"><span class="hljs-string">"users"</span></span>' [:session_salt, :password_changed_at] # ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><hr><br><p>  Au lieu de conclusions, nous pouvons dire que la t√™te douloureuse de Rails est devenue un peu moins douloureuse.  <code>counter_cache</code> processus de <code>counter_cache</code> tels que <code>counter_cache</code> et <code>touch</code> <code>counter_cache</code> dans l'oubli, et dans le prochain article, nous pouvons penser √† quelque chose de plus global, comme la suppression des espaces suspendus, la validation des donn√©es, la suppression des donn√©es en cascade ou la suppression parano√Øaque.  Si vous avez aim√© cet article, bien s√ªr. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421939/">https://habr.com/ru/post/fr421939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421929/index.html">Un an avant le Brexit: la Grande-Bretagne r√©sout le probl√®me des p√©nuries de main-d'≈ìuvre gr√¢ce √† la robotique</a></li>
<li><a href="../fr421931/index.html">Impact de la protection Spectre, Meltdown et Foreshadow sur les performances de Linux 4.19</a></li>
<li><a href="../fr421933/index.html">L'√©tude du syst√®me de fichiers HDD du mod√®le DVR QCM-08DL</a></li>
<li><a href="../fr421935/index.html">Premi√®res impressions de la transition d'Ubuntu 16.04 LTS √† Ubuntu 18.04 LTS</a></li>
<li><a href="../fr421937/index.html">Smart city inside - un coup d'≈ìil sur Huawei</a></li>
<li><a href="../fr421945/index.html">Google et Mastercard concluent un accord secret pour suivre les achats dans les magasins</a></li>
<li><a href="../fr421947/index.html">Bienvenue sur Android Devs Meetup le 8 septembre</a></li>
<li><a href="../fr421949/index.html">Suicide Squad Comment nous recrutons les d√©veloppeurs juniors les plus f√©roces</a></li>
<li><a href="../fr421953/index.html">Summ3r 0f h4ck: stage d'√©t√© chez Digital Security</a></li>
<li><a href="../fr421955/index.html">Le S√©nat ne veut pas de robots distraits par la bi√®re. Et quoi d'autre √† √©crire vendredi?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>