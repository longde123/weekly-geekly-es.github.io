<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèæ ‚úäüèº üë¥ Types d√©pendants de Haskell: pourquoi l'avenir du d√©veloppement logiciel üéº üîú üöì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chez Serokell, nous sommes non seulement engag√©s dans des projets commerciaux, mais nous nous effor√ßons √©galement de changer le monde pour le mieux. P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Types d√©pendants de Haskell: pourquoi l'avenir du d√©veloppement logiciel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485174/"><p><img src="https://habrastorage.org/getpro/habr/post_images/fce/995/232/fce99523266b5bc548c3d1730c70b885.jpg"></p><br><p> Chez Serokell, nous sommes non seulement engag√©s dans des projets commerciaux, mais nous nous effor√ßons √©galement de changer le monde pour le mieux.  Par exemple, nous travaillons √† l'am√©lioration de l'outil principal de toutes les Haskelists - le Glasgow Haskell Compiler (GHC).  Nous nous sommes concentr√©s sur l'expansion du syst√®me de types sous l'influence des travaux de Richard Eisenberg, <a href="https://github.com/goldfirere/thesis/blob/master/built/thesis.pdf" rel="nofollow">"Dependent Types in Haskell: Theory and Practice"</a> . </p><br><p>  Dans <a href="https://serokell.io/blog/why-dependent-haskell" rel="nofollow">notre blog,</a> Vladislav a d√©j√† expliqu√© pourquoi Haskell manque de types d√©pendants et comment nous pr√©voyons de les ajouter.  Nous avons d√©cid√© de traduire ce post en russe afin que le plus de d√©veloppeurs possible puissent utiliser des types d√©pendants et apporter une contribution suppl√©mentaire au d√©veloppement de Haskell en tant que langue. </p><a name="habracut"></a><br><h1 id="tekuschee-polozhenie-del">  Situation actuelle </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6d3/260/bba/6d3260bbad59d047ba6f10b1fffd5383.jpg" alt="Algorithme de s√©lection du langage de programmation"></p><br><p>  Les types d√©pendants sont ce qui me manque le plus √† Haskell.  Voyons pourquoi.  Du code que nous voulons: </p><br><ul><li>  performances, c'est-√†-dire vitesse d'ex√©cution et faible consommation de m√©moire; </li><li>  maintenabilit√© et facilit√© de compr√©hension; </li><li>  exactitude garantie par la m√©thode de compilation. </li></ul><br><p>  Avec les technologies existantes, il est rarement possible d'atteindre les trois caract√©ristiques, mais avec la prise en charge des types d√©pendants de Haskell, la t√¢che est simplifi√©e. </p><br><h2 id="standartnyy-haskell-ergonomika--proizvoditelnost">  Norme Haskell: ergonomie + performance </h2><br><p>  Haskell est bas√© sur un syst√®me simple: un calcul lambda polymorphe avec des calculs paresseux, des types de donn√©es alg√©briques et des classes de types.  C'est cette combinaison de fonctionnalit√©s linguistiques qui nous permet d'√©crire du code √©l√©gant, pris en charge et en m√™me temps productif.  Pour √©tayer cette affirmation, nous comparons bri√®vement Haskell avec des langues plus populaires. </p><br><p>  Les langues avec un acc√®s m√©moire non s√©curis√©, comme C, entra√Ænent les erreurs et les vuln√©rabilit√©s les plus graves (par exemple, les d√©passements de m√©moire tampon, les fuites de m√©moire).  Parfois, ces langues sont n√©cessaires, mais le plus souvent, leur utilisation est une id√©e comme telle. </p><br><p>  Les langages d'acc√®s s√©curis√© √† la m√©moire forment deux groupes: ceux qui d√©pendent du garbage collector et Rust.  La rouille semble √™tre unique en ce qu'elle offre <a href="https://pcwalton.github.io/2013/05/20/safe-manual-memory-management.html" rel="nofollow">un acc√®s s√©curis√© √† la m√©moire sans r√©cup√©ration de place</a> .  Il n'y a √©galement plus de cyclone et d'autres langages de recherche pris en charge dans ce groupe.  Mais contrairement √† eux, Rust est en voie de devenir populaire.  L'inconv√©nient est que malgr√© la s√©curit√©, la gestion de la m√©moire de Rust n'est pas anodine et manuelle.  Dans les applications qui peuvent se permettre d'utiliser le garbage collector, il est pr√©f√©rable de consacrer du temps aux d√©veloppeurs sur d'autres t√¢ches. </p><br><p>  Il y a des langues qui restent avec les r√©cup√©rateurs, que nous allons diviser en deux cat√©gories en fonction de leur syst√®me de types. </p><br><p>  Les langages typ√©s dynamiquement (ou plut√¥t <a href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/" rel="nofollow">monotyp√©s</a> ), tels que JavaScript ou Clojure, ne fournissent pas d'analyse statique et ne peuvent donc pas fournir le m√™me niveau de confiance dans l'exactitude du code (et non, les tests ne peuvent pas remplacer les types - vous avez besoin des deux) !). </p><br><p>  Les langages typ√©s statiquement comme Java ou Go ont souvent un syst√®me de types tr√®s limit√©.  Cela oblige les programmeurs √† √©crire du code redondant et √† mettre des fonctionnalit√©s de langage non s√©curis√©es.  Par exemple, le manque de types g√©n√©riques dans Go vous oblige √† utiliser l' <a href="https://tour.golang.org/methods/14" rel="nofollow">interface {}</a> et le <a href="https://golang.org/ref/spec" rel="nofollow">cast lors de l'ex√©cution</a> .  Il n'y a pas non plus de s√©paration entre les calculs avec effets secondaires (entr√©e, sortie) et les calculs purs. </p><br><p>  Enfin, parmi les langues avec acc√®s s√©curis√© √† la m√©moire, un garbage collector et un syst√®me de type puissant, Haskell se distingue par la paresse.  <a href="https://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html" rel="nofollow">L'informatique paresseuse est</a> extr√™mement utile pour √©crire du code modulaire composable.  Ils permettent de d√©composer en d√©finitions auxiliaires toutes les parties d'expressions, y compris les constructions d√©finissant un flux de contr√¥le. </p><br><p>  Haskell semble √™tre un langage presque parfait jusqu'√† ce que vous r√©alisiez √† quel point il est loin de lib√©rer son plein potentiel en termes de v√©rification statique par rapport aux outils de preuve de th√©or√®me comme <a href="https://agda.readthedocs.io/en/latest/" rel="nofollow">Agda</a> . </p><br><p> Comme exemple simple de cas o√π le syst√®me de type Haskell n'est pas assez puissant, consid√©rons l'op√©rateur d' <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html" rel="nofollow">indexation de liste</a> de <code>Prelude</code> (ou l' <a href="http://hackage.haskell.org/package/primitive-0.6.4.0/docs/Data-Primitive-Array.html" rel="nofollow">indexation d'un tableau √†</a> partir d'un package <code>primitive</code> ): </p><br><pre> <code class="haskell hljs">(!!) :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a indexArray :: <span class="hljs-type"><span class="hljs-type">Array</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a</code> </pre> <br><p>  Rien dans ces signatures de type ne refl√®te l'exigence que l'index soit non n√©gatif et inf√©rieur √† la longueur de la collection.  Pour les logiciels ayant des exigences de fiabilit√© √©lev√©es, cela est inacceptable. </p><br><h2 id="agda-ergonomika--korrektnost">  Agda: ergonomie + justesse </h2><br><p>  Les moyens de preuve de th√©or√®mes (par exemple, <a href="https://coq.inria.fr/" rel="nofollow">Coq</a> ) sont des outils logiciels qui permettent d'utiliser un ordinateur pour d√©velopper des preuves formelles de th√©or√®mes math√©matiques.  Pour un math√©maticien, utiliser de tels outils, c'est comme √©crire des preuves sur papier.  La diff√©rence dans la rigueur sans pr√©c√©dent requise par un ordinateur pour √©tablir la validit√© de ces preuves. </p><br><p>  Pour le programmeur, cependant, les moyens de prouver les th√©or√®mes ne sont pas si diff√©rents du compilateur pour le langage de programmation √©sot√©rique avec un syst√®me de type incroyable (et √©ventuellement un environnement de d√©veloppement int√©gr√©), et m√©diocre (ou m√™me absent) tout le reste.  Un moyen de prouver les th√©or√®mes est, en fait, les langages de programmation, dont les auteurs ont pass√© tout leur temps √† d√©velopper un syst√®me de typage et ont oubli√© que les programmes doivent encore √™tre ex√©cut√©s. </p><br><p>  Le r√™ve ch√©ri des d√©veloppeurs de logiciels v√©rifi√©s est un moyen de prouver les th√©or√®mes, ce qui serait un bon langage de programmation avec un g√©n√©rateur de code et un runtime de haute qualit√©.  Dans ce sens, notamment les cr√©ateurs d' <a href="https://www.idris-lang.org/" rel="nofollow">Idris ont</a> exp√©riment√©.  Mais c'est un langage avec des calculs (√©nerg√©tiques) stricts, et sa mise en ≈ìuvre pour le moment n'est pas stable. </p><br><p>  Parmi tous les moyens de prouver les th√©or√®mes, les Agda Haskellists aiment surtout.  √Ä bien des √©gards, il est similaire √† Haskell, mais avec un syst√®me de type plus puissant.  Chez Serokell, nous l'utilisons pour prouver les diff√©rentes propri√©t√©s de nos programmes.  Ma coll√®gue Dania Rogozin a √©crit une <a href="https://serokell.io/blog/2018/11/14/logical-background" rel="nofollow">s√©rie d'articles</a> √† ce sujet. </p><br><p>  Voici un type de fonction de <a href="" rel="nofollow">recherche</a> similaire √† l'op√©rateur Haskell <code>(!!)</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lookup</span></span> : ‚àÄ (xs : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí <span class="hljs-type"><span class="hljs-type">Fin</span></span> (length xs) ‚Üí <span class="hljs-type"><span class="hljs-type">A</span></span></code> </pre> <br><p>  Le premier param√®tre ici est de type <code>List A</code> , ce qui correspond √† <code>[a]</code> dans Haskell.  Cependant, nous lui donnons le nom <code>xs</code> pour lui faire r√©f√©rence pour le reste de la signature de type.  Dans Haskell, nous pouvons acc√©der aux arguments de fonction uniquement dans le corps de la fonction au niveau du terme: </p><br><pre> <code class="haskell hljs">(!!) :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a <span class="hljs-comment"><span class="hljs-comment">--   xs  (!!) = \xs i -&gt; ... --   xs </span></span></code> </pre> <br><p>  Mais dans Agda, nous pouvons faire r√©f√©rence √† cette valeur <code>xs</code> au niveau du type, ce que nous faisons dans le deuxi√®me param√®tre de <code>lookup</code> , <code>Fin (length xs)</code> .  Une fonction qui fait r√©f√©rence √† son param√®tre au niveau du type est appel√©e <em>fonction d√©pendante</em> et est un exemple de types d√©pendants. </p><br><p>  Le deuxi√®me param√®tre dans la <code>lookup</code> est de type <code>Fin n</code> pour <code>n ~ length xs</code> .  Une valeur de type <code>Fin n</code> correspond √† un nombre dans la plage <code>[0, n)</code> , donc <code>Fin (length xs)</code> est un nombre non n√©gatif inf√©rieur √† la longueur de la liste d'entr√©e.  C'est exactement ce dont nous avons besoin pour pr√©senter un index valide d'un √©l√©ment de liste.  En gros, la <code>lookup ["x","y","z"] 2</code> passera la v√©rification de type, mais la <code>lookup ["x","y","z"] 42</code> √©chouera. </p><br><p>  Quand il s'agit d'ex√©cuter des programmes Agda, nous pouvons les compiler dans Haskell en utilisant le <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php%3Fn%3DDocs.MAlonzo" rel="nofollow">backend</a> MAlonzo.  Mais les performances du code g√©n√©r√© ne seront pas satisfaisantes.  Ce n'est pas la faute de MAlonzo: il doit ins√©rer de nombreux <code>unsafeCoerce</code> pour que le GHC <code>unsafeCoerce</code> code d√©j√† v√©rifi√© par Agda.  Mais le m√™me <code>unsafeCoerce</code> <a href="https://dspace.library.uu.nl/bitstream/handle/1874/357868/3800296.pdf" rel="nofollow">r√©duit les performances</a> <em>(suite √† la discussion de cet article, il s'est av√©r√© que les probl√®mes de performances peuvent avoir √©t√© caus√©s par d'autres raisons - note de l'auteur)</em> . </p><br><p>  Cela nous place dans une position difficile: nous devons utiliser Agda pour la mod√©lisation et la v√©rification formelle, puis r√©impl√©menter la m√™me fonctionnalit√© sur Haskell.  Avec cette organisation des workflows, notre code Agda agit comme une sp√©cification v√©rifi√©e par ordinateur.  C'est mieux que la sp√©cification en langage naturel, mais loin d'√™tre id√©al.  Le but est que si le code est compil√©, il fonctionnera conform√©ment √† la sp√©cification. </p><br><h2 id="haskell-s-rasshireniyami-korrektnost--proizvoditelnost">  Haskell avec extensions: exactitude + performance </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/954/0e8/735/9540e8735ab539e67787046735ee5789.jpg"></p><br><p>  Visant des garanties statiques de langues avec des types d√©pendants, GHC a parcouru un long chemin.  Des extensions y ont √©t√© ajout√©es pour augmenter l'expressivit√© du syst√®me de typage.  J'ai commenc√© √† utiliser Haskell lorsque GHC 7.4 √©tait la derni√®re version du compilateur.  M√™me alors, il avait les principales extensions pour la programmation avanc√©e au niveau du type: <code>RankNTypes</code> , <code>GADTs</code> , <code>TypeFamilies</code> , <code>DataKinds</code> et <code>PolyKinds</code> . </p><br><p>  N√©anmoins, il n'y a toujours pas de types d√©pendants √† part enti√®re dans Haskell: ni fonctions d√©pendantes (types Œ†) ni paires d√©pendantes (types Œ£).  D'un autre c√¥t√©, au moins nous avons un encodage pour eux! </p><br><p>  Les pratiques actuelles sont les suivantes: </p><br><ul><li>  encoder les fonctions de niveau type en tant que familles de types priv√©es </li><li>  utiliser la fonctionnalisation pour activer les fonctions non satur√©es, </li><li>  combler l'√©cart entre les termes et les types √† l'aide de types uniques. </li></ul><br><p>  Cela conduit √† une quantit√© importante de code redondant, mais la biblioth√®que <code>singletons</code> automatise sa g√©n√©ration via Template Haskell. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/003/56f/e2a/00356fe2af43f034df850dbb556fb82f.jpg"></p><br><p>  Ainsi, les plus audacieux et les plus d√©cisifs peuvent coder des types d√©pendants en Haskell en ce moment.  A titre de d√©monstration, voici une impl√©mentation de la fonction de <code>lookup</code> similaire √† la variante sur Agda: </p><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# OPTIONS -Wall -Wno-unticked-promoted-constructors -Wno-missing-signatures #-}</span></span> <span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE LambdaCase, DataKinds, PolyKinds, TypeFamilies, GADTs, ScopedTypeVariables, EmptyCase, UndecidableInstances, TypeSynonymInstances, FlexibleInstances, TypeApplications, TemplateHaskell #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> ListLookup <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Singletons.TH <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Singletons.Prelude singletons [d| data N = Z | SN len :: [a] -&gt; N len [] = Z len (<span class="hljs-title"><span class="hljs-title">_</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = S (<span class="hljs-title"><span class="hljs-title">len</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) |] data Fin n where FZ :: Fin (<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) FS :: Fin n -&gt; Fin (<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) lookupS :: SingKind a =&gt; SList (<span class="hljs-title"><span class="hljs-title">xs</span></span> :: [<span class="hljs-title"><span class="hljs-title">a</span></span>]) -&gt; Fin (<span class="hljs-type"><span class="hljs-type">Len</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) -&gt; Demote a lookupS SNil = \case{} lookupS (<span class="hljs-type"><span class="hljs-type">SCons</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) = \case FZ -&gt; fromSing x FS i' -&gt; lookupS xs i'</code> </pre> <br><p>  Et voici une session GHCi montrant que lookupS rejette en effet les index trop volumineux: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">GHCi</span></span>, version <span class="hljs-number"><span class="hljs-number">8.6</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>: http://www.haskell.org/ghc/ :? for help [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-type"><span class="hljs-type">Compiling</span></span> <span class="hljs-type"><span class="hljs-type">ListLookup</span></span> ( <span class="hljs-type"><span class="hljs-type">ListLookup</span></span>.hs, interpreted ) <span class="hljs-type"><span class="hljs-type">Ok</span></span>, one <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> loaded. *ListLookup&gt; :set -XTypeApplications -XDataKinds *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) FZ "x" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>) "y" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)) "z" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>))) &lt;interactive&gt;:5:34: error: ‚Ä¢ Couldn't match type ''S n0' with ''Z' Expected type: Fin (<span class="hljs-type"><span class="hljs-type">Len</span></span> '["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) Actual type: Fin ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n0</span></span>)))) ‚Ä¢ In the second argument of 'lookupS', namely '(<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)))' In the expression: lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>))) In an equation for 'it': it = lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)))</code> </pre> <br><p>  Cet exemple montre que la faisabilit√© ne signifie pas pratique.  Je suis heureux que Haskell ait des capacit√©s linguistiques pour impl√©menter des <code>lookupS</code> , mais en m√™me temps je suis pr√©occup√© par la complexit√© inutile qui se pose.  En dehors des projets de recherche, je ne recommanderais pas un tel style de code. </p><br><p>  Dans ce cas particulier, nous pourrions obtenir le m√™me r√©sultat avec moins de complexit√© en utilisant des vecteurs index√©s en longueur.  Cependant, la traduction de code directe d'Agda r√©v√®le mieux les probl√®mes que vous devez rencontrer dans d'autres circonstances. </p><br><p>  En voici quelques uns: </p><br><ul><li>  La relation de typage <code>a :: t</code> et la relation de destination de la forme <code>t :: k</code> diff√©rentes.  <code>5 :: Integer</code> est vrai en termes, mais pas en types.  <code>"hi" :: Symbol</code> est vrai dans les types, mais pas dans les termes.  Cela n√©cessite la <code>Demote</code> types de <code>Demote</code> pour mapper les vues et les types. </li><li>  La biblioth√®que standard utilise <code>Int</code> comme repr√©sentation des index de liste (et les <code>singletons</code> utilisent <code>Nat</code> dans les d√©finitions √©lev√©es).  <code>Int</code> et <code>Nat</code> sont des types non inductifs.  Bien qu'ils soient plus efficaces que le codage unaire des nombres naturels, ils ne fonctionnent pas tr√®s bien avec les d√©finitions inductives telles que <code>Fin</code> ou <code>lookupS</code> .  Pour cette raison, nous red√©finissons la <code>length</code> en <code>len</code> . </li><li>  Haskell n'a pas de m√©canismes int√©gr√©s pour √©lever les fonctions au niveau des types.  <code>singletons</code> codent en tant que familles de types priv√©s et appliquent une fonctionnalisation pour contourner le manque d'utilisation partielle des familles de types.  Cet encodage est compliqu√©.  De plus, nous avons d√ª mettre la d√©finition de <code>len</code> dans une citation de Template Haskell afin que les <code>singletons</code> g√©n√®rent son homologue au niveau du type, <code>Len</code> . </li><li>  Il n'y a pas de fonctions d√©pendantes int√©gr√©es.  Il faut utiliser des <a href="https://repository.brynmawr.edu/cgi/viewcontent.cgi%3Farticle%3D1009%26context%3Dcompsci_pubs" rel="nofollow">types d'unit√©s</a> pour combler l'√©cart entre les termes et les types.  Au lieu de la liste habituelle, nous passons le <code>SList</code> √† l'entr√©e <code>lookupS</code> .  Par cons√©quent, nous devons garder √† l'esprit plusieurs d√©finitions de listes √† la fois.  Cela entra√Æne √©galement des frais g√©n√©raux lors de l'ex√©cution du programme.  Ils r√©sultent de la conversion entre des valeurs ordinaires et des valeurs de types d'unit√©s ( <code>toSing</code> , <code>fromSing</code> ) et du transfert de la proc√©dure de conversion (restriction <code>SingKind</code> ). </li></ul><br><p>  L'inconv√©nient est le moindre probl√®me.  Pire encore, ces fonctionnalit√©s linguistiques ne sont pas fiables.  Par exemple, j'ai signal√© le probl√®me <a href="https://gitlab.haskell.org/ghc/ghc/issues/12564" rel="nofollow"># 12564</a> en 2016, et il y a aussi le <a href="https://gitlab.haskell.org/ghc/ghc/issues/12088" rel="nofollow"># 12088 de</a> la m√™me ann√©e.  Ces deux probl√®mes entravent la mise en ≈ìuvre de programmes plus avanc√©s que les exemples de manuels (tels que les listes d'indexation).  Ces bogues GHC ne sont toujours pas corrig√©s, et la raison, il me semble, est que les d√©veloppeurs n'ont tout simplement pas assez de temps.  Le nombre de personnes travaillant activement sur le GHC est √©tonnamment faible, donc certaines choses ne se d√©placent pas. </p><br><h2 id="rezyume">  R√©sum√© </h2><br><p>  J'ai mentionn√© plus t√¥t que nous voulons les trois propri√©t√©s du code, voici donc un tableau illustrant l'√©tat actuel des choses: </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Haskell standard </th><th>  Agda </th><th>  Haskell avec extensions </th></tr></thead><tbody><tr><td>  Ergonomie et maintenabilit√© </td><td>  + </td><td>  + </td><td>  - </td></tr><tr><td>  Performances </td><td>  + </td><td>  - </td><td>  + </td></tr><tr><td>  Exactitude garantie par la m√©thode de r√©daction </td><td>  - </td><td>  + </td><td>  + </td></tr></tbody></table></div><br><h1 id="svetloe-buduschee">  Un avenir radieux </h1><br><p>  Des trois options disponibles, chacune a ses inconv√©nients.  Cependant, nous pouvons les corriger: </p><br><ul><li>  Prenez le Haskell standard et ajoutez directement des types d√©pendants au lieu d'un codage g√™nant via des <code>singletons</code> .  (Plus facile √† dire qu'√† faire.) </li><li>  Prenez Agda et impl√©mentez un g√©n√©rateur de code efficace et RTS pour cela.  (Plus facile √† dire qu'√† faire.) </li><li>  Prenez Haskell avec des extensions, corrigez des bugs et continuez √† ajouter de nouvelles extensions pour simplifier le codage des types d√©pendants.  (Plus facile √† dire qu'√† faire.) </li></ul><br><p>  La bonne nouvelle est que les trois options convergent √† un moment donn√© (dans un sens).  Imaginez la plus petite extension du Haskell standard qui ajoute des types d√©pendants et vous permet donc de garantir l'exactitude du code par la fa√ßon dont il est √©crit.  Le code Agda peut √™tre compil√© (transpos√©) dans cette langue sans <code>unsafeCoerce</code> .  Et Haskell avec extensions est, en un sens, un prototype inachev√© de ce langage.  Quelque chose doit √™tre am√©lior√© et quelque chose doit √™tre supprim√©, mais en fin de compte, nous atteindrons le r√©sultat souhait√©. </p><br><h2 id="izbavlenie-ot-singletons">  D√©barrass√© des <code>singletons</code> </h2><br><p>  Un bon indicateur de progr√®s est la simplification de la biblioth√®que <code>singletons</code> .  Comme les types d√©pendants sont impl√©ment√©s dans Haskell, les solutions de contournement et la gestion sp√©ciale des cas sp√©ciaux impl√©ment√©s dans les <code>singletons</code> ne sont plus n√©cessaires.  En fin de compte, la n√©cessit√© de ce package dispara√Ætra compl√®tement.  Par exemple, en 2016, en utilisant l'extension <code>-XTypeInType</code> j'ai <a href="https://github.com/goldfirere/singletons/pull/148/files" rel="nofollow">supprim√© KProxy</a> de <code>SingKind</code> et <code>SomeSing</code> .  Ce changement a √©t√© rendu possible gr√¢ce √† l'union des types et des types.  Comparez les anciennes et les nouvelles d√©finitions: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kparam</span></span></span><span class="hljs-class"> ~ '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kparam</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam :: * fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> kparam </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kproxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Dans les anciennes d√©finitions, <code>k</code> appara√Æt exclusivement dans les positions de vue, √† droite des annotations de la forme <code>t :: k</code> .  Nous utilisons <code>kparam :: KProxy k</code> pour transf√©rer <code>k</code> vers les types. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k :: * fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k</span></span></code> </pre> <br><p>  Dans les nouvelles d√©finitions, <code>k</code> se d√©place librement entre les positions de vue et de type, nous n'avons donc plus besoin de <code>KProxy</code> .  La raison en est qu'√† partir de GHC 8.0, les types et les types entrent dans la m√™me cat√©gorie syntaxique. </p><br><p>  Il existe trois mondes compl√®tement s√©par√©s dans Haskell standard: termes, types et vues.  Si vous regardez le code source de GHC 7.10, vous pouvez voir un <a href="" rel="nofollow">analyseur</a> distinct pour les vues et une <a href="" rel="nofollow">v√©rification</a> distincte.  GHC 8.0 n'en a plus: l' <a href="" rel="nofollow">analyseur</a> et la <a href="" rel="nofollow">validation</a> des types et des vues sont courants. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d01/37e/387/d0137e3870470beb4b2aee56240926cf.jpg"></p><br><p>  Dans Haskell avec extensions, la vue est juste le r√¥le dans lequel le type est: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: <span class="hljs-type"><span class="hljs-type">T</span></span> z -&gt; ... <span class="hljs-comment"><span class="hljs-comment">-- 'z'   g :: T (a :: z) -&gt; ... -- 'z'   h :: T z -&gt; T (a :: z) -&gt; ... -- 'z'   ,  </span></span></code> </pre> <br><p>  Dans GHC 8.0‚Äì8.4, il y avait encore quelques diff√©rences entre la r√©solution de noms dans les types et les types.  Mais je les ai r√©duits √† GHC 8.6: j'ai cr√©√© l'extension <code>StarIsType</code> et introduit la fonctionnalit√© <code>PolyKinds</code> dans <code>PolyKinds</code> .  Les diff√©rences restantes, j'ai <a href="https://github.com/ghc/ghc/commit/8df24474d0194d28b8273c1539af05793156e23f" rel="nofollow">fait un avertissement</a> √† GHC 8.8, et <a href="https://github.com/ghc/ghc/commit/5bc195b1fe788e9a900a15fbe473967850517c3e" rel="nofollow">compl√®tement √©limin√©</a> dans GHC 8.10 </p><br><p>  Quelle est la prochaine √©tape?  Jetons un coup d'≈ìil √† <code>SingKind</code> dans la derni√®re version de <code>singletons</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class">) | r -&gt; k fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k</span></span></code> </pre> <br><p>  La <code>Demote</code> types <code>Demote</code> n√©cessaire pour tenir compte des √©carts entre la relation de typage <code>a :: t</code> et la relation de destination de la forme <code>t :: k</code> .  Le plus souvent (pour les types de donn√©es alg√©briques), <code>Demote</code> est un mappage d'identit√©: </p><br><ul><li> <code>type Demote Bool = Bool</code> </li> <li> <code>type Demote [a] = [Demote a]</code> </li> <li> <code>type Demote (Either ab) = Either (Demote a) (Demote b)</code> </li> </ul><br><p>  Par cons√©quent, <code>Demote (Either [Bool] Bool) = Either [Bool] Bool</code> .  Cette observation nous invite √† faire la simplification suivante: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fromSing :: <span class="hljs-type"><span class="hljs-type">Sing</span></span> (a :: k) -&gt; k toSing :: k -&gt; <span class="hljs-type"><span class="hljs-type">SomeSing</span></span> k</code> </pre> <br><p>  <code>Demote</code> pas n√©cessaire!  Et, en fait, cela fonctionnerait √† la fois avec le <code>Either [Bool] Bool</code> ou d'autres types de donn√©es alg√©briques.  En pratique, cependant, nous avons affaire √† des types de donn√©es non alg√©briques: <code>Integer,</code> <code>Natural</code> , caract√®re, <code>Text</code> , etc.  S'ils sont utilis√©s comme esp√®ces, ils ne sont pas peupl√©s: <code>1 :: Natural</code> est vrai au niveau des termes, mais pas au niveau des types.  Pour cette raison, nous avons affaire √† de telles d√©finitions: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Natural</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Symbol</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Text</span></span></span></span></code> </pre> <br><p>  La solution √† ce probl√®me est d'√©lever des types primitifs.  Par exemple, le <code>Text</code> d√©fini comme ceci: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | A space efficient, packed, unboxed Unicode text type. data Text = Text {-# UNPACK #-} !Array -- payload (Word16 elements) {-# UNPACK #-} !Int -- offset (units of Word16, not Char) {-# UNPACK #-} !Int -- length (units of Word16, not Char) data Array = Array ByteArray# data Int = I# Int#</span></span></code> </pre> <br><p>  Si nous √©levons correctement <code>ByteArray#</code> et <code>Int#</code> au niveau des types, nous pouvons utiliser <code>Text</code> au lieu de <code>Symbol</code> .  En faisant de m√™me avec <code>Natural</code> et √©ventuellement quelques autres types, vous pouvez vous d√©barrasser de <code>Demote</code> , non? </p><br><p>  H√©las, non.  Dans ce qui pr√©c√®de, j'ai ferm√© les yeux sur le type de donn√©es le plus important: les fonctions.  Ils ont √©galement une instance sp√©ciale de <code>Demote</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k1</span></span></span><span class="hljs-class"> ~&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k2</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k1 -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k2 </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> a ~&gt; b = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TyFun</span></span></span><span class="hljs-class"> ab -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TyFun</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span></span></code> </pre> <br><p>  <code>~&gt;</code> il s'agit d'un type avec lequel les fonctions de niveau type sont cod√©es en singletons en fonction des familles de types priv√©s et de la <a href="https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/" rel="nofollow">fonctionnalisation</a> . </p><br><p>  Au d√©but, cela peut sembler une bonne id√©e de combiner <code>~&gt;</code> et <code>-&gt;</code> , car les deux signifient le type (type) de la fonction.  Le probl√®me est que <code>-&gt;</code> en position de type et <code>-&gt;</code> en position d'affichage signifient des choses diff√©rentes.  Au niveau du terme, toutes les fonctions de <code>a</code> √† <code>b</code> sont de type <code>a -&gt; b</code> .  Au niveau du type, seuls les <em>constructeurs</em> de <code>a</code> √† <code>b</code> sont de type <code>a -&gt; b</code> , mais ils ne sont pas synonymes de types et pas de familles de types.  Afin de d√©duire les types, GHC suppose que <code>f ~ g</code> et <code>a ~ b</code> d√©coulent de <code>fa ~ gb</code> , ce qui est vrai pour les constructeurs, mais pas pour les fonctions - c'est pourquoi il y a une limitation. </p><br><p>  Par cons√©quent, afin d'√©lever les fonctions au niveau des types, mais pour pr√©server l'inf√©rence de type, nous devrons d√©placer les constructeurs vers un type distinct.  Nous l'appelons <code>a :-&gt; b</code> , car il sera vraiment vrai que <code>f ~ g</code> et <code>a ~ b</code> d√©coulent de <code>fa ~ gb</code> .  Les autres fonctions seront toujours de type <code>a -&gt; b</code> .  Par exemple, <code>Just :: a :-&gt; Maybe a</code> , mais en m√™me temps <code>isJust :: Maybe a -&gt; Bool</code> . </p><br><p>  Lorsque la <code>Demote</code> est termin√©e, la derni√®re √©tape consiste √† se d√©barrasser de <code>Sing</code> lui-m√™me.  Pour ce faire, nous avons besoin d'un nouveau quantificateur, un hybride entre <code>forall</code> et <code>-&gt;</code> .  Examinons de plus pr√®s la fonction isJust: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">isJust</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> a. <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> isJust = \x -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> _ -&gt; <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre> <br><p>  La fonction <code>isJust</code> param√©tr√©e avec le type <code>a</code> puis avec la valeur <code>x :: Maybe a</code> .  Ces deux param√®tres ont des propri√©t√©s diff√©rentes: </p><br><ul><li>  Explicitness.  Dans l' <code>isJust (Just "hello")</code> , nous passons explicitement <code>x = Just "hello"</code> et <code>a = String</code> est implicitement √©mis par le compilateur.  Dans Haskell moderne, nous pouvons √©galement forcer le passage explicite des deux param√®tres: <code>isJust @String (Just "hello")</code> . </li><li>  Pertinence  La valeur pass√©e √† l'entr√©e √† <code>isJust</code> dans le code sera transmise lors de l'ex√©cution du programme: nous effectuons une comparaison avec l'exemple en utilisant <code>case</code> pour v√©rifier s'il s'agit de <code>Nothing</code> ou <code>Just</code> .  Par cons√©quent, la valeur est consid√©r√©e comme pertinente.  Mais son type est effac√© et ne peut √™tre compar√© au motif: la fonction g√®re <code>Maybe Int</code> , <code>Maybe String</code> , <code>Maybe Bool</code> , etc.  Par cons√©quent, il est consid√©r√© comme non pertinent.  Cette propri√©t√© est √©galement appel√©e param√©tricit√©. </li><li>  D√©pendance.  En tout <code>forall a. t</code>  <code>forall a. t</code> , le type <code>t</code> peut faire r√©f√©rence √† <code>a</code> , et par cons√©quent, d√©pendre du particulier pass√© <code>a</code> .  Par exemple, <code>isJust @String</code> est de type <code>Maybe String -&gt; Bool</code> et <code>isJust @Int</code> est de type <code>Maybe Int -&gt; Bool</code> .  Cela signifie que <code>forall</code> est un quantificateur d√©pendant.  Remarquez la diff√©rence avec le param√®tre value: peu importe que nous <code>isJust Nothing</code> ou <code>isJust (Just ‚Ä¶)</code> , le type de r√©sultat est toujours <code>Bool</code> .  Par cons√©quent, <code>-&gt;</code> est un quantificateur ind√©pendant. </li></ul><br><p>  Pour supprimer <code>Sing</code> , nous avons besoin d'un quantificateur explicite et pertinent, comme <code>a -&gt; b</code> , et en m√™me temps d√©pendant, comme <code>forall (a :: k). t</code>  <code>forall (a :: k). t</code> .  Notons-le comme <code>foreach (a :: k) -&gt; t</code> .  Pour supprimer <code>SingI</code> , nous introduisons √©galement un quantificateur d√©pendant pertinent implicite, <code>foreach (a :: k). t</code>  <code>foreach (a :: k). t</code> .  En cons√©quence, les <code>singletons</code> ne seront pas n√©cessaires car nous venons d'ajouter des fonctions d√©pendantes au langage. </p><br><h2 id="kratkiy-vzglyad-na-haskell-s-zavisimymi-tipami">  Un bref aper√ßu de Haskell avec les types d√©pendants </h2><br><p>  Avec l'augmentation des fonctions au niveau des types et du quantificateur <code>foreach</code> , nous pouvons r√©√©crire les <code>lookupS</code> comme suit: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">N</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SN</span></span></span><span class="hljs-class"> len :: [a] -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">N</span></span></span><span class="hljs-class"> len [] = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class"> len (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> n where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FZ</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FS</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> n -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) lookupS :: foreach (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">]) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) -&gt; a lookupS [] = \case{} lookupS (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) = \case </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FZ</span></span></span><span class="hljs-class"> -&gt; x </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FS</span></span></span><span class="hljs-class"> i' -&gt; lookupS xs i'</span></span></code> </pre> <br><p>  En bref, le code ne fonctionne pas, mais les <code>singletons</code> assez bons pour masquer le code redondant.  Cependant, le nouveau code est beaucoup plus simple: il n'y a plus <code>Demote</code> , <code>SingKind</code> , <code>SList</code> , <code>SNil</code> , <code>SCons</code> , <code>fromSing</code> .  Il n'y a pas d'utilisation de <code>TemplateHaskell</code> , puisque maintenant nous pouvons appeler la fonction <code>len</code> directement au lieu de cr√©er la famille de type <code>Len</code> .  Les performances seront √©galement meilleures, car vous n'avez plus besoin de convertir depuis le <code>fromSing</code> . </p><br><p>  Nous devons encore red√©finir la <code>length</code> en <code>len</code> pour renvoyer un <code>N</code> d√©fini par induction au lieu de <code>Int</code> .  Ce probl√®me ne doit peut-√™tre pas √™tre consid√©r√© comme faisant partie de l'ajout de types d√©pendants √† Haskell, car Agda utilise √©galement un <code>N</code> d√©fini par induction dans la fonction de <code>lookup</code> . </p><br><p>  √Ä certains √©gards, Haskell avec des types d√©pendants est encore plus simple que Haskell standard.  Pourtant, en lui-m√™me, les types et les types sont combin√©s en une seule langue uniforme.  Je peux facilement imaginer √©crire du code dans ce style dans un projet commercial pour prouver formellement l'exactitude des composants cl√©s des applications.  De nombreuses biblioth√®ques Haskell peuvent fournir des interfaces plus s√©curis√©es sans la complexit√© des <code>singletons</code> . </p><br><p>  Ce ne sera pas facile √† r√©aliser.  Nous sommes confront√©s √† de nombreux probl√®mes d'ing√©nierie affectant tous les composants du GHC: un analyseur, la r√©solution de noms, la v√©rification de type et m√™me le langage Core.  Tout devra √™tre modifi√©, voire compl√®tement repens√©. </p><br><hr><br><h1 id="tezaurus">  Th√©saurus </h1><br><div class="scrollable-table"><table><tbody><tr><td>  <strong>Dur√©e</strong> <br></td><td>  <strong>La traduction</strong> <br></td><td>  <strong>Explication</strong> <br></td></tr><tr><td> correct by construction <br></td><td> ,       <br></td><td>  ,         (,   ),   . <br></td></tr><tr><td> memory unsafe <br></td><td>      <br></td><td>         ,    . <br></td></tr><tr><td> unityped <br></td><td>  <br></td><td> ,   Bob Harper     ,    .           . <br></td></tr><tr><td> boilerplate <br></td><td>   <br></td><td>       ,    -   . <br></td></tr><tr><td> generics <br></td><td>   <br></td><td>       . ,     ¬´¬ª  ¬´¬ª,     ,    &lt;&gt;  &lt;&gt;. <br></td></tr><tr><td> runtime cast <br></td><td>     <br></td><td>              . <br></td></tr><tr><td> effectful computation <br></td><td>     <br></td><td> ,          . <br></td></tr><tr><td> composable <br></td><td>  <br></td><td>  ,          . <br></td></tr><tr><td> control structures <br></td><td> ,    <br></td><td>  ,       . <br></td></tr><tr><td> proof assistant <br></td><td>    <br></td><td>       . <br></td></tr><tr><td> strict (eager) evaluation <br></td><td>  ()  <br></td><td>   ,         . <br></td></tr><tr><td> backend <br></td><td>  <br></td><td>  ,         . <br></td></tr><tr><td> singleton type <br></td><td>   <br></td><td> ,   ,       . <br></td></tr><tr><td> promoted definitions <br></td><td>   <br></td><td>    ,         . <br></td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485174/">https://habr.com/ru/post/fr485174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485158/index.html">Nikolay Vavilov. L'homme qui voulait nourrir le monde entier et est mort de faim dans une cellule de prison</a></li>
<li><a href="../fr485160/index.html">Qu'est-ce que je dans ACID ou une perspective diff√©rente</a></li>
<li><a href="../fr485162/index.html">Comment les commentaires de code ont √©volu√© des ann√©es 1940 √† 2020</a></li>
<li><a href="../fr485164/index.html">Transformers and Hate in Vancouver: How Anti-Plagiarism Rides the NeurIPS-2019</a></li>
<li><a href="../fr485172/index.html">Probl√®mes d'architecture dans les grands projets</a></li>
<li><a href="../fr485176/index.html">Six sch√©mas pour expliquer les concepts de gestion des produits</a></li>
<li><a href="../fr485178/index.html">M√©thodologie de reconstruction des b√¢timents perdus √† partir de photographies</a></li>
<li><a href="../fr485180/index.html">Avons-nous besoin d'un lac de donn√©es? Que faire de l'entrep√¥t de donn√©es?</a></li>
<li><a href="../fr485182/index.html">Sennheiser en 2020 - casque sans fil mis √† jour pour l'anniversaire</a></li>
<li><a href="../fr485184/index.html">R√©sultats du sondage par onglets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>