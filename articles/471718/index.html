<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöî üë®üèæ‚Äç‚úàÔ∏è üë©üèø‚Äçüè≠ SSEGWSW: Gateway de eventos enviados por el servidor por los trabajadores de servicios ‚úäüèæ üôÜüèΩ üë©üèΩ‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola 

 Mi nombre es Sasha y trabajo como arquitecto en Tinkoff Business. 

 En este art√≠culo, quiero hablar sobre c√≥mo superar la restricci√≥n de los ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SSEGWSW: Gateway de eventos enviados por el servidor por los trabajadores de servicios</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/471718/">  Hola <br><br>  Mi nombre es Sasha y trabajo como arquitecto en Tinkoff Business. <br><br>  En este art√≠culo, quiero hablar sobre c√≥mo superar la restricci√≥n de los navegadores sobre la cantidad de conexiones HTTP abiertas de larga duraci√≥n dentro del mismo dominio utilizando Service Worker. <br><br>  Si lo desea, puede omitir el fondo, la descripci√≥n del problema, buscar una soluci√≥n e inmediatamente proceder al resultado. <br><br><img src="https://habrastorage.org/webt/y0/bo/yc/y0boycn5hjiaplzub_5g7rviwpu.png" alt="SSEGWSW"><br><a name="habracut"></a><br><h3>  Antecedentes </h3><br>  Hab√≠a una vez en Tinkoff Business un chat que funcionaba en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Websocket</a> . <br><br>  Despu√©s de un tiempo, dej√≥ de encajar en el dise√±o de su cuenta personal, y en general estaba pidiendo mucho tiempo para reescribir de angular 1.6 a angular 2+.  Decid√≠ que era hora de comenzar a actualizarlo.  Un colega-defensor descubri√≥ que la interfaz de chat cambiar√° y sugiri√≥ al mismo tiempo rehacer la API, en particular: cambiar el transporte de websocket a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SSE (eventos enviados por el servidor)</a> .  Sugiri√≥ esto porque al actualizar la configuraci√≥n de NGINX se rompieron todas las conexiones, lo que fue dif√≠cil de restaurar. <br><br>  Discutimos la arquitectura de la nueva soluci√≥n y llegamos a la conclusi√≥n de que recibiremos y enviaremos datos utilizando solicitudes HTTP regulares.  Por ejemplo, env√≠e un <i>mensaje POST: / api / send-message</i> , obtenga una lista de cuadros de di√°logo <i>GET: / api / conversations-list,</i> y as√≠ sucesivamente.  Y los eventos asincr√≥nicos como "un nuevo mensaje del interlocutor" se enviar√°n a trav√©s de SSE.  Por lo tanto, aumentaremos la tolerancia a fallas de la aplicaci√≥n: si la conexi√≥n SSE se cae, el chat seguir√° funcionando, solo que no recibir√° notificaciones en tiempo real. <br><br>  Adem√°s del chat en websocket, est√°bamos persiguiendo eventos para el componente de "notificaciones delgadas".  Este componente le permite enviar varias notificaciones a la cuenta personal del usuario, por ejemplo, que la importaci√≥n de cuentas, que puede tardar varios minutos, se ha completado con √©xito.  Para abandonar completamente websocket, trasladamos este componente a una conexi√≥n SSE separada. <br><br><h3>  El problema </h3><br>  Cuando abre una pesta√±a del navegador, se crean dos conexiones SSE: una para chat y otra para notificaciones sutiles.  Bueno, que se creen.  Perd√≥n o qu√©?  ¬°No sentimos pena, pero los navegadores lo sienten!  Tienen un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">l√≠mite en el n√∫mero de conexiones persistentes concurrentes para un dominio</a> .  ¬øAdivina cu√°nto hay en Chrome?  Correcto, seis!  Abr√≠ tres pesta√±as: califiqu√© todo el grupo de conexiones y ya no puede realizar solicitudes HTTP.  Esto es cierto para el protocolo HTTP / 1.x.  En HTTP / 2 no existe tal problema debido a la multiplexaci√≥n. <br><br>  Hay un par de formas de resolver este problema a nivel de infraestructura: <br><br><ol><li>  <a href="">Fragmento de dominio.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://developers.google.com/web/fundamentals/performance/">HTTP / 2.</a> </li></ol><br>  Ambos m√©todos parec√≠an caros, ya que mucha infraestructura tendr√≠a que verse afectada. <br><br>  Por lo tanto, para empezar, intentamos resolver el problema en el lado del navegador.  La primera idea era hacer alg√∫n tipo de transporte entre las pesta√±as, por ejemplo, a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LocalStorage</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Broadcast Channel API</a> . <br><br>  El significado es este: abrimos conexiones SSE en una sola pesta√±a y enviamos los datos al resto.  Esta soluci√≥n tampoco parec√≠a √≥ptima, ya que requerir√≠a el lanzamiento de los 50 SPA, que conforman la cuenta personal de Tinkoff Business.  Lanzar 50 aplicaciones tambi√©n es costoso, as√≠ que segu√≠ buscando otras formas. <br><br><h3>  Soluci√≥n </h3><br>  Recientemente trabaj√© con trabajadores de servicios y pens√©: ¬øes posible aplicarlos en esta situaci√≥n? <br><br>  Para responder a esta pregunta, primero debe comprender qu√© hacen generalmente los trabajadores de servicios.  Pueden enviar solicitudes proxy, se ve m√°s o menos as√≠: <br><br><pre><code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = self.caches.open(<span class="hljs-string"><span class="hljs-string">'example'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">caches</span></span></span><span class="hljs-function"> =&gt;</span></span> caches.match(event.request)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> response || fetch(event.request)); event.respondWith(response); });</code> </pre> <br>  Escuchamos eventos para solicitudes HTTP y respondemos a nuestro gusto.  En este caso, estamos tratando de responder desde el cach√©, y si no funciona, hacemos una solicitud al servidor. <br><br>  Ok, intentemos interceptar la conexi√≥n SSE y responderla: <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSSERequest) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } event.respondWith(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(<span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>)); });</code> </pre><br>  En las solicitudes de red, vemos la siguiente imagen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/101/629/3b8/1016293b8b2996a1a3e53478b69eaff6.png" alt="imagen"><br><br>  Y en la consola, esto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d3/22e/b05/1d322eb0533cf21a456790c4d9bef519.png" alt="imagen"><br><br>  Ya no est√° mal.  La solicitud fue interceptada, pero el SSE no quiere una respuesta en forma de <i>texto / sin formato</i> , pero quiere <i>texto / secuencia de eventos</i> .  ¬øC√≥mo crear una transmisi√≥n ahora?  Pero, ¬øpuedo incluso responder con una transmisi√≥n de un trabajador de servicio?  Bueno, veamos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab8/c87/efd/ab8c87efd887d4693c2d6d9cddd986ee.png" alt="imagen"><br><br>  Genial  La clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Response</a> toma como cuerpo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ReadableStream</a> .  Despu√©s de leer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> , puede descubrir que <i>ReadableStream</i> tiene un controlador que tiene un m√©todo <i>enqueue ()</i> , con su ayuda puede transmitir datos.  Adecuado, t√≥malo! <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSSERequest) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseText = <span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseData = <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>.from(responseText, x =&gt; x.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableStream({<span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">controller</span></span></span><span class="hljs-function"> =&gt;</span></span> controller.enqueue(responseData)}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(stream); event.respondWith(response); });</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/35b/6a3/40b35b6a369d02e804e34c2179c0f273.png" alt="imagen"><br><br>  No hay ning√∫n error, la conexi√≥n se cuelga en estado pendiente y no llegan datos del lado del cliente.  Al comparar mi solicitud con una solicitud de servidor real, me di cuenta de que la respuesta estaba en los encabezados.  Para las solicitudes SSE, se deben especificar los siguientes encabezados: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseHeaders = { <span class="hljs-string"><span class="hljs-string">'content-type'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>, <span class="hljs-string"><span class="hljs-string">'Transfer-Encoding'</span></span>: <span class="hljs-string"><span class="hljs-string">'chunked'</span></span>, <span class="hljs-string"><span class="hljs-string">'Connection'</span></span>: <span class="hljs-string"><span class="hljs-string">'keep-alive'</span></span>, };</code> </pre><br>  Cuando agrega estos encabezados, la conexi√≥n se abrir√° correctamente, pero los datos no se recibir√°n en el lado del cliente.  Esto es obvio, ya que no puede enviar texto aleatorio, debe haber alg√∫n formato. <br><br>  En javascript.info, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se describe bien un formato de datos</a> en el que los datos deben enviarse desde el servidor.  Se puede describir f√°cilmente con una funci√≥n: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseChunkData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data: string, event?: string, retry?: number, id?: number</span></span></span><span class="hljs-function">): </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries({event, id, data, retry}) .filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> ![<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>].includes(value)) .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[key, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${key}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string">`</span></span>) .join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) + <span class="hljs-string"><span class="hljs-string">'\n\n'</span></span>;</code> </pre><br>  Para cumplir con el formato SSE, el servidor debe enviar mensajes separados por un salto de l√≠nea doble <i>\ n \ n</i> . <br><br>  El mensaje consta de los siguientes campos: <br><br><ul><li>  <b>datos</b> - cuerpo del mensaje, varios datos en una fila se interpretan como un mensaje, separados por saltos de l√≠nea \ n; </li><li>  <b>id</b> : actualiza la propiedad lastEventId enviada en el encabezado Last-Event-ID al volver a conectar; </li><li>  <b>reintentar</b> : el retraso recomendado antes de reconectarse en milisegundos no se puede establecer con JavaScript; </li><li>  <b>evento</b> : el nombre del evento del usuario, indicado antes de los datos. </li></ul><br>  Agregue los encabezados necesarios, cambie la respuesta al formato deseado y vea qu√© sucede: <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSSERequest) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseChunkData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data, event, retry, id</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries({event, id, data, retry}) .filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> ![<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>].includes(value)) .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[key, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${key}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string">`</span></span>) .join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) + <span class="hljs-string"><span class="hljs-string">'\n\n'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseHeaders = { <span class="hljs-string"><span class="hljs-string">'content-type'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>, <span class="hljs-string"><span class="hljs-string">'Transfer-Encoding'</span></span>: <span class="hljs-string"><span class="hljs-string">'chunked'</span></span>, <span class="hljs-string"><span class="hljs-string">'Connection'</span></span>: <span class="hljs-string"><span class="hljs-string">'keep-alive'</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseText = sseChunkData(<span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseData = <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>.from(responseText, x =&gt; x.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableStream({<span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">controller</span></span></span><span class="hljs-function"> =&gt;</span></span> controller.enqueue(responseData)}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(stream, {<span class="hljs-attr"><span class="hljs-attr">headers</span></span>: sseHeaders}); event.respondWith(response); });</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/216/ecb/010/216ecb0104e296f91267f3d18ab21ff0.png" alt="imagen"><br><br>  Oh mi glob!  ¬°S√≠, hice una conexi√≥n SSE sin un servidor! <br><br><h3>  Resultado </h3><br>  Ahora podemos interceptar con √©xito la solicitud SSE y responderla sin ir m√°s all√° del navegador. <br><br>  Inicialmente, la idea era establecer una conexi√≥n con el servidor, pero solo una cosa, y desde all√≠ enviar datos a pesta√±as.  ¬°Hag√°moslo! <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers, url} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   SSE- if (!isSSERequest) { return; } //    SSE const sseHeaders = { 'content-type': 'text/event-stream', 'Transfer-Encoding': 'chunked', 'Connection': 'keep-alive', }; // ,    SSE const sseChunkData = (data, event, retry, id) =&gt; Object.entries({event, id, data, retry}) .filter(([, value]) =&gt; ![undefined, null].includes(value)) .map(([key, value]) =&gt; `${key}: ${value}`) .join('\n') + '\n\n'; //    ,   ‚Äî url,  ‚Äî EventSource const serverConnections = {}; //   url             const getServerConnection = url =&gt; { if (!serverConnections[url]) serverConnections[url] = new EventSource(url); return serverConnections[url]; }; //          const onServerMessage = (controller, {data, type, retry, lastEventId}) =&gt; { const responseText = sseChunkData(data, type, retry, lastEventId); const responseData = Uint8Array.from(responseText, x =&gt; x.charCodeAt(0)); controller.enqueue(responseData); }; const stream = new ReadableStream({ start: controller =&gt; getServerConnection(url).onmessage = onServerMessage.bind(null, controller) }); const response = new Response(stream, {headers: sseHeaders}); event.respondWith(response); });</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El mismo c√≥digo en github.</a> <br>  Obtuve una soluci√≥n bastante simple para una tarea no tan trivial.  Pero, por supuesto, todav√≠a hay muchos matices.  Por ejemplo, debe cerrar la conexi√≥n al servidor al cerrar todas las pesta√±as, es totalmente compatible con el protocolo SSE, etc. <br><br>  Hemos decidido con √©xito todo esto. ¬°Estoy seguro de que no ser√° dif√≠cil para usted! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471718/">https://habr.com/ru/post/471718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471704/index.html">El libro "Las mitocondrias ego√≠stas. C√≥mo mantener la salud y mover la vejez "</a></li>
<li><a href="../471706/index.html">9 problemas de red t√≠picos que se pueden detectar usando el an√°lisis de NetFlow (usando Flowmon como ejemplo)</a></li>
<li><a href="../471708/index.html">Los storypoints son peligrosos para el desarrollo de aplicaciones cliente-servidor</a></li>
<li><a href="../471712/index.html">Crear una aplicaci√≥n de chat m√≥vil en React Native</a></li>
<li><a href="../471716/index.html">Exposici√≥n de tecnolog√≠a GITEX 2019: c√≥mo fue</a></li>
<li><a href="../471722/index.html">C√≥mo un chico de 17 a√±os port√≥ un √©xito arcade de los 80 a las computadoras</a></li>
<li><a href="../471724/index.html">Necesidades √°giles y cerebrales: manejo del estr√©s</a></li>
<li><a href="../471726/index.html">M√©todo moderno para medir la respuesta al impulso y la distorsi√≥n no lineal.</a></li>
<li><a href="../471728/index.html">Avalonia mis pros y contras</a></li>
<li><a href="../471736/index.html">Sensor Ethernet sin contacto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>