<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóæ ‚ô®Ô∏è üè≥Ô∏è Cuando las llamadas a funciones externas son m√°s r√°pidas que las llamadas nativas en C üèæ üïé üèòÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Agregado por: buena discusi√≥n en Hacker News 

 David Yu en GitHub ha desarrollado una prueba de rendimiento interesante para llamadas de funci√≥n a tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cuando las llamadas a funciones externas son m√°s r√°pidas que las llamadas nativas en C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413181/"> <font color="gray"><i>Agregado por: buena discusi√≥n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hacker News</a></i></font> <br><br>  David Yu en GitHub ha desarrollado una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prueba de rendimiento interesante</a> para llamadas de funci√≥n a trav√©s de varias interfaces externas (Interfaces de funciones externas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FFI</a> ). <br><br>  Cre√≥ un archivo de objeto compartido ( <code>.so</code> ) con una funci√≥n simple de C. Luego escribi√≥ un c√≥digo para llamar repetidamente a esta funci√≥n a trav√©s de cada FFI con una dimensi√≥n de tiempo. <br><br>  Para C "FFI", utiliz√≥ el enlace din√°mico est√°ndar, no <code>dlopen()</code> .  Esta diferencia es muy importante, ya que realmente afecta los resultados de la prueba.  Puede argumentar cu√°n honesta es esta comparaci√≥n con el FFI real, pero a√∫n es interesante medirla. <br><br>  El resultado de referencia m√°s sorprendente es que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el</a> FFI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de LuaJIT</a> es <b>significativamente m√°s r√°pido que C.</b>  Es aproximadamente un 25% m√°s r√°pido que una llamada C nativa para una funci√≥n de objeto compartido.  ¬øC√≥mo podr√≠a un lenguaje de script tipado d√©bil y din√°micamente superar en el punto de referencia C?  ¬øEl resultado es exacto? <br><a name="habracut"></a><br>  De hecho, esto es bastante l√≥gico.  La prueba se ejecuta en Linux, por lo que el retraso proviene de la Tabla de vinculaci√≥n de procedimientos (PLT).  Prepar√© un experimento realmente simple para demostrar el efecto en la vieja C simple: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/skeeto/dynamic-function-benchmark</a> <br><br>  Aqu√≠ est√°n los resultados en el Intel i7-6700 (Skylake): <br><br> <code>plt: 1.759799 ns/call <br> ind: 1.257125 ns/call <br> jit: 1.008108 ns/call</code> <br> <br>  Hay tres tipos diferentes de llamadas a funciones: <br><br><ol><li>  V√≠a PLT. </li><li>  Llamada de funci√≥n indirecta (a trav√©s de <code>dlsym(3)</code> ) </li><li>  Llamada de funci√≥n directa (a trav√©s de una funci√≥n compilada JIT) </li></ol><br>  Como puede ver, este √∫ltimo es el m√°s r√°pido.  Por lo general, no se usa en programas en C, pero es una opci√≥n natural en presencia de un compilador JIT, que incluye, obviamente, LuaJIT. <br><br>  En mi punto de referencia, la funci√≥n <code>empty()</code> se llama: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Compilar a un objeto compartido: <br><br><pre> <code class="cpp hljs">$ cc -shared -fPIC -Os -o empty.so empty.c</code> </pre> <br>  Al igual que en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comparaci√≥n PRNG</a> anterior, el punto de referencia tantas veces como sea posible llama a esta funci√≥n antes de que suene la alarma. <br><br><h1>  Tablas de dise√±o de procedimientos </h1><br>  Cuando un programa o biblioteca llama a una funci√≥n en otro objeto compartido, el compilador no puede saber d√≥nde estar√° esta funci√≥n en la memoria.  La informaci√≥n se encuentra solo en tiempo de ejecuci√≥n cuando el programa y sus dependencias se cargan en la memoria.  Por lo general, la funci√≥n se encuentra en lugares aleatorios, por ejemplo, de acuerdo con la aleatorizaci√≥n del espacio de direcciones (Aleatorizaci√≥n del dise√±o del espacio de direcciones, ASLR). <br><br>  ¬øC√≥mo resolver tal problema?  Bueno, hay varias opciones. <br><br>  Una de ellas es marcar cada llamada en metadatos binarios.  El generador de tiempo de ejecuci√≥n din√°mico <i>inserta la</i> direcci√≥n correcta en cada llamada.  El mecanismo espec√≠fico depende del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modelo de c√≥digo</a> que se utiliz√≥ durante la compilaci√≥n. <br><br>  La desventaja de este enfoque es que ralentiza la carga, aumenta el tama√±o de los archivos binarios y reduce el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intercambio de p√°ginas de c√≥digos</a> entre diferentes procesos.  La descarga se ralentiza porque todos los pares de marcado din√°mico deben ser parcheados con la direcci√≥n correcta antes de iniciar el programa.  El binario est√° hinchado porque cada entrada necesita un lugar en la tabla.  Y la falta de compartir est√° asociada con un cambio en las p√°ginas de c√≥digos. <br><br>  Por otro lado, se puede eliminar la sobrecarga de invocar funciones din√°micas, lo que proporciona un rendimiento similar al JIT, como se muestra en el punto de referencia. <br><br>  La segunda opci√≥n es enrutar todas las llamadas din√°micas a trav√©s de una tabla.  El par de marcado original se refiere al c√≥digo auxiliar en esta tabla, y desde all√≠ a la funci√≥n din√°mica real.  Con este enfoque, el c√≥digo no necesita ser parcheado, lo que conduce a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intercambio trivial</a> entre procesos.  Para cada funci√≥n din√°mica, necesita parchear solo un registro en la tabla.  Adem√°s, estas correcciones pueden hacerse <i>perezosamente</i> , en la primera llamada de la funci√≥n, lo que acelera a√∫n m√°s la carga. <br><br>  En los sistemas binarios ELF, esta tabla se denomina Tabla de vinculaci√≥n de procedimientos (PLT).  PLT en s√≠ no est√° realmente corregido: se muestra como de solo lectura para el resto del c√≥digo.  En cambio, se corrige la tabla de compensaci√≥n global (GOT).  El c√≥digo auxiliar PLT recupera la direcci√≥n de una funci√≥n din√°mica del GOT e <i>indirectamente</i> salta a esa direcci√≥n.  Para cargar direcciones de funciones de manera perezosa, estas entradas GOT se inicializan con la direcci√≥n de la funci√≥n que encuentra el car√°cter de destino, actualiza el GOT con esa direcci√≥n y luego pasa a la funci√≥n.  Las llamadas posteriores usan una direcci√≥n detectada perezosamente. <br><br><img src="https://habrastorage.org/webt/47/2r/yh/472ryhlyogynkwwrxyopa1rg7l0.png"><br><br>  La desventaja de PLT es la sobrecarga adicional de invocar una funci√≥n din√°mica, que es lo que apareci√≥ en el punto de referencia.  Dado que el punto de referencia <i>solo</i> mide llamadas a funciones, la diferencia parece bastante significativa, pero en la pr√°ctica generalmente es cercana a cero. <br><br>  Aqu√≠ est√° el punto de referencia: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Cleared by an alarm signal. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sig_atomic_t</span></span> running; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plt_benchmark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (count = <span class="hljs-number"><span class="hljs-number">0</span></span>; running; count++) empty(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>  Como <code>empty()</code> est√° en un objeto compartido, la llamada pasa por el PLT. <br><br><h1>  Llamadas Din√°micas Indirectas </h1><br>  Otra forma de invocar din√°micamente funciones es recorrer el PLT y obtener la direcci√≥n de la funci√≥n de destino en el programa, por ejemplo, a trav√©s de <code>dlsym(3)</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *h = dlopen(<span class="hljs-string"><span class="hljs-string">"path/to/lib.so"</span></span>, RTLD_NOW); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*f)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = dlsym(<span class="hljs-string"><span class="hljs-string">"f"</span></span>); f();</code> </pre> <br>  Si se recibe la direcci√≥n de la funci√≥n, el costo es menor que la funci√≥n que llama a trav√©s de PLT.  No hay una funci√≥n intermedia de c√≥digo auxiliar y acceso a GOT.  (Precauci√≥n: si el programa tiene un registro PLT para esta funci√≥n, entonces <code>dlsym(3)</code> puede devolver una direcci√≥n de c√≥digo auxiliar). <br><br>  Pero esto sigue siendo un desaf√≠o <i>indirecto</i> .  En arquitecturas convencionales, <i>las</i> llamadas a funciones <i>directas</i> reciben su direcci√≥n relativa inmediata.  Es decir, el prop√≥sito de la llamada es un desplazamiento codificado desde el punto de llamada.  La CPU puede determinar a d√≥nde ir√° la llamada mucho antes. <br><br>  Las llamadas indirectas tienen m√°s gastos generales.  Primero, la direcci√≥n debe almacenarse en alg√∫n lugar.  Incluso si es solo un registro, su uso aumenta el d√©ficit de los registros.  En segundo lugar, las llamadas indirectas provocan un predictor de rama en la CPU, imponiendo una carga adicional en el procesador.  En el peor de los casos, una llamada puede incluso hacer que la tuber√≠a se detenga. <br><br>  Aqu√≠ est√° el punto de referencia: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sig_atomic_t</span></span> running; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indirect_benchmark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (count = <span class="hljs-number"><span class="hljs-number">0</span></span>; running; count++) f(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>  La funci√≥n pasada a este punto de referencia se extrae usando <code>dlsym(3)</code> , por lo que el compilador no puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hacer algo complicado</a> , como convertir esta llamada indirecta a directa. <br><br>  Si el cuerpo del bucle es lo suficientemente complejo como para causar un d√©ficit de registros y, por lo tanto, dar la direcci√≥n a la pila, entonces este punto de referencia tampoco se puede comparar honestamente con el punto de referencia PLT. <br><br><h1>  Llamadas directas a funciones </h1><br>  Los dos primeros tipos de llamadas a funciones din√°micas son simples y f√°ciles de usar.  <i>Las</i> llamadas <i>directas</i> para funciones din√°micas son m√°s dif√≠ciles de organizar, ya que requieren cambios de c√≥digo durante la ejecuci√≥n.  En mi punto de referencia, arm√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">peque√±o compilador JIT</a> para generar una llamada directa. <br><br>  El truco es que en x86-64 las transiciones expl√≠citas est√°n limitadas a un rango de 2 GB debido al operando firmado de 32 bits (firmado inmediatamente).  Esto significa que el c√≥digo JIT debe colocarse casi al lado de la funci√≥n de destino, <code>empty()</code> .  Si el c√≥digo JIT debe llamar a dos funciones din√°micas diferentes, divididas por m√°s de 2 GB, entonces es imposible hacer dos llamadas directas. <br><br>  Para simplificar la situaci√≥n, mi punto de referencia no est√° preocupado por la elecci√≥n exacta o muy cuidadosa de la direcci√≥n del c√≥digo JIT.  Despu√©s de recibir la direcci√≥n de la funci√≥n de destino, simplemente resta 4 MB, la redondea a la p√°gina m√°s cercana, asigna un poco de memoria y le escribe c√≥digo.  Si todo se hace como deber√≠a, entonces para buscar un lugar necesita verificar sus propias representaciones del programa en la memoria, y esto no puede hacerse de una manera limpia y port√°til.  Linux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">requiere analizar archivos virtuales en / proc</a> . <br><br>  As√≠ es como se ve mi asignaci√≥n de memoria JIT.  Asume <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un comportamiento razonable para lanzar uintptr_t</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jit_compile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct jit_func *f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*empty)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> addr = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)empty; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *desired = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)((addr - SAFETY_MARGIN) &amp; PAGEMASK); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = mmap(desired, len, prot, flags, fd, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Aqu√≠ destacan dos p√°ginas: una para escribir y la otra con c√≥digo que no se puede escribir.  Al igual que en mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca para cierres</a> , aqu√≠ la p√°gina inferior se puede escribir y contiene una variable en <code>running</code> que se restablece a alarma.  Esta p√°gina debe estar al lado del c√≥digo JIT para proporcionar un acceso efectivo con respecto al RIP, como una funci√≥n en los otros dos puntos de referencia.  La p√°gina superior contiene este c√≥digo de ensamblaje: <br><br><pre> <code class="hljs vbscript">jit_benchmark: push rbx <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> ebx, ebx .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>: mov eax, [rel running] test eax, eax je .done <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-literal"><span class="hljs-literal">empty</span></span> inc ebx jmp .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> .done: mov eax, ebx pop rbx ret</code> </pre> <br>  <code>call empty</code> es la √∫nica instrucci√≥n generada din√°micamente, es necesario completar correctamente la direcci√≥n relativa (menos 5 se indica en relaci√≥n con el <i>final de la</i> instrucci√≥n): <br><br><pre> <code class="hljs lisp"> // call empty uintptr_t rel = (<span class="hljs-name"><span class="hljs-name">uintptr_t</span></span>)empty - (<span class="hljs-name"><span class="hljs-name">uintptr_t</span></span>)p - <span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-comment"><span class="hljs-comment">; *p++ = 0xe8; *p++ = rel &gt;&gt; 0; *p++ = rel &gt;&gt; 8; *p++ = rel &gt;&gt; 16; *p++ = rel &gt;&gt; 24;</span></span></code> </pre> <br>  Si la funci√≥n <code>empty()</code> no est√° en el objeto general, sino en el mismo archivo binario, entonces esta es esencialmente una llamada directa que el compilador generar√° para <code>plt_benchmark()</code> , suponiendo que por alguna raz√≥n no se haya incorporado en <code>empty()</code> . <br><br>  Ir√≥nicamente, llamar a un c√≥digo compilado JIT requiere una llamada indirecta (por ejemplo, a trav√©s de un puntero de funci√≥n), y no hay forma de evitarlo.  ¬øQu√© puedo hacer aqu√≠, compilar JIT otra funci√≥n para una llamada directa?  Afortunadamente, esto no importa porque solo una llamada directa se mide en un bucle. <br><br><h1>  Ning√∫n secreto </h1><br>  Dados estos resultados, queda claro por qu√© LuaJIT genera llamadas m√°s eficientes a funciones din√°micas que PLT, <i>incluso si siguen siendo llamadas indirectas</i> .  En mi punto de referencia, las llamadas indirectas sin PLT fueron un 28% m√°s r√°pidas que con PLT, y las llamadas directas sin PLT fueron un 43% m√°s r√°pidas que con PLT.  Esta peque√±a ventaja de los programas JIT sobre los antiguos programas nativos simples se logra debido al rechazo absoluto del intercambio de c√≥digo entre procesos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413181/">https://habr.com/ru/post/es413181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413169/index.html">Matriz √∫til y m√©todos de objetos en JavaScript</a></li>
<li><a href="../es413171/index.html">Tokamak JET lanza nueva campa√±a de tritio de deuterio</a></li>
<li><a href="../es413173/index.html">Monitoreo de errores de JavaScript con window.onerror</a></li>
<li><a href="../es413175/index.html">An√°lisis est√°tico en Go: c√≥mo ahorramos tiempo al verificar el c√≥digo</a></li>
<li><a href="../es413177/index.html">Eventos digitales en Mosc√∫ del 4 al 10 de junio</a></li>
<li><a href="../es413185/index.html">Juego sucio, o c√≥mo los organizadores del sorteo nos enga√±an</a></li>
<li><a href="../es413187/index.html">Entrevista con Ryan Dahl, creador de Node.js</a></li>
<li><a href="../es413189/index.html">Colecci√≥n de sombras de ojos css Box-shadows.css</a></li>
<li><a href="../es413195/index.html">Pensamiento funcional Parte 6</a></li>
<li><a href="../es413199/index.html">Fracasos de futur√≥logos. Ideas de pel√≠culas que no se materializaron.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>