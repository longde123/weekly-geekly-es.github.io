<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš‹ â—¾ï¸ ğŸ™‹ğŸ½ UHCI oder der allererste USB ğŸ”¼ â¤´ï¸ ğŸ‘©ğŸ¼â€ğŸ”§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, lieber Leser! Ich wurde gebeten, Ã¼ber UHCI zu schreiben - nun, ich schreibe. 

 Sie kÃ¶nnen diesen Artikel nÃ¼tzlich finden, wenn Sie beispie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UHCI oder der allererste USB</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429422/"><img src="https://habrastorage.org/webt/89/wk/ye/89wkyeuwi_jbnzlge2bawtlabum.png"><br><br>  Guten Tag, lieber Leser!  Ich wurde gebeten, Ã¼ber UHCI zu schreiben - nun, ich schreibe. <br><br>  Sie kÃ¶nnen diesen Artikel nÃ¼tzlich finden, wenn Sie beispielsweise nicht Ã¼ber ausreichende SchreibfÃ¤higkeiten fÃ¼r Treiber und das Lesen von Dokumentation fÃ¼r eine Hardware verfÃ¼gen.  Ein einfaches Beispiel: Sie mÃ¶chten Ihr Betriebssystem fÃ¼r einen Mini-PC schreiben, damit einige Windows- oder andere Linux-Distributionen kein Eisen herunterladen, und Sie nutzen die gesamte Leistung ausschlieÃŸlich fÃ¼r Ihre eigenen Zwecke. <br><a name="habracut"></a><br><h2>  Was ist UHCI? </h2><br>  Ich denke, um nicht noch einmal auf das Thema was und warum zu sprÃ¼hen, hinterlasse einfach einen Link zu meinem vorherigen Artikel Ã¼ber EHCI.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Poke hier</a> <br>  UHCI - Universal Host Controller Interface, arbeitet als PCI-GerÃ¤t, verwendet jedoch im Gegensatz zu EHCI Ports anstelle von MMIO (Memory-Mapped-IO). <br><br><img src="https://habrastorage.org/webt/nk/bl/--/nkbl--cqrxvs21lcitfothfcw4k.png"><br><br><h2>  Begriffe, die im Folgenden verwendet werden </h2><br><ul><li>  USB-Treiber (USBD) - der USB-Treiber selbst </li><li>  HC (Host Controller) - ein Host Controller oder nur unser UHCI </li><li>  Host Controller Driver (HCD) - ein Treiber, der Hardware und USBD verbindet </li><li>  USB-GerÃ¤t - USB-GerÃ¤t selbst </li></ul><br><h2>  Arten der DatenÃ¼bertragung </h2><br>  Isochrone - isosynchrone Ãœbertragung mit einer bestimmten DatenÃ¼bertragungsfrequenz.  Es kann beispielsweise fÃ¼r USB-Mikrofone usw. verwendet werden. <br><br>  Interrupt - Kleine, spontane DatenÃ¼bertragung von einem GerÃ¤t.  Der Interrupt-Ãœbertragungstyp unterstÃ¼tzt GerÃ¤te, die ein vorhersagbares Serviceintervall erfordern, aber nicht unbedingt einen vorhersagbaren Datenstrom bereitstellen.  Wird hÃ¤ufig fÃ¼r GerÃ¤te wie Tastaturen und ZeigegerÃ¤te verwendet, die mÃ¶glicherweise Ã¼ber einen lÃ¤ngeren Zeitraum keine Daten bereitstellen, jedoch eine schnelle Antwort erfordern, wenn Daten gesendet werden mÃ¼ssen. <br><br>  Steuerung - Art der Ãœbertragung von Informationen Ã¼ber den GerÃ¤testatus, den Status und die Konfiguration.  Der Steuerungstransfertyp wird verwendet, um einen Steuerkanal vom Host zu USB-GerÃ¤ten bereitzustellen.  SteuerÃ¼bertragungen bestehen immer aus einer Einrichtungsphase und null oder mehr Datenphasen, gefolgt von einer Statusphase.  Es ist unbedingt erforderlich, dass die SteuerÃ¼bertragung an einen bestimmten Endpunkt im FIFO-Modus verarbeitet wird.  Wenn die Steuerung an denselben Endpunkt Ã¼bergeben wird, kann das Verschachteln zu unvorhersehbarem Verhalten fÃ¼hren. <br><br>  Bulk - Art der Ãœbertragung von Datenarrays.  Wird beispielsweise in MassStorage-GerÃ¤ten verwendet. <br><br><img src="https://habrastorage.org/webt/j1/d5/4a/j1d54aqfs0iicr_-dfpmkwx8d_e.png"><br><br>  So sieht die Zeitverteilung von 1 ms aus - Verarbeitung eines Frames. <br><br><h2>  Zeitverteilung </h2><br>  Der Host-Controller unterstÃ¼tzt die DatenÃ¼bertragung in Echtzeit, indem alle 1 ms ein SOF-Paket (Start Of Frame) generiert wird.  Ein SOF-Paket wird generiert, wenn der SOF-ZÃ¤hler im Host-Controller ablÃ¤uft (Abbildung 3).  Der Host-Controller initialisiert den SOF-ZÃ¤hler fÃ¼r eine Frame-Zeit von 1 ms.  Durch Programmieren des SOF-Ã„nderungsregisters kÃ¶nnen kleine Ã„nderungen an diesem Wert (und damit an der Rahmenzeitdauer) vorgenommen werden.  Mit dieser Funktion kÃ¶nnen Sie bei Bedarf geringfÃ¼gige Ã„nderungen am Frame-Zeitraum vornehmen, um die Echtzeitsynchronisation im gesamten USB-System aufrechtzuerhalten. <br><br>  Der Host-Controller enthÃ¤lt die Rahmennummer in jedem SOF-Paket.  Diese Bildnummer bestimmt eindeutig die Bilddauer in Echtzeit.  Die End-of-Frame-Bedingung (EOF) tritt am Ende des Zeitintervalls von 1 ms auf, wenn der Host-Controller die nÃ¤chste Frame-Zeit startet und ein weiteres SOF-Paket mit der entsprechenden Frame-Nummer generiert.  WÃ¤hrend der Rahmenperiode werden Daten als Informationspakete Ã¼bertragen.  Der Frame-Zeitraum wird vom Host-Controller strikt eingehalten, und die Datenpakete im aktuellen Frame dÃ¼rfen nicht Ã¼ber den EOF hinausgehen (siehe Kapitel 11 in der USB-Spezifikation).  Der Host-Controller unterstÃ¼tzt die Synchronisation der DatenÃ¼bertragung zwischen Frames in Echtzeit und verknÃ¼pft die Frame-Nummer, um einen bestimmten Eintrag in der Frame-Liste vorzunehmen.  Der Frame-ZÃ¤hler des Host-Controllers generiert eine Frame-Nummer (11-Bit-Wert) und enthÃ¤lt diese in jedem SOF-Paket.  Der ZÃ¤hler wird Ã¼ber Register programmiert und jede Rahmenperiode wird inkrementiert.  Der Host-Controller verwendet die unteren 10 Bits der Frame-Nummer als Index in der Frame-Liste mit 1024 Frames, die im Systemspeicher gespeichert sind.  Da der RahmenzÃ¤hler die Auswahl eines Eintrags aus der Liste der Rahmen steuert, verarbeitet der Host-Controller jeden Eintrag in der Liste in einer bestimmten Rahmenperiode.  Der Host-Controller wird fÃ¼r jeden neuen Frame zum nÃ¤chsten Eintrag in der Frame-Liste erweitert.  Dies stellt sicher, dass isochrone Ãœbertragungen in einem bestimmten Rahmen ausgefÃ¼hrt werden. <br><br>  Abbildung 3: <br><br><img src="https://habrastorage.org/webt/d8/pj/iw/d8pjiwyjanx3yse7tmmtnyeooqe.png"><br><br><h2>  UHCI-Struktur </h2><br>  Alles ist genau das gleiche wie bei EHCI.  Beispielanfragen an HC: <br><br><img src="https://habrastorage.org/webt/io/1d/sm/io1dsmtielklqhm84nhekufybj4.png"><br><br><h2>  UHCI konfigurieren und darauf zugreifen </h2><br>  Wie ich bereits sagte, arbeitet UHCI Ã¼ber Ports. Daher mÃ¼ssen wir Ã¼ber PCI die Basis der UHCI-Register ermitteln. <br><br><img src="https://habrastorage.org/webt/gz/ql/3f/gzql3fejuar2ko92q8dnok-ehpi.png"><br><br>  Bei Offset 0x20 gibt es 4 Bytes - IO Base.  In Bezug auf die E / A-Basis kÃ¶nnen wir die folgenden Register verwenden: <br><br><img src="https://habrastorage.org/webt/jk/a5/od/jka5odl_cbgmqxcdsix8e-1tkl0.png"><br><br><h2>  UHCI-Register </h2><br><ul><li>  USBCMD ist ein Register zur Steuerung von HC.  Bits: <ul><li>  Bit 6 ist ein Flag, mit dem das GerÃ¤t erfolgreich konfiguriert und initialisiert wurde. </li><li>  Bit 1 - HC Reset.  Zum ZurÃ¼cksetzen von HC einstellen. </li><li>  Bit 0 - AusfÃ¼hren / Stoppen.  Zeigt den HC-Status an.  1 - funktioniert, 0 - nein. </li></ul></li><li>  USBSTS - Statusregister.  Bits: <ul><li>  Bit 5 - HC angehalten.  Ein Fehler ist aufgetreten oder der Controller hat den HC-Reset erfolgreich abgeschlossen. </li><li>  Bit 4 - Prozessfehler des Host-Controllers.  Das Bit wird auf 1 gesetzt, wenn ein kritischer Fehler aufgetreten ist und HC die Warteschlange und TD nicht fortsetzen kann. </li><li>  Bit 3 - Hostsystemfehler.  PCI-Fehler. </li><li>  Bit 1 - Fehlerunterbrechung.  Zeigt an, dass ein Fehler aufgetreten ist und der HC einen Interrupt generiert hat. </li><li>  Bit 0 - Interrupt.  Zeigt an, dass HC einen Interrupt generiert hat. </li></ul></li><li>  USBINTR - Register der Interrupt-Einstellungen.  Bits: <ul><li>  Bit 2 - IOC - Interrupt bei Abschluss - erzeugt am Ende der Transaktion einen Interrupt. </li></ul></li><li>  FRNUM - Nummer des aktuellen Frames (nimm es &amp; 0x3FF fÃ¼r den richtigen Wert). </li><li>  FLBASEADD - Frame List Base Address - Adresse der Liste der Frames. </li><li>  PORTSC - Portstatus und -steuerung - Status- und Portsteuerungsregister.  Bits: <ul><li>  Bit 9 - Port Reset - 1 - Port zum ZurÃ¼cksetzen. </li><li>  Bit 8 - zeigt an, dass ein GerÃ¤t mit niedriger Geschwindigkeit an den Port angeschlossen ist </li><li>  Bit 3 - Zeigt an, dass sich der Port-On-Status geÃ¤ndert hat </li><li>  Bit 2 - Zeigt an, ob der Port aktiviert ist </li><li>  Bit 1 - zeigt an, dass der Status des GerÃ¤ts mit dem Port verbunden ist </li><li>  Bit 0 - zeigt an, dass das GerÃ¤t an den Port angeschlossen ist. </li></ul></li></ul><br><h2>  Strukturen </h2><br><h3>  Rahmenlistenzeiger </h3><br><img src="https://habrastorage.org/webt/oc/y8/a6/ocy8a6is-xd60i9bxmtdjjyqcdy.png"><br><br><h3>  Deskriptor Ã¼bertragen </h3><br><img src="https://habrastorage.org/webt/jz/sh/bl/jzshblpig4inzxxtzkzxlmvsvq8.png"><br><br><h5>  TD STEUERUNG UND STATUS </h5>  .  Bits: <br><ul><li>  Bits 28-27 - FehlerzÃ¤hler, Ã¤hnlich wie bei EHCI. </li><li><ul><li>  Bit 26 - 1 = GerÃ¤t mit niedriger Geschwindigkeit, 0 = GerÃ¤t mit voller Geschwindigkeit. </li><li>  Bit 25-1 = Isosynchrones TD </li><li>  Bit 24 - IOC </li><li>  Bits 23-16 - Status: </li><li>  Bit 23 - Zeigt an, dass es sich um einen aktiven TD handelt </li><li>  Bit 22 - Blockiert </li><li>  Bit 21 - Datenpufferfehler </li><li>  Bit 20 - Babble erkannt </li><li>  Bit 19 - NAK </li></ul></li><li>  Bits 10â€“0: Die Anzahl der vom Host-Controller Ã¼bertragenen Bytes. </li></ul><br><h5>  TD Token </h5><br><ul><li>  Bits 31:21 - Max Packet Len, Ã¤hnlich wie EHCI </li><li>  Bit 19 - Data Toggle, Ã¤hnlich wie EHCI </li><li>  Bits 18:15 - Endpunktnummer </li><li>  Bits 18:14 - GerÃ¤teadresse </li><li>  Bits 7: 0 - PID.  In = 0x69, Out = 0xE1, Setup = 0x2D </li></ul><br><h3>  Warteschlangenkopf </h3><br><img src="https://habrastorage.org/webt/-4/pb/ia/-4pbiakp01iozcmkne4q1tums4i.png"><br><br><h2>  Code </h2><br>  HC initialisieren und konfigurieren: <br><br><pre><code class="cpp hljs">PciBar bar; PciGetBar(&amp;bar, id, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~bar.flags &amp; PCI_BAR_IO) { <span class="hljs-comment"><span class="hljs-comment">// Only Port I/O supported return; } unsigned int ioAddr = bar.u.port; UhciController *hc = VMAlloc(sizeof(UhciController)); hc-&gt;ioAddr = ioAddr; hc-&gt;frameList = VMAlloc(1024 * sizeof(u32) + 8292); hc-&gt;frameList = ((int)hc-&gt;frameList / 4096) * 4096 + 4096; hc-&gt;qhPool = (UhciQH *)VMAlloc(sizeof(UhciQH) * MAX_QH + 8292); hc-&gt;qhPool = ((int)hc-&gt;qhPool / 4096) * 4096 + 4096; hc-&gt;tdPool = (UhciTD *)VMAlloc(sizeof(UhciTD) * MAX_TD + 8292); hc-&gt;tdPool = ((int)hc-&gt;tdPool / 4096) * 4096 + 4096; memset(hc-&gt;qhPool, 0, sizeof(UhciQH) * MAX_QH); memset(hc-&gt;tdPool, 0, sizeof(UhciTD) * MAX_TD); memset(hc-&gt;frameList, 0, 4 * 1024); // Frame list setup UhciQH *qh = UhciAllocQH(hc); qh-&gt;head = TD_PTR_TERMINATE; qh-&gt;element = TD_PTR_TERMINATE; qh-&gt;transfer = 0; qh-&gt;qhLink.prev = &amp;qh-&gt;qhLink; qh-&gt;qhLink.next = &amp;qh-&gt;qhLink; hc-&gt;asyncQH = qh; for (uint i = 0; i &lt; 1024; ++i) hc-&gt;frameList[i] = 2 | (u32)(uintptr_t)qh; IoWrite16(hc-&gt;ioAddr + REG_INTR, 0); IoWrite16(hc-&gt;ioAddr + REG_CMD, IoRead16(hc-&gt;ioAddr + REG_CMD)&amp;(~1)); unsigned short cfg = PciRead16(id, 4); PciWrite16(id, 4, cfg &amp; (~1)); PciWrite16(id, 0x20, (short)-1); unsigned short size = ~(PciRead16(id, 0x20)&amp;(~3)) + 1; PciWrite16(id, 0x20, hc-&gt;ioAddr); PciWrite16(id, 4, cfg | 5); // Disable Legacy Support IoWrite16(hc-&gt;ioAddr + REG_LEGSUP, 0x8f00); // Disable interrupts IoWrite16(hc-&gt;ioAddr + REG_INTR, 0); // Assign frame list IoWrite16(hc-&gt;ioAddr + REG_FRNUM, 0); IoWrite32(hc-&gt;ioAddr + REG_FRBASEADD, (int)hc-&gt;frameList); IoWrite16(hc-&gt;ioAddr + REG_SOFMOD, 0x40); // Clear status IoWrite16(hc-&gt;ioAddr + REG_STS, 0xffff); // Enable controller IoWrite16(hc-&gt;ioAddr + REG_CMD, 0x1); // Probe devices UhciProbe(hc, size);</span></span></code> </pre> <br>  Endpunkt- und Steuerungsanforderungen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------ static void UhciDevControl(UsbDevice *dev, UsbTransfer *t) { UhciController *hc = (UhciController *)dev-&gt;hc; UsbDevReq *req = t-&gt;req; // Determine transfer properties uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint endp = 0; uint maxSize = dev-&gt;maxPacketSize; uint type = req-&gt;type; uint len = req-&gt;len; // Create queue of transfer descriptors UhciTD *td = UhciAllocTD(hc); if (!td) { return; } UhciTD *head = td; UhciTD *prev = 0; // Setup packet uint toggle = 0; uint packetType = TD_PACKET_SETUP; uint packetSize = sizeof(UsbDevReq); UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, req); prev = td; // Data in/out packets packetType = type &amp; RT_DEV_TO_HOST ? TD_PACKET_IN : TD_PACKET_OUT; u8 *it = (u8 *)t-&gt;data; u8 *end = it + len; while (it &lt; end) { td = UhciAllocTD(hc); if (!td) { return; } toggle ^= 1; packetSize = end - it; if (packetSize &gt; maxSize) { packetSize = maxSize; } UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, it); it += packetSize; prev = td; } // Status packet td = UhciAllocTD(hc); if (!td) { return; } toggle = 1; packetType = type &amp; RT_DEV_TO_HOST ? TD_PACKET_OUT : TD_PACKET_IN; UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, 0, 0); // Initialize queue head UhciQH *qh = UhciAllocQH(hc); UhciInitQH(qh, t, head); // Wait until queue has been processed UhciInsertQH(hc, qh); UhciWaitForQH(hc, qh); } // ------------------------------------------------------------------------------------------------ static void UhciDevIntr(UsbDevice *dev, UsbTransfer *t) { UhciController *hc = (UhciController *)dev-&gt;hc; // Determine transfer properties uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint endp = t-&gt;endp-&gt;desc-&gt;addr &amp; 0xf; // Create queue of transfer descriptors UhciTD *td = UhciAllocTD(hc); if (!td) { t-&gt;success = false; t-&gt;complete = true; return; } UhciTD *head = td; UhciTD *prev = 0; // Data in/out packets uint toggle = t-&gt;endp-&gt;toggle; uint packetType = TD_PACKET_IN; //Here for compiler, on some last expression hadn't worked if (t-&gt;endp-&gt;desc-&gt;addr &amp; 0x80) packetType = TD_PACKET_IN; else packetType = TD_PACKET_OUT; uint packetSize = t-&gt;len; UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, t-&gt;data); // Initialize queue head UhciQH *qh = UhciAllocQH(hc); UhciInitQH(qh, t, head); // Schedule queue UhciInsertQH(hc, qh); if(t-&gt;w) UhciWaitForQH(hc, qh); }</span></span></code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429422/">https://habr.com/ru/post/de429422/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar486150/index.html">ØªØ·ÙˆÙŠØ± Ù…Ø¬Ø§Ù„ ØªÙƒÙ†ÙˆÙ„ÙˆØ¬ÙŠØ§ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ÙÙŠ Ø³Ù„ÙˆÙØ§ÙƒÙŠØ§. ÙÙˆØ§Ø¦Ø¯ Ø§Ù„Ø¹Ù…Ù„ Ù„Ù„Ù…Ù‡Ù†ÙŠÙŠÙ† Ø§Ù„Ø´Ø¨Ø§Ø¨</a></li>
<li><a href="../ar486156/index.html">ÙƒÙ…Ø§ Ø¹Ù„Ù…Øª ØŒ Ø«Ù… ÙƒØªØ¨ Ø¯Ù„ÙŠÙ„ Ø§Ù„ØªØ¯Ø±ÙŠØ¨ ÙÙŠ Ø¨ÙŠØ«ÙˆÙ†</a></li>
<li><a href="../ar486158/index.html">ØªØµÙˆØ± Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¢Ù„ÙŠØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ© (Ù†Ù…Ø§Ø°Ø¬ seq2seq Ù…Ø¹ Ø¢Ù„ÙŠØ© Ø§Ù„Ø§Ù‡ØªÙ…Ø§Ù…)</a></li>
<li><a href="../ar486164/index.html">ÙÙŠØ±ÙˆØ³ ÙƒÙˆØ±ÙˆÙ†Ø§ 2019-nCoV. Ø£Ø³Ø¦Ù„Ø© ÙˆØ£Ø¬ÙˆØ¨Ø© Ø¹Ù† Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø¬Ù‡Ø§Ø² Ø§Ù„ØªÙ†ÙØ³ÙŠ ÙˆØ§Ù„ØªØ·Ù‡ÙŠØ±</a></li>
<li><a href="../ar486174/index.html">Ù„Ø¯ÙŠ ØµÙØ± Ø¯ÙˆØ±Ø§Ù†</a></li>
<li><a href="../de429424/index.html">Robotaxi von Daimler und Bosch wird in Kalifornien auftreten</a></li>
<li><a href="../de429426/index.html">QGIS- und Kachelexport</a></li>
<li><a href="../de429448/index.html">Wir schreiben den FPGA-Loader in LabVIEW. Teil 2</a></li>
<li><a href="../de429450/index.html">Verallgemeinerte Programmiertechniken in Rust: Wie wir Exonum von Iron nach Actix-Web Ã¼bersetzt haben</a></li>
<li><a href="../de429452/index.html">Das Pentagon begann, die Malware anderer Leute zu deklassieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>