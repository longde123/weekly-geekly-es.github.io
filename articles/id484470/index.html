<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¹ğŸ½ ğŸ‘©ğŸ¿â€âš–ï¸ ğŸ¤ Extensible Extensions dalam JavaScript ğŸš° ğŸ˜· ğŸ¤¦ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Kami menarik perhatian Anda pada salinan tambahan yang telah lama ditunggu-tunggu dari buku " JavaScript Ekspresif ", yang baru saja da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Extensible Extensions dalam JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/484470/">  Halo, Habr! <br><br>  Kami menarik perhatian Anda pada salinan tambahan yang telah lama ditunggu-tunggu dari buku " <a href="https://www.piter.com/collection/all/product/vyrazitelnyy-javascript-sovremennoe-veb-programmirovanie-3-e-izdanie">JavaScript Ekspresif</a> ", yang baru saja datang dari percetakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xc/he/sh/xcheshyyruqmp90p5qwuga1k9cu.jpeg"></div><br>  Bagi mereka yang tidak terbiasa dengan karya penulis buku (untuk semua sifat ensiklopedis, pengembang pemula juga akan menyukainya) - kami sarankan Anda membiasakan diri dengan artikel dari blognya;  Artikel ini menguraikan pemikiran tentang mengatur ekstensi dalam JavaScript. <br><a name="habracut"></a><br>  Saat ini, telah menjadi mode untuk menyusun sistem besar dalam bentuk banyak paket terpisah.  Gagasan mengemudi yang mendasari pendekatan ini adalah bahwa lebih baik tidak membatasi orang ke fitur tertentu (diusulkan oleh Anda) dengan menerapkan fitur, tetapi untuk menyediakan fitur ini sebagai paket terpisah yang dapat diunduh seseorang bersama dengan paket sistem dasar. <br>  Untuk melakukan ini, secara umum, Anda perlu ... <br><br><ul><li>  Kemampuan untuk tidak mengunduh fitur yang tidak Anda perlukan sangat berguna pada sistem klien. </li><li>  Kemampuan untuk mengganti dengan implementasi lain sepotong fungsi yang tidak memenuhi tujuan Anda.  Dengan demikian, beban pada modul kernel juga berkurang - tidak perlu mencakup semua kasus praktis yang mungkin dengan bantuan mereka. </li><li>  Memeriksa antarmuka kernel dalam kondisi nyata - dengan mengimplementasikan fitur dasar di atas antarmuka yang menghadap sisi klien, Anda dipaksa untuk membuat antarmuka ini setidaknya sangat kuat sehingga dapat mendukung fitur-fitur ini.  Dengan demikian, Anda dapat yakin bahwa akan ada kemungkinan untuk membangun di atasnya hal serupa yang ditulis oleh pengembang pihak ketiga. </li><li>  Isolasi antar bagian sistem.  Peserta proyek dapat dengan mudah mencari paket yang mereka minati.  Paket dapat diversi, ditandai sebagai tidak diinginkan, atau diganti tanpa mempengaruhi kode inti. </li></ul><br>  Pendekatan ini biasanya dikaitkan dengan peningkatan kompleksitas.  Agar lebih mudah bagi pengguna untuk memulai, Anda dapat menyediakan mereka dengan paket pembungkus di mana "semuanya termasuk", tetapi cepat atau lambat mereka mungkin harus menyingkirkan shell ini dan menginstal dan mengkonfigurasi paket tambahan tertentu, yang kadang-kadang lebih sulit daripada hanya beralih ke fitur lain di perpustakaan monolitik. <br><br>  Dalam artikel ini, kami akan mencoba membahas opsi untuk mekanisme ekspansi yang mendukung "ekstensibilitas skala besar" dan memungkinkan Anda untuk membuat titik ekstensi baru di mana ini tidak disediakan. <br><br><h4>  Ekstensibilitas </h4><br>  Apa yang kita inginkan dari sistem yang dapat diperluas?  Pertama-tama, tentu saja, ia harus memiliki kemampuan untuk memperluas kemampuannya sendiri menggunakan kode eksternal. <br><br>  Tetapi ini hampir tidak cukup.  Biarkan saya ngelantur tentang satu masalah bodoh yang pernah saya temui.  Saya sedang mengembangkan editor kode.  Di salah satu versi editor ini sebelumnya, Anda bisa mengatur gaya untuk baris tertentu dalam kode klien.  Itu hebat - tata letak garis selektif. <br><br>  Kecuali untuk kasus ketika upaya untuk mengubah tampilan garis dilakukan segera dari dua bagian kode - dan upaya ini mulai berakhir.  Ekstensi kedua yang diterapkan pada baris menimpa gaya ekstensi pertama.  Atau, ketika kode pertama mencoba untuk menghapus desain yang dibuat di suatu tempat di bagian selanjutnya dari kode, itu menimpa gaya yang diperkenalkan oleh fragmen kode kedua. <br><br>  Kami berhasil menemukan solusi, memberikan kemampuan untuk menambah (dan menghapus) ekstensi, daripada mendefinisikannya, sehingga dua ekstensi dapat berinteraksi dengan baris yang sama tanpa menyabot pekerjaan masing-masing. <br><br>  Dalam arti yang lebih umum, perlu untuk memastikan bahwa ekstensi dapat digabungkan, bahkan jika mereka sama sekali tidak menyadari keberadaan satu sama lain - tanpa menyebabkan konflik di antara mereka. <br><br>  Untuk melakukan ini, Anda perlu memastikan bahwa sejumlah aktor dapat memengaruhi setiap titik ekspansi.  Bagaimana tepatnya beberapa efek akan diproses tergantung pada situasinya.  Berikut ini beberapa pendekatan yang mungkin berguna bagi Anda: <br><br><ul><li>  Semuanya mulai berlaku.  Misalnya, saat menambahkan kelas CSS ke elemen atau saat menampilkan widget, kedua fitur ini ditambahkan pada waktu yang bersamaan.  Seringkali, mereka masih harus disortir dalam beberapa cara: widget harus ditampilkan dalam urutan yang dapat diprediksi dan didefinisikan dengan baik. </li><li>  Mereka berbaris dalam bentuk konveyor.  Contohnya adalah pawang yang bisa memfilter perubahan yang ditambahkan ke dokumen sebelum dibuat.  Setiap perubahan pertama kali dimasukkan ke pawang, yang, pada gilirannya, juga dapat mengubahnya.  Memesan dalam hal ini tidak kritis, tetapi dapat membuat perbedaan. </li><li>  Anda dapat menerapkan pendekatan first-come-first-serve untuk penangan acara.  Setiap pawang memiliki kesempatan untuk melayani acara tersebut sampai salah satu dari mereka mengatakan bahwa mereka sudah menanganinya, setelah itu pawang yang berdiri dalam antrean untuk itu tidak lagi diinterogasi. </li><li>  Ini juga terjadi bahwa Anda benar-benar perlu memilih nilai tertentu - misalnya, menentukan nilai parameter konfigurasi tertentu.  Mungkin disarankan untuk menggunakan operator tertentu (katakanlah, logis dan, logis atau, minimum atau maksimum) untuk membatasi jumlah nilai input untuk satu posisi.  Misalnya, editor dapat beralih ke mode hanya baca jika ada ekstensi yang memesannya.  Anda dapat mengatur nilai maksimum dokumen, atau jumlah nilai minimum yang dilaporkan ke opsi ini. </li></ul><br>  Dalam banyak kasus seperti itu, ketertiban itu penting.  Ini berarti bahwa prioritas efek yang diterapkan harus dapat dikontrol dan diprediksi. <br><br>  Di front inilah sistem ekstensi imperatif yang didasarkan pada penggunaan efek samping biasanya tidak mampu mengatasinya.  Misalnya, operasi <code>addEventListener</code> dilakukan oleh model DOM peramban menyebabkan penangan peristiwa dipanggil persis sesuai urutan pendaftarannya.  Ini normal jika semua panggilan dikontrol oleh satu sistem, atau jika urutan operasi benar-benar tidak penting, namun, ketika Anda harus berurusan dengan banyak fragmen perangkat lunak yang secara independen menambahkan penangan, bisa sangat sulit untuk memprediksi yang mana dari mereka yang akan dipanggil. <br><br><h4>  Pendekatan sederhana </h4><br>  Untuk memberi Anda contoh sederhana: Saya pertama kali menerapkan strategi modular untuk ProseMirror, sebuah sistem untuk mengedit teks kaya.  Inti dari sistem ini sendiri, pada prinsipnya, tidak berguna - ini sepenuhnya bergantung pada paket tambahan yang menggambarkan struktur dokumen, kunci yang mengikat, memimpin sejarah pembatalan.  Meskipun ini agak sulit untuk menggunakan sistem ini, ia telah diadopsi dalam produk yang memerlukan desain teks khusus, yang tidak tersedia di editor klasik. <br><br>  Mekanisme ekstensi yang digunakan dalam ProseMirror relatif mudah.  Saat membuat editor, kode klien menunjukkan satu array objek yang terhubung.  Masing-masing plugin ini entah bagaimana dapat memengaruhi pekerjaan editor, misalnya, menambahkan potongan data status atau menangani acara antarmuka. <br><br>  Semua aspek ini dirancang untuk bekerja dengan berbagai nilai konfigurasi menggunakan strategi yang diuraikan di bagian sebelumnya.  Misalnya, ketika menentukan beberapa penugasan kunci, urutan instans plugin keymap ditentukan menentukan prioritasnya.  Keymap pertama yang tahu cara menanganinya menerima kunci spesifik dalam pemrosesan. <br><br>  Biasanya mekanisme ini cukup kuat, dan aktif digunakan.  Namun, pada tahap tertentu, menjadi rumit dan menjadi tidak nyaman untuk bekerja dengannya. <br><br><ul><li>  Jika plugin memiliki banyak efek, maka Anda dapat berharap bahwa dalam urutan itu mereka akan diterapkan ke plugin lain, atau Anda harus memecahnya menjadi plugin yang lebih kecil sehingga Anda dapat mengaturnya dengan benar. </li><li>  Secara umum, pengorganisasian plugin menjadi sangat sensitif, karena pengguna akhir tidak selalu mengerti plugin mana yang dapat memengaruhi operasi plugin lain jika mereka mendapatkan prioritas yang lebih tinggi.  Semua kesalahan biasanya muncul hanya pada saat runtime, ketika menggunakan fungsionalitas tertentu - karena itu, mereka mudah untuk dilewatkan. </li><li>  Plugin berdasarkan pada plugin lain harus mendokumentasikan fakta ini - dan masih diharapkan bahwa pengguna tidak akan lupa untuk mengaktifkan dependensi mereka (dalam urutan yang benar). </li></ul><br>  CodeMirror dalam <a href="">versi 6</a> adalah <a href="https://codemirror.net/">editor yang</a> ditulis ulang <a href="https://codemirror.net/">dengan nama yang sama</a> .  Dalam versi keenam, saya mencoba mengembangkan pendekatan modular.  Ini membutuhkan sistem ekstensi yang lebih ekspresif.  Mari kita lihat beberapa tantangan yang terkait dengan merancang sistem seperti itu. <br><br><h4>  Memesan </h4><br>  Sangat mudah untuk merancang sistem yang menyediakan kontrol penuh atas urutan ekstensi.  Tetapi sangat sulit untuk merancang sistem seperti itu, yang pada saat yang sama akan menyenangkan untuk digunakan dan memungkinkan Anda untuk menggabungkan kode ekstensi independen tanpa intervensi manual yang luas dan menyeluruh. <br><br>  Ketika datang ke pemesanan, itu menarik untuk menerapkan nilai-nilai prioritas.  Contoh serupa adalah properti <code>z-index</code> CSS, yang memungkinkan Anda menetapkan angka yang menunjukkan seberapa dalam item akan berada di tumpukan. <br><br>  Karena style sheet terkadang memiliki nilai <code>z-index</code> sangat besar, jelas bahwa cara menunjukkan prioritas ini bermasalah.  Modul tertentu secara individual â€œtidak tahuâ€ nilai prioritas mana yang mengindikasikan modul lain.  Opsi hanyalah titik dalam rentang angka yang tidak ditentukan.  Anda dapat menentukan nilai tinggi terlarang (atau nilai-nilai sangat negatif), berharap mencapai akhir skala ini, tetapi yang lainnya hanyalah permainan tebak-tebakan. <br><br>  Situasi ini dapat sedikit ditingkatkan dengan mendefinisikan sekumpulan terbatas kategori prioritas yang terdefinisi dengan jelas sehingga ekstensi dapat diklasifikasikan berdasarkan â€œlevelâ€ perkiraan prioritas mereka.  Tetapi Anda masih harus entah bagaimana memutuskan ikatan dalam kategori-kategori ini. <br><br><h4>  Pengelompokan dan Deduplikasi </h4><br>  Seperti yang saya sebutkan di atas, setelah Anda mulai serius mengandalkan ekstensi, situasi dapat muncul di mana beberapa ekstensi akan menggunakan yang lain.  Manajemen saling ketergantungan tidak skala dengan baik, jadi alangkah baiknya jika Anda bisa menarik sekelompok ekstensi sekaligus. <br><br>  Namun, tidak hanya itu, dalam hal ini, masalah pemesanan akan semakin memburuk;  masalah lain akan muncul.  Banyak ekstensi lain dapat bergantung pada ekstensi tertentu sekaligus, dan jika Anda menyatakannya sebagai nilai, maka situasi dengan beberapa unduhan dari ekstensi yang sama mungkin muncul.  Dalam beberapa kasus, misalnya, ketika menetapkan kunci atau menangani penangan acara, ini normal.  Di negara lain, misalnya, ketika melacak membatalkan riwayat atau bekerja dengan perpustakaan tooltip, pendekatan seperti itu akan menjadi pemborosan sumber daya dengan risiko melanggar sesuatu. <br><br>  Oleh karena itu, memungkinkan komposisi ekstensi, kami dipaksa untuk beralih ke bagian sistem ekstensi dari kompleksitas yang terkait dengan pengelolaan dependensi.  Anda harus dapat mengenali ekstensi yang tidak boleh diduplikasi, dan hanya mengunduh satu contoh dari masing-masing ekstensi tersebut. <br><br>  Namun, karena dalam kebanyakan kasus, ekstensi dapat dikonfigurasikan, dan semua contoh ekstensi tertentu akan agak berbeda satu sama lain, kami tidak dapat hanya mengambil satu contoh ekstensi dan menggunakannya - kami harus menggabungkannya dengan cara yang bermakna (atau melaporkan kesalahan, saat ini tidak memungkinkan). <br><br><h4>  Proyek </h4><br>  Di sini saya akan menjelaskan apa yang telah dilakukan di CodeMirror 6. Saya mengusulkan contoh ini sebagai solusi, dan bukan sebagai satu-satunya solusi yang benar.  Ada kemungkinan bahwa sistem ini akan berkembang lebih jauh saat perpustakaan stabil. <br><br>  Primitif utama dalam pendekatan ini disebut perilaku.  Perilaku hanyalah hal-hal yang dapat Anda kembangkan dengan menunjukkan nilai.  Sebagai contoh, perhatikan perilaku bidang negara, di mana dengan bantuan ekstensi Anda bisa menambahkan bidang baru, memberikan deskripsi setiap bidang.  Atau perilaku pengendali acara berbasis browser, tempat Anda dapat menambahkan penangan Anda sendiri menggunakan ekstensi. <br><br>  Dari sudut pandang perilaku konsumen, perilaku-perilaku yang dikonfigurasikan dalam contoh editor tertentu memberikan urutan nilai yang terurut, di mana nilai-nilai dengan prioritas lebih tinggi didahulukan.  Setiap perilaku memiliki tipe, dan nilai untuk itu harus cocok dengan tipe itu. <br><br>  <i>Perilaku</i> direpresentasikan sebagai nilai yang digunakan untuk mendeklarasikan instance dari perilaku dan untuk merujuk pada nilai-nilai yang mungkin dimiliki oleh perilaku tersebut.  Misalnya, ekstensi yang menentukan latar belakang nomor baris dapat menentukan perilaku yang memungkinkan kode lain untuk menambahkan penanda baru ke latar belakang ini. <br><br>  <i>Ekstensi</i> adalah nilai yang dapat digunakan saat mengonfigurasi editor.  Array ekstensi dilaporkan selama inisialisasi.  Setiap ekstensi diizinkan dalam perilaku nol atau lebih. <br><br>  Jenis ekstensi paling sederhana adalah contoh perilaku.  Dengan menetapkan nilai untuk perilaku ini, kami mendapatkan respons nilai ekstensi yang mengimplementasikan perilaku ini. <br>  Urutan ekstensi juga dapat dikelompokkan menjadi satu ekstensi.  Misalnya, dalam konfigurasi editor untuk bahasa pemrograman yang diberikan, sejumlah ekstensi lain dapat ditarik, khususnya, tata bahasa untuk parsing dan menyoroti bahasa, informasi tentang cara indentasi, dan juga sumber informasi tentang penyelesaian yang secara cerdas melengkapi kode dalam bahasa itu.  Jadi Anda mendapatkan ekstensi bahasa, yang hanya mengumpulkan semua ekstensi yang diperlukan yang memberikan nilai kumulatif. <br><br>  Menggambarkan versi sederhana dari sistem seperti itu, kita bisa berhenti di sini dan cukup memasukkan ekstensi bersarang ke dalam satu array ekstensi untuk perilaku.  Kemudian mereka dapat dikelompokkan berdasarkan jenis perilaku dan mendapatkan urutan nilai-nilai perilaku. <br><br>  Namun, kami masih belum menemukan deduplikasi, dan kami perlu kontrol lebih lengkap atas pemesanan. <br><br>  Nilai dari tipe ketiga termasuk <i>ekstensi unik</i> , ini adalah mekanisme untuk memastikan deduplikasi.  Ekstensi yang tidak ingin Anda instantiate dua kali di editor yang sama hanyalah itu.  Untuk mendefinisikan ekstensi seperti itu, tipe spesifikasi ditentukan, yaitu, tipe nilai konfigurasi yang diharapkan oleh konstruktor ekstensi, dan fungsi instantiasi yang mengambil larik nilai spek tersebut dan mengembalikan ekstensi. <br>  Ekstensi unik mempersulit proses penyelesaian koleksi ekstensi menjadi serangkaian perilaku.  Selama ada ekstensi unik dalam rangkaian ekstensi yang diselaraskan, mekanisme resolusi harus memilih jenis ekstensi unik, mengumpulkan semua instansinya, memanggil fungsi instantiasi dengan nilai speknya dan menggantinya dengan hasilnya (dalam satu contoh). <br><br>  (Ada satu halangan lagi - mereka harus diselesaikan dalam urutan tertentu. Jika Anda pertama-tama mengaktifkan ekstensi unik X, tetapi kemudian ekstensi Y memutuskan ke X lain, ini akan menjadi kesalahan, karena semua instance X harus digabungkan bersama. Karena instantiating ekstensi adalah operasi murni, sistem, dihadapkan dengan itu, menjalankannya dengan coba-coba, memulai kembali proses - dan merekam informasi yang diklarifikasi.) <br>  Akhirnya, mari kita bicara tentang prioritas.  Pendekatan dasar dalam hal ini adalah untuk menjaga urutan ekstensi dilaporkan.  Ekstensi majemuk disejajarkan dan dimasukkan ke dalam pesanan ini tepat pada posisi di mana mereka pertama kali bertemu.  Hasil penyelesaian ekstensi unik juga disisipkan di tempat pertama kali terjadi. <br><br>  Tetapi ekstensi dapat menetapkan beberapa subekstensi mereka ke kategori dengan prioritas berbeda.  Sistem menentukan jenis kategori tersebut: rollback (berlaku setelah hal-hal lain terjadi), secara default, memperluas (prioritas lebih tinggi daripada bulk) dan mendefinisikan ulang (mungkin harus ditempatkan di bagian paling atas).  Pemesanan aktual dilakukan pertama berdasarkan kategori, dan kemudian dengan posisi awal. <br><br>  Jadi, ekstensi dengan penugasan kunci prioritas rendah dan penangan acara dengan prioritas biasa dapat memberi kami ekstensi majemuk yang dibangun atas dasar ekstensi dengan penugasan utama (dalam hal ini, Anda tidak perlu tahu perilaku apa yang termasuk di dalamnya, dengan prioritas "kembalikan" ditambah contoh perilaku pengendali acara. <br><br>  Tampaknya, pencapaian utama adalah bahwa kami telah memperoleh kemampuan untuk menggabungkan ekstensi, terlepas dari apa yang dilakukan di dalamnya.  Dalam ekstensi yang telah kami modelkan sejauh ini, di antaranya: dua sistem parsing dengan perilaku sintaksis yang sama, penyorotan sintaksis, layanan indentasi pintar, riwayat pembatalan, latar belakang nomor baris, penutupan otomatis tanda kurung, penetapan kunci dan pemilihan ganda - semuanya bekerja dengan baik. <br><br>  Untuk menggunakan sistem seperti itu, Anda benar-benar harus menguasai beberapa konsep baru, dan itu jelas lebih rumit daripada sistem imperatif tradisional yang diterima dalam komunitas JavaScript (panggil metode untuk menambah / menghapus efek).  Namun, kemampuan untuk menautkan ekstensi dengan benar tampaknya membenarkan biaya ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484470/">https://habr.com/ru/post/id484470/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484458/index.html">Pekerja lepas ini rusak - beri saya yang berikutnya</a></li>
<li><a href="../id484462/index.html">Scraping Github: Mencari "Rahasia" untuk Dikembangkan</a></li>
<li><a href="../id484464/index.html">Lelang motor Jepang, bagaimana semua itu terjadi</a></li>
<li><a href="../id484466/index.html">Common JavaScript Menjanjikan Hal-Hal yang Harus Diketahui Semua Orang</a></li>
<li><a href="../id484468/index.html">Budaya perusahaan merah adalah masalah utama bisnis Rusia (Bagian 2)</a></li>
<li><a href="../id484472/index.html">Menggunakan asyncio untuk membuat driver perangkat asinkron di MicroPython v.1.12</a></li>
<li><a href="../id484480/index.html">Kapitalisasi 5 perusahaan teknologi AS terbesar melebihi $ 5 triliun</a></li>
<li><a href="../id484482/index.html">Program pendidikan kecil tentang pengolahan air</a></li>
<li><a href="../id484484/index.html">Ubuntu bukan desktop Linux terbaik</a></li>
<li><a href="../id484486/index.html">Komputer yang menolak mati</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>