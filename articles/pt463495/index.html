<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üà≥ üïö üßëüèª‚Äçü§ù‚Äçüßëüèª Cache do Laravel: o b√°sico, mais dicas e truques üòñ üë©üèº‚Äçüíª üöÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A t√©cnica de armazenamento em cache permite criar aplicativos mais escalon√°veis, armazenando os resultados de algumas consultas em um armazenamento r√°...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cache do Laravel: o b√°sico, mais dicas e truques</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463495/"><p>  A t√©cnica de armazenamento em cache permite criar aplicativos mais escalon√°veis, armazenando os resultados de algumas consultas em um armazenamento r√°pido na mem√≥ria.  No entanto, o cache implementado incorretamente pode prejudicar bastante a impress√£o do usu√°rio sobre o seu aplicativo.  Este artigo cont√©m alguns conceitos b√°sicos sobre armazenamento em cache, v√°rias regras e tabus que aprendi em v√°rios projetos anteriores. </p><br><h2 id="ne-ispolzuyte-keshirovanie">  N√£o use cache. </h2><br><p>  Seu projeto √© r√°pido e n√£o apresenta problemas de desempenho? <br>  Esque√ßa o cache.  S√©rio :) </p><br><p>  Isso complicar√° bastante as opera√ß√µes de leitura do banco de dados sem nenhum benef√≠cio. </p><br><p> √â verdade que Mohamed Said, no in√≠cio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">deste artigo,</a> faz alguns c√°lculos e prova que, em alguns casos, otimizar o aplicativo por milissegundos pode economizar uma tonelada de dinheiro em sua conta da AWS.  Portanto, se a economia projetada em seu projeto for superior a US $ 1,86, talvez o cache seja uma boa id√©ia. </p><a name="habracut"></a><br><h2 id="kak-eto-rabotaet">  Como isso funciona? </h2><br><p> Quando um aplicativo deseja obter alguns dados do banco de dados, por exemplo, a entidade Post por seu ID, ele gera uma chave de cache exclusiva para este caso ( <code>'post_' . $id</code> √© bastante adequado) e tenta encontrar o valor dessa chave no armazenamento r√°pido de valores-chave (memcache, redis ou outro).  Se o valor estiver l√°, o aplicativo o usar√°.  Caso contr√°rio, ele ser√° retirado do banco de dados e armazenado no cache por essa chave para uso futuro. </p><br><p><img src="https://habrastorage.org/webt/vd/9i/kj/vd9ikjg-gji5lauz1atmq9bkdpq.png"></p><br><p>  Manter esse valor no cache n√£o √© uma boa ideia para sempre, pois essa entidade Post pode ser atualizada, mas o aplicativo sempre receber√° o valor antigo em cache. <br>  Portanto, as fun√ß√µes de cache geralmente perguntam a que horas esse valor deve ser armazenado. </p><br><p>  Ap√≥s esse tempo expirar, o memcache ou o redis "esquecem" e o aplicativo recebe um novo valor do banco de dados. </p><br><p>  Um exemplo: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ $key = <span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id; $post = \Cache::get($key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($post === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { $post = Post::findOrFail($id); \Cache::put($key, $post, <span class="hljs-number"><span class="hljs-number">900</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post; }</code> </pre> <br><p>  Aqui, coloquei a entidade Post no cache por 15 minutos (desde a vers√£o 5.8, o laravel usa segundos neste par√¢metro, antes que houvesse minutos).  A fachada do <code>Cache</code> tamb√©m possui um m√©todo conveniente de <code>remember</code> para este caso.  Este c√≥digo faz exatamente a mesma coisa que o anterior: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::findOrFail($id); }); }</code> </pre> <br><p>  H√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">cap√≠tulo sobre cache na</a> documenta√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">do</a> Laravel que explica como instalar os drivers necess√°rios para o seu aplicativo e as principais funcionalidades. </p><br><h2 id="dannye-v-keshe">  Dados em cache </h2><br><p>  Todos os drivers Laravel padr√£o armazenam dados como seq√º√™ncias de caracteres.  Quando pedimos que voc√™ armazene em cache uma inst√¢ncia do modelo Eloquent, ele usa a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">serialize</a> para obter a string do objeto.  A fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unserialize</a> restaura o estado de um objeto quando o obtemos do cache. </p><br><p>  Quase todos os dados podem ser armazenados em cache.  N√∫meros, seq√º√™ncias de caracteres, matrizes, objetos (se eles puderem ser serializados corretamente, consulte as descri√ß√µes das fun√ß√µes pelos links anteriormente). </p><br><p>  Entidades e cole√ß√µes eloquentes podem ser facilmente armazenadas em cache e s√£o os valores mais populares no cache do aplicativo Laravel.  No entanto, o uso de outros tipos tamb√©m √© praticado amplamente.  O m√©todo <code>Cache::increment</code> √© popular para implementar v√°rios contadores.  Al√©m disso, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">bloqueios at√¥micos s√£o</a> bastante √∫teis quando os desenvolvedores est√£o enfrentando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">condi√ß√µes de corrida</a> . </p><br><h2 id="chto-keshirovat">  O que armazenar em cache? </h2><br><p>  Os primeiros candidatos ao cache s√£o solicita√ß√µes executadas com muita frequ√™ncia, mas seu plano de execu√ß√£o n√£o √© o mais f√°cil.  O melhor exemplo s√£o os 5 principais artigos da p√°gina principal ou as √∫ltimas not√≠cias.  Armazenar em cache esses valores pode melhorar muito o desempenho da p√°gina principal. </p><br><p>  Geralmente, a busca de entidades pelo id usando <code>Model::find($id)</code> √© muito r√°pida, mas se essa tabela estiver muito carregada com in√∫meras atualiza√ß√µes, insira e exclua consultas, reduzir o n√∫mero de consultas selecionadas dar√° uma boa tr√©gua ao banco de dados.  As entidades com relacionamentos <code>hasMany</code> que ser√£o carregadas toda vez tamb√©m s√£o boas candidatas ao cache.  Quando trabalhei em um projeto com mais de 10 milh√µes de visitantes por dia, armazenamos em cache quase qualquer solicita√ß√£o selecionada. </p><br><h2 id="invalidaciya-kesha">  Invalida√ß√£o de cache </h2><br><p>  A deteriora√ß√£o da chave ap√≥s um tempo especificado ajuda a atualizar os dados no cache, mas isso n√£o acontece imediatamente.  O usu√°rio pode alterar os dados, mas por algum tempo ele continuar√° vendo a vers√£o antiga deles no aplicativo.  O di√°logo habitual em um dos meus projetos anteriores: </p><br><pre> <code class="plaintext hljs">:   ,     ! : ,  15 ( ,  )...</code> </pre> <br><p>  Esse comportamento √© muito inconveniente para os usu√°rios, e a decis√£o √≥bvia de excluir dados antigos do cache quando os atualizamos rapidamente vem √† mente.  Esse processo √© chamado de defici√™ncia.  Para chaves simples como <code>"post_%id%"</code> , a <code>"post_%id%"</code> n√£o <code>"post_%id%"</code> muito dif√≠cil. </p><br><p>  Eventos eloquentes podem ajudar ou, se o seu aplicativo gerar eventos especiais como <code>PostPublished</code> ou <code>UserBanned</code> , pode ser ainda mais simples.  Exemplo com eventos Eloquent.  Primeiro voc√™ precisa criar classes de eventos.  Por conveni√™ncia, usarei uma classe abstrata para eles: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> Post */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $post; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Post $post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post = $post; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post; } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostSaved</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostDeleted</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span></span>{}</code> </pre> <br><p>  Obviamente, de acordo com o PSR-4, cada classe deve estar em seu pr√≥prio arquivo.  Configure a classe Post Eloquent (usando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">documenta√ß√£o</a> ): </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $dispatchesEvents = [ <span class="hljs-string"><span class="hljs-string">'saved'</span></span> =&gt; PostSaved::class, <span class="hljs-string"><span class="hljs-string">'deleted'</span></span> =&gt; PostDeleted::class, ]; }</code> </pre> <br><p>  Crie um ouvinte para estes eventos: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventServiceProvider</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $listen = [ PostSaved::class =&gt; [ ClearPostCache::class, ], PostDeleted::class =&gt; [ ClearPostCache::class, ], ]; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClearPostCache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PostEvent $event)</span></span></span><span class="hljs-function"> </span></span>{ \Cache::forget(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $event-&gt;getPost()-&gt;id); } }</code> </pre> <br><p>  Este c√≥digo remover√° os valores em cache ap√≥s cada atualiza√ß√£o ou exclus√£o das entidades Post.  A invalida√ß√£o de listas de entidades, como os cinco principais artigos ou as √∫ltimas not√≠cias, ser√° um pouco mais complicada.  Eu vi tr√™s estrat√©gias: </p><br><h3 id="strategiya-ne-invalidiruem">  N√£o desabilite a estrat√©gia </h3><br><p>  S√≥ n√£o toque nesses valores.  Normalmente, isso n√£o traz problemas.  Tudo bem que as novas not√≠cias apare√ßam na lista das √∫ltimas um pouco mais tarde (√© claro, se este n√£o for um grande portal de not√≠cias).  Mas, para alguns projetos, √© realmente importante ter novos dados nessas listas. </p><br><h3 id="strategiya-nayti-i-obezvredit">  Encontrar e desativar estrat√©gia </h3><br><p>  Cada vez que voc√™ atualiza uma publica√ß√£o, voc√™ pode tentar encontr√°-la nas listas em cache e, se houver, excluir esse valor em cache. </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopPosts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::<span class="hljs-comment"><span class="hljs-comment">/*   top-5*/</span></span>()-&gt;get(); }); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CheckAndClearTopPostsCache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PostEvent $event)</span></span></span><span class="hljs-function"> </span></span>{ $updatedPost = $event-&gt;getPost(); $posts = \Cache::get(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>, []); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($posts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $post) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($updatedPost-&gt;id == $post-&gt;id) { \Cache::forget(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } }</code> </pre> <br><p>  Parece feio, mas funciona. </p><br><h3 id="strategiya-hranit-id">  Estrat√©gia "ID da loja" </h3><br><p>  Se a ordem dos itens da lista n√£o for importante, apenas o ID das entradas poder√° ser armazenado no cache.  Depois de receber o id, voc√™ pode criar uma lista de chaves no formato <code>'post_'.$id</code> e obter todos os valores usando o m√©todo <code>Cache::many</code> , que obt√©m muitos valores do cache em uma solicita√ß√£o (isso tamb√©m √© chamado de multi get). </p><br><p>  A invalida√ß√£o do cache n√£o √© em v√£o denominada uma das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">duas dificuldades na programa√ß√£o</a> e √© muito dif√≠cil em alguns casos. </p><br><h2 id="keshirovanie-otnosheniy">  Cache de Relacionamento </h2><br><p>  Armazenar em cache entidades com relacionamentos requer maior aten√ß√£o. </p><br><pre> <code class="php hljs">$post = Post::findOrFail($id); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($post-&gt;comments...)</code> </pre> <br><p>  Este c√≥digo executa duas consultas <code>SELECT</code> .  Obtendo entidade por <code>id</code> e coment√°rios por <code>post_id</code> .  Implementamos o cache: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::findOrFail($id); }); } $post = getPost($id); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($post-&gt;comments...)</code> </pre> <br><p>  O primeiro pedido foi armazenado em cache e o segundo n√£o.  Quando o driver do cache grava Post no cache, os <code>comments</code> ainda n√£o s√£o carregados.  Se tamb√©m queremos armazen√°-los em cache, devemos carreg√°-los manualmente: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $post = Post::findOrFail($id); $post-&gt;load(<span class="hljs-string"><span class="hljs-string">'comments'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post; }); }</code> </pre> <br><p>  Agora, ambas as solicita√ß√µes est√£o armazenadas em cache, mas precisamos invalidar os valores de <code>'post_'.$id</code> toda vez que um coment√°rio √© adicionado.  N√£o √© muito eficiente, portanto, √© melhor armazenar o cache de coment√°rios separadamente: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPostComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Post $post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_comments_'</span></span> . $post-&gt;id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post-&gt;comments; }); } $post = getPost($id); $comments = getPostComments($post); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($comments...)</code> </pre> <br><p>  √Äs vezes, a ess√™ncia e a atitude est√£o fortemente conectadas entre si e s√£o sempre usadas juntas (ordem com detalhes, publica√ß√£o com tradu√ß√£o para o idioma desejado).  Nesse caso, armazen√°-los em um cache √© bastante normal. </p><br><h2 id="single-source-of-truth-dlya-klyuchey-keshirovaniya">  Fonte √∫nica de verdade para chaves de cache </h2><br><p>  Se o projeto implementa a invalida√ß√£o, as chaves de cache s√£o geradas em pelo menos dois locais: para chamar <code>Cache::get</code> / <code>Cache::remember</code> e para chamar <code>Cache::forget</code> .  J√° encontrei situa√ß√µes em que essa chave foi alterada em um lugar, mas n√£o em outro, e a incapacidade se rompeu.  O conselho usual para esses casos √© constante, mas as chaves de cache s√£o geradas dinamicamente, ent√£o eu uso classes especiais que geram chaves: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheKeys</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($postId)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $postId; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($postId)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'post_comments'</span></span> . $postId; } } \Cache::remember(CacheKeys::postById($id), <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $post = Post::findOrFail($id); }); <span class="hljs-comment"><span class="hljs-comment">// .... \Cache::forget(CacheKeys::postById($id));</span></span></code> </pre> <br><p>  A vida √∫til das chaves tamb√©m pode ser renderizada em constantes para melhor legibilidade.  Esses 900 ou 15 * 60 aumentam a carga cognitiva ao ler o c√≥digo. </p><br><h2 id="ne-ispolzuyte-kesh-v-operaciyah-zapisi">  N√£o use cache em opera√ß√µes de grava√ß√£o </h2><br><p>  Ao implementar opera√ß√µes de grava√ß√£o, como alterar o t√≠tulo ou o texto de uma publica√ß√£o, √© tentador usar o m√©todo <code>getPost</code> escrito anteriormente: </p><br><pre> <code class="php hljs">$post = getPost($id); $post-&gt;title = $newTitle; $post-&gt;save();</code> </pre> <br><p>  Por favor, n√£o fa√ßa isso.  O valor no cache pode estar desatualizado, mesmo se a invalida√ß√£o for feita corretamente.  Uma pequena condi√ß√£o de corrida e publica√ß√£o perder√° as altera√ß√µes feitas por outro usu√°rio.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Bloqueios otimistas</a> ajudar√£o pelo menos a n√£o perder altera√ß√µes, mas o n√∫mero de solicita√ß√µes erradas pode aumentar bastante. </p><br><p>  A melhor solu√ß√£o √© usar uma l√≥gica de sele√ß√£o de entidade completamente diferente para opera√ß√µes de leitura e grava√ß√£o (Ol√°, CQRS).  Nas opera√ß√µes de grava√ß√£o, voc√™ sempre precisa selecionar o valor mais recente no banco de dados.  E n√£o se esque√ßa dos bloqueios (otimistas ou pessimistas) para dados importantes. </p><br><p>  Eu acho que isso √© suficiente para um artigo introdut√≥rio.  O armazenamento em cache √© um t√≥pico muito complexo e demorado, com traps para desenvolvedores, mas o ganho de desempenho √†s vezes supera todas as dificuldades. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt463495/">https://habr.com/ru/post/pt463495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt463473/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 16. Trabalho em rede em um pequeno escrit√≥rio</a></li>
<li><a href="../pt463483/index.html">Colabora√ß√£o de documentos, bate-papo corporativo atualizado e aplicativo m√≥vel: O que h√° de novo no Zextras Suite 3.0</a></li>
<li><a href="../pt463489/index.html">O heavy metal mentiu: de fato, a m√∫sica pesada tem um efeito positivo na sa√∫de de seus f√£s</a></li>
<li><a href="../pt463491/index.html">A bizarra hist√≥ria de tradu√ß√£o em ingl√™s de Metal Gear Solid</a></li>
<li><a href="../pt463493/index.html">Mais estat√≠sticas do site em seu pequeno reposit√≥rio</a></li>
<li><a href="../pt463497/index.html">Calculadora de efici√™ncia de estoque e 5 raz√µes pelas quais as coisas d√£o errado</a></li>
<li><a href="../pt463499/index.html">Escrit√≥rio confort√°vel - ajuda a trabalhar ou interfere e distrai? Sidenis, Alternativa Games e FunBox responder√£o</a></li>
<li><a href="../pt463503/index.html">Por que o desenvolvimento web moderno √© t√£o complicado? Parte 1</a></li>
<li><a href="../pt463505/index.html">Por que os administradores de sistema devem se tornar engenheiros de DevOps</a></li>
<li><a href="../pt463507/index.html">Os rins s√£o a sa√≠da</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>