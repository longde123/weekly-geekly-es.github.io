<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßóüèæ ‚¨õÔ∏è üêä Transformation de code Android üÜô ü•ì üå≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Deuxi√®me partie 
 Au lieu de rejoindre 


 Tout a commenc√© avec le fait que je voulais apprendre les subtilit√©s des param√®tres Gradle, comprendre se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transformation de code Android</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469237/"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Deuxi√®me partie</a> </li></ul><br><h2 id="vmesto-vstupleniya">  Au lieu de rejoindre </h2><br><p>  Tout a commenc√© avec le fait que je voulais apprendre les subtilit√©s des param√®tres Gradle, comprendre ses capacit√©s dans le d√©veloppement Android (et en effet).  J'ai commenc√© avec le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cycle de vie</a> et les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livres</a> , j'ai progressivement √©crit des t√¢ches simples, j'ai essay√© de cr√©er mon premier plugin Gradle (dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">buildSrc</a> ) et puis √ßa a commenc√©. </p><br><p>  D√©cidant de faire quelque chose de proche du monde r√©el du d√©veloppement Android, il a √©crit un plugin qui analyse les fichiers de balisage XML de mise en page et cr√©e un objet Java avec des liens vers des vues.  Puis il s'est livr√© √† la transformation du manifeste de l'application (cela √©tait requis par la vraie t√¢che sur le brouillon de travail), car apr√®s la transformation, le manifeste a pris environ 5k lignes, et travailler dans l'EDI avec un tel fichier xml est assez difficile. </p><br><p>  J'ai donc compris comment g√©n√©rer du code et des ressources pour un projet Android, mais au fil du temps, je voulais quelque chose de plus.  Il y avait une id√©e qu'il serait cool de transformer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AST</a> (Abstract Syntax Tree) en temps de compilation comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groovy le</a> fait d√®s la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sortie de la bo√Æte</a> .  Une telle m√©taprogrammation ouvre de nombreuses possibilit√©s, il y aurait un fantasme. </p><br><p>  Pour que la th√©orie ne soit pas seulement une th√©orie, j'ai d√©cid√© de renforcer l'√©tude du sujet avec la cr√©ation de quelque chose d'utile pour le d√©veloppement Android.  La premi√®re chose qui m'est venue √† l'esprit a √©t√© la pr√©servation de l'√©tat lors de la recr√©ation des composants du syst√®me.  En gros, la sauvegarde des variables dans le Bundle est aussi simple que possible avec un passe-partout minimal. </p><a name="habracut"></a><br><h2 id="s-chego-nachat">  Par o√π commencer? </h2><br><ol><li>  Tout d'abord, vous devez comprendre comment acc√©der aux fichiers n√©cessaires dans le cycle de vie Gradle dans un projet Android, que nous transformerons ensuite. </li><li>  Deuxi√®mement, lorsque nous obtenons les fichiers n√©cessaires, nous devons comprendre comment les transformer correctement. </li></ol><br><p>  Commen√ßons dans l'ordre: </p><br><h3 id="poluchaem-dostup-k-faylam-v-moment-kompilyacii">  Acc√©der aux fichiers au moment de la compilation </h3><br><p> Puisque nous recevrons des fichiers au moment de la compilation, nous avons besoin d'un plugin Gradle qui interceptera les fichiers et traitera la transformation.  Le plugin dans ce cas est aussi simple que possible.  Mais d'abord, je vais vous montrer √† quoi <code>build.gradle</code> fichier du module <code>build.gradle</code> avec le plugin: </p><br><pre> <code class="plaintext hljs">apply plugin: 'java-gradle-plugin' apply plugin: 'groovy' dependencies { implementation gradleApi() implementation 'com.android.tools.build:gradle:3.5.0' implementation 'com.android.tools.build:gradle-api:3.5.0' implementation 'org.ow2.asm:asm:7.1' }</code> </pre> <br><ol><li>  <code>apply plugin: 'java-gradle-plugin'</code> dit qu'il s'agit d'un module avec un plugin grad. </li><li>  <code>apply plugin: 'groovy'</code> ce plugin est n√©cessaire pour pouvoir √©crire sur des grooves (peu importe ici, vous pouvez √©crire au moins Groovy, au moins Java, au moins Kotlin, tout ce que vous voulez).  J'√©tais √† l'origine habitu√© √† √©crire des plugins sur des grooves, car il a un typage dynamique et parfois il peut √™tre utile, et s'il n'est pas n√©cessaire, vous pouvez simplement mettre l'annotation <code>@TypeChecked</code> . </li><li>  <code>implementation gradleApi()</code> - connectez la d√©pendance de l'API Gradle afin d'avoir acc√®s √† <code>org.gradle.api.Plugin</code> , <code>org.gradle.api.Project</code> , etc. </li><li>  <code>'com.android.tools.build:gradle:3.5.0'</code> et <code>'com.android.tools.build:gradle-api:3.5.0'</code> sont n√©cessaires pour acc√©der aux entit√©s du plugin Android. </li><li>  Biblioth√®que <code>'com.android.tools.build:gradle-api:3.5.0'</code> pour transformer le bytecode, nous en reparlerons plus tard. </li></ol><br><p>  Passons au plugin lui-m√™me, comme je l'ai dit, c'est assez simple: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YourPlugin</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Project</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isAndroidApp = project.plugins.findPlugin(<span class="hljs-string"><span class="hljs-string">'com.android.application'</span></span>) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isAndroidLib = project.plugins.findPlugin(<span class="hljs-string"><span class="hljs-string">'com.android.library'</span></span>) != <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">null</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!isAndroidApp &amp;&amp; !isAndroidLib)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GradleException( <span class="hljs-string"><span class="hljs-string">"'com.android.application' or 'com.android.library' plugin required."</span></span> ) } BaseExtension androidExtension = project.extensions.findByType(BaseExtension.class) androidExtension.registerTransform(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> YourTransform()) } }</code> </pre> <br><p>  Commen√ßons par <code>isAndroidApp</code> et <code>isAndroidLib</code> , ici nous v√©rifions simplement qu'il s'agit d'un projet / biblioth√®que Android, sinon, lan√ßons une exception.  Ensuite, enregistrez <code>YourTransform</code> dans le plugin Android via <code>androidExtension</code> .  <code>YourTransform</code> est une entit√© permettant d'obtenir l'ensemble de fichiers n√©cessaire et leur √©ventuelle transformation; il doit h√©riter de la classe abstraite <code>com.android.build.api.transform.Transform</code> . </p><br><p>  Passons directement √† <code>YourTransform</code> , consid√©rons d'abord les principales m√©thodes √† red√©finir: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YourTransform</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Transform</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> YourTransform.simpleName } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> Set&lt;QualifiedContent.ContentType&gt; getInputTypes() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TransformManager.CONTENT_CLASS } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> Set&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> QualifiedContent.Scope&gt; getScopes() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TransformManager.PROJECT_ONLY } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIncremental</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } }</code> </pre> <br><ul><li>  <code>getName</code> - ici, vous devez renvoyer le nom qui sera utilis√© pour la t√¢che de transformation, par exemple, pour l'assemblage de d√©bogage dans ce cas, la t√¢che sera appel√©e comme ceci: <code>transformClassesWithYourTransformForDebug</code> . </li><li>  <code>getInputTypes</code> - indiquez les types qui nous int√©ressent: classes, ressources ou les deux (voir <code>com.android.build.api.transform.QualifiedContent.DefaultContentType</code> ).  Si vous sp√©cifiez CLASSES, pour la transformation, nous n'obtiendrons que les fichiers de classe, dans ce cas, ils nous int√©ressent. </li><li>  <code>getScopes</code> - indiquez quelles √©tendues nous allons transformer (voir <code>com.android.build.api.transform.QualifiedContent.Scope</code> ).  Les √©tendues sont l'√©tendue des fichiers.  Par exemple, dans mon cas, c'est PROJECT_ONLY, ce qui signifie que nous transformerons uniquement les fichiers li√©s au module de projet.  Ici, vous pouvez √©galement inclure des sous-modules, des biblioth√®ques, etc. </li><li>  <code>isIncremental</code> - ici, nous indiquons au plug-in Android si notre transformation prend en charge l'assemblage incr√©mentiel: si vrai, nous devons r√©soudre correctement tous les fichiers modifi√©s, ajout√©s et supprim√©s, et si faux, tous les fichiers voleront vers la transformation, cependant, s'il n'y a eu aucun changement dans le projet , alors la transformation ne sera pas appel√©e. </li></ul><br><p>  Rest√© le plus basique et le plus <del>  doux </del>  m√©thode dans laquelle la transformation des fichiers de transformation <code>transform(TransformInvocation transformInvocation)</code> aura lieu.  Malheureusement, je n'ai pas pu trouver d'explication normale sur la fa√ßon de travailler correctement avec cette m√©thode, je n'ai trouv√© que des articles chinois et quelques exemples sans explications particuli√®res, <a href="">voici l'</a> une des options. </p><br><p>  Ce que j'ai compris en √©tudiant comment travailler avec un transformateur: </p><br><ol><li>  Tous les transformateurs sont raccord√©s au processus d'assemblage de la cha√Æne.  Autrement dit, vous √©crivez la logique qui sera <del>  press√© </del>  dans un processus d√©j√† √©tabli.  Apr√®s votre transformateur, un autre fonctionnera, etc. </li><li>  <strong>TR√àS IMPORTANT:</strong> m√™me si vous ne pr√©voyez pas de transformer un fichier, par exemple, vous ne voulez pas changer les fichiers jar qui vous arriveront, ils doivent toujours √™tre copi√©s dans votre r√©pertoire de sortie sans changer.  Cet article d√©coule du premier.  Si vous ne transf√©rez pas le fichier le long de la cha√Æne vers un autre transformateur, le fichier n'existera tout simplement pas. </li></ol><br><p>  Consid√©rez √† quoi devrait ressembler la m√©thode de transformation: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TransformInvocation transformInvocation )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> TransformException, InterruptedException, IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.transform(transformInvocation) transformInvocation.outputProvider.deleteAll() transformInvocation.inputs.each { transformInput -&gt; transformInput.directoryInputs.each { directoryInput -&gt; File inputFile = directoryInput.getFile() File destFolder = transformInvocation.outputProvider.getContentLocation( directoryInput.getName(), directoryInput.getContentTypes(), directoryInput.getScopes(), Format.DIRECTORY ) transformDir(inputFile, destFolder) } transformInput.jarInputs.each { jarInput -&gt; File inputFile = jarInput.getFile() File destFolder = transformInvocation.outputProvider.getContentLocation( jarInput.getName(), jarInput.getContentTypes(), jarInput.getScopes(), Format.JAR ) FileUtils.copyFile(inputFile, destFolder) } } }</code> </pre> <br><p>  √Ä notre entr√©e se trouve <code>TransformInvocation</code> , qui contient toutes les informations n√©cessaires pour d'autres transformations.  Tout d'abord, nous nettoyons le r√©pertoire dans lequel les nouveaux fichiers <code>transformInvocation.outputProvider.deleteAll()</code> seront enregistr√©s, ceci est fait, car le transformateur ne prend pas en charge l'assemblage incr√©mentiel et vous devez supprimer les anciens fichiers avant la transformation. </p><br><p>  Ensuite, nous passons en revue toutes les entr√©es et dans chaque entr√©e, nous passons en revue les r√©pertoires et les fichiers jar.  Vous remarquerez peut-√™tre que tous les fichiers jar sont simplement copi√©s pour aller plus loin au prochain transformateur.  De plus, la copie doit avoir lieu dans le r√©pertoire de votre <code>build/intermediates/transforms/YourTransform/...</code> transformateur <code>build/intermediates/transforms/YourTransform/...</code>  Le r√©pertoire correct peut √™tre obtenu √† l'aide de <code>transformInvocation.outputProvider.getContentLocation</code> . </p><br><p>  Consid√©rons une m√©thode qui extrait d√©j√† des fichiers sp√©cifiques pour modification: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformDir</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File input, File dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dest.exists()) { FileUtils.forceDelete(dest) } FileUtils.forceMkdir(dest) String srcDirPath = input.getAbsolutePath() String destDirPath = dest.getAbsolutePath() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (File file : input.listFiles()) { String destFilePath = file.absolutePath.replace(srcDirPath, destDirPath) File destFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(destFilePath) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.isDirectory()) { transformDir(file, destFile) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.isFile()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.name.endsWith(<span class="hljs-string"><span class="hljs-string">".class"</span></span>) &amp;&amp; !file.name.endsWith(<span class="hljs-string"><span class="hljs-string">"R.class"</span></span>) &amp;&amp; !file.name.endsWith(<span class="hljs-string"><span class="hljs-string">"BuildConfig.class"</span></span>) &amp;&amp; !file.name.contains(<span class="hljs-string"><span class="hljs-string">"R\$"</span></span>)) { transformSingleFile(file, destFile) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { FileUtils.copyFile(file, destFile) } } } }</code> </pre> <br><p>  √Ä l'entr√©e, nous obtenons le r√©pertoire avec le code source et le r√©pertoire o√π vous souhaitez √©crire les fichiers modifi√©s.  Nous parcourons r√©cursivement tous les r√©pertoires et obtenons les fichiers de classe.  Avant la transformation, il y a encore une petite v√©rification qui vous permet d'√©liminer les classes suppl√©mentaires. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.name.endsWith(<span class="hljs-string"><span class="hljs-string">".class"</span></span>) &amp;&amp; !file.name.endsWith(<span class="hljs-string"><span class="hljs-string">"R.class"</span></span>) &amp;&amp; !file.name.endsWith(<span class="hljs-string"><span class="hljs-string">"BuildConfig.class"</span></span>) &amp;&amp; !file.name.contains(<span class="hljs-string"><span class="hljs-string">"R\$"</span></span>)) { transformSingleFile(file, destFile) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { FileUtils.copyFile(file, destFile) }</code> </pre> <br><p>  Nous sommes donc arriv√©s √† la m√©thode <code>transformSingleFile</code> , qui coule d√©j√† dans le deuxi√®me paragraphe de notre plan d'origine </p><br><blockquote>  Deuxi√®mement, lorsque nous obtenons les fichiers n√©cessaires, nous devons comprendre comment les transformer correctement. </blockquote><br><h3 id="transformaciya-vo-vsey-ee-krase">  La transformation dans toute sa splendeur </h3><br><p>  Pour une transformation moins pratique des fichiers de classe r√©sultants, il existe plusieurs biblioth√®ques: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javassist</a> , qui vous permet de modifier √† la fois le bytecode et le code source (il n'est pas n√©cessaire de plonger dans l'√©tude du bytecode) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ASM</a> , qui vous permet de modifier uniquement le bytecode et poss√®de 2 API diff√©rentes. </p><br><p>  J'ai opt√© pour ASM, car il √©tait int√©ressant de plonger dans la structure du bytecode et, en plus, l'API Core analyse les fichiers sur la base du principe de l'analyseur SAX, ce qui garantit des performances √©lev√©es. </p><br><p>  La m√©thode <code>transformSingleFile</code> peut varier en fonction de l'outil de modification de fichier s√©lectionn√©.  Dans mon cas, cela semble assez simple: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String inputPath, String outputPath)</span></span></span><span class="hljs-function"> </span></span>{ FileInputStream is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(inputPath) ClassReader classReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassReader(is) ClassWriter classWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassWriter(ClassWriter.COMPUTE_FRAMES) StaterClassVisitor adapter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaterClassVisitor(classWriter) classReader.accept(adapter, ClassReader.EXPAND_FRAMES) <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> [] newBytes = classWriter.toByteArray() FileOutputStream fos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(outputPath) fos.write(newBytes) fos.close() }</code> </pre> <br><p>  Nous cr√©ons <code>ClassReader</code> pour lire un fichier, nous cr√©ons <code>ClassWriter</code> pour √©crire un nouveau fichier.  J'utilise ClassWriter.COMPUTE_FRAMES pour calculer automatiquement les cadres de pile, car j'ai plus ou moins trait√© avec les sections locales et Args_size (terminologie de bytecode), mais je n'ai pas encore fait grand-chose avec les cadres.  Le calcul automatique des images est un peu plus lent que le fait manuellement. <br>  Cr√©ez ensuite votre <code>StaterClassVisitor</code> qui h√©rite de <code>ClassVisitor</code> et transmet classWriter.  Il s'av√®re que notre logique de modification de fichier est superpos√©e au-dessus du ClassWriter standard.  Dans la biblioth√®que ASM, toutes les entit√©s <code>Visitor</code> sont construites de cette mani√®re.  Ensuite, nous formons un tableau d'octets pour le nouveau fichier et g√©n√©rons le fichier. </p><br><p>  De plus amples d√©tails sur mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application pratique de la</a> th√©orie √©tudi√©e seront fournis. </p><br><h4 id="sohranenie-sostoyaniya-v-bundle-s-pomoschyu-annotacii">  Enregistrement de l'√©tat dans le groupe √† l'aide d'annotations </h4><br><p>  Donc, je me suis fix√© pour t√¢che de se d√©barrasser autant que possible du passe-partout de stockage de donn√©es lors de la recr√©ation de l'activit√©.  Je voulais tout faire comme √ßa: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivityJava</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> savedInt = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Mais pour l'instant, afin de maximiser l'efficacit√©, je l'ai fait (je vais vous dire pourquoi): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Stater</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivityJava</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(StateType.INT) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> savedInt = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Et √ßa marche vraiment!  Apr√®s la transformation, le code <code>MainActivityJava</code> ressemble √† ceci: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Stater</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivityJava</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(StateType.INT) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> savedInt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.savedInt = savedInstanceState.getInt(<span class="hljs-string"><span class="hljs-string">"com/example/stater/MainActivityJava_savedInt"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSaveInstanceState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Bundle outState)</span></span></span><span class="hljs-function"> </span></span>{ outState.putInt(<span class="hljs-string"><span class="hljs-string">"com/example/stater/MainActivityJava_savedInt"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.savedInt); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onSaveInstanceState(outState); }</code> </pre> <br><p>  L'id√©e est tr√®s simple, passons √† l'impl√©mentation. <br>  L'API Core ne vous permet pas d'avoir la structure compl√®te de l'ensemble du fichier de classe, nous devons obtenir toutes les donn√©es n√©cessaires dans certaines m√©thodes.  Si vous regardez <code>StaterClassVisitor</code> , vous pouvez voir que dans la m√©thode de <code>visit</code> , nous obtenons des informations sur la classe, dans <code>StaterClassVisitor</code> nous v√©rifions si notre classe est marqu√©e avec l'annotation <code>@Stater</code> . </p><br><p>  Ensuite, notre <code>ClassVisitor</code> parcourt tous les champs de la classe, en appelant la m√©thode <code>visitField</code> , si la classe doit √™tre transform√©e, notre <code>StaterFieldVisitor</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">FieldVisitor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> access, String name, String descriptor, String signature, Object value)</span></span></span><span class="hljs-function"> </span></span>{ FieldVisitor fv = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.visitField(access, name, descriptor, signature, value) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needTransform) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaterFieldVisitor(fv, name, descriptor, owner) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fv }</code> </pre> <br><p>  <code>StaterFieldVisitor</code> v√©rifie l'annotation <code>@State</code> et, √† son tour, renvoie <code>StateAnnotationVisitor</code> dans la m√©thode <code>visitAnnotation</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">AnnotationVisitor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitAnnotation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String descriptor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible)</span></span></span><span class="hljs-function"> </span></span>{ AnnotationVisitor av = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.visitAnnotation(descriptor, visible) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (descriptor == Descriptors.STATE) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateAnnotationVisitor(av, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.descriptor, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.owner) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> av }</code> </pre> <br><p>  Qui forme d√©j√† une liste de champs n√©cessaires √† la sauvegarde / restauration: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitEnum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String descriptor, String value)</span></span></span><span class="hljs-function"> </span></span>{ String typeString = (String) value SaverField field = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SaverField(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.descriptor, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.owner, StateType.valueOf(typeString)) Const.stateFields.add(field) <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.visitEnum(name, descriptor, value) }</code> </pre> <br><p>  Il s'av√®re que la structure arborescente de nos visiteurs, qui, en cons√©quence, forment une liste de <code>SaverField</code> SaverField avec toutes les informations dont nous avons besoin pour g√©n√©rer un √©tat de sauvegarde. <br>  Ensuite, notre <code>ClassVisitor</code> commence √† parcourir les m√©thodes et √† transformer <code>onCreate</code> et <code>onSaveInstanceState</code> .  Si aucune m√©thode n'est trouv√©e, alors dans <code>visitEnd</code> (appel√©e apr√®s avoir pass√© la classe enti√®re), elles sont g√©n√©r√©es √† partir de z√©ro. </p><br><h4 id="gde-zhe-baytkod">  O√π est le bytecode? </h4><br><p>  La partie la plus int√©ressante commence dans les classes <code>OnCreateVisitor</code> et <code>OnSavedInstanceStateVisitor</code> .  Pour une modification correcte du bytecode, il est n√©cessaire de repr√©senter au moins l√©g√®rement sa structure.  Toutes les m√©thodes et opcodes d'ASM sont tr√®s similaires aux instructions r√©elles du batcode, cela vous permet de fonctionner avec les m√™mes concepts. <br>  Prenons un exemple de modification de la m√©thode <code>onCreate</code> et comparez-le avec le code g√©n√©r√©: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.savedInt = savedInstanceState.getInt(<span class="hljs-string"><span class="hljs-string">"com/example/stater/MainActivityJava_savedInt"</span></span>); }</code> </pre> <br><p>  La v√©rification d'un paquet pour z√©ro est li√©e aux instructions suivantes: </p><br><pre> <code class="java hljs">Label l1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label() mv.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number"><span class="hljs-number">1</span></span>) mv.visitJumpInsn(Opcodes.IFNULL, l1) <span class="hljs-comment"><span class="hljs-comment">//...      mv.visitLabel(l1)</span></span></code> </pre> <br><p>  En termes simples: </p><br><ol><li>  Cr√©ez une √©tiquette l1 (juste une √©tiquette √† laquelle vous pouvez aller). </li><li>  Nous chargeons en m√©moire la variable de r√©f√©rence avec l'index 1. Puisque l'index 0 correspond toujours √† la r√©f√©rence √† ceci, alors dans ce cas 1 est la r√©f√©rence au <code>Bundle</code> dans l'argument. </li><li>  La v√©rification z√©ro elle-m√™me et l'instruction goto sur l'√©tiquette l1.  <code>visitLabel(l1)</code> sp√©cifi√© apr√®s avoir travaill√© avec le bundle. </li></ol><br><p>  Lorsque vous travaillez avec le bundle, nous <code>PUTFIELD</code> la liste des champs g√©n√©r√©s et appelons l'instruction <code>PUTFIELD</code> - affectation √† une variable.  Regardons le code: </p><br><pre> <code class="java hljs">mv.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number"><span class="hljs-number">0</span></span>) mv.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number"><span class="hljs-number">1</span></span>) mv.visitLdcInsn(field.key) <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> StateType type = MethodDescriptorUtils.primitiveIsObject(field.descriptor) ? StateType.SERIALIZABLE : field.type MethodDescriptor methodDescriptor = MethodDescriptorUtils.getDescriptorByType(type, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodDescriptor == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !methodDescriptor.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"StateType for ${field.name} in ${field.owner} is unknown!"</span></span>) } mv.visitMethodInsn( Opcodes.INVOKEVIRTUAL, Types.BUNDLE, methodDescriptor.method, <span class="hljs-string"><span class="hljs-string">"(${Descriptors.STRING})${methodDescriptor.descriptor}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// cast if (type == StateType.SERIALIZABLE || type == StateType.PARCELABLE || type == StateType.PARCELABLE_ARRAY || type == StateType.IBINDER ) { mv.visitTypeInsn(Opcodes.CHECKCAST, Type.getType(field.descriptor).internalName) } mv.visitFieldInsn(Opcodes.PUTFIELD, field.owner, field.name, field.descriptor)</span></span></code> </pre> <br><p>  <code>MethodDescriptorUtils.primitiveIsObject</code> - ici, nous v√©rifions que la variable a un type wrapper, si c'est le cas, consid√©rez le type de variable comme <code>Serializable</code> .  Ensuite, le getter du bundle est appel√©, cast√© si n√©cessaire et affect√© √† une variable. </p><br><p>  C'est tout, la g√©n√©ration de code dans la m√©thode <code>onSavedInstanceState</code> se produit de la m√™me mani√®re, par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Quels probl√®mes avez-vous rencontr√©s</b> <div class="spoiler_text"><ol><li>  Le premier accroc qui a <code>@Stater</code> annotation <code>@Stater</code> .  Votre activit√© / fragment peut √™tre h√©rit√© d'une certaine <code>BaseActivity</code> , ce qui complique grandement la compr√©hension de l'enregistrement ou non d'un √©tat.  Vous devrez parcourir tous les parents de cette classe pour d√©couvrir que c'est vraiment une activit√©.  Il peut √©galement r√©duire les performances du compilateur (√† l'avenir, il y a une id√©e pour se d√©barrasser de l'annotation <code>@Stater</code> plus efficacement). </li><li>  La raison de la sp√©cification explicite de <code>StateType</code> est la m√™me que la raison du premier accroc.  Vous devez analyser davantage la classe pour comprendre qu'elle est <code>Parcelable</code> ou <code>Serializable</code> .  Mais les plans ont d√©j√† des id√©es pour se d√©barrasser de <code>StateType</code> :). </li></ol></div></div><br><h4 id="nemnogo-o-proizvoditelnosti">  Un peu de performance </h4><br><p>  Pour v√©rification, j'ai cr√©√© 10 activations, chacune avec 46 champs stock√©s de diff√©rents types, v√©rifi√©s sur la commande <code>./gradlew :app:clean :app:assembleDebug</code> .  Le temps pris par ma transformation varie de 108 √† 200 ms. </p><br><h4 id="sovety">  Astuces </h4><br><ul><li><p>  Si vous souhaitez <code>TraceClassVisitor</code> le bytecode r√©sultant, vous pouvez connecter <code>TraceClassVisitor</code> (fourni par ASM) √† votre processus de transformation: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String inputPath, String outputPath)</span></span></span><span class="hljs-function"> </span></span>{ ... TraceClassVisitor traceClassVisitor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TraceClassVisitor(classWriter, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(System.out)) StaterClassVisitor adapter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaterClassVisitor(traceClassVisitor) ... }</code> </pre> <br><p>  <code>TraceClassVisitor</code> ce cas, <code>TraceClassVisitor</code> √©crira sur la console l'int√©gralit√© du bytecode des classes qui l'ont travers√©, un utilitaire tr√®s pratique au stade du d√©bogage. </p><br></li><li><p>  Si le bytecode est incorrectement modifi√©, des erreurs tr√®s incompr√©hensibles surviennent, donc si possible, cela vaut la peine d'enregistrer des sections potentiellement dangereuses du code ou de g√©n√©rer vos exceptions. </p><br></li></ul><br><h2 id="podytozhim">  Pour r√©sumer </h2><br><p>  La modification du code source est un outil puissant.  Avec lui, vous pouvez mettre en ≈ìuvre de nombreuses id√©es.  Les cadres Proguard, Realm, Robolectric et autres fonctionnent sur ce principe.  L'AOP est √©galement possible pr√©cis√©ment gr√¢ce √† la transformation de code. <br>  Et la connaissance de la structure du bytecode permet au d√©veloppeur de comprendre √† la fin ce que le code qu'il a √©crit est compil√©.  Et lors de la modification, il n'est pas n√©cessaire de penser dans quelle langue le code est √©crit, en Java ou en Kotlin, mais de modifier directement le bytecode. </p><br><p>  Ce sujet m'a sembl√© tr√®s int√©ressant, les principales difficult√©s ont √©t√© rencontr√©es lors du d√©veloppement de l'API Transform de Google, car elles ne plaisent pas avec une documentation et des exemples sp√©ciaux.  ASM, contrairement √† l'API Transform, poss√®de une excellente documentation, un guide tr√®s d√©taill√© sous la forme d'un fichier pdf de 150 pages.  Et, comme les m√©thodes du framework sont tr√®s similaires aux instructions r√©elles de bytecode, le guide est doublement utile. </p><br><p>  Je pense √† ce sujet mon immersion dans la transformation, le bytecode, et ce n'est pas fini, je vais continuer √† √©tudier et, peut-√™tre, √† √©crire autre chose. </p><br><h2 id="ssylki">  Les r√©f√©rences </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemple Github</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ASM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article Habr sur le bytecode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un peu plus sur le bytecode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API de transformation</a> <br>  Eh bien, en lisant la documentation </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469237/">https://habr.com/ru/post/fr469237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469223/index.html">R√©tro√©clairage LED comme porte d√©rob√©e</a></li>
<li><a href="../fr469229/index.html">Le projet des clubs de robotique ¬´GoROBO¬ª - une startup de l'acc√©l√©rateur de l'Universit√© ITMO</a></li>
<li><a href="../fr469231/index.html">Soir√©e conf√©rence Game Design</a></li>
<li><a href="../fr469233/index.html">L'authentification Habr Weekly # 20 / 2FA n'est pas une panac√©e, Android 10 Go pour l'histoire la plus faible, jQuery, le film Gates</a></li>
<li><a href="../fr469235/index.html">Troldesh dans un nouveau masque: la prochaine vague de distribution de masse du virus ransomware</a></li>
<li><a href="../fr469245/index.html">Solstice d√©veloppe l'id√©e de projets de groupe pour obtenir de l'√©nergie solaire √† partir des toits des maisons</a></li>
<li><a href="../fr469249/index.html">Nitter, une interface alternative pour Twitter</a></li>
<li><a href="../fr469253/index.html">Combien co√ªte l'application √† construire</a></li>
<li><a href="../fr469257/index.html">Nous int√©grons des commandes Linux dans Windows √† l'aide de PowerShell et WSL</a></li>
<li><a href="../fr469259/index.html">Changement climatique: nous analysons la temp√©rature dans diff√©rentes villes au cours des 100 derni√®res ann√©es</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>