<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌶️ 🌬️ 👞 编程理论：变体 🛅 🧒 🐶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您好，我叫Dmitry Karlovsky，我...想告诉您类型系统的基本特性，这种类型特性通常是或根本不被理解，或者由于特定语言的实现而被误解了，由于发展的演变，该语言具有许多缺陷。 因此，即使您认为自己知道什么是“变异”，也请尝试以全新的方式看待问题。 我们将从最基础的内容入手，因此即使是初学者...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>编程理论：变体</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477448/"><p>您好，我叫Dmitry Karlovsky，我...想告诉您类型系统的基本特性，这种类型特性通常是或根本不被理解，或者由于特定语言的实现而被误解了，由于发展的演变，该语言具有许多缺陷。 因此，即使您认为自己知道什么是“变异”，也请尝试以全新的方式看待问题。 我们将从最基础的内容入手，因此即使是初学者也可以理解所有内容。 而且我们会继续用水，因此，即使专业人士也将对他们的知识构成有用。 代码示例将使用类似于TypeScript的伪语言。 然后将研究几种实际语言的方法。 而且，如果您正在开发自己的语言，那么本文将帮助您不要踩别人的耙子。 </p><br><p><img src="https://habrastorage.org/webt/uz/yw/ly/uzywlybdb47qium0-khvukslzwc.png" alt="如果有狐狸怎么办？"></p><a name="habracut"></a><br><h1 id="argumenty-i-parametry"> 参数和参数 </h1><br><p>  <strong>参数</strong>是我们接受的。 描述参数的类型时，我们对可以传递给我们的类型集设置了限制。 一些例子： </p><br><pre><code class="plaintext hljs">//   function log( id : string | number ) {} //   class Logger { constructor( readonly id : Natural ) {} } //   class Node&lt; Id extends Number &gt; { id : Id }</code> </pre> <br><p>  <strong>一个论点</strong>就是我们传递的。 在传输时，参数始终具有某些特定类型。 但是，在静态分析中，可能不知道特定类型，这就是为什么编译器会再次在类型限制下运行。 一些例子： </p><br><pre> <code class="plaintext hljs">log( 123 ) //   new Logger( promptStringOrNumber( 'Enter id' ) ) //       new Node( 'root' ) //   ,  </code> </pre> <br><h1 id="podtipy"> 亚型 </h1><br><p> 类型可以形成层次结构。  <em>子类型</em>是<em>超类型</em>的特例。 可以通过<strong>缩小</strong>超类型的可能值<strong>的</strong>集合来形成子类型。 例如，自然类型是整数和正数的子类型。 并且这三个都是同时的Real的子类型。  Prime类型是上述所有类型的子类型。 同时，Positive和Integer类型是重叠的，但是没有一个会约束另一个。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ca8/220/c10/ca8220c10205146b59dc7f9b4a479c4b.png" alt="图片"></p><br><p> 形成子类型的另一种方法是通过将其与与它正交的另一种类型组合<strong>来扩展</strong>它。 例如，存在一个具有“颜色”属性的“彩色图形”，而存在一个具有“高度”属性的“正方形”。 通过组合这些类型，我们得到一个“颜色方块”。 加上一个带有“半径”的“圆”，我们可以得到一个“色筒”。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/484/181/21d/48418121d846dc7aa19d4cd7472638c6.png" alt="图片"></p><br><h1 id="ierarhii"> 层次结构 </h1><br><p> 为了进一步叙述，我们需要一个小的动物层次结构和一个类似的细胞层次结构。 </p><br><pre> <code class="plaintext hljs">abstract class Animal {} abstract class Pet extends Animal {} class Cat extends Pet {} class Dog extends Pet {} class Fox extends Animal {} class AnimalCage { content : Animal } class PetCage extends AnimalCage { content : Pet } class CatCage extends PetCage { content : Cat } class DogCage extends PetCage { content : Dog } class FoxCage extends AnimalCage { content : Fox }</code> </pre> <br><p> 下面的所有内容都是上面类型的缩小范围。 带宠物的笼子只能容纳家畜，而不能容纳野生动物。 带狗的笼子只能容纳狗。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/397/a01/046/397a01046371d0316d2231db9771de24.png" alt="图片"></p><br><h1 id="kovariantnost"> 协方差 </h1><br><p> 最简单和最容易理解的是对<strong>超类型</strong>或协方差的<strong>限制</strong> 。 在以下示例中，功能参数与为其指定的类型协变。 也就是说，函数既可以接受此类型本身也可以接受其任何子类型，但不能接受超类型或其他类型。 </p><br><pre> <code class="plaintext hljs">function touchPet( cage : PetCage ) : void { log( `touch ${cage.content}` ) } touchPet( new AnimalCage ) // forbid touchPet( new PetCage ) // allow touchPet( new CatCage ) // allow touchPet( new DogCage ) // allow touchPet( new FoxCage ) // forbid</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/a68/94b/667/a6894b667d46336844466ff63a972011.png" alt="图片"></p><br><p> 由于我们不更改笼子中的任何东西，因此我们可以安全地将功能转移给带猫的笼子，因为这只不过是带宠物笼子的特殊情况。 </p><br><h1 id="kontravariantnost"> 逆差 </h1><br><p> 很难理解<strong>亚型的限制</strong>或矛盾。 在以下示例中，功能参数与为其指定的类型相反。 也就是说，函数既可以接受此类型本身也可以接受其任何超类型，但不能接受子类型或其他类型。 </p><br><pre> <code class="plaintext hljs">function pushPet( cage : PetCage ) : void { const Pet = random() &gt; .5 ? Cat : Dog cage.content = new Pet } pushPet( new AnimalCage ) // allow pushPet( new PetCage ) // allow pushPet( new CatCage ) // forbid pushPet( new DogCage ) // forbid pushPet( new FoxCage ) // forbid</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9b/a03/b2d/e9ba03b2d3e4f0b82a6f3d9a4f85c05f.png" alt="图片"></p><br><p> 我们不能将猫带进笼子，因为该功能可以将狗放在那里，这是不允许的。 但是可以将任何动物的笼子安全地转移，因为猫和狗都可以放在那里。 </p><br><h1 id="invariantnost"> 不变性 </h1><br><p>  <strong>限制子类型和超类型</strong>可以同时存在。 这种情况称为不变性。 在以下示例中，功能参数对于为其指定的类型是不变的。 也就是说，该函数只能接受指定的类型，不能再接受其他类型。 </p><br><pre> <code class="plaintext hljs">function replacePet( cage : PetCage ) : void { touchPet( cage ) pushPet( cage ) } replacePet( new AnimalCage ) // forbid replacePet( new PetCage ) // allow replacePet( new CatCage ) // forbid replacePet( new DogCage ) // forbid replacePet( new FoxCage ) // forbid</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/3c3/bec/d6d/3c3becd6de5faa045963dc7c45774d19.png" alt="图片"></p><br><p>  <code>replacePet</code>函数继承了其内部使用的那些函数的限制：它从<code>pushPet</code>接受了对类型的限制，并通过<code>pushPet</code>接受了<code>pushPet</code>类型的<code>pushPet</code> 。 如果我们给她放上任何动物的笼子，她将无法将其转移到touchPet函数中，后者不知道如何处理狐狸（野生动物只会咬断手指）。 而且，如果我们将笼子与猫一起转移，则无法调用<code>pushPet</code> 。 </p><br><h1 id="bivariantnost"> 双方差 </h1><br><p> 人们不能不提到异国情调的<strong>缺乏限制</strong> -双方差。 在下面的示例中，函数可以接受子类型或子类型的任何类型。 </p><br><pre> <code class="plaintext hljs">function enshurePet( cage : PetCage ) : void { if( cage.content instanceof Pet ) return pushPet( cage ) } replacePet( new AnimalCage ) // allow replacePet( new PetCage ) // allow replacePet( new CatCage ) // allow replacePet( new DogCage ) // allow replacePet( new FoxCage ) // forbid</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/8b8/b85/66f/8b8b8566f8c6db9cd3959f1152202957.png" alt="图片"></p><br><p> 您可以在其中随动物一起转移笼子。 然后，她将检查笼子中是否有宠物，否则，将其放入随机宠物中。 例如，您可以转移带猫的笼子，然后她什么也不会做。 </p><br><h1 id="obobscheniya"> 概论 </h1><br><p> 有些人认为方差某种程度上与概括有关。 通常是因为通常使用通用容器作为示例来解释差异。 但是，在整个故事中，我们仍然没有一个单一的概括-完全是具体的类： </p><br><pre> <code class="plaintext hljs">class AnimalCage { content : Animal } class PetCage extends AnimalCage { content : Pet } class CatCage extends PetCage { content : Cat } class DogCage extends PetCage { content : Dog } class FoxCage extends AnimalCage { content : Fox }</code> </pre> <br><p> 这样做是为了证明方差问题与概化无关。 仅需要泛化以减少复制粘贴。 例如，可以通过简单的概括来重写上面的代码： </p><br><pre> <code class="plaintext hljs">class Cage&lt;Animal&gt; { content : Animal }</code> </pre> <br><p> 现在，您可以创建任何单元的实例： </p><br><pre> <code class="plaintext hljs">const animalCage = new Cage&lt;Animal&gt;() const petCage = new Cage&lt;Pet&gt;() const catCage = new Cage&lt;Cat&gt;() const dogCage = new Cage&lt;Dog&gt;() const foxCage = new Cage&lt;Fox&gt;()</code> </pre> <br><h1 id="deklaraciya-ogranicheniy"> 限制声明 </h1><br><p> 请注意，前面列出的所有四个功能的签名都完全相同： </p><br><pre> <code class="plaintext hljs">( cage : PetCage )=&gt; void</code> </pre> <br><p> 也就是说，对函数接受参数的这种描述不完整-从中不能说可以将其传递给函数。 好吧，除非可以清楚地看到，将狐狸笼子放进去绝对不值得。 </p><br><p> 因此，在现代语言中，有一种方法可以明确指示参数具有哪些类型限制。 例如，C＃中的<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-generic-modifier">in</a>和<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out-generic-modifier">out</a>修饰符： </p><br><pre> <code class="plaintext hljs">interface ICageIn&lt;in T&gt; { T content { set; } } // contravariant generic parameter interface ICageOut&lt;out T&gt; { T content { get; } } // covariant generic parameter interface ICageInOut&lt;T&gt; { T content { get; set; } } // invariant generic parameter</code> </pre> <br><p> 不幸的是，在C＃中，修饰符的每个变体都必须在单独的接口上启动。 另外，据我了解，C＃中的双方差通常是无法表达的。 </p><br><h1 id="vyhodnye-parametry"> 输出参数 </h1><br><p> 函数不仅可以接受，还可以返回值。 通常，返回值不能为1。 例如，采取带宠物的笼子并归还两只宠物的功能。 </p><br><pre> <code class="plaintext hljs">function getPets( input : PetCage ) : [ Pet , Pet ] { return [ input.content , new Cat ] }</code> </pre> <br><p> 这种功能等效于除一个输入参数外还具有另外两个输出的功能。 </p><br><pre> <code class="plaintext hljs">function getPets( input : PetCage , output1 : PetCage , output2 : PetCage ) : void { output1.content = input.content output2.content = new Cat }</code> </pre> <br><p> 外部代码在堆栈上分配了额外的内存，以便该函数将其要返回的所有内容放入其中。 完成后，调用代码将已经能够将这些容器用于自己的目的。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2c3/292/0b5/2c32920b5a5aeb4ed22923ac97de9267.png" alt="图片"></p><br><p> 从这两个函数的等价关系可以得出，与参数相比，函数返回的值始终与指定的输出类型相反。 一个函数可以向它们写入，但不能从它们读取。 </p><br><h1 id="metody-obektov"> 对象方法 </h1><br><p> 对象方法是将指向对象的附加指针作为隐式参数的函数。 即，以下两个功能是等效的。 </p><br><pre> <code class="plaintext hljs">class PetCage { pushPet() : void { const Pet = random() &gt; .5 ? Cat : Dog this.content = new Pet } }</code> </pre> <br><pre> <code class="plaintext hljs">function pushPet( this : PetCage ) : void { const Pet = random() &gt; .5 ? Cat : Dog this.content = new Pet }</code> </pre> <br><p> 但是，必须注意，与常规函数不同的是，方法也是该类的成员，该类是该类型的扩展。 这导致以下事实：调用此方法的函数会出现一个附加的超类型限制： </p><br><pre> <code class="plaintext hljs">function fillPetCage( cage : PetCage ) { cage.pushPet() }</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/44e/f44/c67/44ef44c670ebef55ab1d8f248da44b11.png" alt="图片"></p><br><p> 在<code>pushPet</code>方法尚未定义的情况下，我们不能向其传递这样的<code>pushPet</code> 。 这与不变的情况相似，因为从下方和上方都有限制。 但是， <code>pushPet</code>方法的位置在层次结构中可能更高。 这就是改型限制所在。 </p><br><h1 id="princip-podstanovki--barbary-liskov-lsp"> 芭芭拉·里斯克（Barbara Lisk）换人原则（LSP） </h1><br><p> 许多人认为，子类型与子类型的比率不是基于前面提到的缩小和扩展类型的方法来确定的，而是通过在使用超类型的任何位置替换子类型的可能性来确定的。 显然，此错误的原因正是在LSP中。 但是，让我们仔细阅读该原理的定义，注意什么是主要的，什么是次要的： </p><br><blockquote> 使用基本类型的函数应该能够使用基本类型的子类型而不知道它，也不会破坏程序的正确性。 </blockquote><p> 对于不可变的对象（包括那些不引用可变对象的对象），由于没有地方可以接受子类型限制，因此自动执行此原理。 </p><br><p> 对于可变变量，它变得越来越困难，因为以下两种情况对于LSP原理是互斥的： </p><br><ol><li> 类<code>A</code>有一个<code>B</code>的子类，其中字段<code>B::foo</code>是<code>A::foo</code>的子类型。 </li><li> 类<code>A</code>的方法可以更改<code>A::foo</code>字段。 </li></ol><br><p> 因此，只剩下三种方式： </p><br><ol><li> 防止对象继承缩小其字段类型。 但是随后您可以将大象推入笼子里养猫。 </li><li> 不是由LSP指导，而是由每个函数的每个参数的可变性分别指导。 但是随后您必须考虑很多，并向编译器说明类型限制在哪里。 </li><li> 吐上一切去 <del> 修道院 </del> 函数式编程，其中所有对象都是不可变的，这意味着它们接受的参数与声明的类型协变。 </li></ol><br><h1 id="typescript"> 打字稿 </h1><br><p> 在时间脚本中，逻辑很简单：将函数的所有参数视为协变的（不正确），将返回值视为反变的（正确的）。 先前已证明，函数的参数可以有任何变化，具体取决于此函数对这些参数的作用。 因此，这些是以下事件： </p><br><pre> <code class="plaintext hljs">abstract class Animal { is! : 'cat' | 'dog' | 'fox' } abstract class Pet extends Animal { is! : 'cat' | 'dog' } class Cat extends Pet { is! : 'cat' } class Dog extends Pet { is! : 'dog' } class Fox extends Animal { is! : 'fox' } class Cage&lt;Animal&gt; { content! : Animal } function pushPet( cage : Cage&lt;Pet&gt; ) : void { const Pet = Math.random() &gt; .5 ? Cat : Dog cage.content = new Pet } pushPet( new Cage&lt;Animal&gt;() ) // forbid to push Pet to Animal Cage :-( pushPet( new Cage&lt;Cat&gt;() ) // allow to push Dog to Cat Cage :-(</code> </pre> <br><p> 要解决此问题，您必须使用不平凡的代码来帮助编译器： </p><br><pre> <code class="plaintext hljs">function pushPet&lt; PetCage extends Cage&lt;Animal&gt; &gt;( cage: Cage&lt;Pet&gt; extends PetCage ? PetCage : never ): void { const Pet = Math.random() &gt; .5 ? Cat : Dog cage.content = new Pet } pushPet( new Cage&lt;Animal&gt;() ) // allow :-) pushPet( new Cage&lt;Pet&gt;() ) // allow :-) pushPet( new Cage&lt;Cat&gt;() ) // forbid :-) pushPet( new Cage&lt;Dog&gt;() ) // forbid :-) pushPet( new Cage&lt;Fox&gt;() ) // forbid :-)</code> </pre> <br><p>  <a href="https://tinyurl.com/uesu87y"><strong>在线尝试</strong></a> </p><br><h1 id="flowjs">  Flowjs </h1><br><p>  FlowJS具有更高级的类型系统。 特别地，在<a href="https://flow.org/en/docs/types/generics/">类型描述中可以指出其</a>对于通用参数和对象字段的<a href="https://flow.org/en/docs/types/generics/">可变性</a> 。 在我们的单元格示例中，它看起来像这样： </p><br><pre> <code class="plaintext hljs">class Animal {} class Pet extends Animal {} class Cat extends Pet {} class Dog extends Pet {} class Fox extends Animal {} class Cage&lt; Animal &gt; { content : Animal } function touchPet( cage : { +content : Pet } ) : void { console.log( `touch ${typeof cage.content}` ) } function pushPet( cage: { -content: Pet } ): void { const Pet = Number((0: any)) &gt; .5 ? Cat : Dog cage.content = new Pet } function replacePet( cage : { content : Pet } ) : void { touchPet( cage ) pushPet( cage ) } touchPet( new Cage&lt;Animal&gt; ) // forbid :-) touchPet( new Cage&lt;Pet&gt; ) // allow :-) touchPet( new Cage&lt;Cat&gt; ) // allow :-) touchPet( new Cage&lt;Dog&gt; ) // allow :-) touchPet( new Cage&lt;Fox&gt; ) // forbid :-) pushPet( new Cage&lt;Animal&gt; ) // allow :-) pushPet( new Cage&lt;Pet&gt; ) // allow :-) pushPet( new Cage&lt;Cat&gt; ) // forbid :-) pushPet( new Cage&lt;Dog&gt; ) // forbid :-) pushPet( new Cage&lt;Fox&gt; ) // forbid :-) replacePet( new Cage&lt;Animal&gt; ) // forbid :-) replacePet( new Cage&lt;Pet&gt; ) // allow :-) replacePet( new Cage&lt;Cat&gt; ) // forbid :-) replacePet( new Cage&lt;Dog&gt; ) // forbid :-) replacePet( new Cage&lt;Fox&gt;) // forbid :-)</code> </pre> <br><p>  <a href="https://tinyurl.com/uak4hne"><strong>在线尝试</strong></a> </p><br><p> 这里的双方差是无法表达的。 不幸的是，在没有明确描述所有字段的类型的情况下，我找不到更方便地设置方差的方法。 例如，如下所示： </p><br><pre> <code class="plaintext hljs">function pushPet( cage: Contra&lt; Cage&lt;Pet&gt; , 'content' &gt; ): void { const Pet = Number((0: any)) &gt; .5 ? Cat : Dog cage.content = new Pet }</code> </pre> <br><h1 id="c-sharp">  C锐 </h1><br><p>  C＃最初设计时对变化没有任何了解。 但是，稍后又添加了参数修饰符，这使编译器可以正确检查传递的参数类型。 不幸的是，再次使用这些修饰符不是很方便。 </p><br><pre> <code class="plaintext hljs">using System; abstract class Animal {} abstract class Pet : Animal {} class Cat : Pet {} class Dog : Pet {} class Fox : Animal {} interface ICageIn&lt;in T&gt; { T content { set; } } interface ICageOut&lt;out T&gt; { T content { get; } } interface ICageInOut&lt;T&gt; { T content { get; set; } } class Cage&lt;T&gt; : ICageIn&lt;T&gt;, ICageOut&lt;T&gt;, ICageInOut&lt;T&gt; { public T content { get; set; } } public class Program { static void touchPet( ICageOut&lt;Pet&gt; cage ) { Console.WriteLine( cage.content ); } static void pushPet( ICageIn&lt;Pet&gt; cage ) { cage.content = new Dog(); } static void replacePet( ICageInOut&lt;Pet&gt; cage ) { touchPet( cage as ICageOut&lt;Pet&gt; ); pushPet( cage as ICageIn&lt;Pet&gt; ); } void enshurePet( Cage&lt;Pet&gt; cage ) { if( cage.content is Pet ) return; pushPet( cage as ICageIn&lt;Pet&gt; ); } public static void Main() { var animalCage = new Cage&lt;Animal&gt;(); var petCage = new Cage&lt;Pet&gt;(); var catCage = new Cage&lt;Cat&gt;(); var dogCage = new Cage&lt;Dog&gt;(); var foxCage = new Cage&lt;Fox&gt;(); touchPet( animalCage ); // forbid :-) touchPet( petCage ); // allow :-) touchPet( catCage ); // allow :-) touchPet( dogCage ); // allow :-) touchPet( foxCage ); // forbid :-) pushPet( animalCage ); // allow :-) pushPet( petCage ); // allow :-) pushPet( catCage ); // forbid :-) pushPet( dogCage ); // forbid :-) pushPet( foxCage ); // forbid :-) replacePet( animalCage ); // forbid :-) replacePet( petCage ); // allow :-) replacePet( catCage ); // forbid :-) replacePet( dogCage ); // forbid :-) replacePet( foxCage ); // forbid :-) } }</code> </pre> <br><p>  <a href="https://dotnetfiddle.net/jAx53p"><strong>在线尝试</strong></a> </p><br><h1 id="java"> 爪哇 </h1><br><p> 在Java中，切换变体的功能添加得很晚，并且仅适用于通用参数，而这些参数本身是相对较新的。 如果该参数不通用，那就麻烦了。 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fox</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cage</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T content; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">touchPet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Cage&lt;? extends Pet&gt; cage )</span></span></span><span class="hljs-function"> </span></span>{ System.out.println( cage.content ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushPet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Cage&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Pet&gt; cage )</span></span></span><span class="hljs-function"> </span></span>{ cage.content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replacePet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cage&lt;Pet&gt; cage )</span></span></span><span class="hljs-function"> </span></span>{ touchPet( cage ); pushPet( cage ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enshurePet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Cage&lt;Pet&gt; cage )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( cage.content <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Pet ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; pushPet( cage ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Cage&lt;Animal&gt; animalCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Animal&gt;(); Cage&lt;Pet&gt; petCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Pet&gt;(); Cage&lt;Cat&gt; catCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Cat&gt;(); Cage&lt;Dog&gt; dogCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Dog&gt;(); Cage&lt;Fox&gt; foxCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Fox&gt;(); touchPet( animalCage ); <span class="hljs-comment"><span class="hljs-comment">// forbid :-) touchPet( petCage ); // allow :-) touchPet( catCage ); // allow :-) touchPet( dogCage ); // allow :-) touchPet( foxCage ); // forbid :-) pushPet( animalCage ); // allow :-) pushPet( petCage ); // allow :-) pushPet( catCage ); // forbid :-) pushPet( dogCage ); // forbid :-) pushPet( foxCage ); // forbid :-) replacePet( animalCage ); // forbid :-) replacePet( petCage ); // allow :-) replacePet( catCage ); // forbid :-) replacePet( dogCage ); // forbid :-) replacePet( foxCage ); // forbid :-) } }</span></span></code> </pre> <br><p>  <a href="https://paiza.io/projects/pIBVVcjarSB0j0RJY8iNTw%3Flanguage%3Djava"><strong>在线尝试</strong></a> </p><br><h1 id="c">  C ++ </h1><br><p>  C ++凭借其强大的模板系统，可以表达各种变体，但是当然有很多代码。 </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;typeinfo&gt; #include &lt;type_traits&gt; class Animal {}; class Pet: public Animal {}; class Cat: public Pet {}; class Dog: public Pet {}; class Fox: public Animal {}; template&lt;class T&gt; class Cage { public: T *content; }; template&lt;class T, class = std::enable_if_t&lt;std::is_base_of&lt;Pet, T&gt;::value&gt;&gt; void touchPet(const Cage&lt;T&gt; &amp;cage) { std::cout &lt;&lt; typeid(T).name(); } template&lt;class T, class = std::enable_if_t&lt;std::is_base_of&lt;T, Pet&gt;::value&gt;&gt; void pushPet(Cage&lt;T&gt; &amp;cage) { cage.content = new Dog(); } void replacePet(Cage&lt;Pet&gt; &amp;cage) { touchPet(cage); pushPet(cage); } int main(void) { Cage&lt;Animal&gt; animalCage {new Fox()}; Cage&lt;Pet&gt; petCage {new Cat()}; Cage&lt;Cat&gt; catCage {new Cat()}; Cage&lt;Dog&gt; dogCage {new Dog()}; Cage&lt;Fox&gt; foxCage {new Fox()}; touchPet( animalCage ); // forbid :-) touchPet( petCage ); // allow :-) touchPet( catCage ); // allow :-) touchPet( dogCage ); // allow :-) touchPet( foxCage ); // forbid :-) pushPet( animalCage ); // allow :-) pushPet( petCage ); // allow :-) pushPet( catCage ); // forbid :-) pushPet( dogCage ); // forbid :-) pushPet( foxCage ); // forbid :-) replacePet( animalCage ); // forbid :-) replacePet( petCage ); // allow :-) replacePet( catCage ); // forbid :-) replacePet( dogCage ); // forbid :-) replacePet( foxCage ); // forbid :-) return 0; }</span></span></span></span></code> </pre> <br><p>  <a href="http://cpp.sh/8aqxm"><strong>在线尝试</strong></a> </p><br><h1 id="d">  d </h1><br><p>  D没有任何明智的方式来明确指示方差，但是他知道如何根据使用情况来推断类型。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.random; abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> {</span></span>} abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> :</span></span> Animal { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> Pet {} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> :</span></span> Pet {} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fox</span></span></span><span class="hljs-class"> :</span></span> Animal {} <span class="hljs-function"><span class="hljs-function">class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-function"> </span></span>{ T content; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">touchPet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage cage )</span></span></span><span class="hljs-function"> </span></span>{ writeln( cage.content.name ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushPet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage cage )</span></span></span><span class="hljs-function"> </span></span>{ cage.content = ( uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog() : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replacePet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage cage )</span></span></span><span class="hljs-function"> </span></span>{ touchPet( cage ); pushPet( cage); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Cage!Animal animalCage; Cage!Pet petCage; Cage!Cat catCage; Cage!Dog dogCage; Cage!Fox foxCage; animalCage.touchPet(); <span class="hljs-comment"><span class="hljs-comment">// forbid :-) petCage.touchPet(); // allow :-) catCage.touchPet(); // allow :-) dogCage.touchPet(); // allow :-) foxCage.touchPet(); // forbid :-) animalCage.pushPet(); // allow :-) petCage.pushPet(); // allow :-) catCage.pushPet(); // forbid :-) dogCage.pushPet(); // forbid :-) foxCage.pushPet(); // forbid :-) animalCage.replacePet(); // forbid :-) petCage.replacePet(); // allow :-) catCage.replacePet(); // forbid :-) dogCage.replacePet(); // forbid :-) foxCage.replacePet(); // forbid :-) }</span></span></code> </pre> <br><p>  <a href="https://tinyurl.com/qwxwzqg"><strong>在线尝试</strong></a> </p><br><h1 id="epilog"> 结语 </h1><br><p> 现在就这些了。 我希望介绍的材料可以帮助您更好地理解类型的限制，以及如何以不同的语言实现它们。 总的来说，某处更好，某处更糟，某处没有办法，但总之。 也许是您将开发一种语言，使所有这些语言都可以方便地实现并且是类型安全的。 同时，加入我们的<a href="https://teleg.run/lang_idioms">电报聊天，有时我们讨论编程语言的理论概念</a> 。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN477448/">https://habr.com/ru/post/zh-CN477448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN477434/index.html">微服务的服务网格。 第二部分，使用Istio的基础知识</a></li>
<li><a href="../zh-CN477436/index.html">如何编写一个简单的客户端-服务器计算器（JavaFX + EJB + WildFly）</a></li>
<li><a href="../zh-CN477438/index.html">如何重新控制并减少对智能手机和通知的依赖</a></li>
<li><a href="../zh-CN477440/index.html">Flipper Zero-戊酯tomagotchi patsan多功能工具</a></li>
<li><a href="../zh-CN477442/index.html">56个开源Python项目</a></li>
<li><a href="../zh-CN477450/index.html">9种检测异常的方法</a></li>
<li><a href="../zh-CN477452/index.html">第二届编程冠军：我们分析ML轨道的任务</a></li>
<li><a href="../zh-CN477454/index.html">配置文件。 Libconfig库和未使用设置的定义</a></li>
<li><a href="../zh-CN477458/index.html">苏格兰IT生活的利与弊</a></li>
<li><a href="../zh-CN477460/index.html">第26期：IT培训-领先公司的当前问题和挑战</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>