<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öæÔ∏è üö† üëéüèº WAL en PostgreSQL: 3. Punto de control ‚öúÔ∏è ‚ò¶Ô∏è üë®üèª‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya nos hemos familiarizado con el dispositivo de cach√© del b√∫fer , uno de los objetos principales en la memoria compartida, y nos hemos dado cuenta de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL en PostgreSQL: 3. Punto de control</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/460423/">  Ya nos hemos familiarizado con el dispositivo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cach√©</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫fer</a> , uno de los objetos principales en la memoria compartida, y nos hemos dado cuenta de que para recuperarse de una falla cuando se pierde el contenido de la RAM, debe mantener un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">registro de pregrabaci√≥n</a> . <br><br>  El problema no resuelto que detuvimos la √∫ltima vez es que no se sabe en qu√© momento puede comenzar a reproducir los registros durante la recuperaci√≥n.  Comenzar desde el principio, como aconsej√≥ el Rey de <em>Alicia</em> , no funcionar√°: es imposible almacenar todas las entradas del diario desde el inicio del servidor; esto es potencialmente una gran cantidad y el mismo gran tiempo de recuperaci√≥n.  Necesitamos un punto de avance gradual desde el cual podamos comenzar la recuperaci√≥n (y, en consecuencia, podemos eliminar con seguridad todas las entradas de diario anteriores).  Este es el <em>punto de control</em> que se discutir√° hoy. <br><br><h1>  Punto de control </h1><br>  ¬øQu√© propiedad debe tener un punto de control?  Debemos estar seguros de que todas las entradas de diario, comenzando desde el punto de control, se aplicar√°n a las p√°ginas escritas en el disco.  Si no fuera as√≠, durante la restauraci√≥n podr√≠amos leer del disco una versi√≥n demasiado antigua de la p√°gina y aplicarle una entrada de diario, y as√≠ da√±ar permanentemente los datos. <br><a name="habracut"></a><br>  ¬øC√≥mo obtener un punto de interrupci√≥n?  La opci√≥n m√°s f√°cil es suspender peri√≥dicamente el sistema y vaciar al disco todas las p√°ginas sucias del b√∫fer y otras memorias cach√©.  (Tenga en cuenta que las p√°ginas solo se escriben, pero no se expulsan de la memoria cach√©). Tales puntos satisfar√°n la condici√≥n, pero, por supuesto, nadie querr√° trabajar con un sistema que se congela constantemente por un tiempo indefinido pero muy significativo. <br><br>  Por lo tanto, en la pr√°ctica, todo es algo m√°s complicado: un punto de control de un punto se convierte en un segmento.  Primero comenzamos <em>el</em> punto de ruptura.  Despu√©s de eso, sin interrumpir el trabajo y, si es posible, sin crear cargas m√°ximas, volcamos lentamente los buffers sucios en el disco. <br><br><img src="https://habrastorage.org/webt/n0/ch/6f/n0ch6fdrfxkylmuqjdar7idfxsw.png"><br><br>  Cuando se escribieron todos los b√∫feres que estaban sucios <em>al comienzo del</em> punto <em>de</em> control, el punto de control se considera <em>completo</em> .  Ahora (pero no antes) podemos usar el punto de <em>inicio</em> como el punto desde el cual puede comenzar la recuperaci√≥n.  Y las entradas de diario hasta este punto ya no las necesitamos. <br><br><img src="https://habrastorage.org/webt/q4/th/83/q4th83seql63dkrgfmg7esu3zh8.png"><br><br>  El punto de verificaci√≥n se maneja mediante un proceso especial de puntero de verificaci√≥n en segundo plano. <br><br>  La duraci√≥n de los buffers sucios est√° determinada por el valor del par√°metro <em>checkpoint_completion_target</em> .  Muestra cu√°nto tiempo transcurrir√° entre dos puntos de control adyacentes la grabaci√≥n.  El valor predeterminado es 0.5 (como en las figuras anteriores), es decir, la grabaci√≥n tarda la mitad del tiempo entre los puntos de control.  T√≠picamente, el valor se incrementa hasta 1.0 para una mayor uniformidad. <br><br>  Consideremos con m√°s detalle lo que sucede cuando se ejecuta un punto de control. <br><br>  El proceso de punto de control primero descarga los buffers de estado de transacci√≥n (XACT) en el disco.  Como hay pocos (128 en total), se registran de inmediato. <br><br>  Entonces comienza el trabajo principal: escribir p√°ginas sucias desde la memoria cach√© del b√∫fer.  Como ya dijimos, es imposible restablecer todas las p√°ginas a la vez, ya que el tama√±o de la memoria cach√© del b√∫fer puede ser significativo.  Por lo tanto, primero, todas las p√°ginas actualmente sucias se marcan en la memoria cach√© del b√∫fer en los encabezados con un indicador especial. <br><br><img src="https://habrastorage.org/webt/_4/ym/eq/_4ymeqozl8o23kwq6su9ntvjujk.png"><br><br>  Y luego, el proceso del punto de control pasa gradualmente por todos los buffers y vac√≠a los marcados en el disco.  Recuerde que las p√°ginas no se expulsan del cach√©, sino que solo se escriben en el disco, por lo que no necesita prestar atenci√≥n a la cantidad de llamadas al b√∫fer ni a su reparaci√≥n. <br><br>  Los buffers etiquetados tambi√©n pueden ser escritos por procesos del servidor, dependiendo de qui√©n llegue primero al buffer.  En cualquier caso, el indicador previamente establecido se elimina al grabar, por lo que (para el punto de control) el b√∫fer se escribir√° solo una vez. <br><br>  Naturalmente, durante la ejecuci√≥n del punto de control, las p√°ginas contin√∫an cambiando en la memoria cach√© del b√∫fer.  Pero los nuevos buffers sucios no est√°n marcados y el proceso del punto de control no deber√≠a escribirlos. <br><br><img src="https://habrastorage.org/webt/fg/uo/vm/fguovmm8yzy0jb4jwisgg10nmm8.png"><br><br>  Al final de su trabajo, el proceso crea una entrada de diario para el final del punto de control.  Este registro contiene el LSN del inicio del trabajo del punto de control.  Dado que el punto de control no escribe nada en el registro al comienzo de su trabajo, este LSN puede contener cualquier registro de registro. <br><br>  Adem√°s, el archivo $ PGDATA / global / pg_control actualiza la indicaci√≥n del √∫ltimo punto de control <em>pasado</em> .  Antes de que se complete el punto de control, pg_control apunta al punto de control anterior. <br><br><img src="https://habrastorage.org/webt/w0/cy/gi/w0cygixp3k4k3qscwfa2nlapqna.png"><br><br>  Para ver el trabajo del punto de control, cree una tabla: sus p√°ginas ir√°n al cach√© del b√∫fer y estar√°n sucias: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> chkpt <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(n); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_buffercache; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> isdirty;</code> </pre> <pre> <code class="plaintext hljs"> count ------- 78 (1 row)</code> </pre><br>  Recuerde la posici√≥n actual en el registro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A048 (1 row)</code> </pre><br>  Ahora ejecutaremos el punto de control manualmente y nos aseguraremos de que no haya p√°ginas sucias en el cach√© (como dijimos, pueden aparecer nuevas p√°ginas sucias, pero en nuestro caso no hubo cambios en el proceso de ejecuci√≥n del punto de control): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> isdirty;</code> </pre><pre> <code class="plaintext hljs"> count ------- 0 (1 row)</code> </pre><br>  Veamos c√≥mo se reflej√≥ el punto de control en el registro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A0E4 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/3514A048 -e 0/3514A0E4</code> </pre><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 50/ 50, tx: 0, lsn: 0/3514A048, prev 0/35149CEC, desc: RUNNING_XACTS nextXid 101105 latestCompletedXid 101104 oldestRunningXid 101105</code> </pre><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 102/ 102, tx: 0, lsn: 0/3514A07C, prev 0/3514A048, desc: CHECKPOINT_ONLINE redo 0/3514A048; tli 1; prev tli 1; fpw true; xid 0:101105; oid 74081; multi 1; offset 0; oldest xid 561 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 101105; online</code> </pre><br>  Aqu√≠ vemos dos entradas.  El √∫ltimo es un registro de pasar el punto de control (CHECKPOINT_ONLINE).  El LSN del inicio del punto de control se indica despu√©s de la palabra rehacer, y esta posici√≥n corresponde a la entrada del diario, que fue la √∫ltima al comienzo del punto de control. <br><br>  Encontraremos la misma informaci√≥n en el archivo de control: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | egrep 'Latest.*location'</code> </pre><pre> <code class="plaintext hljs">Latest checkpoint location: 0/3514A07C Latest checkpoint's REDO location: 0/3514A048</code> </pre><br><h1>  Recuperaci√≥n </h1><br>  Ahora estamos listos para aclarar el algoritmo de recuperaci√≥n descrito en el art√≠culo anterior. <br><br>  Si el servidor falla, la pr√≥xima vez que se inicie, el proceso de inicio lo detecta al mirar el archivo pg_control y ver un estado que no sea "apagado".  En este caso, se realiza la recuperaci√≥n autom√°tica. <br><br>  Primero, el proceso de recuperaci√≥n leer√° desde el mismo pg_control la posici√≥n del inicio del punto de control.  (Para completar, observamos que si el archivo backup_label est√° presente, entonces se lee el registro del punto de control; esto es necesario para restaurar desde copias de seguridad, pero este es un tema para un ciclo separado). <br><br>  Luego leer√° la revista, comenzando desde la posici√≥n encontrada, aplicando secuencialmente entradas de diario a las p√°ginas (si es necesario, como lo discutimos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√∫ltima vez</a> ). <br><br>  En conclusi√≥n, todas las tablas no registradas se sobrescriben usando im√°genes en los archivos init. <br><br>  En este punto, el proceso de inicio finaliza y el proceso del puntero de verificaci√≥n ejecuta inmediatamente un punto de verificaci√≥n para corregir el estado restaurado en el disco. <br><br>  Puede simular un fallo deteniendo por la fuerza el servidor en modo inmediato. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop -m immediate --skip-systemctl-redirect</code> </pre><br>  (La clave <code>--skip-systemctl-redirect</code> es necesaria aqu√≠ porque PostgreSQL est√° instalado en Ubuntu desde el paquete. Est√° controlado por el comando pg_ctlcluster, que en realidad llama systemctl, y ya llama a pg_ctl. Con todos estos contenedores, el nombre del modo se pierde en el camino, y el <code>--skip-systemctl-redirect</code> permite prescindir de systemctl y guardar informaci√≥n importante). <br><br>  Verifique el estado del cl√∫ster: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: in production</code> </pre><br>  Al iniciarse, PostgreSQL comprende que se ha producido un error y que se requiere una recuperaci√≥n. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><pre> <code class="plaintext hljs">postgres$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-07-17 15:27:49.441 MSK [8865] LOG: database system was interrupted; last known up at 2019-07-17 15:27:48 MSK 2019-07-17 15:27:49.801 MSK [8865] LOG: database system was not properly shut down; automatic recovery in progress 2019-07-17 15:27:49.804 MSK [8865] LOG: redo starts at 0/3514A048 2019-07-17 15:27:49.804 MSK [8865] LOG: invalid record length at 0/3514A0E4: wanted 24, got 0 2019-07-17 15:27:49.804 MSK [8865] LOG: redo done at 0/3514A07C 2019-07-17 15:27:49.824 MSK [8864] LOG: database system is ready to accept connections 2019-07-17 15:27:50.409 MSK [8872] [unknown]@[unknown] LOG: incomplete startup packet</code> </pre><br>  La necesidad de recuperaci√≥n se observa en el registro de mensajes: el <em>sistema de base de datos no se cerr√≥ correctamente;</em>  <em>recuperaci√≥n autom√°tica en progreso</em> .  Luego, las entradas de diario comienzan a reproducirse desde la posici√≥n marcada en "rehacer comienza en" y contin√∫an hasta que se puedan recuperar las siguientes entradas de diario.  Esto completa la recuperaci√≥n en la posici√≥n "rehacer en" y el DBMS comienza a trabajar con los clientes (el <em>sistema de base de datos est√° listo para aceptar conexiones</em> ). <br><br>  ¬øY qu√© sucede durante un apagado normal del servidor?  Para vaciar las p√°ginas sucias al disco, PostgreSQL desconecta todos los clientes y luego ejecuta el punto de control final. <br><br>  Recuerde la posici√≥n actual en el registro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A14C (1 row)</code> </pre><br>  Ahora detenga suavemente el servidor: <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop</code> </pre><br>  Verifique el estado del cl√∫ster: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: shut down</code> </pre><br>  Y en el registro encontramos el √∫nico registro sobre el punto de control final (CHECKPOINT_SHUTDOWN): <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/3514A14C</code> </pre><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 102/ 102, tx: 0, lsn: 0/3514A14C, prev 0/3514A0E4, desc: CHECKPOINT_SHUTDOWN redo 0/3514A14C; tli 1; prev tli 1; fpw true; xid 0:101105; oid 74081; multi 1; offset 0; oldest xid 561 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 0; shutdown</code> </pre><pre> <code class="plaintext hljs">pg_waldump: FATAL: error in WAL record at 0/3514A14C: invalid record length at 0/3514A1B4: wanted 24, got 0</code> </pre><br>  (En un terrible mensaje fatal, pg_waldump solo quiere decir que ley√≥ hasta el final de la revista). <br><br>  Ejecute la instancia nuevamente. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><h1>  Grabaci√≥n de fondo </h1><br>  Como descubrimos, el punto de control es uno de los procesos que escribe p√°ginas sucias desde la memoria cach√© del b√∫fer al disco.  Pero no el √∫nico. <br><br>  Si el backend necesita sacar la p√°gina del b√∫fer y la p√°gina est√° sucia, tendr√° que escribirla en el disco por s√≠ misma.  Esta es una mala situaci√≥n, que lleva a expectativas: es mucho mejor cuando la grabaci√≥n se produce de forma as√≠ncrona en segundo plano. <br><br>  Por lo tanto, adem√°s del <em>proceso de</em> punto de control <em>,</em> tambi√©n hay <em>un proceso de grabaci√≥n de</em> fondo (escritor de fondo, bgwriter o simplemente escritor).  Este proceso utiliza el mismo algoritmo de b√∫squeda de b√∫fer que el mecanismo de preferencia.  B√°sicamente hay dos diferencias. <br><br><ol><li>  No utiliza un puntero a la "pr√≥xima v√≠ctima", sino el suyo.  Puede adelantarse al puntero de la "v√≠ctima", pero nunca se queda atr√°s. </li><li>  Al atravesar buffers, el contador de golpes no disminuye. </li></ol><br>  Se escriben buffers que son simult√°neamente: <br><br><ul><li>  contener datos modificados (sucios), </li><li>  no fijo (n√∫mero de pines = 0), </li><li>  tener cero aciertos (recuento de uso = 0). </li></ul><br>  Por lo tanto, el proceso de grabaci√≥n en segundo plano, por as√≠ decirlo, se adelanta al desplazamiento y encuentra esos b√∫feres que probablemente se desplazar√°n pronto.  Idealmente, debido a esto, los procesos de servicio deber√≠an encontrar que los buffers que seleccionan pueden usarse sin detenerse para escribir. <br><br><h1>  Personalizaci√≥n </h1><br>  <em>El proceso del punto de control</em> generalmente se configura por los siguientes motivos. <br><br>  Primero debe decidir cu√°ntos archivos de registro podemos guardar (y qu√© tiempo de recuperaci√≥n nos conviene).  Cuanto m√°s grande, mejor, pero por razones obvias, este valor ser√° limitado. <br><br>  A continuaci√≥n, podemos calcular cu√°nto tiempo se generar√° este volumen bajo carga normal.  Ya hemos considerado c√≥mo hacer esto (necesitamos recordar las posiciones en el diario y restar una de la otra). <br><br>  Esta vez ser√° nuestro intervalo habitual entre puntos de control.  Lo escribimos en el par√°metro <em>checkpoint_timeout</em> .  El valor predeterminado de 5 minutos es obviamente demasiado peque√±o, por lo general, el tiempo se incrementa, por ejemplo, a media hora.  Repito: cuanto menos pueda permitirse hitos, mejor, esto reduce los gastos generales. <br><br>  Sin embargo, es posible (e incluso probable) que a veces la carga sea m√°s alta de lo normal, y se generar√°n demasiados asientos en el tiempo especificado en el par√°metro.  En este caso, me gustar√≠a realizar el punto de control con m√°s frecuencia.  Para hacer esto, en el par√°metro <em>max_wal_size</em> especificamos la cantidad que es v√°lida dentro del mismo punto de control.  Si el volumen real se obtiene m√°s, el servidor inicia un punto de control no programado. <br><br>  Por lo tanto, la mayor√≠a de los puntos de control ocurren en un horario: una vez por unidades de tiempo <em>checkpoint_timeout</em> .  Pero con el aumento de la carga, el punto de control se llama con mayor frecuencia cuando se <em>alcanza el</em> volumen <em>max_wal_size</em> . <br><br>  Es importante comprender que el par√°metro <em>max_wal_size</em> no determina en absoluto la cantidad m√°xima que pueden ocupar los archivos de registro en el disco. <br><br><ul><li>  Para recuperarse de una falla, debe almacenar los archivos desde el momento en que se pas√≥ el √∫ltimo punto de control, m√°s los archivos que se acumularon durante la operaci√≥n del punto de control actual.  Por lo tanto, el volumen total puede estimarse aproximadamente como <br>  (1 + <em>checkpoint_completion_target</em> ) √ó <em>max_wal_size</em> . </li><li>  Antes de la versi√≥n 11, PostgreSQL tambi√©n almacenaba archivos para el punto de control de dos a√±os, por lo que hasta la versi√≥n 10 en la f√≥rmula anterior, debe establecer 2 en lugar de 1. </li><li>  El par√°metro <em>max_wal_size</em> es solo un deseo, pero no un l√≠mite <em>estricto</em> .  Puede resultar m√°s. </li><li>  El servidor no tiene derecho a borrar archivos de registro que a√∫n no se han transferido a trav√©s de las ranuras de replicaci√≥n y que a√∫n no se han archivado durante el archivado continuo.  Si se utiliza esta funcionalidad, es necesaria una supervisi√≥n constante, ya que es f√°cil desbordar la memoria del servidor. </li></ul><br>  Para completar la imagen, puede establecer no solo el volumen m√°ximo, sino tambi√©n el m√≠nimo: par√°metro <em>min_wal_size</em> .  El significado de esta configuraci√≥n es que el servidor no elimina archivos mientras se ajustan en <em>min_wal_size</em> en <em>volumen</em> , sino que simplemente los renombra y los usa nuevamente.  Esto le ahorra un poco al crear y eliminar archivos constantemente. <br><br>  <em>El proceso de grabaci√≥n en segundo plano</em> tiene sentido para configurar despu√©s de configurar el punto de control.  Juntos, estos procesos deben tener tiempo para escribir buffers sucios antes de que sean necesarios para los procesos de mantenimiento. <br><br>  El proceso de grabaci√≥n en segundo plano se ejecuta en ciclos de, como m√°ximo, p√°ginas <em>bgwriter_lru_maxpages</em> , quedando dormido entre ciclos en <em>bgwriter_delay</em> . <br><br>  El n√∫mero de p√°ginas que se registrar√°n en un ciclo de trabajo est√° determinado por el n√∫mero promedio de memorias intermedias que se solicitaron mediante los procesos de servicio de la √∫ltima ejecuci√≥n (utilizando un promedio m√≥vil para suavizar las desigualdades entre las ejecuciones, pero no depende de un largo historial).  El n√∫mero calculado de buffers se multiplica por el coeficiente <em>bgwriter_lru_multiplier</em> (pero en cualquier caso no exceder√° <em>bgwriter_lru_maxpages</em> ). <br><br>  Valores predeterminados: <em>bgwriter_delay</em> = 200ms (lo m√°s probable es que gotee mucha agua en 1/5 de segundo), <em>bgwriter_lru_maxpages</em> = 100, <em>bgwriter_lru_multiplier</em> = 2.0 (tratamos de responder a la demanda antes de lo programado). <br><br>  Si el proceso no detecta buffers sucios (es decir, no sucede nada en el sistema), "hiberna" de lo que se deduce que el proceso del servidor accede al buffer.  Despu√©s de eso, el proceso se despierta y vuelve a funcionar de la manera habitual. <br><br><h1>  Monitoreo </h1><br>  El punto de control y la configuraci√≥n de grabaci√≥n en segundo plano pueden y deben ajustarse, recibiendo comentarios de la supervisi√≥n. <br><br>  El par√°metro <em>checkpoint_warning</em> muestra una advertencia si los puntos de control causados ‚Äã‚Äãpor desbordamientos del tama√±o del archivo de registro se ejecutan con demasiada frecuencia.  Su valor predeterminado es de 30 segundos, y debe alinearse con el valor de <em>checkpoint_timeout</em> . <br><br>  El par√°metro <em>log_checkpoints</em> (deshabilitado de forma predeterminada) permite recibir informaci√≥n sobre los puntos de verificaci√≥n ejecutados en el registro de mensajes del servidor.  Enci√©ndelo. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_checkpoints = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Ahora cambie algo en los datos y ejecute el punto de control. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> chkpt <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> n = n + <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>;</code> </pre><br>  En el registro de mensajes veremos algo como esto: <br><br><pre> <code class="plaintext hljs">postgres$ tail -n 2 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-07-17 15:27:55.248 MSK [8962] LOG: checkpoint starting: immediate force wait 2019-07-17 15:27:55.274 MSK [8962] LOG: checkpoint complete: wrote 79 buffers (0.5%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.013 s, total=0.025 s; sync files=2, longest=0.011 s, average=0.006 s; distance=1645 kB, estimate=1645 kB</code> </pre><br>  Aqu√≠ puede ver cu√°ntos b√∫feres se escribieron, c√≥mo cambi√≥ la composici√≥n de los archivos de registro despu√©s del punto de control, cu√°nto tiempo tom√≥ el punto de control y la distancia (en bytes) entre los puntos de control adyacentes. <br><br>  Pero, probablemente, la informaci√≥n m√°s √∫til son las estad√≠sticas del trabajo del punto de control y los procesos de grabaci√≥n en segundo plano en la vista pg_stat_bgwriter.  La vista es una para dos, porque una vez que ambas tareas fueron realizadas por un proceso;  entonces sus funciones se dividieron y la vista permaneci√≥. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_bgwriter \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]---------+------------------------------ checkpoints_timed | 0 checkpoints_req | 1 checkpoint_write_time | 1 checkpoint_sync_time | 13 buffers_checkpoint | 79 buffers_clean | 0 maxwritten_clean | 0 buffers_backend | 42 buffers_backend_fsync | 0 buffers_alloc | 363 stats_reset | 2019-07-17 15:27:49.826414+03</code> </pre><br>  Aqu√≠, entre otras cosas, vemos la cantidad de puntos de control completados: <br><br><ul><li>  checkpoints_timed - de acuerdo con el horario (al llegar a checkpoint_timeout), </li><li>  checkpoints_req: bajo demanda (incluso al llegar a max_wal_size). </li></ul><br>  El gran valor de checkpoint_req (en comparaci√≥n con checkpoints_timed) indica que los puntos de control ocurren con m√°s frecuencia de lo esperado. <br><br>  Informaci√≥n importante sobre el n√∫mero de p√°ginas grabadas: <br><br><ul><li>  buffers_checkpoint - proceso de punto de control, </li><li>  buffers_backend: al servir procesos, </li><li>  buffers_clean: proceso de grabaci√≥n en segundo plano. </li></ul><br>  En un sistema bien ajustado, el valor de buffers_backend deber√≠a ser sustancialmente menor que la suma de buffers_checkpoint y buffers_clean. <br><br>  Adem√°s, maxwritten_clean es √∫til para configurar la grabaci√≥n en segundo plano: este n√∫mero muestra cu√°ntas veces el proceso de grabaci√≥n en segundo plano dej√≥ de funcionar debido a que excedi√≥ <em>bgwriter_lru_maxpages</em> . <br><br>  Puede restablecer las estad√≠sticas acumuladas mediante la siguiente llamada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_stat_reset_shared(<span class="hljs-string"><span class="hljs-string">'bgwriter'</span></span>);</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar√°</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460423/">https://habr.com/ru/post/460423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460411/index.html">Mad Converter GIF'ok a stickers animados para Telegram</a></li>
<li><a href="../460413/index.html">7 sitios y aplicaciones √∫tiles para aprender ingl√©s</a></li>
<li><a href="../460415/index.html">Apple Watch 4 (44 mm, 2019) vs Pebble Steel Classic (2014)</a></li>
<li><a href="../460419/index.html">Recuperaci√≥n de calor de gases de combusti√≥n: respetuoso con el medio ambiente</a></li>
<li><a href="../460421/index.html">Interruptor √≥ptico TP-Link T2600G-28SQ para proveedores de servicios: una revisi√≥n detallada</a></li>
<li><a href="../460425/index.html">Fr√≠o infernal, levitaci√≥n y plasma: pasado, presente y futuro de la superconductividad</a></li>
<li><a href="../460431/index.html">Creaci√≥n de una canalizaci√≥n de pruebas automatizada en Azure DevOps</a></li>
<li><a href="../460433/index.html">Riesgos y amenazas en Internet de las cosas.</a></li>
<li><a href="../460435/index.html">Petty little joy # 8: peque√±os placeres por trabajar con la base de datos</a></li>
<li><a href="../460437/index.html">C√≥mo sacamos una bicicleta de soporte t√©cnico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>