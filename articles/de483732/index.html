<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õµÔ∏è ü§ô ‚òØÔ∏è Lesen Sie die sichere Firmware vom STM32F1xx-Flash mit ChipWhisperer ü§≥üèæ üåö „äóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im vorherigen Artikel haben wir uns mit Vcc-Glitch-Angriffen mit ChipWhisperer befasst. Unser weiteres Ziel war eine schrittweise Untersuchung des Pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lesen Sie die sichere Firmware vom STM32F1xx-Flash mit ChipWhisperer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/483732/"><img src="https://habrastorage.org/webt/8h/fe/kf/8hfekfa930idilbg4asymru0cbm.png"><br><p>  Im vorherigen <a href="https://habr.com/ru/company/ntc-vulkan/blog/480500/">Artikel haben</a> wir uns mit Vcc-Glitch-Angriffen mit ChipWhisperer befasst.  Unser weiteres Ziel war eine schrittweise Untersuchung des Prozesses des Lesens gesch√ºtzter Firmware-Mikrocontroller.  Durch solche Angriffe kann ein Angreifer auf alle Ger√§tekennw√∂rter und Softwarealgorithmen zugreifen.  Ein anschauliches Beispiel ist das <a href="https://www.youtube.com/watch%3Flist%3DPLhixgUqwRTjyLgF4x-ZLVFL-CRTCrUo03%255E_%255Eamp%255E_%255Etime_continue%3D3%255E_%255Eamp%255E_%255Ev%3DnNBktKw9Is4">Hacken der</a> Ledger Nano S-Hardware-Kryptob√∂rse mit dem MK STM32F042-Board unter Verwendung von Vcc-Glitch-Attacken. </p><br><p>  Interessant?  Lass uns unter die Katze schauen. </p><a name="habracut"></a><br><p>  Die M√∂glichkeit, gesch√ºtzte Firmware zu lesen, haben wir einem <a href="https://pdfs.semanticscholar.org/4c01/a7514deacc2c02d010bb14c4fb58d1712adc.pdf">Artikel</a> entnommen, in dem die Ergebnisse eines Vcc-Glitch-Angriffs vorgestellt werden. Dabei wird das RDP-Schutzbyte durch einen Bootloader f√ºr mehrere Mikrocontroller (im Folgenden - MK) umgangen.  Wir empfehlen auch, den <a href="https://limitedresults.com/2019/11/pwn-the-esp32-forever-flash-encryption-and-sec-boot-keys-extraction/">Artikel</a> √ºber das Brechen des ESP32 zu lesen. </p><br><p>  Die theoretische Grundlage der Studie war die <a href="https://wiki.newae.com/Tutorial_A9_Bypassing_LPC1114_Read_Protect">Richtlinie zum</a> erfolgreichen Lesen der gesch√ºtzten Firmware f√ºr LPC1114 √ºber einen Maskenlader mit ChipWhisperer. </p><br><p>  Wie im ersten Artikel haben wir uns entschlossen, Experimente mit dem MK STM32F103RBT6-Board durchzuf√ºhren: </p><br><img src="https://habrastorage.org/webt/nc/ul/rw/nculrwzmxjlbwnjkwqzs9wlpq3e.png"><br><p>  <em>Karte STM32F103RBT6</em> </p><br><p>  Die F√§higkeit, Daten in den Flash- und RAM-Sektor zu schreiben oder diese zu lesen sowie andere Aktionen mit dem MK-Speicher auszuf√ºhren, wird durch den Wert des Schutzbytes (f√ºr STM32 - RDP) bestimmt.  F√ºr verschiedene MK sind die Werte und der Zweck der Schutzbytes sowie der Algorithmus zu deren √úberpr√ºfung unterschiedlich. </p><br><p>  <strong>Hardware-Setup</strong> </p><br><p>  Beginnen wir mit dem Experiment.  Zuerst m√ºssen Sie ChipWhisperer gem√§√ü der Abbildung an MK anschlie√üen: </p><br><img src="https://habrastorage.org/webt/cw/fs/8s/cwfs8sdseto5gdlv8bcedgk9wzg.png"><br><p>  <em>Anschlussplan von ChipWhisperer an STM32 zum Auslesen der gesch√ºtzten Firmware √ºber einen Maskenlader</em> </p><br><p>  Elemente, die von der STM32F103RBT6-Karte entfernt werden sollen, sind im Diagramm durchgestrichen (im Gegensatz zum Standard-MK-Anschluss).  Die Pfeile kennzeichnen die Anschlusspunkte von ChipWhisperer und die Signaturen die Pins. </p><br><p>  Das Vorhandensein von externem Quarz, wie in der Abbildung gezeigt, ist nicht erforderlich, da der MK STM32F103RBT6 bei der Arbeit mit einem Maskenlader eine interne UHR mit einer Frequenz von 24 MHz verwendet, sodass keine Synchronisation zwischen ChipWhisperer und MK stattfindet. </p><br><p>  Fahren wir mit der Einrichtung von ChipWhisperer fort.  Wie oben erw√§hnt, betr√§gt die empfohlene Frequenz von ChipWhisperer 24 MHz (oder ein anderes Vielfaches).  Je h√∂her die Multiplizit√§t dieser Frequenz ist, desto genauer k√∂nnen Sie den Moment des Anschlags einstellen.  Aufgrund der fehlenden Synchronisation ist die Auswahl des Parameters scope.glitch.offset optional und es kann ein beliebiger Wert zugewiesen werden. </p><br><p> Die Parameter scope.glitch.repeat und scope.glitch.width m√ºssen abh√§ngig von der eingestellten Frequenz von ChipWhisperer gew√§hlt werden.  Bei einem gro√üen Frequenzwert verschmelzen alle Kurzzeitimpulse, deren Anzahl mit scope.glitch.repeat eingestellt wird, zu einem langen Impuls.  Daher k√∂nnen Sie den Wert des Parameters scope.glitch.width und scope.glitch.repeat fix ausw√§hlen oder umgekehrt.  Wir fanden heraus, dass die optimale Pulsdauer ungef√§hr 80 ns betragen sollte (definiert als die Pulsbreite bei halbem Maximum). </p><br><p>  Es bleibt die Auswahl des Wertes des Parameters scope.glitch.ext_offset. </p><br><p>  <strong>Auswahl scope.glitch.ext_offset</strong> </p><br><p>  Zuerst m√ºssen Sie den Moment des Angriffs ausw√§hlen.  Gem√§√ü dem im <a href="https://www.st.com/content/ccc/resource/technical/document/application_note/51/5f/03/1e/bd/9b/45/be/CD00264342.pdf/files/CD00264342.pdf/jcr:content/translations/en.CD00264342.pdf">Dokument</a> des STM-Unternehmens dargestellten Schema wird der Schutzbytewert √ºberpr√ºft, nachdem eine Anforderung zum Lesen von Daten aus dem Flash-Sektor empfangen wurde: </p><br><img src="https://habrastorage.org/webt/m7/b-/ja/m7b-jat7np90pioveykbe8giw6y.jpeg"><br><p>  <em>Der Algorithmus zum Beantworten einer Anforderung zum Lesen von Daten aus dem Flash-Sektor</em> </p><br><p>  Um die G√ºltigkeit eines solchen √úberpr√ºfungsschemas zu √ºberpr√ºfen, lesen wir den ausf√ºhrbaren Bootloader-Code eines √§hnlichen MK ohne RDP-Schutz √ºber ST-Link.  Die folgenden Abbildungen zeigen Teile des Algorithmus f√ºr die Verarbeitung von Lesespeicherbefehlen. </p><br><img src="https://habrastorage.org/webt/tf/1k/uf/tf1kufh_t31hbeol-vhdxzooqba.png"><br><p>  <em>Gesamtansicht der Verarbeitung eines Speicherlesebefehls (der Aufruf der RDP-Pr√ºffunktion und das Senden von NACK im Falle einer fehlgeschlagenen Pr√ºfung sind deutlich sichtbar)</em> </p><br><img src="https://habrastorage.org/webt/as/vk/3h/asvk3h81acmw7vjx75he0tcimga.jpeg"><br><p>  <em>RDP-Validierungsfunktionsk√∂rper</em> </p><br><p> Lassen Sie uns auf den Hauptteil der RDP-Pr√ºffunktion achten: Es ist zu sehen, dass das Register mit <code>0x40022000 + 0x1C</code> , einer logischen Verschiebung von 30 Bit und einer Verzweigung gelesen wird.  Aus der Dokumentation des <a href="https://www.st.com/content/ccc/resource/technical/document/programming_manual/10/98/e8/d4/2b/51/4b/f5/CD00283419.pdf/files/CD00283419.pdf/jcr:content/translations/en.CD00283419.pdf">PM0075-Programmierhandbuchs (STM32F10xxx-Flash-Speicher-Mikrocontroller)</a> geht hervor, dass <code>0x40022000</code> die Basisadresse des Flash-Speicher-Controllers ist und <code>0x1C</code> der <strong>FLASH_OBR-</strong> Registerversatz, an dem wir das zweite Bit von <strong>RDPRT</strong> interessiert sind: <strong>Leseschutz</strong> , das den RDP-Schutzstatus enth√§lt. </p><br><p>  Der notwendige Angriffsmoment ist die Entwicklung des <code>LDR</code> Befehls (Memory Loading).  Diese Anweisung befindet sich zwischen der Anforderung zum Lesen der Firmware (Senden eines <code>0x11</code> Bytes mit einer <code>0xEE</code> ) und der <code>ACK</code> / <code>NOACK</code> MK-Antwort von UART.  Um diesen Moment visuell zu fixieren, muss das Oszilloskop an UART1_RX (Pin PA10) und UART1_TX (Pin PA9) angeschlossen und anschlie√üend die Spannungs√§nderung gem√§√ü UART1 √ºberwacht werden.  Folglich sollte die Power Attack-Wellenform mit dem ausgew√§hlten scope.glitch.ext_offset-Wert ungef√§hr so ‚Äã‚Äãaussehen: </p><br><img src="https://habrastorage.org/webt/fz/dm/j5/fzdmj5iyu5zfmcvmbqx0hf2mqms.jpeg"><br><p>  <em>Den Moment des Angriffs ausw√§hlen</em> </p><br><p>  <strong>Firmware-Leseskript</strong> </p><br><p>  Jetzt m√ºssen Sie den Trigger-Moment des CW_TRIG-Triggers im Python-Code angeben, um den Moment der √úbertragung der Pr√ºfsumme √ºber UART1_RX abzufangen.  ChipWhisperer verf√ºgt √ºber eine Bibliothek f√ºr die Kommunikation mit dem STM32 MK-Maskenlader.  Im normalen Modus wird diese Bibliothek zum Herunterladen von Firmware aus Handb√ºchern auf das MK verwendet. Dabei wird die Klassenklasse <code>class STM32FSerial(object)</code> sich in der Datei <code>programmer_stm32fserial.py</code> unter dem Pfad <code>software/chipwhisperer/hardware/naeusb/</code> .  Um den Trigger zu aktivieren, m√ºssen Sie diese Klasse in das ausf√ºhrbare Hauptskript kopieren, damit auf die Klassenmethode <code>CmdGeneric(self, cmd)</code> global <code>scope.arm()</code> , und den Befehl <code>scope.arm()</code> hinzuf√ºgen, bevor Sie die Pr√ºfsumme (0xEE) der Anforderung zum Lesen des Speichersektors senden.  Die Schlussklasse ist im Spoiler unten angegeben. </p><br><div class="spoiler">  <b class="spoiler_title">Klasse f√ºr die Kommunikation von ChipWhisperer mit STM32</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> logging <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> chipwhisperer.common.utils <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> util <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> chipwhisperer.hardware.naeusb.programmer_stm32fserial <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> supported_stm32f <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> chipwhisperer.capture.api.programmers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Programmer <span class="hljs-comment"><span class="hljs-comment"># class which can normally using internal CW library for reading STM32 firmware by UART class STM32Reader(Programmer): def __init__(self): super(STM32Reader, self).__init__() self.supported_chips = supported_stm32f self.slow_speed = False self.small_blocks = True self.stm = None def stm32prog(self): if self.stm is None: stm = self.scope.scopetype.dev.serialstm32f else: stm = self.stm stm.slow_speed = self.slow_speed stm.small_blocks = self.small_blocks return stm def stm32open(self): stm32f = self.stm32prog() stm32f.open_port() def stm32find(self): stm32f = self.stm32prog() stm32f.scope = self.scope sig, chip = stm32f.find() def stm32readMem(self, addr, lng): stm32f = self.stm32prog() stm32f.scope = self.scope #answer = stm32f.readMemory(addr, lng) answer = self.ReadMemory(addr, lng) return answer def stm32GetID(self): stm32f = self.stm32prog() stm32f.scope = self.scope answer = stm32f.cmdGetID() return answer # Needed for connection to STM after reload by reset_target(scope) method def FindSTM(self): #setup serial port (or CW-serial port?) stm32f = self.stm32prog() try: stm32f.initChip() except IOError: print("Failed to detect chip. Check following: ") print(" 1. Connections and device power. ") print(" 2. Device has valid clock (or remove clock entirely for internal osc).") print(" 3. On Rev -02 CW308T-STM32Fx boards, BOOT0 is routed to PDIC.") raise boot_version = stm32f.cmdGet() chip_id = stm32f.cmdGetID() for t in supported_stm32f: if chip_id == t.signature: # print("Detected known STMF32: %s" % t.name) stm32f.setChip(t) return chip_id, t # print("Detected unknown STM32F ID: 0x%03x" % chip_id) return chip_id, None</span></span></code> </pre> </div></div><br><p>  Es ist zu beachten, dass Sie mit dem STM32F1xx-Maskenlader in einer einzigen Anforderung nicht mehr als 256 Byte Firmware aus einem angegebenen Flash-Sektor lesen k√∂nnen.  Daher m√ºssen beim Lesen der gesamten Firmware des MK w√§hrend des Vcc-Glitch-Angriffs mehrere Leseanforderungen ausgef√ºhrt werden.  Die empfangenen 256 Bytes sollten dann in acht 32-Byte-Arrays aufgeteilt werden und daraus eine HEX-Datei bilden. </p><br><div class="spoiler">  <b class="spoiler_title">HEX-Konvertercode und Zusatzfunktionen</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int2str_0xFF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int_number, number_of_bytes)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'{0:0{1}X}'</span></span>.format(int_number,number_of_bytes_in_string) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data_dividing_from_256_to_32_bytes</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data_to_divide, mem_sector, mem_step=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mem_sector &gt; <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>: mem_conversion = mem_sector &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span> mem_conversion = mem_sector - (mem_conversion &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) data_out = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(int(<span class="hljs-number"><span class="hljs-number">256</span></span>/mem_step)): data_vector = data_to_divide[(i * mem_step):((i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * mem_step)] mem_calc = mem_conversion + (i * mem_step) data_out += read_and_convert_data_hex_file(data_vector, mem_calc, mem_step) + <span class="hljs-string"><span class="hljs-string">'\n'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_out <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_and_convert_data_hex_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data_to_convert, memory_address, mem_step)</span></span></span><span class="hljs-function">:</span></span> addr_string = memory_address -((memory_address &gt;&gt; <span class="hljs-number"><span class="hljs-number">20</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>) data_buffer = <span class="hljs-string"><span class="hljs-string">''</span></span> crcacc = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(data_to_convert)): data_buffer += int2str_0xFF(data_to_convert[x], <span class="hljs-number"><span class="hljs-number">2</span></span>) crcacc += data_to_convert[x] crcacc += mem_step temp_addr_string = addr_string <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>): crcacc += temp_addr_string &gt;&gt; i*<span class="hljs-number"><span class="hljs-number">4</span></span> temp_addr_string -= ((temp_addr_string &gt;&gt; i*<span class="hljs-number"><span class="hljs-number">4</span></span>) &lt;&lt; i*<span class="hljs-number"><span class="hljs-number">4</span></span>) crcacc_2nd_symbol = (crcacc &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> crcacc = (crcacc_2nd_symbol &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) - crcacc <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> crcacc == <span class="hljs-number"><span class="hljs-number">0x100</span></span>: crcacc = <span class="hljs-number"><span class="hljs-number">0</span></span> RECTYP = <span class="hljs-number"><span class="hljs-number">0x00</span></span> out_string = <span class="hljs-string"><span class="hljs-string">':'</span></span>+ Int_To_Hex_String(mem_step, <span class="hljs-number"><span class="hljs-number">2</span></span>) +\ Int_To_Hex_String((addr_string),<span class="hljs-number"><span class="hljs-number">4</span></span>) +\ Int_To_Hex_String(RECTYP, <span class="hljs-number"><span class="hljs-number">2</span></span>) +\ data_buffer +\ Int_To_Hex_String(crcacc, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out_string <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_to_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(info_to_output, File_name, directory)</span></span></span><span class="hljs-function">:</span></span> file = open(directory + File_name + <span class="hljs-string"><span class="hljs-string">'.hex'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) file.write(info_to_output) file.close() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset_target</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scope)</span></span></span><span class="hljs-function">:</span></span> scope.io.nrst = <span class="hljs-string"><span class="hljs-string">'low'</span></span> time.sleep(<span class="hljs-number"><span class="hljs-number">0.05</span></span>) scope.io.nrst = <span class="hljs-string"><span class="hljs-string">'high'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple Range = namedtuple(<span class="hljs-string"><span class="hljs-string">'Range'</span></span>, [<span class="hljs-string"><span class="hljs-string">'min'</span></span>, <span class="hljs-string"><span class="hljs-string">'max'</span></span>, <span class="hljs-string"><span class="hljs-string">'step'</span></span>])</code> </pre></div></div><br><p>  Das Konfigurieren der ChipWhisperer-Einstellungen ist nun abgeschlossen.  Das letzte Skript zum Lesen der Firmware lautet wie folgt: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># string of start HEX file Start_of_File_Record = ':020000040800F2' # string of end HEX file End_of_File_Record = ':00000001FF' length_of_sector = 256 if length_of_sector % 4 != 0: sys.exit('length_of_sector must be equal to 4') output_to_file_buffer = '' output_to_file_buffer += Start_of_File_Record + '\n' mem_current = mem_start while mem_current &lt; mem_stop: # flush the garbage from the computer's target read buffer target.ser.flush() # run aux stuff that should run before the scope arms here reset_target(scope) # initialize STM32 after each reset prog.FindSTM() try: # reading of closed memory sector data = prog.stm32readMem(mem_current, length_of_sector) except Exception as message: message = str(message) if "Can't read port" in message: # print('Port silence') pass elif 'Unknown response. 0x11: 0x0' in message: # print('Crashed. Reload!') pass elif 'NACK 0x11' in message: # print('Firmware is closed!') pass else: # print('Unknown error:', message, scope.glitch.offset, scope.glitch.width, scope.glitch.ext_offset) pass else: data_to_out = data_dividing_from_256_to_32_bytes (data, mem_current) print(data_to_out) output_to_file_buffer += data_to_out mem_current += length_of_sector output_to_file_buffer += End_of_File_Record + '\n' send_to_file(output_to_file_buffer, File_name, directory)</span></span></code> </pre> <br><p>  Alle auskommentierten <code>print()</code> -Nachrichten nach der Zeile mit <code>except Exception as</code> Hilfe zur √úberwachung des MC-Status bei der Suche nach den optimalen Parametern f√ºr den St√∂rimpuls.  Um den spezifischen Status von MK zu verfolgen, gen√ºgt es, die erforderliche <code>print()</code> Meldung zu entfernen. </p><br><p>  <strong>Ergebnisse lesen</strong> </p><br><p>  Das Video zeigt das Herunterladen der Firmware auf das MK √ºber den ST-LINK-Programmierer, das √úbertragen von RDP in den Schutzstatus und das anschlie√üende Lesen der Firmware: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CRfg9-1BV0k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Die folgenden Fehler k√∂nnen erfolgreiche Vcc-Glitch-Angriffe verhindern: </p><br><p>  ‚Ä¢ Lesen des falschen Speichersektors; </p><br><p>  ‚Ä¢ Spontanes Entfernen der Firmware. </p><br><p>  Eine genaue Auswahl des Angriffsmoments durch Erh√∂hen der Frequenz von ChipWhisperer hilft, solche Fehler zu vermeiden. </p><br><p>  Nach der Entwicklung und dem Debuggen des Algorithmus zum Lesen der gesch√ºtzten Firmware haben wir ein Testlesen der Firmware des ST-LINK-V2.1-Programmierger√§ts durchgef√ºhrt, das auf dem STM32F103CBT6 MK funktioniert.  Ein paar Firmware haben wir auf eine "saubere" MK STM32F103CBT6 aufgen√§ht und diese anstelle der werkseitigen installiert.  Infolgedessen arbeitete ST-LINK-V2.1 mit dem ersetzten MK im normalen Modus, als g√§be es keinen Ersatz. </p><br><p>  Wir haben auch versucht, eine Reihe von Angriffen auf STM32F303RCT7 auszuf√ºhren.  Dieser MK hat sich w√§hrend des Angriffs identisch zu STM32F103RBT6 verhalten, aber die Antwort auf die Lesespeicheranforderung enthielt ein Byte von 0x00, das nicht mit dem erwarteten Ergebnis √ºbereinstimmte.  Der Grund f√ºr dieses Versagen war ein komplexeres und entwickeltes Prinzip zur Organisation des Schutzes dieser MKs. </p><br><p>  Es gibt zwei Schutzzust√§nde im STM32F1xx MK: Der Schutz ist ausgeschaltet (Stufe 0) und eingeschaltet (Stufe 1).  Bei √§lteren Modellen gibt es drei Schutzzust√§nde: Der Schutz ist deaktiviert (Stufe 0, RDP = 0x55AA), der Schutz des Flash- und SRAM-Speichers (Stufe 2, RDP = 0x33CC) und nur der Schutz des Flash-Speichers (Stufe 1, RDP nimmt andere Werte an als von 0x55AA und 0x33CC).  Da Level 1 viele RDP-Werte annehmen kann, ist das Einstellen von Level 0 ziemlich schwierig.  Auf der anderen Seite ist es m√∂glich, die Schutzstufe von Stufe 2 auf Stufe 1 zu senken, indem ein Bit im RDP-Byte (siehe Abbildung unten) heruntergefahren wird, wodurch auf den SRAM-Speicher zugegriffen werden kann. </p><br><img src="https://habrastorage.org/webt/dj/by/ef/djbyefc1yji_gpevygy72yzvtjm.jpeg"><br><p>  <em>Vergleich der RDP-Werte f√ºr verschiedene Firmware-Schutzstufen</em> </p><br><p>  Es bleibt nur zu verstehen, wie ein Angreifer dies ausnutzen kann.  Verwenden Sie beispielsweise die in <a href="https://www.usenix.org/system/files/conference/woot17/woot17-paper-obermaier.pdf">diesem Artikel</a> beschriebene CBS-Methode (Cold-Boot Stepping).  Diese Methode basiert auf einer schrittweisen Momentaufnahme des Status des SRAM-Speichers (die H√§ufigkeit jeder Momentaufnahme lag im Mikrosekundenbereich) nach dem Laden des MC, um Verschl√ºsselungsschl√ºssel, verborgene Kennw√∂rter oder andere wertvolle Informationen zu erhalten.  Die Autoren schlagen vor, dass die CBS-Methode auf allen STM32 MK-Serien funktioniert. </p><br><p>  <strong>Schlussfolgerungen</strong> </p><br><p>  Um unsere Experimente zusammenzufassen.  Wir haben mehrere Tage gebraucht, um einen Vcc-Glitch-Angriff mit den Daten einer fr√ºheren Studie (die hier nachzulesen <a href="https://habr.com/ru/company/ntc-vulkan/blog/480500/">ist</a> ) durchzuf√ºhren.  Das Erlernen solcher Angriffe ist also einfach genug. </p><br><p>  Vcc-Glitch-Angriffe sind gef√§hrlich, weil sie schwer zu verteidigen sind.  Um die Wahrscheinlichkeit eines erfolgreichen Durchf√ºhrens solcher Angriffe zu verringern, wird vorgeschlagen, MK mit einem h√∂heren Schutzniveau zu verwenden. </p><br><p> <a href="https://raccoonsecurity.ru/"><img src="https://habrastorage.org/webt/6d/ts/lv/6dtslv2uikkshhl7tmsi7fgjp0y.png"></a> </p><br><p>  Raccoon Security ist ein spezielles Expertenteam des Volcano Scientific and Technical Center im Bereich praktischer Informationssicherheit, Kryptographie, Schaltungstechnik, Reverse Engineering und der Erstellung von Low-Level-Software. </p><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483732/">https://habr.com/ru/post/de483732/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483720/index.html">Was brachte uns Pandas 1.0</a></li>
<li><a href="../de483722/index.html">Geoanalytik f√ºr den Einzelhandel, Teil 1: Wir automatisieren den Prozess der Standortwahl f√ºr ein Unternehmen. 2GIS + MS Azure + ML</a></li>
<li><a href="../de483724/index.html">Arbeiten Sie mit Custom-Reifen Komplex Redd</a></li>
<li><a href="../de483726/index.html">Vanille JavaScript und HTML. Keine Frameworks. Keine Bibliotheken. Kein Problem</a></li>
<li><a href="../de483730/index.html">Programmers Union 2: Slippers h√∂rte auf zu lachen und wurde nachdenklich</a></li>
<li><a href="../de483734/index.html">Welchen Preis zahlen wir f√ºr die Verwendung von async / await in JS / C # / Rust?</a></li>
<li><a href="../de483736/index.html">Reverse Image Search: Ein Leitfaden von Bellingcat Detective Agency</a></li>
<li><a href="../de483740/index.html">Dynamisches Routing (insbesondere BGP) √ºber den OpenVPN-Tunnel unter Linux (und wahrscheinlich * BSD) einrichten</a></li>
<li><a href="../de483744/index.html">Old New Year Sale</a></li>
<li><a href="../de483746/index.html">Gateway Station: Durchgang zur Mondlinie, Zugang zur Marsstation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>