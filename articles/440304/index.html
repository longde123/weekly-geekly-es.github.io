<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úÖ üöô ‚ûñ Interrupciones de dispositivos externos en un sistema x86. Parte 3. Configuraci√≥n del enrutamiento de interrupci√≥n en el conjunto de chips utilizando el ejemplo coreboot üë©üèº‚Äçüç≥ üö¢ ‚òØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos considerando configurar interrupciones desde dispositivos externos en el sistema x86. 
 En la parte 1 (La evoluci√≥n de los controladores d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interrupciones de dispositivos externos en un sistema x86. Parte 3. Configuraci√≥n del enrutamiento de interrupci√≥n en el conjunto de chips utilizando el ejemplo coreboot</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440304/"> Continuamos considerando configurar interrupciones desde dispositivos externos en el sistema x86. <br>  En la parte 1 (La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">evoluci√≥n de los controladores de interrupci√≥n</a> ), examinamos los fundamentos te√≥ricos de los controladores de interrupci√≥n y los t√©rminos generales; en la parte 2 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Opciones de arranque del kernel de Linux</a> ), observamos c√≥mo el sistema operativo elige entre los controladores en la pr√°ctica.  En esta parte, veremos c√≥mo el BIOS configura el enrutamiento IRQ para los controladores de interrupci√≥n en el conjunto de chips. <br><br>  Ninguna empresa moderna de desarrollo de BIOS (AwardBIOS / AMIBIOS / Insyde) divulga el c√≥digo fuente de sus programas.  Pero afortunadamente existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Coreboot</a> , un proyecto para reemplazar el BIOS propietario con software libre.  En su c√≥digo, veremos c√≥mo se configura el enrutamiento de interrupci√≥n en el conjunto de chips. <br><br><img src="https://habrastorage.org/webt/mx/vi/wu/mxviwuisp5rglec_kgsk872hmy8.png"><br><br><a name="habracut"></a><br><h2>  Teor√≠a </h2><br>  Primero, actualizar y complementar nuestro conocimiento te√≥rico.  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1,</a> identificamos una ruta de interrupci√≥n com√∫n para el caso de PIC y APIC. <br><br>  <b>Pic:</b> <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>APIC:</b> <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  En estas figuras, el mapeo del dispositivo PCI ‚Üí PIR se muestra de manera abstracta; de hecho, es algo m√°s complicado.  En realidad, cada dispositivo PCI tiene 4 l√≠neas de interrupci√≥n (INTA #, INTB #, INTC #, INTD #).  Cada dispositivo PCI puede tener hasta 8 funciones y cada funci√≥n ya tiene una interrupci√≥n INTx #.  La l√≠nea de INTx # que obtendr√° cada funci√≥n del dispositivo est√° fijada en el hardware o est√° determinada por la configuraci√≥n del dispositivo. <br><br><img src="https://habrastorage.org/webt/dk/ny/gh/dknyghwfo8gktn5l_lmmqb5awz0.png"><br><br>  En esencia, las funciones son bloques l√≥gicos separados.  Por ejemplo, en un dispositivo PCI puede haber una funci√≥n controlador Smbus, funci√≥n controlador SATA, funci√≥n puente LPC.  En el lado del sistema operativo, cada funci√≥n es un dispositivo separado con su propio espacio de configuraci√≥n PCI Config. <br><br>  En el caso m√°s simple (y m√°s com√∫n) en un dispositivo PCI, solo hay una funci√≥n, cuya interrupci√≥n es a trav√©s de la l√≠nea INTA #.  Pero, en general, el dispositivo puede tener incluso m√°s de 4 funciones (como dijimos antes de 8), entonces algunas de ellas deber√°n plantarse en una l√≠nea INTx # (las interrupciones PCI pueden dividir la l√≠nea).  Adem√°s, para los dispositivos PCI incluidos en el conjunto de chips al escribir en registros especiales, a menudo es posible indicar qu√© funciones usan qu√© l√≠neas INTx # (y si se usan en absoluto). <br><br>  Sistematizando nuestro conocimiento, denotamos la ruta (enrutamiento) de las interrupciones de cualquier funci√≥n PCI a trav√©s de INTx # ‚Üí PIRQy ‚Üí IRQz, donde: <br><br><ul><li>  INTx # - l√≠nea INT # (INTA #, INTB #, INTC #, INTD #) del dispositivo PCI que utilizar√° la funci√≥n </li><li>  PIRQy: la l√≠nea PIRQ (PIRQA, PIRQB, ...) desde el PIR al que est√° conectada la l√≠nea INTx # </li><li>  IRQz: l√≠nea IRQ (0, 1, 2, ...) en el controlador de interrupci√≥n (APIC / PIC), que est√° conectado a la l√≠nea PIRQy </li></ul><br><h3>  ¬øPor qu√© no puedes conectarte a todas partes INTA # ‚Üí PIRQA, INTB # ‚Üí PIRQB, ...? </h3><br>  ¬øPor qu√© molestarse en configurar el enrutamiento?  Supongamos que decidimos no molestarnos y obtener todas las l√≠neas de interrupci√≥n de todos los dispositivos PCI a las mismas l√≠neas PIRQ.  Digamos esto: <br><br><ul><li>  INTA # ‚Üí PIRQA </li><li>  INTB # ‚Üí PIRQB </li><li>  INTC # ‚Üí PIRQC </li><li>  INTD # ‚Üí PIRQD </li></ul><br>  Como dijimos anteriormente, el caso m√°s com√∫n es cuando un dispositivo PCI tiene una funci√≥n y su interrupci√≥n est√° conectada a la l√≠nea INTA # (porque ¬øpor qu√© el desarrollador del dispositivo debe iniciarlo de manera diferente?).  Entonces, si de repente decidimos comenzar todas las l√≠neas como escribimos, entonces casi todas las interrupciones de los dispositivos se dividir√°n en l√≠neas PIRQA.  Digamos que termin√≥ en IRQ16.  Luego, cada vez que se informa al procesador que se ha producido una interrupci√≥n en la l√≠nea IRQ16, tendr√° que interrogar a los controladores de todos los dispositivos conectados a la l√≠nea IRQ16 (PIRQA) si tienen una interrupci√≥n.  Si hay muchos de estos dispositivos, esto naturalmente no acelerar√° la respuesta del sistema a la interrupci√≥n.  Y las l√≠neas PIRQB-PIRQD en este caso estar√°n inactivas en su mayor parte.  Para mayor claridad, la figura que ilustra el problema: <br><br><img src="https://habrastorage.org/webt/cz/dv/bf/czdvbfsnymw5xyyqujavawdcv_m.png"><br><br>  Pero todo se podr√≠a hacer as√≠: <br><br><img src="https://habrastorage.org/webt/dk/3e/x6/dk3ex67xjmm_9h0q3miq2djqnti.png"><br><br>  La imagen es un poco confusa, pero el punto es que simplemente conectamos las l√≠neas INTx # con PIRQy a round-robin (PIRQA, PIRQB, PIRQC, PIRQD, PIRQA, PIRQB, PIRQC, PIRQD, PIRQA, PIRQB, PIRQC, PIRQD). ..) <br><br>  Cabe se√±alar que aqu√≠ es necesario tener en cuenta no solo que se carga el mismo n√∫mero de funciones PCI en cada l√≠nea PIRQ.  Despu√©s de todo, algunas funciones pueden crear interrupciones muy raramente, y algunas permanentemente (controlador Ethernet, por ejemplo).  En este caso, incluso la asignaci√≥n de una l√≠nea PIRQ separada para interrupciones con dicha funci√≥n puede estar bastante justificada. <br><br>  Con base en lo anterior, el desarrollador del BIOS, entre otras cosas, tiene la tarea de garantizar que las l√≠neas PIRQ est√©n cargadas uniformemente con interrupciones. <br><br><h3>  ¬øQu√© debe hacer el BIOS? </h3><br>  Sistematizamos en la figura: <br><br><img src="https://habrastorage.org/webt/pm/rq/xg/pmrqxgkdu0nkjz6yb44vdn79a8q.png"><br><br><ul><li>  <b>1) Indique qu√© l√≠nea de INTx # extrae cada funci√≥n de los dispositivos PCI</b> <br>  Para dispositivos PCI externos, este elemento no se realiza, pero para las funciones de los dispositivos PCI incluidos en el conjunto de chips puede ser. </li><li>  <b>2) Configure la asignaci√≥n INTx # ‚Üí PIRQy para cada dispositivo PCI</b> <br>  Vale la pena se√±alar que puede haber m√°s de cuatro se√±ales PIRQy est√°ndar (PIRQA, PIRQB, PIRQC, PIRQD).  Por ejemplo 8: PIRQA-PIRQH. </li></ul><br>  Las se√±ales PIRQy van en la l√≠nea IRQz del controlador de interrupci√≥n seleccionado (APIC / PIC).  Como queremos admitir todos los m√©todos de carga posibles (consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte 2</a> ), debemos completar ambos mapas: <br><br><ul><li>  <b>3a) Complete el mapeo PIRQy ‚Üí IRQz1 para la comunicaci√≥n PIR ‚Üí I / O APIC</b> <br>  Pero generalmente esto no es necesario, ya que las l√≠neas PIRQy est√°n fijas en la l√≠nea APIC.  La soluci√≥n com√∫n es PIRQA ‚Üí IRQ16, PIRQB ‚Üí IRQ17, ... La soluci√≥n m√°s simple, porque  Al colocar l√≠neas PIRQy en l√≠neas de controlador ‚â•16, no tiene que preocuparse por conflictos con interrupciones inseparables de dispositivos ISA. </li><li>  <b>3b) Rellene el mapeo PIRQy ‚Üí IRQz2 para la comunicaci√≥n PIR ‚Üí PIC</b> <br>  Esto debe proporcionarse en caso de que usemos enrutamiento a trav√©s del controlador PIC.  No existe una soluci√≥n tan inequ√≠voca como en el caso de APIC, porque en el caso de PIC, uno debe recordar la posibilidad de conflictos con interrupciones inseparables de los dispositivos ISA. </li></ul><br>  El √∫ltimo cuarto elemento es necesario para ayudar al sistema operativo a determinar el enrutamiento de interrupci√≥n.  El dispositivo en s√≠ generalmente no utiliza estos registros. <br><br><ul><li>  <b>4) Complete los registros de l√≠nea de interrupci√≥n / pin de interrupci√≥n para cada funci√≥n PCI</b> <br>  En general, el registro de Pin de interrupci√≥n se rellena autom√°ticamente y generalmente es de solo lectura, por lo que lo m√°s probable es que solo sea necesario completar el registro de la l√≠nea de interrupci√≥n.  Esto debe proporcionarse en caso de que utilicemos el enrutamiento a trav√©s del controlador PIC sin proporcionar al sistema operativo ninguna tabla sobre las interrupciones de enrutamiento (consulte nuevamente la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte 2</a> ).  Si se proporcionan tablas y esta asignaci√≥n es coherente con las tablas de enrutamiento ($ PIR / ACPI), el sistema operativo a menudo la abandona. </li></ul><br>  Cabe se√±alar que todav√≠a no tocamos las tablas $ PIR / MPtable / ACPI y consideramos c√≥mo configurar los registros del conjunto de chips en t√©rminos de interrupciones de enrutamiento antes de transferir el control al cargador del sistema.  Las tablas de interrupci√≥n son un tema para un art√≠culo separado (posiblemente uno futuro). <br><br>  Entonces, se estudian los fundamentos te√≥ricos, ¬°finalmente comenzamos a practicar! <br><br><h2>  Practica </h2><br>  Como ejemplo para los art√≠culos de esta serie, uso una placa personalizada con un procesador Intel Haswell i7 y un chipset LynxPoint-LP.  En esta placa, lanc√© coreboot junto con SeaBIOS.  Coreboot proporciona inicializaci√≥n espec√≠fica de hardware, y la carga √∫til de SeaBIOS proporciona una interfaz de BIOS para sistemas operativos.  En este art√≠culo, no describir√© el proceso de configuraci√≥n de coreboot, sino que tratar√© de mostrar con un ejemplo qu√© tipo de configuraci√≥n de BIOS se debe realizar en el conjunto de chips para enrutar las interrupciones IRQ desde dispositivos externos. <br><br>  Dado que el proyecto coreboot se est√° desarrollando activamente para que el art√≠culo est√© siempre actualizado, consideraremos el c√≥digo utilizando el ejemplo de la √∫ltima versi√≥n fija <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.9</a> (versi√≥n 2018-12-20). <br><br>  La placa base m√°s cercana a la m√≠a es Google Beltino con variaci√≥n Panther.  La carpeta principal de esta placa base es la carpeta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"src \ mainboard \ google \ beltino"</a> .  Todas las configuraciones se concentran aqu√≠ y el c√≥digo espec√≠fico de esta placa. <br><br>  Entonces, comencemos a ordenar d√≥nde est√°n configurados los elementos anteriores: <br><br><h4>  1) Indique qu√© l√≠nea de INTx # extrae cada funci√≥n de los dispositivos PCI </h4><br>  Esta informaci√≥n se define en el archivo <a href="">"src / mainboard / google / beltino / romstage.c"</a> en la estructura rcba_config a trav√©s de los registros DxxIP (Device xx Interrupt Pin Register (IP)).  Este registro indica qu√© pin INTx # (A / B / C / D) cada una de las funciones del dispositivo emite una interrupci√≥n. <br><br>  Opciones posibles (vea el archivo <a href="">"src / southbridge / intel / lynxpoint / pch.h"</a> ): <br><br><pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>h = No interrupt <span class="hljs-number"><span class="hljs-number">1</span></span>h = INTA# <span class="hljs-number"><span class="hljs-number">2</span></span>h = INTB# <span class="hljs-number"><span class="hljs-number">3</span></span>h = INTC# <span class="hljs-number"><span class="hljs-number">4</span></span>h = INTD#</code> </pre> <br>  Se supone que varias funciones usan el mismo pin. <br><br>  Se supone que las funciones no pueden usar el pin para las interrupciones (sin interrupci√≥n). <br>  Todo lo que vimos en la figura al comienzo del art√≠culo. <br><br>  El c√≥digo completo es responsable del art√≠culo designado por nosotros: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt pin register (board specific) */</span></span> RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)), RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)), RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTB &lt;&lt; D28IP_P4IP)), RCBA_SET_REG_32(D27IP, (INTA &lt;&lt; D27IP_ZIP)), RCBA_SET_REG_32(D26IP, (INTA &lt;&lt; D26IP_E2P)), RCBA_SET_REG_32(D22IP, (NOINT &lt;&lt; D22IP_MEI1IP)), RCBA_SET_REG_32(D20IP, (INTA &lt;&lt; D20IP_XHCI)),</code> </pre> <br>  Para una mejor comprensi√≥n, considere algunos ejemplos: <br><br>  <b>Ejemplo 1:</b> <br><br>  El dispositivo 0x1d (29 en decimal) tiene una funci√≥n (controlador EHCI). <br><br>  En este caso, asigne una interrupci√≥n a INTA #. <br><br>  00: 1d.0 - INTA # <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)),</code> </pre> <br>  <b>Ejemplo 2</b> <br>  El dispositivo 0x1f (31 en decimal) tiene las funciones controlador de sensor t√©rmico (00: 1f.6), controlador SATA 2 (00: 1f.2), controlador SMBus (00: 1f.3), controlador SATA 1 (00: 1f .2).  Queremos utilizar solo el controlador SMBus, el controlador SATA 1 y el controlador del sensor t√©rmico. <br><br>  00: 1f.2 - INTA # (controlador SATA 1) <br>  00: 1f.3 - INTB # (controlador SMBus) <br>  00: 1f.2 - Sin interrupci√≥n (el controlador SATA 2 no se usa) <br>  00: 1f.6 - INTC # (controlador del sensor t√©rmico) <br><br>  Para esta configuraci√≥n, debe escribir: <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)),</code> </pre> <br>  <b>Ejemplo 3</b> <br><br>  En un dispositivo, el n√∫mero de funciones que necesitamos es m√°s de 4. En el dispositivo 0x1c, cada funci√≥n es responsable del puerto PCI Express.  Para que los puertos 0-5 funcionen, y las interrupciones se distribuyan entre las l√≠neas de manera uniforme, puede configurar esto: <br><br>  00: 1c.0 - INTA # (puerto PCI Express 0) <br>  00.1c.1 - INTB # (puerto PCI Express 1) <br>  00.1c.2 - INTC # (puerto PCI Express 2) <br>  00.1c.3 - INTD # (puerto PCI Express 3) <br>  00.1c.4 - INTA # (puerto PCI Express 4) <br>  00.1c.5 - INTB # (puerto PCI Express 5) <br>  00.1c.6 - Sin interrupci√≥n (puerto no utilizado) <br>  00.1c.7 - Sin interrupci√≥n (puerto no utilizado) <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTB &lt;&lt; D28IP_P2IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTD &lt;&lt; D28IP_P4IP) | (INTA &lt;&lt; D28IP_P5IP) | (INTB &lt;&lt; D28IP_P6IP) | (NOINT &lt;&lt; D28IP_P7IP) | (NOINT &lt;&lt; D28IP_P8IP)),</code> </pre> <br><h4>  2) Configure la asignaci√≥n INTx # ‚Üí PIRQy para cada dispositivo PCI </h4><br>  Esta informaci√≥n tambi√©n se define en el archivo <a href="">"src \ mainboard \ google \ beltino \ romstage.c"</a> <br>  en la estructura rcba_config, pero ya a trav√©s de los registros DxxIR (Device xx Interrupt Route Register). <br><br>  La informaci√≥n en este registro muestra a qu√© l√≠nea PIRQx (A / B / C / D / E / F / G / H) est√° conectada cada l√≠nea de interrupci√≥n INTx #. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt route registers */</span></span> RCBA_SET_REG_32(D31IR, DIR_ROUTE(PIRQG, PIRQC, PIRQB, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* LPC */</span></span> RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* EHCI */</span></span> RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* PCIE */</span></span> RCBA_SET_REG_32(D27IR, DIR_ROUTE(PIRQG, PIRQG, PIRQG, PIRQG)),<span class="hljs-comment"><span class="hljs-comment">/* HDA */</span></span> RCBA_SET_REG_32(D22IR, DIR_ROUTE(PIRQA, PIRQA, PIRQA, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* ME */</span></span> RCBA_SET_REG_32(D21IR, DIR_ROUTE(PIRQE, PIRQF, PIRQF, PIRQF)),<span class="hljs-comment"><span class="hljs-comment">/* SIO */</span></span> RCBA_SET_REG_32(D20IR, DIR_ROUTE(PIRQC, PIRQC, PIRQC, PIRQC)),<span class="hljs-comment"><span class="hljs-comment">/* XHCI */</span></span> RCBA_SET_REG_32(D23IR, DIR_ROUTE(PIRQH, PIRQH, PIRQH, PIRQH)),<span class="hljs-comment"><span class="hljs-comment">/* SDIO */</span></span></code> </pre> <br>  <b>Ejemplo 1:</b> <br><br>  El dispositivo 0x1c (28 en el sistema decimal) son los puertos PCIe como ya descubrimos. <br><br>  Hacemos una conexi√≥n "directa": <br><br><ul><li>  INTA # ‚Üí PIRQA </li><li>  INTB # ‚Üí PIRQB </li><li>  INTC # ‚Üí PIRQC </li><li>  INTD # ‚Üí PIRQD </li></ul><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD))</code> </pre> <br>  <b>Ejemplo 2</b> <br><br>  Dispositivo 0x1d (29 en decimal): una funci√≥n (controlador EHCI) en INTA #, no se utilizan otras l√≠neas. <br><br>  Conecte la l√≠nea INTA # a PIRQD: <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD))</code> </pre> <br>  En este caso, solo el primer registro PIRQD (para INTA #) tiene sentido, el resto no tiene sentido. <br><br><h4>  3a) Rellene el mapeo PIRQy ‚Üí IRQz1 (PIR ‚Üí APIC) </h4><br>  Como ya hemos dicho, el mapeo a menudo se arregla aqu√≠, y este caso no es una excepci√≥n. <br><br><ul><li>  PIRQA ‚Üí IRQ16 </li><li>  PIRQB ‚Üí IRQ17 </li><li>  ... </li><li>  PIRQH ‚Üí IRQ23 </li></ul><br><h4>  3b) Rellene el mapeo PIRQy ‚Üí IRQz2 (PIR ‚Üí PIC) </h4><br>  En coreboot, el contenido para llenar estos registros se define en el archivo <a href="">devicetree.cb</a> en la carpeta de la placa base "src \ mainboard \ google \ beltino \". <br><br>  devicetree.cb (el nombre devicetree para la comunicaci√≥n con un concepto similar en el kernel de Linux, y "cb" es la abreviatura de coreboot) es un archivo especial que refleja la configuraci√≥n de esta placa base: qu√© procesador, qu√© chipset se utilizan, qu√© dispositivos se incluyen en ellos, qu√© apagado, etc.  Adem√°s, se puede especificar informaci√≥n especial para la configuraci√≥n del conjunto de chips en este archivo.  Este es solo el caso que necesitamos: <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span></code> </pre> <br>  Estas l√≠neas especifican la asignaci√≥n PIRQy ‚Üí IRQz2.  En el c√≥digo, despu√©s de analizar el archivo devicetree.cb, se transforman en las variables "config-&gt; pirqX_routing". <br><br>  La variable "config-&gt; pirqa_routing = 0x8b" significar√° que el PIRQA est√° conectado a la l√≠nea de interrupci√≥n IRIC11 (0x0b = 11) del controlador PIC, sin embargo, el bit m√°s alto (que es 0x80) significa que no se realiza el enrutamiento de interrupci√≥n.  Honestamente, en mi experiencia, esto es un error, por defecto vale la pena activar el enrutamiento PIC, el sistema operativo en s√≠ mismo podr√° cambiar a I / O APIC configurando este bit a 1 si es necesario. <br><br>  Es decir, en este caso ser√≠a m√°s correcto escribir: <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> <span class="hljs-comment"><span class="hljs-comment"># not used register "pirqf_routing" = "0x80" # not used register "pirqg_routing" = "0x80" # not used register "pirqh_routing" = "0x80" # not used</span></span></code> </pre><br>  No habilitamos las √∫ltimas 4 interrupciones, porque  La interrupci√≥n IRQ0 siempre se usa bajo el temporizador del sistema y claramente no est√° disponible (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informaci√≥n general de interrupci√≥n compatible con IBM-PC</a> ) <br><br>  Pero si miramos m√°s de cerca el punto 2), veremos que algunos dispositivos PCI usan las l√≠neas PIRQE-PIRQH, por lo que dejarlos desconectados es la forma correcta de dispositivos rotos. <br><br>  Entonces es mejor escribir algo como esto: <br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x03"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x04"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x05"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x06"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0e"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0f"</span></span></code> </pre> <br><br>  El llenado real de los registros correspondientes se produce en el archivo <a href="">src \ southbridge \ intel \ lynxpoint \ lpc.c</a> en la funci√≥n pch_pirq_init. <br><br>  Fragmento de c√≥digo responsable del llenado del registro: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Get the chip configuration */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">config_t</span></span> *config = dev-&gt;chip_info; pci_write_config8(dev, PIRQA_ROUT, config-&gt;pirqa_routing); pci_write_config8(dev, PIRQB_ROUT, config-&gt;pirqb_routing); pci_write_config8(dev, PIRQC_ROUT, config-&gt;pirqc_routing); pci_write_config8(dev, PIRQD_ROUT, config-&gt;pirqd_routing); pci_write_config8(dev, PIRQE_ROUT, config-&gt;pirqe_routing); pci_write_config8(dev, PIRQF_ROUT, config-&gt;pirqf_routing); pci_write_config8(dev, PIRQG_ROUT, config-&gt;pirqg_routing); pci_write_config8(dev, PIRQH_ROUT, config-&gt;pirqh_routing);</code> </pre> <br>  Las constantes de direcci√≥n de registro se describen en el mismo archivo <a href="">pch.h</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQA_ROUT 0x60 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQB_ROUT 0x61 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQC_ROUT 0x62 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQD_ROUT 0x63 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQE_ROUT 0x68 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQF_ROUT 0x69 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQG_ROUT 0x6A #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQH_ROUT 0x6B</span></span></code> </pre> <br>  El mapeo PIRQy ‚Üí IRQz2 para este chipset se escribe en el dispositivo PCI LPC (direcci√≥n 00: 1f.0) en los registros PIRQy_ROUT.  Cabe se√±alar que a menudo no se permiten el uso de todas las 15 l√≠neas IRQz2 por PIC, sino solo una parte (por ejemplo, 3,4,5,6,7,9,10,11,12,14,15).  La descripci√≥n de estos registros debe contener informaci√≥n sobre qu√© IRQ est√°n disponibles para asignarles interrupciones de l√≠neas PIRQ.  Entonces, el mapeo propuesto por nosotros arriba solo es posible si la asignaci√≥n de PIRQ en la l√≠nea IRQ3, IRQ4, IRQ5, IRQ6, IRQ10, IRQ11, IRQ14, IRQ15 est√° disponible.  Pero si miramos cuidadosamente el comentario antes de la funci√≥n pch_pirq_init, veremos que es: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PIRQ[n]_ROUT[3:0] - PIRQ Routing Control * 0x00 - 0000 = Reserved * 0x01 - 0001 = Reserved * 0x02 - 0010 = Reserved * 0x03 - 0011 = IRQ3 * 0x04 - 0100 = IRQ4 * 0x05 - 0101 = IRQ5 * 0x06 - 0110 = IRQ6 * 0x07 - 0111 = IRQ7 * 0x08 - 1000 = Reserved * 0x09 - 1001 = IRQ9 * 0x0A - 1010 = IRQ10 * 0x0B - 1011 = IRQ11 * 0x0C - 1100 = IRQ12 * 0x0D - 1101 = Reserved * 0x0E - 1110 = IRQ14 * 0x0F - 1111 = IRQ15 * PIRQ[n]_ROUT[7] - PIRQ Routing Control * 0x80 - The PIRQ is not routed. */</span></span></code> </pre> <br><h4>  4) Complete los registros de l√≠nea de interrupci√≥n / pin de interrupci√≥n para cada funci√≥n PCI </h4><br>  En el espacio de configuraci√≥n de PCI (cada PCI tiene funciones de acuerdo con el est√°ndar) hay 2 registros de inter√©s para nosotros: <br><br><ul><li>  3Ch: L√≠nea de interrupci√≥n: aqu√≠ debe escribir el n√∫mero IRQz2 (un n√∫mero del 0 al 15), el n√∫mero de interrupci√≥n que la funci√≥n finalmente obtiene al usar el controlador PIC </li><li>  3Dh: Pin de interrupci√≥n: muestra qu√© l√≠nea INTx # (A / B / C / D) usa la funci√≥n </li></ul><br>  Comencemos con el √∫ltimo.  El registro de Pin de interrupci√≥n se completar√° autom√°ticamente en funci√≥n de la configuraci√≥n del conjunto de chips (registros DxxIP) realizada por nosotros en el p√°rrafo 1 y ser√° de solo lectura. <br><br>  Entonces, todo lo que queda es llenar el registro de la l√≠nea de interrupci√≥n con una interrupci√≥n IRQz2 para cada funci√≥n PCI. <br><br>  Conociendo el mapeo PIRQy ‚Üí IRQz2 (elemento 3b) y el mapeo INTx # ‚Üí PIRQy (elemento 2), puede completar f√°cilmente el registro de la l√≠nea de interrupci√≥n para cada funci√≥n, sabiendo qu√© interrupci√≥n INTx # utiliza (elemento 1). <br><br>  En coreboot, los registros de la l√≠nea de interrupci√≥n tambi√©n se rellenan en el <a href="">archivo src \ southbridge \ intel \ lynxpoint \ lpc.c</a> en la funci√≥n pch_pirq_init: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Eric Biederman once said we should let the OS do this. * I am not so sure anymore he was right. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (irq_dev = all_devices; irq_dev; irq_dev = irq_dev-&gt;next) { u8 int_pin=<span class="hljs-number"><span class="hljs-number">0</span></span>, int_line=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!irq_dev-&gt;enabled || irq_dev-&gt;path.type != DEVICE_PATH_PCI) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; int_pin = pci_read_config8(irq_dev, PCI_INTERRUPT_PIN); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (int_pin) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTA# */</span></span> int_line = config-&gt;pirqa_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTB# */</span></span> int_line = config-&gt;pirqb_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTC# */</span></span> int_line = config-&gt;pirqc_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTD# */</span></span> int_line = config-&gt;pirqd_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!int_line) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; pci_write_config8(irq_dev, PCI_INTERRUPT_LINE, int_line); }</code> </pre> <br>  Por alguna raz√≥n, este c√≥digo implica que la asignaci√≥n es en cualquier caso INTA # ‚Üí PIRQA, INTB # ‚Üí PIRQB, INTC # ‚Üí PIRQC, INTD # ‚Üí PIRQD.  Aunque en la pr√°ctica vimos que puede ser diferente (ver p√°rrafo 2). <br><br>  En general, "Eric Biederman dijo una vez", y lo copiamos en cualquier lugar: <br><br><pre> <code class="bash hljs">$ grep <span class="hljs-string"><span class="hljs-string">"Eric Biederman once said"</span></span> -r src/ src/southbridge/intel/fsp_bd82x6x/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801gx/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801ix/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/lynxpoint/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/sch/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this.</code> </pre> <br>  En general, coreboot realmente no se preocupa por el soporte de interrupci√≥n heredado.  Mucho de sorprenderse por este error no vale la pena.  Al cargar un sistema operativo moderno, esto no le molestar√°, pero si de repente necesita cargar Linux con las opciones "acpi = off nolapic", entonces esto es casi imposible. <br><br><h2>  Conclusi√≥n </h2><br>  En conclusi√≥n, repetiremos la informaci√≥n t√≠pica que debe configurarse en el conjunto de chips para enrutar las interrupciones PCI: <br><br><ol><li>  Indique qu√© l√≠nea INTx # extrae cada funci√≥n PCI </li><li>  Configure la asignaci√≥n INTx # ‚Üí PIRQy para cada dispositivo PCI </li><li>  Mapeo de relleno PIRQy ‚Üí IRQz1 (PIR ‚Üí APIC) y mapeo PIRQy ‚Üí IRQz2 (PIR ‚Üí PIC) </li><li>  Complete los registros de L√≠nea de interrupci√≥n / Pin de interrupci√≥n del espacio de configuraci√≥n PCI para cada funci√≥n PCI. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440304/">https://habr.com/ru/post/440304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440294/index.html">Enrutador MIDI en Raspberry Pi</a></li>
<li><a href="../440296/index.html">6 aplicaciones para el IoT industrial</a></li>
<li><a href="../440298/index.html">Aplicaci√≥n de San Valent√≠n en Libgdx</a></li>
<li><a href="../440300/index.html">10 comandos de consola para ayudar a debatir el c√≥digo JavaScript como un PRO</a></li>
<li><a href="../440302/index.html">CRM: costo de √©xito, costo de error, costo de propiedad</a></li>
<li><a href="../440306/index.html">Escalado de bases de datos en sistemas altamente cargados</a></li>
<li><a href="../440308/index.html">Divide y conquista, o escribe lentamente - lee r√°pidamente</a></li>
<li><a href="../440310/index.html">C√≥mo ense√±arle a una m√°quina a comprender facturas y extraer datos de ellas</a></li>
<li><a href="../440312/index.html">Hackquest 2018. Resultados y rese√±as. D√≠a 4-7</a></li>
<li><a href="../440314/index.html">Candidato de lanzamiento de JDK 12: Shenandoah, G1, JMH, Arm64. Los insectos en Swing contraatacan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>