<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧦 🚴🏿 💤 OpenSceneGraph: Penanganan Acara 🧗🏾 🎤 👨🏾‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Salah satu fitur dari bahasa C ++ yang sering dikritik adalah kurangnya mekanisme pemrosesan acara dalam standar. Sementara itu, mekanis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Penanganan Acara</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438218/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="gambar"><br><h1>  Pendahuluan </h1><br>  Salah satu fitur dari bahasa C ++ yang sering dikritik adalah kurangnya mekanisme pemrosesan acara dalam standar.  Sementara itu, mekanisme ini adalah salah satu cara utama interaksi beberapa komponen perangkat lunak dengan komponen perangkat lunak dan perangkat keras lainnya, dan diimplementasikan pada tingkat OS tertentu.  Secara alami, setiap platform memiliki nuansa sendiri dalam mengimplementasikan mekanisme yang dijelaskan. <br><br>  Sehubungan dengan semua hal di atas, ketika berkembang dalam C ++, ada kebutuhan untuk mengimplementasikan pemrosesan acara dengan satu atau lain cara, diselesaikan dengan menggunakan perpustakaan dan kerangka kerja pihak ketiga.  Kerangka kerja Qt yang terkenal menyediakan mekanisme untuk sinyal dan slot, yang memungkinkan mengatur interaksi kelas yang diwarisi dari QObject.  Implementasi acara juga hadir di perpustakaan boost.  Dan tentu saja, mesin OpenSceneGraph tidak dapat melakukan tanpa "sepeda" sendiri, aplikasi yang akan dibahas dalam artikel. <br><a name="habracut"></a><br>  OSG adalah perpustakaan grafik abstrak.  Di satu sisi, itu abstrak dari antarmuka prosedural OpenGL, menyediakan pengembang dengan seperangkat kelas yang merangkum seluruh mekanika OpneGL API.  Di sisi lain, itu juga abstrak dari antarmuka pengguna grafis tertentu, karena pendekatan pelaksanaannya berbeda untuk platform yang berbeda dan memiliki fitur bahkan dalam platform yang sama (MFC, Qt, .Net untuk Windows, misalnya). <br><br>  Terlepas dari platform, dari sudut pandang aplikasi, interaksi pengguna dengan antarmuka grafis bermuara pada generasi urutan peristiwa oleh elemen-elemennya, yang kemudian diproses di dalam aplikasi.  Sebagian besar kerangka kerja grafis menggunakan pendekatan ini, tetapi bahkan dalam platform yang sama mereka, sayangnya, tidak kompatibel satu sama lain. <br><br>  Untuk alasan ini, OSG menyediakan antarmuka dasarnya sendiri untuk menangani acara widget widget dan input pengguna berdasarkan kelas osgGA :: GUIEventHandler.  Handler ini dapat dilampirkan ke viewer dengan memanggil metode addEventHandler () dan dihapus dengan metode removeEventHandler ().  Tentu saja, kelas handler beton harus diwarisi dari kelas osgGA :: GUIEventHandler, dan metode handle () harus didefinisikan ulang di dalamnya.  Metode ini menerima dua argumen: osgGA :: GUIEventAdapter, yang berisi antrian acara dari GUI dan osg :: GUIActionAdepter, digunakan untuk umpan balik.  Khas dalam definisi adalah desain seperti itu <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdepter &amp;aa)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br>  Parameter osgGA :: GUIActionAdapter memungkinkan pengembang untuk meminta GUI untuk mengambil tindakan sebagai tanggapan terhadap acara tersebut.  Dalam kebanyakan kasus, penampil dipengaruhi melalui parameter ini, sebuah penunjuk yang dapat diperoleh dengan konversi penunjuk dinamis <br><br><pre> <code class="cpp hljs">osgViewer::Viewer* viewer = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgViewer::Viewer *&gt;(&amp;aa);</code> </pre><br><h1>  1. Penanganan acara keyboard dan mouse </h1><br>  Kelas osgGA :: GUIEventAdapter () mengelola semua jenis acara yang didukung oleh OSG, menyediakan data untuk mengatur dan mengambil parameternya.  Metode getEventType () mengembalikan acara GUI saat ini yang terkandung dalam antrian acara.  Setiap kali, mengganti metode handler () dari handler, saat memanggil metode ini, Anda harus menggunakan pengambil ini untuk menerima event dan menentukan jenisnya. <br><br>  Tabel berikut menjelaskan semua acara yang tersedia. <br><br><table><thead><tr><th>  Jenis acara </th><th>  Deskripsi </th><th>  Metode Pengambilan Data Kejadian </th></tr></thead><tbody><tr><td>  PUSH / RELEASE / DOUBLECLICK </td><td>  Klik / Lepaskan dan klik dua kali tombol mouse </td><td>  getX (), getY () - mendapatkan posisi kursor.  getButton () - kode pada tombol yang ditekan (LEFT_MOUSE_BUTTON, RIGHT_MOUSE_BUTTON, MIDDLE_MOUSE_BUTTON </td></tr><tr><td>  Scrol </td><td>  Bergulir roda mouse </td><td>  getScrollingMotion () - mengembalikan SCROOL_UP, SCROLL_DOWN, SCROLL_LEFT, SCROLL_RIGHT </td></tr><tr><td>  DRAG </td><td>  Seret mouse </td><td>  getX (), getY () - posisi kursor;  getButtonMask () - nilai yang mirip dengan getButton () </td></tr><tr><td>  PINDAHKAN </td><td>  Gerakan mouse </td><td>  getX (), getY () - posisi kursor </td></tr><tr><td>  KEYDOWN / KEYUP </td><td>  Menekan / melepaskan tombol pada keyboard </td><td>  getKey () - kode ASCII dari tombol yang ditekan atau nilai enumerator Key_Symbol (misalnya, KEY_BackSpace) </td></tr><tr><td>  BINGKAI </td><td>  Acara dihasilkan saat merender bingkai </td><td>  tidak ada input </td></tr><tr><td>  PENGGUNA </td><td>  Acara Buatan Pengguna </td><td>  getUserDataPointer () - mengembalikan pointer ke buffer data pengguna (buffer dikontrol oleh smart pointer) </td></tr></tbody></table><br>  Ada juga metode getModKeyMask () untuk mengambil informasi tentang kunci pengubah yang ditekan (mengembalikan nilai dari bentuk MODKEY_CTRL, MODKEY_SHIFT, MODKEY_ALT, dan sebagainya), memungkinkan Anda untuk memproses kombinasi tombol yang menggunakan pengubah <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ea.getModKeyMask() == osgGA::GUIEventAdapter::MODKEY_CTRL) { <span class="hljs-comment"><span class="hljs-comment">//    Ctrl }</span></span></code> </pre><br>  Ingatlah bahwa metode penyetel seperti setX (), setY (), setEventType (), dll.  tidak digunakan dalam handler handle ().  Mereka dipanggil oleh sistem windowing grafis tingkat rendah OSG untuk mengantri acara. <br><br><h1>  2. Kami mengontrol cessna dari keyboard </h1><br>  Kita sudah tahu bagaimana mengubah objek adegan melalui kelas osg :: MatrixTransform.  Kami memeriksa berbagai jenis animasi menggunakan kelas osg :: AnimationPath dan osg :: Animation.  Tetapi untuk interaktivitas suatu aplikasi (misalnya, sebuah game), animasi dan transformasi jelas tidak cukup.  Langkah selanjutnya adalah mengontrol posisi objek di atas panggung dari perangkat input pengguna.  Mari kita coba kencangkan manajemen ke cessna kita tercinta. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh keyboard</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgGA/GUIEventHandler&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class ModelController : public osgGA::GUIEventHandler { public: ModelController( osg::MatrixTransform *node ) : _model(node) {} virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: osg::ref_ptr&lt;osg::MatrixTransform&gt; _model; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ bool ModelController::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { (void) aa; if (!_model.valid()) return false; osg::Matrix matrix = _model-&gt;getMatrix(); switch (ea.getEventType()) { case osgGA::GUIEventAdapter::KEYDOWN: switch (ea.getKey()) { case 'a': case 'A': matrix *= osg::Matrix::rotate(-0.1, osg::Z_AXIS); break; case 'd': case 'D': matrix *= osg::Matrix::rotate( 0.1, osg::Z_AXIS); break; case 'w': case 'W': matrix *= osg::Matrix::rotate(-0.1, osg::X_AXIS); break; case 's': case 'S': matrix *= osg::Matrix::rotate( 0.1, osg::X_AXIS); break; default: break; } _model-&gt;setMatrix(matrix); break; default: break; } return true; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = new osg::MatrixTransform; mt-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(mt.get()); osg::ref_ptr&lt;ModelController&gt; mcontrol = new ModelController(mt.get()); osgViewer::Viewer viewer; viewer.addEventHandler(mcontrol.get()); viewer.getCamera()-&gt;setViewMatrixAsLookAt( osg::Vec3(0.0f, -100.0f, 0.0f), osg::Vec3(), osg::Z_AXIS ); viewer.getCamera()-&gt;setAllowEventFocus(false); viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Untuk mengatasi masalah ini, kami menulis kelas event handler input <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelController</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgGA::GUIEventHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ModelController( osg::MatrixTransform *node ) : _model(node) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: osg::ref_ptr&lt;osg::MatrixTransform&gt; _model; };</code> </pre><br>  Ketika membangun kelas ini, sebagai parameter, ia meneruskan sebuah pointer ke node transformasi, yang akan kita tindak lanjuti di handler.  Metode handler () menangani sendiri didefinisikan ulang sebagai berikut <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ModelController::handle(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) aa; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_model.valid()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; osg::Matrix matrix = _model-&gt;getMatrix(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ea.getEventType()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::KEYDOWN: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ea.getKey()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span>: matrix *= osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">-0.1</span></span>, osg::Z_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'D'</span></span>: matrix *= osg::Matrix::rotate( <span class="hljs-number"><span class="hljs-number">0.1</span></span>, osg::Z_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'w'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'W'</span></span>: matrix *= osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">-0.1</span></span>, osg::X_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'s'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'S'</span></span>: matrix *= osg::Matrix::rotate( <span class="hljs-number"><span class="hljs-number">0.1</span></span>, osg::X_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } _model-&gt;setMatrix(matrix); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Di antara rincian penting dari implementasinya, harus dicatat bahwa kita harus terlebih dahulu mendapatkan matriks transformasi dari simpul yang kita kontrol <br><br><pre> <code class="cpp hljs">osg::Matrix matrix = _model-&gt;getMatrix();</code> </pre><br>  Selanjutnya, dua pernyataan switch bersarang () menganalisis jenis peristiwa (keystroke) dan kode tombol yang ditekan.  Bergantung pada kode tombol yang ditekan, matriks transformasi saat ini dikalikan dengan matriks rotasi tambahan di sekitar sumbu yang sesuai <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span>: matrix *= osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">-0.1</span></span>, osg::Z_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  - Putar pesawat pada sudut yaw -0.1 radian saat Anda menekan tombol "A". <br><br>  Setelah memproses penekanan tombol, jangan lupa untuk menerapkan matriks transformasi baru ke node transformasi <br><br><pre> <code class="cpp hljs">_model-&gt;setMatrix(matrix);</code> </pre><br>  Dalam fungsi utama (), muat model pesawat dan buat simpul transformasi induk untuknya, tambahkan subgraf yang dihasilkan ke simpul akar adegan <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; mt-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(mt.get());</code> </pre><br>  Membuat dan menginisialisasi penangan input pengguna <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;ModelController&gt; mcontrol = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModelController(mt.get());</code> </pre><br>  Buat pengunjung dengan menambahkan penangan kami ke sana <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.addEventHandler(mcontrol.get());</code> </pre><br>  Atur matriks tampilan kamera <br><br><pre> <code class="cpp hljs">viewer.getCamera()-&gt;setViewMatrixAsLookAt( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-100.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec3(), osg::Z_AXIS );</code> </pre><br>  Larang kamera untuk menerima acara dari perangkat input <br><br><pre> <code class="cpp hljs">viewer.getCamera()-&gt;setAllowEventFocus(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br>  Jika ini tidak dilakukan, maka pawang yang tergantung pada kamera akan secara default mencegat semua input pengguna dan mengganggu pawang kita.  Kami mengatur data adegan ke penampil dan menjalankannya <br><br><pre> <code class="cpp hljs">viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Sekarang, setelah meluncurkan program, kita akan dapat mengontrol orientasi pesawat di ruang angkasa dengan menekan tombol A, D, W dan S. <br><br><img src="https://habrastorage.org/webt/a0/gu/od/a0guoddsokpfkthvefo07tfn1h4.gif"><br><br>  Pertanyaan yang menarik adalah apa yang harus dikembalikan oleh metode handle () saat keluar.  Jika benar dikembalikan, maka kami menunjukkan OSG, maka kami telah memproses input peristiwa dan pemrosesan lebih lanjut tidak diperlukan.  Paling sering, perilaku ini tidak sesuai dengan kita, jadi adalah praktik yang baik untuk mengembalikan false dari handler agar tidak mengganggu pemrosesan acara oleh penangan lain jika mereka melekat pada node lain di tempat kejadian. <br><br><h1>  3. Penggunaan pengunjung dalam pemrosesan acara </h1><br>  Mirip dengan bagaimana itu diterapkan ketika melintasi grafik adegan ketika memperbaruinya, OSG mendukung panggilan balik untuk menangani peristiwa yang dapat dikaitkan dengan node dan objek geometris.  Untuk ini, panggilan ke setEventCallback () dan addEventCallback () digunakan, yang mengambil sebagai parameter penunjuk ke child osg :: NodeCallback.  Untuk menerima peristiwa di operator operator (), kami dapat mengonversi pointer yang diteruskan ke pengunjung situs menjadi pointer ke osgGA :: EventVisitor, misalnya seperti ini <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/EventVisitor&gt; ... void operator()( osg::Node *node, osg::NodeVisitor *nv ) { std::list&lt;osg::ref_ptr&lt;osgGA::GUIEventAdapter&gt;&gt; events; osgGA::EventVisitor *ev = dynamic_cast&lt;osgGA::EventVisitor *&gt;(nv); if (ev) { events = ev-&gt;getEvents(); //       } }</span></span></span></span></code> </pre><br><h1>  4. Pembuatan dan pemrosesan acara khusus </h1><br>  OSG menggunakan antrian acara internal (FIFO).  Acara di awal antrian diproses dan dihapus darinya.  Acara yang baru dibuat ditempatkan di akhir antrian.  Metode handle () dari masing-masing event handler akan dieksekusi sebanyak yang ada dalam antrian.  Antrian acara dijelaskan oleh kelas osgGA :: EventQueue, yang, di antara hal-hal lainnya, memungkinkan Anda untuk menempatkan suatu peristiwa dalam antrian kapan saja dengan memanggil metode addEvent ().  Argumen untuk metode ini adalah pointer ke osgGA :: GUIEventAdapter, yang dapat diatur ke perilaku tertentu menggunakan metode setEventType () dan seterusnya. <br><br>  Salah satu metode dari kelas osgGA :: EventQueue adalah userEvent (), yang menetapkan acara pengguna dengan mengaitkannya dengan data pengguna, sebuah penunjuk yang diteruskan ke parameter tersebut sebagai parameter.  Data ini dapat digunakan untuk mewakili setiap acara khusus. <br><br>  Tidak dapat membuat turunan kejadian sendiri.  Instance ini telah dibuat dan dilampirkan pada instance viewer, jadi Anda hanya bisa mendapatkan pointer ke singleton ini <br><br><pre> <code class="cpp hljs">viewer.getEventQueue()-&gt;userEvent(data);</code> </pre><br>  Data pengguna adalah objek pewaris osg :: Dirujuk, yaitu, Anda dapat membuat penunjuk pintar untuk itu. <br><br>  Ketika acara khusus diterima, pengembang dapat mengekstrak data darinya dengan memanggil metode getUserData () dan memprosesnya sesuai keinginan. <br><br><h1>  5. Implementasi pengatur waktu pengguna </h1><br>  Banyak perpustakaan dan kerangka kerja yang menerapkan GUI menyediakan pengembang kelas untuk menerapkan timer yang menghasilkan suatu peristiwa setelah interval waktu tertentu.  OSG tidak mengandung sarana reguler untuk menerapkan timer, jadi mari kita coba menerapkan semacam timer sendiri, menggunakan antarmuka untuk membuat acara khusus. <br><br>  Apa yang bisa kita andalkan saat menyelesaikan masalah ini?  Untuk acara periodik tertentu yang terus-menerus dihasilkan oleh render, misalnya, pada FRAME, acara menggambar bingkai berikutnya.  Untuk ini kami menggunakan contoh yang sama dengan mengganti model cessna dari normal ke pembakaran. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh pengatur waktu</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgGA/GUIEventHandler&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct TimerInfo : public osg::Referenced { TimerInfo(unsigned int c) : _count(c) {} unsigned int _count; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class TimerHandler : public osgGA::GUIEventHandler { public: TimerHandler(osg::Switch *sw, unsigned int interval = 1000) : _switch(sw) , _count(0) , _startTime(0.0) , _interval(interval) , _time(0) { } virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: osg::ref_ptr&lt;osg::Switch&gt; _switch; unsigned int _count; double _startTime; unsigned int _interval; unsigned int _time; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ bool TimerHandler::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { switch (ea.getEventType()) { case osgGA::GUIEventAdapter::FRAME: { osgViewer::Viewer *viewer = dynamic_cast&lt;osgViewer::Viewer *&gt;(&amp;aa); if (!viewer) break; double time = viewer-&gt;getFrameStamp()-&gt;getReferenceTime(); unsigned int delta = static_cast&lt;unsigned int&gt;( (time - _startTime) * 1000.0); _startTime = time; if ( (_count &gt;= _interval) || (_time == 0) ) { viewer-&gt;getEventQueue()-&gt;userEvent(new TimerInfo(_time)); _count = 0; } _count += delta; _time += delta; break; } case osgGA::GUIEventAdapter::USER: if (_switch.valid()) { const TimerInfo *ti = dynamic_cast&lt;const TimerInfo *&gt;(ea.getUserData()); std::cout &lt;&lt; "Timer event at: " &lt;&lt; ti-&gt;_count &lt;&lt; std::endl; _switch-&gt;setValue(0, !_switch-&gt;getValue(0)); _switch-&gt;setValue(1, !_switch-&gt;getValue(1)); } break; default: break; } return false; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1.get(), true); root-&gt;addChild(model2.get(), false); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); viewer.addEventHandler(new TimerHandler(root.get(), 1000)); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Pertama, mari kita tentukan format data yang dikirim dalam pesan pengguna, mendefinisikannya sebagai struktur <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimerInfo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::Referenced { TimerInfo(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c) : _count(c) {} <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; };</code> </pre><br>  Parameter _count akan berisi jumlah bilangan bulat milidetik yang berlalu sejak saat program diluncurkan hingga acara penghitung waktu berikutnya diterima.  Struktur ini diturunkan dari kelas osg :: Referenced sehingga dapat dikontrol melalui OSG smart pointer.  Sekarang buat pengendali acara <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimerHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgGA::GUIEventHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TimerHandler(osg::Switch *sw, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interval = <span class="hljs-number"><span class="hljs-number">1000</span></span>) : _switch(sw) , _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) , _startTime(<span class="hljs-number"><span class="hljs-number">0.0</span></span>) , _interval(interval) , _time(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: osg::ref_ptr&lt;osg::Switch&gt; _switch; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> _startTime; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _interval; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _time; };</code> </pre><br>  Pawang ini memiliki beberapa anggota tertentu yang dilindungi.  Variabel _switch menunjukkan node yang beralih model pesawat terbang;  _count - hitungan mundur relatif dari waktu yang berlalu sejak generasi terakhir dari peristiwa pengatur waktu, berfungsi untuk menghitung interval waktu;  _startTime - variabel sementara untuk menyimpan hitung mundur sebelumnya, yang dilakukan oleh pemirsa;  _time - total waktu program dalam milidetik.  Konstruktor kelas menerima switch node sebagai parameter dan, secara opsional, interval waktu yang diperlukan untuk pengatur waktu switching untuk beroperasi. <br><br>  Di kelas ini, kami menimpa metode handle () <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> TimerHandler::handle(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ea.getEventType()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::FRAME: { osgViewer::Viewer *viewer = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgViewer::Viewer *&gt;(&amp;aa); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!viewer) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> time = viewer-&gt;getFrameStamp()-&gt;getReferenceTime(); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( (time - _startTime) * <span class="hljs-number"><span class="hljs-number">1000.0</span></span>); _startTime = time; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (_count &gt;= _interval) || (_time == <span class="hljs-number"><span class="hljs-number">0</span></span>) ) { viewer-&gt;getEventQueue()-&gt;userEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerInfo(_time)); _count = <span class="hljs-number"><span class="hljs-number">0</span></span>; } _count += delta; _time += delta; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::USER: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_switch.valid()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *ti = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *&gt;(ea.getUserData()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Timer event at: "</span></span> &lt;&lt; ti-&gt;_count &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Di sini kami menganalisis jenis pesan yang diterima.  Jika FRAME, maka tindakan berikut dilakukan: <br><ol><li>  Dapatkan pointer ke penampil <br></li></ol><br><pre> <code class="cpp hljs">osgViewer::Viewer *viewer = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgViewer::Viewer *&gt;(&amp;aa);</code> </pre><br><ol><li>  Setelah menerima pointer yang benar, baca waktu yang berlalu sejak program dimulai <br></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> time = viewer-&gt;getFrameStamp()-&gt;getReferenceTime();</code> </pre><br>  menghitung jumlah waktu yang dihabiskan untuk membuat bingkai dalam milidetik <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( (time - _startTime) * <span class="hljs-number"><span class="hljs-number">1000.0</span></span>);</code> </pre><br>  dan ingat hitungan waktu saat ini <br><br><pre> <code class="cpp hljs">_startTime = time;</code> </pre><br>  Jika nilai penghitung _count melebihi interval waktu yang diperlukan (atau ini adalah panggilan pertama ketika _time masih nol), kami menempatkan pesan pengguna dalam antrian, melewati struktur di atas waktu program dalam milidetik.  Penghitung _ jumlah diset ulang ke nol <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (_count &gt;= _interval) || (_time == <span class="hljs-number"><span class="hljs-number">0</span></span>) ) { viewer-&gt;getEventQueue()-&gt;userEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerInfo(_time)); _count = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Terlepas dari nilai _count, kita harus meningkatkannya dan _time dengan jumlah penundaan yang diperlukan untuk menggambar bingkai <br><br><pre> <code class="cpp hljs">_count += delta; _time += delta;</code> </pre><br>  Ini adalah bagaimana acara pengatur waktu akan dihasilkan.  Penanganan acara dilaksanakan sebagai berikut <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::USER: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_switch.valid()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *ti = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *&gt;(ea.getUserData()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Timer event at: "</span></span> &lt;&lt; ti-&gt;_count &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  Di sini kita memeriksa validitas pointer ke switching node, kurangi data dari event, memimpin dari struktur TimerInfo, menampilkan konten struktur pada layar dan mengganti status node. <br><br>  Kode dalam fungsi main () mirip dengan kode pada dua contoh switching sebelumnya, dengan perbedaan bahwa dalam hal ini kita menggantung event handler pada viewer. <br><br><pre> <code class="cpp hljs">viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerHandler(root.get(), <span class="hljs-number"><span class="hljs-number">1000</span></span>));</code> </pre><br>  meneruskan pointer ke simpul akar dan interval switching yang diperlukan dalam milidetik ke konstruktor handler.  Menjalankan contoh, kita akan melihat bahwa model beralih pada interval satu detik, dan di konsol kita menemukan output dari waktu di mana switching terjadi <br><br><pre> <code class="plaintext hljs">Timer event at: 0 Timer event at: 1000 Timer event at: 2009 Timer event at: 3017 Timer event at: 4025 Timer event at: 5033</code> </pre><br>  Acara khusus dapat dibuat kapan saja selama pelaksanaan program, dan tidak hanya ketika acara FRAME diterima, dan ini memberikan mekanisme yang sangat fleksibel untuk bertukar data antara bagian-bagian dari program, memungkinkan untuk memproses sinyal dari perangkat input non-standar, seperti joystick atau sarung tangan VR, misalnya. <br><br>  <i>Dilanjutkan ...</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438218/">https://habr.com/ru/post/id438218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438204/index.html">Perangkat kompiler Swift. Bagian 1</a></li>
<li><a href="../id438206/index.html">26 rekomendasi untuk menggunakan tipe var di Jawa</a></li>
<li><a href="../id438210/index.html">Peradaban Mata Air, 2/5</a></li>
<li><a href="../id438212/index.html">Bukti Konsep: Cara Memverifikasi Implementasi ML adalah Worth the Candle</a></li>
<li><a href="../id438214/index.html">Startup teknologi AS akan menghadapi kontrol pemerintah baru pada 2019</a></li>
<li><a href="../id438224/index.html">Kuartal pemerintah. Pilot</a></li>
<li><a href="../id438226/index.html">Memecahkan masalah menginstal .NET Framework 3.5 pada Windows 8 pada jaringan dengan WSUS</a></li>
<li><a href="../id438228/index.html">Apakah Anda memesan kacamata video transparan dengan HDMI dan USB-C? Bertemu: Epson Moverio BT-35E</a></li>
<li><a href="../id438230/index.html">Penerjemahan “Siapkan aplikasi Anda untuk persyaratan 64-bit”</a></li>
<li><a href="../id438234/index.html">Februari Acara TI Digest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>