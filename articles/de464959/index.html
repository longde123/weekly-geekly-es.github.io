<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🎤 👨‍👩‍👦 🉐 Analyse des Satzes der russischen Sprache 💶 👟 🧗🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel beschreibt den Prozess des Parsens des Satzes der russischen Sprache unter Verwendung der kontextfreien Grammatik und des LR-Analysealg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse des Satzes der russischen Sprache</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464959/">  Dieser Artikel beschreibt den Prozess des Parsens des Satzes der russischen Sprache unter Verwendung der kontextfreien Grammatik und des LR-Analysealgorithmus. <br><br>  <b>Die Verarbeitung natürlicher Sprache</b> ist die allgemeine Richtung der künstlichen Intelligenz und der mathematischen Linguistik.  Es untersucht die Probleme der Computeranalyse und Synthese natürlicher Sprachen. <br><br>  Im Allgemeinen ist der Prozess der Analyse von Sätzen in natürlicher Sprache wie folgt: (1) Aufteilen von Sätzen in syntaktische Einheiten - Wörter und Phrasen;  (2) Bestimmung der grammatikalischen Parameter jeder Einheit;  (3) die Definition der syntaktischen Beziehung zwischen Einheiten.  Die Ausgabe ist ein abstrakter Analysebaum. <br><a name="habracut"></a><br><h3>  1. Aufteilen von Sätzen in syntaktische Einheiten </h3><br>  Ein Satz in natürlicher Sprache besteht aus Wortformen und starken Phrasen.  Eine Anzahl von Wortformen eines bestimmten Wortes wird als Paradigma bezeichnet. <br><br>  Zum Beispiel <br><br><pre><code class="plaintext hljs">  "": [, , , , ,  ]</code> </pre> <br>  Phrasen - zusammengesetzte Konjunktionen, Prädikate oder stabile Ausdrücke - ändern sich nicht und können nicht ohne Bedeutungsverlust in kleinere Einheiten zerlegt werden.  Mit einem Wort meinen wir außerdem jede syntaktische Einheit - eine Wortform oder eine Phrase. <br><br>  Jedes Wort in einem Satz wird durch ein Tripel bestimmt: <br><br><ol><li>  Wortform / Wortfolge ("geschrieben") </li><li>  normale Form des Wortes ("schreiben") </li><li>  eine Reihe von grammatikalischen Parametern (['VERB', 'sing', 'musc', 'tran', 'past']) </li></ol><br>  Daher hat die Aufschlüsselung des Satzes " <i>Er wird eindeutig nicht zur Sitzung kommen</i> " die folgende Form: <br><br><pre> <code class="plaintext hljs">[' ', '', '', '', '', '']  ' ' -  , </code> </pre> <br><h3>  2. Definition von grammatikalischen Parametern (Grammatiken) </h3><br>  <b>Ein Gramm</b> ist ein Element einer grammatikalischen Kategorie;  Verschiedene Grammatiken derselben Kategorie schließen sich gegenseitig aus und können nicht zusammen ausgedrückt werden.  Für jede Wortform definieren wir einen Satz von sieben Grammatiken: <br><br><pre> <code class="plaintext hljs">[  , , , , , ,  ]</code> </pre> <br>  Als Quelle verwenden wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenCorpora-</a> Wörterbuch und seine Schnittstelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pymorphy2</a> .  Um nach einer Regel in der Grammatik für einen bestimmten Satz von Gramm zu suchen, werden wir sie in allgemeiner Form präsentieren: <br><br><pre> <code class="plaintext hljs"> '' [NOUN,plur,neut,accs] -&gt; [NOUN,?numb,?per,?gend,accs,None,None]  '?' ,      </code> </pre> <br><h3>  3. Definition der syntaktischen Beziehung zwischen Wörtern </h3><br>  Um die syntaktische Beziehung zwischen Wörtern zu bestimmen, verwenden wir kontextfreie Grammatik und LR-Analyse. <br><br><h4>  Grammatik- und LR-Analyse </h4><br>  <b>Die formale Grammatik</b> beschreibt eine Sprache in Form von sogenannten Produktionen.  Zum Beispiel: <br><br><pre> <code class="plaintext hljs">a -&gt; ab | ac</code> </pre> <br>  bedeutet die Regel 'a' spawnt 'ab' ODER 'ac'. <br><br>  <b>Nichtterminale</b> sind Objekte, die jede Essenz der Sprache bezeichnen (Satz, Formel usw.).  <b>Terminals</b> - Objekte, die direkt in der der Grammatik entsprechenden Sprache vorhanden sind und eine bestimmte, unveränderliche Bedeutung haben (Buchstaben, Wörter, Formeln usw.).  Kontextfreie Grammatiken sind Grammatiken, bei denen die linken Seiten aller Produkte einzelne Nicht-Terminals sind. <br><br>  Um die russische Sprache zu beschreiben, verwenden wir die Grammatiktheorie der Komponenten ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phrasenstrukturgrammatik</a> ), die besagt, dass jede komplexe grammatikalische Einheit aus zwei einfacheren und sich nicht überschneidenden Einheiten besteht, die als unmittelbare Komponenten bezeichnet werden.  Folgende Komponenten werden unterschieden: <br><br>  <b>(1) Nominalgruppe (NP)</b> <br><br><pre> <code class="plaintext hljs">NP[case='nomn'] -&gt; N[case='nomn'] | ADJ[case='nomn'] NP[case='nomn'] | …</code> </pre> <br>  Das heißt, eine Nominativ-Nominalphrase ist ein Substantiv im Nominativ oder ein Adjektiv im Nominativ + eine Nominativ-Nominalphrase ODER eine andere. <br><br>  <b>(2) Verbale Gruppe (VP)</b> <br><br><pre> <code class="plaintext hljs">VP[tran] -&gt; V[tran] NP[case='ablt'] | ADJ VP[tran] | …</code> </pre> <br>  Mit anderen Worten, eine transitive Verbgruppe ist ein transitives Verb + eine ablative Substantivgruppe ODER ein kurzes Adjektiv + eine transitive Verbgruppe ODER eine andere. <br><br>  <b>(3) Präpositionalgruppe (PP)</b> <br><br><pre> <code class="plaintext hljs"> PP -&gt; PREP NP[case='datv'] | ...</code> </pre> <br>  Eine Präposition ist eine Präposition + eine nominelle Dativgruppe ODER eine andere. <br><br>  <b>(4) Vollständiges Angebot (S)</b> <br><br><pre> <code class="plaintext hljs">S -&gt; NP[case='nomn'] VP[tran]</code> </pre><br>  Ein vollständiger Satz liegt genau dann vor, wenn die Substantiv- und Verbgruppen in Anzahl, Person und Geschlecht übereinstimmen. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">agreement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node_left, node_right)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numb1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> numb2): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numb1 != numb2): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (per1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> per2): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (per1 != per2): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gend1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> gend2): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gend1 != gend2): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>;</code> </pre><br>  Ein unvollständiger Satz ist ein Satz, bei dem der Nominalteil weggelassen wird.  In solchen Sätzen wird die Verbgruppe in der Regel durch ein unpersönliches Verb ausgedrückt.  Zum Beispiel " <i>Ich möchte laufen</i> ", "Es wird <i>hell</i> ."  Ein elliptischer Satz ist ein Satz, bei dem der Verbteil weggelassen und durch einen Bindestrich ersetzt wird.  Zum Beispiel: " <i>Hinter dem Rücken ist ein Wald. Rechts und links sind Sümpfe</i> ." <br><br>  Um festzustellen, ob dieser Satz zur Grammatiksprache gehört, verwenden wir den LR-Analysealgorithmus.  Bei diesem Algorithmus wird ein Analysebaum von unten nach oben (von den Blättern bis zur Wurzel) erstellt.  Das Schlüsselelement des Algorithmus ist die Methode der "Transfer-Faltung" (englische <i>Shift-Reduktion</i> ): <br><br>  (1) Wir lesen die Zeichen der Eingabezeile, bis eine Kette vorhanden ist, die mit der rechten Seite einiger Regeln übereinstimmt. Legen Sie die gefundene Kette in den Stapel (Übertragung). <br>  (2) Ersetzen Sie die durch die Regel gefundene Kette aus der Grammatik (Faltung). <br><br>  Wenn alle Zeichenfolgenketten umbrochen wurden, gehört dieser Satz zur Grammatiksprache, und es ist mindestens ein Analysebaum vorhanden. <br><br>  <b>Baum</b> <br><br>  Um die syntaktische Verbindung darzustellen, verwendet der Satz einen Binärbaum, wobei die Blätter Wörter (Terminals) mit einer Menge von Gramm sind und die Knoten Regeln (Preterminals) sind.  Die Wurzel ist der Satz (nicht terminal). <br><br>  Ein Baumknoten ist wie folgt definiert: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, word=None, tag=None, grammemes=None, leaf=False)</span></span></span><span class="hljs-function">:</span></span> self.word = word; <span class="hljs-comment"><span class="hljs-comment">#   self.tag = tag; #   - ,      self.grammemes = grammemes; #   self.leaf = leaf; self.l = None; self.r = None; self.p = None;</span></span></code> </pre><br>  Die Konstruktion eines Baumes beginnt mit Blättern, denen eine Reihe von Wörtern oder Phrasen sowie eine Reihe seiner Grammatiken zugewiesen sind. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, sent)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sent: new_node = Node(word[<span class="hljs-number"><span class="hljs-number">0</span></span>], word[<span class="hljs-number"><span class="hljs-number">1</span></span>], word[<span class="hljs-number"><span class="hljs-number">2</span></span>], leaf=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) self.nodes.append(new_node)</code> </pre> <br>  Als nächstes wird eine LR-Analyse durchgeführt.  Jede Faltung entspricht der Vereinigung zweier Knoten oder Blätter unter einem gemeinsamen Vorfahren.  Einem Vorfahrenknoten wird ein vorzeitiges Tag zugewiesen, das der Grammatikregel entspricht. Außerdem akzeptiert der Vorfahr Grammatiken des Hauptmitglieds der Gruppe, z. B. werden in der Verbgruppe V [tran] PRCL (z. B. <i>"möchte"</i> ) die Zeichen aus dem transitiven Verb V [tran] übernommen nicht von einem PRCL-Partikel;  und in der Substantivgruppe NP [case = 'nomn'] NP [case = 'gent'] (z. B. <i>"Vater von Kindern"</i> ) werden die Zeichen dem Substantiv im Nominativ entnommen. <br><br>  Es ist wichtig zu beachten, dass die Faltung in der festgelegten Reihenfolge erfolgt: <br><br><pre> <code class="plaintext hljs"> def reduce(self): self.reduce_ADJ() #  self.reduce_NP() #   self.reduce_PP() #  self.reduce_VP() #  self.reduce_S() #    </code> </pre><br>  Diese Reihenfolge ist wichtig, da sie die Möglichkeit ausschließt, einige Mitglieder des Vorschlags zu „verpassen“.  Zuerst werden Adjektive zusammen mit Modifikatoren (z. B. <i>wahnsinnig schön</i> ) gebildet, dann nominelle Gruppen, präpositionell und schließlich verbal.  Danach wird nach vollständigen / unvollständigen Sätzen gesucht. Wenn keine vorhanden sind, hat der Baum keine Wurzel und daher gehört der Satz nicht zur Grammatiksprache. <br><br>  Betrachten Sie ein bedingtes Beispiel für das Erstellen eines Baums: <br><br><pre> <code class="plaintext hljs">sent = "    " def build(self, sent): for word in sent: new_node = Node(word[0], word[1], word[2], leaf=True) self.nodes.append(new_node)</code> </pre><br><img src="https://habrastorage.org/webt/dv/os/q2/dvosq2enl-vsvwnoif2ikvwspqw.png"><br><br><pre> <code class="plaintext hljs">NP[case='nomn'] -&gt; NPRO[case='nomn'] NP[case='accs'] -&gt; N[case='accs'] NP[case='datv'] -&gt; ADJ[case='datv'] NP[case='datv']</code> </pre> <br><img src="https://habrastorage.org/webt/zo/dp/3i/zodp3iqmbp3-v7mheec_rd2d_gy.png"><br><br><pre> <code class="plaintext hljs">VP[tran] -&gt; V[tran] NP[case='accs']</code> </pre> <br><img src="https://habrastorage.org/webt/ez/9a/jk/ez9ajkpo58rfxtnsqt3o0ij2las.png"><br><br><pre> <code class="plaintext hljs">VP[tran] -&gt; VP[tran] NP[case='datv']</code> </pre> <br><img src="https://habrastorage.org/webt/w3/0y/m_/w30ym_ey2ehicxufasvky3vml4w.png"><br><br><pre> <code class="plaintext hljs">S -&gt; NP[case='nomn'] VP[tran]</code> </pre> <br><img src="https://habrastorage.org/webt/wg/f_/xw/wgf_xw3qoj9dhpk8nvhjztzhqlu.png"><br><br>  Ein spezielles Beispiel für das Parsen eines zweiteiligen Satzes: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> analyzer parser = analyzer.Parser() sent = <span class="hljs-string"><span class="hljs-string">"  ,     ."</span></span> t = parser.parse(sent) t[<span class="hljs-number"><span class="hljs-number">0</span></span>].display() S NP[case=<span class="hljs-string"><span class="hljs-string">'nomn'</span></span>]  [<span class="hljs-string"><span class="hljs-string">'NOUN'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'femn'</span></span>, <span class="hljs-string"><span class="hljs-string">'nomn'</span></span>] VP[tran] VP[tran]  [<span class="hljs-string"><span class="hljs-string">'VERB'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'3per'</span></span>, <span class="hljs-string"><span class="hljs-string">'tran'</span></span>, <span class="hljs-string"><span class="hljs-string">'pres'</span></span>] NP[case=<span class="hljs-string"><span class="hljs-string">'datv'</span></span>]  [<span class="hljs-string"><span class="hljs-string">'NOUN'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'datv'</span></span>] S NP[case=<span class="hljs-string"><span class="hljs-string">'nomn'</span></span>]  [<span class="hljs-string"><span class="hljs-string">'NOUN'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'femn'</span></span>, <span class="hljs-string"><span class="hljs-string">'nomn'</span></span>] VP[tran] PP PREP  [<span class="hljs-string"><span class="hljs-string">'PREP'</span></span>] NP[case=<span class="hljs-string"><span class="hljs-string">'ablt'</span></span>]  [<span class="hljs-string"><span class="hljs-string">'NOUN'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'femn'</span></span>, <span class="hljs-string"><span class="hljs-string">'ablt'</span></span>] VP[tran]  [<span class="hljs-string"><span class="hljs-string">'VERB'</span></span>, <span class="hljs-string"><span class="hljs-string">'sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'3per'</span></span>, <span class="hljs-string"><span class="hljs-string">'tran'</span></span>, <span class="hljs-string"><span class="hljs-string">'pres'</span></span>]</code> </pre> <br><h3>  Die Probleme </h3><br>  Die natürliche Sprache ist mehrdeutig, ihr Verständnis hängt von einer Reihe von Faktoren ab - von den Merkmalen der grammatikalischen Struktur der Sprache, von der nationalen Kultur, vom Sprecher usw.  Wir listen die Hauptprobleme der maschinellen Sprachverarbeitung auf. <br><br><ol><li>  Offenlegung von Anaphoren.  Eine lebende Person versteht Anaphoren basierend auf gesundem Menschenverstand und Kontext, aber für einen Computer ist dies offensichtlich nicht immer einfach. </li><li>  Homonymie ist ein Zufall im Klang und in der Schreibweise von Spracheinheiten, deren Bedeutung nicht miteinander in Beziehung steht.  Eine Lösung sind probabilistische Methoden.  Im Satz „ <i>Ich weiß das gut</i> “ ist die Wahrscheinlichkeit, dass „ <i>das</i> “ ein Pronomen und kein Teilchen ist, größer.  Solche Verfahren erfordern ein ausreichend großes Gehäuse. </li><li>  Die freie Reihenfolge der Wörter führt dazu, dass die Interpretation des Satzes mehrdeutig sein kann.  Zum Beispiel: „ <i>Sein bestimmt das Bewusstsein</i> “ - was bestimmt was?  Im Russischen wird die freie Wortreihenfolge durch entwickelte Morphologie, Servicewörter und Satzzeichen kompensiert, aber in den meisten Fällen stellt dies für den Computer ein zusätzliches Problem dar. </li><li>  Nicht alle Leute schreiben richtig.  Im Internet neigen Menschen dazu, Abkürzungen, Neologismen, Ellipsen und andere Dinge zu verwenden, die der literarischen Norm widersprechen können.  Aus diesem Grund ist die Verwendung kontextfreier Grammatiken und Wörterbücher nicht immer möglich. </li></ol><br><h4>  Fazit </h4><br>  Das Projekt kann verwendet und bearbeitet werden.  Es enthält den Analysator selbst, den Analysebaum sowie die russische Grammatik und Grammatik der russischen Sprache sowie ein kleines Wörterbuch mit zusammengesetzten Vereinigungen und Prädikaten, die nicht im OpenCorpora-Wörterbuch enthalten sind.  Im Moment kann der Parser für lange komplexe Sätze 3 oder mehr Bäume finden, um dieses Problem zu lösen. Es werden Änderungen an der Grammatik vorgenommen, und es ist auch geplant, probabilistische Methoden zu verwenden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464959/">https://habr.com/ru/post/de464959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464939/index.html">Testen von @ NonNull / @ Nullable-Annotationen</a></li>
<li><a href="../de464947/index.html">Digitale Veranstaltungen in Moskau vom 25. August bis 1. September</a></li>
<li><a href="../de464949/index.html">Noch einmal über GCD, den euklidischen Algorithmus und ein wenig über die Geschichte der Algorithmen im Allgemeinen. Natürlich mit Swift-Beispielen</a></li>
<li><a href="../de464951/index.html">Je einfacher die Aufgabe, desto öfter irre ich mich</a></li>
<li><a href="../de464955/index.html">Iron Mike Tyson und das Blockchain-Projekt Fight to Fame</a></li>
<li><a href="../de464961/index.html">Erstellen Sie visuelle Komponenten in der Unity-Benutzeroberfläche. Partikelsystem</a></li>
<li><a href="../de464963/index.html">Lokalisieren Sie schnell Microsoft SQL Server-Leistungsprobleme in Quest Foglight</a></li>
<li><a href="../de464965/index.html">Frontend Weekly Digest (19. - 25. August 2019)</a></li>
<li><a href="../de464967/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 377 (19. - 25. August 2019)</a></li>
<li><a href="../de464969/index.html">CRISPR bietet Ihnen die Möglichkeit, eine Person vor Schmerzen zu bewahren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>