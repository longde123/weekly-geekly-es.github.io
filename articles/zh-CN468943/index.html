<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏼 🏳️‍🌈 👼🏽 EcmaScript中的this和ScopeChain 🎡 👍 🤗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 

 在上一篇文章中，我们研究了应用于EcmaScript的OOP的一般理论，以及有关JS中的OOP与古典语言之间的差异的新手开发人员的普遍谬误。 

 今天，我们将讨论另外两个同样重要的EcmaScript概念，即，实体与执行上下文的关系（此连接）和实体与生成上下文的关系（ ScopeC...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EcmaScript中的this和ScopeChain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468943/">哈Ha！ <br><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章中，</a>我们研究了应用于EcmaScript的OOP的一般理论，以及有关JS中的OOP与古典语言之间的差异的新手开发人员的普遍谬误。 <br><br> 今天，我们将讨论另外两个同样重要的EcmaScript概念，即，实体与执行上下文的关系（此连接）和实体与生成上下文的关系（ <b>ScopeChain</b> ）。 <br><br> 因此，让我们开始吧！ <br><br><h3> 这个 </h3><br> 在采访中回答以下问题：“告诉我们更多有关<i>此问题</i> 。”。 通常，新手开发人员会给出非常模糊的答案：“ <i>这</i>是对象”，位于“用于调用方法的位置”之前，“这是调用函数的上下文”，等等。 <br><br> 实际上，这种概念（对于EcmaScript至关重要）的情况要复杂得多。 让我们按顺序弄清楚。 <br><br> 假设我们有一个JavaScript程序，该程序具有全局声明的变量； 全局功能； 局部函数（在其他函数内部声明），从函数返回的函数。 <br><a name="habracut"></a><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span>, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooBaz</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooBar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">40</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } } fooBar()();</code> </pre> <br> 将控制权转移到可执行代码时，将在执行上下文中创建一个条目。 可执行代码-这是我们在给定时间执行的任何代码，可以是全局代码或任何函数的代码。 <br><br>  <b>执行上下文</b>是代表和定界代码的抽象。 从这种抽象的角度来看，代码分为全局代码（任何连接的脚本，内联脚本）和函数代码（嵌套函数的代码不属于父函数的上下文）。 <br><br> 第三种类型-EvalCode。 在本文中，我们忽略了它。 <br><br> 从逻辑上讲，执行上下文集是一个按照后进先出（lifo）原理工作的<b>堆栈</b> 。 堆栈的底部始终是全局上下文，顶部是当前可执行文件。 每次调用函数时，都会在其上下文中创建一个条目。 函数完成后，其上下文结束。 用完的上下文按顺序和相反的顺序从堆栈中删除。 <br><br> 看一下上面的代码。 我们在全局代码中调用了<b>fooBar</b>函数。 在<b>fooBar</b>函数中<b>，</b>我们返回<b>一个</b>立即调用<b>的匿名函数</b> 。 堆栈发生以下变化： <b>全局上下文</b>进入该堆栈-调用<b>fooBar</b>时<b>，</b>其上下文进入堆栈<b>-fooBar</b>上下文结束，返回<b>一个匿名函数，</b>并从堆栈中删除-调用一个<b>匿名函数</b> ，其上下文进入堆栈- <b>匿名函数</b>实现，返回值并将其上下文从堆栈中删除-在脚本末尾，将从堆栈中删除<b>全局上下文</b> 。 <br><cut></cut><br> 执行上下文可以有条件地表示为对象。 该对象的属性之一将是词法环境（LO）。 <br><br>  <b>词汇环境</b>包含： <br><br><ul><li> 所有上下文变量声明 </li><li> 所有函数声明 </li><li> 函数的所有形式参数（如果我们正在谈论函数的上下文） </li></ul><br> 输入执行上下文时，解释器将扫描上下文。 所有变量声明和函数声明都将出现在上下文的开头。 创建的变量等于未定义的变量，并且函数完全可以使用。 <br><br>  <b>这</b>也是执行上下文的属性，而不是上下文本身，正如一些新手访调员回答的那样！  <b>这是</b>在进入上下文时定义的，并且在上下文生存期结束之前一直保持不变（直到从堆栈中删除上下文为止）。 <br><br> 在全局执行上下文中， <b>这</b>由<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">严格模式</a></b>决定：当严格模式关闭时，它包含一个全局对象（在浏览器中，它代理到窗口对象的顶层），其中“使用严格”的定义是不确定的。 <br><cut></cut><br> 在函数的上下文中-这个问题要有趣得多！ <br> 此函数的功能由调用者确定，并取决于调用的语法。 例如，据我们所知，有一些方法可以让您在调用（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">call</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">apply</a> ）时很难固定该方法，也有一些方法可以让您使用“已修复此问题”（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bind</a> ）创建包装器。 在这些情况下，我们明确声明了这一点，毫无疑问它的定义。 <br><br> 使用正常的函数调用，情况就复杂得多！ <br><br>  EcmaScript内置类型之一<b>ReferenceType</b>将帮助我们理解函数中如何附加此类型。 这是在实施级别可用的内部类型之一。 从逻辑上讲，它是一个具有两个<b>基本</b>属性的对象（对某个基本对象的引用，为其返回ReferenceType）， <b>propertyName</b> （该对象标识符的字符串表示形式，其返回了ReferenceType）。 <br><br> 对于所有变量声明，函数声明和属性引用， <b>都会</b>返回<b>ReferenceType</b> （从理解这一点的角度来看，这是我们感兴趣的情况）。 <br><br> 为以通常方式调用的函数定义<b>此</b>规则： <br>  <i>如果<b>ReferenceType</b>位于功能激活括号的左侧，则此<b>ReferenceType</b>的<b>底部</b>将放在<code>this</code>函数中。</i>  <i>如果方括号左侧是其他类型，则<code>this</code>可能是全局对象，也可能是<code>undefined</code>对象（实际上为<code>null</code> ，但是由于从ecmascript的角度来看null没有特定的值，因此将其强制转换为全局对象，对该对象的引用可能是等于<code>undefined</code>取决于严格模式）。</i> <br><br> 让我们看一个例子： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } obj.foo();<span class="hljs-comment"><span class="hljs-comment">//  10 ..    ReferenceType  base     obj const test = obj.foo;//       test();//  0 ..  test()   .test(),..  base    ,       0.</span></span></code> </pre><br> 我认为定义方法很清楚。 现在考虑一些不太明显的情况。 <br><br><h4> 功能表达 </h4><br> 让我们回到参考类型。 此类型具有内置的<b>GetValue</b>方法，该方法返回通过ReferenceType接收到的对象的真实类型。 在表达式区域中，GetValue始终会触发。 <br><br> 一个例子： <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;<span class="hljs-comment"><span class="hljs-comment">// this     undefined    strict mode })()</span></span></code> </pre><br> 这是因为GetValue始终在表达式区域中触发。  GetValue返回一个函数类型，并且在激活括号的左侧不是ReferenceType。 回想一下我们确定<b>该</b>规则的规则： <i>如果方括号的左边有任何其他类型，则将全局对象放入<code>this</code>对象或<code>undefined</code> （实际上为<code>null</code> ，但是由于从ecmascript的角度来看null没有特定值，因此它将转换为全局对象，取决于严格模式，该链接可以等于undefined）</i> 。 <br><br> 表达式区域是：赋值（=），运算符|| 或其他逻辑运算符，三元运算符，数组初始化程序，逗号分隔列表。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } obj.foo(); <span class="hljs-comment"><span class="hljs-comment">//        //  ? (obj.foo)(); // ,    , GetValue   // ? (obj.foo = obj.foo)(); //        GetValue,     Fuction,   ReferenceType,   0   (   this) //  ||    ,    ..? (obj.foo || obj.foo)();// 0    ,     //  [obj.foo][0]();// 0    ,     // ..</span></span></code> </pre><br> 命名函数表达式中的相同情况。 即使递归调用此全局对象或<code>undefined</code> <br><br><h4> 此嵌套函数在父级中调用 </h4><br> 也是重要的情况！ <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {<span class="hljs-attr"><span class="hljs-attr">x</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}; obj.test = foo; obj.test();<span class="hljs-comment"><span class="hljs-comment">// undefined</span></span></code> </pre><br> 这是因为对<code>bar()</code>的调用等效于对<code>LE_foo.bar</code>的调用，并且词法环境的对象为此未定义。 <br><br><h4> 构造函数 </h4><br> 正如我上面所写： <blockquote> 此函数的功能由调用者确定，并取决于调用的语法。 </blockquote><br> 我们使用new关键字调用构造函数。 此函数激活方法的特殊之处在于，将调用内部函数方法<i><b>[[construct]]</b></i> ，该方法执行某些操作（有关设计人员创建实体的机制，将在OOP的第二篇或第三篇文章中进行讨论！）并调用内部<i><b>[[call]]</b></i>方法，该方法放下在<b>此</b>创建的构造函数实例中。 <br><br><h3> 范围链 </h3><br> 范围链也是这样的执行上下文的属性。 它是当前上下文和所有生成上下文的词法环境的对象列表。 在此链中，解析标识符名称时将进行变量搜索。 <br><br> 注意：这将函数与执行上下文关联，并将ScopeChain与子上下文关联。 <br><br> 规范指出ScopeChain是一个数组： <br><br><pre> <code class="javascript hljs"> SC = [LO, LO1, LO2,..., LOglobal];</code> </pre><br> 但是，在某些实现中，例如JS，范围链是通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接列表</a>实现的。 <br><br> 为了更好地理解ScopeChain，我们将讨论功能的生命周期。 它分为创建阶段和执行阶段。 <br><br> 创建函数时，将为其分配内部<i><b>[[SCOPE]]</b></i>属性。 <br> 在<i><b>[[SCOPE]]中</b></i> ，记录了较高（生成）上下文的词汇环境的对象的层次链。 该属性将保持不变，直到该函数被垃圾收集器销毁为止。 <br><br> 注意！  <i><b>[[SCOPE]]</b></i>与ScopeChain不同，它是函数本身的属性，而不是其上下文。 <br><br> 调用函数时，将初始化并填充其执行上下文。 上下文附加有ScopeChain = LO（函数本身）+ [[SCOPE]]（影响上下文的LO层次链）。 <br><br>  <b>标识符名称</b>的<b>解析-ScopeChain</b>链<b>中</b>从左到右顺序轮询<b>LO</b>对象。 输出是ReferenceType，其基本属性指向在其中找到标识符的LO对象，PropertyName将是标识符名称的字符串表示形式。 <br><br> 这就是盖子在引擎盖下的排列方式！ 闭包本质上是在ScopeChain中搜索其标识符在函数中存在的所有变量的结果。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>; foo();<span class="hljs-comment"><span class="hljs-comment">// 10 ..     &lt;b&gt;&lt;i&gt;[[SCOPE]]&lt;/i&gt;&lt;/b&gt; foo          })()</span></span></code> </pre><br> 以下示例说明了生命周期<b><i>[[SCOPE]]</i></b> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> y = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x,y]; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = foo();<span class="hljs-comment"><span class="hljs-comment">//   ,   foo    bar();// [10,20] .. [[SCOPE]]    foo         </span></span></code> </pre><br> 一个重要的例外是<b>构造函数</b> 。 对于此类功能，[[SCOPE]]始终指向全局对象。 <br><br> 另外，不要忘记，如果ScopeChain链中的链接之一具有原型，那么搜索也将在原型中进行。 <br><br><h3> 结论 </h3><br> 我们将通过论文提出关键思想： <br><br><ul><li> 这是实体与执行上下文的关系 </li><li>  ScopeChain是实体与所有生成上下文的关系 </li><li>  this和ScopeChain是执行上下文属性 </li><li> 此功能由调用方确定，并取决于调用的语法 </li><li>  ScopeChain是当前上下文的词法环境+ [[Scope]] </li><li>  [[Scope]]-这是函数本身的属性，包含生成上下文的词汇环境的层次链 </li></ul><br> 希望本文对您有所帮助。 直到以后的文章，朋友们！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN468943/">https://habr.com/ru/post/zh-CN468943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN468929/index.html">迷你手册如何设置hackintosh尽可能简单，轻松</a></li>
<li><a href="../zh-CN468931/index.html">在容器中运行systemd</a></li>
<li><a href="../zh-CN468933/index.html">无论身在何处，都尖锐而尖锐：海胆牙齿自动锐化的机制</a></li>
<li><a href="../zh-CN468935/index.html">2019年10月IT领域人力资源专业人员的事件摘要</a></li>
<li><a href="../zh-CN468937/index.html">非接触式银行卡攻击</a></li>
<li><a href="../zh-CN468945/index.html">ITIL和ITSM是一个极具欺骗性的故事。 有什么好处吗？ 它要花多少钱？到底谁不“实施ITIL”？</a></li>
<li><a href="../zh-CN468951/index.html">小型设备的大配置问题</a></li>
<li><a href="../zh-CN468953/index.html">代码风格作为开发标准</a></li>
<li><a href="../zh-CN468955/index.html">通信是另一个可配置的远程选项</a></li>
<li><a href="../zh-CN468957/index.html">以Unexplored为例的循环地下城生成</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>