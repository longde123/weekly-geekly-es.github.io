<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÜ ‚≠ïÔ∏è üñ•Ô∏è Impl√©mentation de la minimisation des fonctions logiques par la m√©thode Quine \ McCluskey avec un jeu d'entr√©es incomplet üéè üí≥ ‚òùüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article est, dans une certaine mesure, une continuation de mon article sur la minimisation des fonctions logiques par la m√©thode Quine-Mac'Klaski ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Impl√©mentation de la minimisation des fonctions logiques par la m√©thode Quine \ McCluskey avec un jeu d'entr√©es incomplet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424517/">  Cet article est, dans une certaine mesure, une continuation de mon article sur la minimisation des fonctions logiques par la m√©thode Quine-Mac'Klaski ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://habr.com/post/328506</a> ).  Il a consid√©r√© un cas avec des fonctions logiques compl√®tement d√©finies (bien que cela n'y soit pas directement mentionn√©, mais seulement implicite).  En r√©alit√©, un tel cas est assez rare lorsque le nombre de variables d'entr√©e est petit.  Les fonctions logiques dont la d√©finition est partielle ou incompl√®te ne sont donn√©es que pour la partie Q de l'ensemble complet P = <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mi>N</mi></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.854ex" height="2.419ex" viewBox="0 -935.7 1228.8 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMATHI-4E" x="707" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>N</mi></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ N </script>  ensembles (termes) possibles de leurs arguments (variables) de nombre <i>N</i> , c'est-√†-dire Q &lt;P. Cette situation se rencontre en pratique dans la plupart des cas d'application d'algorithmes d'optimisation de fonctions logiques.  En effet, par exemple, si le nombre de variables d'entr√©e est <i>N</i> = 30, ce qui est un cas ordinaire, par exemple, sur les march√©s financiers, alors le volume de l'√©chantillon de formation d'entr√©e devrait √™tre de l'ordre de <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>30</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMAIN-30" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>30</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-2"> 2 ^ {30} </script>  &gt; <math></math><img src="https://habrastorage.org/getpro/habr/formulas/027/d2f/484/027d2f48439c514c7b9e44214daac670.svg" alt="10 $ ^ 9 $" data-tex="inline">  termes uniques uniques.  Un tel ensemble de donn√©es ne se retrouve pas dans toutes les organisations, m√™me tr√®s grandes, sans parler des individus, c'est-√†-dire que c'est d√©j√† le domaine du BigData, de l'utilisation des centres de donn√©es, etc. <br><br>  Par cons√©quent, dans la pratique, le plus souvent, les fonctions logiques minimis√©es ne seront pas compl√®tement d√©termin√©es simplement en raison du manque de quantit√© requise de donn√©es accumul√©es ou pour diverses autres raisons objectives (par exemple, il n'y a pas assez d'espace pour les stocker).  La question se pose de la possibilit√© de ¬´contournement¬ª de ce probl√®me lors de l'utilisation d'un algorithme qui fonctionne avec un ensemble compl√®tement d√©fini de fonctions de logique thermique, comme, par exemple, dans mon article pr√©c√©dent. <br><a name="habracut"></a><br><br>  Dans ce cas, la pratique standard consiste √† d√©terminer l'ensemble d'entr√©e incomplet de valeurs de variable (terme) √† l'ensemble afin de donner un r√©sultat optimal pour l'ensemble de donn√©es existant.  Mais, dans ce cas, il y a un probl√®me √† √©num√©rer toutes les variantes possibles de d√©finitions suppl√©mentaires, dont le nombre total est V = <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>P</mi><mo>&amp;#x2212;</mo><mi>Q</mi></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.207ex" height="2.539ex" viewBox="0 -987.6 2242 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMATHI-50" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMAIN-2212" x="751" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMATHI-51" x="1530" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mi>P</mi><mo>‚àí</mo><mi>Q</mi></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-3"> 2 ^ {P-Q} </script>  pour s√©lectionner la meilleure option pour une d√©finition suppl√©mentaire en fonction d'un crit√®re donn√©.  De toute √©vidence, pour les valeurs r√©ellement utilis√©es de Q et P, le nombre d'options tri√©es pour des d√©finitions suppl√©mentaires est astronomiquement important et cette approche ne peut pas √™tre mise en ≈ìuvre dans la pratique en raison de l'immense co√ªt de calcul. <br><br>  Ainsi, une approche diff√©rente est n√©cessaire qui √©liminerait la n√©cessit√© d'√©num√©rer diverses options pour des d√©finitions suppl√©mentaires.  Par cons√©quent, il est n√©cessaire de moderniser l'algorithme d'origine, qui ne fonctionne initialement qu'avec un ensemble d'entr√©e enti√®rement d√©fini, afin qu'il puisse √©galement fonctionner avec un ensemble tronqu√©.  C'est une telle impl√©mentation de l'algorithme qui est propos√©e dans cet article, bas√©e sur le fait que pendant le processus de minimisation, deux listes incompl√®tes de termes sont trait√©es simultan√©ment, sur lesquelles la fonction est sp√©cifi√©e comme FAUX (0) et VRAI (1). <br><br>  Du point de vue de l'apprentissage automatique, l'algorithme Quine-Mac'Klaski met en ≈ìuvre le paradigme d'apprentissage avec l'enseignant lorsque les valeurs de sortie correspondantes de la fonction objectif sont impliqu√©es dans le processus d'apprentissage (dans ce cas, la minimisation) simultan√©ment.  Permettez-moi de vous rappeler que le principe de fonctionnement de la m√©thode de base Quine-Mac'Klaski selon la th√©orie se compose de deux √©tapes principales: <br><ol><li>  Stage.  Trouver tous les termes LF simples en utilisant des r√®gles de collage (lois): <br>  a) (A et B)?  (A et! B)?  A; <br>  b) (A? B) &amp; (A?! B)?  A; <br>  o√π &amp; est l'op√©ration logique ET;?  - fonctionnement du "OU" logique;!  - op√©ration de n√©gation logique "NON".  De ces formules, il s'ensuit que deux termes sont coll√©s ensemble s'ils ne diff√®rent l'un de l'autre que dans l'une des positions des variables.  Dans la position o√π les deux termes diff√®rent l'un de l'autre, le signe ¬´*¬ª est plac√©.  Ainsi, l'alphabet en termes coll√©s par rapport √† l'original se d√©veloppe en trois valeurs: <br>  ‚Ä¢ 0 =&gt; faux; <br>  ‚Ä¢ 1 =&gt; vrai; <br>  ‚Ä¢ 2 =&gt; variable coll√©e (*). </li><li>  Stage.  Minimisation du nombre de termes coll√©s obtenus apr√®s la premi√®re √©tape, comme probl√®me de trouver la couverture optimale de l'ensemble initial de termes avec la quantit√© Q. Autrement dit, puisque chaque terme de sortie ne couvre qu'un certain sous-ensemble des termes initiaux, il est n√©cessaire de choisir un ensemble minimal de termes de sortie qui sont identifi√©s avec avec eux, des sous-ensembles de diff√©rentes longueurs au total couvraient compl√®tement tous les termes d'entr√©e initiaux.  Le rev√™tement dans ce cas signifie que l'op√©ration au niveau du bit de disjonction du terme de sortie sur le terme d'entr√©e a donn√© une vraie valeur.  Disons que le terme de sortie coll√© a la forme suivante: 10 * 0110 *. <br>  Ensuite, il couvre le terme 10101100: <br>  10 * 0110 * &amp; 10101100 = VRAI <br>  mais ne couvre pas le terme 00101100: <br>  10 * 0110 * &amp; 00101100 = FAUX <br>  Autrement dit, le terme d'entr√©e et la sortie doivent co√Øncider partout sauf pour les positions o√π il y a un symbole ¬´*¬ª - √† cette position, la variable du terme d'entr√©e peut prendre n'importe quelle valeur, car  dans cette position, la variable est exclue de la consid√©ration. </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Le code d'impl√©mentation est le suivant (cliquez pour voir):</b> <div class="spoiler_text"><pre><code class="plaintext hljs">using System; using System.Collections.Generic; using System.Linq; #region   /// &lt;summary&gt; ///      /// &lt;/summary&gt; public abstract class LogicFunction { // ""  public const byte cStarSymb = 2; //    public readonly ICollection&lt;byte[]&gt; Terms = new LinkedList&lt;byte[]&gt;(); //   public abstract bool Calculate(bool[] X); //   public abstract bool Calculate(char[] X); //   public abstract bool Calculate(byte[] X); } /// &lt;summary&gt; ///    /// &lt;/summary&gt; public class Dnf : LogicFunction { public static bool Calculate(byte[] X, byte[] term) { bool bResult = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] == cStarSymb) || (term[i] == X[i])) continue; bResult = false; break; } return bResult; } public override bool Calculate(byte[] X) { bool bResult = false; foreach (byte[] term in Terms) { bool bTermVal = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] &gt;= cStarSymb) || (term[i] == X[i])) continue; bTermVal = false; break; } //bResult |= bTermVal; if (bTermVal) { bResult = true; break; } } return bResult; } public override bool Calculate(char[] X) { bool bResult = false; foreach (byte[] term in Terms) { bool bTermVal = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] &gt;= cStarSymb) || (term[i] == (byte)(X[i] == '0' ? 0 : 1))) continue; bTermVal = false; break; } //bResult |= bTermVal; if (bTermVal) { bResult = true; break; } } return bResult; } public override bool Calculate(bool[] X) { bool bResult = false; foreach (byte[] term in Terms) { bool bTermVal = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] &gt;= cStarSymb) || ((term[i] != 0) == X[i])) continue; bTermVal = false; break; } //bResult |= bTermVal; if (bTermVal) { bResult = true; break; } } return bResult; } } #endregion /// &lt;summary&gt; ///   /// &lt;/summary&gt; public class TreeFuncTerm { /// &lt;summary&gt; ///     /// &lt;/summary&gt; public class TreeNodeEnd { } //    private readonly TreeNodeEnd pCommonTreeNodeEnd = new TreeNodeEnd(); //  private readonly object[] rootNode = new object[3]; // ()  private int _rang = 0; public int Rang { get { return _rang; } } //    private int enumerationPos = 0; private object[][] enumerationBuf; //,     private byte[] enumerationTerm; public byte[] EnumerationTerm { get { return enumerationTerm; } } //     private UInt32 _count = 0; public UInt32 Count { get { return _count; } } // public TreeFuncTerm() { Clear(); } //  public void Clear() { _count = 0; _rang = 0; enumerationPos = 0; enumerationBuf = null; enumerationTerm = null; rootNode[0] = rootNode[1] = rootNode[2] = null; } //      public TreeNodeEnd EnumerationInit() { enumerationPos = 0; enumerationTerm = new byte[_rang]; enumerationTerm[0] = 0; enumerationBuf = new object[_rang][]; enumerationBuf[0] = rootNode; //    return EnumerationNextNode(); } //     public TreeNodeEnd EnumerationNextNode() { int iIsNext = (enumerationPos &gt; 0 ? 1 : 0); TreeNodeEnd pRetTreeNode = null; while ((pRetTreeNode == null) &amp;&amp; (enumerationPos &gt;= 0)) { object[] pCurrNodes = enumerationBuf[enumerationPos]; object pNextNode = null; int i = enumerationTerm[enumerationPos] + iIsNext; for (; i &lt; 3; i++) if ((pNextNode = pCurrNodes[i]) != null) break; if (pNextNode == null) { //    enumerationPos--; iIsNext = 1; } else { enumerationTerm[enumerationPos] = (byte)i; if (pNextNode is object[]) { //    enumerationPos++; enumerationBuf[enumerationPos] = (object[])pNextNode; enumerationTerm[enumerationPos] = 0; iIsNext = 0; } else //if (pNextNode is TreeNodeEnd) { //   pRetTreeNode = (TreeNodeEnd)pNextNode; } } } return pRetTreeNode; } //     public void AddTerm(byte[] term) { _rang = Math.Max(_rang, term.Length); object[] pCurrNode = rootNode; int iTermLength1 = term.Length - 1; for (int j = 0; j &lt; iTermLength1; j++) { byte cSymb = term[j]; object item = pCurrNode[cSymb]; if (item == null) { item = new object[3]; pCurrNode[cSymb] = item; } pCurrNode = (object[])item; } if (pCurrNode[term[iTermLength1]] == null) { //    pCurrNode[term[iTermLength1]] = pCommonTreeNodeEnd; _count++; } } //      public TreeNodeEnd Remove(byte[] term) { int iTermLength1 = term.Length - 1; object[] pCurrNode = rootNode; for (int i = 0; i &lt; iTermLength1; i++) { pCurrNode = (object[])pCurrNode[term[i]]; if (pCurrNode == null) break; } TreeNodeEnd pRemovedNode = null; if (pCurrNode != null) { //      pRemovedNode = (TreeNodeEnd)pCurrNode[term[iTermLength1]]; if (pRemovedNode != null) { //     pCurrNode[term[iTermLength1]] = null; // -  _count--; } } return pRemovedNode; } //     public bool Contains(byte[] term) { object pCurrNode = rootNode; foreach (byte cSymb in term) { pCurrNode = ((object[])pCurrNode)[cSymb]; if (pCurrNode == null) break; } return ((pCurrNode != null) &amp;&amp; (pCurrNode is TreeNodeEnd)); } } /// &lt;summary&gt; ///     ---- /// &lt;/summary&gt; public class Quine_McCluskey { //    private readonly Dnf _result = new Dnf(); public Dnf Result { get { return _result; } } //    private readonly Dnf _resultNeg = new Dnf(); public Dnf ResultNeg { get { return _resultNeg; } } //     private static void Skleivanie(TreeFuncTerm X1Tree, TreeFuncTerm X2Tree, TreeFuncTerm NegativTree, IEnumerable&lt;byte[]&gt; InpNegTerms, Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; OutResult, int iLevel) { LinkedList&lt;byte[]&gt; OutR = new LinkedList&lt;byte[]&gt;(); if (OutResult != null) OutResult.Add(iLevel, OutR); bool IsVirtSkleivOn = ((NegativTree != null) &amp;&amp; (InpNegTerms != null) &amp;&amp; (InpNegTerms.Count() != 0)); for (TreeFuncTerm.TreeNodeEnd x1 = X1Tree.EnumerationInit(); x1 != null; x1 = X1Tree.EnumerationNextNode()) { bool bIsSkleiv = false; byte[] pCurrTerm = X1Tree.EnumerationTerm; for (int iPos = 0; iPos &lt; pCurrTerm.Length; iPos++) { byte cSymbSav = pCurrTerm[iPos]; if (cSymbSav == LogicFunction.cStarSymb) continue; //      pCurrTerm[iPos] = (byte)(1 - cSymbSav); if (X1Tree.Contains(pCurrTerm)) { bIsSkleiv = true; //,         if (cSymbSav == 1) { pCurrTerm[iPos] = LogicFunction.cStarSymb; //  X2Tree.AddTerm(pCurrTerm); } } //    ,    NegativTree else if (IsVirtSkleivOn &amp;&amp; !NegativTree.Contains(pCurrTerm)) { bool bIsNotCanAdd = false; pCurrTerm[iPos] = LogicFunction.cStarSymb; //  foreach (byte[] NegTerm in InpNegTerms) { if (bIsNotCanAdd = Dnf.Calculate(NegTerm, pCurrTerm)) break; } if (!bIsNotCanAdd) { bIsSkleiv = true; X2Tree.AddTerm(pCurrTerm); } } pCurrTerm[iPos] = cSymbSav; } //    ,       if (!bIsSkleiv) OutR.AddLast((byte[])pCurrTerm.Clone()); } } //     private static UInt64 GetTermCode(byte[] pTerm) { UInt64 iMultip = 1, iCode = 0; for (int i = 0; i &lt; pTerm.Length; i++) { iCode += (iMultip * pTerm[i]); iMultip *= 3; } return iCode; } //     private static byte[] GetTermByCode(UInt64 iCode, int iTermLength, byte[] pTerm = null) { if (pTerm == null) pTerm = new byte[iTermLength]; int iCounter = 0; while (iCode != 0) { pTerm[iCounter++] = (byte)(iCode % 3); iCode /= 3; } while (iCounter &lt; iTermLength) pTerm[iCounter++] = 0; return pTerm; } //     private static void Skleivanie(ICollection&lt;UInt64&gt; X1Tree, ICollection&lt;UInt64&gt; X2Tree, ICollection&lt;UInt64&gt; NegativTree, IEnumerable&lt;byte[]&gt; InpNegTerms, Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; OutResult, int iLevel, int iTermLength) { LinkedList&lt;byte[]&gt; OutR = new LinkedList&lt;byte[]&gt;(); if (OutResult != null) OutResult.Add(iLevel, OutR); byte[] pCurrTerm = new byte[iTermLength]; bool IsVirtSkleivOn = ((NegativTree != null) &amp;&amp; (InpNegTerms != null) &amp;&amp; (InpNegTerms.Count() != 0)); foreach (UInt64 x1 in X1Tree) { GetTermByCode(x1, iTermLength, pCurrTerm); bool bIsSkleiv = false; UInt64 iMultip = 1; for (int iPos = 0; iPos &lt; iTermLength; iPos++) { byte cSymbSav = pCurrTerm[iPos]; //(byte)((x1 / iMultip) % 3); if (cSymbSav != LogicFunction.cStarSymb) { UInt64 iCode = (cSymbSav == 0 ? x1 + iMultip : x1 - iMultip); //      if (X1Tree.Contains(iCode)) { bIsSkleiv = true; //,         if (cSymbSav == 1) { X2Tree.Add(x1 + iMultip); } } //    ,    NegativTree else if (IsVirtSkleivOn &amp;&amp; !NegativTree.Contains(iCode)) { bool bIsNotCanAdd = false; pCurrTerm[iPos] = LogicFunction.cStarSymb; //  foreach (byte[] NegTerm in InpNegTerms) { if (bIsNotCanAdd = Dnf.Calculate(NegTerm, pCurrTerm)) break; } pCurrTerm[iPos] = cSymbSav; if (!bIsNotCanAdd) { bIsSkleiv = true; X2Tree.Add(x1 + (byte)(LogicFunction.cStarSymb - cSymbSav) * iMultip); } } } iMultip *= 3; } //    ,       if (!bIsSkleiv) OutR.AddLast((byte[])pCurrTerm.Clone()); } } //      //       private static void DeleteDublicatingTerms(IEnumerable&lt;byte[]&gt; InX1, ICollection&lt;UInt64&gt; OutX2Tree) { OutX2Tree.Clear(); foreach (byte[] x1 in InX1) { UInt64 iCode = GetTermCode(x1); if (OutX2Tree.Contains(iCode)) continue; OutX2Tree.Add(iCode); } } //      //       private static void DeleteDublicatingTerms(IEnumerable&lt;byte[]&gt; InX1, TreeFuncTerm OutX2Tree) { OutX2Tree.Clear(); foreach (byte[] x1 in InX1) OutX2Tree.AddTerm(x1); } //    private static bool IsEqualTerms(byte[] pTermC, byte[] pTermB) { if ((pTermC == null) || (pTermB == null) || (pTermC.Length != pTermB.Length)) return false; bool bIsEqual = false; int iLength = Math.Min(pTermC.Length, pTermB.Length); for ( int i = 0; i &lt; iLength; i++) { if (!(bIsEqual = (pTermB[i] == pTermC[i]))) break; } return bIsEqual; } //            private static void ReduceRedundancyTerms(LinkedList&lt;byte[]&gt; InpTerms, Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; SkleivTerms, ICollection&lt;byte[]&gt; ResultTerms) { if ((InpTerms == null) || (SkleivTerms == null) || (ResultTerms == null)) return; //   ResultTerms.Clear(); //        ,    Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt; Outputs2Inputs = new Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt;(); //        ,    Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt; Inputs2Outputs = new Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt;(); //    foreach (int iLevel in SkleivTerms.Keys.OrderByDescending(p =&gt; p).AsEnumerable()) { //       foreach (byte[] outTerm in SkleivTerms[iLevel]) { //  ,      term HashSet&lt;byte[]&gt; InpTermsLst = new HashSet&lt;byte[]&gt;(); //     foreach (byte[] inpTerm in InpTerms) { if (Dnf.Calculate(inpTerm, outTerm)) { InpTermsLst.Add(inpTerm); if (!Inputs2Outputs.ContainsKey(inpTerm)) Inputs2Outputs.Add(inpTerm, new HashSet&lt;byte[]&gt;()); Inputs2Outputs[inpTerm].Add(outTerm); } } Outputs2Inputs.Add(outTerm, InpTermsLst); } } //      -    Inputs2Outputs = Inputs2Outputs.OrderBy(p =&gt; p.Value.Count).ToDictionary(p =&gt; p.Key, v =&gt; v.Value); //   ,   -    while (Inputs2Outputs.Count &gt; 0) { byte[] outTerm = Inputs2Outputs.First().Value.OrderByDescending(q =&gt; Outputs2Inputs[q].Count()).First(); ResultTerms.Add(outTerm); foreach (byte[] inpTerm in Outputs2Inputs[outTerm].ToArray()) { foreach (byte[] outTerm2Del in Inputs2Outputs[inpTerm]) Outputs2Inputs[outTerm2Del].Remove(inpTerm); Inputs2Outputs.Remove(inpTerm); } } } //    public static void LogicFuncMinimize(IEnumerable&lt;byte[]&gt; PositivTerms, ICollection&lt;byte[]&gt; OutPos, IEnumerable&lt;byte[]&gt; NegativTerms, ICollection&lt;byte[]&gt; OutNeg) { int iTotalLevels = (PositivTerms.Count() &gt; 0 ? PositivTerms.First().Length : (NegativTerms != null &amp;&amp; NegativTerms.Count() &gt; 0 ? NegativTerms.First().Length : 0)); Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; SkleivPosTerms = new Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt;(iTotalLevels); Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; SkleivNegTerms = new Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt;(iTotalLevels); LinkedList&lt;byte[]&gt; InpPosTerms = new LinkedList&lt;byte[]&gt;(); LinkedList&lt;byte[]&gt; InpNegTerms = new LinkedList&lt;byte[]&gt;(); if (iTotalLevels &lt; 40) { HashSet&lt;UInt64&gt; X1PositivTree = new HashSet&lt;UInt64&gt;(); DeleteDublicatingTerms(PositivTerms, X1PositivTree); HashSet&lt;UInt64&gt; X1NegativTree = null; if (NegativTerms != null) { X1NegativTree = new HashSet&lt;UInt64&gt;(); DeleteDublicatingTerms(NegativTerms, X1NegativTree); //        foreach(UInt64 iNumb in X1PositivTree.Intersect(X1NegativTree)) { // -    X1   NegativTerms int iPos_Count = PositivTerms.Count(p =&gt; GetTermCode(p) == iNumb); int iNeg_Count = NegativTerms.Count(p =&gt; GetTermCode(p) == iNumb); if (iPos_Count &gt; iNeg_Count) { X1NegativTree.Remove(iNumb); } else if (iPos_Count &lt; iNeg_Count) { X1PositivTree.Remove(iNumb); } else //if (iPos_Count == iNeg_Count) { X1PositivTree.Remove(iNumb); X1NegativTree.Remove(iNumb); } } //           foreach (UInt64 code in X1NegativTree) { InpNegTerms.AddLast(GetTermByCode(code, iTotalLevels)); } } //          foreach (UInt64 code in X1PositivTree) { InpPosTerms.AddLast(GetTermByCode(code, iTotalLevels)); } int iLevelCounter = 0; //        while ((X1PositivTree.Count != 0) &amp;&amp; (iLevelCounter &lt; iTotalLevels)) { HashSet&lt;UInt64&gt; X2PositivTree = new HashSet&lt;UInt64&gt;(); Skleivanie(X1PositivTree, X2PositivTree, X1NegativTree, InpNegTerms, SkleivPosTerms, iLevelCounter, iTotalLevels); if ((X1NegativTree != null) &amp;&amp; (X1NegativTree.Count != 0)) { HashSet&lt;UInt64&gt; X2NegativTree = new HashSet&lt;UInt64&gt;(); Skleivanie(X1NegativTree, X2NegativTree, X1PositivTree, InpPosTerms, SkleivNegTerms, iLevelCounter, iTotalLevels); //   X1NegativTree.Clear(); X1NegativTree = X2NegativTree; } //   X1PositivTree.Clear(); X1PositivTree = X2PositivTree; iLevelCounter++; GC.Collect(); } } else { TreeFuncTerm X1PositivTree = new TreeFuncTerm(); DeleteDublicatingTerms(PositivTerms, X1PositivTree); TreeFuncTerm X1NegativTree = null; if (NegativTerms != null) { X1NegativTree = new TreeFuncTerm(); DeleteDublicatingTerms(NegativTerms, X1NegativTree); //         for (TreeFuncTerm.TreeNodeEnd x1 = X1PositivTree.EnumerationInit(); x1 != null; x1 = X1PositivTree.EnumerationNextNode()) { if (!X1NegativTree.Contains(X1PositivTree.EnumerationTerm)) continue; // -    PositivTerms   NegativTerms int iPos_Count = PositivTerms.Count(p =&gt; IsEqualTerms(p, X1PositivTree.EnumerationTerm)); int iNeg_Count = NegativTerms.Count(p =&gt; IsEqualTerms(p, X1PositivTree.EnumerationTerm)); if (iPos_Count &gt; iNeg_Count) { X1NegativTree.Remove(X1PositivTree.EnumerationTerm); } else if (iPos_Count &lt; iNeg_Count) { X1PositivTree.Remove(X1PositivTree.EnumerationTerm); } else //if (iPos_Count == iNeg_Count) { X1PositivTree.Remove(X1PositivTree.EnumerationTerm); X1NegativTree.Remove(X1PositivTree.EnumerationTerm); } } //           for (TreeFuncTerm.TreeNodeEnd x1 = X1NegativTree.EnumerationInit(); x1 != null; x1 = X1NegativTree.EnumerationNextNode()) { InpNegTerms.AddLast((byte[])X1NegativTree.EnumerationTerm.Clone()); } } //          for (TreeFuncTerm.TreeNodeEnd X1Term = X1PositivTree.EnumerationInit(); X1Term != null; X1Term = X1PositivTree.EnumerationNextNode()) { InpPosTerms.AddLast((byte[])X1PositivTree.EnumerationTerm.Clone()); } int iLevelCounter = 0; //        while ((X1PositivTree.Count != 0) &amp;&amp; (iLevelCounter &lt; iTotalLevels)) { TreeFuncTerm X2PositivTree = new TreeFuncTerm(); Skleivanie(X1PositivTree, X2PositivTree, X1NegativTree, InpNegTerms, SkleivPosTerms, iLevelCounter); if ((X1NegativTree != null) &amp;&amp; (X1NegativTree.Count != 0)) { TreeFuncTerm X2NegativTree = new TreeFuncTerm(); Skleivanie(X1NegativTree, X2NegativTree, X1PositivTree, InpPosTerms, SkleivNegTerms, iLevelCounter); //   X1NegativTree.Clear(); X1NegativTree = X2NegativTree; } //   X1PositivTree.Clear(); X1PositivTree = X2PositivTree; iLevelCounter++; GC.Collect(); } } //       ReduceRedundancyTerms(InpPosTerms, SkleivPosTerms, OutPos); //       ReduceRedundancyTerms(InpNegTerms, SkleivNegTerms, OutNeg); } //  public void Start(IEnumerable&lt;byte[]&gt; TermsInput) { LogicFuncMinimize(TermsInput, _result.Terms, null, null); } //  public void Start(IEnumerable&lt;byte[]&gt; TermsInput, IEnumerable&lt;byte[]&gt; NegativTerms) { LogicFuncMinimize(TermsInput, _result.Terms, NegativTerms, _resultNeg.Terms); } //  public void Start(IEnumerable&lt;char[]&gt; TermsInput) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray())); } //  public void Start(IEnumerable&lt;char[]&gt; TermsInput, IEnumerable&lt;char[]&gt; NegativTerms) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray()), NegativTerms.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray())); } //  public void Start(IEnumerable&lt;bool[]&gt; TermsInput) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray())); } //  public void Start(IEnumerable&lt;bool[]&gt; TermsInput, IEnumerable&lt;bool[]&gt; NegativTerms) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray()), NegativTerms.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray())); } public void PrintResult() { Console.WriteLine("--------Otvet-------"); char[] pTermSymbs = new char[] { '0', '1', '*' }; foreach (byte[] Term in _result.Terms) { for (int j = 0; j &lt; Term.Length; j++) { Console.Write(pTermSymbs[Term[j]].ToString() + " "); } Console.WriteLine(); } } }</code> </pre> <br></div></div><br><br>  La classe Quine_McCluskey est une impl√©mentation de cet algorithme qui utilise d'autres classes et interfaces: Dnf, TreeNodeBase, TreeNodeMiddle, TreeNodeEnd, TreeFuncTerm.  Pour d√©marrer l'optimisation, vous devez appeler l'une des m√©thodes Start surcharg√©es, qui appelle la fonction LogicFuncMinimize, o√π, en fait, l'algorithme de minimisation est impl√©ment√©.  Le m√©canisme de minimisation est impl√©ment√© en deux versions: <br>  ‚Ä¢ Utilisation du conteneur .NET SortedSet pour stocker et rechercher des termes. <br>  ‚Ä¢ sans utiliser de conteneurs .NET bas√©s sur l'arborescence ternaire TreeFuncTerm. <br><br>  En termes de vitesse, ces deux options sont √† peu pr√®s √©gales (avec les conteneurs .NET, peut-√™tre un peu plus rapides, mais pas toujours), mais la n√©cessit√© d'impl√©menter TreeFuncTerm est due √† plusieurs facteurs: <br>  ‚Ä¢ La premi√®re option, bas√©e sur des codes de hachage d'entiers 64 bits et une recherche dans le dictionnaire SortedSet .NET, ne fonctionne correctement qu'avec le nombre de variables d'entr√©e en termes jusqu'√† 40, et avec un nombre plus grand, elle d√©passe la grille de codes de hachage d'entiers 64 bits, utilis√© pour le fonctionnement des conteneurs.  En effet, puisque la logique ternaire est utilis√©e en termes coll√©s √† l'int√©rieur de l'algorithme, alors avec le nombre de variables d'entr√©e √©gal √† 41, la valeur maximale du code de hachage <math></math><img src="https://habrastorage.org/getpro/habr/formulas/bd6/da6/984/bd6da6984fc746d3a36494ed571a2758.svg" alt="3 $ ^ {41} $" data-tex="inline">  d√©passe d√©j√† la valeur maximale <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>64</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMAIN-36"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMAIN-34" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>64</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-4"> 2 ^ {64} </script>  -1, qui peut √™tre √©crit dans une variable 64 bits.  Avec plus de variables, une option est utilis√©e bas√©e sur l'arbre de recherche ternaire TreeFuncTerm de l'auteur. <br>  ‚Ä¢ Il est n√©cessaire de v√©rifier le fonctionnement de l'impl√©mentation sur les conteneurs .NET avec une autre impl√©mentation ind√©pendante de celle-ci, libre d'eux. <br>  ‚Ä¢ Vous avez juste besoin d'une option exempte de conteneurs .NET, qui pourrait √™tre facilement impl√©ment√©e sur des plateformes o√π il n'y a pas de plateforme .NET (par exemple, dans les microcontr√¥leurs, les FPGA, etc.). <br>  Le fonctionnement de l'arborescence de recherche TreeFuncTerm est bas√© sur la configuration des liens vers les classes TreeNodeMiddle et TreeNodeEnd, qui sont des impl√©mentations de l'interface TreeNodeBase.  La classe TreeNodeMiddle est un n≈ìud interm√©diaire de l'arbre et la classe TreeNodeEnd est l'extr√©mit√© de feuille de l'arbre.  √Ä l'aide des fonctions EnumerationInit () et EnumerationNextNode (), un m√©canisme non r√©cursif pour √©num√©rer toutes les feuilles de TreeNodeEnd est impl√©ment√© dans l'arborescence.  La fonction EnumerationInit () initialise l'√©num√©ration et renvoie la premi√®re feuille de l'arborescence.  La fonction EnumerationNextNode () renvoie la prochaine feuille d'arbre ou NULL s'il n'y a plus de feuilles pour la s√©lection.  De plus, la structure interne auxiliaire EnumerationTerm, qui refl√®te la position du ¬´curseur¬ª de recherche √† l'int√©rieur de l'arbre, est √©galement le terme code de la feuille trouv√©e dans la logique ternaire {0,1,2}.  Il est √† noter que l'ordre de s√©lection des feuilles de l'arbre ne co√Øncide pas avec l'ordre de leur addition. <br><br>  L'algorithme √† des fins fonctionnelles peut √™tre divis√© en trois √©tapes. <br><ol><li>  <b>Pr√©paration.</b>  Pour r√©soudre le probl√®me ci-dessus d'√©liminer l'√©num√©ration des options de d√©finitions suppl√©mentaires dans l'impl√©mentation consid√©r√©e, l'entr√©e de l'algorithme dans la fonction LogicFuncMinimize re√ßoit deux ensembles de donn√©es initiaux PositivTerms et NegativTerms, sur lesquels la fonction optimis√©e accepte respectivement les valeurs true (TRUE, 1) et false (FALSE, 0).  Tout d'abord, ces listes sont v√©rifi√©es pour la coh√©rence des donn√©es source.  Il est n√©cessaire que chacun des ensembles de donn√©es soit garanti pour ne contenir que des termes uniques qui ne sont pr√©sents que dans l'une des listes.  Pour garantir cela, chaque terme d'entr√©e unique est analys√© et le nombre d'entr√©es dans chacune des listes source est trouv√©.  Si le terme appara√Æt dans les deux listes, il ne reste que dans la liste dans laquelle il appara√Æt davantage et est supprim√© de l'autre.  Si le terme appara√Æt √©galement dans chacune des listes, il est supprim√© des deux listes, ce qui garantit l'unicit√©. </li><li>  <b>Collage.</b>  Ensuite, un cycle it√©ratif de collage des termes d'entr√©e est effectu√©.  A chaque it√©ration, en termes coll√©s, un signe * de la position coll√©e est ajout√©.  Par cons√©quent, le nombre d'it√©rations ne peut pas √™tre sup√©rieur au nombre de variables <i>N.</i>  Contrairement √† l'impl√©mentation pr√©c√©dente, la fonction Skleivanie pour coller des termes d'entr√©e a la capacit√© de coller non seulement avec des termes de sa liste, mais aussi en l'absence d'un terme avec une diff√©rence √©galement avec les termes dits "virtuels".  Par termes ¬´virtuels¬ª, nous entendons des termes d√©finis artificiellement qui ne se trouvent dans aucune des listes de termes d'un ensemble du niveau actuel.  Mais le collage n'est possible que si le terme ¬´virtuel¬ª ne couvre pas un seul terme de l'ensemble initial de la liste oppos√©e. <br>  La fonction Skleivanie est appel√©e pour traiter deux fois les listes √† chaque it√©ration de sorte que dans le premier appel, la signification de l'utilisation des listes PositivTerms et NegativTerms co√Øncide avec leur contenu r√©el, et dans le deuxi√®me appel, les listes PositivTerms et NegativTerms sont √©chang√©es en termes d'utilisation, c'est-√†-dire, on consid√®re que La liste PositivTerms contient des termes n√©gatifs et la liste NegativTerms contient des termes positifs: <br>  Skleivanie (X1PositivTree, ..., X1NegativTree, ..., SkleivTerms, ...); <br>  Skleivanie (X1NegativTree, ..., X1PositivTree, ..., null, ...); <br>  Ainsi, un collage simultan√© interd√©pendant des termes de deux listes se produit. <br>  Si pour le terme il n'y a pas d'autre terme qui soit diff√©rent de lui dans une seule position, ni r√©el ni virtuel, c'est-√†-dire que le terme ne colle avec personne, alors il est consid√©r√© comme l'un des r√©sultats de l'√©tape 1 de l'algorithme, il est exclu des travaux ult√©rieurs et va √† l'entr√©e de l'√©tape 2 de l'algorithme impl√©ment√© dans la proc√©dure ReduceRedundancyTerms.  Les termes non coll√©s sont envoy√©s √† la sortie de l'algorithme uniquement lors de cet appel √† la fonction Skleivanie, pour lequel la signification de l'utilisation des listes PositivTerms et NegativTerms co√Øncide avec leur remplissage r√©el, c'est-√†-dire lors du premier appel. </li><li>  <b>Abr√©viation.</b>  Les termes coll√©s redondants sont rejet√©s dans ReduceRedundancyTerms √† l'aide d'un algorithme pour r√©soudre approximativement le probl√®me de la couverture de l'ensemble d'origine avec des sous-ensembles de longueur variable.  La couverture, qui est proche de la plus courte, est fournie par l'algorithme de conversion de la table de couverture (TP), bas√© sur la m√©thode ¬´colonne minimale - ligne maximale¬ª (qui peut √™tre consult√©e, par exemple, ici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://www.studfiles.ru/preview/5175815/page:4</a> ) . <br>  La logique approximative de son travail est la suivante: <br>  0. La table d'origine est consid√©r√©e comme le TP transform√© actuel, l'ensemble des lignes de couverture est vide; <br>  1. La colonne avec le moins d'unit√©s est mise en surbrillance dans le tableau actuel.  Parmi les lignes contenant des unit√©s dans cette colonne, une avec le plus grand nombre d'unit√©s est mise en √©vidence.  Cette ligne est incluse dans la couverture, la table actuelle est r√©duite en supprimant toutes les colonnes dans lesquelles la ligne s√©lectionn√©e a une unit√©. <br>  2. S'il n'y a pas de colonnes barr√©es dans le tableau, l'√©tape 1 est ex√©cut√©e, sinon la couverture est construite.  Remarque: Lors du calcul du nombre d'unit√©s dans une ligne, les unit√©s dans les colonnes non marqu√©es sont prises en compte. <br>  Cet algorithme fonctionne assez rapidement et donne un r√©sultat presque optimal. <br>  Pour tester le fonctionnement de l'algorithme, il est propos√© d'utiliser la fonction de test TestQuineMcCluskeyRandomPart, qui, sur l'ensemble des termes possibles, est <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mi>N</mi></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.854ex" height="2.419ex" viewBox="0 -935.7 1228.8 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhhBB0jfQH-b-RiNNrpLGt1I6_wmdg#MJMATHI-4E" x="707" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>N</mi></msup></math></span></span><script type="math/tex" id="MathJax-Element-5"> 2 ^ N </script>  s√©lectionne al√©atoirement uniquement la partie donn√©e 0 &lt;dPart &lt;= 1 (est un param√®tre de la fonction), pour laquelle l'optimisation est effectu√©e.  Avec le param√®tre dPart &lt;1, un ensemble tronqu√© de termes d'entr√©e sera obtenu et avec dPart = 1, un ensemble complet de donn√©es d'entr√©e sera obtenu. </li></ol><br><div class="spoiler">  <b class="spoiler_title">TestQuineMcCluskeyRandomPart (cliquez pour voir)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">public static void TestQuineMcCluskeyRandomPart(int iVariableAmount, double dPart=1) { if (dPart &lt; 0) throw new ArgumentException(" dPart    0   1"); if (dPart &gt; 1) dPart = 1; //   ulong iTotalCombines = (ulong)1 &lt;&lt; iVariableAmount; LinkedList&lt;byte[]&gt; pTrueCol = new LinkedList&lt;byte[]&gt;(); LinkedList&lt;byte[]&gt; pFalseCol = new LinkedList&lt;byte[]&gt;(); HashSet&lt;ulong&gt; pUsedTerms = new HashSet&lt;ulong&gt;(); Random rnd = new Random(); byte[] buf = new byte[8]; while (pUsedTerms.LongCount() &lt; (iTotalCombines * dPart)) { rnd.NextBytes(buf); ulong iCurValue = (ulong)BitConverter.ToInt64(buf, 0) % iTotalCombines; if (pUsedTerms.Contains(iCurValue)) { //  -     do { iCurValue = ++iCurValue % iTotalCombines; } while (pUsedTerms.Contains(iCurValue)); } pUsedTerms.Add(iCurValue); byte[] sLine = new byte[iVariableAmount]; for (int i = 0; i &lt; iVariableAmount; i++) { sLine[i] += (byte)(iCurValue % 2); iCurValue &gt;&gt;= 1; } if (rnd.Next(2) != 0) { pTrueCol.AddLast(sLine); } else { pFalseCol.AddLast(sLine); } } //   DateTime DtStart = DateTime.Now; Console.WriteLine(" - " + DtStart.ToLongTimeString()); Quine_McCluskey Logic = new Quine_McCluskey(); Logic.Start(pTrueCol, pFalseCol); DateTime DtEnd = DateTime.Now; Logic.PrintResult(); Console.WriteLine(" - " + DtStart.ToLongTimeString()); Console.WriteLine(" - " + DtEnd.ToLongTimeString()); TimeSpan Elapsed = DtEnd - DtStart; Console.WriteLine(" - " + String.Format("{0:00}:{1:00}:{2:00}", Elapsed.Hours, Elapsed.Minutes, Elapsed.Seconds)); //  int iErrorsCounter = 0; foreach (byte[] kvp in pTrueCol) { if (Logic.Result.Calculate(kvp) != true) iErrorsCounter++; } foreach (byte[] kvp in pFalseCol) { if (Logic.Result.Calculate(kvp) != false) iErrorsCounter++; } Console.WriteLine("-   = " + pUsedTerms.Count); Console.WriteLine("-   = " + Logic.Result.Terms.Count); Console.WriteLine("-  = " + iErrorsCounter); Console.ReadLine(); }</code> </pre><br></div></div><br><br>  √Ä la suite de la fonction de test, le nombre de termes dans la forme normale disjonctive minimale et le nombre d'erreurs le couvrant avec l'ensemble de termes d'origine sont calcul√©s. <br><br>  En conclusion, je voudrais noter qu'en pratique, cette impl√©mentation de l'algorithme s'est r√©v√©l√©e √™tre un moyen efficace et fiable de minimiser les fonctions logiques d√©finies par deux ensembles de termes incomplets sur lesquels la fonction logique prend les valeurs VRAI et FAUX, respectivement.  Bien entendu, cette impl√©mentation peut √©galement √™tre utilis√©e sous la forme classique dans le cas d'une fonction logique d'entr√©e compl√®tement d√©finie, lorsque seule l'une ou l'autre liste de termes est entr√©e.  Comme inconv√©nient, il est n√©cessaire de v√©rifier dans la fonction Skleivanie qu'il n'y a pas d'erreurs de couverture pour chaque terme virtuel de la liste compl√®te des termes source √† chaque it√©ration de l'algorithme, ce qui entra√Æne des co√ªts de temps importants avec un grand nombre de termes d'entr√©e. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424517/">https://habr.com/ru/post/fr424517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424505/index.html">¬´Nous avons des id√©es pour Maven 4 et m√™me Maven 5¬ª - une interview de Robert Scholte, un acteur cl√© du projet Maven</a></li>
<li><a href="../fr424507/index.html">VI Hackathon JetBrains annuel: Shiftius Altius Ctrlius</a></li>
<li><a href="../fr424509/index.html">Utilisation de l'API KOMPAS-3D ‚Üí Le√ßon 12 ‚Üí Lignes compos√©es</a></li>
<li><a href="../fr424511/index.html">Outils pour trouver des classes annot√©es en Java</a></li>
<li><a href="../fr424513/index.html">√Ä propos des centres de donn√©es bon march√©, de la protection ILV et DDoS</a></li>
<li><a href="../fr424519/index.html">Beethoven peut-il envoyer des demandes de suppression?</a></li>
<li><a href="../fr424525/index.html">Contr√¥le de vitesse mini-perceuse</a></li>
<li><a href="../fr424531/index.html">Microservices: la taille compte m√™me si vous avez Kubernetes</a></li>
<li><a href="../fr424533/index.html">"Tout informaticien qui se respecte est engag√© dans la technologie pendant son temps libre" - 10 questions pour le programmeur, num√©ro 6</a></li>
<li><a href="../fr424537/index.html">Sberbank a lanc√© son propre op√©rateur SberMobile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>