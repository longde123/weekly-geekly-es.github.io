<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏿 ✔️ 🌬️ Perluas dan pelengkap Kubernetes (tinjau dan laporkan video) 👨🏿‍🏭 🤱🏿 👨🏿‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada 8 April, di konferensi Saint HighLoad ++ 2019 , dalam kerangka kerja bagian DevOps dan Operasi, sebuah laporan dibuat berjudul "Memperluas dan Me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perluas dan pelengkap Kubernetes (tinjau dan laporkan video)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/449096/"><img src="https://habrastorage.org/webt/kv/co/ra/kvcoraarvayusctrljjfqzvmukq.jpeg"><br><br>  Pada 8 April, di konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saint HighLoad ++ 2019</a> , dalam kerangka kerja bagian DevOps dan Operasi, sebuah laporan dibuat berjudul "Memperluas dan Melengkapi Kubernetes", yang dibuat oleh tiga karyawan Flant.  Di dalamnya, kami berbicara tentang berbagai situasi di mana kami ingin memperluas dan melengkapi kemampuan Kubernetes, tetapi kami tidak menemukan solusi yang siap pakai dan sederhana.  Solusi yang diperlukan muncul dalam bentuk proyek Open Source, dan presentasi ini juga didedikasikan untuk mereka. <br><br>  Secara tradisi, kami senang menyajikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>video dengan laporan</b></a> (50 menit, jauh lebih informatif daripada artikel) dan penekanan utama dalam bentuk teks.  Ayo pergi! <a name="habracut"></a><br><br><h2>  K8s Kernel dan Add-on </h2><br>  Kubernetes mengubah pendekatan industri dan administrasi yang sudah lama ada: <br><br><ul><li>  Berkat <b>abstraksinya</b> , kami tidak lagi beroperasi dengan konsep seperti mengonfigurasi konfigurasi atau menjalankan perintah (Chef, Ansible ...), tetapi menggunakan pengelompokan wadah, layanan, dll. </li><li>  Kami dapat menyiapkan aplikasi tanpa memikirkan nuansa <b>platform spesifik</b> tempat peluncurannya: bare metal, cloud salah satu penyedia, dll. </li><li>  Dengan K8, <b>praktik terbaik</b> untuk mengatur infrastruktur menjadi lebih mudah diakses dari sebelumnya: penskalaan, penyembuhan sendiri, toleransi kesalahan, dll. </li></ul><br>  Namun, tentu saja, semuanya tidak begitu mulus: dengan Kubernetes datang tantangan baru - mereka sendiri. <br><br>  Kubernetes <b>bukan</b> kombinasi yang menyelesaikan semua masalah semua pengguna.  <b>Inti</b> Kubernetes hanya bertanggung jawab untuk sekumpulan fungsi minimum yang diperlukan yang ada di <b>setiap</b> kluster: <br><br><img src="https://habrastorage.org/webt/j4/bi/2r/j4bi2rovwoaeg30vtxmqvkf3gr0.png"><br><br>  Dalam inti Kubernetes, satu set primitif dasar didefinisikan - untuk pengelompokan kontainer, mengatur lalu lintas, dan sebagainya.  Kami membicarakannya lebih detail dalam sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan 2 tahun yang lalu</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ri/3r/bh/ri3rbhiadlucbkmjxoi7evenkoc.png"></a> <br><br>  Di sisi lain, K8 menawarkan peluang besar untuk memperluas fungsi yang tersedia, yang membantu untuk menutup kebutuhan pengguna khusus lainnya.  Administrator cluster bertanggung jawab atas penambahan Kubernetes, yang harus menginstal dan mengkonfigurasi semua yang diperlukan sehingga cluster mereka "menemukan bentuk yang tepat" [untuk menyelesaikan masalah spesifik mereka].  Tambahan apa ini?  Mari kita lihat beberapa contoh. <br><br><h2>  Contoh penambahan </h2><br>  Setelah menginstal Kubernetes, kita mungkin akan terkejut bahwa jaringan, yang sangat diperlukan untuk interaksi pod baik di dalam node maupun di antara node, tidak bekerja dengan sendirinya.  Inti Kubernetes tidak menjamin koneksi yang diperlukan - sebaliknya, inti Kubernetes menentukan <b>antarmuka</b> jaringan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CNI</a> ) untuk add-on pihak ketiga.  Kita harus menginstal salah satu dari tambahan ini, yang akan bertanggung jawab untuk konfigurasi jaringan. <br><br><img src="https://habrastorage.org/webt/y1/dz/kh/y1dzkhba60lopgq_nokdcisaols.png"><br><br>  Contoh dekat adalah solusi penyimpanan data (disk lokal, perangkat blok jaringan, Ceph ...).  Awalnya, mereka berada di kernel, tetapi dengan munculnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CSI,</a> situasinya berubah menjadi serupa yang sudah dijelaskan: di Kubernetes, antarmuka, dan implementasinya, dalam modul pihak ketiga. <br><br>  Di antara contoh lain: <br><br><ul><li>  Pengendali masuk <i>(untuk ulasan, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terbaru kami</a> )</i> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>manajer sertifikat</b></a> : <br><br><img src="https://habrastorage.org/webt/jd/be/oc/jdbeocyiociiucegto-own0o6g0.gif"></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Operator</b></a> adalah seluruh kelas dari add-on (yang termasuk manajer sertifikat yang disebutkan), mereka mendefinisikan primitif (s) dan pengontrol (s).  Logika pekerjaan mereka hanya dibatasi oleh imajinasi kita dan memungkinkan kita untuk mengubah komponen infrastruktur siap pakai (misalnya, DBMS) menjadi primitif, yang jauh lebih mudah untuk dikerjakan (daripada dengan satu set wadah dan pengaturannya).  Sejumlah besar operator telah ditulis - meskipun banyak dari mereka belum siap untuk diproduksi, ini hanya masalah waktu: <br><br><img src="https://habrastorage.org/webt/uu/yp/gi/uuypgi9fy-7ot0uho2vh27uq7nq.png"></li><li>  <b>Metrik</b> adalah ilustrasi lain tentang bagaimana Kubernetes memisahkan antarmuka (Metrik API) dari implementasi (add-on pihak ketiga seperti adaptor Prometheus, agen cluster Datadog ...). </li><li>  Untuk <b>pemantauan dan statistik</b> , di mana dalam praktiknya tidak hanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prometheus dan Grafana yang dibutuhkan</a> , tetapi juga metrik-negara-metrik, simpul-eksportir, dll. </li></ul><br>  Dan ini bukan daftar lengkap add-ons ... Misalnya, kami di Flant company saat ini menginstal <b>29 add-ons</b> untuk setiap cluster Kubernetes (semuanya membuat total 249 objek Kubernetes).  Sederhananya, kita tidak melihat kehidupan sebuah cluster tanpa tambahan. <br><br><h2>  Otomasi </h2><br>  Operator dirancang untuk mengotomatiskan operasi rutin yang kita hadapi setiap hari.  Berikut adalah contoh kehidupan yang bagus untuk menulis operator: <br><br><ol><li>  Ada registri pribadi (mis. Yang membutuhkan login) dengan gambar untuk aplikasi.  Diasumsikan bahwa setiap pod terikat dengan rahasia khusus yang memungkinkan otentikasi dalam registri.  Tugas kami adalah memastikan bahwa rahasia ini ditemukan di namespace, sehingga pod dapat mengunduh gambar.  Mungkin ada banyak aplikasi (masing-masing membutuhkan rahasia), dan berguna untuk memperbarui rahasia itu sendiri secara berkala, sehingga opsi untuk membuka rahasia dengan tangan Anda menghilang.  Di sini operator datang untuk menyelamatkan: kami membuat controller yang akan menunggu namespace muncul dan menambahkan rahasia ke namespace untuk acara ini. </li><li>  Misalkan akses default dari pod ke Internet dilarang.  Tetapi kadang-kadang mungkin diperlukan: logis untuk mekanisme izin akses untuk bekerja hanya tanpa memerlukan keterampilan khusus, misalnya, dengan kehadiran label tertentu di namespace.  Bagaimana operator akan membantu kami di sini?  Kontroler dibuat yang mengharapkan label muncul di namespace dan menambahkan kebijakan yang sesuai untuk mengakses Internet. </li><li>  Situasi serupa: mari kita perlu menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">noda</a> tertentu ke simpul jika memiliki label yang sama (dengan semacam awalan).  Tindakan dengan operator jelas ... </li></ol><br>  Di gugus mana pun, perlu untuk menyelesaikan tugas-tugas rutin, dan melakukan ini <b>dengan benar</b> - menggunakan operator. <br><br>  Merangkum semua cerita yang dijelaskan, kami sampai pada kesimpulan bahwa <b>untuk pekerjaan yang nyaman di Kubernetes diperlukan</b> : a) untuk <b>menginstal add-on</b> , b) untuk <b>mengembangkan operator</b> (untuk menyelesaikan tugas admin sehari-hari). <br><br><h2>  Bagaimana cara menulis pernyataan untuk Kubernetes? </h2><br>  Secara umum, skema ini sederhana: <br><br><img src="https://habrastorage.org/webt/qt/jo/7u/qtjo7ujblxe_kbzr05hw0ixow1y.png"><br><br>  ... tetapi ternyata: <br><br><ul><li>  API Kubernetes adalah hal yang agak non-sepele yang membutuhkan banyak waktu untuk dikuasai; </li><li>  pemrograman juga bukan untuk semua orang (Go dipilih sebagai bahasa pilihan karena ada kerangka kerja khusus untuk itu - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Operator SDK</a> ); </li><li>  dengan kerangka kerja seperti itu, situasi serupa. </li></ul><br>  Intinya: <b>untuk menulis controller</b> (operator), Anda harus <b>menghabiskan sumber daya yang signifikan</b> untuk mempelajari materi.  Ini akan dibenarkan untuk operator "besar" - katakanlah, untuk DBMS MySQL.  Tetapi jika kita mengingat contoh-contoh yang dijelaskan di atas (mengungkap rahasia, mengakses pod ke Internet ...), yang juga ingin kita lakukan dengan benar, maka kita akan memahami bahwa upaya yang dilakukan akan lebih besar daripada hasil yang sekarang dibutuhkan: <br><br><img src="https://habrastorage.org/webt/zn/w3/9b/znw39bssazgqnsoe9mrsh8e7o6o.png"><br><br>  Secara umum, dilema muncul: menghabiskan banyak sumber daya dan menemukan alat yang tepat untuk menulis pernyataan atau bertindak "dengan cara lama" (tetapi dengan cepat).  Untuk mengatasinya - untuk menemukan kompromi di antara yang ekstrem ini - kami menciptakan proyek kami sendiri: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>shell-operator</b></a> <i>(lihat juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengumuman terbarunya</a> tentang hub)</i> . <br><br><h2>  Operator shell </h2><br>  Bagaimana cara kerjanya?  Di cluster ada pod di mana Go-binary dengan shell-operator terletak.  Satu set <b>kait</b> disimpan di sebelahnya <i>(untuk lebih jelasnya, lihat di bawah)</i> .  Shell-operator itu sendiri berlangganan <b>acara</b> - <b>acara</b> tertentu di API Kubernetes, di mana ia meluncurkan kait terkait. <br><br>  Bagaimana operator shell memahami kait mana yang harus dipicu dalam kejadian apa?  Informasi ini diteruskan ke operator shell oleh pengait sendiri dan mereka membuatnya sangat sederhana. <br><br>  Hook adalah skrip Bash atau file yang dapat dieksekusi lainnya yang mendukung argumen tunggal <code>--config</code> dan mengembalikan JSON sebagai responsnya.  Yang terakhir menentukan objek mana yang menarik baginya dan peristiwa apa (untuk objek ini) harus bereaksi: <br><br><img src="https://habrastorage.org/webt/6m/7f/ei/6m7feilxyvybractmb6aoxj-olm.png"><br><br>  Saya akan mengilustrasikan implementasi shell-operator dari salah satu contoh kami - mengungkap rahasia untuk mengakses registry pribadi dengan gambar aplikasi.  Ini terdiri dari dua tahap. <br><br><h3>  Latihan: 1. Menulis kail </h3><br>  Langkah pertama dalam hook adalah untuk memproses <code>--config</code> , menunjukkan bahwa kami tertarik pada namespace, dan secara khusus - saat pembuatannya: <br><br><pre> <code class="bash hljs">[[ <span class="hljs-variable"><span class="hljs-variable">$1</span></span> == <span class="hljs-string"><span class="hljs-string">"--config"</span></span> ]] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> cat &lt;&lt; EOF { <span class="hljs-string"><span class="hljs-string">"onKubernetesEvent"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>, <span class="hljs-string"><span class="hljs-string">"event"</span></span>: [<span class="hljs-string"><span class="hljs-string">"add"</span></span>] } ] } EOF …</code> </pre> <br>  Seperti apa logikanya?  Cukup sederhana juga: <br><br><pre> <code class="bash hljs">… <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> createdNamespace=$(jq -r <span class="hljs-string"><span class="hljs-string">'.[0].resourceName'</span></span> <span class="hljs-variable"><span class="hljs-variable">$BINDING_CONTEXT_PATH</span></span>) kubectl create -n <span class="hljs-variable"><span class="hljs-variable">${createdNamespace}</span></span> -f - &lt;&lt; EOF Kind: Secret ... EOF <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Langkah pertama adalah mencari tahu namespace mana yang telah dibuat, dan langkah kedua adalah membuat rahasia untuk namespace ini melalui <code>kubectl</code> . <br><br><h3>  Latihan: 2. Menyusun gambar </h3><br>  Tetap mentransfer kait yang dibuat ke operator shell - bagaimana melakukan ini?  Shell-operator itu sendiri disediakan sebagai gambar Docker, jadi tugas kami adalah menambahkan hook ke direktori khusus pada gambar ini: <br><br><pre> <code class="plaintext hljs">FROM flant/shell-operator:v1.0.0-beta.1 ADD my-handler.sh /hooks</code> </pre> <br>  Tetap mengumpulkan dan mendorongnya: <br><br><pre> <code class="bash hljs">$ docker build -t registry.example.com/my-operator:v1 . $ docker push registry.example.com/my-operator:v1</code> </pre> <br>  Sentuhan terakhir adalah menyematkan gambar dalam sebuah cluster.  Untuk melakukan ini, tulis <i>Penempatan</i> : <br><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Deployment metadata: name: my-operator spec: template: spec: containers: - name: my-operator image: registry.example.com/my-operator:v1 # 1 serviceAccountName: my-operator # 2</code> </pre> <br>  Di dalamnya, Anda perlu memperhatikan dua poin: <br><br><ol><li>  Indikasi gambar yang baru saja dibuat; </li><li>  ini adalah komponen sistem yang (minimal) membutuhkan hak untuk berlangganan acara di Kubernetes dan untuk mengungkapkan rahasia berdasarkan namespace, jadi kami membuat ServiceAccount (dan seperangkat aturan) untuk hook. </li></ol><br>  Hasilnya - kami memecahkan masalah kami dengan cara yang <b>asli di</b> Kubernetes, menciptakan operator untuk mengungkapkan rahasia. <br><br><h3>  Fitur-fitur shell-operator lainnya </h3><br>  Untuk membatasi objek dari jenis pilihan yang akan digunakan oleh kait, <b>Anda dapat memfilternya dengan memfilter</b> menurut label tertentu (atau menggunakan <code>matchExpressions</code> ): <br><br><pre> <code class="plaintext hljs">"onKubernetesEvent": [ { "selector": { "matchLabels": { "foo": "bar", }, "matchExpressions": [ { "key": "allow", "operation": "In", "values": ["wan", "warehouse"], }, ], } … } ]</code> </pre> <br>  Sebuah <b>mekanisme deduplikasi</b> disediakan, yang - menggunakan filter jq - memungkinkan Anda untuk mengkonversi objek JSON besar menjadi objek kecil, di mana hanya parameter-parameter yang tersisa yang ingin kami pantau perubahannya. <br><br>  Ketika hook dipanggil, operator shell meneruskannya <b>data tentang objek</b> , yang dapat digunakan untuk kebutuhan apa pun. <br><br>  Peristiwa di mana kait dipicu tidak terbatas pada peristiwa Kubernetes: operator shell menyediakan dukungan untuk <b>memanggil kait tepat waktu</b> (mirip dengan crontab dalam penjadwal tradisional), serta acara <b>onStartup</b> khusus.  Semua acara ini dapat digabungkan dan ditugaskan ke pengait yang sama. <br><br>  Dan dua fitur lagi dari shell-operator: <br><br><ol><li>  Ini bekerja secara tidak <b>sinkron</b> .  Karena peristiwa Kubernetes (misalnya, pembuatan objek), peristiwa lainnya (misalnya, penghapusan objek yang sama) dapat terjadi di gugus, dan ini harus diperhitungkan dalam kaitan.  Jika kait gagal, maka secara default akan <b>dipanggil lagi</b> sampai berhasil diselesaikan (perilaku ini dapat diubah). </li><li>  Ini mengekspor <b>metrik</b> untuk Prometheus, yang dengannya Anda dapat memahami apakah operator shell berfungsi, mencari tahu jumlah kesalahan untuk setiap kait, dan ukuran antrian saat ini. </li></ol><br>  Untuk meringkas bagian laporan ini: <br><br><img src="https://habrastorage.org/webt/v2/aa/zo/v2aazotslqg8mvbgb4wbkrwz1do.png"><br><br><h2>  Instalasi Pengaya </h2><br>  Untuk kerja yang nyaman dengan Kubernetes, kebutuhan untuk menginstal add-on juga disebutkan.  Saya akan membicarakannya pada contoh cara perusahaan kami dengan cara kami melakukannya sekarang. <br><br>  Kami mulai bekerja dengan Kubernetes dengan beberapa cluster, satu-satunya tambahan adalah Ingress.  Itu perlu untuk meletakkannya di setiap cluster secara berbeda, dan kami membuat beberapa konfigurasi YAML untuk lingkungan yang berbeda: bare metal, AWS ... <br><br>  Ada lebih banyak cluster - lebih banyak konfigurasi.  Selain itu, kami meningkatkan konfigurasi ini sendiri, akibatnya menjadi sangat heterogen: <br><br><img src="https://habrastorage.org/webt/sx/bb/3n/sxbb3ndabtfctyjimx7lzwvg-sk.png"><br><br>  Untuk mengatur semuanya, kami mulai dengan sebuah skrip ( <code>install-ingress.sh</code> ), yang mengambil jenis cluster yang akan digunakan sebagai argumen, menghasilkan konfigurasi YAML yang diinginkan dan meluncurkannya ke Kubernetes. <br><br>  Singkatnya, jalan kita selanjutnya dan argumen yang terkait dengannya adalah sebagai berikut: <br><br><ul><li>  untuk bekerja dengan konfigurasi YAML, mesin template diperlukan (pada tahap pertama ini adalah sed sederhana); </li><li>  dengan peningkatan jumlah cluster, kebutuhan datang untuk pembaruan otomatis (solusi paling awal adalah dengan meletakkan skrip di Git, perbarui dengan cron, dan jalankan); </li><li>  skrip yang sama diperlukan untuk Prometheus ( <code>install-prometheus.sh</code> ), namun perlu dicatat bahwa skrip ini membutuhkan lebih banyak input data, serta penyimpanannya (dengan cara yang baik, terpusat dan dalam cluster), dan beberapa data (kata sandi) dapat secara otomatis dihasilkan : <br><br><img src="https://habrastorage.org/webt/u9/3s/oe/u93soes0m24zohi4oy0ugk2uvcg.png"></li><li>  risiko memasukkan sesuatu yang salah ke semakin banyak kelompok terus meningkat, jadi kami menyadari bahwa para penginstal <i>(mis., dua skrip: untuk Ingress dan Prometheus)</i> memerlukan penyiapan panggung (beberapa cabang di Git, beberapa cron untuk memperbaruinya di yang sesuai: cluster stabil atau uji); </li><li>  menjadi sulit untuk bekerja dengan <code>kubectl apply</code> , karena tidak deklaratif dan hanya dapat membuat objek, tetapi tidak membuat keputusan tentang status mereka / menghapusnya; </li><li>  kekurangan beberapa fungsi yang tidak kita sadari pada saat itu: <br><ul><li>  kontrol penuh atas hasil pembaruan cluster, </li><li>  penentuan beberapa parameter secara otomatis (input untuk skrip instalasi) berdasarkan data yang dapat diperoleh dari kluster (penemuan), </li><li>  pengembangan logis dalam bentuk penemuan berkelanjutan. </li></ul></li></ul><br>  Kami menyadari semua akumulasi pengalaman ini dalam kerangka proyek kami yang lain - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>addon-operator</b></a> . <br><br><h2>  Addon-operator </h2><br>  Ini didasarkan pada operator shell yang telah disebutkan.  Seluruh sistem adalah sebagai berikut: <br><br>  Untuk kait shell-operator ditambahkan: <br><br><ul><li>  <b>penyimpanan nilai</b> </li><li>  <b>Grafik helm</b> </li><li>  komponen yang <b>memantau repositori nilai-nilai</b> dan - jika ada perubahan - meminta Helm untuk memutar kembali bagan. </li></ul><br><img src="https://habrastorage.org/webt/w8/8f/kf/w88fkfrbrukitlgx_u5jzauwtzq.gif"><br><br>  Dengan demikian, kita dapat menanggapi suatu peristiwa di Kubernetes, meluncurkan sebuah hook, dan dari hook ini - buat perubahan pada repositori, setelah itu bagan akan dimuat ulang.  Dalam skema yang dihasilkan, kami memilih satu set kait dan bagan menjadi satu komponen, yang kami sebut <b>modul</b> : <br><br><img src="https://habrastorage.org/webt/b9/3j/qj/b93jqjumemaiju4cwcji2qnmaqw.png"><br><br>  Mungkin ada banyak modul, dan untuk itu kami menambahkan kait global, penyimpanan nilai global, dan komponen yang memantau penyimpanan global ini. <br><br>  Sekarang sesuatu sedang terjadi di Kubernetes, kita dapat menanggapi ini dengan hook global dan mengubah sesuatu di repositori global.  Perubahan ini akan diperhatikan dan akan menyebabkan rollback semua modul di kluster: <br><br><img src="https://habrastorage.org/webt/ad/hh/e-/adhhe-ml3wrrqjks5dniduqxecg.gif"><br><br>  Skema ini memenuhi semua persyaratan untuk menginstal add-on yang diumumkan di atas: <br><br><ul><li>  Helm bertanggung jawab atas standardisasi dan deklaratifitas. </li><li>  Masalah pembaruan-otomatis diselesaikan menggunakan hook global, yang masuk ke registri pada jadwal dan, jika melihat gambar baru dari sistem di sana, putar ulang itu (yaitu, "itu sendiri"). </li><li>  Penyimpanan pengaturan di cluster diimplementasikan menggunakan <i>ConfigMap</i> , di mana data primer untuk penyimpanan dicatat (saat startup mereka dimuat ke penyimpanan). </li><li>  Masalah pembuatan kata sandi, penemuan dan penemuan berkelanjutan diselesaikan dengan menggunakan kait. </li><li>  Pementasan dicapai berkat tag yang didukung Docker di luar kotak. </li><li>  Hasilnya dipantau menggunakan metrik yang dengannya kami dapat memahami statusnya. </li></ul><br>  Seluruh sistem ini diimplementasikan sebagai biner tunggal di Go, yang disebut addon-operator.  Berkat ini, skema ini terlihat lebih sederhana: <br><br><img src="https://habrastorage.org/webt/ip/2n/cf/ip2ncf-unok3h5azr8-icyby3hs.png"><br><br>  Komponen utama dalam diagram ini adalah satu set modul <i>(berwarna abu-abu di bawah)</i> .  Sekarang kita dapat menulis modul dengan sedikit usaha untuk add-on yang diinginkan dan memastikan bahwa itu akan dipasang di setiap cluster, akan diperbarui dan menanggapi peristiwa yang dibutuhkan dalam cluster. <br><br>  Flant menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">addon-operator</a> di 70+ Kubernetes-cluster.  Status saat ini adalah <b>versi alfa</b> .  Sekarang kami sedang mempersiapkan dokumentasi untuk merilis beta, tetapi untuk saat ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, contoh tersedia</a> di repositori, berdasarkan di mana Anda dapat membuat addon Anda. <br><br>  Di mana mendapatkan modul addon-operator sendiri?  Penerbitan perpustakaan kami adalah tahap berikutnya bagi kami, kami berencana untuk melakukannya di musim panas. <br><br><h2>  Video dan slide </h2><br>  Video dari kinerja (~ 50 menit): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6VHk1R1TNgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Penyajian laporan: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  PS </h2><br>  Laporan lain di blog kami: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Database dan Kubernetes</a> ";  <i>(Dmitry Stolyarov; 8 November 2018 di HighLoad ++)</i> ; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monitoring and Kubernetes</a> ”;  <i>(Dmitry Stolyarov; 28 Mei 2018 di RootConf)</i> ; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktik CI / CD Terbaik dengan Kubernetes dan GitLab</a> ”;  <i>(Dmitry Stolyarov; 7 November 2017 di HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengalaman kami dengan Kubernetes dalam proyek-proyek kecil</a> ";  <i>(Dmitry Stolyarov; 6 Juni 2017 di RootConf)</i> . </li></ul><br>  Anda mungkin juga tertarik dengan publikasi berikut: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apakah mudah dan nyaman menyiapkan cluster Kubernetes?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Umumkan operator tambahan</a> ”; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memperkenalkan operator-shell: membuat operator untuk Kubernet lebih mudah</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449096/">https://habr.com/ru/post/id449096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449086/index.html">Di dalam nyala api: metode baru untuk menyelidiki sistem reaktif suhu tinggi</a></li>
<li><a href="../id449088/index.html">Sudah saatnya bagi investor dan pengusaha untuk mulai memecahkan masalah kesehatan mental di startup.</a></li>
<li><a href="../id449090/index.html">Ubah skema JSON secara dinamis di Go with gob</a></li>
<li><a href="../id449092/index.html">Tiga paradigma pemrograman asinkron di Vertx</a></li>
<li><a href="../id449094/index.html">Psikologi Startup: Transformasi Yang Tidak Semua Orang Akan Hidup</a></li>
<li><a href="../id449098/index.html">Bagaimana perusahaan spyware masuk ke toko sertifikat Mozilla dan apa yang terjadi</a></li>
<li><a href="../id449100/index.html">Setelah RTM. Investigasi forensik komputer yang terinfeksi trojan perbankan</a></li>
<li><a href="../id449106/index.html">UPS untuk lembaga perbankan dan keuangan</a></li>
<li><a href="../id449108/index.html">UDB. Apa ini Bagian 7. Pengaturan waktu dan reset modul kontrol</a></li>
<li><a href="../id449110/index.html">Memperbaiki bug yang terkait dengan ketidakmampuan untuk menggunakan alfabet Cyrillic dalam nama folder IMAP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>