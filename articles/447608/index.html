<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèΩ üôÄ üë®üèæ‚Äçüç≥ Evoluci√≥n de CI en el equipo de desarrollo m√≥vil üëã üöä üë©üèº‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy, la mayor√≠a de los productos de software se desarrollan en equipos. Las condiciones de √©xito para el desarrollo del equipo se pueden presentar en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Evoluci√≥n de CI en el equipo de desarrollo m√≥vil</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/447608/">  Hoy, la mayor√≠a de los productos de software se desarrollan en equipos.  Las condiciones de √©xito para el desarrollo del equipo se pueden presentar en forma de un esquema simple. <br><br><img src="https://habrastorage.org/webt/wd/yv/we/wdyvwe6jcuq9yygmffhk5-eqnlo.png"><br><br>  Despu√©s de escribir el c√≥digo, debe asegurarse de que: <br><br><ol><li>  Funciona </li><li>  No rompe nada, incluido el c√≥digo que escribieron sus colegas. </li></ol><br>  Si se cumplen ambas condiciones, entonces est√°s en el camino hacia el √©xito.  Para verificar f√°cilmente estas condiciones y no desactivar una ruta rentable, se les ocurri√≥ la integraci√≥n continua. <br><br>  CI es un flujo de trabajo en el que integra su c√≥digo en el c√≥digo general del producto con la mayor frecuencia posible.  Y no solo integrar, sino tambi√©n comprobar constantemente que todo funciona.  Como necesita verificar mucho y con frecuencia, debe pensar en la automatizaci√≥n.  Puede verificar todo en tracci√≥n manual, pero no vale la pena, y es por eso. <br><a name="habracut"></a><br><ul><li>  <strong>La gente es cara</strong> .  Una hora de trabajo de cualquier programador es m√°s costosa que una hora de trabajo de cualquier servidor. </li><li>  <strong>La gente est√° equivocada</strong> .  Por lo tanto, pueden surgir situaciones cuando realizaron pruebas en la rama incorrecta o recopilaron la confirmaci√≥n incorrecta para los evaluadores. </li><li>  <strong>La gente es perezosa</strong> .  Peri√≥dicamente, cuando termino una tarea, tengo el pensamiento: ‚Äú¬øPero qu√© hay para verificar?  Escrib√≠ dos l√≠neas: ¬°stopudovo, todo funciona!  Creo que para algunos de ustedes, tales pensamientos a veces vienen a la mente.  Pero siempre debes comprobarlo. </li></ul><br>  C√≥mo se introdujo y desarroll√≥ Continuous Integration en el equipo de desarrollo m√≥vil de Avito, c√≥mo alcanzaron de 0 a 450 ensamblajes por d√≠a, y que las m√°quinas de construcci√≥n recolectan 200 horas al d√≠a, dice Nikolay Nesterov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">nnesterov</a> ), participante en todos los cambios evolutivos de la aplicaci√≥n de Android CI / CD . <br><br>  La historia se basa en el ejemplo del equipo de Android, pero la mayor√≠a de los enfoques se aplican tambi√©n en iOS. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lz8MNATTUCU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  √ârase una vez, una persona trabaj√≥ en el equipo de Avito Android.  Por definici√≥n, no necesitaba nada de la integraci√≥n continua: no hab√≠a nadie con quien integrarse. <br><br>  Pero la aplicaci√≥n creci√≥, aparecieron m√°s y m√°s tareas nuevas, respectivamente, el equipo creci√≥.  En alg√∫n momento, lleg√≥ el momento de establecer m√°s formalmente el proceso de integraci√≥n del c√≥digo.  Se decidi√≥ usar Git flow. <br><br><img src="https://habrastorage.org/webt/rv/qa/jd/rvqajd0kgcao3w0-vw6lnomjpc8.png"><br><br>  El concepto de flujo de Git es conocido: hay una rama de desarrollo com√∫n en el proyecto, y para cada nueva caracter√≠stica, los desarrolladores cortan una rama separada, la confirman, la env√≠an, y cuando quieren inyectar su c√≥digo en la rama de desarrollo, abren la solicitud de extracci√≥n.  Para compartir conocimiento y discutir enfoques, introdujimos una revisi√≥n de c√≥digo, es decir, los colegas deben verificar y confirmar el c√≥digo del otro. <br><br><h2>  Cheques </h2><br>  Ver el c√≥digo con los ojos es genial, pero no lo suficiente.  Por lo tanto, se introducen las verificaciones autom√°ticas. <br><br><ul><li>  En primer lugar, verificamos el <strong>ensamblaje del ARC</strong> . </li><li>  Muchas <strong>pruebas</strong> de <strong>Junit</strong> . </li><li>  <strong>Consideramos la cobertura del c√≥digo</strong> , ya que ejecutamos las pruebas. </li></ul><br>  Para comprender c√≥mo deben ejecutarse estas comprobaciones, veamos el proceso de desarrollo en Avito. <br><br>  Esquem√°ticamente, se puede representar de la siguiente manera: <br><br><ul><li>  El desarrollador escribe el c√≥digo en su computadora port√°til.  Puede ejecutar comprobaciones de integraci√≥n aqu√≠, ya sea con un enlace de confirmaci√≥n o simplemente ejecutar comprobaciones en segundo plano. </li><li>  Despu√©s de que el desarrollador haya ejecutado el c√≥digo, abre la solicitud de extracci√≥n.  Para que su c√≥digo entre en la rama de desarrollo, debe pasar por una revisi√≥n de c√≥digo y recopilar el n√∫mero requerido de confirmaciones.  Puede habilitar comprobaciones y compilaciones aqu√≠: hasta que todas las compilaciones sean exitosas, la solicitud de extracci√≥n no se puede fusionar. </li><li>  Despu√©s de fusionar la solicitud de extracci√≥n y de desarrollar el c√≥digo, puede elegir un momento conveniente: por ejemplo, por la noche, cuando todos los servidores est√°n libres, y realice las comprobaciones que desee. </li></ul><br>  A nadie le gustaba hacer pruebas en su computadora port√°til.  Cuando el desarrollador ha finalizado la funci√≥n, quiere iniciarla r√°pidamente y abrir la solicitud de extracci√≥n.  Si en ese momento se inician algunas comprobaciones largas, esto no solo no es muy agradable, sino que tambi√©n ralentiza el desarrollo: mientras el port√°til est√° comprobando algo, es imposible trabajar normalmente en √©l. <br><br>  Realmente nos gust√≥ hacer cheques por la noche, porque hay mucho tiempo y servidores, puedes dar un paseo.  Pero, desafortunadamente, cuando se desarroll√≥ el c√≥digo de caracter√≠stica, el desarrollador ya tiene mucha menos motivaci√≥n para reparar los errores que encontr√≥ CI.  Peri√≥dicamente me sorprend√≠a pensando cuando miraba en el informe de la ma√±ana sobre todos los errores y descubr√≠ que los solucionar√≠a alg√∫n tiempo despu√©s, porque ahora en Jira se encuentra una nueva y genial tarea que solo quiero comenzar a hacer. <br><br>  Si los controles bloquean la solicitud de extracci√≥n, entonces hay suficiente motivaci√≥n, porque hasta que las compilaciones se vuelvan verdes, el c√≥digo no se desarrollar√°, lo que significa que la tarea no se completar√°. <br><br>  Como resultado, elegimos esta estrategia: en la noche manejamos el m√°ximo conjunto de controles posible, y el m√°s cr√≠tico de ellos y, lo m√°s importante, r√°pido, ejecutamos una solicitud de extracci√≥n.  Pero no nos detenemos all√≠: en paralelo, optimizamos la velocidad de pasar cheques de tal manera que los transfiera del modo nocturno a los cheques por solicitud de extracci√≥n. <br><br>  En ese momento, todos nuestros ensamblajes fueron lo suficientemente r√°pidos, por lo que solo incluimos el ensamblaje ARC, las pruebas Junit y el c√°lculo de la cobertura del c√≥digo con el bloqueador de solicitud de extracci√≥n.  Lo encendieron, lo pensaron y abandonaron la cobertura del c√≥digo porque pensaron que no lo necesit√°bamos. <br><br>  <strong><em>Nos llev√≥ dos d√≠as completar la configuraci√≥n b√°sica de CI (en adelante, una estimaci√≥n temporal es aproximada, necesaria para la escala).</em></strong> <br><br>  Despu√©s de eso, comenzaron a pensar m√°s: ¬ølo estamos verificando correctamente?  ¬øEstamos lanzando compilaciones en la solicitud de extracci√≥n correctamente? <br><br>  Comenzamos la compilaci√≥n en el √∫ltimo commit de la rama con la que est√° abierta la solicitud de extracci√≥n.  Pero las comprobaciones de esta confirmaci√≥n solo pueden mostrar que el c√≥digo que el desarrollador escribi√≥ funciona.  Pero no prueban que no haya roto nada.  De hecho, debe verificar el estado de la rama de desarrollo despu√©s de que la caracter√≠stica se haya inyectado en ella. <br><br><img src="https://habrastorage.org/webt/g7/sw/gn/g7swgnopkxqajjm-73mz9oxwbng.png"><br><br>  Para hacer esto, escribimos un script bash simple <strong>premerge.sh:</strong> <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash set -e git fetch origin develop git merge origin/develop</span></span></code> </pre> <br>  Aqu√≠, todos los √∫ltimos cambios desde el desarrollo simplemente se extraen y se fusionan en la rama actual.  Agregamos el script premerge.sh como el primer paso de todas las compilaciones y comenzamos a verificar exactamente lo que queremos, es decir, la <strong>integraci√≥n</strong> . <br><br>  <strong><em>Le llev√≥ tres d√≠as localizar el problema, encontrar una soluci√≥n y escribir este script.</em></strong> <br><br>  La aplicaci√≥n se desarroll√≥, aparecieron m√°s y m√°s tareas, el equipo creci√≥ y premerge.sh a veces comenz√≥ a decepcionarnos.  En el desarrollo penetraron cambios conflictivos que rompieron la asamblea. <br><br>  Un ejemplo de c√≥mo sucede esto: <br><br><img src="https://habrastorage.org/webt/xc/dm/e-/xcdme-bg7rwxkmgip5pgh4hlc8u.png"><br><br>  Dos desarrolladores al mismo tiempo comienzan a cortar las funciones A y B. El desarrollador de la funci√≥n A descubre la funci√≥n <code>answer()</code> no utilizada en el proyecto y, como un buen explorador, la elimina.  Al mismo tiempo, el desarrollador de la funci√≥n B agrega una nueva llamada a esta funci√≥n en su sucursal. <br><br>  Los desarrolladores terminan el trabajo y al mismo tiempo abren la solicitud de extracci√≥n.  Inicio de compilaciones, premerge.sh comprueba tanto la solicitud de extracci√≥n para un nuevo estado de desarrollo: todas las comprobaciones son verdes  Despu√©s de que las caracter√≠sticas de solicitud de extracci√≥n A se fusionen, las caracter√≠sticas de solicitud de extracci√≥n B se fusionan ... ¬°Auge!  Desarrolle pausas porque en el c√≥digo de desarrollo hay una llamada a una funci√≥n inexistente. <br><br><img src="https://habrastorage.org/webt/zk/im/_r/zkim_rji20ahq4fyztlnc-twxwi.png"><br><br>  Cuando no se va a desarrollar, este es un <strong>desastre local</strong> .  Todo el equipo no puede recolectar y dar nada para probar. <br><br>  Dio la casualidad de que participaba con mayor frecuencia en tareas de infraestructura: an√°lisis, red, bases de datos.  Es decir, escrib√≠ las funciones y clases que usan otros desarrolladores.  Debido a esto, muy a menudo me met√≠ en tales situaciones.  Incluso tuve una foto as√≠ a la vez. <br><br><img src="https://habrastorage.org/webt/xo/vj/6e/xovj6ea0xjjvuoxfgnrrhbskxta.jpeg"><br><br>  Como esto no nos conven√≠a, comenzamos a encontrar opciones sobre c√≥mo prevenir esto. <br><br><h2>  C√≥mo no romper desarrollarse </h2><br>  Primera opci√≥n: <strong>reconstruir todas las solicitudes de extracci√≥n cuando se desarrolle la actualizaci√≥n.</strong>  Si en nuestro ejemplo, una solicitud de extracci√≥n con la funci√≥n A se desarrolla por primera vez, la solicitud de extracci√≥n de la funci√≥n B se reconstruir√° y, en consecuencia, las comprobaciones fallar√°n debido a un error de compilaci√≥n. <br><br>  Para comprender cu√°nto tiempo llevar√°, considere un ejemplo con dos RP.  Abrimos dos relaciones p√∫blicas: dos compilaciones, dos lanzamientos de prueba.  Despu√©s de que el primer PR se vierta en desarrollo, el segundo debe ser reconstruido.  En total, dos lanzamientos PR de cheques requieren tres RP: 2 + 1 = 3. <br><br>  En principio, es normal.  Pero observamos las estad√≠sticas, y una situaci√≥n t√≠pica en nuestro equipo fue de 10 RP abiertos, y luego el n√∫mero de controles es la suma de la progresi√≥n: 10 + 9 + ... + 1 = 55. Es decir, para aceptar 10 RP, debes reconstruir 55 veces.  Y esto se encuentra en una situaci√≥n ideal, cuando todos los cheques pasan la primera vez, cuando nadie abre una solicitud de extracci√≥n adicional mientras se procesan estos diez. <br><br>  Imag√≠nese un desarrollador que necesita tiempo para presionar primero el bot√≥n "fusionar", porque si esto lo hace un vecino, tendr√° que esperar hasta que todos los ensambles vuelvan a pasar ... No, eso no funcionar√°, ralentizar√° seriamente el desarrollo. <br><br>  La segunda forma posible: <strong>recopilar la solicitud de extracci√≥n despu√©s de la revisi√≥n del c√≥digo.</strong>  Es decir, abra la solicitud de extracci√≥n, recopile la cantidad necesaria de actualizaciones de colegas, arregle lo que necesita y luego ejecute las compilaciones.  Si tienen √©xito, la solicitud de extracci√≥n se fusiona con el desarrollo.  En este caso, no hay reinicios adicionales, pero los comentarios se ralentizan mucho.  Como desarrollador, cuando abro una solicitud de extracci√≥n, inmediatamente quiero ver si lo har√°.  Por ejemplo, si una prueba falla, debe corregirla r√°pidamente.  En el caso de una construcci√≥n retrasada, la retroalimentaci√≥n se ralentiza, lo que significa todo el desarrollo.  Esto tampoco nos conven√≠a. <br><br>  Como resultado, solo quedaba la tercera opci√≥n: hacer un <strong>ciclo</strong> .  Todo nuestro c√≥digo, todas nuestras fuentes se almacenan en el repositorio en el servidor Bitbucket.  En consecuencia, tuvimos que desarrollar un complemento para Bitbucket. <br><br><img src="https://habrastorage.org/webt/kf/ye/yx/kfyeyxalmkommukvjics9uvinn4.png"><br><br>  Este complemento anula el mecanismo de combinaci√≥n de solicitud de extracci√≥n.  El comienzo es est√°ndar: PR abre, todos los ensamblajes comienzan, la revisi√≥n de c√≥digo pasa.  Pero despu√©s de que la revisi√≥n del c√≥digo ha pasado, y el desarrollador decide hacer clic en "fusionar", el complemento verifica en qu√© estado se ejecutaron las comprobaciones de desarrollo.  Si, despu√©s de las compilaciones, el desarrollo logr√≥ actualizarse, el complemento no le permitir√° fusionar dicha solicitud de extracci√≥n en la rama principal.  Simplemente reiniciar√° las compilaciones en relaci√≥n con el nuevo desarrollo. <br><br><img src="https://habrastorage.org/webt/_v/_s/0z/_v_s0zaf1bjvxn8oiwekagtj37a.png"><br><br>  En nuestro ejemplo con cambios conflictivos, tales compilaciones fallar√°n debido a un error de compilaci√≥n.  En consecuencia, el desarrollador de la funci√≥n B tendr√° que corregir el c√≥digo, reiniciar las comprobaciones, luego el complemento aplicar√° autom√°ticamente la solicitud de extracci√≥n. <br><br>  Antes de implementar este complemento, ten√≠amos un promedio de 2.7 ejecuciones de prueba por solicitud de extracci√≥n.  Con el complemento hubo 3.6 lanzamientos.  Nos convino. <br><br>  Vale la pena se√±alar que este complemento tiene un inconveniente: reinicia la compilaci√≥n solo una vez.  Es decir, de todos modos, queda una peque√±a ventana a trav√©s de la cual se pueden desarrollar cambios conflictivos.  Pero la probabilidad de esto no es alta, e hicimos este compromiso entre el n√∫mero de arranques y la probabilidad de falla.  Durante dos a√±os, se dispar√≥ solo una vez, por lo tanto, probablemente no en vano. <br><br>  <strong><em>Nos llev√≥ dos semanas escribir la primera versi√≥n del complemento para Bitbucket.</em></strong> <br><br><h3>  Nuevos cheques </h3><br>  Mientras tanto, nuestro equipo continu√≥ creciendo.  Se agregaron nuevos controles. <br><br>  Pensamos: ¬øpor qu√© reparar errores si pueden evitarse?  Y entonces introdujeron <strong>el an√°lisis de c√≥digo est√°tico</strong> .  Comenzamos con lint, que est√° incluido en el SDK de Android.  Pero en ese momento no sab√≠a c√≥mo trabajar con el c√≥digo de Kotlin, y ya tenemos el 75% de la aplicaci√≥n escrita en Kotlin.  Por lo tanto, los <strong>controles</strong> integrados de <strong>Android Studio</strong> se agregaron a lint <strong>.</strong> <br><br>  Para hacer esto, tuve que ser muy pervertido: tomar Android Studio, empacarlo en Docker y ejecutarlo en CI con un monitor virtual para que creyera que se estaba ejecutando en una computadora port√°til real.  Pero funcion√≥. <br><br>  Tambi√©n en este momento, comenzamos a escribir muchas <strong>pruebas</strong> de <strong>instrumentaci√≥n</strong> e implementamos <strong>pruebas de captura de pantalla</strong> .  Esto es cuando se genera una captura de pantalla de referencia para una vista peque√±a separada, y la prueba es que se toma una captura de pantalla de la vista y se compara directamente con la referencia p√≠xel por p√≠xel.  Si hay una discrepancia, significa que un dise√±o se ha ido a alg√∫n lado o que algo est√° mal en los estilos. <br><br>  Pero las pruebas de instrumentaci√≥n y las pruebas de captura de pantalla deben ejecutarse en dispositivos: en emuladores o en dispositivos reales.  Dado que hay muchas pruebas y que a menudo persiguen, necesita una granja completa.  Iniciar su propia granja es demasiado laborioso, por lo que encontramos una opci√≥n ya preparada: Firebase Test Lab. <br><br><h3>  Laboratorio de pruebas de Firebase </h3><br>  Fue elegido porque Firebase es un producto de Google, es decir, debe ser confiable y es poco probable que muera.  Los precios son asequibles: $ 5 por hora para un dispositivo real, $ 1 por hora para un emulador. <br><br>  <strong><em>La implementaci√≥n del Firebase Test Lab en nuestro CI tard√≥ aproximadamente tres semanas.</em></strong> <br><br>  Pero el equipo continu√≥ creciendo y Firebase, desafortunadamente, comenz√≥ a decepcionarnos.  En ese momento, no ten√≠a SLA.  A veces, Firebase nos hizo esperar hasta que la cantidad requerida de dispositivos para las pruebas quedara libre y no comenzara a ejecutarlos de inmediato, como quer√≠amos.  Esperar en l√≠nea tom√≥ hasta media hora, y esto es mucho tiempo.  Las pruebas de instrumentaci√≥n se ejecutaron en cada RP, los retrasos ralentizaron mucho el desarrollo, y luego lleg√≥ una factura mensual con una suma redonda.  En general, se decidi√≥ abandonar Firebase y se vio internamente, ya que el equipo ha crecido lo suficiente. <br><br><h3>  Docker + python + bash </h3><br>  Tomamos docker, introdujimos emuladores, escribimos un programa simple de Python que en el momento adecuado aumenta la cantidad correcta de emuladores en la versi√≥n correcta y los detiene cuando es necesario.  Y, por supuesto, un par de scripts de bash, ¬ød√≥nde sin ellos? <br><br>  <strong><em>Nos llev√≥ cinco semanas crear nuestro propio entorno de prueba.</em></strong> <br><br>  Como resultado, cada solicitud de extracci√≥n ten√≠a una extensa lista de comprobaciones de combinaci√≥n de bloqueo: <br><br><ul><li>  Asamblea del ARC; </li><li>  Pruebas Junit </li><li>  Pelusa </li><li>  Comprobaciones de Android Studio; </li><li>  Pruebas de instrumentaci√≥n; </li><li>  Pruebas de captura de pantalla. </li></ul><br>  Esto evit√≥ muchas posibles aver√≠as.  T√©cnicamente, todo funcion√≥, pero los desarrolladores se quejaron de que la espera de los resultados fue demasiado larga. <br><br>  ¬øCu√°nto tiempo es demasiado?  Subimos los datos de Bitbucket y TeamCity al sistema de an√°lisis y nos dimos cuenta de que el <strong>tiempo de espera promedio es de 45 minutos</strong> .  Es decir, un desarrollador, al abrir una solicitud de extracci√≥n, en promedio espera resultados de compilaci√≥n de 45 minutos.  En mi opini√≥n, esto es mucho, y no puedes trabajar as√≠. <br><br>  Por supuesto, decidimos acelerar todas nuestras compilaciones. <br><br><h2>  Acelerar </h2><br>  Al ver que a menudo las construcciones est√°n en l√≠nea, lo primero que <strong>compramos es hierro</strong> : el desarrollo extensivo es el m√°s simple.  Las construcciones dejaron de hacer cola, pero el tiempo de espera disminuy√≥ solo un poco, porque algunos controles por s√≠ mismos estuvieron persigui√©ndolos durante mucho tiempo. <br><br><h3>  Eliminamos cheques demasiado largos </h3><br>  Nuestra integraci√≥n continua podr√≠a detectar este tipo de errores y problemas. <br><br><ul><li>  <strong>No voy a hacerlo</strong>  CI puede detectar un error de compilaci√≥n cuando, debido a cambios conflictivos, algo no va a suceder.  Como dije, entonces nadie puede recolectar nada, el desarrollo aumenta y todos se ponen nerviosos. </li><li>  <strong>Un error en el comportamiento</strong> .  Por ejemplo, cuando se crea la aplicaci√≥n, pero cuando hace clic en el bot√≥n se bloquea o el bot√≥n no se presiona en absoluto.  Esto es malo porque dicho error puede llegar al usuario. </li><li>  <strong>Error en el dise√±o</strong> .  Por ejemplo, se presiona un bot√≥n, pero se mueve 10 p√≠xeles hacia la izquierda. </li><li>  <strong>Aumento de la deuda t√©cnica</strong> . </li></ul><br>  Al mirar esta lista, nos dimos cuenta de que solo los dos primeros puntos son cr√≠ticos.  Queremos atrapar tales problemas en primer lugar.  Los errores en el dise√±o se detectan en la etapa de revisi√≥n del dise√±o y luego se solucionan f√°cilmente.  Trabajar con deuda t√©cnica requiere un proceso y una planificaci√≥n por separado, por lo que decidimos no verificarlo para la solicitud de extracci√≥n. <br><br>  Con base en esta clasificaci√≥n, sacudimos la lista completa de controles.  <strong>Tach√≥ Lint</strong> y pospuso su lanzamiento para la noche: solo para que d√© un informe de cu√°ntos problemas hay en el proyecto.  Acordamos trabajar por separado con la deuda t√©cnica, pero <strong>rechazamos completamente los cheques de Android Studio</strong> .  El estudio de Android de Docker para iniciar inspecciones parece interesante, pero trae muchos problemas de soporte.  Cualquier actualizaci√≥n de las versiones de Android Studio es una lucha contra errores oscuros.  Tambi√©n fue dif√≠cil mantener las pruebas de captura de pantalla, porque la biblioteca no funcionaba de manera muy estable, hab√≠a falsos positivos.  <strong>Las pruebas de captura de pantalla se eliminaron de la lista de verificaciones</strong> . <br><br>  Como resultado, nos queda: <br><br><ul><li>  Asamblea del ARC; </li><li>  Pruebas Junit </li><li>  Pruebas de instrumentaci√≥n. </li></ul><br><br><h3>  Gradle cach√© remoto </h3><br>  Sin controles pesados, las cosas mejoraron.  ¬°Pero no hay l√≠mite para la perfecci√≥n! <br><br>  Nuestra aplicaci√≥n ya se ha dividido en aproximadamente 150 m√≥dulos de gradle.  Por lo general, en este caso, el cach√© remoto de Gradle funciona bien y decidimos probarlo. <br><br>  Gradle remote cache es un servicio que puede almacenar en cach√© artefactos de construcci√≥n para tareas individuales en m√≥dulos separados.  Gradle, en lugar de compilar el c√≥digo, derriba el cach√© remoto a trav√©s de HTTP y pregunta si alguien ya ha realizado esta tarea.  Si es as√≠, simplemente descargue el resultado. <br><br>  <strong><em>Iniciar Gradle Remote Cache es f√°cil porque Gradle proporciona una imagen Docker.</em></strong>  <strong><em>Logramos hacer esto en tres horas.</em></strong> <br><br>  Todo lo que se necesitaba era iniciar Docker y registrar una l√≠nea en el proyecto.  Pero aunque puede iniciarlo r√°pidamente para que todo funcione bien, tomar√° mucho tiempo. <br><br>  A continuaci√≥n se muestra un gr√°fico de errores de cach√©. <br><br><img src="https://habrastorage.org/webt/je/0j/an/je0jansmt1nkhgiqhwybnmc2_fs.png"><br><br>  Al principio, el porcentaje de fallas m√°s all√° del cach√© era de aproximadamente 65. Tres semanas despu√©s, logramos llevar este valor al 20%.  Result√≥ que las tareas que recopila la aplicaci√≥n de Android tienen dependencias transitivas extra√±as, por lo que Gradle perdi√≥ el cach√©. <br><br>  Al conectar el cach√©, aceleramos enormemente el ensamblaje.  Pero aparte del ensamblaje, las pruebas de instrumentaci√≥n a√∫n persiguen y persiguen durante mucho tiempo.  Quiz√°s no todas las pruebas necesitan ser perseguidas para cada solicitud de extracci√≥n.  Para averiguarlo, utilizamos el an√°lisis de impacto. <br><br><h3>  An√°lisis de impacto </h3><br>  En la solicitud de extracci√≥n, creamos git diff y encontramos los m√≥dulos Gradle modificados. <br><br><img src="https://habrastorage.org/webt/yg/xn/ki/ygxnkisjdskb-qkqxoccaywcu5a.png"><br><br>  Tiene sentido ejecutar solo las pruebas de instrumentaci√≥n que prueban los m√≥dulos modificados y todos los m√≥dulos que dependen de ellos.  No tiene sentido ejecutar pruebas para m√≥dulos vecinos: el c√≥digo no ha cambiado all√≠ y nada puede romperse. <br><br>  Las pruebas de instrumentaci√≥n no son tan simples, ya que deben ubicarse en el m√≥dulo de Aplicaci√≥n de nivel superior.  Aplicamos una heur√≠stica de an√°lisis de c√≥digo de bytes para comprender a qu√© m√≥dulo pertenece cada prueba. <br><br>  <strong><em>Tom√≥ alrededor de ocho semanas actualizar las pruebas de instrumentaci√≥n para probar solo los m√≥dulos involucrados.</em></strong> <br><br>  Las medidas de aceleraci√≥n de verificaci√≥n han funcionado con √©xito.  A partir de los 45 minutos llegamos a aproximadamente 15. Un cuarto de hora para esperar la construcci√≥n ya es normal. <br><br>  Pero ahora los desarrolladores han comenzado a quejarse de que no les queda claro qu√© compilaciones se est√°n lanzando, d√≥nde se ver√° el registro, por qu√© la compilaci√≥n es roja, qu√© prueba cay√≥, etc. <br><br><img height="487" src="https://habrastorage.org/webt/ez/ev/wl/ezevwlalp50tf9bcret2aff7fte.png"><br><br>  Los problemas de retroalimentaci√≥n retrasan el desarrollo, por lo que intentamos proporcionar la informaci√≥n m√°s comprensible y detallada sobre cada RP y compilaci√≥n.  Comenzamos con comentarios en Bitbucket para relaciones p√∫blicas, indicando qu√© versi√≥n cay√≥ y por qu√©, escribimos mensajes espec√≠ficos en Slack.  Al final, crearon un panel para la p√°gina de relaciones p√∫blicas con una lista de todas las compilaciones que se est√°n ejecutando actualmente y su estado: en l√≠nea, comienza, se bloquea o termina.  Puede hacer clic en la compilaci√≥n y acceder a su registro. <br><br><img src="https://habrastorage.org/webt/d5/hu/fr/d5hufrypmfupj3g8k4snhrksy9w.png"><br><br>  <strong><em>Se pasaron seis semanas en comentarios detallados.</em></strong> <br><br><h2>  Planes </h2><br>  Pasamos a la √∫ltima historia.  Una vez resuelta la cuesti√≥n de los comentarios, pasamos a un nuevo nivel: decidimos construir nuestra propia granja de emuladores.  Cuando hay muchas pruebas y emuladores, son dif√≠ciles de administrar.  Como resultado, todos nuestros emuladores se trasladaron a un cl√∫ster k8s con administraci√≥n de recursos flexible. <br><br>  Adem√°s, hay otros planes. <br><br><ul><li>  <strong>Devolver pelusa</strong> (y otros an√°lisis est√°ticos).  Ya estamos trabajando en esta direcci√≥n. </li><li>  Ejecute todas las <strong>pruebas de extremo a extremo</strong> en el bloqueador de PR en todas las versiones del SDK. </li></ul><br>  Entonces, rastreamos la historia del desarrollo de la Integraci√≥n Continua en Avito.  Ahora quiero dar algunos consejos desde el punto de vista de los experimentados. <br><br><h1>  Consejos </h1><br>  Si pudiera dar solo un consejo, este ser√≠a este: <br><br><blockquote>  ¬°Tenga cuidado con los scripts de shell! </blockquote><br>  Bash es una herramienta muy flexible y poderosa, es muy conveniente y r√°pido escribir scripts en ella.  Pero con √©l puedes caer en la trampa, y nosotros, desafortunadamente, ca√≠mos en ella. <br><br>  Todo comenz√≥ con scripts simples que se ejecutaban en nuestras m√°quinas de compilaci√≥n: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash ./gradlew assembleDebug</span></span></code> </pre> <br>  Pero, como saben, todo se desarrolla y se complica con el tiempo: ejecutemos un script a partir de otro, pasemos algunos par√°metros all√≠, al final tuve que escribir una funci√≥n que determine en qu√© nivel de anidaci√≥n bash estamos ahora, para sustituir las citas necesarias, para que todo comience. <br><br><img src="https://habrastorage.org/webt/rt/o6/vp/rto6vp4hs-ucbefd_3pbzehvx0a.png"><br><br>  Puedes imaginar el trabajo involucrado en el desarrollo de tales guiones.  Te aconsejo que no caigas en esta trampa. <br><br>  ¬øQu√© se puede reemplazar? <br><br><ul><li>  Cualquier lenguaje de script.  Escribir en <strong>Python o Kotlin Script es</strong> m√°s conveniente porque es programaci√≥n, no scripts. </li><li>  O describa toda la l√≥gica de compilaci√≥n en forma de <strong>tareas de gradle personalizadas</strong> para su proyecto. </li></ul><br>  Decidimos elegir la segunda opci√≥n, y ahora estamos eliminando sistem√°ticamente todos los scripts de bash y escribiendo muchos gradle shuffles personalizados. <br><br>  <strong>Consejo # 2: mantenga su infraestructura en c√≥digo.</strong> <br><br>  Es conveniente cuando la configuraci√≥n de Integraci√≥n continua se almacena no en la interfaz de usuario de Jenkins o TeamCity, etc., sino como archivos de texto directamente en el repositorio del proyecto.  Esto le da versatilidad.  No ser√° dif√≠cil revertir o recopilar c√≥digo en otra sucursal. <br><br>  Las secuencias de comandos se pueden almacenar en el proyecto.  ¬øY qu√© hacer con el medio ambiente? <br><br>  <strong>Consejo # 3: Docker puede ayudar con el medio ambiente.</strong> <br><br>  Definitivamente ayudar√° a los desarrolladores de Android, iOS a√∫n no, desafortunadamente. <br><br>  Este es un ejemplo de un archivo acoplable simple que contiene jdk y android-sdk: <br><br><pre> <code class="plaintext hljs">FROM openjdk:8 ENV SDK_URL="https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip" \ ANDROID_HOME="/usr/local/android-sdk" \ ANDROID_VERSION=26 \ ANDROID_BUILD_TOOLS_VERSION=26.0.2 # Download Android SDK RUN mkdir "$ANDROID_HOME" .android \ &amp;&amp; cd "$ANDROID_HOME" \ &amp;&amp; curl -o sdk.zip $SDK_URL \ &amp;&amp; unzip sdk.zip \ &amp;&amp; rm sdk.zip \ &amp;&amp; yes | $ANDROID_HOME/tools/bin/sdkmanager --licenses # Install Android Build Tool and Libraries RUN $ANDROID_HOME/tools/bin/sdkmanager --update RUN $ANDROID_HOME/tools/bin/sdkmanager "build-tools;${ANDROID_BUILD_TOOLS_VERSION}" \ "platforms;android-${ANDROID_VERSION}" \ "platform-tools" RUN mkdir /application WORKDIR /application</code> </pre><br>  Despu√©s de escribir este archivo acoplable (te dir√© un secreto, no puedes escribirlo, pero s√°calo de GitHub) y recopila la imagen, obtienes una m√°quina virtual en la que puedes construir la aplicaci√≥n y ejecutar pruebas de Junit. <br><br>  Los dos argumentos principales por los que esto tiene sentido son la escalabilidad y la repetibilidad.  Con Docker, puede generar r√°pidamente una docena de agentes de compilaci√≥n que tendr√°n exactamente el mismo entorno que el anterior.  Esto facilita la vida de los ingenieros de CI.  Empujar android-sdk en Docker es bastante simple, con emuladores un poco m√°s complicados: tienes que ejercitarte un poco (bueno, o descargar el terminado nuevamente desde GitHub). <br><br>  <strong>Consejo n√∫mero 4: no olvide que los cheques no se realizan por el bien de los cheques, sino por las personas.</strong> <br><br>  La retroalimentaci√≥n r√°pida y, lo m√°s importante, clara es muy importante para los desarrolladores: lo que rompieron, qu√© prueba cay√≥, d√≥nde se encuentra el registro de compilaci√≥n. <br><br>  <strong>Consejo # 5: Sea pragm√°tico con la integraci√≥n continua.</strong> <br><br>  Comprenda claramente qu√© tipos de errores desea evitar, cu√°nto est√° dispuesto a gastar recursos, tiempo, tiempo en la computadora.  Los cheques demasiado largos pueden, por ejemplo, reprogramarse durante la noche.  Y aquellos que atrapan errores no muy importantes deben ser completamente abandonados. <br><br>  <strong>Consejo n√∫mero 6: use herramientas listas para usar.</strong> <br><br>  Ahora hay muchas compa√±√≠as que proporcionan CI en la nube. <br><br><img src="https://habrastorage.org/webt/7a/dr/k3/7adrk3z_1xnccybehwal8sfi-pi.png"><br><br>  Para equipos peque√±os, esta es una buena salida.  No necesita mantener nada, solo pague algo de dinero, recopile su aplicaci√≥n e incluso realice pruebas de instrumentaci√≥n. <br><br>  <strong>Consejo # 7: en un equipo grande, las soluciones internas son m√°s rentables.</strong> <br><br>  Pero tarde o temprano, con el crecimiento del equipo, las soluciones internas ser√°n m√°s rentables.  Hay un punto con estas decisiones.  En econom√≠a, existe una ley de rendimientos decrecientes: en cualquier proyecto, cada mejora posterior se hace m√°s dif√≠cil, requiere m√°s y m√°s inversi√≥n. <br><br>  La econom√≠a describe toda nuestra vida, incluida la integraci√≥n continua.  Constru√≠ un cronograma de trabajo para cada etapa de nuestro desarrollo de Integraci√≥n Continua. <br><br><img src="https://habrastorage.org/webt/es/za/8w/esza8woeimanj5auez2iz9js7di.png"><br><br>  Se puede ver que cualquier mejora es cada vez m√°s dif√≠cil.  Mirando este gr√°fico, podemos entender que el desarrollo de la Integraci√≥n Continua debe ser consistente con el crecimiento del tama√±o del equipo.  Para un equipo de dos personas, pasar 50 d√≠as desarrollando una granja de emuladores internos es una idea regular.  Pero al mismo tiempo, para un gran equipo no hacer Integraci√≥n Continua es una mala idea, debido a problemas de integraci√≥n, arreglando comunicaciones, etc.  Tomar√° a√∫n m√°s tiempo. <br><br>  Comenzamos con el hecho de que la automatizaci√≥n es necesaria porque las personas son caras, est√°n equivocadas y son flojas.  Pero la gente tambi√©n se automatiza.  Por lo tanto, todos estos mismos problemas se aplican a la automatizaci√≥n. <br><br><ul><li>  Automatizar es costoso.  Recuerda el horario de trabajo. </li><li>  En automatizaci√≥n, las personas cometen errores. </li><li>  La automatizaci√≥n a veces es muy floja, porque todo funciona as√≠.  ¬øPor qu√© m√°s mejorar, por qu√© toda esta integraci√≥n continua? </li></ul><br>     :  20%   .     ,      .  ,   , ,    - ,     develop,    . ,           ,    -   . <br><br> <strong> Continuous Integration.   .</strong> <br><br><blockquote> ,        ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf</a>        .            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> .     22-23   . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447608/">https://habr.com/ru/post/447608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447592/index.html">WhatsApp en la palma de tu mano: ¬ød√≥nde y c√≥mo puedes detectar artefactos forenses?</a></li>
<li><a href="../447594/index.html">Instrumentos personalizados: cuando la se√±alizaci√≥n no es suficiente</a></li>
<li><a href="../447598/index.html">Escribir un juego de cartas de memoria en Swift</a></li>
<li><a href="../447604/index.html">Dientes lisos, C ++ y matem√°ticas: ¬øc√≥mo se relacionan? Conversaci√≥n con Alinear</a></li>
<li><a href="../447606/index.html">Recolector de basura CLRium # 5: Peter - Agotado</a></li>
<li><a href="../447610/index.html">C√≥mo tomar el control de su infraestructura de red. Cap√≠tulo tres Seguridad de red. Parte tres</a></li>
<li><a href="../447612/index.html">Centro de datos espaciales. Traducci√≥n de texto del lanzamiento del servidor a la estratosfera</a></li>
<li><a href="../447614/index.html">No podr√° resolver este problema en la entrevista.</a></li>
<li><a href="../447616/index.html">Conectando Aquastorozh a Smart Home en Z-Wave</a></li>
<li><a href="../447618/index.html">La base de datos del servicio de transmisi√≥n Kanopy filtr√≥ hasta 40 millones de entradas de registro sobre pel√≠culas vistas por los usuarios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>