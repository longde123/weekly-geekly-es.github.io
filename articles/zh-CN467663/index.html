<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔓 🧓🏾 👩🏿‍🤝‍👨🏾 支持.NET Core中的特定于硬件的指令（现在不仅限于SIMD） ⛄️ 👃 🧑🏼‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 


几年前， 我们认为是时候在.NET中支持SIMD代码了 。 我们引入了类型为Vector2 ， Vector3 ， Vector4和Vector<T>的System.Numerics命名空间。 这些类型表示通用API，用于在可能的情况下创建，访问和操纵向量指令。 它们还为硬件不支持适当指...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>支持.NET Core中的特定于硬件的指令（现在不仅限于SIMD）</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/467663/"><h2 id="vvedenie"> 引言 </h2><br><p>几年前， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们认为是时候在.NET中支持SIMD代码了</a> 。 我们引入了类型为<code>Vector2</code> ， <code>Vector3</code> ， <code>Vector4</code>和<code>Vector&lt;T&gt;</code>的<code>System.Numerics</code>命名空间。 这些类型表示通用API，用于在可能的情况下创建，访问和操纵向量指令。 它们还为硬件不支持适当指令的情况提供软件兼容性。 通过最少的重构，这可以向量化许多算法。 尽管如此，这种方法的通用性使其难以应用，以充分利用现代硬件上的矢量指令的全部优势。 此外，现代硬件还提供了许多专用的非矢量指令，可以显着提高性能。 在本文中，我将讨论如何绕过.NET Core 3.0中的这些限制。 </p><br><p><img src="https://habrastorage.org/webt/4d/mx/lt/4dmxlt8xgnpgncvellsujvoe_rk.jpeg"><br>  <strong>注意：</strong> <em><strong>Intrisics</strong>翻译尚无既定术语。</em>  <em>在文章的结尾，对翻译选项进行了投票。</em>  <em>如果我们选择一个好的选择，我们将更改文章</em> </p><a name="habracut"></a><br><h2 id="chto-takoe-vstroennye-funkcii"> 有哪些内置功能 </h2><br><p> 在.NET Core 3.0中，我们添加了新功能，称为<em>特定于硬件的内置功能</em> （远距WF）。 此<em>功能</em>提供对许多特定硬件指令的访问，这些指令无法用通用机制简单地表示。 它们与现有的SIMD指令的不同之处在于它们没有通用的用途（新的<em>WF</em>不是跨平台的，并且其体系结构不提供软件兼容性）。 相反，它们直接为.NET开发人员提供平台和特定于硬件的功能。 现有的SIMD功能（例如，跨平台）可提供软件兼容性，并且它们是从底层硬件中抽象出来的。 这种抽象可能很昂贵，此外，它还可以防止某些功能的泄露（例如，当功能不存在或难以在所有目标平台上仿真时）。 </p><br><p> 新的<em>内置函数</em>和受支持的类型位于<code>System.Runtime.Intrinsics</code> 。 对于.NET Core 3.0，目前有一个<code>System.Runtime.Intrinsics.X86</code> 。 我们正在努力为其他平台（例如<code>System.Runtime.Intrinsics.Arm</code>支持<em>内置功能</em> 。 </p><br><p> 在特定于平台的名称空间下， <em>WF</em>被分为代表逻辑集成的硬件指令（通常称为指令集体系结构（ISA））组的类。 每个类都提供一个<code>IsSupported</code>属性<code>IsSupported</code>该属性指示运行代码的硬件是否支持此指令集。 此外，每个此类都包含映射到相应指令集的一组方法。 有时还有一个额外的子类，对应于同一指令集的一部分，可能受到特定硬件的限制（支持）。 例如， <code>Lzcnt</code>类提供对<em>用于计数前导零的指令的</em>访问。 他有一个名为<code>X64</code>的子类，其中包含仅在具有64位体系结构的计算机上使用的这些指令的形式。 </p><br><p> 这些类中的某些本质上是自然分层的。 例如，如果<code>Lzcnt.X64.IsSupported</code>返回true，则<code>Lzcnt.IsSupported</code>也应该返回true，因为这是一个显式的子类。 或者，例如，如果<code>Sse2.IsSupported</code>返回true，则<code>Sse.IsSupported</code>应该返回true，因为<code>Sse2</code>显式继承自<code>Sse</code> 。 但是，值得注意的是，类名的相似性并不表示它们属于同一继承层次结构。 例如， <code>Bmi2</code>不是从<code>Bmi1</code>继承的，因此<code>IsSupported</code>对于这两套指令返回的值将不同。 开发这些类的基本原理是对ISA规范的明确介绍。  SSE2需要对SSE1的支持，因此代表它们的类通过继承进行关联。 同时，BMI2不需要对BMI1的支持，因此我们没有使用继承。 以下是上述API的示例。 </p><br><pre> <code class="plaintext hljs">namespace System.Runtime.Intrinsics.X86 { public abstract class Sse { public static bool IsSupported { get; } public static Vector128&lt;float&gt; Add(Vector128&lt;float&gt; left, Vector128&lt;float&gt; right); // Additional APIs public abstract class X64 { public static bool IsSupported { get; } public static long ConvertToInt64(Vector128&lt;float&gt; value); // Additional APIs } } public abstract class Sse2 : Sse { public static new bool IsSupported { get; } public static Vector128&lt;byte&gt; Add(Vector128&lt;byte&gt; left, Vector128&lt;byte&gt; right); // Additional APIs public new abstract class X64 : Sse.X64 { public static bool IsSupported { get; } public static long ConvertToInt64(Vector128&lt;double&gt; value); // Additional APIs } } }</code> </pre> <br><p> 您可以<a href="">在GitHub上</a>的以下链接<a href="">source.dot.net或dotnet / coreclr</a>的源代码中看到更多信息。 </p><br><p>  <code>IsSupported</code>编译器将<code>IsSupported</code>检查作为运行时常量（启用优化时）进行处理，因此您不需要交叉编译即可支持多个ISA，平台或体系结构。 相反，您只需要使用<code>if</code>表达式编写代码，其结果是在生成本机代码时将丢弃未使用的代码分支（即由于条件语句中的变量值而无法访问的那些分支）。 </p><br><p> 重要的是，在使用内置硬件命令之前，对相应的<code>IsSupported</code>进行验证。 如果没有这样的检查，则在不支持这些命令的平台/体系结构上运行的特定于平台的命令的代码将引发<code>PlatformNotSupportedException</code>运行时异常。 </p><br><h2 id="kakie-preimuschestva-oni-dayut"> 它们提供什么好处？ </h2><br><p> 当然， <em>特定于硬件的内置函数</em>并不适合每个人，但可以用来提高加载计算的操作的性能。  <code>CoreFX</code>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>ML.NET</code></a>使用这些方法来加快操作，例如在内存中复制，搜索数组或字符串中元素的索引，调整图像大小或使用向量/矩阵/张量。 手动将某些代码变成瓶颈的代码也可能比听起来简单。 实际上，代码的矢量化通常是一次使用SIMD指令（一个指令流，多个数据流）一次执行多个操作。 </p><br><p> 在决定对某些代码进行矢量化之前，需要进行概要分析，以确保该代码确实是“热点”的一部分（因此，优化将大大提高性能）。 在向量化的每个阶段进行概要分析也很重要，因为并非所有代码的向量化都会提高生产率。 </p><br><h2 id="vektorizaciya-prostogo-algoritma"> 简单算法的向量化 </h2><br><p> 为了说明<em>内置函数</em>的用法<em>，</em>我们采用该算法对数组或范围的所有元素求和。 这种代码是矢量化的理想选择，因为 在每次迭代中，执行相同的琐碎操作。 </p><br><p> 这种算法的示例实现可能如下所示： </p><br><pre> <code class="plaintext hljs">public int Sum(ReadOnlySpan&lt;int&gt; source) { int result = 0; for (int i = 0; i &lt; source.Length; i++) { result += source[i]; } return result; }</code> </pre> <br><p> 这段代码非常简单明了，但同时对于足够大的输入数据也足够慢，​​因为 每次迭代仅执行一次琐碎的操作。 </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.11.5, OS=Windows 10.0.18362 AMD Ryzen 7 1800X, 1 CPU, 16 logical and 8 physical cores .NET Core SDK=3.0.100-preview9-013775 [Host] : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT [AttachedDebugger] DefaultJob : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 数 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th></tr></thead><tbody><tr><td> 求和 </td><td>  1个 </td><td>  2.477 ns </td><td>  0.0192 ns </td><td>  0.0179 ns </td></tr><tr><td> 求和 </td><td>  2 </td><td>  2.164纳秒 </td><td>  0.0265 ns </td><td>  0.0235纳秒 </td></tr><tr><td> 求和 </td><td>  4 </td><td>  3.224 ns </td><td>  0.0302纳秒 </td><td>  0.0267 ns </td></tr><tr><td> 求和 </td><td>  8 </td><td>  4.347纳秒 </td><td>  0.0665纳秒 </td><td>  0.0622纳秒 </td></tr><tr><td> 求和 </td><td>  16 </td><td>  8.444纳秒 </td><td>  0.2042纳秒 </td><td>  0.3734纳秒 </td></tr><tr><td> 求和 </td><td>  32 </td><td>  13.963 ns </td><td>  0.2182 ns </td><td>  0.2041纳秒 </td></tr><tr><td> 求和 </td><td>  64 </td><td>  50.374 ns </td><td>  0.2955纳秒 </td><td>  0.2620纳秒 </td></tr><tr><td> 求和 </td><td>  128 </td><td>  60.139 ns </td><td>  0.3890 ns </td><td>  0.3639纳秒 </td></tr><tr><td> 求和 </td><td>  256 </td><td>  106.416 ns </td><td>  0.6404纳秒 </td><td>  0.5990纳秒 </td></tr><tr><td> 求和 </td><td>  512 </td><td>  291.450 ns </td><td>  3.5148 ns </td><td>  3.2878 ns </td></tr><tr><td> 求和 </td><td>  1024 </td><td>  574.243 ns </td><td>  9.5851 ns </td><td>  8.4970 ns </td></tr><tr><td> 求和 </td><td>  2048 </td><td>  1137.819 ns </td><td>  5.9363 ns </td><td>  5.5529 ns </td></tr><tr><td> 求和 </td><td>  4096 </td><td>  2 228.341 ns </td><td>  22.8882 ns </td><td>  21.4097 ns </td></tr><tr><td> 求和 </td><td>  8192 </td><td>  2 973.040 ns </td><td>  14.2863 ns </td><td>  12.6644 ns </td></tr><tr><td> 求和 </td><td>  16384 </td><td>  5 883.504 ns </td><td>  15.9619 ns </td><td>  14.9308 ns </td></tr><tr><td> 求和 </td><td>  32768 </td><td>  11699.237 ns </td><td>  104.0970 ns </td><td>  97.3724 ns </td></tr></tbody></table></div><br><h2 id="povyshenie-proizvoditelnosti-za-schet-razvertyvaniya-ciklov"> 通过部署周期提高生产力 </h2><br><p> 现代处理器具有提高代码性能的多种选择。 对于单线程应用程序，一种这样的选择是在单个处理器周期内执行多个基本操作。 </p><br><p> 大多数现代处理器可以在一个时钟周期内（在最佳条件下）执行四个加法运算，因此，使用正确的代码“布局”，即使在单线程实现中，有时也可以提高性能。 </p><br><p> 尽管JIT可以自行执行循环展开，但由于生成的代码的大小，JIT在做出这种决策时比较保守。 因此，以代码形式手动部署循环可能是有利的。 </p><br><p> 您可以在上面的代码中扩展循环，如下所示： </p><br><pre> <code class="plaintext hljs">public unsafe int SumUnrolled(ReadOnlySpan&lt;int&gt; source) { int result = 0; int i = 0; int lastBlockIndex = source.Length - (source.Length % 4); // Pin source so we can elide the bounds checks fixed (int* pSource = source) { while (i &lt; lastBlockIndex) { result += pSource[i + 0]; result += pSource[i + 1]; result += pSource[i + 2]; result += pSource[i + 3]; i += 4; } while (i &lt; source.Length) { result += pSource[i]; i += 1; } } return result; }</code> </pre> <br><p> 这段代码有点复杂，但是可以更好地利用硬件功能。 </p><br><p> 对于非常小的循环，此代码运行速度稍慢。 但是对于8个元素的输入数据，这种趋势已经发生了变化，此后执行速度开始提高（对于32,000个元素，优化代码的执行时间比原始版本的时间减少了26％）。 值得注意的是，这种优化并不总是会提高生产率。 例如，当使用元素类型为<code>float</code>集合时，该算法<code>float</code> “已部署”版本的速度几乎与原始速度相同。 因此，进行概要分析非常重要。 </p><br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 数 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th></tr></thead><tbody><tr><td>  Sumunrolled </td><td>  1个 </td><td>  2.922纳秒 </td><td>  0.0651纳秒 </td><td>  0.0609 ns </td></tr><tr><td>  Sumunrolled </td><td>  2 </td><td>  3.576 ns </td><td>  0.0116纳秒 </td><td>  0.0109 ns </td></tr><tr><td>  Sumunrolled </td><td>  4 </td><td>  3.708纳秒 </td><td>  0.0157 ns </td><td>  0.0139 ns </td></tr><tr><td>  Sumunrolled </td><td>  8 </td><td>  4.832纳秒 </td><td>  0.0486 ns </td><td>  0.0454纳秒 </td></tr><tr><td>  Sumunrolled </td><td>  16 </td><td>  7.490 ns </td><td>  0.1131 ns </td><td>  0.1058 ns </td></tr><tr><td>  Sumunrolled </td><td>  32 </td><td>  11.277 ns </td><td>  0.0910纳秒 </td><td>  0.0851 ns </td></tr><tr><td>  Sumunrolled </td><td>  64 </td><td>  19.761 ns </td><td>  0.2016 ns </td><td>  0.1885纳秒 </td></tr><tr><td>  Sumunrolled </td><td>  128 </td><td>  36.639 ns </td><td>  0.3043纳秒 </td><td>  0.2847 ns </td></tr><tr><td>  Sumunrolled </td><td>  256 </td><td>  77.969 ns </td><td>  0.8409纳秒 </td><td>  0.7866 ns </td></tr><tr><td>  Sumunrolled </td><td>  512 </td><td>  146.357 ns </td><td>  1.3209 ns </td><td>  1.2356 ns </td></tr><tr><td>  Sumunrolled </td><td>  1024 </td><td>  287.354 ns </td><td>  0.9223 ns </td><td>  0.8627 ns </td></tr><tr><td>  Sumunrolled </td><td>  2048 </td><td>  566.405 ns </td><td>  4.0155 ns </td><td>  3.5596 ns </td></tr><tr><td>  Sumunrolled </td><td>  4096 </td><td>  1 131.016 ns </td><td>  7.3601 ns </td><td>  6.5246 ns </td></tr><tr><td>  Sumunrolled </td><td>  8192 </td><td>  2 259.836 ns </td><td>  8.6539 ns </td><td>  8.0949 ns </td></tr><tr><td>  Sumunrolled </td><td>  16384 </td><td>  4 501.295 ns </td><td>  6.4186 ns </td><td>  6.0040 ns </td></tr><tr><td>  Sumunrolled </td><td>  32768 </td><td>  8 979.690 ns </td><td>  19.5265 ns </td><td>  18.2651 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4b7/180/775/4b71807758bdae4be2fba1eb6af8360b.png"></p><br><h2 id="povyshenie-proizvoditelnosti-za-schet-vektorizacii-ciklov"> 通过循环矢量化提高生产力 </h2><br><p> 尽其所能，但是我们仍然可以稍微优化一下此代码。  SIMD指令是现代处理器提供的另一种提高性能的选项。 使用一条指令，它们使您可以在单个时钟周期内执行多项操作。 这可能比直接循环展开更好，因为事实上，可以完成相同的事情，但是生成的代码量较小。 </p><br><p> 为了清楚起见，每个部署操作在一个部署周期中占用4个字节。 因此，以扩展形式，我们需要16个字节来进行4个加法运算。 同时，SIMD加法指令还执行4个加法运算，但仅占用4个字节。 这意味着我们对CPU的指令更少。 除此之外，对于SIMD指令，CPU可以进行<em>假设</em>并执行优化，但这不在本文的讨论范围之内。 更好的是，现代处理器可以一次执行多个SIMD指令，即在某些情况下，您可以应用混合策略，同时执行部分周期扫描和矢量化。 </p><br><p> 通常，您需要先查看<code>Vector&lt;T&gt;</code>通用类以完成您的任务。 与新的<em>WF</em>一样，他将嵌入SIMD指令，但是同时，鉴于此类的多功能性，他可以减少“手动”编码的数量。 </p><br><p> 代码可能看起来像这样： </p><br><pre> <code class="plaintext hljs">public int SumVectorT(ReadOnlySpan&lt;int&gt; source) { int result = 0; Vector&lt;int&gt; vresult = Vector&lt;int&gt;.Zero; int i = 0; int lastBlockIndex = source.Length - (source.Length % Vector&lt;int&gt;.Count); while (i &lt; lastBlockIndex) { vresult += new Vector&lt;int&gt;(source.Slice(i)); i += Vector&lt;int&gt;.Count; } for (int n = 0; n &lt; Vector&lt;int&gt;.Count; n++) { result += vresult[n]; } while (i &lt; source.Length) { result += source[i]; i += 1; } return result; }</code> </pre> <br><p> 这段代码的运行速度更快，但是在计算最终数量时，我们不得不分别引用每个元素。 另外， <code>Vector&lt;T&gt;</code>大小没有精确定义，并且可能会有所不同，具体取决于运行代码的设备。  <em>特定于硬件的内置功能</em>提供了一些附加功能，可以稍微改善此代码并使其更快一点（以增加代码复杂性和维护要求为代价）。 </p><br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 数 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th></tr></thead><tbody><tr><td>  SumVectorT </td><td>  1个 </td><td>  4.517 ns </td><td>  0.0752纳秒 </td><td>  0.0703纳秒 </td></tr><tr><td>  SumVectorT </td><td>  2 </td><td>  4.853纳秒 </td><td>  0.0609 ns </td><td>  0.0570 ns </td></tr><tr><td>  SumVectorT </td><td>  4 </td><td>  5.047 ns </td><td>  0.0909纳秒 </td><td>  0.0850 ns </td></tr><tr><td>  SumVectorT </td><td>  8 </td><td>  5.671 ns </td><td>  0.0251纳秒 </td><td>  0.0223 ns </td></tr><tr><td>  SumVectorT </td><td>  16 </td><td>  6.579 ns </td><td>  0.0330 ns </td><td>  0.0276纳秒 </td></tr><tr><td>  SumVectorT </td><td>  32 </td><td>  10.460纳秒 </td><td>  0.0241 ns </td><td>  0.0226纳秒 </td></tr><tr><td>  SumVectorT </td><td>  64 </td><td>  17.148 ns </td><td>  0.0407纳秒 </td><td>  0.0381纳秒 </td></tr><tr><td>  SumVectorT </td><td>  128 </td><td>  23.239 ns </td><td>  0.0853 ns </td><td>  0.0756纳秒 </td></tr><tr><td>  SumVectorT </td><td>  256 </td><td>  62.146 ns </td><td>  0.8319 ns </td><td>  0.7782纳秒 </td></tr><tr><td>  SumVectorT </td><td>  512 </td><td>  114.863 ns </td><td>  0.4175纳秒 </td><td>  0.3906纳秒 </td></tr><tr><td>  SumVectorT </td><td>  1024 </td><td>  172.129 ns </td><td>  1.8673 ns </td><td>  1.7467 ns </td></tr><tr><td>  SumVectorT </td><td>  2048 </td><td>  429.722 ns </td><td>  1.0461 ns </td><td>  0.9786纳秒 </td></tr><tr><td>  SumVectorT </td><td>  4096 </td><td>  654.209 ns </td><td>  3.6215 ns </td><td>  3.0241 ns </td></tr><tr><td>  SumVectorT </td><td>  8192 </td><td>  1 675.046 ns </td><td>  14.5231 ns </td><td>  13.5849 ns </td></tr><tr><td>  SumVectorT </td><td>  16384 </td><td>  2514.778 ns </td><td>  5.3369 ns </td><td>  4.9921 ns </td></tr><tr><td>  SumVectorT </td><td>  32768 </td><td>  6,689.829 ns </td><td>  13.9947 ns </td><td>  13.0906 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00e/0be/5d4/00e0be5d469067af095f34beccf8c45c.png"></p><br><p>  <em>注意</em>对于本文，我使用内部配置参数（ <code>COMPlus_SIMD16ByteOnly=1</code> ）强制使<code>Vector&lt;T&gt;</code>大小等于16个字节。 当将<code>SumVectorT</code>与<code>SumVectorizedSse</code>进行比较时，此调整对结果进行了归一化，从而使代码保持简单。 特别地，它避免了编写<code>if (Avx2.IsSupported) { }</code>的条件跳转。 该代码与<code>Sse2</code>的代码几乎相同，但是处理<code>Vector256&lt;T&gt;</code> （32字节），并在循环的一次迭代中处理甚至更多的元素。 </p><br><p> 因此，使用新的<em>内置函数</em> ，可以按以下方式重写代码： </p><br><pre> <code class="plaintext hljs">public int SumVectorized(ReadOnlySpan&lt;int&gt; source) { if (Sse2.IsSupported) { return SumVectorizedSse2(source); } else { return SumVectorT(source); } } public unsafe int SumVectorizedSse2(ReadOnlySpan&lt;int&gt; source) { int result; fixed (int* pSource = source) { Vector128&lt;int&gt; vresult = Vector128&lt;int&gt;.Zero; int i = 0; int lastBlockIndex = source.Length - (source.Length % 4); while (i &lt; lastBlockIndex) { vresult = Sse2.Add(vresult, Sse2.LoadVector128(pSource + i)); i += 4; } if (Ssse3.IsSupported) { vresult = Ssse3.HorizontalAdd(vresult, vresult); vresult = Ssse3.HorizontalAdd(vresult, vresult); } else { vresult = Sse2.Add(vresult, Sse2.Shuffle(vresult, 0x4E)); vresult = Sse2.Add(vresult, Sse2.Shuffle(vresult, 0xB1)); } result = vresult.ToScalar(); while (i &lt; source.Length) { result += pSource[i]; i += 1; } } return result; }</code> </pre> <br><p> 这段代码再复杂一点，但是对于每个人，除了最小的输入集外，它的速度要快得多。 对于32,000个元素，此代码比扩展的周期执行速度快75％，比示例的源代码执行速度快81％。 </p><br><p> 您注意到我们写了一些<code>IsSupported</code>检查。 第一个检查当前硬件是否支持所需的<em>内置函数集</em> ，如果不是，则通过结合使用scan和<code>Vector&lt;T&gt;</code>进行优化。 对于不支持所需指令集的平台（如ARM / ARM64），或者如果平台已禁用该指令集，则将选择后一个选项。 如果硬件支持<code>Ssse3</code>指令<code>Ssse3</code> ，则使用<code>SumVectorizedSse2</code>方法中的第二个<code>IsSupported</code>测试进行其他优化。 </p><br><p> 否则，大多数逻辑与扩展循环基本相同。  <code>Vector128&lt;T&gt;</code>是包含<code>Vector128&lt;T&gt;.Count</code>元素的128位类型。 在这种情况下，本身是32位的<code>uint</code>可以具有4（128/32）个元素，这就是我们启动循环的方式。 </p><br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 数 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th></tr></thead><tbody><tr><td> 总和 </td><td>  1个 </td><td>  4.555 ns </td><td>  0.0192 ns </td><td>  0.0179 ns </td></tr><tr><td> 总和 </td><td>  2 </td><td>  4.848 ns </td><td>  0.0147 ns </td><td>  0.0137 ns </td></tr><tr><td> 总和 </td><td>  4 </td><td>  5.381 ns </td><td>  0.0210纳秒 </td><td>  0.0186 ns </td></tr><tr><td> 总和 </td><td>  8 </td><td>  4.838 ns </td><td>  0.0209纳秒 </td><td>  0.0186 ns </td></tr><tr><td> 总和 </td><td>  16 </td><td>  5.107 ns </td><td>  0.0175 ns </td><td>  0.0146 ns </td></tr><tr><td> 总和 </td><td>  32 </td><td>  5.646纳秒 </td><td>  0.0230纳秒 </td><td>  0.0204 ns </td></tr><tr><td> 总和 </td><td>  64 </td><td>  6.763 ns </td><td>  0.0338纳秒 </td><td>  0.0316 ns </td></tr><tr><td> 总和 </td><td>  128 </td><td>  9.308 ns </td><td>  0.1041纳秒 </td><td>  0.0870 ns </td></tr><tr><td> 总和 </td><td>  256 </td><td>  15.634 ns </td><td>  0.0927纳秒 </td><td>  0.0821 ns </td></tr><tr><td> 总和 </td><td>  512 </td><td>  34.706 ns </td><td>  0.2851纳秒 </td><td>  0.2381纳秒 </td></tr><tr><td> 总和 </td><td>  1024 </td><td>  68.110 ns </td><td>  0.4016纳秒 </td><td>  0.3756纳秒 </td></tr><tr><td> 总和 </td><td>  2048 </td><td>  136.533 ns </td><td>  1.3104 ns </td><td>  1.2257 ns </td></tr><tr><td> 总和 </td><td>  4096 </td><td>  277.930 ns </td><td>  0.5913纳秒 </td><td>  0.5531纳秒 </td></tr><tr><td> 总和 </td><td>  8192 </td><td>  554.720 ns </td><td>  3.5133 ns </td><td>  3.2864 ns </td></tr><tr><td> 总和 </td><td>  16384 </td><td>  1 110.730 ns </td><td>  3.3043 ns </td><td>  3.0909 ns </td></tr><tr><td> 总和 </td><td>  32768 </td><td>  2 200.996 ns </td><td>  21.0538 ns </td><td>  19.6938 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/311/e70/320/311e7032050337fe946103244e749076.png"></p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 新的<em>内置功能</em>使您有机会利用运行代码的计算机的硬件特定功能。  X86和X64大约有1,500个API，分布在15个集合中，一篇文章中介绍的太多了。 通过分析代码以识别瓶颈，您可以确定代码中受益于矢量化的部分，并观察到相当不错的性能提升。 在许多情况下都可以应用矢量化，而循环展开仅仅是个开始。 </p><br><p> 任何想查看更多示例的人都可以在框架（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dotnet</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">aspnet</a> ）或其他社区文章中使用<em>内置函数</em> 。 尽管当前的<em>WF</em>数量巨大，但是仍然需要引入许多功能。 如果您具有要介绍的功能，请随时通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上的dotnet / corefx</a>注册您的API请求。  <a href="">这里</a>描述<a href="">了</a> API审核过程<a href="">，</a>并且有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">很好的示例</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a>在步骤1中指定了API请求模板。 </p><br><h2 id="osobye-blagodarnosti"> 特别感谢 </h2><br><p> 我要特别感谢我们的社区成员<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Fei Peng（@fiigii）</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jacek Blaszczynski（@ 4creators）</a>在实施<em>WF方面</em>的帮助，以及社区的所有成员，感谢他们对该功能的开发，实施和易用性提供了宝贵的反馈意见。 </p><br><hr><br><h3 id="posleslovie-k-perevodu"> 后记翻译 </h3><br><p> 我喜欢观察.NET平台的发展，尤其是C＃语言的发展。 来自C ++领域，对使用Delphi和Java进行开发几乎没有经验，因此我很乐意开始用C＃编写程序。 在2006年，在托管垃圾收集和跨平台领域中，这种编程语言（语言本身）比Java更为简洁实用。 因此，我的选择落在了C＃上，我并不后悔。 语言发展的第一阶段就是它的出现。 到2006年，C＃吸收了当时最好的语言和平台上的所有优点：C ++ / Java / Delphi。  2010年，F＃上市。 这是一个研究功能范式的实验平台，旨在将其引入.NET世界。 实验的结果是C＃进化的下一阶段-通过引入匿名函数，lambda表达式以及最终的LINQ，将其功能扩展到FP。 从我的角度来看，这种语言的扩展使C＃成为最先进的通用语言。 下一步的发展步骤与支持并发和异步有关。 任务/任务&lt;T&gt;，TPL的整个概念，LINQ-PLINQ的开发以及最后的异步/等待。  ,   - ,       .NET   C# —      .    Span&lt;T&gt;  Memory&lt;T&gt;, ValueTask/ValueTask&lt;T&gt;, IAsyncDispose, ref readonly struct   in,  foreach, IO.Streams.         GC    .   ,       —       .  ,     .NET   C#,  ,          .   (       )         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467663/">https://habr.com/ru/post/zh-CN467663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467653/index.html">Habrastatistics：分析读者评论</a></li>
<li><a href="../zh-CN467655/index.html">我如何在C＃8中度过夏天</a></li>
<li><a href="../zh-CN467657/index.html">从I到Z的库存。我们计算软件许可证</a></li>
<li><a href="../zh-CN467659/index.html">通过更新的HyperX FURY DDR4内存的其他配置示例，显着加快了任务执行速度</a></li>
<li><a href="../zh-CN467661/index.html">Seryozha的剂量计。 第一部分Polimaster-核猎人</a></li>
<li><a href="../zh-CN467665/index.html">ROS卡车手推车。 第5部分。在rviz和凉亭中工作：xacro，新传感器</a></li>
<li><a href="../zh-CN467667/index.html">组织项目计划（第4部分）</a></li>
<li><a href="../zh-CN467669/index.html">观看全文：充分利用移动平台上的实时视频</a></li>
<li><a href="../zh-CN467671/index.html">NLX复古电脑</a></li>
<li><a href="../zh-CN467673/index.html">内置Go功能</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>