<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🍳 🚶🏿 👨🏿 Celesta 7.x: ORM, migrasi dan pengujian "dalam satu paket" 🤾🏻 🖍️ 🥣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mungkin Anda sudah tahu sesuatu tentang perpustakaan open source Celesta . Jika tidak, itu tidak masalah, sekarang kami akan memberi tahu Anda segalan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Celesta 7.x: ORM, migrasi dan pengujian "dalam satu paket"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455746/"><p>  Mungkin Anda sudah tahu sesuatu tentang perpustakaan open source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Celesta</a> .  Jika tidak, itu tidak masalah, sekarang kami akan memberi tahu Anda segalanya.  Satu tahun berlalu, versi 7.x dirilis, banyak hal telah berubah, dan sudah waktunya untuk meringkas perubahan, dan pada saat yang sama mengingatkan apa Celesta secara umum. </p><br><div style="text-align:center;"><img width="350" src="https://habrastorage.org/webt/jj/7z/jt/jj7zjthmrh2dhdo4v0ueefqj6uq.png"></div><a name="habracut"></a><br><p> Jika Anda belum pernah mendengar apa pun tentang Celesta, dan ketika membaca artikel ini Anda ingin tahu untuk tugas bisnis mana penerapannya paling efektif, saya dapat merekomendasikan bagian pertama dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting lama</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video setengah jam ini</a> (kecuali untuk kata-kata tentang menggunakan bahasa Python).  Tapi lebih baik lagi, baca artikel ini dulu.  Saya akan mulai dengan perubahan yang terjadi di versi 7, dan kemudian saya akan membahas contoh teknis lengkap menggunakan versi modern Celesta untuk menulis layanan backend kecil untuk aplikasi Java menggunakan Spring Boot. </p><br><h2 id="chto-izmenilos-v-versii-7x">  Apa yang berubah di versi 7.x? </h2><br><ol><li>  Kami menolak menggunakan Jython sebagai bahasa bawaan Celesta.  Jika sebelumnya kita mulai berbicara tentang Celesta dengan fakta bahwa logika bisnis ditulis dengan Python, sekarang ... bahasa Java apa pun dapat berfungsi sebagai bahasa logika bisnis: Java, Groovy, JRuby, atau Jython yang sama.  Sekarang Celesta tidak memanggil kode logika bisnis, tetapi kode logika bisnis menggunakan Celesta dan kelas akses datanya sebagai perpustakaan Java yang paling umum.  Ya, kompatibilitas mundur dilanggar karena ini, tetapi ini adalah harga yang kami bayarkan.  Sayangnya, taruhan kami pada Jython hilang.  Ketika kami mulai menggunakan Jython beberapa tahun yang lalu, itu adalah proyek yang hidup dan menjanjikan, tetapi selama bertahun-tahun perkembangannya melambat, tumpukan dari spesifikasi bahasa terakumulasi, masalah kompatibilitas untuk sebagian besar perpustakaan pip tidak diselesaikan.  Sedotan terakhir adalah bug baru dalam rilis bahasa terbaru, yang memanifestasikan diri ketika mengerjakan beban produksi.  Kami sendiri tidak memiliki sumber daya untuk mendukung proyek Jython, dan kami memutuskan untuk berpisah dengannya.  Celesta tidak lagi bergantung pada Jython. </li><li>  Kelas akses data sekarang dihasilkan kode dalam bahasa Java (dan bukan Python, seperti sebelumnya) menggunakan plugin Maven.  Dan karena kami beralih dari pengetikan dinamis ke pengetikan statis karena ini, ada lebih banyak peluang untuk refactoring dan menjadi lebih mudah untuk menulis kode yang benar secara subyektif. </li><li>  Ekstensi untuk JUnit5 muncul, sehingga menjadi sangat nyaman untuk menulis tes logika yang berfungsi dengan database di JUnit5 (yang akan dibahas nanti). </li><li>  Sebuah proyek terpisah telah muncul - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spring-boot-starter-celesta</a> , yang seperti namanya, adalah starter Celesta di Spring Boot.  Kemampuan untuk mengemas aplikasi Celesta ke dalam layanan Spring Boot yang mudah digunakan dikompensasi dengan hilangnya kemampuan untuk memperbarui aplikasi di server dengan hanya mengubah folder dengan skrip Python. </li><li>  Kami mentransfer semua dokumentasi dari Wiki ke format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AsciiDoctor</a> , menempatkannya di kontrol versi bersama dengan kode, dan sekarang kami memiliki dokumentasi terbaru untuk setiap rilis Celesta.  Untuk rilis terbaru, dokumentasi online tersedia di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://courseorchestra.github.io/celesta/</a> </li><li>  Kami sering ditanya apakah mungkin menggunakan migrasi basis data melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">idempoten DDL</a> secara terpisah dari Celesta.  Sekarang ada peluang seperti itu menggunakan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2bass</a> . </li></ol><br><h2 id="chto-takoe-selesta-i-chto-ona-umeet">  Apa itu Celesta dan apa yang bisa dia lakukan? </h2><br><p>  Singkatnya, Celesta adalah: </p><br><ul><li>  lapisan menengah antara database relasional dan kode logika bisnis, berdasarkan pada pendekatan desain <em>database-pertama</em> , </li><li>  mekanisme migrasi struktur basis data, </li><li>  kerangka kerja untuk menguji kode yang berfungsi dengan data. </li></ul><br><p>  Kami mendukung empat jenis database relasional: PostgreSQL, MS SQL Server, Oracle dan H2. </p><br><p>  Fitur utama Celesta: </p><br><ol><li>  Prinsip yang sangat mirip dengan prinsip dasar Jawa: "Tulis sekali, jalankan pada setiap RDBMS yang didukung."  Kode logika bisnis tidak tahu jenis database apa yang akan dijalankan.  Anda dapat menulis kode logika bisnis dan menjalankannya di MS SQL Server, kemudian beralih ke PostgreSQL, dan ini akan terjadi tanpa komplikasi (well, hampir :) </li><li>  Restrukturisasi otomatis pada database langsung.  Sebagian besar siklus hidup proyek-proyek Celesta terjadi ketika database yang bekerja sudah ada dan diisi dengan data yang perlu disimpan, tetapi juga perlu untuk terus mengubah struktur mereka.  Salah satu fitur utama Celesta adalah kemampuan untuk secara otomatis "menyesuaikan" struktur database dengan model data Anda. </li><li>  Pengujian.  Banyak perhatian diberikan untuk memastikan bahwa kode untuk Celesta dapat diuji, sehingga kami dapat secara otomatis menguji metode yang memodifikasi data dalam database, melakukan ini dengan mudah, cepat dan elegan, tanpa menggunakan alat eksternal seperti DbUnit dan wadah. </li></ol><br><h2 id="dlya-chego-nuzhna-nezavisimost-ot-tipa-subd">  Mengapa Anda membutuhkan independensi dari jenis DBMS? </h2><br><p>  Kemandirian kode logika bisnis dari jenis DBMS bukanlah poin pertama yang kami masukkan: kode yang ditulis untuk Celesta tidak tahu sama sekali dari mana DBMS dijalankan.  Mengapa </p><br><p>  Pertama, karena fakta bahwa pilihan jenis DBMS bukan masalah teknologi, tetapi masalah politik.  Datang ke pelanggan bisnis baru, kita sering menemukan bahwa dia sudah memiliki jenis DBMS favorit di mana dana diinvestasikan, dan pelanggan ingin melihat solusi lain pada infrastruktur yang ada.  Lansekap teknologi berubah: PostgreSQL semakin banyak ditemukan di lembaga pemerintah dan perusahaan swasta, meskipun MS SQL Server menang dalam praktik kami beberapa tahun yang lalu.  Celesta mendukung DBMS yang paling umum, dan kami tidak khawatir tentang perubahan ini. </p><br><p>  Kedua, saya ingin mentransfer kode yang sudah dibuat untuk menyelesaikan masalah standar dari satu proyek ke proyek lain, untuk membuat perpustakaan yang dapat digunakan kembali.  Hal-hal seperti direktori hierarki atau modul distribusi notifikasi email pada dasarnya standar, dan mengapa kita perlu mendukung banyak versi untuk pelanggan dengan hubungan yang berbeda? </p><br><p>  Ketiga, terakhir namun tidak kalah pentingnya, kemampuan untuk menjalankan tes unit tanpa menggunakan DbUnit dan wadah menggunakan basis data H2 di dalam memori.  Dalam mode ini, basis H2 dimulai secara instan.  Celesta dengan sangat cepat membuat skema data di dalamnya, setelah itu Anda dapat melakukan tes yang diperlukan dan "melupakan" database.  Karena kode logika bisnis benar-benar tidak tahu atas dasar apa itu dieksekusi, maka sesuai, jika ia bekerja tanpa kesalahan pada H2, maka tanpa kesalahan itu akan bekerja pada PostgreSQL.  Tentu saja, tugas para pengembang sistem Celesta itu sendiri adalah melakukan semua tes menggunakan DBMS nyata untuk memastikan bahwa platform kami melakukan API yang sama pada hubungan yang berbeda.  Dan kami melakukannya.  Tetapi pengembang logika bisnis tidak lagi diperlukan. </p><br><h2 id="celestasql">  CelestaSQL </h2><br><p>  Bagaimana lintas-basementisme tercapai?  Tentu saja, dengan biaya bekerja dengan data hanya melalui API khusus yang mengisolasi logika dari setiap basis data spesifik.  Celesta menghasilkan kelas Java untuk mengakses data, di satu sisi, dan kode SQL dan beberapa objek tambahan di dalam database, di sisi lain. </p><br><p>  Celesta tidak menyediakan pemetaan objek-relasional dalam bentuknya yang paling murni, karena ketika merancang model data, kita tidak berasal dari kelas, tetapi dari struktur basis data.  Yaitu, pertama kita membangun model tabel ER, dan kemudian, berdasarkan model ini, Celesta sendiri menghasilkan kelas kursor untuk mengakses data. </p><br><p>  Anda dapat mencapai pekerjaan yang sama di semua DBMS yang didukung hanya untuk fungsionalitas yang kira-kira diimplementasikan secara sama di masing-masing.  Jika kami secara kondisional menggambarkan serangkaian kemampuan fungsional dari masing-masing pangkalan yang didukung oleh kami dalam bentuk "Lingkaran Euler", maka kami mendapatkan gambar berikut: </p><br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/getpro/habr/post_images/7d9/2ad/1e1/7d92ad1e1a3bc0bb83b5c4bcc511ec66.png"></div><br><p>  Jika kami memberikan kebebasan penuh dari jenis database, maka fungsionalitas yang kami buka untuk programmer logika bisnis harus berada di dalam persimpangan semua pangkalan.  Sekilas, tampaknya ini adalah batasan yang signifikan.  Ya: beberapa fitur tertentu, misalnya, kami tidak dapat menggunakan SQL Server.  Tetapi tanpa kecuali, tabel dukungan database relasional, kunci asing, tampilan, sekuens, kueri SQL dengan BERGABUNG dan GROUP BY.  Dengan demikian, kami dapat memberikan peluang ini kepada pengembang.  Kami menyediakan pengembang dengan "depersonalized SQL", yang kami sebut "CelestaSQL", dan dalam prosesnya kami menghasilkan permintaan SQL untuk dialek dari database yang sesuai. </p><br><p>  Bahasa CelestaSQL mencakup DDL untuk mendefinisikan objek database dan permintaan SELECT untuk tampilan dan filter, tetapi tidak mengandung perintah DML: kursor digunakan untuk memodifikasi data, yang masih harus didiskusikan. </p><br><p>  Setiap basis data memiliki jenis data sendiri.  CelestaSQL juga memiliki serangkaian tipe sendiri.  Pada saat penulisan, ada sembilan dari mereka, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel ini</a> membandingkan mereka dengan tipe nyata di berbagai database dan tipe data Java. </p><br><p>  Mungkin terlihat bahwa sembilan jenis tidak cukup (dibandingkan dengan apa yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">didukung</a> PostgreSQL, misalnya), tetapi dalam kenyataannya ini adalah jenis yang cukup untuk menyimpan informasi keuangan, perdagangan, dan logistik: string, integer, fraksional , tanggal, nilai boolean, dan gumpalan selalu cukup untuk mewakili data tersebut. </p><br><p>  Bahasa CelestaSQL sendiri dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> dengan sejumlah besar diagram sintaks. </p><br><h2 id="modifikaciya-struktury-bazy-dannyh-idempotentnyy-ddl">  Modifikasi struktur basis data.  DDL idempoten </h2><br><p>  Fitur kunci lain dari Celesta adalah pendekatannya untuk memigrasikan struktur database yang berfungsi saat proyek berkembang.  Untuk melakukan ini, pendekatan yang dibangun ke dalam Celesta menggunakan idempotent DDL digunakan. </p><br><p>  Singkatnya, ketika kita menulis dalam CelestaSQL, teks berikut: </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderLine( order_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, line_no <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), qty <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span> <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> Idx_OrderLine PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (order_id, line_no) );</code> </pre> <br><p>  - teks ini tidak ditafsirkan oleh Celesta sebagai "buat tabel, tetapi jika sudah ada tabel, maka berikan kesalahan", tetapi "bawa tabel ke struktur yang diinginkan".  Yaitu: "jika tidak ada tabel, buatlah, jika ada tabel, lihat bidang apa yang ada di dalamnya, dengan tipe apa, yang mengindeks, kunci asing mana, nilai default mana, dll, dan jika ada sesuatu yang perlu diubah di meja ini untuk membawanya ke jenis yang tepat. " </p><br><p>  Dengan pendekatan ini, kami menerapkan kemampuan untuk memperbaiki dan mengontrol skrip versi untuk menentukan struktur database: </p><br><ul><li>  kita melihat dalam skrip "gambar yang diinginkan" saat ini dari struktur, </li><li>  apa, oleh siapa dan mengapa dalam struktur telah berubah dari waktu ke waktu, kita dapat melihat melalui sistem kontrol versi, </li><li>  seperti untuk perintah ALTER, Celesta secara otomatis menghasilkan dan mengeksekusi mereka "di bawah tenda" sebagaimana diperlukan. </li></ul><br><p>  Tentu saja, pendekatan ini memiliki keterbatasan.  Celesta berusaha keras untuk memastikan bahwa migrasi otomatis tidak menimbulkan rasa sakit dan mulus, tetapi ini tidak mungkin dalam semua kasus.  Motivasi, kemungkinan dan keterbatasan pendekatan ini diuraikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam posting ini</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi bahasa Inggrisnya</a> juga tersedia). </p><br><p>  Untuk mempercepat proses pengecekan / pembaruan struktur basis data, Celesta menerapkan penyimpanan checksum skrip DDL dalam basis data (sampai checksum diubah, proses pemeriksaan dan pembaruan struktur basis data tidak dimulai).  Agar proses pembaruan untuk melanjutkan tanpa masalah yang terkait dengan urutan perubahan objek bergantung satu sama lain, pengurutan topologi dependensi antara skema dengan kunci asing diterapkan.  Proses migrasi otomatis dijelaskan secara lebih rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . </p><br><h2 id="sozdanie-proekta-celesta-i-modeli-dannyh">  Membuat proyek dan model data Celesta </h2><br><p>  Proyek demo, yang akan kami pertimbangkan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia di github</a> .  Mari kita lihat bagaimana Anda dapat menggunakan Celesta saat menulis aplikasi Spring Boot.  Berikut adalah dependensi Maven yang Anda butuhkan: </p><br><ul><li>  <code>org.springframework.boot:spring-boot-starter-web</code> dan <code>ru.curs:spring-boot-starter-celesta</code> (untuk rincian lebih lanjut, <code>ru.curs:spring-boot-starter-celesta</code> dokumentasi). </li><li>  Jika Anda tidak menggunakan Spring Boot, Anda dapat menghubungkan <code>ru.curs:celesta-system-services</code> ketergantungan <code>ru.curs:celesta-system-services</code> secara langsung. </li><li>  Untuk pembuatan kode kelas akses data berdasarkan skrip Celesta-SQL, <code>ru.curs:celesta-maven-plugin</code> diperlukan <code>ru.curs:celesta-maven-plugin</code> - kode sumber untuk contoh demo atau dokumentasi menjelaskan cara menghubungkannya. </li><li>  Untuk memanfaatkan kemampuan menulis tes unit JUnit5 untuk metode yang mengubah data, Anda harus menghubungkan <code>ru.curs:celesta-unit</code> dalam cakupan pengujian. </li></ul><br><p>  Sekarang buat model data dan kompilasi kelas akses data. </p><br><p>  Katakanlah kita sedang melakukan proyek untuk perusahaan e-commerce yang baru-baru ini bergabung dengan perusahaan lain.  Masing-masing memiliki database sendiri.  Mereka mengumpulkan pesanan, tetapi sampai mereka menggabungkan basis data mereka, mereka membutuhkan satu titik masuk untuk mengumpulkan pesanan dari luar. </p><br><p>  Implementasi "titik masuk" ini harus sangat tradisional: layanan HTTP dengan operasi CRUD yang menyimpan data dalam basis data relasional. </p><br><p>  Karena fakta bahwa Celesta mengimplementasikan pendekatan desain Database-pertama, pertama kita perlu membuat struktur tabel yang menyimpan pesanan.  Pesanan, seperti yang Anda ketahui, adalah entitas gabungan: terdiri dari tajuk tempat informasi tentang pelanggan, tanggal pesanan, dan atribut lainnya dari pesanan disimpan, serta banyak baris (item komoditas). </p><br><p>  Jadi, untuk pekerjaan itu: buat </p><br><ul><li>  <code>src/main/celestasql</code> - secara default, ini adalah path ke skrip proyek CelestaSQL </li><li>  ini berisi subfolder yang mengulangi struktur folder paket java ( <code>ru/curs/demo</code> dalam kasus kami). </li><li>  di folder paket, buat file <code>.sql</code> dengan konten berikut: </li></ul><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SCHEMA</span></span> demo <span class="hljs-keyword"><span class="hljs-keyword">VERSION</span></span> <span class="hljs-string"><span class="hljs-string">'1.0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderHeader( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">date</span></span> DATETIME, customer_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>), <span class="hljs-comment"><span class="hljs-comment">/**  */</span></span> customer_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">50</span></span>), manager_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> Pk_OrderHeader PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">/** */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderLine( order_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, line_no <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), qty <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span> <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> Idx_OrderLine PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (order_id, line_no) ); <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> fk_OrderLine <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (order_id) <span class="hljs-keyword"><span class="hljs-keyword">REFERENCES</span></span> OrderHeader(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> item_id;</code> </pre> <br><p>  Di sini kami menggambarkan dua tabel yang terhubung dengan kunci asing, dan satu tampilan yang akan mengembalikan jumlah ringkasan untuk barang yang ada di semua pesanan.  Seperti yang Anda lihat, ini tidak berbeda dari SQL biasa, dengan pengecualian perintah <code>CREATE SCHEMA</code> , di mana kami mendeklarasikan versi skema <code>demo</code> (untuk bagaimana nomor versi memengaruhi migrasi otomatis, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> ).  Tetapi ada juga fitur.  Misalnya, semua nama tabel dan bidang yang kami gunakan hanya bisa sedemikian rupa sehingga dapat diubah menjadi nama kelas dan variabel yang valid dalam bahasa Java.  Karenanya, spasi, karakter khusus dikecualikan.  Anda juga dapat melihat bahwa komentar yang kami letakkan di atas nama tabel dan beberapa bidang, kami tidak memulai dengan / *, seperti biasa, tetapi dengan / **, bagaimana komentar JavaDoc dimulai - dan ini bukan kebetulan!  Komentar yang didefinisikan atas entitas yang dimulai dengan / ** akan tersedia saat runtime di properti <code>.getCelestaDoc()</code> dari entitas itu.  Ini berguna ketika kami ingin memberikan elemen-elemen database dengan meta-informasi tambahan: misalnya, nama bidang yang dapat dibaca manusia, informasi tentang cara mewakili bidang dalam antarmuka pengguna, dll. </p><br><p>  Skrip CelestaSQL melayani dua tugas yang sama pentingnya: pertama, untuk penyebaran / modifikasi struktur database relasional, dan kedua, untuk pembuatan kode kelas akses data. </p><br><p>  Kami dapat membuat kelas akses data sekarang, jalankan saja perintah <code>mvn generate-sources</code> atau, jika Anda bekerja di IDEA, klik tombol 'Hasilkan sumber dan perbarui folder' di panel kontrol Maven.  Dalam kasus kedua, IDEA “ <code>target/generated-sources/celesta</code> folder yang dibuat dalam <code>target/generated-sources/celesta</code> dan membuat isinya tersedia untuk impor dalam kode sumber proyek.  Hasil pembuatan kode akan terlihat sebagai berikut - satu kelas untuk setiap objek dalam database: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2x/3q/cs/2x3qcsydsu3y5vplbyh7oz15z-s.png"></div><br><p>  Koneksi ke database ditentukan dalam pengaturan aplikasi, dalam kasus kami, dalam file <code>src/main/resources/application.yml</code> .  Saat menggunakan spring-boot-starter-celesta, IDEA akan memberi tahu Anda opsi kode yang tersedia dalam penyelesaian kode. </p><br><p>  Jika kami tidak ingin repot dengan RDBMS "nyata" untuk tujuan demonstrasi, kami dapat membuat Celesta bekerja dengan basis data H2 bawaan dalam mode dalam memori menggunakan konfigurasi berikut: </p><br><pre> <code class="plaintext hljs">celesta: h2: inMemory: true</code> </pre> <br><p>  Untuk menghubungkan database "nyata", ubah konfigurasi ke sesuatu seperti </p><br><pre> <code class="plaintext hljs">celesta: jdbc: url: jdbc:postgresql://127.0.0.1:5432/celesta username: &lt;your_username&gt; password: &lt;your_password&gt;</code> </pre> <br><p>  (dalam hal ini, Anda juga perlu menambahkan driver JDBC PostgreSQL ke aplikasi Anda melalui ketergantungan Maven). </p><br><p>  Saat Anda meluncurkan aplikasi Celesta dengan koneksi ke server database, Anda dapat mengamati bahwa tabel, tampilan, indeks, dll. Yang diperlukan dibuat untuk database kosong, dan untuk yang tidak kosong, mereka diperbarui ke struktur yang ditentukan dalam DDL. </p><br><h2 id="sozdanie-metodov-rabotayuschih-s-dannymi">  Membuat metode manipulasi data </h2><br><p>  Setelah mengetahui cara membuat struktur basis data, Anda dapat mulai menulis logika bisnis. </p><br><p>  Agar dapat menerapkan persyaratan untuk mendistribusikan hak akses dan tindakan logging, setiap operasi pada data di Celesta dilakukan atas nama pengguna, tidak ada operasi "anonim".  Oleh karena itu, setiap kode Celesta dieksekusi dalam <em>konteks panggilan yang</em> dijelaskan dalam kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CallContext</a> . </p><br><ul><li>  Sebelum memulai operasi yang dapat mengubah data dalam database, <code>CallContext</code> diaktifkan. </li><li>  Pada saat aktivasi, koneksi ke database diambil dari kumpulan koneksi dan transaksi dimulai. </li><li>  Setelah operasi <code>CallContext</code> mengeksekusi <code>commit()</code> jika operasi berhasil, atau <code>rollback()</code> jika pengecualian tidak tertangani terjadi selama eksekusi, <code>CallContext</code> ditutup dan koneksi database dikembalikan ke kumpulan. </li></ul><br><p>  Jika kita menggunakan spring-boot-starter-celesta, maka tindakan ini dilakukan secara otomatis untuk semua metode yang dijelaskan oleh <code>@CelestaTransaction</code> . </p><br><p>  Misalkan kita ingin menulis handler yang menyimpan dokumen ke database.  Kode level pengontrolnya mungkin terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/api"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocumentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DocumentService srv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DocumentController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DocumentService srv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.srv = srv; } <span class="hljs-meta"><span class="hljs-meta">@PutMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/save"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody OrderDto order)</span></span></span><span class="hljs-function"> </span></span>{ CallContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CallContext(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//new SystemCallContext(); srv.postOrder(ctx, order); }</span></span></code> </pre> <br><p>  Sebagai aturan, pada tingkat metode pengontrol (mis., Ketika otentikasi telah berlalu), kami tahu ID pengguna dan dapat menggunakannya saat membuat <code>CallContext</code> .  Mengikat pengguna ke konteks menentukan izin untuk mengakses tabel, dan juga menyediakan kemampuan untuk mencatat perubahan yang dibuat atas namanya.  Benar, dalam hal ini, untuk operabilitas kode yang berinteraksi dengan database, hak untuk pengguna "user1" harus ditunjukkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel sistem</a> .  Jika Anda tidak ingin menggunakan sistem distribusi akses Celesta dan memberikan konteks sesi semua hak ke tabel apa pun, Anda bisa membuat objek <code>SystemCallContext</code> . </p><br><p>  Metode menyimpan faktur di tingkat layanan mungkin terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocumentService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@CelestaTransaction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context, OrderDto doc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (OrderHeaderCursor header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderHeaderCursor(context); OrderLineCursor line = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderLineCursor(context)) { header.setId(doc.getId()); header.setDate(Date.from(doc.getDate().atStartOfDay(ZoneId.systemDefault()).toInstant())); header.setCustomer_id(doc.getCustomerId()); header.setCustomer_name(doc.getCustomerName()); header.insert(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lineNo = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (OrderLineDto docLine : doc.getLines()) { lineNo++; line.setLine_no(lineNo); line.setOrder_id(doc.getId()); line.setItem_id(docLine.getItemId()); line.setQty(docLine.getQty()); line.insert(); } } }</code> </pre> <br><p>  Perhatikan anotasi <code>@CelestaTransaction</code> .  Berkat itu, objek proxy <code>DocumentService</code> akan melakukan semua tindakan layanan tersebut dengan parameter <code>CallContext ctx</code> dijelaskan di atas.  Artinya, pada awal pelaksanaan metode, itu sudah akan terikat ke koneksi database, dan transaksi akan siap untuk dimulai.  Kita dapat fokus pada penulisan logika bisnis.  Dalam kasus kami, membaca objek <code>OrderDto</code> dan menyimpannya ke database. </p><br><p>  Untuk melakukan ini, kami menggunakan kursor yang disebut - kelas yang dihasilkan menggunakan <code>celesta-maven-plugin</code> .  Kita sudah melihat apa itu.  Satu kelas dibuat untuk masing-masing objek skema - dua tabel dan satu tampilan.  Dan sekarang kita bisa menggunakan kelas-kelas ini untuk mengakses objek database dalam logika bisnis kita. </p><br><p>  Untuk membuat kursor pada tabel pesanan dan memilih catatan pertama, Anda perlu menulis kode berikut: </p><br><pre> <code class="java hljs">OrderHeaderCursor header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderHeaderCursor(context); header.tryFirst();</code> </pre> <br><p>  Setelah membuat objek tajuk, kita dapat mengakses bidang entri tabel melalui getter dan setter: </p><br><div style="text-align:center;"><img width="450" src="https://habrastorage.org/webt/_8/gl/9i/_8gl9ikjbprpjano2dbvj0reme8.png"></div><br><p>  Saat membuat kursor, kita harus menggunakan konteks panggilan aktif - ini adalah satu-satunya cara untuk membuat kursor.  Konteks panggilan membawa informasi tentang pengguna saat ini dan hak aksesnya. </p><br><p>  Dengan objek kursor, kita dapat melakukan berbagai hal: menyaring, menelusuri catatan, dan juga, secara alami, menyisipkan, menghapus, dan memperbarui catatan.  Seluruh API kursor dijelaskan secara rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . </p><br><p>  Misalnya, kode contoh kita dapat dikembangkan sebagai berikut: </p><br><pre> <code class="java hljs">OrderHeaderCursor header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderHeaderCursor(context); header.setRange(<span class="hljs-string"><span class="hljs-string">"manager_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"manager1"</span></span>); header.tryFirst(); header.setCounter(header.getCounter() + <span class="hljs-number"><span class="hljs-number">1</span></span>); header.update();</code> </pre> <br><p>  Dalam contoh ini, kami menetapkan filter berdasarkan bidang manager_id, lalu kami menemukan catatan pertama menggunakan metode tryFirst. </p><br><div class="spoiler">  <b class="spoiler_title">(mengapa "mencoba")</b> <div class="spoiler_text"><p>  Metode <code>get</code> , <code>first</code> , <code>insert</code> , <code>update</code> memiliki dua opsi: tanpa awalan coba (hanya <code>get(...)</code> , dll.) Dan dengan awalan coba ( <code>tryGet(...)</code> , <code>tryFirst()</code> , dll.) .  Metode tanpa coba awalan melemparkan pengecualian jika database tidak memiliki data yang sesuai untuk melakukan tindakan.  Misalnya, first () akan melempar pengecualian jika tidak ada catatan yang masuk ke filter yang ditetapkan pada kursor.  Pada saat yang sama, metode dengan awalan coba tidak membuang pengecualian, tetapi sebaliknya mengembalikan nilai Boolean yang menandakan keberhasilan atau kegagalan operasi yang sesuai.  Praktik yang disarankan adalah menggunakan metode tanpa awalan coba sedapat mungkin.  Dengan cara ini, kode "swa-uji" dibuat, menandakan kesalahan waktu dalam logika dan / atau data basis data. </p></div></div><br><p>  Ketika <code>tryFirst</code> dipicu, variabel <code>tryFirst</code> diisi dengan data dari satu catatan, kita dapat membaca dan menetapkan nilai kepada mereka.  Dan ketika data dalam kursor sepenuhnya siap, kami menjalankan <code>update()</code> , dan menyimpan isi kursor dalam database. </p><br><p>  Masalah apa yang mungkin dipengaruhi oleh kode ini?  Tentu saja, munculnya kondisi balapan / pembaruan yang hilang!  Karena antara saat ketika kami menerima data sejalan dengan "tryFirst" dan saat ketika kami mencoba memperbarui data ini pada titik "pembaruan", orang lain sudah dapat menerima, memodifikasi, dan memperbarui data ini dalam database.  Setelah data dibaca, kursor tidak akan memblokir penggunaannya oleh pengguna lain!  Untuk melindungi dari pembaruan yang hilang, Celesta menggunakan prinsip kunci optimis.  Di setiap tabel, secara default, Celesta menciptakan bidang <code>recversion</code> , dan pada tingkat <code>recversion</code> UPDATE memicu penambahan nomor versi dan memeriksa bahwa data yang diperbarui memiliki versi yang sama dengan tabel.  Jika terjadi masalah, lempar pengecualian.  Anda dapat membaca lebih lanjut tentang ini di artikel artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perlindungan terhadap pembaruan yang hilang</a> ". </p><br><p>  Ingat kembali bahwa transaksi dikaitkan dengan objek CallContext.  Jika prosedur Celesta berhasil, komit terjadi.  Jika metode Celesta berakhir dengan pengecualian yang tidak ditangani, rollback terjadi.  Jadi, jika kesalahan terjadi dalam beberapa prosedur yang rumit, seluruh transaksi yang terkait dengan konteks panggilan dibatalkan, seolah-olah kita belum mulai melakukan apa pun dengan data, data tidak rusak.  Jika karena alasan tertentu Anda memerlukan komit di tengah, katakanlah, semacam prosedur besar, maka komit eksplisit dapat dieksekusi dengan memanggil <code>context.commit()</code> . </p><br><h2 id="testirovanie-metodov-rabotayuschih-s-dannymi">  Menguji Metode Data </h2><br><p>  Mari kita buat unit test yang memeriksa kebenaran metode layanan yang menyimpan <code>OrderDto</code> di database. </p><br><p>  Saat menggunakan JUnit5 dan ekstensi untuk JUnit5 tersedia di modul <code>celesta-unit</code> , ini sangat mudah.  Struktur tes adalah sebagai berikut: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CelestaTest</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocumentServiceTest</span></span></span><span class="hljs-class"> </span></span>{ DocumentService srv = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DocumentService(); <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">documentIsPutToDb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context)</span></span></span><span class="hljs-function"> </span></span>{ OrderDto doc =... srv.postOrder(context, doc); <span class="hljs-comment"><span class="hljs-comment">//Check the fact that records are in the database OrderHeaderCursor header = new OrderHeaderCursor(context); header.tryFirst(); assertEquals(doc.getId(), header.getId()); OrderLineCursor line = new OrderLineCursor(context); line.setRange("order_id", doc.getId()); assertEquals(2, line.count()); } }</span></span></code> </pre> <br><p>  Berkat anotasi <code>@CelestaTest</code> , yang merupakan ekstensi untuk JUnit5, kami dapat mendeklarasikan parameter <code>CallContext context</code> dalam metode pengujian.  Konteks ini sudah diaktifkan dan terikat ke database (in-memory H2), dan oleh karena itu kami tidak perlu membungkus kelas layanan dalam proxy - kami membuatnya menggunakan yang <code>new</code> , dan tidak menggunakan Spring.  Namun, jika perlu, menyuntikkan layanan ke dalam tes menggunakan alat Spring, tidak ada hambatan untuk ini. </p><br><p>  Kami membuat unit test dengan asumsi bahwa pada saat eksekusi mereka database akan benar-benar kosong, tetapi dengan struktur yang kita butuhkan, dan setelah eksekusi mereka kita tidak dapat khawatir tentang fakta bahwa kita meninggalkan "sampah" dalam database.  Tes ini dilakukan pada kecepatan yang sangat tinggi. </p><br><p>  Mari kita buat prosedur kedua yang mengembalikan JSON dengan nilai agregat yang menunjukkan berapa banyak produk yang kami pesan. </p><br><p>  Tes menulis dua pesanan ke database, setelah itu memeriksa nilai total yang dikembalikan oleh metode <code>getAggregateReport</code> baru: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportReturnsAggregatedQuantities</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context)</span></span></span><span class="hljs-function"> </span></span>{ srv.postOrder(context, . . .); srv.postOrder(context, . . .); Map&lt;String, Integer&gt; result = srv.getAggregateReport(context); assertEquals(<span class="hljs-number"><span class="hljs-number">5</span></span>, result.get(<span class="hljs-string"><span class="hljs-string">"A"</span></span>).intValue()); assertEquals(<span class="hljs-number"><span class="hljs-number">7</span></span>, result.get(<span class="hljs-string"><span class="hljs-string">"B"</span></span>).intValue()); }</code> </pre> <br><p>  Untuk mengimplementasikan metode <code>getAggregateReport</code> kita akan menggunakan tampilan OrderedQty, yang saya ingat, dalam file CelestaSQL terlihat seperti ini: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> item_id;</code> </pre> <br><p>  Permintaan standar: kami merangkum garis pesanan berdasarkan jumlah dan kelompok berdasarkan kode produk.  Kursor OrderedQtyCursor telah dibuat untuk tampilan, yang dapat kita gunakan.  Kami mendeklarasikan kursor ini, beralih di atasnya dan kumpulkan <code>Map&lt;String, Integer&gt;</code> diinginkan: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CelestaTransaction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAggregateReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Integer&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (OrderedQtyCursor ordered_qty = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderedQtyCursor(context)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (OrderedQtyCursor line : ordered_qty) { result.put(ordered_qty.getItem_id(), ordered_qty.getQty()); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h2 id="materializovannye-predstavleniya-celesta">  Tampilan Celesta terwujud </h2><br><p>  Mengapa menggunakan tampilan buruk untuk mendapatkan data agregat?  Pendekatan ini cukup bisa diterapkan, tetapi dalam kenyataannya menempatkan bom waktu di bawah seluruh sistem kami: setelah semua, pandangan, yang merupakan permintaan SQL, berjalan lebih lambat dan lebih lambat ketika data terakumulasi dalam sistem.  Dia harus meringkas dan mengelompokkan lebih banyak garis.  Bagaimana cara menghindarinya? </p><br><p>  Celesta mencoba mengimplementasikan semua tugas standar yang selalu dihadapi oleh programmer logika bisnis di tingkat platform. </p><br><p>  MS SQL Server memiliki konsep pandangan terwujud (terindeks), yang disimpan sebagai tabel dan diperbarui dengan cepat ketika data dalam tabel sumber berubah.  Jika kami bekerja di MS SQL Server "bersih", maka untuk kasus kami, penggantian tampilan dengan tampilan yang diindeks akan sesuai dengan yang kami butuhkan: mengambil laporan teragregasi tidak akan melambat karena data terkumpul, dan pekerjaan untuk memperbarui laporan teragregasi akan dilakukan saat ini memasukkan data ke dalam tabel baris pesanan dan juga tidak akan meningkat banyak dengan peningkatan jumlah baris. </p><br><p>  Tetapi jika kita bekerja dengan PostgreSQL melalui Celesta, apa yang bisa kita lakukan?  Definisikan kembali tampilan dengan menambahkan kata yang terwujud: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">materialized</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> item_id;</code> </pre> <br><p>  Mari kita mulai sistem dan melihat apa yang terjadi pada basis data. </p><br><p>  Kami akan melihat bahwa tampilan <code>OrderedQty</code> telah menghilang, dan tabel <code>OrderedQty</code> telah muncul <code>OrderedQty</code> .  Selain itu, karena tabel OrderLine diisi dengan data, informasi dalam tabel OrderedQty akan "diperbarui secara ajaib", seolah-olah OrderedQty akan menjadi tampilan. </p><br><p>  Tidak ada keajaiban di sini jika kita melihat pemicu yang dibangun di atas tabel <code>OrderLine</code> .  Celesta, setelah menerima tugas untuk membuat "tampilan terwujud", menganalisis kueri dan membuat pemicu pada tabel <code>OrderLine</code> yang memperbarui <code>OrderedQty</code> .  Dengan memasukkan satu kata kunci - <code>materialized</code> - ke dalam file CelestaSQL, kami memecahkan masalah penurunan kinerja, dan kode logika bisnis bahkan tidak perlu diubah! </p><br><p> ,    ,   , . «»  Celesta    ,    ,  JOIN-,    GROUP BY.     ,  , ,     ,      . .     . </p><br><h2 id="zaklyuchenie">  </h2><br><p>       Celesta.     —    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455746/">https://habr.com/ru/post/id455746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455736/index.html">Konsensus dalam cryptocurrency dengan penambangan hybrid dan Multi-PoW</a></li>
<li><a href="../id455738/index.html">Bagaimana cara menghasilkan satu miliar dengan memonetisasi data Anda?</a></li>
<li><a href="../id455740/index.html">Pembelajaran mesin di perusahaan investasi: kami mengklasifikasikan panggilan dukungan teknis</a></li>
<li><a href="../id455742/index.html">Membuat musik: ketika solusi sederhana mengungguli pembelajaran yang mendalam</a></li>
<li><a href="../id455744/index.html">Sistem pembangkitan lanskap labirin dengan realisme visual yang ditingkatkan [terjemahan artikel oleh Jinmo Kim]</a></li>
<li><a href="../id455754/index.html">Tes stratostat melayang. Peluncuran Rogozin dan LoRa ke stratosfer</a></li>
<li><a href="../id455756/index.html">Apakah [nikmat] th</a></li>
<li><a href="../id455758/index.html">Pertumbuhan Hacking di Retail Rocket: Dari Pencarian Hipotesis ke Teknik Pengujian</a></li>
<li><a href="../id455760/index.html">Keajaiban SwiftUI atau tentang Function builders</a></li>
<li><a href="../id455762/index.html">Pengantar singkat tentang rantai Markov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>