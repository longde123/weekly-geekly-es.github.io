<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõµ üë∞üèª üôãüèæ Sandbox am√©lior√© pour les scripts groovy üëåüèæ üîå ü§∞üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Depuis un traducteur: lors du d√©veloppement de la plateforme CUBA, nous mettons dans ce cadre la possibilit√© d'ex√©cuter des scripts personnalis√©s pour...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sandbox am√©lior√© pour les scripts groovy</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/445114/"><p><img src="https://habrastorage.org/webt/l7/d9/cg/l7d9cgoh4tjgptdfr68phnooab4.jpeg"></p><br><p>  <em>Depuis un traducteur: lors du d√©veloppement de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plateforme CUBA,</a> nous mettons dans ce cadre la possibilit√© d'ex√©cuter des scripts personnalis√©s pour une configuration plus flexible de la logique m√©tier de l'application.</em>  <em>Que cette opportunit√© soit bonne ou mauvaise (et nous ne parlons pas seulement de CUBA) est d√©battue depuis longtemps, mais le fait que le contr√¥le de l'ex√©cution des scripts utilisateur soit n√©cessaire ne soul√®ve aucune question.</em>  <em>L'une des fonctionnalit√©s utiles de Groovy pour g√©rer l'ex√©cution de scripts personnalis√©s est pr√©sent√©e dans cette traduction de C√©dric Champeau.</em>  <em>Malgr√© le fait qu'il ait r√©cemment quitt√© l'√©quipe de d√©veloppement de Groovy, la communaut√© des programmeurs semble profiter longtemps de ses travaux.</em> </p><br><p>  L'un des moyens les plus couramment utilis√©s pour utiliser Groovy consiste √† utiliser des scripts, car Groovy facilite l'ex√©cution dynamique de code lors de l'ex√©cution.  Selon l'application, les scripts peuvent √™tre localis√©s √† diff√©rents endroits: le syst√®me de fichiers, la base de donn√©es, les services distants ... mais surtout, le d√©veloppeur de l'application ex√©cutant les scripts ne les √©crit pas forc√©ment.  De plus, les scripts peuvent fonctionner dans un environnement limit√© (m√©moire limit√©e, limite sur le nombre de descripteurs de fichiers, runtime ...), ou vous pouvez emp√™cher l'utilisateur d'utiliser toutes les fonctionnalit√©s du langage dans le script. </p><br><p>  <strong>Ce message vous le dira.</strong> </p><br><ul><li>  pourquoi groovy est bon pour √©crire dsl interne </li><li>  quelles sont ses fonctionnalit√©s en termes de s√©curit√© de votre application </li><li>  comment configurer la compilation pour am√©liorer DSL </li><li> sur la valeur de <code>SecureASTCustomizer</code> </li><li>  √† propos des extensions de contr√¥le de type </li><li>  comment utiliser les extensions de contr√¥le de type pour rendre le sandboxing efficace </li></ul><a name="habracut"></a><br><p>  Par exemple, imaginez ce que vous devez faire pour que l'utilisateur puisse calculer des expressions math√©matiques.  Une option d'impl√©mentation consiste √† incorporer un DSL interne, √† cr√©er un analyseur et enfin un interpr√©teur pour ces expressions.  Pour ce faire, bien s√ªr, vous devrez travailler, mais si vous devez augmenter la productivit√©, par exemple, en g√©n√©rant du bytecode pour les expressions au lieu de les calculer dans l'interpr√©teur ou en utilisant la mise en cache des classes g√©n√©r√©es lors de l'ex√©cution, alors Groovy est une excellente option. </p><br><p>  Il existe de nombreuses options d√©crites dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> , mais l'exemple le plus simple utilise simplement la classe <code>Eval</code> : </p><br><p> <code>Example.java</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = (Integer) Eval.me(<span class="hljs-string"><span class="hljs-string">"1+1"</span></span>);</code> </pre> <br><p>  Le code <code>1+1</code> est analys√©, compil√© en bytecode, charg√© et ex√©cut√© par Groovy en runtime.  Bien s√ªr, le code de cet exemple est tr√®s simple et vous devrez ajouter des param√®tres, mais l'id√©e est que le code ex√©cutable peut √™tre arbitraire.  Et ce n'est peut-√™tre pas exactement ce dont vous avez besoin.  Dans la calculatrice, vous devez autoriser quelque chose comme ceci: </p><br><pre> <code class="plaintext hljs">1+1 x+y 1+(2*x)**y cos(alpha)*r v=1+x</code> </pre> <br><p>  mais certainement pas </p><br><pre> <code class="plaintext hljs">println 'Hello' (0..100).each { println 'Blah' } Pong p = new Pong() println(new File('/etc/passwd').text) System.exit(-1) Eval.me('System.exit(-1)') // a script within a script!</code> </pre> <br><p>  C'est ici que les difficult√©s commencent, et il devient √©galement clair que nous devons r√©soudre plusieurs probl√®mes: </p><br><ul><li>  limiter la grammaire d'une langue √† un sous-ensemble de ses capacit√©s </li><li>  emp√™cher les utilisateurs d'ex√©cuter le code </li><li>  emp√™cher l'ex√©cution de code malveillant </li></ul><br><p>  L'exemple avec la calculatrice est assez simple, mais pour les DSL plus complexes, les gens peuvent ne pas remarquer qu'ils √©crivent du code probl√©matique, surtout si DSL est si simple que les <em>d√©veloppeurs ne</em> peuvent pas l'utiliser. </p><br><p>  Il y a quelques ann√©es, j'√©tais dans cette situation.  J'ai d√©velopp√© un moteur qui ex√©cutait des ¬´scripts¬ª Groovy √©crits par des linguistes.  Un probl√®me, par exemple, √©tait qu'ils pouvaient cr√©er par inadvertance une boucle sans fin.  Le code a √©t√© ex√©cut√© sur le serveur, et il est apparu un thread d√©vorant 100% du CPU, apr√®s quoi il fallait red√©marrer le serveur d'applications.  J'ai d√ª chercher un moyen de r√©soudre le probl√®me sans affecter les performances DSL, les outils ou les applications. </p><br><p>  En fait, de nombreuses personnes ont des besoins similaires.  Au cours des 4 derni√®res ann√©es, j'ai parl√© √† beaucoup de gens qui ont eu la m√™me question: <em>comment puis-je emp√™cher les utilisateurs de faire des b√™tises dans les scripts Groovy?</em> </p><br><h2 id="kastomayzery-kompilyacii">  Compilateurs de personnalisation </h2><br><p>  √Ä cette √©poque, j'avais d√©j√† ma propre d√©cision et je savais que d'autres personnes avaient √©galement d√©velopp√© quelque chose de similaire.  Au final, Guillaume Laforge m'a propos√© de cr√©er un m√©canisme dans le noyau Groovy pour aider √† r√©soudre ces probl√®mes.  Il est apparu dans Groovy 1.8.0 en tant que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">personnalisateurs de compilation</a> . </p><br><p>  Les personnalisateurs de compilation sont un ensemble de classes qui modifient le processus de compilation des scripts Groovy.  Vous pouvez √©crire votre propre personnalisateur, mais Groovy fournit: </p><br><ul><li>  personnalisateur d'importation qui ajoute implicitement des importations aux scripts afin que les utilisateurs n'aient pas besoin d'ajouter des descriptions d'importation </li><li>  personnalisation des transformations AST (arbre de syntaxe abstraite), vous permettant d'ajouter des transformations AST directement aux scripts </li><li>  Personnaliseur AST s√©curis√© restreignant les constructions grammaticales et syntaxiques d'un langage </li></ul><br><p>  Le personnalisateur des transformations AST m'a aid√© √† r√©soudre le probl√®me de boucle sans fin avec la transformation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>@ThreadInterrupt</code></a> , mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SecureASTCustomizer</a> est la chose qui est probablement la plus mal comprise dans la grande majorit√© des cas. </p><br><p>  Je devrais m'en excuser.  Ensuite, je ne pouvais pas trouver un meilleur nom.  La partie la plus importante du nom ¬´SecureASTCustomizer¬ª est l' <strong>AST</strong> .  Le but de ce m√©canisme √©tait de limiter l'acc√®s √† certaines fonctions AST.  Le mot ¬´s√©curis√©¬ª dans le titre est g√©n√©ralement superflu, et j'expliquerai pourquoi.  Il y a m√™me un article de blog de Kosuke Kawaguchi, c√©l√®bre de Jenkins, intitul√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Fatal Groovy SecureASTCustomizer¬ª</a> .  Et tout y est √©crit tr√®s correctement.  SecureASTCustomizer n'a pas √©t√© con√ßu pour le sandboxing.  Il a √©t√© cr√©√© pour limiter le langage au moment de la compilation, mais pas lors de l'ex√©cution.  Maintenant, je pense que le meilleur nom serait <em>GrammarCustomizer</em> .  Mais, comme vous le savez certainement, il y a trois difficult√©s en informatique: l'invalidation du cache, l'invention de noms et une erreur par unit√©. </p><br><p>  Imaginez maintenant que vous envisagez de personnaliser le personnalisateur AST comme un moyen d'assurer la s√©curit√© de votre script, et votre t√¢che consiste √† emp√™cher l'utilisateur d' <code>System.exit</code> partir du script.  La documentation indique que les appels peuvent √™tre interdits dans des r√©cepteurs sp√©ciaux en cr√©ant des listes noires ou blanches.  Si la s√©curit√© est n√©cessaire, je recommande toujours des listes blanches qui indiquent strictement ce qui est autoris√©, mais pas des listes noires qui interdisent quoi que ce soit.  Parce que les pirates pensent toujours √† ce que vous n'auriez peut-√™tre pas pens√©.  Je vais vous donner un exemple. </p><br><p>  Voici comment configurer un moteur de script de bac √† sable primitif √† l'aide de <code>SecureASTCustomizer</code> .  Bien que je puisse les √©crire dans Groovy, je donne des exemples de configuration Java pour rendre la diff√©rence entre le code d'int√©gration et les scripts plus explicites. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); SecureASTCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureASTCustomizer(); customizer.setReceiversBlackList(Arrays.asList(System.class.getName())); conf.addCompilationCustomizers(customizer); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(conf); Object v = shell.evaluate(<span class="hljs-string"><span class="hljs-string">"System.exit(-1)"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Result = "</span></span> +v); } }</code> </pre> <br><ol><li>  cr√©er la configuration du compilateur </li><li>  cr√©er un personnalisateur AST s√©curis√© </li><li>  d√©clarer que la classe <code>System</code> tant que r√©cepteur d'appels de m√©thode est sur liste noire </li><li>  ajouter un personnalisateur √† la configuration du compilateur </li><li>  lier la configuration avec le script shell, c'est-√†-dire essayer de cr√©er un sandbox </li><li>  ex√©cuter le "mauvais" script </li><li>  afficher le r√©sultat de l'ex√©cution du script </li></ol><br><p>  Si vous ex√©cutez cette classe, une erreur se produira lors de l'ex√©cution du script: </p><br><pre> <code class="plaintext hljs">General error during canonicalization: Method calls not allowed on [java.lang.System] java.lang.SecurityException: Method calls not allowed on [java.lang.System]</code> </pre> <br><p>  Cette conclusion est √©mise par une application avec un personnalisateur AST s√©curis√©, qui ne permet pas l'ex√©cution de m√©thodes de la classe <code>System</code> .  Succ√®s!  Nous avons donc prot√©g√© notre script!  Mais attendez une minute ... </p><br><h2 id="secureastcustomizer-vzloman">  SecureASTCustomizer est pirat√©! </h2><br><p>  La protection, par exemple?  Et si je fais √ßa: </p><br><pre> <code class="java hljs">def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Si vous r√©ex√©cutez le programme, vous verrez qu'il se bloque <strong>sans</strong> erreur et <strong>sans</strong> afficher le r√©sultat √† l'√©cran.  Le code de sortie du processus est -1, ce qui signifie que le script utilisateur a √©t√© ex√©cut√©!  Qu'est-il arriv√©?  Au moment de la compilation, le personnalisateur AST s√©curis√© n'est pas en mesure de reconna√Ætre que <code>c.exit</code> est un appel √† la m√©thode <code>System</code> en principe car il fonctionne au niveau AST!  Il analyse l'appel de m√©thode, et dans ce cas, l'appel de m√©thode est <code>c.exit(-1)</code> , puis il d√©termine le r√©cepteur et v√©rifie s'il est dans la liste blanche (ou noire).  Dans ce cas, le r√©cepteur est <code>c</code> , cette variable est <strong>d√©clar√©e via def</strong> , et cela revient √† le d√©clarer en tant <code>Object</code> , et le personnalisateur AST s√©curis√© pensera que le type de la variable <code>c</code> est <code>Object</code> , pas <code>System</code> ! </p><br><p>  En g√©n√©ral, il existe de <strong>nombreuses</strong> fa√ßons de contourner les diff√©rentes configurations cr√©√©es sur le personnalisateur AST s√©curis√©.  En voici quelques-unes: </p><br><pre> <code class="java hljs">((Object)System).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) Class.forName(<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span>).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span> as Class).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.<span class="hljs-function"><span class="hljs-function">exit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br><p>  et il peut y en avoir <strong>beaucoup</strong> plus.  La nature dynamique de Groovy emp√™che la possibilit√© de r√©soudre ces probl√®mes au moment de la compilation.  Cependant, une solution existe.  Une option consiste √† s'appuyer sur le gestionnaire de s√©curit√© JVM standard.  Cependant, il s'agit d'une solution lourde et volumineuse imm√©diatement pour l'ensemble du syst√®me, ce qui √©quivaut √† tirer un canon sur des moineaux.  De plus, cela ne fonctionne pas dans tous les cas, par exemple, si vous souhaitez interdire la lecture des fichiers, mais pas la cr√©ation ... </p><br><p>  Cette limitation - plut√¥t un chagrin pour beaucoup d'entre nous - a conduit √† la cr√©ation d'une solution bas√©e sur les <strong>contr√¥les √† l'ex√©cution</strong> .  Ce type de v√©rification n'a pas de tels probl√®mes.  Par exemple, parce que vous conna√Ætrez le type de r√©cepteur r√©el du message avant de commencer la validation de l'appel de m√©thode.  Les impl√©mentations suivantes sont particuli√®rement int√©ressantes: </p><br><ul><li>  <a href="">SecureScript</a> par Jim White </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groovy Sandbox</a> par Kosuke Kawaguchi </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groovy Sandbox</a> par Simon Temple </li></ul><br><p>  Cependant, aucune de ces impl√©mentations n'est compl√®tement fiable et s√ªre.  Par exemple, la version de Kosuke est bas√©e sur le piratage de l'impl√©mentation interne de la mise en cache du site d'appel.  Le probl√®me est qu'il n'est pas compatible avec la version dynamique invoqu√©e de Groovy, et ces classes internes ne seront pas dans les futures versions de Groovy.  La version de Simon, quant √† elle, est bas√©e sur des transformations AST, mais laisse de nombreux trous potentiels. </p><br><p>  En cons√©quence, mes amis Corinne Crisch, Fabrice Matrat et Sebastian Blanc, et moi avons d√©cid√© de cr√©er un nouveau m√©canisme de sandboxing lors de l'ex√©cution, qui n'aura pas de probl√®mes tels que ces projets.  Nous avons commenc√© √† le mettre en ≈ìuvre lors d'un hackathon √† Nice, et lors de la conf√©rence Greach de l'ann√©e derni√®re, nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fait un rapport √† ce sujet</a> .  Ce m√©canisme est bas√© sur des transformations AST et r√©√©crit essentiellement le code √† v√©rifier avant chaque appel de m√©thode, tenter d'acc√©der au champ de classe, incr√©menter une variable, une expression binaire ... Cette <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impl√©mentation</a> n'est toujours pas pr√™te, et peu de travail a √©t√© fait dessus, donc car je me suis rendu compte que le probl√®me avec les m√©thodes et les param√®tres appel√©s "implicitement ceci" n'a pas encore √©t√© r√©solu, comme, par exemple, dans les constructeurs: </p><br><pre> <code class="plaintext hljs">xml { cars { // cars is a method call on an implicit this: "this".cars(...) car(make:'Renault', model: 'Clio') } }</code> </pre> <br><p>  √Ä ce jour, je n'ai toujours pas trouv√© de moyen de r√©soudre ce probl√®me en raison de l'architecture du protocole de m√©ta-objet dans Groovy, qui est bas√© sur le fait que le r√©cepteur l√®ve une exception lorsqu'il ne trouve pas la m√©thode, avant de passer √† un autre r√©cepteur.  En bref, cela signifie que vous ne pouvez pas trouver le type de r√©cepteur avant l'appel de m√©thode r√©el.  Et si l'appel est pass√©, alors c'est trop tard ... </p><br><p>  Et jusqu'√† r√©cemment, je n'avais pas de solution optimale √† ce probl√®me dans le cas o√π le script ex√©cutable utilise les propri√©t√©s dynamiques du langage.  Mais le moment est venu d'expliquer comment vous pouvez am√©liorer consid√©rablement la situation si vous √™tes pr√™t √† sacrifier un peu le dynamisme de la langue. </p><br><h2 id="proverka-tipov">  V√©rification de type </h2><br><p>  Revenons au probl√®me principal avec SecureASTCustomizer: il fonctionne avec une arborescence de syntaxe abstraite et n'a pas d'informations sur les types de messages et les r√©cepteurs sp√©cifiques.  Mais avec Groovy 2, Groovy a ajout√© la compilation, et dans Groovy 2.1, nous avons ajout√© des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extensions pour la v√©rification de type</a> . </p><br><p>  Les extensions pour la v√©rification de type sont une chose tr√®s puissante: elles permettent au d√©veloppeur Groovy DSL d'aider le compilateur avec l'inf√©rence de type, et permettent √©galement la g√©n√©ration d'erreurs de compilation dans les cas o√π elles ne se produisent g√©n√©ralement pas.  Ces extensions sont utilis√©es en interne par Groovy pour prendre en charge un compilateur statique, par exemple, lors de l'impl√©mentation de traits ou d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteur de mod√®le de balisage</a> . </p><br><p>  Et si, au lieu d'utiliser les r√©sultats de l'analyseur, nous pouvions nous fier aux informations du m√©canisme de v√©rification de type?  Prenez le code que notre pirate a essay√© d'√©crire: </p><br><p> <code>((Object)System).exit(-1)</code> </p> <br><p>  Si vous activez les v√©rifications de type, le code ne compile pas: </p><br><pre> <code class="plaintext hljs">1 compilation error: [Static type checking] - Cannot find matching method java.lang.Object#exit(java.lang.Integer). Please check if the declared type is right and if the method exists.</code> </pre> <br><p>  Donc, ce code ne compile plus.  Et si on prend ce code: </p><br><pre> <code class="java hljs">def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Comme vous pouvez le voir, il passe la v√©rification de type, envelopp√© dans une m√©thode et ex√©cut√© √† l'aide de la commande <code>groovy</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@groovy</span></span>.transform.TypeChecked <span class="hljs-comment"><span class="hljs-comment">// or even @CompileStatic void foo() { def c = System c.exit(-1) } foo()</span></span></code> </pre> <br><p>  Le v√©rificateur de type d√©tecte que la m√©thode de <code>exit</code> est appel√©e √† partir de la classe <code>System</code> et est valide.  Cela ne nous aidera pas ici.  Mais ce que nous savons, c'est que si ce code passe la v√©rification de type, cela signifie que le compilateur reconna√Æt l'appel au r√©cepteur avec le type <code>System</code> .  En g√©n√©ral, l'id√©e est d'interdire un appel avec une extension pour la v√©rification de type. </p><br><h2 id="prostoe-rasshirenie-dlya-proverki-tipov">  Extension simple pour la v√©rification de type </h2><br><p>  Avant de nous plonger dans le sandboxing en d√©tail, essayons de ¬´s√©curiser¬ª notre script √† l'aide d'une extension standard pour la v√©rification de type.  L'enregistrement d'une telle extension est facile: il suffit de d√©finir le param√®tre d' <code>extensions</code> pour l'annotation <code>@TypeChecked</code> (ou <code>@CompileStatic</code> si vous utilisez une compilation statique): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TypeChecked</span></span>(extensions=[<span class="hljs-string"><span class="hljs-string">'SecureExtension1.groovy'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) } foo()</code> </pre> <br><p>  La recherche d'extensions aura lieu dans le chemin de classe au format du code source (vous pouvez cr√©er des extensions pr√©compil√©es pour la v√©rification de type, mais nous ne les consid√©rerons pas dans cet article): </p><br><p> <code>SecureExtension1.groovy</code> </p> <br><pre> <code class="java hljs">onMethodSelection { expr, methodNode -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodNode.declaringClass.name==<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span>) { addStaticTypeError(<span class="hljs-string"><span class="hljs-string">"Method call is not allowed!"</span></span>, expr) } }</code> </pre> <br><ol><li>  lorsque le v√©rificateur de type s√©lectionne une m√©thode √† appeler </li><li>  si la m√©thode appartient √† la classe <code>System</code> </li><li>  puis laissez le v√©rificateur de type g√©n√©rer une erreur </li></ol><br><p>  C‚Äôest tout ce dont vous avez besoin.  Maintenant, ex√©cutez √† nouveau le code et vous verrez une erreur de compilation! </p><br><pre> <code class="plaintext hljs">/home/cchampeau/tmp/securetest.groovy: 6: [Static type checking] - Method call is not allowed! @ line 6, column 3. c.exit(-1) ^ 1 error</code> </pre> <br><p>  Cette fois, gr√¢ce au v√©rificateur de type, <code>c</code> reconnu comme une instance de la classe <code>System</code> , et nous pouvons interdire l'appel.  Il s'agit d'un exemple tr√®s simple, et il ne montre pas tout ce qui peut √™tre fait avec le personnalisateur AST s√©curis√© en termes de configuration.  Dans l'extension que nous avons <strong>√©crite</strong> , les ch√®ques sont <strong>cod√©s en dur</strong> , mais il pourrait √™tre pr√©f√©rable de les rendre personnalisables.  Alors, compliquons l'exemple. </p><br><p>  Supposons que votre application calcule certaines m√©triques d'un document et permette aux utilisateurs de les personnaliser.  Dans ce cas, DSL: </p><br><ul><li>  fonctionnera (au moins) la variable de <code>score</code> </li><li>  permet aux utilisateurs d'effectuer des op√©rations math√©matiques (y compris appeler les m√©thodes <em>cos</em> , <em>abs</em> , ...) </li><li>  doit interdire toutes les autres m√©thodes </li></ul><br><p>  Exemple de script utilisateur: </p><br><p> <code>abs(cos(1+score))</code> </p> <br><p>  Cette DSL est facile √† configurer.  Ceci est une variante de ce que nous avons d√©fini ci-dessus: </p><br><p> <code>Sandbox.java</code> </p> <br><pre> <code class="java hljs">CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); ImportCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImportCustomizer(); customizer.addStaticStars(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>); conf.addCompilationCustomizers(customizer); Binding binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Binding(); binding.setVariable(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>d); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(binding,conf); Double userScore = (Double) shell.evaluate(<span class="hljs-string"><span class="hljs-string">"abs(cos(1+score))"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"userScore = "</span></span> + userScore);</code> </pre> <br><ol><li>  ajouter un personnalisateur d'importation qui ajoutera l' <code>import static java.lang.Math.*</code> √† tous les scripts </li><li>  rendre la variable de <code>score</code> disponible pour le script </li><li>  ex√©cuter le script </li></ol><br><p>  <em>Il existe des moyens de mettre en cache des scripts au lieu de les analyser et de les compiler √† chaque fois.</em>  <em>Consultez la documentation pour plus de d√©tails.</em> </p><br><p>  Donc, notre script fonctionne, mais rien n'emp√™che le pirate de lancer du code malveillant.  Puisque nous pr√©voyons d'utiliser la v√©rification de type, je recommanderais d'utiliser la transformation <code>@CompileStatic</code> : </p><br><ul><li>  il active la v√©rification de type dans le script, et nous pourrons effectuer des v√©rifications suppl√©mentaires gr√¢ce √† l'extension pour la v√©rification de type </li><li>  am√©liorer les performances des scripts </li></ul><br><p>  <code>@CompileStatic</code> implicitement l'annotation <code>@CompileStatic</code> √† vos scripts est assez simple.  Il vous suffit de mettre √† jour la configuration du compilateur: </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer(CompileStatic.class); conf.addCompilationCustomizers(astcz);</code> </pre> <br><p>  Maintenant, si vous essayez de r√©ex√©cuter le script, vous verrez une erreur de compilation: </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - The variable [score] is undeclared. @ line 1, column 11. abs(cos(1+score)) ^ Script1.groovy: 1: [Static type checking] - Cannot find matching method int#plus(java.lang.Object). Please check if the declared type is right and if the method exists. @ line 1, column 9. abs(cos(1+score)) ^ 2 errors</code> </pre> <br><p>  Qu'est-il arriv√©?  Si vous lisez le script du point de vue du compilateur, il devient clair qu'il ne sait rien de la variable "score".  Mais <strong>vous, en</strong> tant que d√©veloppeur, savez qu'il s'agit d'une <code>double</code> variable, mais le compilateur ne peut pas la produire.  Pour cela, des extensions pour la v√©rification de type sont cr√©√©es: vous pouvez donner au compilateur des informations suppl√©mentaires, et la compilation fonctionnera bien.  Dans ce cas, nous devons indiquer que la variable de <code>score</code> est de type <code>double</code> . </p><br><p>  Par cons√©quent, vous pouvez l√©g√®rement modifier la fa√ßon dont l'annotation <code>@CompileStatic</code> est <code>@CompileStatic</code> : </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension2.groovy"</span></span>)), CompileStatic.class);</code> </pre> <br><p>  Cela "√©mule" le code annot√© par <code>@CompileStatic(extensions=['SecureExtension2.groovy'])</code> .  Maintenant, bien s√ªr, nous devons √©crire une extension qui reconna√Ætra la variable de <code>score</code> : </p><br><p> <code>SecureExtension2.groovy</code> </p> <br><pre> <code class="java hljs">unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name==<span class="hljs-string"><span class="hljs-string">'score'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, double_TYPE) } }</code> </pre> <br><ol><li>  dans le cas o√π le v√©rificateur de type ne peut pas d√©terminer la variable </li><li>  si le nom de la variable est <code>score</code> </li><li>  laissez le compilateur d√©finir la variable dynamiquement avec le type <code>double</code> </li></ol><br><p>  Une description compl√®te des extensions DSL pour la v√©rification de type peut √™tre trouv√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cette section de la documentation</a> , mais il existe un exemple de mode de compilation combin√©: le compilateur ne peut pas d√©finir de variable de <code>score</code> .  En tant que d√©veloppeur DSL, vous <strong>savez</strong> que la variable est en fait son type - <code>double</code> , donc l'appel √† <code>makeDynamic</code> l√† pour dire: "ok, ne vous inqui√©tez pas, je sais ce que je fais, cette variable peut √™tre d√©finie dynamiquement avec le <code>double</code> type "  C'est tout! </p><br><h2 id="pervoe-zavershennoe-secure-rasshirenie">  Premi√®re extension "s√©curis√©e" termin√©e </h2><br><p>  Maintenant, mettons tout cela ensemble.  Nous avons √©crit une extension de v√©rification de type qui emp√™che les appels aux m√©thodes de la classe <code>System</code> une part et une autre qui d√©finit la variable de <code>score</code> de l'autre.  Donc, si nous les connectons, nous obtenons la premi√®re extension compl√®te pour la v√©rification de type: </p><br><p> <code>SecureExtension3.groovy</code> </p> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// disallow calls on System onMethodSelection { expr, methodNode -&gt; if (methodNode.declaringClass.name=='java.lang.System') { addStaticTypeError("Method call is not allowed!", expr) } } // resolve the score variable unresolvedVariable { var -&gt; if (var.name=='score') { return makeDynamic(var, double_TYPE) } }</span></span></code> </pre> <br><p>  N'oubliez pas de mettre √† jour la configuration de votre classe Java pour utiliser la nouvelle extension pour la v√©rification de type: </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension3.groovy"</span></span>)), CompileStatic.class);</code> </pre> <br><p>  Ex√©cutez √† nouveau le code - cela fonctionne toujours.  Maintenant, essayez ceci: </p><br><pre> <code class="plaintext hljs">abs(cos(1+score)) System.exit(-1)</code> </pre> <br><p>  La compilation du script se bloquera avec une erreur: </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - Method call is not allowed! @ line 1, column 19. abs(cos(1+score));System.exit(-1) ^ 1 error</code> </pre> <br><p>  F√©licitations, vous venez d'√©crire la premi√®re extension de v√©rification de type qui emp√™che l'ex√©cution de code malveillant! </p><br><h2 id="uluchshenie-konfiguracii-rasshireniya">  Configuration d'extension am√©lior√©e </h2><br><p>  Donc, tout va bien, nous pouvons interdire les appels aux m√©thodes de la classe <code>System</code> , mais il semble que de nouvelles vuln√©rabilit√©s seront bient√¥t d√©couvertes, et nous devrons emp√™cher le lancement de code malveillant.  Ainsi, au lieu de tout coder en dur dans l'extension, nous allons essayer de rendre notre extension universelle et personnalisable.  C'est probablement le plus difficile, car il n'y a aucun moyen direct de passer le contexte √† l'extension pour la v√©rification de type.  L'id√©e est donc bas√©e sur l'utilisation d'une variable locale de thread (m√©thode de la courbe, oui) pour transmettre les donn√©es de configuration aux v√©rificateurs de type. </p><br><p>  Tout d'abord, nous allons personnaliser la liste des variables.  Voici √† quoi ressemblera le code Java: </p><br><p> <code>Sandbox.java</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String VAR_TYPES = <span class="hljs-string"><span class="hljs-string">"sandboxing.variable.types"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ThreadLocal&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); ImportCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImportCustomizer(); customizer.addStaticStars(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>); ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension4.groovy"</span></span>)), CompileStatic.class); conf.addCompilationCustomizers(astcz); conf.addCompilationCustomizers(customizer); Binding binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Binding(); binding.setVariable(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>d); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Map&lt;String,ClassNode&gt; variableTypes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, ClassNode&gt;(); variableTypes.put(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, ClassHelper.double_TYPE); Map&lt;String,Object&gt; options = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, Object&gt;(); options.put(VAR_TYPES, variableTypes); COMPILE_OPTIONS.set(options); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(binding, conf); Double userScore = (Double) shell.evaluate(<span class="hljs-string"><span class="hljs-string">"abs(cos(1+score));System.exit(-1)"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"userScore = "</span></span> + userScore); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { COMPILE_OPTIONS.remove(); } } }</code> </pre> <br><ol><li>  <code>ThreadLocal</code> ,          </li><li>    ‚Äî <code>SecureExtension4.groovy</code> </li><li> <code>variableTypes</code> ‚Äî   ‚Äú  ‚Üí  ‚Äù </li><li>      <code>score</code> </li><li> <code>options</code> ‚Äî     </li><li>   "variable types"     VAR_TYPES </li><li>     thread local </li><li> ,    ,     thread local </li></ol><br><p>          : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) } }</code> </pre> <br><ol><li>        thread local </li><li>      ,      , </li><li>   type checker       </li></ol><br><p>         thread local,    ,  type checker  . ,      <code>unresolvedVariable</code> ,    ,  ,    type checker,   .  ,     .   ! </p><br><p>           .        ,       . </p><br><h2 id="konfiguraciya-belogo-spiska-metodov">     </h2><br><p>    .   ,       .      ,         ,     . ,  <code>System.exit</code> ,   : </p><br><pre> <code class="plaintext hljs">java.lang.System#exit(int)</code> </pre> <br><p> ,     Java,    : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String WHITELIST_PATTERNS = <span class="hljs-string"><span class="hljs-string">"sandboxing.whitelist.patterns"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... public static void main(String[] args) { // ... try { Map&lt;String,ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;(); variableTypes.put("score", ClassHelper.double_TYPE); Map&lt;String,Object&gt; options = new HashMap&lt;String, Object&gt;(); List&lt;String&gt; patterns = new ArrayList&lt;String&gt;(); patterns.add("java\\.lang\\.Math#"); options.put(VAR_TYPES, variableTypes); options.put(WHITELIST_PATTERNS, patterns); COMPILE_OPTIONS.set(options); GroovyShell shell = new GroovyShell(binding, conf); Double userScore = (Double) shell.evaluate("abs(cos(1+score));System.exit(-1)"); System.out.println("userScore = " + userScore); } finally { COMPILE_OPTIONS.remove(); } } }</span></span></code> </pre> <br><ol><li>    </li><li>    <code>java.lang.Math</code>   </li><li>        </li></ol><br><p>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> groovy.transform.CompileStatic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.MethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.Parameter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.ExtensionMethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassNode node)</span></span></span><span class="hljs-function"> </span></span>{ node.isArray()?<span class="hljs-string"><span class="hljs-string">"${prettyPrint(node.componentType)}[]"</span></span>:node.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toMethodDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExtensionMethodNode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toMethodDescriptor(node.extensionMethodNode) } def sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() sb.append(node.declaringClass.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) sb.append(node.name) sb.append(<span class="hljs-string"><span class="hljs-string">'('</span></span>) sb.append(node.parameters.collect { Parameter it -&gt; prettyPrint(it.originType) }.join(<span class="hljs-string"><span class="hljs-string">','</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">')'</span></span>) sb } def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS] onMethodSelection { expr, MethodNode methodNode -&gt; def descr = toMethodDescriptor(methodNode) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!whiteList.any { descr =~ it }) { addStaticTypeError(<span class="hljs-string"><span class="hljs-string">"You tried to call a method which is not allowed, what did you expect?: $descr"</span></span>, expr) } } unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) } }</code> </pre> <br><ol><li>       <code>MethodNode</code> </li><li>     thread local </li><li>       </li><li>        ,   </li></ol><br><p>      ,    : </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - You tried to call a method which is not allowed, what did you expect?: java.lang.System#exit(int) @ line 1, column 19. abs(cos(1+score));System.exit(-1) ^ 1 error</code> </pre> <br><p> ,  !        ,   <strong>  </strong> , <strong>  </strong>  .    ,      !     ,       ,       . ,   (  <code>foo.text</code> ,     <code>foo.getText()</code> ). </p><br><h2 id="sobiraem-vse-vmeste">    </h2><br><p>     ,    type checker'    "property selection", ,   .      ,         ,  .         ,     ,       ‚Äî    .     . </p><br><p> <code>SandboxingTypeCheckingExtension.groovy</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> groovy.transform.CompileStatic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassCodeVisitorSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassHelper <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.MethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.Parameter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.expr.PropertyExpression <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.control.SourceUnit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.ExtensionMethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SandboxingTypeCheckingExtension</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyTypeCheckingExtensionSupport</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeCheckingDSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassNode node)</span></span></span><span class="hljs-function"> </span></span>{ node.isArray()?<span class="hljs-string"><span class="hljs-string">"${prettyPrint(node.componentType)}[]"</span></span>:node.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toMethodDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExtensionMethodNode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toMethodDescriptor(node.extensionMethodNode) } def sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() sb.append(node.declaringClass.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) sb.append(node.name) sb.append(<span class="hljs-string"><span class="hljs-string">'('</span></span>) sb.append(node.parameters.collect { Parameter it -&gt; prettyPrint(it.originType) }.join(<span class="hljs-string"><span class="hljs-string">','</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">')'</span></span>) sb } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Fetch white list of regular expressions of authorized method calls def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS] def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] onMethodSelection { expr, MethodNode methodNode -&gt; def descr = toMethodDescriptor(methodNode) if (!whiteList.any { descr =~ it }) { addStaticTypeError("You tried to call a method which is not allowed, what did you expect?: $descr", expr) } } unresolvedVariable { var -&gt; if (isDynamic(var) &amp;&amp; typesOfVariables[var.name]) { storeType(var, typesOfVariables[var.name]) handled = true } } // handling properties (like foo.text) is harder because the type checking extension // does not provide a specific hook for this. Harder, but not impossible! afterVisitMethod { methodNode -&gt; def visitor = new PropertyExpressionChecker(context.source, whiteList) visitor.visitMethod(methodNode) } } private class PropertyExpressionChecker extends ClassCodeVisitorSupport { private final SourceUnit unit private final List&lt;String&gt; whiteList PropertyExpressionChecker(final SourceUnit unit, final List&lt;String&gt; whiteList) { this.unit = unit this.whiteList = whiteList } @Override protected SourceUnit getSourceUnit() { unit } @Override void visitPropertyExpression(final PropertyExpression expression) { super.visitPropertyExpression(expression) ClassNode owner = expression.objectExpression.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER) if (owner) { if (expression.spreadSafe &amp;&amp; StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(owner, classNodeFor(Collection))) { owner = typeCheckingVisitor.inferComponentType(owner, ClassHelper.int_TYPE) } def descr = "${prettyPrint(owner)}#${expression.propertyAsString}" if (!whiteList.any { descr =~ it }) { addStaticTypeError("Property is not allowed: $descr", expression) } } } } }```     sandbox',     assert' ,  ,     : ``Sandbox.java`` ```java public class Sandbox { public static final String WHITELIST_PATTERNS = "sandboxing.whitelist.patterns"; public static final String VAR_TYPES = "sandboxing.variable.types"; public static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = new ThreadLocal&lt;Map&lt;String, Object&gt;&gt;(); public static void main(String[] args) { CompilerConfiguration conf = new CompilerConfiguration(); ImportCustomizer customizer = new ImportCustomizer(); customizer.addStaticStars("java.lang.Math"); ASTTransformationCustomizer astcz = new ASTTransformationCustomizer( singletonMap("extensions", singletonList("SandboxingTypeCheckingExtension.groovy")), CompileStatic.class); conf.addCompilationCustomizers(astcz); conf.addCompilationCustomizers(customizer); Binding binding = new Binding(); binding.setVariable("score", 2.0d); try { Map&lt;String, ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;(); variableTypes.put("score", ClassHelper.double_TYPE); Map&lt;String, Object&gt; options = new HashMap&lt;String, Object&gt;(); List&lt;String&gt; patterns = new ArrayList&lt;String&gt;(); // allow method calls on Math patterns.add("java\\.lang\\.Math#"); // allow constructors calls on File patterns.add("File#&lt;init&gt;"); // because we let the user call each/times/... patterns.add("org\\.codehaus\\.groovy\\.runtime\\.DefaultGroovyMethods"); options.put(VAR_TYPES, variableTypes); options.put(WHITELIST_PATTERNS, patterns); COMPILE_OPTIONS.set(options); GroovyShell shell = new GroovyShell(binding, conf); Object result; try { result = shell.evaluate("Eval.me('1')"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("System.exit(-1)"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("((Object)Eval).me('1')"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("new File('/etc/passwd').getText()"); // getText is not allowed assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("new File('/etc/passwd').text"); // getText is not allowed assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } Double userScore = (Double) shell.evaluate("abs(cos(1+score))"); System.out.println("userScore = " + userScore); } finally { COMPILE_OPTIONS.remove(); } } }</span></span></code> </pre> <br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>      Groovy       JVM.        ,      . ,    ,    ,      .  ,    Groovy,      sandboxing'          (,       ,   ). </p><br><p>  ,            ,          .      ,            .  ,      ,        . </p><br><p>    ,   sandboxing',   , ‚Äî  <strong></strong>  <code>SecureASTCustomizer</code> .    <strong> ,  </strong> ,       : secure AST customizer    ,      (,       ),              (   ,   ). </p><br><p> ,    : ,   , .   Groovy   .          Groovy,   ,  -      pull request,      -  ! <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445114/">https://habr.com/ru/post/fr445114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445104/index.html">Une br√®ve histoire de la marque audio Klipsch</a></li>
<li><a href="../fr445106/index.html">Table ronde: la technologie additive comme alternative √† la fabrication traditionnelle</a></li>
<li><a href="../fr445108/index.html">Pas un seul Falcon - des projets ESA et ULA r√©utilisables fondamentalement diff√©rents</a></li>
<li><a href="../fr445110/index.html">Un ordinateur avec un lecteur de terminal de style Fallout</a></li>
<li><a href="../fr445112/index.html">D√©m√™ler un enchev√™trement de vuln√©rabilit√©s sur les sites</a></li>
<li><a href="../fr445116/index.html">L'US Air Force travaille sur un drone IA appel√© Skyborg</a></li>
<li><a href="../fr445118/index.html">Dans un chat priv√© Telegram, vous pouvez supprimer tous les messages - m√™me les √©trangers (un r√©sultat de vote a √©t√© ajout√©)</a></li>
<li><a href="../fr445120/index.html">Frontend Weekly Digest (18-24 mars 2019)</a></li>
<li><a href="../fr445122/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 357 (18-24 mars 2019)</a></li>
<li><a href="../fr445124/index.html">Durcissement mod√©r√© pour Firefox</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>