<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏿 👨🏿‍💻 👨🏽‍🎤 简要介绍如何从Python使用RabbitMQ 🧒🏿 🧙🏾 🙍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="碰巧的是，在MegaFon中工作时，使用RabbitMQ必须面对相同的任务。 问题自然产生了：“如何简化和自动化此类任务的执行？” 


 我想到的第一个解决方案是使用HTTP接口，当然，RabbitMQ开箱即用，具有良好的Web界面和HTTP API。 但是，使用HTTP API并不总是很方便，有...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>简要介绍如何从Python使用RabbitMQ</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434510/"><p><img src="https://habrastorage.org/webt/wj/xp/kf/wjxpkfeg45pxv_pbpaiyykpj9jg.png" alt="KDPV"></p><br><p> 碰巧的是，在MegaFon中工作时，使用RabbitMQ必须面对相同的任务。 问题自然产生了：“如何简化和自动化此类任务的执行？” </p><br><p> 我想到的第一个解决方案是使用HTTP接口，当然，RabbitMQ开箱即用，具有良好的Web界面和HTTP API。 但是，使用HTTP API并不总是很方便，有时甚至是不可能的（假设您没有足够的访问权限，但我确实想发布一条消息），使用AMQP协议就变得很有必要 </p><br><p> 未能在网络的开放空间中找到适合我的现成解决方案，因此决定编写一个小型应用程序以使用AMQP协议与RabbitMQ一起使用 <a name="habracut"></a> 能够通过命令行传输启动参数并提供最少的必要功能集，即： </p><br><ul><li> 过帐 </li><li> 校对消息 </li><li> 创建和编辑基本路线元素 </li></ul><br><p>  Python被选为实现此类任务的最简单（我认为很漂亮）的工具。  （有人可以在这里争论，但是会发生什么变化？） </p><br><p> 中心上提供RabbitMQ提供的官方指南（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一本</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">二本</a> ）的翻译；但是，有时从实践中得到一个简单的例子也是有用的。 在本文中，我将通过一个小应用程序示例来说明使用Python的AMQP通道处理兔子时出现的基本问题。 该应用程序本身可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上获得</a> 。 </p><br><h4 id="korotko-o-protokole-amqp-i-brokere-soobscheniy-rabbitmq"> 简要介绍AMQP协议和RabbitMQ消息代理 </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>AMQP</strong></a>是分布式系统组件之间最常见的消息传递协议之一。 该协议的主要区别特征是构造消息路由的概念，该消息路由包含两个主要结构元素： <strong>队列</strong>和<strong>交换点</strong> 。 队列累积消息，直到收到消息为止。 交换点是消息分发者，可以将它们路由到所需的队列或另一个交换点。 交换点通过该<strong>分发规则（绑定）</strong>来确定将消息定向到何处，该<strong>分发规则（绑定）</strong>基于检查<strong>消息的路由密钥</strong>是否符合指定的掩码。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关AMQP的更多信息。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>RabbitMQ</strong></a>是一个完全支持AMQP的开源应用程序，并提供许多其他功能。 为了与RabbitMQ一起使用，已经用多种编程语言（包括Python）编写了大量库。 </p><br><h2 id="realizaciya-na-python">  Python实现 </h2><br><p> 您总是可以抛出几个脚本供个人使用，而不知道它们带来的麻烦。 要在同事之间传播他们，一切都会变得更加复杂。 每个人都需要展示并告诉他们如何启动，什么版本，要在哪里进行更改，在哪里获得最新版本以及版本中发生了什么更改……您不由自主地得出结论，一次创建一个简单的界面会更容易，这样您就不会再浪费时间了。 为了易于使用，决定将应用程序分为4个模块： </p><br><ol><li> 负责发布的模块 </li><li> 负责从队列中减去消息的模块 </li><li> 一个旨在更改RabbitMQ代理配置的模块 </li><li> 包含先前模块共有的参数和方法的模块 </li></ol><br><p> 这种方法简化了启动参数集。 我们选择了所需的模块，选择了其操作模式之一，并传递了必要的参数（有关–help帮助中有关操作模式和参数的更多信息）。 </p><br><p> 由于MegaFon中的“兔子”结构由足够多的节点组成，为方便使用，将用于连接到节点的数据传输到具有常规参数和方法<strong>rmq_common_tools.py</strong>的模块中。 </p><br><p> 要使用Python处理AMQP，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pika</a>库。 </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pika</code> </pre> <br><p> 使用该库，使用RabbitMQ将包括三个主要阶段： </p><br><ol><li> 建立连接 </li><li> 执行所需的操作 </li><li> 紧密连接 </li></ol><br><p> 第一阶段和最后阶段对于所有模块都是相同的，并在<strong>rmq_common_tools.py</strong>中实现 </p><br><p> 建立连接： </p><br><pre> <code class="python hljs">rmq_parameters = pika.URLParameters(rmq_url_connection_str) rmq_connection = pika.BlockingConnection(rmq_parameters) rmq_channel = rmq_connection.channel()</code> </pre> <br><p> 通过Pika库，您可以使用各种设计选项来连接RabbitMQ。 在这种情况下，最方便的选择是采用以下格式的URL字符串形式传递参数： </p><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">'amqp://rabbit_user:rabbit_password@host:port/vhost'</span></span></code> </pre> <br><p> 要关闭连接： </p><br><pre> <code class="python hljs">rmq_connection.close()</code> </pre> <br><h4 id="publikaciya-soobscheniy"> 过帐 </h4><br><p> 发布消息可能是最简单的方法，但同时也是处理兔子时最流行的操作。 </p><br><p> 在<strong>rmq_publish.py中</strong>编译的发布工具 </p><br><p> 要发布消息，请使用方法 </p><br><pre> <code class="python hljs">rmq_channel.basic_publish(exchange = params.exch, routing_key = params.r_key, body = text)</code> </pre> <br><p> 其中： <br>  <strong>exchange-</strong>消息将发布到的交换点的名称 <br>  <strong>routing_key-</strong>用来发布消息的路由密钥 <br>  <strong>正文</strong> -邮件正文 </p><br><p>  <strong>rmq_publish.py</strong>支持两种消息输入模式进行发布： </p><br><ol><li> 该消息是通过命令行（from_console）作为参数输入的 </li><li> 从文件（from_file）中读取消息 </li></ol><br><p> 我认为，第二种模式在处理大型消息或消息数组时更为方便。 反过来，第一个允许您发送不带其他文件的消息，这在将模块集成到其他方案中时非常方便。 </p><br><h4 id="poluchenie-soobscheniy"> 接收讯息 </h4><br><p> 接收消息的问题不再像发布那样琐碎。 在阅读邮件时，您需要了解： </p><br><ul><li> 确认收到消息后，将从队列中将其删除。 因此，从“战斗”行中读取消息后，我们从主要使用者中“选择”它们。 如果我们不想丢失消息流，而只是想了解“兔子”中正在移动的消息，那么最合乎逻辑的选择是创建一个单独的“日志记录”队列，或者也称为“陷阱队列”。 </li><li> 通常，读取的消息需要进一步的处理或分析，这意味着如果无法进行实时处理或不需要进行实时处理，则需要将其保存在某个位置。 </li></ul><br><p> 在<strong>rmq_consume.py</strong>文件中实现的消息阅读器 </p><br><p> 提供两种操作模式： </p><br><ol><li> 从现有队列中读取消息 </li><li> 创建时间队列和路由以从该队列中读取消息 </li></ol><br><p> 下面将考虑创建队列和路由的问题。 </p><br><p> 直接校对的实现方式如下： </p><br><pre> <code class="python hljs">channel.basic_consume(on_message, queue=params.queue) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: channel.start_consuming() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyboardInterrupt: channel.stop_consuming() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception: channel.stop_consuming() rmq_tools.console_log(<span class="hljs-string"><span class="hljs-string">":\n"</span></span>, traceback.format_exc())</code> </pre> <br><p> 在哪里 <br>  <strong>on_message-</strong>消息处理程序过程 <br>  <strong>params.queue-</strong>将从中进行<strong>减法</strong>的队列的名称 </p><br><p> 消息处理程序必须对读取的消息执行某些操作，并确认（或在需要时不确认）消息传递。 </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(channel, method_frame, header_frame, body)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> all_cnt, lim <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> all_cnt &gt;= lim: rmq_tools.console_log(<span class="hljs-string"><span class="hljs-string">'   .'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyboardInterrupt body_str = body.decode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>)[:<span class="hljs-number"><span class="hljs-number">4000</span></span>] rk = method_frame.routing_key rmq_params.file.write(rk + <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) rmq_params.file.write(body_str + <span class="hljs-string"><span class="hljs-string">'\n\n'</span></span>) all_cnt = all_cnt + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lim != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (rmq_params.file == sys.stdout): sys.stdout.write(<span class="hljs-string"><span class="hljs-string">f'[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{rmq_tools.time_now()}</span></span></span><span class="hljs-string">] - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{all_cnt}</span></span></span><span class="hljs-string"> of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{lim}</span></span></span><span class="hljs-string"> messages consumed.\r'</span></span>) channel.basic_ack(delivery_tag=method_frame.delivery_tag)</code> </pre> <br><p> 在哪里 <br>  <strong>all_cnt-</strong>全球柜台 <br>  <strong>lim-</strong>要读取的消息数 </p><br><p> 在处理程序的这种实现中，如果在文件中进行记录，则减去一定数量的消息，并将有关减法进度的信息输出到控制台。 </p><br><p> 也可以将读取的消息写入数据库。 在当前的实现中，没有提供这样的机会，但是并不难添加。 </p><br><div class="spoiler">  <b class="spoiler_title">记录在数据库中</b> <div class="spoiler_text"><p> 我们将考虑为Oracle数据库和<strong>cx_oracle</strong>库将消息写入数据库的<strong>示例</strong> 。 </p><br><p> 连接到数据库 </p><br><pre> <code class="python hljs">ora_adress = <span class="hljs-string"><span class="hljs-string">'host:port/dbSID'</span></span> ora_creds = <span class="hljs-string"><span class="hljs-string">'user/pass'</span></span> connection_ora = cx_Oracle.connect(ora_creds + <span class="hljs-string"><span class="hljs-string">'@'</span></span> + ora_address) ora_cursor = connection_ora.cursor()</code> </pre> <br><p> 在<strong>on_message</strong>处理程序中添加 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">global</span></span> cnt, commit_int insert_rec = <span class="hljs-string"><span class="hljs-string">'insert into '</span></span> + tab_name + <span class="hljs-string"><span class="hljs-string">'(routing_key, text) values (:rkey, :text)'</span></span> ora_cursor.execute(insert_rec, text = body_str, rkey = rk) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cnt &gt; commit_int : ora_cursor.execute(<span class="hljs-string"><span class="hljs-string">'commit'</span></span>) cnt = <span class="hljs-number"><span class="hljs-number">1</span></span> cnt = cnt + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p> 在哪里 <br>  <strong>cnt</strong>是另一个柜台 <br>  <strong>commit_int-</strong>插入数据库的次数，之后必须执行“ commit”。 该参数的存在是由于希望减少数据库的负载。 但是，安装它不是特别大，因为 如果失败，则有可能会丢失最后一次成功提交后读取的消息。 </p><br><p> 并且，正如预期的那样，在工作结束时，我们进行最后的提交并关闭连接 </p><br><pre> <code class="python hljs">ora_cursor.execute(<span class="hljs-string"><span class="hljs-string">'commit'</span></span>) connection_ora.close()</code> </pre> <br><p> 这样的事情正在阅读邮件。 如果取消了对已读消息数量的限制，则可以进行后台处理以连续读取“兔子”中的消息。 </p></div></div><br><h4 id="konfigurirovanie"> 构型 </h4><br><p> 尽管AMQP协议主要用于发布和阅读消息，但它也允许您使用路由配置执行简单的操作（我们不是在将网络连接和其他RabbitMQ设置配置为应用程序）。 </p><br><p> 主要配置操作为： </p><br><ol><li> 创建队列或交换点 </li><li> 创建转发规则（绑定） </li><li> 删除队列或交换点 </li><li> 删除转发规则（绑定） </li><li> 队列清除 </li></ol><br><p> 由于每个组件都在pika库中有一个现成的过程，为了启动方便，只需将它们编译在<strong>rmq_setup.py</strong>文件中即可。 接下来，我们列出了pika库中的过程，并对参数进行了一些注释。 </p><br><p>  <strong>创建队列</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_declare(queue=params.queue, durable = params.durable)</code> </pre> <br><p> 一切都很简单 <br>  queue-要创建的队列的名称 <br>  <strong>持久</strong> -逻辑参数，值为True表示兔子重启时，队列将继续存在。 如果为False，则重新启动后将删除队列。 第二个选项通常用于保证将来不再需要的临时队列。 </p><br><p>  <strong>创建交换点（交换）</strong> </p><br><pre> <code class="python hljs">rmq_channel.exchange_declare(exchange=params.exch, exchange_type = params.type, durable = params.durable)</code> </pre> <br><p> 这里出现一个新的参数<strong>exchange_type-</strong>交换点的类型。 关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>阅读什么类型的交换点。 <br>  <strong>exchange-</strong>创建的交换点的名称 </p><br><p>  <strong>删除队列或交换点</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_delete(queue=params.queue) rmq_channel.exchange_delete(exchange=params.exch)</code> </pre> <br><p>  <strong>创建转发规则（绑定）</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_bind(exchange=params.exch, queue=params.queue, routing_key=params.r_key)</code> </pre> <br><p>  <strong>交换</strong> -从中进行转移的交换点的名称 <br>  <strong>queue-</strong>要转发到的队列的名称 <br>  <strong>routing_key-</strong>路由密钥的掩码，将用于转发。 </p><br><p> 以下条目有效： </p><br><ul><li>  <strong>rk.my_key。*</strong> -在此掩码中，星号表示非空字符集。 换句话说，这样的掩码将跳过<strong>rk.my_key</strong>类型的任何键<strong>。</strong>  +其他东西，但不会丢失键<strong>rk.my_key</strong> </li><li>  <strong>rk.my_key。＃</strong> -此掩码将跳过所有与上一个+键<strong>rk.my_key相同的内容</strong> </li></ul><br><p>  <strong>删除转发规则（绑定）</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_unbind(exchange=params.exch, queue=params.queue, routing_key=params.r_key)</code> </pre> <br><p> 一切都类似于创建转发规则。 </p><br><p>  <strong>队列清除</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_purge(queue=params.queue)</code> </pre> <br><p>  <strong>queue-</strong>要清除的队列的名称 </p><br><div class="spoiler">  <b class="spoiler_title">关于在Python应用程序中使用命令行界面</b> <div class="spoiler_text"><p> 启动选项使生活更加轻松。 为了在每次启动之前不编辑代码，提供一种在启动时传递参数的机制是合乎逻辑的。  <strong>为此</strong>选择了<strong>argparse</strong>库。 我不会详细介绍其用法的复杂性；对此主题有足够的指南（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">二</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三</a> ）。 我只注意到该工具帮助我极大地简化了应用程序的使用过程（如果可以调用它的话）。 即使抛出了简单的命令序列并将它们包装在类似的界面中，您也可以获得功能齐全且易于使用的工具。 </p></div></div><br><h2 id="primenenie-v-povsednevnoy-zhizni-chto-prigodilos-bolshe-vsego"> 在日常生活中的应用。 最方便的是什么。 </h2><br><p> 好了，现在对在日常生活中使用AMQP有了一点印象。 </p><br><p> 最需要的功能是消息的发布。 特定用户的访问权限并不总是允许使用Web界面，尽管有时仅需要测试特定服务。 在此，AMQP和代表使用此通道的服务的授权传递给帮助。 </p><br><p> 第二受欢迎的是从时间队列中读取消息的功能。 此功能在配置新路由和消息流以及防止事故方面很有用。 </p><br><p> 在其他任务中也发现了其他可能性。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN434510/">https://habr.com/ru/post/zh-CN434510/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN434500/index.html">骗子叫珍妮或看你的耳朵</a></li>
<li><a href="../zh-CN434502/index.html">“数字考古学家”如何发现NES的失落版本SimCity并将其还原</a></li>
<li><a href="../zh-CN434504/index.html">快速报告20年“该产品是一口气创造出来的，只是高出……”</a></li>
<li><a href="../zh-CN434506/index.html">体验在Microsoft Store中发布视频编辑应用程序的经验</a></li>
<li><a href="../zh-CN434508/index.html">搜索引擎营销的阴暗面：Google如何以及为何收集我们的个人信息</a></li>
<li><a href="../zh-CN434512/index.html">公司法人</a></li>
<li><a href="../zh-CN434514/index.html">用于“渗透测试者”的“秘密” DPAPI或DPAPI</a></li>
<li><a href="../zh-CN434516/index.html">一种处理您的职业理想的简便方法。</a></li>
<li><a href="../zh-CN434518/index.html">掌声和欢呼声：Apple商店中经过精心控制的戏剧</a></li>
<li><a href="../zh-CN434522/index.html">任务证明模式和反模式</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>