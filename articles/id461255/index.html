<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏻 🎿 🕉️ Cara menembak diri Anda di kaki di C dan C ++. Koleksi Resep OS Haiku 🙆🏻 💶 🕛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kisah pertemuan analisa statis PVS-Studio dengan kode sistem operasi Haiku kembali ke tahun 2015 yang jauh. Itu adalah eksperimen yang menarik dan pen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menembak diri Anda di kaki di C dan C ++. Koleksi Resep OS Haiku</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/461255/">  Kisah pertemuan analisa statis PVS-Studio dengan kode sistem operasi Haiku kembali ke tahun 2015 yang jauh.  Itu adalah eksperimen yang menarik dan pengalaman yang berguna bagi tim dari kedua proyek.  Mengapa harus bereksperimen?  Tidak ada analisa untuk Linux saat itu dan tidak akan ada satu setengah tahun lagi.  Tetapi pekerjaan para penggemar tim kami dihargai: kami bertemu dengan para pengembang Haiku dan meningkatkan kualitas kode, mengisi ulang database dengan kesalahan programmer yang jarang terjadi, dan menyempurnakan penganalisa.  Memeriksa kode Haiku untuk kesalahan cepat dan mudah sekarang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/3b6/925/3a83b6925fff10cf8924920b96996e8d.png" alt="Gambar 3"></div><br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Pahlawan sejarah kita adalah sistem operasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Haiku</a> open-source dan analisa statis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> untuk C, C ++, C # dan Java.  Ketika 4,5 tahun yang lalu kami mulai menganalisis proyek, kami hanya perlu bekerja dengan file executable analyzer yang dikompilasi.  Seluruh infrastruktur untuk parsing parameter kompilasi, mulai preprocessor, analisis paralelisasi, dll.  diambil dari utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UI Pemantau Kompiler</a> dalam C #, yang portingnya sebagian ke platform Mono untuk dijalankan di Linux.  Proyek Haiku sendiri dibangun menggunakan cross-compiler di bawah berbagai sistem operasi, kecuali Windows.  Sekali lagi, saya ingin mencatat kenyamanan dan kelengkapan dokumentasi perakitan Haiku, dan juga berterima kasih kepada para pengembang Haiku atas bantuan mereka dalam membangun proyek. <br><br>  Sekarang analisis jauh lebih mudah.  Daftar semua perintah untuk membangun dan menganalisis proyek terlihat seperti ini: <br><br><pre><code class="cpp hljs">cd /opt git clone https:<span class="hljs-comment"><span class="hljs-comment">//review.haiku-os.org/buildtools git clone https://review.haiku-os.org/haiku cd ./haiku mkdir generated.x86_64; cd generated.x86_64 ../configure --distro-compatibility official -j12 \ --build-cross-tools x86_64 ../../buildtools cd ../../buildtools/jam make all cd /opt/haiku/generated.x86_64 pvs-studio-analyzer trace -- /opt/buildtools/jam/bin.linuxx86/jam \ -q -j1 @nightly-anyboot pvs-studio-analyzer analyze -l /mnt/svn/PVS-Studio.lic -r /opt/haiku \ -C x86_64-unknown-haiku-gcc -o /opt/haiku/haiku.log -j12</span></span></code> </pre> <br>  Omong-omong, analisis proyek dilakukan dalam wadah Docker.  Baru-baru ini, kami telah menyiapkan dokumentasi baru tentang topik ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menjalankan PVS-Studio di Docker</a> .  Ini dapat sangat menyederhanakan penggunaan teknik analisis proyek statis untuk beberapa perusahaan. <br><br><h2>  Variabel tidak diinisialisasi </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V614</a> Variabel tidak diinisialisasi 'rval' digunakan.  fetch.c 1727 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">auto_fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argpos; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rval; <span class="hljs-comment"><span class="hljs-comment">// &lt;= argpos = 0; if (sigsetjmp(toplevel, 1)) { if (connected) disconnect(0, NULL); if (rval &gt; 0) // &lt;= rval = argpos + 1; return (rval); } .... }</span></span></code> </pre> <br>  Variabel <i>rval</i> tidak diinisialisasi ketika dideklarasikan, jadi membandingkannya dengan nilai nol akan menghasilkan hasil yang tidak ditentukan.  Jika keadaan gagal, nilai variabel <i>rval</i> yang tidak <i>ditentukan</i> dapat menjadi nilai <i>balik</i> fungsi <i>auto_fetch</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V614</a> 'Res' pointer tidak diinisialisasi digunakan.  commands.c 2873 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addrinfo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_flags; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_family; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_socktype; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_protocol; <span class="hljs-keyword"><span class="hljs-keyword">socklen_t</span></span> ai_addrlen; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ai_canonname; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai_addr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addrinfo</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai_next</span></span></span><span class="hljs-class">;</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sourceroute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct addrinfo *ai, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **cpp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lenp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *protop, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *optp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1024</span></span> + ALIGNBYTES]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, *cp2, *lsrp, *ep; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> *_</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sin</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> INET6 struct sockaddr_in6 *sin6; struct ip6_rthdr *rth; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> struct addrinfo hints, *res; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= int error; char c; if (cpp == NULL || lenp == NULL) return -1; if (*cpp != NULL) { switch (res-&gt;ai_family) { // &lt;= case AF_INET: if (*lenp &lt; 7) return -1; break; .... } } .... }</span></span></span></span></code> </pre> <br>  Kasus serupa menggunakan variabel tidak diinisialisasi, hanya di sini adalah pointer pointer diinisialisasi. <br><br>  Pointer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V506</a> ke variabel lokal 'dinormalisasi' disimpan di luar ruang lingkup variabel ini.  Pointer seperti itu akan menjadi tidak valid.  TextView.cpp 5596 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BTextView::_ApplyStyleRange(...., <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BFont* font, ....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (font != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { BFont normalized = *font; _NormalizeFont(&amp;normalized); font = &amp;normalized; } .... fStyles-&gt;SetStyleRange(fromOffset, toOffset, fText-&gt;Length(), mode, font, color); }</code> </pre> <br>  Mungkin, programmer perlu menormalkan objek melalui variabel perantara.  Tapi sekarang, di penunjuk <i>font</i> , penunjuk ke objek sementara yang <i>dinormalisasi disimpan</i> , yang akan dihancurkan setelah meninggalkan ruang lingkup di mana objek sementara ini dibuat. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V603</a> Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 27 <br><br><pre> <code class="cpp hljs">int8 BUnicodeChar::Type(uint32 c) { BUnicodeChar(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u_charType(c); }</code> </pre> <br>  Kesalahan yang sangat umum di antara programmer C ++ adalah menggunakan panggilan konstruktor yang seharusnya untuk menginisialisasi / nol bidang kelas.  Dalam hal ini, tidak ada modifikasi bidang kelas, tetapi objek baru yang tidak disebutkan namanya dari kelas ini dibuat, yang segera dihancurkan.  Sayangnya, ada banyak tempat seperti itu: <br><br><ul><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 37 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 49 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 58 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 67 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 77 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 89 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 103 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 115 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 126 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 142 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 152 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 163 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 186 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 196 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 206 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 214 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 222 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 230 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V670</a> Anggota kelas 'fPatternHandler' yang tidak diinisialisasi digunakan untuk menginisialisasi anggota 'fInternal'.  Ingat bahwa anggota diinisialisasi dalam urutan deklarasi mereka di dalam kelas.  Painter.cpp 184 <br><br><pre> <code class="cpp hljs">Painter::Painter() : fInternal(fPatternHandler), .... fPatternHandler(), .... { .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Painter</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> PainterAggInterface fInternal; <span class="hljs-comment"><span class="hljs-comment">// line 336 bool fSubpixelPrecise : 1; bool fValidClipping : 1; bool fDrawingText : 1; bool fAttached : 1; bool fIdentityTransform : 1; Transformable fTransform; float fPenSize; const BRegion* fClippingRegion; drawing_mode fDrawingMode; source_alpha fAlphaSrcMode; alpha_function fAlphaFncMode; cap_mode fLineCapMode; join_mode fLineJoinMode; float fMiterLimit; PatternHandler fPatternHandler; // line 355 mutable AGGTextRenderer fTextRenderer; };</span></span></code> </pre> <br>  Contoh lain inisialisasi yang salah.  Bidang kelas diinisialisasi dalam urutan mereka dideklarasikan di kelas itu sendiri.  Dalam contoh ini, bidang <i>fInternal</i> akan diinisialisasi pertama menggunakan nilai yang tidak diinisialisasi <i>fPatternHandler</i> . <br><br><h2>  #Define mencurigakan </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V523</a> Pernyataan 'lalu' sama dengan pernyataan 'lain'.  subr_gtaskqueue.c 191 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_LOCK(tq) \ do { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((tq)-&gt;tq_spin) \ mtx_lock_spin(&amp;(tq)-&gt;tq_mutex); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> \ mtx_lock(&amp;(tq)-&gt;tq_mutex); \ } while (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_ASSERT_LOCKED(tq) mtx_assert(&amp;(tq)-&gt;tq_mutex, MA_OWNED) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_UNLOCK(tq) \ do { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((tq)-&gt;tq_spin) \ mtx_unlock_spin(&amp;(tq)-&gt;tq_mutex); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> \ mtx_unlock(&amp;(tq)-&gt;tq_mutex); \ } while (0) void grouptask_block(struct grouptask *grouptask) { .... TQ_LOCK(queue); gtask-&gt;ta_flags |= TASK_NOENQUEUE; gtaskqueue_drain_locked(queue, gtask); TQ_UNLOCK(queue); }</span></span></code> </pre> <br>  Cuplikan kode tidak terlihat mencurigakan hingga Anda melihat hasil preprocessor: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grouptask_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct grouptask *grouptask)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_spin) mtx_lock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mtx_lock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>); gtask-&gt;ta_flags |= <span class="hljs-number"><span class="hljs-number">0x4</span></span>; gtaskqueue_drain_locked(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>, gtask); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_spin) mtx_unlock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mtx_unlock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Alat analisis benar-benar - cabang <i>if</i> dan <i>else</i> identik.  Tetapi kemana <i>perginya</i> fungsi <i>mtx_lock_spin</i> dan <i>mtx_unlock_spin</i> ?  Makro <i>TQ_LOCK</i> , <i>TQ_UNLOCK</i> dan fungsi <i>grouptask_block</i> dideklarasikan dalam file yang sama dan hampir berdampingan, namun ada substitusi di suatu tempat. <br><br>  Pencarian pada isi file hanya ditemukan <i>mutex.h</i> dengan konten berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* on FreeBSD these are different functions */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mtx_lock_spin(x) mtx_lock(x) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mtx_unlock_spin(x) mtx_unlock(x)</span></span></code> </pre> <br>  Apakah substitusi seperti itu benar atau tidak, layak untuk memeriksa pengembang proyek.  Saya memeriksa proyek di Linux, dan penggantian seperti itu tampak mencurigakan bagi saya. <br><br><h2>  Kesalahan dengan fungsi bebas </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V575 Penunjuk</a> nol dilewatkan ke fungsi 'bebas'.  Periksa argumen pertama.  setmime.cpp 727 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MimeType::_PurgeProperties() { fShort.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fLong.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fPrefApp.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fPrefAppSig.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fSniffRule.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fSmallIcon; fSmallIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fBigIcon; fBigIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; fVectorIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= free(fVectorIcon); // &lt;= fExtensions.clear(); fAttributes.clear(); }</span></span></code> </pre> <br>  Anda dapat melewatkan pointer nol ke fungsi <i>bebas</i> , tetapi entri seperti itu jelas mencurigakan.  Jadi, penganalisa menemukan garis kode yang membingungkan.  Pertama, Anda harus membebaskan memori menggunakan pointer <i>fVectorIcon</i> , dan hanya kemudian mengaturnya ke <i>NULL</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V575 Penunjuk</a> nol dilewatkan ke fungsi 'bebas'.  Periksa argumen pertama.  driver_settings.cpp 461 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> settings_handle * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_driver_settings_from_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *driverName)</span></span></span><span class="hljs-function"> </span></span>{ .... handle = new_settings(text, driverName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// everything went fine! return handle; } free(handle); // &lt;= .... }</span></span></code> </pre> <br>  Contoh lain dari pengoper null pointer secara eksplisit ke fungsi <i>bebas</i> .  Baris ini dapat dihapus, karena  setelah berhasil menerima pointer, fungsi keluar. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V575 Penunjuk</a> nol dilewatkan ke fungsi 'bebas'.  Periksa argumen pertama.  PackageFileHeapWriter.cpp 166 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* _GetBuffer() { .... <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* buffer = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(fBufferSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; !fBuffers.AddItem(buffer)) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(buffer); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer; }</code> </pre> <br>  Ini kesalahan.  Alih-alih operator &amp;&amp;, operator || harus digunakan.  Hanya dalam kasus ini pengecualian akan dilemparkan <i>std :: bad_alloc ()</i> jika tidak memungkinkan untuk mengalokasikan memori menggunakan fungsi <i>malloc</i> . <br><br><h2>  Kesalahan dengan operator hapus </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V611</a> Memori dialokasikan menggunakan operator 'T baru] tetapi dirilis menggunakan operator' hapus '.  Pertimbangkan untuk memeriksa kode ini.  Mungkin lebih baik menggunakan 'delete [] fMsg;'.  Err.cpp 65 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Err</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fMsg; <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> fPos; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Err::Unset() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fMsg; <span class="hljs-comment"><span class="hljs-comment">// &lt;= fMsg = __null; fPos = -1; } void Err::SetMsg(const char *msg) { if (fMsg) { delete fMsg; // &lt;= fMsg = __null; } if (msg) { fMsg = new(std::nothrow) char[strlen(msg)+1]; // &lt;= if (fMsg) strcpy(fMsg, msg); } }</span></span></code> </pre> <br>  Pointer <i>fMsg</i> digunakan untuk mengalokasikan memori untuk menyimpan berbagai karakter, dan operator <i>hapus</i> digunakan untuk mengosongkan memori, alih-alih <i>menghapus []</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V611</a> Memori dialokasikan menggunakan operator 'baru' tetapi dirilis menggunakan fungsi 'bebas'.  Pertimbangkan untuk memeriksa logika operasi di belakang variabel 'wrapperPool'.  vm_page.cpp 3080 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> vm_page_write_modified_page_range(....) { .... PageWriteWrapper* wrapperPool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(malloc_flags(allocationFlags)) PageWriteWrapper[maxPages + <span class="hljs-number"><span class="hljs-number">1</span></span>]; PageWriteWrapper** wrappers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(malloc_flags(allocationFlags)) PageWriteWrapper*[maxPages]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapperPool == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || wrappers == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(wrapperPool); <span class="hljs-comment"><span class="hljs-comment">// &lt;= free(wrappers); // &lt;= wrapperPool = stackWrappersPool; wrappers = stackWrappers; maxPages = 1; } .... }</span></span></code> </pre> <br>  Di sini <i>malloc_flags</i> adalah fungsi yang membuat <i>malloc</i> .  Dan kemudian <i>penempatan-baru</i> membangun objek di sini.  Dan karena kelas <i>PageWriteWrapper</i> diimplementasikan sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PageWriteWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PageWriteWrapper(); ~PageWriteWrapper(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm_page* page)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">status_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> result)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: vm_page* fPage; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VMCache</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fCache</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fIsActive; }; PageWriteWrapper::PageWriteWrapper() : fIsActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { } PageWriteWrapper::~PageWriteWrapper() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsActive) panic(<span class="hljs-string"><span class="hljs-string">"page write wrapper going out of scope but isn't completed"</span></span>); }</code> </pre> <br>  maka objek destruktor dari kelas ini tidak akan dipanggil karena penggunaan fungsi bebas untuk membebaskan memori. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V611</a> Memori dialokasikan menggunakan operator 'T baru] tetapi dirilis menggunakan operator' hapus '.  Pertimbangkan untuk memeriksa kode ini.  Mungkin lebih baik menggunakan 'delete [] fOutBuffer;'.  Periksa baris: 26, 45. PCL6Rasterizer.h 26 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PCL6Rasterizer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Rasterizer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... ~PCL6Rasterizer() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fOutBuffer; fOutBuffer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fOutBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> uchar[fOutBufferSize]; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: uchar* fOutBuffer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fOutBufferSize; };</code> </pre> <br>  Menggunakan operator <i>hapus</i> alih-alih <i>menghapus []</i> adalah kesalahan yang sangat umum.  Cara termudah untuk membuat kesalahan saat menulis kelas adalah  Kode destruktor sering terletak jauh dari lokasi alokasi memori.  Di sini, programmer secara tidak benar membebaskan memori dalam destruktor oleh pointer <i>fOutBuffer</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V772</a> Memanggil operator 'hapus' untuk pointer kosong akan menyebabkan perilaku tidak terdefinisi.  Hashtable.cpp 207 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Hashtable::MakeEmpty(int8 keyMode,int8 valueMode) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (entry = fTable[index]; entry; entry = next) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (keyMode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HASH_EMPTY_DELETE: <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> destructors are not called! delete (void*)entry-&gt;key; break; case HASH_EMPTY_FREE: free((void*)entry-&gt;key); break; } switch (valueMode) { case HASH_EMPTY_DELETE: // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> destructors are not called! delete entry-&gt;value; break; case HASH_EMPTY_FREE: free(entry-&gt;value); break; } next = entry-&gt;next; delete entry; } .... }</span></span></code> </pre> <br>  Selain pilihan yang salah antara <i>hapus</i> / <i>hapus []</i> dan <i>gratis</i> , Anda dapat menambahkan perilaku tidak terdefinisi ke program dengan cara lain - coba hapus memori dengan pointer ke tipe yang tidak ditentukan <i>(batal *)</i> . <br><br><h2>  Fungsi tanpa nilai kembali </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi V591</a> Non-void harus mengembalikan nilai.  Referenceable.h 228 <br><br><pre> <code class="cpp hljs">BReference&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BReference&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Type&gt;&amp; other) { fReference = other.fReference; }</code> </pre> <br>  Operator tugas yang ditimpa tidak memiliki nilai pengembalian yang cukup.  Dalam hal ini, operator akan mengembalikan nilai acak, yang dapat menyebabkan kesalahan aneh. <br><br>  Masalah serupa di cuplikan kode lain dari kelas ini: <br><br><ul><li>  Fungsi V591 Non-void harus mengembalikan nilai.  Referenceable.h 233 </li><li>  Fungsi V591 Non-void harus mengembalikan nilai.  Referenceable.h 239 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi V591</a> Non-void harus mengembalikan nilai.  main.c 1010 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, ...)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getoptionvalue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) errx(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"getoptionvalue() invoked with NULL name"</span></span>); c = getoption(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c-&gt;value); errx(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"getoptionvalue() invoked with unknown option '%s'"</span></span>, name); <span class="hljs-comment"><span class="hljs-comment">/* NOTREACHED */</span></span> }</code> </pre> <br>  Komentar pengguna NOTREACHED di sini tidak ada artinya.  Untuk menulis kode dengan benar untuk skenario seperti itu, Anda perlu menandai fungsi seperti noreturn.  Ada atribut noreturn untuk ini: standar dan khusus kompiler.  Pertama-tama, atribut tersebut diperhitungkan oleh kompiler untuk pembuatan kode yang benar atau pemberitahuan beberapa jenis kesalahan dengan bantuan peringatan.  Berbagai alat analisis statis juga mempertimbangkan atribut untuk meningkatkan kualitas analisis. <br><br><h2>  Penanganan pengecualian </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V596</a> Objek telah dibuat tetapi tidak sedang digunakan.  Kata kunci 'lempar' bisa hilang: lempar ParseException (FOO);  Response.cpp 659 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Response::ExtractNumber(BDataIO&amp; stream) { BString <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = ExtractString(stream); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* end; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> number = strtoul(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.String(), (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>**)&amp;end, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (end == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || end[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) ParseException(<span class="hljs-string"><span class="hljs-string">"Invalid number!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number; }</code> </pre> <br>  Di sini, kata kunci <i>lemparan</i> tidak sengaja terlupakan.  Dengan demikian, <i>ParseException</i> tidak akan <i>dilempar</i> , dan objek dari kelas ini hanya akan dihancurkan ketika meninggalkan ruang lingkup.  Setelah itu fungsi akan melanjutkan kerjanya seolah-olah tidak ada yang terjadi, seolah-olah nomor yang benar dimasukkan. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1022</a> Pengecualian dilemparkan oleh pointer.  Pertimbangkan untuk melemparkannya dengan nilai saja.  gensyscallinfos.cpp 316 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Main().Run(argc, argv); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception&amp; exception) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= fprintf(stderr, "%s\n", exception.what()); return 1; } } int Run(int argc, char** argv) { .... _ParseSyscalls(argv[1]); .... } void _ParseSyscalls(const char* filename) { ifstream file(filename, ifstream::in); if (!file.is_open()) throw new IOException(string("Failed to open '") + filename + "'."); // &lt;= .... }</span></span></code> </pre> <br>  Analyzer mendeteksi <i>IOException yang</i> dilemparkan oleh pointer.  Melempar pointer menyebabkan pengecualian tidak ditangkap, sehingga pengecualian akhirnya ditangkap oleh referensi.  Juga, menggunakan pointer memaksa pencegat untuk memanggil operator <i>hapus</i> untuk menghancurkan objek yang dibuat, yang juga tidak dilakukan. <br><br>  Dua area masalah lagi dari kode: <br><br><ul><li>  V1022 Pengecualian dilemparkan oleh pointer.  Pertimbangkan untuk melemparkannya dengan nilai saja.  gensyscallinfos.cpp 347 </li><li>  V1022 Pengecualian dilemparkan oleh pointer.  Pertimbangkan untuk melemparkannya dengan nilai saja.  gensyscallinfos.cpp 413 </li></ul><br><h2>  Keselamatan formal </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V597</a> Kompiler dapat menghapus panggilan fungsi 'memset', yang digunakan untuk flush objek 'f_key'.  Fungsi memset_s () harus digunakan untuk menghapus data pribadi.  dst_api.c 1018 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SAFE_FREE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAFE_FREE(a) \ do{</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(a != NULL){memset(a,0, sizeof(*a)); free(a); a=NULL;}} while (0) .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> DST_KEY * dst_free_key(DST_KEY *f_key) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key == NULL) return (f_key); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_func &amp;&amp; f_key-&gt;dk_func-&gt;destroy) f_key-&gt;dk_KEY_struct = f_key-&gt;dk_func-&gt;destroy(f_key-&gt;dk_KEY_struct); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { EREPORT((</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dst_free_key(): Unknown key alg %d\n"</span></span></span><span class="hljs-meta">, f_key-&gt;dk_alg)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_KEY_struct) { free(f_key-&gt;dk_KEY_struct); f_key-&gt;dk_KEY_struct = NULL; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_key_name) SAFE_FREE(f_key-&gt;dk_key_name); SAFE_FREE(f_key); return (NULL); }</span></span></code> </pre> <br>  Penganalisis mendeteksi kode mencurigakan yang dirancang untuk membersihkan data pribadi dengan aman.  Sayangnya, makro <i>SAFE_FREE</i> , yang diperluas menjadi <i>memset</i> , panggilan <i>gratis</i> , dan penugasan <i>NULL</i> , tidak membuat kode lebih aman, karena  semua ini dihapus oleh kompiler selama optimasi <i>O2</i> . <br><br>  By the way, ini tidak seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CWE-14</a> : Penghapusan Kompiler Kode ke Hapus Buffer. <br><br>  Seluruh daftar tempat di mana buffer sebenarnya tidak dibersihkan: <br><br><ul><li>  V597 Kompiler dapat menghapus pemanggilan fungsi 'memset', yang digunakan untuk membersihkan buffer 'encoded_block'.  Fungsi memset_s () harus digunakan untuk menghapus data pribadi.  dst_api.c 446 </li><li>  V597 Kompiler dapat menghapus panggilan fungsi 'memset', yang digunakan untuk menyiram objek 'key_st'.  Fungsi memset_s () harus digunakan untuk menghapus data pribadi.  dst_api.c 685 </li><li>  V597 Kompiler dapat menghapus pemanggilan fungsi 'memset', yang digunakan untuk membersihkan buffer 'in_buff'.  Fungsi memset_s () harus digunakan untuk menghapus data pribadi.  dst_api.c 916 </li><li>  V597 Kompiler dapat menghapus panggilan fungsi 'memset', yang digunakan untuk menyiram objek 'ce'.  Fungsi memset_s () harus digunakan untuk menghapus data pribadi.  fs_cache.c 1078 </li></ul><br><h2>  Perbandingan yang Tidak Ditandatangani </h2><br>  Ekspresi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V547</a> 'tersisa &lt;0' selalu salah.  Nilai tipe yang tidak ditandatangani tidak pernah &lt;0. DwarfFile.cpp 1947 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> DwarfFile::_UnwindCallFrame(....) { .... uint64 remaining = lengthOffset + length - dataReader.Offset(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remaining &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_BAD_DATA; .... }</code> </pre> <br>  Penganalisa menemukan perbandingan eksplisit dari variabel yang tidak ditandatangani dengan nilai negatif.  Mungkin Anda harus membandingkan variabel yang <i>tersisa dengan</i> hanya nol atau menerapkan pemeriksaan overflow. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V547</a> Ekspresi 'sleep ((unsigned) secs) &lt;0' selalu salah.  Nilai tipe yang tidak ditandatangani tidak pernah &lt;0. Misc.cpp 56 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> snooze(<span class="hljs-keyword"><span class="hljs-keyword">bigtime_t</span></span> amount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_OK; int64 secs = amount / <span class="hljs-number"><span class="hljs-number">1000000L</span></span>L; int64 usecs = amount % <span class="hljs-number"><span class="hljs-number">1000000L</span></span>L; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (secs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sleep((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)secs) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= return errno; } if (usecs &gt; 0) { if (usleep((useconds_t)usecs) &lt; 0) return errno; } return B_OK; }</span></span></code> </pre> <br>  Untuk memahami apa kesalahannya, mari kita beralih ke tanda tangan fungsi <i>sleep</i> and <i>usleep</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __seconds)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usleep</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">__useconds_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __useconds)</span></span></span></span>;</code> </pre> <br>  Seperti yang bisa kita lihat, fungsi <i>sleep</i> mengembalikan nilai dari tipe yang tidak ditandatangani dan penggunaannya dalam kode salah. <br><br><h2>  Pointer berbahaya </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V774 Pointer</a> 'perangkat' digunakan setelah memori dilepaskan.  xhci.cpp 1572 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> XHCI::FreeDevice(Device *device) { uint8 slot = fPortSlots[device-&gt;HubPort()]; TRACE(<span class="hljs-string"><span class="hljs-string">"FreeDevice() port %d slot %d\n"</span></span>, device-&gt;HubPort(), slot); <span class="hljs-comment"><span class="hljs-comment">// Delete the device first, so it cleans up its pipes and tells us // what we need to destroy before we tear down our internal state. delete device; DisableSlot(slot); fDcba-&gt;baseAddress[slot] = 0; fPortSlots[device-&gt;HubPort()] = 0; // &lt;= delete_area(fDevices[slot].trb_area); delete_area(fDevices[slot].input_ctx_area); delete_area(fDevices[slot].device_ctx_area); memset(&amp;fDevices[slot], 0, sizeof(xhci_device)); fDevices[slot].state = XHCI_STATE_DISABLED; }</span></span></code> </pre> <br>  Objek <i>perangkat</i> dihapus oleh operator <i>hapus</i> .  Ini adalah tindakan logis untuk fungsi yang disebut <i>FreeDevice</i> .  Tetapi, untuk beberapa alasan, untuk melepaskan sumber daya lain dalam kode, ada lagi daya tarik ke objek yang sudah dihapus. <br><br>  Kode semacam itu sangat berbahaya dan terjadi di beberapa tempat lain: <br><br><ul><li>  V774 Pointer 'mandiri' digunakan setelah memori dilepaskan.  TranslatorRoster.cpp 884 </li><li>  V774 Pointer 'string' digunakan setelah memori dilepaskan.  RemoteView.cpp 1269 </li><li>  V774 Pointer 'bs' digunakan setelah memori dilepaskan.  mkntfs.c 4291 </li><li>  V774 Pointer 'bs' digunakan setelah memori dilepaskan.  mkntfs.c 4308 </li><li>  V774 Pointer 'al' digunakan setelah memori dialokasikan kembali.  inode.c 1155 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V522 Dereferencing</a> dari 'data' pointer nol mungkin terjadi.  Pointer nol dilewatkan ke fungsi 'malo_hal_send_helper'.  Periksa argumen ketiga.  Periksa baris: 350, 394. if_malohal.c 350 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malo_hal_fwload_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct malo_hal *mh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *helper)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* tell the card we're done and... */</span></span> error = malo_hal_send_helper(mh, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, MALO_NOWAIT); <span class="hljs-comment"><span class="hljs-comment">// &lt;= NULL .... } static int malo_hal_send_helper(struct malo_hal *mh, int bsize, const void *data, size_t dsize, int waitfor) { mh-&gt;mh_cmdbuf[0] = htole16(MALO_HOSTCMD_CODE_DNLD); mh-&gt;mh_cmdbuf[1] = htole16(bsize); memcpy(&amp;mh-&gt;mh_cmdbuf[4], data , dsize); // &lt;= data .... }</span></span></code> </pre> <br>  Analisis antar prosedur mengungkapkan situasi di mana <i>NULL</i> diteruskan ke fungsi dan penunjuk <i>data</i> dengan nilai ini kemudian ditinjau kembali dalam fungsi <i>memcpy</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V773</a> Fungsi itu keluar tanpa melepaskan pointer 'inputFileFile'.  Kebocoran memori dimungkinkan.  command_recompress.cpp 119 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">command_recompress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv)</span></span></span><span class="hljs-function"> </span></span>{ .... BFile* inputFileFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BFile; error = inputFileFile-&gt;SetTo(inputPackageFileName, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != B_OK) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: Failed to open input file \"%s\": %s\n"</span></span>, inputPackageFileName, strerror(error)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } inputFile = inputFileFile; .... }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio dapat mendeteksi kebocoran memori</a> .  Di sini, memori tidak dibebaskan untuk <i>inputFileFile</i> jika terjadi beberapa jenis kesalahan.  Seseorang percaya bahwa jika terjadi kesalahan, Anda tidak dapat repot-repot dengan membebaskan memori - program masih akan berakhir.  Tapi ini tidak selalu terjadi.  Menangani kesalahan dengan benar dan terus bekerja - suatu persyaratan untuk banyak program. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V595 Pointer</a> 'fReply' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 49, 52. BalasBuilder.cpp 49 <br><br><pre> <code class="cpp hljs">RPC::CallbackReply* ReplyBuilder::Reply() { fReply-&gt;Stream().InsertUInt(fStatusPosition, _HaikuErrorToNFS4(fStatus)); fReply-&gt;Stream().InsertUInt(fOpCountPosition, fOpCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fReply == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || fReply-&gt;Stream().Error() == B_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fReply; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  Seberapa sering pengembang menunjuk petunjuk sebelum memeriksa.  Diagnostik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V595</a> hampir selalu menjadi pemimpin dalam jumlah peringatan dalam suatu proyek.  Penggunaan pointer <i>fReply</i> yang <i>berbahaya</i> dalam bagian kode ini. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V595 Pointer</a> 'mq' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 782, 786. oce_queue.c 782 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oce_mq_free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct oce_mq *mq)</span></span></span><span class="hljs-function"> </span></span>{ POCE_SOFTC sc = (POCE_SOFTC) mq-&gt;parent; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">oce_mbx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbx</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbx_destroy_common_mq</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fwcmd</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mq) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  Contoh serupa.  Pointer <i>mg</i> direferensikan beberapa baris lebih awal daripada diperiksa untuk nilai nol.  Ada banyak tempat serupa dalam proyek ini.  Di beberapa tempat, menggunakan dan memeriksa pointer jauh dari satu sama lain, jadi dua contoh disertakan dalam artikel.  Selebihnya akan dapat melihat pengembang dalam laporan analisa lengkap. <br><br><h2>  Kesalahan lain-lain </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V645</a> Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_acpi_namespace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acpi_ns_device_info *device, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indenting)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> output[<span class="hljs-number"><span class="hljs-number">320</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tabs[<span class="hljs-number"><span class="hljs-number">255</span></span>] = <span class="hljs-string"><span class="hljs-string">""</span></span>; .... strlcat(tabs, <span class="hljs-string"><span class="hljs-string">"|--- "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tabs)); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (....) { uint32 type = device-&gt;acpi-&gt;get_object_type(result); <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(output, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output), <span class="hljs-string"><span class="hljs-string">"%s%s"</span></span>, tabs, result + depth); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ACPI_TYPE_INTEGER: <span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>(output, <span class="hljs-string"><span class="hljs-string">" INTEGER"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ACPI_TYPE_STRING: <span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>(output, <span class="hljs-string"><span class="hljs-string">" STRING"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... } .... } .... }</code> </pre> <br>  Perbedaan antara fungsi <i>strlcat</i> dan <i>strncat</i> tidak sepenuhnya jelas bagi orang yang baru <i>mengenal</i> deskripsi fungsi-fungsi ini.  Fungsi <i>strlcat</i> mengambil <b>ukuran seluruh buffer</b> sebagai argumen ketiga, dan fungsi <i>strncat mengambil</i> <b>ukuran ruang kosong dalam buffer</b> , yang mengharuskan penghitungan nilai yang diinginkan sebelum memanggil fungsi.  Namun pengembang sering lupa atau tidak mengetahuinya.  Melewati fungsi <i>strncat ke</i> ukuran seluruh buffer dapat menyebabkan buffer overflow, karena  fungsi akan menganggap nilai ini sebagai jumlah karakter yang diizinkan untuk disalin.  Fungsi <i>strlcat</i> tidak memiliki masalah ini, tetapi agar berfungsi dengan benar, perlu mentransfer saluran yang berakhir di terminal nol. <br><br>  Seluruh daftar tempat berbahaya dengan garis: <br><br><ul><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 104 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 107 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 110 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 113 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 118 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 119 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 120 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 123 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 126 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 129 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 132 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 135 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 138 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 141 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 144 </li><li> V645 The 'strncat' function call could lead to the 'features_string' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. VirtioDevice.cpp 283 </li><li> V645 The 'strncat' function call could lead to the 'features_string' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. VirtioDevice.cpp 284 </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'fitur_string'. </font><font style="vertical-align: inherit;">Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya. </font><font style="vertical-align: inherit;">VirtioDevice.cpp 285</font></font></li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V792</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fungsi 'SetDecoratorSettings' terletak di sebelah kanan operator '|' </font><font style="vertical-align: inherit;">akan dipanggil terlepas dari nilai operan kiri. </font><font style="vertical-align: inherit;">Mungkin, lebih baik menggunakan '||'. </font><font style="vertical-align: inherit;">DesktopListener.cpp 324</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DesktopListener</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DoublyLinkedListLinkImpl&lt;DesktopListener&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDecoratorSettings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Window* window, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BMessage&amp; settings)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> DesktopObservable::SetDecoratorSettings(Window* window, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BMessage&amp; settings) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fWeAreInvoking) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-function">InvokeGuard </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invokeGuard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fWeAreInvoking)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> changed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (DesktopListener* listener = fDesktopListenerList.First(); listener != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; listener = fDesktopListenerList.GetNext(listener)) changed = changed | listener-&gt;SetDecoratorSettings(window, settings); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> changed; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemungkinan besar, operator '|' </font><font style="vertical-align: inherit;">dan '||'. </font><font style="vertical-align: inherit;">Kesalahan seperti itu menyebabkan panggilan yang tidak perlu ke fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetDecoratorSettings</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V627</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertimbangkan untuk memeriksa ekspresi. </font><font style="vertical-align: inherit;">Argumen sizeof () adalah makro yang diperluas ke angka. </font><font style="vertical-align: inherit;">device.c 72</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCI_line_size 0x0c </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* (1 byte) cache line size in 32 bit words */</span></span></span><span class="hljs-meta"> static status_t wb840_open(const char* name, uint32 flags, void** cookie) { .... data-&gt;wb_cachesize = gPci-&gt;read_pci_config(data-&gt;pciInfo-&gt;bus, data-&gt;pciInfo-&gt;device, data-&gt;pciInfo-&gt;function, PCI_line_size, sizeof(PCI_line_size)) &amp; 0xff; .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melewati </font><font style="vertical-align: inherit;">nilai </font><i><font style="vertical-align: inherit;">0x0c</font></i><font style="vertical-align: inherit;"> ke </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ukuran</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operator </font><font style="vertical-align: inherit;">terlihat mencurigakan. </font><font style="vertical-align: inherit;">Mungkin Anda harus menghitung ukuran beberapa objek, misalnya, </font><i><font style="vertical-align: inherit;">data</font></i><font style="vertical-align: inherit;"> . </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">V562</font></a><font style="vertical-align: inherit;"> Aneh membandingkan nilai tipe bool dengan nilai 18: 0x12 == IsProfessionalSpdif (). </font><font style="vertical-align: inherit;">CEchoGals_mixer.cpp 533</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BOOL; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsProfessionalSpdif</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ECHOSTATUS_DSP_DEAD 0x12 ECHOSTATUS CEchoGals::ProcessMixerFunction(....) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( ECHOSTATUS_DSP_DEAD == IsProfessionalSpdif() ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= { Status = ECHOSTATUS_DSP_DEAD; } else { pMixerFunction-&gt;Data.bProfSpdif = IsProfessionalSpdif(); } .... }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsProfessionalSpdif</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengembalikan nilai tipe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sedangkan dalam kondisi hasil fungsi dibandingkan dengan angka </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x12</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melewatkan rilis beta Haiku pertama musim gugur yang lalu, karena sibuk merilis PVS-Studio untuk bahasa Jawa. Tetapi sifat kesalahan programmer adalah sedemikian sehingga mereka tidak pergi ke mana pun kecuali Anda mencarinya dan tidak memperhatikan kualitas kode sama sekali. Pengembang mencoba menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coverity Scan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi analisis terakhir hampir dua tahun lalu. Ini akan mengganggu pengguna Haiku. Meskipun analisis menggunakan Cakupan didirikan pada tahun 2014, ini tidak menghentikan kami dari menulis dua artikel besar dengan ulasan kesalahan pada tahun 2015 ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bagian 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bagian 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mereka yang telah membaca sampai akhir menunggu tinjauan lain dari kode Haiku yang tidak kalah volumenya dengan jenis kesalahan baru. </font><font style="vertical-align: inherit;">Laporan analisa lengkap akan dikirim ke pengembang sebelum menerbitkan ulasan kode, sehingga beberapa kesalahan dapat diperbaiki. </font><font style="vertical-align: inherit;">Untuk menghabiskan waktu di antara publikasi, saya sarankan mengunduh dan mencoba </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada proyek Anda.</font></font><br><br>  Ingin mencoba Haiku dan memiliki pertanyaan?  Pengembang Haiku mengundang Anda ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran telegram</a> . <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Svyatoslav Razmyslov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara menembak diri Anda di kaki di C dan C ++.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Haiku OS Cookbook</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461255/">https://habr.com/ru/post/id461255/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461243/index.html">Jangan pergi ke Afrika untuk berjalan-jalan: apa situasinya dengan sensor internet di Benua Hitam</a></li>
<li><a href="../id461247/index.html">50 Sumber Terbaik tentang Manajemen Produk untuk Membaca, Mendengarkan, dan Menonton</a></li>
<li><a href="../id461249/index.html">Menulis Aplikasi Android untuk Penggemar Film - Bagian 2 (Desain)</a></li>
<li><a href="../id461251/index.html">Pilihan slide yang berguna dari Julia Evans</a></li>
<li><a href="../id461253/index.html">Cara menembak diri Anda di kaki di C dan C ++. Haiku OS Cookbook</a></li>
<li><a href="../id461257/index.html">Bagaimana cara menghitung ROI dari otomatisasi uji dengan Selenium?</a></li>
<li><a href="../id461259/index.html">Pesta Penyimpanan, 8 Agustus, Moskow</a></li>
<li><a href="../id461261/index.html">Daftar periksa webinar RRC yang bermanfaat untuk produk RRC</a></li>
<li><a href="../id461265/index.html">Tentang penyalahgunaan penggunaan sistem operasi dalam proyek untuk mikrokontroler</a></li>
<li><a href="../id461267/index.html">Teknologi Intel Baru untuk Kemasan Chip</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>