<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏻 ↙️ 😡 Automatisation du contrôle des frontières au sein de l'entreprise 🏳️‍🌈 ✍🏼 👨🏼‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un autre morceau d'un manuel sur la programmation d'entreprise. 


 Les processus frontaliers sont mieux automatisés. Cela peut paraître ringard, mais...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatisation du contrôle des frontières au sein de l'entreprise</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439472/"><p>  Un autre morceau d'un manuel sur la programmation d'entreprise. </p><br><p>  Les processus frontaliers sont mieux automatisés.  Cela peut paraître ringard, mais une telle recommandation est loin d'être toujours mise en œuvre. </p><br><p>  Les situations sont encore courantes lorsque le processus traverse la frontière sans utiliser de systèmes automatisés.  Dans de nombreuses entreprises, des notes de service, applications, commandes, etc. sont utilisées.  Bien sûr, cela ne s'applique pas seulement aux frontières entre les services - les employés du même service pèchent également avec des morceaux de papier. </p><br><p>  Si un employé remet le processus à un autre sous forme papier, il est extrêmement difficile de suivre l'état de cette tâche.  La méthode élémentaire et répandue de perdre une telle tâche s'exprime dans la phraséologie «nettoyer sous le tissu».  C'est bien si l'employé empile de tels morceaux de papier sur son bureau - alors le volume des applications est au moins visible.  Théoriquement, un morceau de papier spécifique dans cette pile peut même être trouvé et déterminer combien de temps il a été dans cette file d'attente. </p><br><p> Une méthode de transfert d'un processus par e-mail est également courante.  Hélas, cette approche n'est pas bonne non plus.  Dans un certain sens, c'est encore pire qu'une pile de papiers, car  les clients de messagerie ne disposent pas de fonctionnalités suffisantes pour gérer les lettres en tant que tâches.  Une personne aura juste une montagne de lettres, ce qui est à peine possible de déterminer l'état de la file d'attente. </p><br><p>  A propos du transfert oral des tâches et ne vaut pas la peine d'en parler.  Comme on dit, a volé dans une oreille, a volé dans l'autre. <a name="habracut"></a></p><br><p>  Il y a un autre moment désagréable associé à la connaissance des frontières.  Lorsqu'une personne a transféré la tâche à une autre - sur papier, verbalement ou par e-mail - alors le porteur de tâche appartient désormais à la seconde.  D'un point de vue formel, moral et souvent technique, le premier ne peut plus se plonger dans les tâches du second.  Avec une certaine structure de subordination, vous pouvez bien sûr creuser plus profondément dans une pile de documents, mais lire le courrier électronique de quelqu'un d'autre est déjà trop.  Il est toujours possible de connaître l'état d'une ou plusieurs de vos applications, vos instances de processus, mais il est presque impossible d'évaluer l'état général de la file d'attente «à la frontière». </p><br><p>  Nous avons donc besoin d'un système automatisé de contrôle des frontières.  Il a plusieurs exigences importantes. </p><br><p>  <em>La première exigence</em> est que le système doit identifier clairement la file d'attente et les tâches qu'elle contient.  Même dans les systèmes automatisés développés, ce n'est pas toujours possible.  Si vous demandez à une personne de montrer le tour de ses tâches dans le programme, elle pourra démontrer quelque chose - il montrera une liste de documents, appliquera des filtres et triera, et vous obtiendrez une liste de tâches.  Si vous demandez au programmeur, il fera de même, non seulement dans la liste des documents, mais, très probablement, en interrogeant les données. </p><br><p>  La phrase clé ici est «si vous le demandez».  Et si vous ne demandez pas?  Pour un programmeur d'entreprise, cette simple question («et si vous ne posez pas de question?») Peut être un critère clair pour l'identification correcte de la frontière.  Si vous, en tant qu'observateur extérieur, pouvez, sans demander à un employé, voir une liste de ses tâches, alors la première exigence est remplie - la file d'attente est identifiée. </p><br><p>  Avec l'apparente simplicité de ce critère, vous constaterez que la plupart des systèmes automatisés ne le satisfont pas.  Comprendre la file d'attente car elle n'était que dans la tête d'un employé, même sous le tsar Gorokh et les notes de service, est resté dans le système automatisé.  Cette situation est familière et semble normale, car «tout le monde l'a».  Mais si vous, en tant que programmeur d'entreprise, souhaitez améliorer ce processus, vous devrez faire l'identification de la file d'attente. </p><br><p>  <em>La deuxième exigence</em> est que la file d'attente doit être décomposée avant les tâches, c'est-à-dire  à des entités simples qui nécessitent des actions compréhensibles.  Il arrive que la file d'attente semble être identifiée, mais les tâches de différents processus y sont mélangées.  Dans ce cas, la contrôlabilité et la contrôlabilité de la file d'attente est une question sérieuse. </p><br><p>  Le critère est simple: si vous, sans demander à un employé, pouvez vous dire pour chaque tâche spécifique ce qui doit être fait, alors la file d'attente est correctement décomposée.  Si la réponse est «il faut comprendre», ou «il faut y remédier d'une manière ou d'une autre», ou «n'a pas encore regardé», alors la décomposition est mauvaise.  Le système et le processus continuent de dépendre de l'employé. </p><br><p>  <em>La troisième exigence</em> est que les priorités pour l'accomplissement des tâches doivent être claires.  Le principe est le même que dans les critères précédents.  Si vous, en regardant la file d'attente de côté, voyez l'ordre des tâches, alors les priorités sont claires.  Si vous, ou les consommateurs du processus, devez interroger l'employé sur les priorités ou réinitialiser ces priorités tous les jours, la file d'attente est mal gérée. </p><br><p>  <em>La quatrième exigence</em> est que le temps passé par la tâche dans la file d'attente, c'est-à-dire  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">principe "Iceberg" est</a> appliqué.  Le temps passé est généralement lié aux priorités d'exécution, mais il existe également des conflits. </p><br><p>  Par exemple, le système de priorité est construit sur un double tri - d'abord l'importance, puis la date de la tâche.  Dans ce cas, avec un volume important de tâches importantes, il n'atteindra jamais l'important.  Si le processus est tel que la non-réalisation éternelle de certaines tâches est considérée comme la norme, alors ça va.  Mais, en règle générale, dans les processus de streaming, il est important de terminer toutes les tâches. </p><br><p>  Par conséquent, l'influence mutuelle de la priorité et du temps passé dans la file d'attente doit être surveillée.  Par exemple, après avoir spécifié le système de priorité, ajoutez un coefficient de pondération au temps passé dans la file d'attente, de sorte qu'à une certaine valeur, la tâche flotte à la surface, quelle que soit son importance. </p><br><p>  Ainsi, le critère est simple: si vous voyez que chaque tâche a du temps dans la file d'attente, alors l'exigence est remplie.  Une erreur typique est l'opinion qu'il suffit de connaître et de voir la date de l'énoncé du problème, car dans ce cas, le temps passé dans la file d'attente peut être facilement calculé.  L'automatisation est vraiment facile à faire.  Mais le calcul dans l'esprit est beaucoup plus difficile, et aucun employé sain d'esprit ne le fera.  Par conséquent, le temps passé dans la file d'attente ne sera pas pris en compte dans le travail. </p><br><p>  <em>La cinquième exigence</em> n'est pas banale, mais l'exécuteur de la tâche doit être connu.  Si le choix de l'entrepreneur est réglé par un algorithme automatisé, alors le moment où cet algorithme est exécuté doit être compris. </p><br><p>  Tant que la tâche n'a pas d'exécuteur testamentaire, elle ne sera pas résolue.  L'entrepreneur n'a pas à être affecté à chaque tâche spécifique - il suffit de comprendre que la solution à toutes les tâches de la file d'attente identifiée est attribuée à une personne spécifique. </p><br><p>  Le choix d'un entrepreneur entraîne souvent une file d'attente inactive dans les cas où l'entrepreneur dans le processus désigne non pas une personne spécifique, mais un poste ou un service.  Dans ce cas, il est recommandé que le choix de l'exécuteur testamentaire soit effectué comme une tâche distincte, que le gestionnaire ou un certain répartiteur devrait effectuer.  Bien que le choix de l'entrepreneur ne soit pas une tâche, mais un privilège, la file d'attente sera constamment bloquée à ce stade. </p><br><p>  Le critère est simple: en regardant du côté de la ligne, vous devez savoir exactement qui fera la tâche. </p><br><p>  <em>La sixième exigence</em> , des domaines supérieurs de la programmation d'entreprise: le système doit être capable de visualiser et de comparer les files d'attente de différents processus.  Dans le cas général, une telle exigence n'est jamais remplie, nous ne pouvons donc parler que du degré de conformité. </p><br><p>  Le problème, généralement, est que différentes files d'attente, tâches et processus sont différentes entités système, avec des ensembles de propriétés disjoints.  Il existe une instance de processus dans une file d'attente, mais pas dans une autre.  Une tâche a une date de production, tandis que l'autre n'en a pas.  Etc. </p><br><p>  Compte tenu d'une telle diversité d'entités, personne ne résout généralement la tâche de contrôler toutes les files d'attente «dans une seule fenêtre» - ni dans les systèmes automatisés, ni dans le contrôle manuel.  Par conséquent, l'état des files d'attente - à la fois instantanées et métriques par période - reste un mystère, ce qui réduit l'efficacité de la gestion et de l'analyse. </p><br><p>  Les systèmes de contrôle de processus qui «enchaînent» une variété de documents primaires en entités uniques sont en partie utiles.  C'est ainsi que les cartes de processus, les tâches communes et les entités d'adressage apparaissent. </p><br><p>  Mais pour un programmeur d'entreprise, hélas, cette approche n'est pas très appropriée. </p><br><p>  Premièrement, l'application de processus entraîne généralement une complication de l'automatisation - pas tant de la période de développement que des changements ultérieurs.  Le processus, avec la carte, les exécuteurs, les actions et les conditions, est en soi un objet d'automatisation, avec toutes les conséquences qui en découlent - la nécessité de maintenance, de débogage, de coordination, etc. </p><br><p>  Deuxièmement, la véritable image des processus, en règle générale, ne peut être tracée en raison du conflit «un-plusieurs».  La plupart des systèmes de dessin de processus veulent qu'un seul objet soit exécuté à la fois, même si l'objet est multiple. </p><br><p>  Par exemple, le processus d'exécution d'une demande d'achat.  Si vous dessinez une carte de bout en bout de ce processus, il s'avère que la même application s'exécute du début à la fin.  Le même fournisseur, à en juger par la mappe de processus, doit travailler avec chaque application séparément, dans le cadre de l'instance de processus. </p><br><p>  En réalité, le fournisseur ne participe pas du tout au processus de bout en bout.  Il a sa propre carte, à l'entrée de laquelle se trouve un éventail d'applications.  De plus, chaque jour - d'un volume différent (y compris, parfois, vide).  Après avoir exécuté une application spécifique à partir de cette première instance, la gestion revient à un seul processus. </p><br><p>  Un tel processus ne peut être dessiné qu'en utilisant des processus imbriqués, qui réussissent généralement, mais la simplicité et la clarté de l'algorithme sont perdues - il devient technique, compréhensible pour les programmeurs, mais ne convient pas aux personnes vivantes et à la gestion. </p><br><p>  Troisièmement, ces processus sont sujets à la bureaucratisation - ils s'efforcent de les rendre «béton armé», de les coordonner, de les imprimer et de les mettre sur l'étagère.  Cette approche contredit les principes de l'automatisation rapide et, par conséquent, ne convient pas à la programmation d'entreprise.  Les processus de bétonnage, en particulier pendant la période de débogage, sont identiques à l'impression du code de programme. </p><br><p>  Et, quatrièmement, les développeurs de mécanismes de dessin de processus, guidés uniquement par la logique du programmeur, ne fournissent pas d'outils de gestion de file d'attente.  En conséquence, analyser toutes les lignes aux frontières, les comparer les unes aux autres, en déplacement ne fonctionnera pas.  Vous devez encore inventer vos propres outils. </p><br><p>  La méthode de dessin des procédés "béton armé" peut être utilisée comme auxiliaire, il n'y aura pas beaucoup de mal.  Ou, il peut être utilisé à la fin du projet, comme un moyen de préserver les processus configurés.  Jusqu'au prochain projet. </p><br><p>  Cependant, n'oubliez pas le troisième point - la tendance à la bureaucratisation.  S'il vous semble que vous pouvez conserver le système pendant un certain temps, alors le reste des employés et des gestionnaires ont une opinion opposée: ne touchez pas à ce qui fonctionne.  Le système créé, débogué et implémenté par vous commencera à vous résister. </p><br><p>  Il est préférable d'utiliser le principe de "Tâche automatique" ou similaire lorsque votre système possède des entités qui peuvent "se rattacher" aux processus en cours et créer des tâches dans une file d'attente.  Le principe lui-même sera examiné ultérieurement. </p><br><p>  Une entité unique pour gérer les files d'attente aux frontières donne, tout d'abord, un système de coordonnées unique - les métriques de tous les processus dans les mêmes unités.  Tout processus peut être évalué - à la fois instantanément et rétrospectivement - sur la même échelle. </p><br><p>  L'évaluation instantanée peut être implémentée, par exemple, dans un panneau de contrôle de processus commun.  Pas dans la carte de processus générale traditionnelle, qui ne peut pas être vue sur un écran sans défilement, mais sous la forme d'une liste simple, même sans chiffres, utilisant un écran couleur, comme un feu de circulation.  Cela se traduira par une liste de deux colonnes: processus et statut. </p><br><p>  L'option est un peu plus intéressante - pas une liste de processus, mais une liste de points problématiques.  Le point, dans ce cas, est une tâche automatique, un certain nœud d'un processus spécifique, sans équivoque comparable à la vie.  Par exemple, «accord de contrats par un avocat».  Il suffit de lister tous les points, d'afficher leur statut et de les trier pour que les plus problématiques apparaissent en haut. </p><br><p>  Une telle évaluation instantanée de tous les processus, malgré son apparente simplicité et son évidence, est extrêmement rare.  Vous comprenez maintenant pourquoi. </p><br><p>  L'analyse de file d'attente rétrospective est un phénomène encore moins courant car la plupart des systèmes ne contiennent pas du tout les données nécessaires.  Ces données ne sont disponibles que si le principe Iceberg est pleinement utilisé, lorsque non seulement l'heure de l'état instantané est stockée, mais aussi son historique. </p><br><p>  En général, comme vous le voyez, il n'y a rien de compliqué à automatiser le contrôle des frontières.  Il est important de ne pas créer de difficultés artificiellement en utilisant des processus de «béton armé» et en ignorant les principes d'une automatisation rapide.  Les approches et les critères que vous devez utiliser lors de l'automatisation des états limites des processus sont désormais connus de vous. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439472/">https://habr.com/ru/post/fr439472/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439462/index.html">Civilisation printanière, 5/5</a></li>
<li><a href="../fr439464/index.html">VXinspect: contrôle qualité des pièces en 10 minutes</a></li>
<li><a href="../fr439466/index.html">La sonde en orbite lunaire de la NASA a pris les premières photos de la station chinoise Chang'e-4 - deux pixels de lumière</a></li>
<li><a href="../fr439468/index.html">Où mène la recherche du SCADA parfait</a></li>
<li><a href="../fr439470/index.html">L'Allemagne prévoit d'abandonner le charbon dans un avenir proche</a></li>
<li><a href="../fr439476/index.html">Argot de Cockney: histoire moderne et statut social</a></li>
<li><a href="../fr439478/index.html">C # divertissant. Cinq exemples de pauses café</a></li>
<li><a href="../fr439480/index.html">Cédez le passage, ou pourquoi votre CRM (et CRM) ralentit-il?</a></li>
<li><a href="../fr439482/index.html">devleads - motivation (non) financière</a></li>
<li><a href="../fr439484/index.html">Obtention de données d'énumération dans une perspective Automapper</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>