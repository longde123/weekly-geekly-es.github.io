<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏻 🤸🏽 🕵️ Liste insaisissable des mises à jour Windows installées 👉🏼 💆🏽 👩🏿‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vous êtes-vous déjà demandé pourquoi une liste des mises à jour Windows installées est générée? Et par quelle API pour l'obtenir? J'essaierai de donne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Liste insaisissable des mises à jour Windows installées</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467445/">  Vous êtes-vous déjà demandé pourquoi une liste des mises à jour Windows installées est générée?  Et par quelle API pour l'obtenir?  J'essaierai de donner des réponses à ces questions et à d'autres questions émergentes dans ma petite étude. <br><br><img src="https://habrastorage.org/webt/bb/rl/zc/bbrlzcws8p-tumczrzauuvx2l7w.jpeg"><br><a name="habracut"></a><br><h2>  Contexte ou comment tout a commencé. </h2><br>  Chaque année, une conférence de jeunes spécialistes est organisée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans notre entreprise</a> , où chaque participant peut résoudre le problème d'un département (une liste de sujets est proposée à l'avance).  Et le département de SPAS (maintenance des logiciels et du matériel) avait la tâche suivante, ce qui m'a intéressé, en plus il a permis de revenir à la programmation (malheureusement, pour le moment je travaille dans cette entreprise en tant que simple opérateur de NPPS). <br><br>  Auparavant, pour chaque «TO» avec l'aide de WSUS, toutes les mises à jour publiées étaient récupérées et distribuées à toutes les machines.  Des BST (bulletins de service technique) sont également apparus périodiquement, ce qui indiquait qu'il était nécessaire d'installer les mises à jour nécessaires sous la forme de packages isolés.  Par conséquent, nous accumulons des mises à jour qui ne peuvent pas être suivies dans WSUS, mais qui ne peuvent être vues que via le panneau de configuration dans la section "Mises à jour installées". <br><br><br><br><img src="https://habrastorage.org/webt/v6/9f/kb/v69fkb557stfaokhfjpoccmnuma.png" alt="Schéma de mise à jour visuelle"><br><br>  Il y a des situations où le poste de travail ou le serveur "plante" et vous devez le restaurer à partir d'une image créée il y a quelque temps.  Lors de la récupération à partir d'une image, il est possible que nous perdions les mises à jour dont nous avons besoin (qui se présentaient sous la forme de packages isolés) qui ont été installées avant que la machine ne plante.  Expliqué le plus en détail possible, car les clarifications seront déjà un secret commercial. <br><br>  C'est pourquoi l'idée est venue de créer un programme qui pourrait extraire cette liste de mises à jour (de préférence à <b>distance</b> sur le réseau local), écrire dans un fichier / base de données, comparer la liste actuelle avec un certain modèle et envoyer un message au système SCADA via l'un des protocoles - SNMP, OPC. <br><br>  Comme vous l'avez peut-être deviné d'après le titre de l'article, j'ai déjà eu du mal à choisir la méthode de récupération de la liste.  Comme d'habitude, j'ai décidé de rechercher la bonne dans le moteur de recherche, posé des questions sur les ressources spécialisées ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux</a> , pour une raison quelconque, stackoverflow en anglais n'aimait pas ma question et a dû être supprimé), mais toutes les réponses n'ont pas donné le résultat souhaité.  Par conséquent, j'ai dû le découvrir moi-même, ce qui sera discuté plus tard. <br><br><h2>  Commandes de la console </h2><br>  Commençons par un simple et profitons de ce que Windows nous offre sans utiliser d'outils tiers.  Cela peut être fait en utilisant les commandes suivantes: <br><br><ul><li>  liste wmic qfe </li><li>  systeminfo </li><li>  dism / online / get-packages </li><li>  via PowerShell: <br><br><ul><li>  <b>Obtenez le correctif</b> </li><li>  <b>Get-SilWindowsUpdate</b> (uniquement disponible dans les éditions serveur) </li><li>  <b>Get-WmiObject -Class win32_quickfixengineering</b> - via l'accès à la classe WMI win32_quickfixengineering (à propos de WMI un peu plus tard) </li></ul><br></li></ul><br><br>  Vous pouvez obtenir la liste via l'interface graphique via l'élément standard du Panneau de configuration «Ajout / Suppression de programmes», mais nous ne pouvons rien copier à partir de là.  Chaque outil du panneau de configuration est représenté par un fichier .cpl dans le dossier Windows \ System.  Les fichiers .Cpl du dossier système Windows sont automatiquement téléchargés au démarrage du panneau de configuration.  Le fichier Appwiz.cpl est responsable de l'élément de programme.  Son analyse n'a abouti à rien. <br><br>  La sortie de la commande console peut être redirigée vers un fichier puis elle peut être analysée, mais c'est faux, plus un appel de programme (selon les règles SB, cela ne fonctionnera pas) et il n'est pas question de recevoir la liste à distance.  Par conséquent, je vous suggère d'appeler simplement les commandes, de comparer le nombre de mises à jour dans chaque liste, avec la liste via le Panneau de configuration et de poursuivre notre enquête. <br><br>  Formellement, toutes les méthodes pour obtenir la liste des mises à jour peuvent être divisées en deux groupes: local et réseau. <br><br><img src="https://habrastorage.org/webt/jw/jt/nf/jwjtnfe3m0dqr_cc9q9xybhf1ka.png" alt="Méthodes locales et réseau pour obtenir des informations"><br><br>  Toutes les méthodes ont été testées sur des images système propres (Windows 7, 8, Server 2012 R2) avec des mises à jour intégrées, après chaque mise à jour via le centre de mise à jour à partir des serveurs officiels de Microsoft, une vérification supplémentaire a été effectuée.  Arrêtons-nous sur chacun d'eux plus en détail. <br><br><h2>  WUA </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WUApi</a> (API Windows Update Agent) - Utilisation de l'API Windows Update Agent.  L'option la plus évidente, dont le nom parle de lui-même.  Nous utiliserons la bibliothèque Wuapi.dll pour cela. <br><blockquote>  Remarque: ci-après, pour ma commodité, je vais insérer tous les résultats dans la liste.  Ce n'est peut-être pas rationnel, mais cela m'a paru une bonne idée. </blockquote><div class="spoiler">  <b class="spoiler_title">Exemple d'implémentation</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WUApiLib; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listUpdateHistory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//WUApi List&lt;string&gt; result = new List&lt;string&gt;(200); try { UpdateSession uSession = new UpdateSession(); IUpdateSearcher uSearcher = uSession.CreateUpdateSearcher(); uSearcher.Online = false; ISearchResult sResult = uSearcher.Search("IsInstalled=1 And IsHidden=0"); string sw = "   WUApi: " + sResult.Updates.Count; result.Add(sw); foreach (WUApiLib.IUpdate update in sResult.Updates) { result.Add(update.Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre> <br></div></div><br>  Il existe une deuxième variante de cette méthode: <b>Update Session</b> - recevoir des informations en se connectant à la session de mise à jour de Windows Update Agent (dans ce cas, nous ne travaillons pas directement avec la bibliothèque). <br><br><div class="spoiler">  <b class="spoiler_title">Exemple d'implémentation</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sessionlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pc</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    object sess = null; object search = null; object coll = null; try { sess = Activator.CreateInstance(Type.GetTypeFromProgID("Microsoft.Update.Session", pc)); search = (sess as dynamic).CreateUpdateSearcher(); int n = (search as dynamic).GetTotalHistoryCount(); int kol = 0; //coll = (search as dynamic).QueryHistory(1, n); coll = (search as dynamic).QueryHistory(0, n); result.Add("  Update.Session: " + n); foreach (dynamic item in coll as dynamic) { if (item.Operation == 1) result.Add(item.Title); kol++; //Console.WriteLine(": " + kol); } result.Add("  : " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } finally { if (sess != null) Marshal.ReleaseComObject(sess); if (search != null) Marshal.ReleaseComObject(search); if (coll != null) Marshal.ReleaseComObject(coll); } return result; }</span></span></code> </pre><br></div></div><br>  Microsoft suggère l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisation à</a> distance <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de l'API</a> . <br><br>  Les principaux inconvénients de ces deux méthodes sont qu'elles ne vous permettent pas de trouver des correctifs KB qui ne sont pas distribués via Windows Update.  Vous ne pouvez voir que ce qui s'est passé par l'agent de mise à jour lui-même, c'est-à-dire que cette option ne nous convient pas. <br><br><h2>  DISM </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Deployment Image Servicing and Management</a> est un outil de ligne de commande qui peut être utilisé pour gérer une image Windows ou pour préparer une image d'un environnement de préinstallation Windows (Windows PE).  Il remplace le gestionnaire de packages (Pkgmgr.exe), PEimg et Intlcfg. <br><br>  Cet utilitaire est utilisé pour intégrer des mises à jour, des service packs dans l'image système.  Les mises à jour Windows sont des modules distincts qui peuvent être présentés de plusieurs manières: <br><br><ul><li>  Fichiers .cab (Cabinet) - archives.  Conçu pour la distribution et l'installation à l'aide de modules Windows Update en mode automatisé; </li><li>  Fichiers .msu (Microsoft Update Standalone Package) - fichiers exécutables.  Conçu pour la distribution et l'installation par les utilisateurs eux-mêmes en mode manuel via le catalogue de mise à jour Microsoft.  En fait, il s'agit d'un ensemble packagé composé de fichiers .cab-, .xml, .txt. </li></ul><br>  La commande <b>dism / online / get-packages</b> mentionnée précédemment affiche des informations de base sur tous les packages dans l'image wim / le système actuel.  Microsoft a pris soin de nous et fournit des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">packages NuGet</a> pour une utilisation pratique de l'API. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple d'implémentation</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.Dism; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DISMlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">220</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { DismApi.Initialize(DismLogLevel.LogErrors); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dismsession = DismApi.OpenOnlineSession(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listupdate = DismApi.GetPackages(dismsession); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ab = listupdate.Count; <span class="hljs-comment"><span class="hljs-comment">//Console.WriteLine("   DISM: " + ab); string sw = "   DISM: " + ab; result.Add(sw); foreach (DismPackage feature in listupdate) { result.Add(feature.PackageName); //result.Add($"[ ] {feature.PackageName}"); //result.Add($"[ ] {feature.InstallTime}"); //result.Add($"[ ] {feature.ReleaseType}"); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br>  Le nombre de mises à jour a coïncidé avec le nombre de la liste du Panneau de configuration jusqu'à la première mise à jour via le centre de contrôle - après cela, le nombre de mises à jour est devenu moins (il était de 214, il est devenu de 209), bien que logiquement elles devraient augmenter.  Exemples de sortie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Avant la mise à jour</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Après la mise à jour</a> . <br><br>  Quelle est la raison de cela, je ne peux que spéculer - peut-être que certaines mises à jour ont remplacé les précédentes, par conséquent, le nombre est devenu moins. <br><br>  Un peu plus tard, je suis tombé sur un utilitaire du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DISM ++</a> chinois, qui n'est pas basé sur l'API DISM ou l'API DISM Core, mais les bibliothèques dont il dispose n'ont pas les méthodes dont j'ai besoin pour ouvrir, j'ai donc abandonné cette idée et j'ai poursuivi ma recherche. <br><br><h2>  WSUS </h2><br>  Windows Server Update Services ( <a href="">WSUS</a> ) est un serveur de mise à jour des systèmes d'exploitation et des produits Microsoft.  Le serveur de mise à jour se synchronise avec le site Web de Microsoft, téléchargeant des mises à jour pouvant être distribuées sur le réseau local de l'entreprise.  Encore une fois, un outil spécial conçu pour fonctionner avec les mises à jour. <br><br>  Distribué uniquement sur les éditions serveur de Windows, le support suivant a donc été déployé: <br><br><ul><li>  le système principal est Windows Server 2016; </li><li>  et grâce au système de virtualisation Hyper-V, deux systèmes d'exploitation clients ont été déployés: <br><ul><li>  Windows 8.1 </li><li>  Windows 7 </li></ul><br></li></ul><br>  Tous les systèmes sont connectés à un seul réseau local virtuel, mais <u>sans accès à Internet</u> . <br><br><div class="spoiler">  <b class="spoiler_title">Quelques conseils</b> <div class="spoiler_text">  Afin de ne pas allouer de partition de disque dur pour le nouveau système, j'utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WinNTSetup</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">j'installe</a> le système sur des disques VHD - le chargeur de démarrage, à partir de Windows 7 (éditions Professional / Ultimate), fait un excellent travail de démarrage à partir d'une image disque.  Les disques ainsi obtenus peuvent être utilisés en toute sécurité dans Hyper-V - vous tuez deux oiseaux avec une pierre à la fois.  N'oubliez pas de faire une copie du référentiel BCD à l'avance via la commande <b>bcdedit / export e: \ bcd_backup.bcd</b> . <br><br>  Je ne voulais pas configurer AD pour la distribution des mises à jour, j'ai donc simplement enregistré le chemin d'accès au serveur WSUS dans les stratégies de groupe: <br><br><img src="https://habrastorage.org/webt/j6/7f/v0/j67fv0mdw8mr8l0m73fowtmm238.png" alt="Paramètres"><br><br>  Assurez-vous de faire attention au port, en raison d'une faute de frappe (8350 au lieu de 8530), je n'ai pas pu recevoir de mises à jour sur les machines clientes, bien que tout ait été fait correctement.  En outre, les noms des éléments des stratégies de groupe sous Windows 7 et Windows 8 sont différents. <br><br>  Pour recevoir le rapport à l'aide de WSUS, vous devez en outre installer le package - le système vous en informera. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Et maintenant un petit code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      using Microsoft.UpdateServices.Administration; public static List&lt;string&gt; GetWSUSlist(params string[] list) { List&lt;string&gt; result = new List&lt;string&gt;(200); //    string namehost = list[0]; // ,     string = "example1"; string servername = list[1]; //  string = "WIN-E1U41FA6E55"; string Username = list[2]; string Password = list[3]; try { ComputerTargetScope scope = new ComputerTargetScope(); IUpdateServer server = AdminProxy.GetUpdateServer(servername, false, 8530); ComputerTargetCollection targets = server.GetComputerTargets(scope); // Search targets = server.SearchComputerTargets(namehost); // To get only on server FindTarget method IComputerTarget target = FindTarget(targets, namehost); result.Add(" : " + target.FullDomainName); IUpdateSummary summary = target.GetUpdateInstallationSummary(); UpdateScope _updateScope = new UpdateScope(); // See in UpdateInstallationStates all other properties criteria //_updateScope.IncludedInstallationStates = UpdateInstallationStates.Downloaded; UpdateInstallationInfoCollection updatesInfo = target.GetUpdateInstallationInfoPerUpdate(_updateScope); int updateCount = updatesInfo.Count; result.Add(" -   - " + updateCount); foreach (IUpdateInstallationInfo updateInfo in updatesInfo) { result.Add(updateInfo.GetUpdate().Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; } public static IComputerTarget FindTarget(ComputerTargetCollection coll, string computername) { foreach (IComputerTarget target in coll) { if (target.FullDomainName.Contains(computername.ToLower())) return target; } return null; }</span></span></code> </pre><br></div></div><br>  Comme il n'y a pas d'Internet, la situation des mises à jour se présente comme dans la capture d'écran ci-dessous: <br><br><img src="https://habrastorage.org/webt/az/gc/le/azgclepy6kznsibmilm1psoewa8.png"><br><br>  Le comportement est similaire à WUApi - si les mises à jour ne les ont pas traversées, alors ils ne le savent pas.  Par conséquent, cette méthode ne fonctionne plus. <br><br><h2>  Wmi </h2><br>  Windows Management Instrumentation ( <b>WMI</b> ) dans la traduction littérale est une boîte à outils de gestion Windows. <br><br>  WMI est une norme mise en œuvre par Microsoft pour gérer une entreprise <u>sur Internet</u> pour l'administration et la surveillance centralisées de diverses parties d'une infrastructure informatique exécutant une plate-forme Windows.  WMI est un système ouvert et unifié d'interfaces d'accès à tous les paramètres du système d'exploitation, des appareils et des applications qui y fonctionnent. <br><br>  Cette méthode vous permet de recevoir des données à la fois de la machine locale et à distance au sein du réseau local.  Pour accéder aux objets WMI, un langage de requête WMI (WQL) spécifique est utilisé, qui est l'une des variétés de SQL.  Nous recevrons la liste via la classe WMI <b>win32_quickfixengineering</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Exemple d'implémentation</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Management; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWMIlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] list</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ManagementScope Scope; string ComputerName = list[0]; string Username = list[1]; string Password = list[2]; int kol = 0; if (!ComputerName.Equals("localhost", StringComparison.OrdinalIgnoreCase)) { //    ,      //  . ConnectionOptions Conn = new ConnectionOptions(); Conn.Username = Username; Conn.Password = Password; //      «NTLMDOMAIN:»  NTLM  ,       NTLM. Conn.Authority = "ntlmdomain:DOMAIN"; Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), Conn); } else Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), null); try { Scope.Connect(); ObjectQuery Query = new ObjectQuery("SELECT * FROM Win32_QuickFixEngineering"); ManagementObjectSearcher Searcher = new ManagementObjectSearcher(Scope, Query); foreach (ManagementObject WmiObject in Searcher.Get()) { result.Add(WmiObject["HotFixID"].ToString()); //Console.WriteLine("{0,-35} {1,-40}", "HotFixID", WmiObject["HotFixID"]);// String //result.Add(); /*result.Add("{0,-17} {1}", " : ", WmiObject["Description"]); result.Add("{0,-17} {1}", ": ", WmiObject["Caption"]); result.Add("{0,-17} {1}", " : ", WmiObject["InstalledOn"]);*/ kol++; } result.Add("  " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br>  Quantitativement, tout coïncide (même après les mises à jour), il a donc été décidé d'utiliser cette méthode.  Pour la création par programme de requêtes WMI, je vous conseille d'utiliser l'utilitaire suivant - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WMI Delphi Code Creator</a> .  Grâce à elle, j'ai regardé mon code un peu différemment et j'ai décidé d'utiliser un blanc de ce programme. <br><br><h2>  XML </h2><br>  Les données obtenues par la méthode WMI ne m'ont pas arrêté et j'ai opté pour le «reverse engineering de surface».  Nous utiliserons l'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Process Monitor</a> de la collection de logiciels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sysinternals Suite</a> pour identifier les fichiers et les branches de registre utilisés lors de l'appel des commandes de la console répertoriées ci-dessus et de l'accès à l'élément «Mises à jour installées» via le panneau de configuration. <br><br>  Mon attention a été attirée sur le fichier wuindex.xml situé dans le dossier C: \ Windows \ servicing \ Packages \.  Pour l'analyser, le programme suivant a été écrit: <br><br><div class="spoiler">  <b class="spoiler_title">Exemple d'application console</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Xml; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text.RegularExpressions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">XMLviewer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> writePath = AppDomain.CurrentDomain.BaseDirectory + <span class="hljs-string"><span class="hljs-string">"XML  "</span></span> + Environment.MachineName + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(writePath)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  txt "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" XML .txt ,   "</span></span>); File.Delete(writePath); } <span class="hljs-comment"><span class="hljs-comment">//      KB Regex regex = new Regex(@"KB[0-9]{6,7}"); //Regex(@"(\w{2}\d{6,7}) ?"); //SortedSet    ,     ""     SortedSet&lt;string&gt; spisok = new SortedSet&lt;string&gt;(); XmlDocument xDoc = new XmlDocument(); string path = "C:\\Windows\\servicing\\Packages\\wuindex.xml"; //   xml xDoc.Load(path); int kol = 0; //-  int total = 0; //-    xml int total2 = 0; //-   XmlNodeList name = xDoc.GetElementsByTagName("Mappings"); foreach (XmlNode xnode in name) { //Console.WriteLine(xnode.Name); kol++; XmlNode attr = xnode.Attributes.GetNamedItem("UpdateId"); //Console.WriteLine(attr.Value); foreach (XmlNode childnode in xnode.ChildNodes) { XmlNode childattr = childnode.Attributes.GetNamedItem("Package"); total++; //Console.WriteLine(childattr.Value); MatchCollection matches = regex.Matches(childattr.Value); if (matches.Count &gt; 0) { foreach (Match match in matches) //Console.WriteLine(match.Value); spisok.Add(match.Value); } else { //Console.WriteLine("  "); } } } try { StreamWriter sw = new StreamWriter(writePath); foreach (string element in spisok) { //Console.WriteLine(element); sw.WriteLine(element); total2++; } sw.Close(); } catch (Exception ex) { Console.WriteLine(": " + ex.Message); } //Console.WriteLine("\n"); Console.WriteLine(" : " +kol); Console.WriteLine("    xml: " + total); Console.WriteLine(" KB : " + total2); Console.WriteLine("    ."); Console.Read(); } } }</span></span></code> </pre><br></div></div><br>  Malheureusement, ce fichier ne se trouve pas sur tous les systèmes et le principe de sa génération et de sa mise à jour est resté un mystère pour moi.  Par conséquent, encore une fois, cette méthode ne nous convient pas. <br><br><h2>  Cbs </h2><br>  Nous arrivons ici à ce que toutes ces méthodes sont associées.  Poursuivant l'analyse des journaux de Process Monitor, j'ai identifié les dossiers et fichiers suivants. <br><br>  Le fichier DataStore.edb situé dans le dossier <b>C: \ Windows \ SoftwareDistribution \ DataStore</b> .  Il s'agit d'une base de données qui contient l'historique de toutes les mises à jour de la version installée de Windows, y compris celles qui sont uniquement mises en file d'attente. <br><br>  Le programme ESEDatabaseView a été utilisé pour analyser le fichier DataStore.edb.  Il existe une table tbUpdates dans la base de données, dont le contenu est difficile à interpréter. <br><br><img src="https://habrastorage.org/webt/n4/1v/b0/n41vb0kmc5axymvp2gd3qax5bek.png" alt="Tableau TbUpdates dans ESEDatabaseView"><br><br>  Après avoir attiré mon attention sur le processus <b>TiWorker.exe</b> , qui était appelé chaque fois que <b>j'ouvrais</b> un élément dans le Panneau de configuration.  Il a «parcouru» de nombreux dossiers, dont l'un m'a conduit sur la bonne voie. <br><br>  <b>C: \ Windows \ SoftwareDistribution</b> est un dossier utilisé par Windows Update pour télécharger les mises à jour sur un ordinateur et les installer, et il stocke également des informations sur toutes les mises à jour précédemment installées. <br><br>  Dossier WinSxS situé dans <b>C: \ Windows \ winsxs</b> .  Il s'agit du dossier de service du système d'exploitation Windows utilisé pour stocker les versions précédemment installées des composants du système.  En raison de sa présence, il est possible de revenir à une ancienne version de la mise à jour si nécessaire. <br><br>  <b>C: \ Windows \ servicing</b> - le composant principal de tout le système, dont le nom est <b>Component-Based Servicing (CBS)</b> . <br><br>  CBS est un service basé sur des composants qui fait partie de Windows et est intégré au service Windows Update.  Contrairement au <b>service de maintenance basée</b> sur les <b>fichiers (FBS)</b> (pour les systèmes d'exploitation antérieurs à Windows Vista), dans lequel les fichiers étaient mis à jour directement dans les répertoires système, CBS a introduit toute une hiérarchie de répertoires et toute une famille (pile) de modules / bibliothèques de services. <br><br>  <b>CbsApi.dll</b> est la principale bibliothèque de support technologique CBS.  Il n'a pas de méthodes ouvertes, je ne pouvais donc pas l'utiliser directement.  Microsoft utilise TrustedInstaller.exe et TiWorker.exe pour accéder aux méthodes de cette bibliothèque et déjà via ces processus affiche les données dont nous avons besoin.  Les enregistrements sont conservés dans <b>C: \ Windows \ Logs \ CBS \ CBS.log</b> . <br><br>  Au moment de la création du prototype du programme (vous pouvez voir mai 2019 dans les captures d'écran), il n'y avait pas d'informations en russe sur CBS, mais à la fin août, il y avait un très bon article de blog - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://datadump.ru/component-based-servicing</a> .  Un article très intéressant qui a confirmé mon expérience et rassemblé les informations nécessaires.  Et plus sur le sujet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://www.outsidethebox.ms/17988/</a> <br><br><h2>  Conclusion </h2><br>  Microsoft a trop compliqué la tâche triviale d'obtenir une liste de mises à jour et a rendu ce processus pas tout à fait évident.  Tout cela est fait pour la sécurité, mais pas pour la facilité d'utilisation.  Je suis d'accord avec l'auteur de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> - la prévisibilité et la transparence ont commencé à être absentes lors de la réception des mises à jour. <br><br>  À la suite de l'étude, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">programme</a> suivant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a</a> été écrit, dont une démonstration peut être vue dans cette vidéo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SNxReaN4EKY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Le projet d'ajouter: <br><br><ol><li>  comparer la liste des mises à jour nécessaires avec celle reçue; </li><li>  envoyer le résultat via SNMP / OPC (si quelqu'un a de l'expérience, partagez les commentaires); </li><li>  organiser l'installation des mises à jour «hors ligne» manquantes à partir du dossier spécifié. </li></ol><br>  Si vous connaissez plus de méthodes pour obtenir une liste non seulement des mises à jour, mais aussi des composants supplémentaires (Adobe Flash, Acrobat Reader, etc.) ou si vous avez d'autres suggestions intéressantes, écrivez à ce sujet dans les commentaires ou dans les messages privés - je serai heureux de recevoir des commentaires .  Et participez à l'enquête pour cet article - je saurai donc si mon expérience avec le public Habrahabr sera intéressante. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467445/">https://habr.com/ru/post/fr467445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467429/index.html">Habrastatistique: explorer les sections les plus et les moins visitées du site</a></li>
<li><a href="../fr467435/index.html">Nous envoyons les rapports de l'agent Veeam Linux par courrier ou par télégramme</a></li>
<li><a href="../fr467437/index.html">MVCC dans PostgreSQL-1. L'isolement</a></li>
<li><a href="../fr467439/index.html">Pourquoi le vinyle est-il revenu et comment les services de streaming sont-ils liés à cela?</a></li>
<li><a href="../fr467443/index.html">Centre multimédia "Kodi" et projet Yocto</a></li>
<li><a href="../fr467449/index.html">Détection des vulnérabilités et évaluation de la résistance aux attaques de pirates des cartes à puce et des processeurs cryptographiques avec protection intégrée</a></li>
<li><a href="../fr467453/index.html">Résolution du problème du numéro 42 à l'aide d'un supercalculateur planétaire</a></li>
<li><a href="../fr467455/index.html">Modèle QBS pour la programmation de microcontrôleurs dans QtCreator en utilisant l'exemple des contrôleurs Milander</a></li>
<li><a href="../fr467457/index.html">Le chemin de la chirurgie au développement de jeux ou la première expérience de développement mobile sur Unity</a></li>
<li><a href="../fr467459/index.html">Comment un microcontrôleur peut lire des données à 1,6 Gbit / s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>