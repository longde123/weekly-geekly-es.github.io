<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèª ü§∏üèΩ üïµÔ∏è Liste insaisissable des mises √† jour Windows install√©es üëâüèº üíÜüèΩ üë©üèø‚Äçü§ù‚Äçüë©üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vous √™tes-vous d√©j√† demand√© pourquoi une liste des mises √† jour Windows install√©es est g√©n√©r√©e? Et par quelle API pour l'obtenir? J'essaierai de donne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Liste insaisissable des mises √† jour Windows install√©es</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467445/">  Vous √™tes-vous d√©j√† demand√© pourquoi une liste des mises √† jour Windows install√©es est g√©n√©r√©e?  Et par quelle API pour l'obtenir?  J'essaierai de donner des r√©ponses √† ces questions et √† d'autres questions √©mergentes dans ma petite √©tude. <br><br><img src="https://habrastorage.org/webt/bb/rl/zc/bbrlzcws8p-tumczrzauuvx2l7w.jpeg"><br><a name="habracut"></a><br><h2>  Contexte ou comment tout a commenc√©. </h2><br>  Chaque ann√©e, une conf√©rence de jeunes sp√©cialistes est organis√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans notre entreprise</a> , o√π chaque participant peut r√©soudre le probl√®me d'un d√©partement (une liste de sujets est propos√©e √† l'avance).  Et le d√©partement de SPAS (maintenance des logiciels et du mat√©riel) avait la t√¢che suivante, ce qui m'a int√©ress√©, en plus il a permis de revenir √† la programmation (malheureusement, pour le moment je travaille dans cette entreprise en tant que simple op√©rateur de NPPS). <br><br>  Auparavant, pour chaque ¬´TO¬ª avec l'aide de WSUS, toutes les mises √† jour publi√©es √©taient r√©cup√©r√©es et distribu√©es √† toutes les machines.  Des BST (bulletins de service technique) sont √©galement apparus p√©riodiquement, ce qui indiquait qu'il √©tait n√©cessaire d'installer les mises √† jour n√©cessaires sous la forme de packages isol√©s.  Par cons√©quent, nous accumulons des mises √† jour qui ne peuvent pas √™tre suivies dans WSUS, mais qui ne peuvent √™tre vues que via le panneau de configuration dans la section "Mises √† jour install√©es". <br><br><br><br><img src="https://habrastorage.org/webt/v6/9f/kb/v69fkb557stfaokhfjpoccmnuma.png" alt="Sch√©ma de mise √† jour visuelle"><br><br>  Il y a des situations o√π le poste de travail ou le serveur "plante" et vous devez le restaurer √† partir d'une image cr√©√©e il y a quelque temps.  Lors de la r√©cup√©ration √† partir d'une image, il est possible que nous perdions les mises √† jour dont nous avons besoin (qui se pr√©sentaient sous la forme de packages isol√©s) qui ont √©t√© install√©es avant que la machine ne plante.  Expliqu√© le plus en d√©tail possible, car les clarifications seront d√©j√† un secret commercial. <br><br>  C'est pourquoi l'id√©e est venue de cr√©er un programme qui pourrait extraire cette liste de mises √† jour (de pr√©f√©rence √† <b>distance</b> sur le r√©seau local), √©crire dans un fichier / base de donn√©es, comparer la liste actuelle avec un certain mod√®le et envoyer un message au syst√®me SCADA via l'un des protocoles - SNMP, OPC. <br><br>  Comme vous l'avez peut-√™tre devin√© d'apr√®s le titre de l'article, j'ai d√©j√† eu du mal √† choisir la m√©thode de r√©cup√©ration de la liste.  Comme d'habitude, j'ai d√©cid√© de rechercher la bonne dans le moteur de recherche, pos√© des questions sur les ressources sp√©cialis√©es ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux</a> , pour une raison quelconque, stackoverflow en anglais n'aimait pas ma question et a d√ª √™tre supprim√©), mais toutes les r√©ponses n'ont pas donn√© le r√©sultat souhait√©.  Par cons√©quent, j'ai d√ª le d√©couvrir moi-m√™me, ce qui sera discut√© plus tard. <br><br><h2>  Commandes de la console </h2><br>  Commen√ßons par un simple et profitons de ce que Windows nous offre sans utiliser d'outils tiers.  Cela peut √™tre fait en utilisant les commandes suivantes: <br><br><ul><li>  liste wmic qfe </li><li>  systeminfo </li><li>  dism / online / get-packages </li><li>  via PowerShell: <br><br><ul><li>  <b>Obtenez le correctif</b> </li><li>  <b>Get-SilWindowsUpdate</b> (uniquement disponible dans les √©ditions serveur) </li><li>  <b>Get-WmiObject -Class win32_quickfixengineering</b> - via l'acc√®s √† la classe WMI win32_quickfixengineering (√† propos de WMI un peu plus tard) </li></ul><br></li></ul><br><br>  Vous pouvez obtenir la liste via l'interface graphique via l'√©l√©ment standard du Panneau de configuration ¬´Ajout / Suppression de programmes¬ª, mais nous ne pouvons rien copier √† partir de l√†.  Chaque outil du panneau de configuration est repr√©sent√© par un fichier .cpl dans le dossier Windows \ System.  Les fichiers .Cpl du dossier syst√®me Windows sont automatiquement t√©l√©charg√©s au d√©marrage du panneau de configuration.  Le fichier Appwiz.cpl est responsable de l'√©l√©ment de programme.  Son analyse n'a abouti √† rien. <br><br>  La sortie de la commande console peut √™tre redirig√©e vers un fichier puis elle peut √™tre analys√©e, mais c'est faux, plus un appel de programme (selon les r√®gles SB, cela ne fonctionnera pas) et il n'est pas question de recevoir la liste √† distance.  Par cons√©quent, je vous sugg√®re d'appeler simplement les commandes, de comparer le nombre de mises √† jour dans chaque liste, avec la liste via le Panneau de configuration et de poursuivre notre enqu√™te. <br><br>  Formellement, toutes les m√©thodes pour obtenir la liste des mises √† jour peuvent √™tre divis√©es en deux groupes: local et r√©seau. <br><br><img src="https://habrastorage.org/webt/jw/jt/nf/jwjtnfe3m0dqr_cc9q9xybhf1ka.png" alt="M√©thodes locales et r√©seau pour obtenir des informations"><br><br>  Toutes les m√©thodes ont √©t√© test√©es sur des images syst√®me propres (Windows 7, 8, Server 2012 R2) avec des mises √† jour int√©gr√©es, apr√®s chaque mise √† jour via le centre de mise √† jour √† partir des serveurs officiels de Microsoft, une v√©rification suppl√©mentaire a √©t√© effectu√©e.  Arr√™tons-nous sur chacun d'eux plus en d√©tail. <br><br><h2>  WUA </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WUApi</a> (API Windows Update Agent) - Utilisation de l'API Windows Update Agent.  L'option la plus √©vidente, dont le nom parle de lui-m√™me.  Nous utiliserons la biblioth√®que Wuapi.dll pour cela. <br><blockquote>  Remarque: ci-apr√®s, pour ma commodit√©, je vais ins√©rer tous les r√©sultats dans la liste.  Ce n'est peut-√™tre pas rationnel, mais cela m'a paru une bonne id√©e. </blockquote><div class="spoiler">  <b class="spoiler_title">Exemple d'impl√©mentation</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WUApiLib; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listUpdateHistory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//WUApi List&lt;string&gt; result = new List&lt;string&gt;(200); try { UpdateSession uSession = new UpdateSession(); IUpdateSearcher uSearcher = uSession.CreateUpdateSearcher(); uSearcher.Online = false; ISearchResult sResult = uSearcher.Search("IsInstalled=1 And IsHidden=0"); string sw = "   WUApi: " + sResult.Updates.Count; result.Add(sw); foreach (WUApiLib.IUpdate update in sResult.Updates) { result.Add(update.Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre> <br></div></div><br>  Il existe une deuxi√®me variante de cette m√©thode: <b>Update Session</b> - recevoir des informations en se connectant √† la session de mise √† jour de Windows Update Agent (dans ce cas, nous ne travaillons pas directement avec la biblioth√®que). <br><br><div class="spoiler">  <b class="spoiler_title">Exemple d'impl√©mentation</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sessionlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pc</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    object sess = null; object search = null; object coll = null; try { sess = Activator.CreateInstance(Type.GetTypeFromProgID("Microsoft.Update.Session", pc)); search = (sess as dynamic).CreateUpdateSearcher(); int n = (search as dynamic).GetTotalHistoryCount(); int kol = 0; //coll = (search as dynamic).QueryHistory(1, n); coll = (search as dynamic).QueryHistory(0, n); result.Add("  Update.Session: " + n); foreach (dynamic item in coll as dynamic) { if (item.Operation == 1) result.Add(item.Title); kol++; //Console.WriteLine(": " + kol); } result.Add("  : " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } finally { if (sess != null) Marshal.ReleaseComObject(sess); if (search != null) Marshal.ReleaseComObject(search); if (coll != null) Marshal.ReleaseComObject(coll); } return result; }</span></span></code> </pre><br></div></div><br>  Microsoft sugg√®re l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisation √†</a> distance <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de l'API</a> . <br><br>  Les principaux inconv√©nients de ces deux m√©thodes sont qu'elles ne vous permettent pas de trouver des correctifs KB qui ne sont pas distribu√©s via Windows Update.  Vous ne pouvez voir que ce qui s'est pass√© par l'agent de mise √† jour lui-m√™me, c'est-√†-dire que cette option ne nous convient pas. <br><br><h2>  DISM </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Deployment Image Servicing and Management</a> est un outil de ligne de commande qui peut √™tre utilis√© pour g√©rer une image Windows ou pour pr√©parer une image d'un environnement de pr√©installation Windows (Windows PE).  Il remplace le gestionnaire de packages (Pkgmgr.exe), PEimg et Intlcfg. <br><br>  Cet utilitaire est utilis√© pour int√©grer des mises √† jour, des service packs dans l'image syst√®me.  Les mises √† jour Windows sont des modules distincts qui peuvent √™tre pr√©sent√©s de plusieurs mani√®res: <br><br><ul><li>  Fichiers .cab (Cabinet) - archives.  Con√ßu pour la distribution et l'installation √† l'aide de modules Windows Update en mode automatis√©; </li><li>  Fichiers .msu (Microsoft Update Standalone Package) - fichiers ex√©cutables.  Con√ßu pour la distribution et l'installation par les utilisateurs eux-m√™mes en mode manuel via le catalogue de mise √† jour Microsoft.  En fait, il s'agit d'un ensemble packag√© compos√© de fichiers .cab-, .xml, .txt. </li></ul><br>  La commande <b>dism / online / get-packages</b> mentionn√©e pr√©c√©demment affiche des informations de base sur tous les packages dans l'image wim / le syst√®me actuel.  Microsoft a pris soin de nous et fournit des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">packages NuGet</a> pour une utilisation pratique de l'API. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple d'impl√©mentation</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.Dism; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DISMlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">220</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { DismApi.Initialize(DismLogLevel.LogErrors); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dismsession = DismApi.OpenOnlineSession(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listupdate = DismApi.GetPackages(dismsession); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ab = listupdate.Count; <span class="hljs-comment"><span class="hljs-comment">//Console.WriteLine("   DISM: " + ab); string sw = "   DISM: " + ab; result.Add(sw); foreach (DismPackage feature in listupdate) { result.Add(feature.PackageName); //result.Add($"[ ] {feature.PackageName}"); //result.Add($"[ ] {feature.InstallTime}"); //result.Add($"[ ] {feature.ReleaseType}"); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br>  Le nombre de mises √† jour a co√Øncid√© avec le nombre de la liste du Panneau de configuration jusqu'√† la premi√®re mise √† jour via le centre de contr√¥le - apr√®s cela, le nombre de mises √† jour est devenu moins (il √©tait de 214, il est devenu de 209), bien que logiquement elles devraient augmenter.  Exemples de sortie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Avant la mise √† jour</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apr√®s la mise √† jour</a> . <br><br>  Quelle est la raison de cela, je ne peux que sp√©culer - peut-√™tre que certaines mises √† jour ont remplac√© les pr√©c√©dentes, par cons√©quent, le nombre est devenu moins. <br><br>  Un peu plus tard, je suis tomb√© sur un utilitaire du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DISM ++</a> chinois, qui n'est pas bas√© sur l'API DISM ou l'API DISM Core, mais les biblioth√®ques dont il dispose n'ont pas les m√©thodes dont j'ai besoin pour ouvrir, j'ai donc abandonn√© cette id√©e et j'ai poursuivi ma recherche. <br><br><h2>  WSUS </h2><br>  Windows Server Update Services ( <a href="">WSUS</a> ) est un serveur de mise √† jour des syst√®mes d'exploitation et des produits Microsoft.  Le serveur de mise √† jour se synchronise avec le site Web de Microsoft, t√©l√©chargeant des mises √† jour pouvant √™tre distribu√©es sur le r√©seau local de l'entreprise.  Encore une fois, un outil sp√©cial con√ßu pour fonctionner avec les mises √† jour. <br><br>  Distribu√© uniquement sur les √©ditions serveur de Windows, le support suivant a donc √©t√© d√©ploy√©: <br><br><ul><li>  le syst√®me principal est Windows Server 2016; </li><li>  et gr√¢ce au syst√®me de virtualisation Hyper-V, deux syst√®mes d'exploitation clients ont √©t√© d√©ploy√©s: <br><ul><li>  Windows 8.1 </li><li>  Windows 7 </li></ul><br></li></ul><br>  Tous les syst√®mes sont connect√©s √† un seul r√©seau local virtuel, mais <u>sans acc√®s √† Internet</u> . <br><br><div class="spoiler">  <b class="spoiler_title">Quelques conseils</b> <div class="spoiler_text">  Afin de ne pas allouer de partition de disque dur pour le nouveau syst√®me, j'utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WinNTSetup</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">j'installe</a> le syst√®me sur des disques VHD - le chargeur de d√©marrage, √† partir de Windows 7 (√©ditions Professional / Ultimate), fait un excellent travail de d√©marrage √† partir d'une image disque.  Les disques ainsi obtenus peuvent √™tre utilis√©s en toute s√©curit√© dans Hyper-V - vous tuez deux oiseaux avec une pierre √† la fois.  N'oubliez pas de faire une copie du r√©f√©rentiel BCD √† l'avance via la commande <b>bcdedit / export e: \ bcd_backup.bcd</b> . <br><br>  Je ne voulais pas configurer AD pour la distribution des mises √† jour, j'ai donc simplement enregistr√© le chemin d'acc√®s au serveur WSUS dans les strat√©gies de groupe: <br><br><img src="https://habrastorage.org/webt/j6/7f/v0/j67fv0mdw8mr8l0m73fowtmm238.png" alt="Param√®tres"><br><br>  Assurez-vous de faire attention au port, en raison d'une faute de frappe (8350 au lieu de 8530), je n'ai pas pu recevoir de mises √† jour sur les machines clientes, bien que tout ait √©t√© fait correctement.  En outre, les noms des √©l√©ments des strat√©gies de groupe sous Windows 7 et Windows 8 sont diff√©rents. <br><br>  Pour recevoir le rapport √† l'aide de WSUS, vous devez en outre installer le package - le syst√®me vous en informera. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Et maintenant un petit code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      using Microsoft.UpdateServices.Administration; public static List&lt;string&gt; GetWSUSlist(params string[] list) { List&lt;string&gt; result = new List&lt;string&gt;(200); //    string namehost = list[0]; // ,     string = "example1"; string servername = list[1]; //  string = "WIN-E1U41FA6E55"; string Username = list[2]; string Password = list[3]; try { ComputerTargetScope scope = new ComputerTargetScope(); IUpdateServer server = AdminProxy.GetUpdateServer(servername, false, 8530); ComputerTargetCollection targets = server.GetComputerTargets(scope); // Search targets = server.SearchComputerTargets(namehost); // To get only on server FindTarget method IComputerTarget target = FindTarget(targets, namehost); result.Add(" : " + target.FullDomainName); IUpdateSummary summary = target.GetUpdateInstallationSummary(); UpdateScope _updateScope = new UpdateScope(); // See in UpdateInstallationStates all other properties criteria //_updateScope.IncludedInstallationStates = UpdateInstallationStates.Downloaded; UpdateInstallationInfoCollection updatesInfo = target.GetUpdateInstallationInfoPerUpdate(_updateScope); int updateCount = updatesInfo.Count; result.Add(" -   - " + updateCount); foreach (IUpdateInstallationInfo updateInfo in updatesInfo) { result.Add(updateInfo.GetUpdate().Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; } public static IComputerTarget FindTarget(ComputerTargetCollection coll, string computername) { foreach (IComputerTarget target in coll) { if (target.FullDomainName.Contains(computername.ToLower())) return target; } return null; }</span></span></code> </pre><br></div></div><br>  Comme il n'y a pas d'Internet, la situation des mises √† jour se pr√©sente comme dans la capture d'√©cran ci-dessous: <br><br><img src="https://habrastorage.org/webt/az/gc/le/azgclepy6kznsibmilm1psoewa8.png"><br><br>  Le comportement est similaire √† WUApi - si les mises √† jour ne les ont pas travers√©es, alors ils ne le savent pas.  Par cons√©quent, cette m√©thode ne fonctionne plus. <br><br><h2>  Wmi </h2><br>  Windows Management Instrumentation ( <b>WMI</b> ) dans la traduction litt√©rale est une bo√Æte √† outils de gestion Windows. <br><br>  WMI est une norme mise en ≈ìuvre par Microsoft pour g√©rer une entreprise <u>sur Internet</u> pour l'administration et la surveillance centralis√©es de diverses parties d'une infrastructure informatique ex√©cutant une plate-forme Windows.  WMI est un syst√®me ouvert et unifi√© d'interfaces d'acc√®s √† tous les param√®tres du syst√®me d'exploitation, des appareils et des applications qui y fonctionnent. <br><br>  Cette m√©thode vous permet de recevoir des donn√©es √† la fois de la machine locale et √† distance au sein du r√©seau local.  Pour acc√©der aux objets WMI, un langage de requ√™te WMI (WQL) sp√©cifique est utilis√©, qui est l'une des vari√©t√©s de SQL.  Nous recevrons la liste via la classe WMI <b>win32_quickfixengineering</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Exemple d'impl√©mentation</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Management; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWMIlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] list</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ManagementScope Scope; string ComputerName = list[0]; string Username = list[1]; string Password = list[2]; int kol = 0; if (!ComputerName.Equals("localhost", StringComparison.OrdinalIgnoreCase)) { //    ,      //  . ConnectionOptions Conn = new ConnectionOptions(); Conn.Username = Username; Conn.Password = Password; //      ¬´NTLMDOMAIN:¬ª  NTLM  ,       NTLM. Conn.Authority = "ntlmdomain:DOMAIN"; Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), Conn); } else Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), null); try { Scope.Connect(); ObjectQuery Query = new ObjectQuery("SELECT * FROM Win32_QuickFixEngineering"); ManagementObjectSearcher Searcher = new ManagementObjectSearcher(Scope, Query); foreach (ManagementObject WmiObject in Searcher.Get()) { result.Add(WmiObject["HotFixID"].ToString()); //Console.WriteLine("{0,-35} {1,-40}", "HotFixID", WmiObject["HotFixID"]);// String //result.Add(); /*result.Add("{0,-17} {1}", " : ", WmiObject["Description"]); result.Add("{0,-17} {1}", ": ", WmiObject["Caption"]); result.Add("{0,-17} {1}", " : ", WmiObject["InstalledOn"]);*/ kol++; } result.Add("  " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br>  Quantitativement, tout co√Øncide (m√™me apr√®s les mises √† jour), il a donc √©t√© d√©cid√© d'utiliser cette m√©thode.  Pour la cr√©ation par programme de requ√™tes WMI, je vous conseille d'utiliser l'utilitaire suivant - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WMI Delphi Code Creator</a> .  Gr√¢ce √† elle, j'ai regard√© mon code un peu diff√©remment et j'ai d√©cid√© d'utiliser un blanc de ce programme. <br><br><h2>  XML </h2><br>  Les donn√©es obtenues par la m√©thode WMI ne m'ont pas arr√™t√© et j'ai opt√© pour le ¬´reverse engineering de surface¬ª.  Nous utiliserons l'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Process Monitor</a> de la collection de logiciels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sysinternals Suite</a> pour identifier les fichiers et les branches de registre utilis√©s lors de l'appel des commandes de la console r√©pertori√©es ci-dessus et de l'acc√®s √† l'√©l√©ment ¬´Mises √† jour install√©es¬ª via le panneau de configuration. <br><br>  Mon attention a √©t√© attir√©e sur le fichier wuindex.xml situ√© dans le dossier C: \ Windows \ servicing \ Packages \.  Pour l'analyser, le programme suivant a √©t√© √©crit: <br><br><div class="spoiler">  <b class="spoiler_title">Exemple d'application console</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Xml; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text.RegularExpressions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">XMLviewer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> writePath = AppDomain.CurrentDomain.BaseDirectory + <span class="hljs-string"><span class="hljs-string">"XML  "</span></span> + Environment.MachineName + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(writePath)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  txt "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" XML .txt ,   "</span></span>); File.Delete(writePath); } <span class="hljs-comment"><span class="hljs-comment">//      KB Regex regex = new Regex(@"KB[0-9]{6,7}"); //Regex(@"(\w{2}\d{6,7}) ?"); //SortedSet    ,     ""     SortedSet&lt;string&gt; spisok = new SortedSet&lt;string&gt;(); XmlDocument xDoc = new XmlDocument(); string path = "C:\\Windows\\servicing\\Packages\\wuindex.xml"; //   xml xDoc.Load(path); int kol = 0; //-  int total = 0; //-    xml int total2 = 0; //-   XmlNodeList name = xDoc.GetElementsByTagName("Mappings"); foreach (XmlNode xnode in name) { //Console.WriteLine(xnode.Name); kol++; XmlNode attr = xnode.Attributes.GetNamedItem("UpdateId"); //Console.WriteLine(attr.Value); foreach (XmlNode childnode in xnode.ChildNodes) { XmlNode childattr = childnode.Attributes.GetNamedItem("Package"); total++; //Console.WriteLine(childattr.Value); MatchCollection matches = regex.Matches(childattr.Value); if (matches.Count &gt; 0) { foreach (Match match in matches) //Console.WriteLine(match.Value); spisok.Add(match.Value); } else { //Console.WriteLine("  "); } } } try { StreamWriter sw = new StreamWriter(writePath); foreach (string element in spisok) { //Console.WriteLine(element); sw.WriteLine(element); total2++; } sw.Close(); } catch (Exception ex) { Console.WriteLine(": " + ex.Message); } //Console.WriteLine("\n"); Console.WriteLine(" : " +kol); Console.WriteLine("    xml: " + total); Console.WriteLine(" KB : " + total2); Console.WriteLine("    ."); Console.Read(); } } }</span></span></code> </pre><br></div></div><br>  Malheureusement, ce fichier ne se trouve pas sur tous les syst√®mes et le principe de sa g√©n√©ration et de sa mise √† jour est rest√© un myst√®re pour moi.  Par cons√©quent, encore une fois, cette m√©thode ne nous convient pas. <br><br><h2>  Cbs </h2><br>  Nous arrivons ici √† ce que toutes ces m√©thodes sont associ√©es.  Poursuivant l'analyse des journaux de Process Monitor, j'ai identifi√© les dossiers et fichiers suivants. <br><br>  Le fichier DataStore.edb situ√© dans le dossier <b>C: \ Windows \ SoftwareDistribution \ DataStore</b> .  Il s'agit d'une base de donn√©es qui contient l'historique de toutes les mises √† jour de la version install√©e de Windows, y compris celles qui sont uniquement mises en file d'attente. <br><br>  Le programme ESEDatabaseView a √©t√© utilis√© pour analyser le fichier DataStore.edb.  Il existe une table tbUpdates dans la base de donn√©es, dont le contenu est difficile √† interpr√©ter. <br><br><img src="https://habrastorage.org/webt/n4/1v/b0/n41vb0kmc5axymvp2gd3qax5bek.png" alt="Tableau TbUpdates dans ESEDatabaseView"><br><br>  Apr√®s avoir attir√© mon attention sur le processus <b>TiWorker.exe</b> , qui √©tait appel√© chaque fois que <b>j'ouvrais</b> un √©l√©ment dans le Panneau de configuration.  Il a ¬´parcouru¬ª de nombreux dossiers, dont l'un m'a conduit sur la bonne voie. <br><br>  <b>C: \ Windows \ SoftwareDistribution</b> est un dossier utilis√© par Windows Update pour t√©l√©charger les mises √† jour sur un ordinateur et les installer, et il stocke √©galement des informations sur toutes les mises √† jour pr√©c√©demment install√©es. <br><br>  Dossier WinSxS situ√© dans <b>C: \ Windows \ winsxs</b> .  Il s'agit du dossier de service du syst√®me d'exploitation Windows utilis√© pour stocker les versions pr√©c√©demment install√©es des composants du syst√®me.  En raison de sa pr√©sence, il est possible de revenir √† une ancienne version de la mise √† jour si n√©cessaire. <br><br>  <b>C: \ Windows \ servicing</b> - le composant principal de tout le syst√®me, dont le nom est <b>Component-Based Servicing (CBS)</b> . <br><br>  CBS est un service bas√© sur des composants qui fait partie de Windows et est int√©gr√© au service Windows Update.  Contrairement au <b>service de maintenance bas√©e</b> sur les <b>fichiers (FBS)</b> (pour les syst√®mes d'exploitation ant√©rieurs √† Windows Vista), dans lequel les fichiers √©taient mis √† jour directement dans les r√©pertoires syst√®me, CBS a introduit toute une hi√©rarchie de r√©pertoires et toute une famille (pile) de modules / biblioth√®ques de services. <br><br>  <b>CbsApi.dll</b> est la principale biblioth√®que de support technologique CBS.  Il n'a pas de m√©thodes ouvertes, je ne pouvais donc pas l'utiliser directement.  Microsoft utilise TrustedInstaller.exe et TiWorker.exe pour acc√©der aux m√©thodes de cette biblioth√®que et d√©j√† via ces processus affiche les donn√©es dont nous avons besoin.  Les enregistrements sont conserv√©s dans <b>C: \ Windows \ Logs \ CBS \ CBS.log</b> . <br><br>  Au moment de la cr√©ation du prototype du programme (vous pouvez voir mai 2019 dans les captures d'√©cran), il n'y avait pas d'informations en russe sur CBS, mais √† la fin ao√ªt, il y avait un tr√®s bon article de blog - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://datadump.ru/component-based-servicing</a> .  Un article tr√®s int√©ressant qui a confirm√© mon exp√©rience et rassembl√© les informations n√©cessaires.  Et plus sur le sujet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://www.outsidethebox.ms/17988/</a> <br><br><h2>  Conclusion </h2><br>  Microsoft a trop compliqu√© la t√¢che triviale d'obtenir une liste de mises √† jour et a rendu ce processus pas tout √† fait √©vident.  Tout cela est fait pour la s√©curit√©, mais pas pour la facilit√© d'utilisation.  Je suis d'accord avec l'auteur de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> - la pr√©visibilit√© et la transparence ont commenc√© √† √™tre absentes lors de la r√©ception des mises √† jour. <br><br>  √Ä la suite de l'√©tude, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">programme</a> suivant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a</a> √©t√© √©crit, dont une d√©monstration peut √™tre vue dans cette vid√©o: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SNxReaN4EKY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Le projet d'ajouter: <br><br><ol><li>  comparer la liste des mises √† jour n√©cessaires avec celle re√ßue; </li><li>  envoyer le r√©sultat via SNMP / OPC (si quelqu'un a de l'exp√©rience, partagez les commentaires); </li><li>  organiser l'installation des mises √† jour ¬´hors ligne¬ª manquantes √† partir du dossier sp√©cifi√©. </li></ol><br>  Si vous connaissez plus de m√©thodes pour obtenir une liste non seulement des mises √† jour, mais aussi des composants suppl√©mentaires (Adobe Flash, Acrobat Reader, etc.) ou si vous avez d'autres suggestions int√©ressantes, √©crivez √† ce sujet dans les commentaires ou dans les messages priv√©s - je serai heureux de recevoir des commentaires .  Et participez √† l'enqu√™te pour cet article - je saurai donc si mon exp√©rience avec le public Habrahabr sera int√©ressante. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467445/">https://habr.com/ru/post/fr467445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467429/index.html">Habrastatistique: explorer les sections les plus et les moins visit√©es du site</a></li>
<li><a href="../fr467435/index.html">Nous envoyons les rapports de l'agent Veeam Linux par courrier ou par t√©l√©gramme</a></li>
<li><a href="../fr467437/index.html">MVCC dans PostgreSQL-1. L'isolement</a></li>
<li><a href="../fr467439/index.html">Pourquoi le vinyle est-il revenu et comment les services de streaming sont-ils li√©s √† cela?</a></li>
<li><a href="../fr467443/index.html">Centre multim√©dia "Kodi" et projet Yocto</a></li>
<li><a href="../fr467449/index.html">D√©tection des vuln√©rabilit√©s et √©valuation de la r√©sistance aux attaques de pirates des cartes √† puce et des processeurs cryptographiques avec protection int√©gr√©e</a></li>
<li><a href="../fr467453/index.html">R√©solution du probl√®me du num√©ro 42 √† l'aide d'un supercalculateur plan√©taire</a></li>
<li><a href="../fr467455/index.html">Mod√®le QBS pour la programmation de microcontr√¥leurs dans QtCreator en utilisant l'exemple des contr√¥leurs Milander</a></li>
<li><a href="../fr467457/index.html">Le chemin de la chirurgie au d√©veloppement de jeux ou la premi√®re exp√©rience de d√©veloppement mobile sur Unity</a></li>
<li><a href="../fr467459/index.html">Comment un microcontr√¥leur peut lire des donn√©es √† 1,6 Gbit / s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>